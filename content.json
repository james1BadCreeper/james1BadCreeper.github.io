{"meta":{"title":"james1 çš„åšå®¢","subtitle":"","description":"james1","author":"james1BadCreeper","url":"https://james1badcreeper.github.io","root":"/"},"pages":[{"title":"","date":"2024-06-11T13:06:29.183Z","updated":"2024-06-11T13:06:29.183Z","comments":true,"path":"404.html","permalink":"https://james1badcreeper.github.io/404.html","excerpt":"","text":"æ— ç›¸å¹½é—­è’™è”½äº†ä½ çš„åŒçœ¼ã€‚å¾ˆæŠ±æ­‰ï¼Œæ‚¨è®¿é—®çš„é¡µé¢ä¸¢å¤±äº†ã€‚å¯èƒ½è¾“å…¥åœ°å€æœ‰è¯¯æˆ–è¯¥åœ°å€å·²è¢«ç§»åŠ¨æˆ–åˆ é™¤ã€‚å¦‚æœæ‚¨è®¤ä¸ºæ‚¨è¾“å…¥çš„åœ°å€æ²¡æœ‰é—®é¢˜ï¼Œå¯ä»¥é€šè¿‡ä¸‹æ–¹çš„è¯„è®ºæ¥å‘Šè¯‰æˆ‘ä»¬æ˜¯å“ªé‡Œå‘ç”Ÿäº†çµå¼‚äº‹ä»¶ã€‚ä»¥ä¸‹æ˜¯å¯èƒ½å¯¼è‡´ 404 çš„åŸå› ï¼šæˆ‘ä»¬äº 2023/10/3 å–æ¶ˆäº†æ–‡ç« ç»å¯¹è·¯å¾„çš„å¹´ä»½ï¼Œå¦‚æœæ‚¨è¾“å…¥çš„åœ°å€å¸¦æœ‰å¹´ä»½ï¼Œé‚£ä¹ˆåˆ é™¤å®ƒä»¬å°±åº”è¯¥èƒ½æ­£å¸¸è®¿é—®äº†ã€‚ æ— å†…é¬¼ï¼Œæç‚¹å›¾ç‰‡é‰´èµï¼Œä¸º bing æ¯æ—¥å£çº¸"},{"title":"","date":"2024-06-11T13:06:29.207Z","updated":"2024-06-11T13:06:29.207Z","comments":true,"path":"about/index.html","permalink":"https://james1badcreeper.github.io/about/index.html","excerpt":"","text":"æˆ‘ä»¬ç»ˆå°†ä»æ—¶å…‰å½’æ¥ï¼Œä¸ºå®‡å®™å¥å“é—å¿˜çš„é•‡é­‚æ›²ã€‚ æ¬¢è¿æ‚¨ï¼Œæ—…è¡Œè€…ï¼ å¸Œæœ›æ‚¨å¯ä»¥åœ¨è¿™ä¸ªç®€é™‹çš„åœ°æ–¹åº¦è¿‡ä¸€ä¸ªæ„‰å¿«çš„å¤œæ™š~ åŠ¨æ€å‹é“¾å…³äº è¿™æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘åœ¨å“ªé‡Œï¼Ÿ æˆ‘ä¹Ÿä¸çŸ¥é“ã€‚ è¿™é‡Œæ˜¯ james1BadCreeper çš„åšå®¢ã€‚å…è´¹æ­å»ºï¼Œæä¸å¯é ã€‚ ä¸»è¦è®°å½•å¥‡æ€ªçš„ä¸œè¥¿ã€‚å½“ä¸œè¥¿å¥‡æ€ªåˆ°ä¸€å®šç¨‹åº¦ï¼Œå°±ä¸å†æ˜¯ä¸œè¥¿äº†ã€‚ å‚æ•°å¦‚ä¸‹ï¼š Key Value Generator Hexo Theme Volantis Wikiï¼ŒRepo Deploy on Github Pages CDN jsdelivr å›¾åºŠ è·¯è¿‡å›¾åºŠ &amp; èšåˆå›¾åºŠ å…¬å¼æ¸²æŸ“ KaTeX\\KaTeXKATEâ€‹X ä½ æ˜¯ä»€ä¹ˆï¼Ÿ ä¸€åªè‹¦åŠ›æ€•ï¼Œè€Œä¸”æ˜¯æ¥è‡ªè¿œå¤çš„æœºå™¨äººã€‚ ä¸€åæ™®é€šçš„ OIerï¼Œå°±è¯»äºå¤§è¿å¸‚ç¬¬äºŒåå››ä¸­å­¦ã€‚ æ‚¨å¯ä»¥å«æˆ‘ james1ï¼Œæˆ–è€…ä¹Ÿå¯ä»¥å«æˆ‘ iznomiaã€‚ æˆåˆ†å¯èƒ½æ¯”è¾ƒå¤æ‚ï¼Œäººå¯èƒ½æ¯”è¾ƒæŠ½è±¡ã€‚ 16personalities äººæ ¼ç±»å‹ éŸ³ä¹æ¸¸æˆå…¶å®ƒè¿™é‡Œæ”¾ä¸€ä¸ªæ­Œå•ï¼ˆåˆ«é—®æˆ‘ä¸ºä»€ä¹ˆæ²¡æœ‰é“¾æ¥ï¼Œè¿™æ˜¯ LX å¯¼å‡ºçš„ txtï¼‰ï¼Œåº”è¯¥å¯ä»¥çœ‹å‡ºä¸ªå¤§æ¦‚ï¼Œä¸å®šæœŸæ›´æ–°ã€‚ å·²ä¸ºæ‚¨æŠ˜å è¿‡é•¿çš„å†…å®¹ æ›²åè‰ºæœ¯å®¶ä¸“è¾‘10000ColBreakz10000å®‰ä¹ (Liveç‰ˆ)å¼ æ°ã€åæ™¨å®‡å£°ç”Ÿä¸æ¯Â·å®å²›å­£ ç¬¬8æœŸå½©è™¹å±±æ–‡é›€å½©è™¹å±±è¾¾æ‹‰å´©å§ (Live)å‘¨æ·±æ­Œæ‰‹Â·å½“æ‰“ä¹‹å¹´ ç¬¬8æœŸå¤§æ¢¦æƒ³å®¶TFBOYSå¤§æ¢¦æƒ³å®¶ç™»ç¥ (GODS)NewJeansç™»ç¥ (GODS)å†¬ã®èŠ±å®®æœ¬æµ©æ¬¡å†¬ã®èŠ±æ–—ç‰›åæ™¨å®‡æ–°ä¸–ç•ŒNEW WORLDäºŒå‘ç®”Bo Peepã€CDYäºŒå‘ç®”é£è¡ŒæŒ‡æŒ¥å®¶åæ™¨å®‡ã€å’Œå¹³ç²¾è‹±é£è¡ŒæŒ‡æŒ¥å®¶é£ä¹‹æµ·åæ™¨å®‡é£ä¹‹æµ·ç–¯äººé™¢åæ™¨å®‡æ–°ä¸–ç•ŒNEW WORLDçˆ¶äº²ç­·å­å…„å¼Ÿçˆ¶äº²æ­Œè€…Â·æ—¶é—´ç«¥è¯å‡‘è¯—ã€ä¸‰ä½“ã€‘æ­Œè€…Â·æ—¶é—´ç«¥è¯å­¤å‹‡è€… (Live)å¼ æ°æ—¶å…‰éŸ³ä¹ä¼šè€å‹è®° ç¬¬6æœŸå¯’é¸¦å°‘å¹´åæ™¨å®‡å¯’é¸¦å°‘å¹´å¥½æƒ³çˆ±è¿™ä¸ªä¸–ç•Œå•Šåæ™¨å®‡æ–°ä¸–ç•ŒNEW WORLDçº¢æ—¥æå…‹å‹¤çº¢æ—¥èŠ±ã«äº¡éœŠãƒ¨ãƒ«ã‚·ã‚«èŠ±ã«äº¡éœŠè®°å¿†å•†åº—å‘¨æ·±åæ·±ä»£è¯å‡è¡Œåƒ§ (Live)åæ™¨å®‡æ­Œæ‰‹2018 ç¬¬10æœŸéª„å‚²çš„å°‘å¹´å—å¾åŒ—æˆ˜NZBZéª„å‚²çš„å°‘å¹´ä»Šã€æ­©ãå‡ºã™å›ã¸ã€‚ (çŒ®ç»™æ­¤åˆ»è¿ˆæ­¥å‰è¡Œçš„ä½ ã€‚)CeuiPCã‚²ãƒ¼ãƒ  ã„ã¾ã™ããŠå…„ã¡ã‚ƒã‚“ã«å¦¹ã ã£ã¦ã„ã„ãŸã„! ãƒœãƒ¼ã‚«ãƒ«ã‚¢ãƒ«ãƒãƒ ä¹é¾™èµç¾¤æ˜Ÿçƒ­é—¨åè¯­259æ‹å¿ƒ-Rest in Peace-rionosæ‹å¿ƒ-Rest in Peace-è¼ªå»»å±±æœ¬ç¾ç¦°å­ã•ãã‚‰ã€ã‚‚ã‚†ã€‚-as the Nightâ€™s, Reincarnation- ãƒŸãƒ¥ãƒ¼ã‚¸ãƒƒã‚¯ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³è£¸ã®å‹‡è€… (èµ¤èº«å‹‡è€…)Vaundyè£¸ã®å‹‡è€…é¢å£è€…G.E.M.é‚“ç´«æ£‹é¢å£è€…ç§’é‡ã‚’å™›ã‚€ãšã£ã¨çœŸå¤œä¸­ã§ã„ã„ã®ã«ã€‚æ­£ã—ã„å½ã‚Šã‹ã‚‰ã®èµ·åºŠæœ«æ—¥é£èˆ¹å”æ±‰éœ„ã€å‘¨æ·±æœ«æ—¥é£èˆ¹é‚£äº›æˆ‘å°šæœªçŸ¥é“çš„ç¾ä¸½åæ™¨å®‡é‚£äº›æˆ‘å°šæœªçŸ¥é“çš„ç¾ä¸½å—æ–¹æ–‡é›€çœ‹é£æ™¯çš„äººå¹³å‡¡ä¹‹è·¯æœ´æ ‘çŒæˆ·æ˜Ÿåº§æ™®é€šåˆ°ä¸æ™®é€šçš„äººç”Ÿåæ™¨å®‡æ™®é€šåˆ°ä¸æ™®é€šçš„äººç”Ÿé½å¤©åæ™¨å®‡é½å¤©èµ·é£äº†å‘¨æ·±èµ·é£äº†é’æ˜¥ä¿®ç‚¼æ‰‹å†ŒTFBOYSé’æ˜¥ä¿®ç‚¼æ‰‹å†Œç¾¤é’YOASOBIç¾¤é’äººæ˜¯_å‘¨æ·±äººæ˜¯_å¦‚æœè èèµ›ä¸œã€Bo Peepå¦‚æœæ€æ­»é‚£ä¸ªçŸ³å®¶åº„äººä¸‡èƒ½é’å¹´æ—…åº—ä¸‡èƒ½é’å¹´æ—…åº— åŒåä¸“è¾‘æ²™æ¼ éª†é©¼å±•å±•ä¸ç½—ç½—æ²™æ¼ éª†é©¼å±±æµ· (Live)åæ™¨å®‡æ­Œæ‰‹2018 ç¬¬9æœŸæ·±æµ·å°‘å¥³ã®ã¶ãªãŒã€ã‚†ã†ã‚†voices in a bottle ï½æµ·ã‚’è¶Šãˆå±Šã„ãŸæ­Œå£°ï½ç¥æ ‘ (Live)åæ™¨å®‡æ­Œæ‰‹Â·å½“æ‰“ä¹‹å¹´ ç¬¬6æœŸèœƒæ¥¼å‘¨æ·±åæ·±ä»£è¯æ—¶é—´ä¹‹æµ·å‘¨æ·±å¼‚äººä¹‹ä¸‹ ç”µè§†å‰§åŸå£°å¸¦ä¸–ç•Œæ˜¯ä¸ªåŠ¨ç‰©å›­åæ™¨å®‡å¼‚ç±»åŒæˆªæ£ (Live)åæ™¨å®‡æ­Œæ‰‹2018 ç¬¬6æœŸæ°´æ‰‹éƒ‘æ™ºåŒ–ç§æˆ¿æ­Œæ­»ã«ã‚†ãå­£ç¯€ã®ãã¿ã¸éº»æå‡†ã€ã‚„ãªããªãæ­»ã«ã‚†ãå­£ç¯€ã®ãã¿ã¸å¡‘æ–™è¢‹ä¹”æ‰ç¼çº«æœºä¹é˜Ÿ ç”µå½±åŸå£°éŸ³ä¹å¥¹è¯´æ—ä¿Šæ°å¥¹è¯´ æ¦‚å¿µè‡ªé€‰è¾‘ç½‘ç»œçƒ­é—¨ç§‘æ™®å·¥ä½œè€…é‰´å®šBo Peepç½‘ç»œçƒ­é—¨ç§‘æ™®å·¥ä½œè€…é‰´å®šæˆ‘ç®¡ä½ åæ™¨å®‡å¼‚ç±»æ— æ‹˜æ—ä¿Šæ°æ— æ‹˜å¿ƒæ‹æ•°#0822Hâ–³Gå£° ~VOCALOID Cover Album~æ–°ä¸–ç•Œåæ™¨å®‡æ–°ä¸–ç•ŒNEW WORLDæ˜Ÿç©ºRichard ClaydermanRichard Claydermanæ˜Ÿæ˜Ÿç‚¹ç¯éƒ‘æ™ºåŒ–æ˜Ÿæ˜Ÿç‚¹ç¯æ˜Ÿã®å¢“æ¨™éº»æå‡†ã€ã‚„ãªããªãæ˜Ÿã®å¢“æ¨™å˜˜æœˆãƒ¨ãƒ«ã‚·ã‚«å‰µä½œå¯»åæ™¨å®‡å¯»çƒŸç«é‡Œçš„å°˜åŸƒåæ™¨å®‡çƒŸç«é‡Œçš„å°˜åŸƒå¤œèˆªæ˜Ÿ (Night Voyager)ä¸æ‰ã€ä¸‰ä½“å®‡å®™æˆ‘çš„ä¸‰ä½“ä¹‹ç« åŒ—æµ·ä¼  åŸå£°éŸ³ä¹é›†å¤œç©ºä¸­æœ€äº®çš„æ˜Ÿé€ƒè·‘è®¡åˆ’ä¸–ç•Œå¤œæœªå¤®è°­å’éºŸéš¾èˆéš¾åˆ†å¤œè¡Œãƒ¨ãƒ«ã‚·ã‚«å¤œè¡Œå¤œä¸­ã®ã‚­ã‚¹ãƒŸãšã£ã¨çœŸå¤œä¸­ã§ã„ã„ã®ã«ã€‚ä¼¸ã³ä»•è‰æ‡²ã‚Šã¦æš‡ä¹ã„å¤œã«é§†ã‘ã‚‹YOASOBIå¤œã«é§†ã‘ã‚‹å¼‚é‚¦äººã®åˆƒä½è—¤ç›´ç´€ã‚¹ãƒˆãƒ¬ãƒ³ãƒ‚ã‚¢-æ— çš‡åˆƒè°­-ã‚ªãƒªã‚¸ãƒŠãƒ«ãƒ»ã‚µã‚¦ãƒ³ãƒ‰ãƒˆãƒ©ãƒƒã‚¯å¼‚ç±»åæ™¨å®‡å¼‚ç±»æ°¸ä¸ç†„ç­çš„ç«ç„°åæ™¨å®‡ã€å’Œå¹³ç²¾è‹±æ°¸ä¸ç†„ç­çš„ç«ç„°æ°¸æ’å­¤ç‹¬å‘¨æ·±ä¸‰ä½“ ç”µè§†å‰§å½±è§†åŸå£°å¸¦è¿½å…‰è€… (Live)å¼ æ°æ—¶å…‰éŸ³ä¹ä¼šè€å‹è®° ç¬¬7æœŸæœ€åä¸€é¦–æ­Œè¿ªå…‹ç‰›ä»”å¿˜è®°æˆ‘è¿˜æ˜¯å¿˜è®°ä»–A Historic ReckoningBackground Music LabEpic Cinematic Background (Heroic, Inspiring, Dramatic Trailer Music)A Historic ReckoningRubricã€Kyle PrestonA Historic ReckoningA New DayMark Petrie1M1 Music Volume 1AbiogenesisJuggernaut.AD:PIANO VII -Alternative-After You SleeprionosAfter You SleepAge of WondersBrunuhVilleAge of WondersaLIEzç‘è‘µ(mizuki)ã€SawanoHiroyuki[nZk]A/ZAmerican IdiotGreen DayAmerican Idiot (Deluxe)AnimalsMartin GarrixHardwell Presents Revealed Volume 4AnomalyLights &amp; MotionDear AvalancheAnother WorldRazorrekkerAnother WorldApolloThomas BergersenHumanity - Chapter IVArise (Trailer Music)Mark PetrieEpic Action AdventureBad Apple!! feat. nomicoã®ã¿ã“EXSERENSBe What You Wanna BeDarinDarinBecause of YouKelly ClarksonBecause Of YouBefore I Riseã‚„ãªããªãã€éº»æå‡†Before I RiseBelieve In Myself (ç›¸ä¿¡æˆ‘è‡ªå·±)EDGE of LIFEEDGE of LIFEBlackheartTwo Steps From Hellã€Thomas BergersenSkyworldBreatheTwo Steps From HellLegend OriginsBrotherhoodJohn DreamerBrotherhoodCalamityTwo Steps From HellLegendCelestialEd SheeranCelestialChildren of the SunThomas Bergersenã€Merethe SoltvedtChildren Of The SunCollapsing WorldLightscapeCollapsing WorldConnected SkyKARUTBlue Archive Original Soundtrack Vol.1 ~Longing for the Memorable Days ~Constant ModeratoãƒŸãƒ„ã‚­ãƒ¨Blue Archive Original Soundtrack Vol.1 ~Longing for the Memorable Days ~Croatian Rhapsody (Arr. Bratos &amp; Kazinoti)Maksimã€NikÅ¡a BratoÅ¡ã€Remi Kazinotiã€Craig Pruessã€OrchestraThe Piano PlayerDamnationReally Slow MotionSupremacyDemonsImagine DragonsTransports en communDepend on meVIXXDepend on me(åˆå›é™å®šç›¤A)DragonheartedTryHardNinjaDragonheartedDragonwingTwo Steps From Hellã€Thomas BergersenDragonDream ChasersFuture World MusicReign of VengeanceDream It PossibleDelaceyDream It PossibleEl DoradoTwo Steps From Hellã€Thomas BergersenSkyworldEmerald PrincessTwo Steps From Hellã€Thomas BergersenDragonEmpire Of AngelsTwo Steps From HellEternalEndless WarWithin TemptationResist (Extended Deluxe)Energetic Indie RockKLM MusicKlm Music, Vol. 8EntropyNick MurrayAeonExperienceLudovico Einaudiã€Daniel Hopeã€I Virtuosi ItalianiRoyalcoreExtinctionBrand X MusicBrand X Music Vol. 11Extreme Ways (Bourneâ€™s Ultimatum)MobyThe Bourne UltimatumFadedAlan WalkerFadedFake Love (Orchestral Version)MDPOriginsFallen KingdomTryHardNinjaFallen KingdomFalling AgainNurkoã€RoniitFalling Again (feat. Roniit)Far Beyond the MountainsPeter RoeFrozen WildsFinal Days of RomeTwo Steps From HellUnleashedFind the PiecesTryHardNinjaPick a UniverseFool For YouKASTRAFool For YouFool For You (VIP Mix)KASTRAFool For You (VIP Mix)For The WinTwo Steps From Hellã€Thomas BergersenSkyworldForever (Epic Edition)PIKASONICForever (Epic Edition)Fractures (Trivecta Remix)ILLENIUMã€Nevveã€TrivectaAwake (Remixes)Freedom Is OursEpic ScoreVengeance - ES033Future FunkVarienPick Your Poison Vol. 01Go SoloTom RosenthalThe Pleasant TreesHeâ€™s a PirateKlaus BadeltPirates of the Caribbean: The Curse of the Black PearlHellbreakerSub Pub MusicEquilibriumHotel California (2013 Remaster)EaglesThe Studio Albums 1972-1979 (2013 Remaster)HumanityThomas Bergersenã€Audrey CallahanHumanity - Chapter IIâ€™m A Starå‘¨æ·±Iâ€™m A Star (ç”µå½±ã€Šæ˜Ÿæ„¿ã€‹è®¸æ„¿æ˜Ÿä¹‹æ­Œ)IcarusIvan TorrentIcarusImmortalThomas BergersenIllusionsImpossibleTwo Steps From HellUnleashedIn the EndTommee Profittã€Jung Youthã€FleurieIN THE END (Cinematic Cover)Into YouMatisse &amp; Sadkoã€Hanne MjÃ¸enInto YouIt Wouldnâ€™t Be RightChasing JonahPreludeItâ€™s My LifeBon JoviCrushLast Reunion (Epicmusicvn Series)Peter RoeLast Reunion (Epicmusicvn Series)Last TransmissionNINJA TRACKSA Million Stars FallingLegends Never DieAgainst the CurrentLegends Never DieLemonç±³æ´¥ç„å¸«LemonLiberatorsEpic ScoreVengeance - ES033Light Yearséº»æå‡†ã€ã‚„ãªããªãLight YearsLost FlowersrionosLost FlowersLove The Way You LieEminemã€RihannaRecovery (Explicit)Luminous memoryãƒŸãƒ„ã‚­ãƒ¨( â€¢ Ì€Ï‰â€¢Ì )âœ§MILABOãšã£ã¨çœŸå¤œä¸­ã§ã„ã„ã®ã«ã€‚æœ—ã‚‰ã‹ãªçš®è†šã¨ã¦ä¸æœMinecraft Pigstep (Remix)FlyxTheKidMinecraft PigstepMinecraft StyleTryHardNinjaMinecraft StyleMonody (Radio Edit)TheFatRatã€Laura BrehmMonody (Radio Edit)MonstersTimefliesã€Katie SkyAfter HoursMountain CallThomas BergersenHumanity - Chapter IMythTwo Steps From Hellã€Thomas BergersenMythNevadaVicetoneã€Cozi ZuehlsdorffNevadaNever Back DownTwo Steps From HellBattlecryNever Give up on Your DreamsTwo Steps From HellUnleashedNew LightMark Petrie1M1 Music Volume 8On My OwnAshes RemainWhat Iâ€™ve BecomeOnly My RailgunfripSideonly my railgunOther WorldsReally Slow MotionOther WorldsothersideLena RaineMinecraft: Caves &amp; Cliffs (Original Game Soundtrack)Out of Time (Sagan Remix)Saganã€Shane 54ã€Cubicoreã€Eric LumiereOut of TimePastel Subliminala_hisacolorsPitcairn StoryMichael ConnGlobe Trekker - EpicPromise of HopeInside Tracksã€Liquid CinemaMusic Featured in â€œAladdinâ€ TrailerRadiantå¡å£¬å”±ç‰‡-MSRã€Mary ClareRadiantRenegadesX AmbassadorsVHSRequiem For A DreamJennifer ThomasIlluminationResuscitated Hopeã‚³ãƒŸãƒãƒªã‚µResuscitated Hope/unityRevengeCaptainSparklezRevengeRicochetRob GasserRicochetRISEThe Glitch Mobã€Makoã€The Word AliveRISERise - Epic MusicJohn DreamerRise - Epic MusicRise of the EmpireCharles Ian EvansHeroesRising SunCody SorensonRising SunRun FreeTwo Steps From HellUnleashedScarborough FairSarah BrightmanThe Very Best of Sarah Brightman 1990-2000Season 2019è‹±é›„è”ç›ŸSeason 2019SkyfireLiquid CinemaLumina Epic Emotional TrailersSpecial OpsSilver ScreenUnder SiegeStallionThomas BergersenVanquishStar SkyTwo Steps From HellBattlecrySTAR WALKINâ€™ (League of Legends Worlds Anthem)Lil Nas XSTAR WALKINâ€™ (League of Legends Worlds Anthem)Strength of a Thousand MenTwo Steps From HellArchangelsummertimecinnamonsã€evening cinemasummertimeTake Back the NightTryHardNinjaIn Real LifeTake Me HandCÃ©cile CorbelTake Me HandTh3 Awak3n1ngIvan Torrentâ€œTh3 Awak3n1ngâ€The Black DepthsReally Slow MotionValiant RecordThe DawnDreamtaleBeyond Reality (Japanese Edition)The New York NightfallPosition MusicVolume 55 Epic Hip-HopThe One to SurviveHidden CitizensObsidianThe PromiseGlobusShire Music Greatest Hits VOL 2:Lost QueenThe UntoldSecession StudiosThe UntoldThe Untold IISecession Studiosã€Greg DombrowskiThe Untold IIThe WinnerAPM MusicVideo Game Music (As Featured In FIFA Manager 13)Time Will Remember UsEpic ScoreEpic Action &amp; Adventure Vol. 6To GloryTwo Steps From HellInvincibleUmbrella (Matte Remix)Matteã€Ember IslandUmbrella (Matte Remix)unityã‚³ãƒŸãƒãƒªã‚µResuscitated Hope/unityVictoryTwo Steps From HellBattlecryViva La VidaColdplayViva La Vida or Death and All His FriendsWhisper of HopeGothic StormEpic Emotional PianoWhite Spelléº»æå‡†ã€ã‚„ãªããªãWhite SpellWinning Together1 Revolution MusicFamily Oriented &amp; Feel GoodWolf KingTwo Steps From HellBattlecryYouApproaching NirvanaYOUã‚¢ã‚¤ãƒ­ãƒ‹(ã‚«ãƒãƒ¼)majikoContrastã‚¢ã‚¹ã‚¿ãƒ­ã‚¢éˆ´æœ¨ã“ã®ã¿PCã‚²ãƒ¼ãƒ ã€Summer Pockets REFLECTION BLUEã€ã‚ªãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°ãƒ†ãƒ¼ãƒã€Œã‚¢ã‚¹ã‚¿ãƒ­ã‚¢ã€ã‚ã¦ã‚‚ãªãAimerã‚ã¦ã‚‚ãªãã‚¢ãƒ«ã‚«ãƒ†ã‚¤ãƒ«éˆ´æœ¨ã“ã®ã¿Shake Up!ã„ã‚ã¨ã‚Šã©ã‚Šã®ä¸–ç•Œå¿ç´…ã„ç³ã«æ˜ ã‚‹ã‚»ã‚«ã‚¤ ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚µã‚¦ãƒ³ãƒ‰ãƒˆãƒ©ãƒƒã‚¯ ãƒ—ãƒ©ã‚¹ã‚¨ãƒŸãƒ¤_UBW Extendedæ·±æ¾¤ç§€è¡ŒFate/stay night [Unlimited Blade Works] ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚µã‚¦ãƒ³ãƒ‰ãƒˆãƒ©ãƒƒã‚¯ IIãã¿ã®æ¨ªé¡”éº»æå‡†ã€ã‚„ãªããªããã¿ã®æ¨ªé¡”ãŸã å£°ä¸€ã¤ãƒ­ã‚¯ãƒ‡ãƒŠã‚·ãŸã å£°ä¸€ã¤ãƒ•ãƒªãƒ¼ã‚¸ã‚¢Uruãƒ•ãƒªãƒ¼ã‚¸ã‚¢ãƒ•ãƒ­ãƒ å”æ²¢ç¾å¸†ãƒ•ãƒ­ãƒ ã¾ãŸå¤ã‚’è¿½ã†ã‚ãŸã‚‰ã‚ˆã¾ãŸå¤ã‚’è¿½ã†ã‚‚ã†å°‘ã—ã ã‘YOASOBIã‚‚ã†å°‘ã—ã ã‘ãƒ¦ã‚­ãƒˆã‚­ã‚„ãªããªãã‚„ãªããªã ãƒ™ã‚¹ãƒˆã‚¢ãƒ«ãƒãƒ  -LIBRARY-ãƒ©ã‚¤ãƒ ãƒ©ã‚¤ãƒˆã®æ®‹ç«ã‚¢ãƒ¤ãƒãƒ©ã‚¤ãƒ ãƒ©ã‚¤ãƒˆã®æ®‹ç«ãƒªãƒ†ãƒ©ãƒãƒ¥ã‚¢Yuumiãƒªãƒ†ãƒ©ãƒãƒ¥ã‚¢ ç”±äºæ²¡æœ‰ä»€ä¹ˆæ—¶é—´ï¼Œæ‰€ä»¥ä¸æ€ä¹ˆç©æ¸¸æˆã€‚ å–œæ¬¢è¡€æŸ“é’Ÿæ¥¼ï¼Œä¸è¿‡æ˜¯äº‘ç©å®¶ã€‚ æ›¾ç»æ˜¯ Minecraft ç©å®¶ï¼Œç°åœ¨æ˜¯äº‘ç©å®¶ã€‚ï¼ˆupdï¼šç°åœ¨åˆå¼€å§‹ç©äº†ï¼‰ å–œæ¬¢ä¸è‚çš„ã€æœ‰æŒ‘æˆ˜æ€§çš„ã€å¯åˆ›é€ æ€§å¼ºçš„ã€å‰§æƒ…å¼•äººå…¥èƒœçš„æ¸¸æˆã€‚ä½†æ˜¯æˆ‘æ‰¾ä¸å¤ªåˆ°è¿™ç§ä¸œè¥¿ã€‚æƒ³è¦ç ”ç©¶çš„ä¸œè¥¿å¾ˆå¤šï¼ŒåŒ…æ‹¬ä½†ä¸é™äºï¼š å†å² åŸºå› å·¥ç¨‹ï¼Œæœºæ¢°ç”Ÿå‘½ å¤©æ–‡å­¦ å“²å­¦ï¼å…¶å®æ˜¯å¸¦æœ‰å“²å­¦è‰²å½©çš„ç§‘å¹»ï¼Œä¼šå¯¹ç±»ä¼¼äºä»¥ä¸‹é—®é¢˜æ„Ÿåˆ°å¥½å¥‡ï¼š å®‡å®™ä¸­çš„ç»ˆæé€»è¾‘ï¼Œæ˜¯å¦æ˜¯çœŸæ˜¯å­˜åœ¨çš„å®‡å®™ï¼Œè¿˜æ˜¯è¢«åˆ»æ„ç¼–è¾‘è¿‡çš„é€»è¾‘å­¦ï¼Ÿ æ—¶é—´æ—…è¡Œï¼Œæ‚–è®ºï¼Ÿ ç”Ÿå‘½ä»¥ä½•ç§æ–¹å¼å­˜åœ¨ï¼Ÿ å„ç±»è®¡ç®—æœºç§‘å­¦ç›¸å…³çš„å†…å®¹ æ—…è¡Œï¼Œä½†ä¸çŸ¥é“ç›®çš„åœ°æ˜¯å“ªé‡Œ æ€ä¹ˆæ‰¾ä½ ï¼Ÿ çŸ­æœŸè”ç³»ä½¿ç”¨ Outlook é‚®ç®±ï¼Œé•¿æœŸä½ å¯ä»¥é€šè¿‡å‘é‚®ä»¶æˆ‘ç´¢è¦æˆ‘çš„è”ç³»æ–¹å¼ã€‚åªè¦ä¸æ˜¯æ¶æ„éªšæ‰°ï¼Œéšä¾¿æˆ³ã€‚ Outlook: CN__james1@outlook.comï¼Œå¦‚æœæ‚¨è®¤ä¸ºäº‹æƒ…å¾ˆé‡è¦è¯·ç›´æ¥ä½¿ç”¨ iznomia@outlook.comã€‚ åœ¨å…¶å®ƒå¹³å°ä¸Šå¯ä»¥æ‰¾åˆ°æˆ‘ï¼š Luoguï¼šjames1BadCreeper Bilibiliï¼šiznomia Zhihuï¼šiznomia QQï¼š61121481 What is the answer to Life, the Universe, and Everything? 42ã€‚è¯æ˜å¦‚ä¸‹ï¼š å¦‚ä½•è¯æ˜ä¸€åˆ‡çš„ç­”æ¡ˆæ˜¯ 42 è¿™é‡Œæ²¡æœ‰æˆ‘è¦æ‰¾çš„ä¸œè¥¿ï¼Ÿ å¯ä»¥ä½¿ç”¨æœç´¢åŠŸèƒ½ã€‚åŒæ—¶ï¼Œæ¬¢è¿å¤§å®¶åœ¨ä¸‹æ–¹çš„è¯„è®ºä¸­çŒæ°´ï¼"},{"title":"","date":"2024-06-11T13:06:29.207Z","updated":"2024-06-11T13:06:29.207Z","comments":true,"path":"categories/index.html","permalink":"https://james1badcreeper.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-06-11T13:06:29.207Z","updated":"2024-06-11T13:06:29.207Z","comments":true,"path":"friends/index.html","permalink":"https://james1badcreeper.github.io/friends/index.html","excerpt":"æˆ‘ä»¬ç»ˆå°†ä»æ—¶å…‰å½’æ¥ï¼Œä¸ºå®‡å®™å¥å“é—å¿˜çš„é•‡é­‚æ›²ã€‚ æ¬¢è¿æ‚¨ï¼Œæ—…è¡Œè€…ï¼ å¸Œæœ›æ‚¨å¯ä»¥åœ¨è¿™ä¸ªç®€é™‹çš„åœ°æ–¹åº¦è¿‡ä¸€ä¸ªæ„‰å¿«çš„å¤œæ™š~ åŠ¨æ€å‹é“¾å…³äº","text":"æˆ‘ä»¬ç»ˆå°†ä»æ—¶å…‰å½’æ¥ï¼Œä¸ºå®‡å®™å¥å“é—å¿˜çš„é•‡é­‚æ›²ã€‚ æ¬¢è¿æ‚¨ï¼Œæ—…è¡Œè€…ï¼ å¸Œæœ›æ‚¨å¯ä»¥åœ¨è¿™ä¸ªç®€é™‹çš„åœ°æ–¹åº¦è¿‡ä¸€ä¸ªæ„‰å¿«çš„å¤œæ™š~ åŠ¨æ€å‹é“¾å…³äº ä¸æˆ‘äº¤æ¢å‹é“¾çš„æ–¹å¼ï¼š æ‹¥æœ‰ä¸€ä¸ªå¯ä»¥æ”¾ç½®å‹é“¾çš„åšå®¢ã€‚ ç«™ç‚¹æ²¡æœ‰è¥åˆ©æ€§ã€‚ ç„¶åå‘é‚®ä»¶ç»™æˆ‘ï¼šiznomia@outlook.comï¼Œå¦‚æœä¸æ–¹ä¾¿ä¹Ÿå¯ä»¥è¯•è¯•ä¸‹é¢çš„è¯„è®ºã€‚ æˆ‘çš„ä¿¡æ¯ï¼ˆæ ¹æ®æ‚¨èƒ½æ”¯æŒçš„ä¿¡æ¯é€‰å–ï¼Œæˆ–è€…æœ‰ç¼ºçš„åœ¨æ¢çš„æ—¶å€™å‘Šè¯‰æˆ‘ï¼Œæˆ‘ä¼šå›å¤ï¼‰ï¼š title: james1 # å¦‚æœæ‚¨é«˜å…´ä¹Ÿå¯ä»¥å†™ iznomia avatar: https://s3.bmp.ovh/imgs/2022/07/15/832a039463fab678.png url: https://james1badcreeper.github.io/ description: Fool for You. å¦‚æœæ‚¨éœ€è¦æ›´æ”¹æ‚¨çš„ä¿¡æ¯ï¼Œç›´æ¥è”ç³»æˆ‘å°±è¡Œï¼"},{"title":"æ ‡ç­¾åˆ—è¡¨","date":"2024-06-11T13:06:29.207Z","updated":"2024-06-11T13:06:29.207Z","comments":true,"path":"tags/index.html","permalink":"https://james1badcreeper.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-06-11T13:06:29.207Z","updated":"2024-06-11T13:06:29.207Z","comments":true,"path":"timeline/index.html","permalink":"https://james1badcreeper.github.io/timeline/index.html","excerpt":"","text":"æˆ‘ä»¬ç»ˆå°†ä»æ—¶å…‰å½’æ¥ï¼Œä¸ºå®‡å®™å¥å“é—å¿˜çš„é•‡é­‚æ›²ã€‚ æ¬¢è¿æ‚¨ï¼Œæ—…è¡Œè€…ï¼ å¸Œæœ›æ‚¨å¯ä»¥åœ¨è¿™ä¸ªç®€é™‹çš„åœ°æ–¹åº¦è¿‡ä¸€ä¸ªæ„‰å¿«çš„å¤œæ™š~ åŠ¨æ€å‹é“¾å…³äº å¦‚æœæ‚¨æœ‰ä»€ä¹ˆçœ‹æ³•ï¼Œè¯·ç‚¹å‡»åŠ¨æ€ä¸‹æ–¹çš„è¯„è®ºæŒ‰é’®ç•™è¨€ï¼ åŠ¨æ€çŸ­åšæ–‡åŠ¨æ€ä¸»è¦ç”¨äºè®°å½•ç”Ÿæ´»ä¸­å‘ç”Ÿçš„å¤§å¤§å°å°çš„äº‹ï¼Œæ¯”è¾ƒè½»æ¾æ„‰å¿«ã€‚ æ›´è¿œå¤çš„åŠ¨æ€çŸ­åšæ–‡ç”¨äºå‘å¸ƒä¸é€‚åˆå‘æˆåšæ–‡çš„å°æ–‡ç« ï¼Œä½†åˆæ¯”åŠ¨æ€æ›´é•¿ï¼Œå…¶é€šå¸¸æ¯”è¾ƒæœ‰å®è´¨æ€§æ„ä¹‰ã€‚ æ›´è¿œå¤çš„åšæ–‡"}],"posts":[{"title":"2024/06/11(#50)ï¼šå†è§ å’Œä½ è¯´å£°å†è§","slug":"default/è®°å½•/2024/6/2024-06-11","date":"2024-06-11T00:00:00.000Z","updated":"2024-06-11T00:00:00.000Z","comments":true,"path":"65e613ec/","link":"","permalink":"https://james1badcreeper.github.io/65e613ec/","excerpt":"â€”â€”ã€Šå»æ˜å¤©ã€‹","text":"â€”â€”ã€Šå»æ˜å¤©ã€‹ 72 [Ynoi Easy Round 2022] å •å¤©ä½œæˆ˜ TEST_98 å€å¢å€¼åŸŸåˆ†å—æ¿å­ï¼Œä½†æ˜¯ä¸ºå•¥è°ƒäº†åŠå¤©ï¼Ÿï¼Ÿï¼Ÿ","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/06/09(#49)ï¼šå°†æˆ‘å¸¦å»ä½ æ‰€å­˜åœ¨çš„åœ°æ–¹","slug":"default/è®°å½•/2024/6/2024-06-05","date":"2024-06-06T00:00:00.000Z","updated":"2024-06-09T00:00:00.000Z","comments":true,"path":"dbd1dffa/","link":"","permalink":"https://james1badcreeper.github.io/dbd1dffa/","excerpt":"æš‚æ—¶æ²¡æœ‰æè¿°ã€‚","text":"æš‚æ—¶æ²¡æœ‰æè¿°ã€‚ åŠ æ²¹å•Šï¼ï¼1 69 IOI2022 åƒå²› å¡é¢˜çš„åŸå› æ˜¯æŠŠ 2Ã—1062\\times 10^62Ã—106 çš„èˆªè¡Œæ¬¡æ•°çœ‹æˆäº† 2Ã—1052\\times 10^52Ã—105ï¼Œç»·ä¸ä½äº†ã€‚ åœ¨çŸ¥é“åˆ æ‰æ— ç”¨ç‚¹ï¼Œèµ°åˆ°ä¸€ä¸ªå‡ºåº¦æœ‰äºŒçš„ç‚¹ä¹‹åï¼Œé‚£ä¹ˆç›´æ¥æš´åŠ›æ¨¡æ‹Ÿæ„é€ å°±æ˜¯æœ‰è§£çš„ã€‚ 70 CF1375G Tree Modification çŒœäº†ä¸ªç»“è®ºï¼Œç„¶åç›´æ¥è¿‡äº†ï¼Ÿï¼Ÿï¼Ÿ 70.5 QOJ4827 Message Made of Noise ç›´æ¥æŒ‰ç…§ mod 27\\bmod 27mod27 è¿›è¡Œåˆ†è£‚ï¼Œåˆ¶é€ ä¸€ä¸ªåˆ†éš”ç¬¦å³å¯ã€‚ 71 CF776F Sherlockâ€™s bet to Moriarty å‘ç°å®é™…ä¸Šç›¸é‚»çš„æ˜¯ä¸€æ£µæ ‘çš„ç»“æ„ï¼Œé‚£ä¹ˆå»ºç«‹ç‚¹åˆ†æ ‘ï¼ŒLCA ä¸€å®šåœ¨è·¯å¾„ä¸Šï¼ŒæŒ‰ç…§å±‚æŸ“è‰²å³å¯ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/06/04(#48)ï¼šå°‘å¥³åœ¨ç­‰å¾…ç€ é»‘è‰²çš„æ¢¦å¢ƒä¸­","slug":"default/è®°å½•/2024/6/2024-06-04","date":"2024-06-04T00:00:00.000Z","updated":"2024-06-04T00:00:00.000Z","comments":true,"path":"24234d8d/","link":"","permalink":"https://james1badcreeper.github.io/24234d8d/","excerpt":"ä»Šå¤©ä¸ VPï¼Œåšä¸€ç‚¹æ‚é¢˜ã€‚","text":"ä»Šå¤©ä¸ VPï¼Œåšä¸€ç‚¹æ‚é¢˜ã€‚ è®°å¾—è¡¥ IOI2022 D2T3ã€‚ åšå¥½çœ¼å‰çš„å·¥ä½œã€‚ 67 CF605E Intergalaxy Trips ç›´æ¥åšå°±è¡Œäº†ã€‚ 68 AGC013E Placing Squares å¦‚æœç›´æ¥æŒ‰ç…§é¢˜ç›®æ¡ä»¶å»åšï¼Œå‘ç°è½¬1ç§»æ— æ³•å†™æˆçŸ©é˜µï¼Œç›´æ¥å‘Šè¾ã€‚ å°†å…¶è½¬åŒ–æˆï¼šåˆ†æˆæ­£æ–¹å½¢æ•°é‡æ®µï¼Œæ¯æ®µæ”¾ä¸¤ä¸ªé¢œè‰²ä¸åŒçš„å°çƒï¼Œå¯ä»¥é‡å ï¼Œæ€»æ–¹æ¡ˆæ•°ã€‚æ„Ÿè§‰è¿™ä¸€æ­¥å¾ˆå‰å®³ï¼ ç„¶åå°±ä¹±åšäº†ï¼Œå†™å‡ºè½¬ç§»åå¯ä»¥ç›´æ¥çŸ©é˜µå¿«é€Ÿå¹‚ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/06/03(#47)ï¼šé¥è¿œå®ˆæŠ¤ ç»§ç»­è¿½é€ æˆ–æ˜¯ä½“é¢ç»“æŸ","slug":"default/è®°å½•/2024/6/2024-06-02","date":"2024-06-02T00:00:00.000Z","updated":"2024-06-03T00:00:00.000Z","comments":true,"path":"12429a6f/","link":"","permalink":"https://james1badcreeper.github.io/12429a6f/","excerpt":"åº”è¯¥ä»˜å‡ºå…¨åŠ›äº†ã€‚","text":"åº”è¯¥ä»˜å‡ºå…¨åŠ›äº†ã€‚ é²œèŠ±åœ¨æœ€åé¢ã€‚ 63 xmascon23 Distance Construction Portal. å…¶å®æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„é¢˜ï¼Œä¸è¿‡ä¸ºå•¥æˆ‘ä¸ä¼šå‘¢ï¼Ÿ é¦–å…ˆå°†è¿™ä¸ªè¿‡ç¨‹è½¬åŒ–ä¸ºå¡«å†™ä»»æ„æ•°ï¼Œç„¶åå¯¹ kkk å–æ¨¡ï¼Œåªè¦ä¸å–æˆ 000 å°±è¡Œï¼Œå› æ­¤ k=2tk=2^{t}k=2t æ—¶æ— è§£ã€‚ ç„¶åå‘ç°åªèƒ½è¦å¥‡æ•°ï¼Œç›´æ¥å€å¢æ„é€ å³å¯ï¼ˆå°±æ˜¯ç»´æŠ¤ä¸€æ¡æ­£é“¾ï¼Œå¦‚æœæ²¡æœ‰è¿™ä¸ªäºŒè¿›åˆ¶ä½ä¸¢åˆ°å¯¹é¢å³å¯ï¼‰ã€‚ æ”¾ä¸€ä»½ä¸æ˜¯æˆ‘å†™çš„ä»£ç ï¼šã€‚ 64 CF773E Blog Post Rating aaa ä¸€å®šæ˜¯å•è°ƒä¸é™çš„æ’åºï¼Œæ‰¾åˆ°æ‹ç‚¹å¯ä»¥ç›´æ¥ç”¨çº¿æ®µæ ‘äºŒåˆ†å®Œæˆã€‚ åé¢çš„å¯ä»¥æ‹†æˆ ans=minâ¡{ai,aiâˆ’1+1,â‹¯ }ans=\\min\\{a_i,a_{i-1}+1,\\cdots\\}ans=min{aiâ€‹,aiâˆ’1â€‹+1,â‹¯}ï¼ŒåŒºé—´ +1 åŒºé—´ minâ¡\\minmin å³å¯ã€‚ æ„Ÿè§‰è„‘å­ä¸å¤ªæ¸…é†’ï¼ŒVP ä¸€ç‚¹ä¸œè¥¿ï¼ˆä»¥åå°½é‡å°‘åšé‚ªå…¸ï¼Œæ„Ÿè§‰ä¸èƒ½è€ƒï¼ï¼‰ã€‚ 65 IOI2022 Digital Circuit å°†è®¡æ•°é—®é¢˜è½¬åŒ–ä¸ºæ¦‚ç‡é—®é¢˜ï¼Œè®¾ fx,if_{x,i}fx,iâ€‹ ä»£è¡¨ xxx å‚æ•°ä¸º iii äº®çš„æ¦‚ç‡ï¼Œgx=1cxâˆ‘fx,ig_x=\\frac 1 {c_x}\\sum f_{x,i}gxâ€‹=cxâ€‹1â€‹âˆ‘fx,iâ€‹ï¼Œç„¶åå‘ç°ï¼Œgx=1cxâˆ‘gson(x)g_x=\\frac 1 {c_x} \\sum g_{son(x)}gxâ€‹=cxâ€‹1â€‹âˆ‘gson(x)â€‹ï¼Œé‚£ä¹ˆå¶å­çš„è´¡çŒ®æ˜¯ 1 / (ä¸€ä¸ªèŠ‚ç‚¹åˆ°æ ¹çš„è·¯å¾„ä¸Šæ‰€æœ‰å„¿å­çš„ä¹˜ç§¯)ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªèŠ‚ç‚¹åˆ°æ ¹çš„è·¯å¾„ä¸Šæ’é™¤å½“å‰å„¿å­çš„ä¹˜ç§¯ï¼Œçº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ 66 IOI2022 Rarest Insects ä¸ºå•¥ä¸ä¼šå•Šã€‚ä½¿åŠ²æµ‘èº«è§£æ•°ä¹Ÿåªæœ‰ 64ï¼Œè¦å¤šè®­äº†ã€‚ ç›´æ¥æ‰«ä¸€éè¿‡å»å¯ä»¥å¾—åˆ°é¢œè‰²æ•°ï¼Œç„¶åå¯ä»¥äºŒåˆ†ç­”æ¡ˆï¼ŒäºŒåˆ†çš„æ—¶å€™æ¯æ¬¡å¯ä»¥æ’é™¤æ‰ä¸€åŠä»¥ä¸Šçš„åŒºé—´ä¸å†è€ƒè™‘ï¼ˆæˆ‘æ²¡æƒ³åˆ°è¿™ä¸ªï¼Ÿï¼Ÿï¼‰ï¼Œé‚£ä¹ˆè¯¢é—®æ¬¡æ•°æ˜¯å¯¹çš„ã€‚ â€œçœ‹ï¼Œè¿™é‡Œé²œèŠ±ç››å¼€ï¼Œè‰æœ¨ä»ä¸ä¼šæ¯èã€‚â€ è¿™æ˜¯è«å¤§çš„è®½åˆºã€‚ æˆ‘æ²¡æœ‰èµ„æ ¼æŒ‡è´£åˆ«äººï¼Œå› ä¸ºæˆ‘æœ‰æ—¶å€™ä¹Ÿä¼šçŠ¯è ¢ï¼Œæˆ‘è‡ªå·±ä¹Ÿåº”è¯¥è¢«æ¶ˆé™¤ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/31(#46)ï¼šåªèº«èˆªè¡Œäºç”Ÿå‘½ä¸ä¿¡ä»°çš„æµ·æ´‹","slug":"default/è®°å½•/2024/5/2024-05-30","date":"2024-05-30T00:00:00.000Z","updated":"2024-05-31T00:00:00.000Z","comments":true,"path":"d02d0ba3/","link":"","permalink":"https://james1badcreeper.github.io/d02d0ba3/","excerpt":"èœå°±å¤šç»ƒã€‚","text":"èœå°±å¤šç»ƒã€‚ 61 PA 2015 Final Edycja å¯ä»¥è§†ä½œæå‡ºä¸€ä¸ªå†…å‘åŸºç¯æ ‘æ£®æ—ã€‚å…ˆè´ªå¿ƒé€‰æ‹©ï¼Œç„¶åè¦å¤„ç†ç¯ã€‚è®¾ fi,S,tf_{i,S,t}fi,S,tâ€‹ ä»£è¡¨è€ƒè™‘åˆ°ç¬¬ iii ä¸ªç‚¹ï¼Œæšä¸¾å…¶å‡ºè¾¹ï¼Œæ‹†æ‰äº† SSS çš„ç¯ï¼Œæ˜¯å¦å­˜åœ¨å…¥åº¦ä¸º 000 çš„ç‚¹ï¼ˆå› ä¸ºå…¨æ˜¯ç¯ï¼Œä¸”ä¸æ˜¯å…¨æ˜¯è‡ªç¯æ˜¯åˆæ³•çš„ï¼‰ã€‚ 60 CEOI2019 Building Skyscrapers æ¥è¡¥æ˜¨å¤©çš„ä¸œè¥¿ã€‚ æˆ‘ä»¬æ˜¾ç„¶è¦å»åˆ å¤§æ¥¼ï¼ˆå­—å…¸åºæ˜¯å€’ç€æ¯”çš„ä¹Ÿæç¤ºäº†è¿™ä¸€ç‚¹ï¼‰ï¼Œè€ƒè™‘å½“å‰å­é—®é¢˜æœ‰è§£çš„å……è¦æ¡ä»¶ï¼šå½“å‰å¤§æ¥¼å…«è¿é€šã€‚ ä¸€ä¸ªç‚¹èƒ½è¢«åˆ æ‰çš„å……è¦æ¡ä»¶æ˜¯ï¼š å®ƒèƒ½å¤Ÿåˆ°è¾¾æ— ç©·è¿œå¤„ï¼› å®ƒä¸æ˜¯å…«è¿é€šå›¾çš„å‰²ç‚¹ã€‚ è€ƒè™‘å°†éå¤§æ¥¼ç‚¹ç§°ä¸ºç™½ç‚¹ï¼Œé‚£ä¹ˆèƒ½åˆ°è¾¾æ— ç©·è¿œçš„ç™½ç‚¹çš„å¤§æ¥¼æ»¡è¶³æ¡ä»¶ä¸€ï¼Œè¿™ä¸ªå¾ˆå¥½ç»´æŠ¤ã€‚ æ¡ä»¶äºŒè¯´æ˜æˆ‘ä»¬åªèƒ½åˆ åœ†æ–¹æ ‘çš„å¶å­ï¼Œä½†æ˜¯è¿™æ ·å‘ç°æˆ‘ä»¬éœ€è¦ç»´æŠ¤åŠ¨æ€å›¾çš„åœ†æ–¹æ ‘ï¼ŒåŸºæœ¬ä¸Šæ˜¯æ­»äº†ã€‚ä½†è¿™æ˜¯ç½‘æ ¼å›¾ï¼Œæ€§è´¨å¾ˆå¥½ï¼Œå‡ºç°é—®é¢˜åªæœ‰ç±»ä¼¼ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼ˆB è¡¨ç¤ºæ¥¼ï¼ŒX è¡¨ç¤ºæ˜¯å‰²ç‚¹ï¼ŒW è¡¨ç¤ºç™½ç‚¹ï¼‰ï¼š B W B W X B B B B B B B W X W B B B å…¶ä¸­ W è¦åœ¨åŒä¸€ä¸ªè¿é€šå—å†…ï¼Œæ¯æ¬¡æ›´æ–°å³å¯ã€‚ä½†æ˜¯æˆ‘ä¸€å¼€å§‹å†™äº†å„ç§å¥‡æ€ªçš„ä¸œè¥¿ï¼Œä¸€ä¸ªç®€å•é¢˜è¢«æˆ‘æ–­æ–­ç»­ç»­å†™äº†ä¸¤å¤©ï¼Œåªèƒ½è¯´æˆ‘æ˜¯å”æ°ã€‚ 62 QOJ6320 Parallel Processing å¦‚æœæˆ‘ä»¬èƒ½ä½¿ç”¨æ¯ä¸€æ¡æŒ‡ä»¤ï¼Œé‚£ä¹ˆå¤§æ¦‚ç‡å®ƒæ˜¯å¾ˆä¼˜çš„ã€‚å¯¹äº nnn è¾ƒå°çš„æ‰‹ç©ï¼Œè¾ƒå¤§çš„ç›´æ¥é€’å½’å³å¯ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/29(#45)ï¼šå°±ç­‰å¾…å§ æ˜¥å½’æ—¶å¸Œæœ›é¸£å“","slug":"default/è®°å½•/2024/5/2024-05-29","date":"2024-05-28T00:00:00.000Z","updated":"2024-05-29T00:00:00.000Z","comments":true,"path":"ad68868e/","link":"","permalink":"https://james1badcreeper.github.io/ad68868e/","excerpt":"â€”â€” COPã€Šé›ªæ¥ä¸´æ—¶ã€‹","text":"â€”â€” COPã€Šé›ªæ¥ä¸´æ—¶ã€‹ ä»Šå¤©åšä¸€ç‚¹æ‚é¢˜ã€‚ 55 CF843D Dynamic Shortest Path ä½ çœ‹ï¼Œå› ä¸ºå€¼åŸŸæ˜¯æœ‰é™çš„ï¼Œå› æ­¤ç›´æ¥æ¯æ¬¡ BFS æ›´æ–°ä¸€ä¸‹å³å¯ã€‚ 56 ARC125F Tree Degree Subset Sum é¦–å…ˆå¯ä»¥å°†æ‰€æœ‰çš„ ddd éƒ½å‡å» 111ã€‚ç„¶åæˆ‘ä»¬èƒ½è¯æ˜ï¼Œå¯¹äºä¸€ä¸ª yyyï¼Œåˆæ³•çš„ xxx æ˜¯ä¸€ä¸ªè¿ç»­æ®µã€‚å› ä¸ºå¶å­åœ¨æ ‘ä¸­è‡³å°‘æœ‰ n2\\frac n 22nâ€‹ ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®é€‰æ‹©å¶å­çš„æ•°é‡æ¥è°ƒæ•´ã€‚ ç°åœ¨è¦å¯¹äºæ¯ä¸ª yyyï¼Œæ±‚å‡ºæœ€å°‘ã€æœ€å¤šç”¨å¤šå°‘ä¸ªç‰©å“å‡‘å‡ºã€‚ç”±äº âˆ‘d\\sum dâˆ‘d çš„ä¿è¯ï¼Œç›´æ¥äºŒè¿›åˆ¶æ‹†åˆ†ä¼˜åŒ–å¤šé‡èƒŒåŒ…ã€‚ 57 AGC028B Removing Blocks è€ƒè™‘ä¸€ä¸ªåˆ é™¤çš„æ—¶é—´åºåˆ—ï¼Œå¦‚ä½•è®¡ç®—å…¶è´¡çŒ®ï¼Ÿå»ºç«‹å°æ ¹ç¬›å¡å°”æ ‘ï¼Œä»£ä»·ä¸º âˆ‘depiÃ—ai\\sum dep_i\\times a_iâˆ‘depiâ€‹Ã—aiâ€‹ã€‚ å¦‚æœ xxx æ˜¯ iii çš„ç¥–å…ˆï¼Œå¯ä»¥è€ƒè™‘ï¼š x&lt;ix&lt;ix&lt;i æ—¶ï¼Œx,x+1,â‹¯ ,iâˆ’1x,x+1,\\cdots,i-1x,x+1,â‹¯,iâˆ’1 åº”è¯¥æ¯” iii ååˆ é™¤ï¼Œæ¦‚ç‡æ˜¯ 1iâˆ’x+1\\frac 1 {i-x+1}iâˆ’x+11â€‹ï¼› x&gt;ix&gt;ix&gt;i æ—¶ï¼Œä¸º 1xâˆ’i+1\\frac 1 {x-i+1}xâˆ’i+11â€‹ã€‚ ä¸éš¾è®¡ç®—å‡ºç­”æ¡ˆã€‚ VP CEOI2019 Day1ã€‚ 58 B. Dynamic Diameter è€ƒè™‘ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ç­”æ¡ˆï¼Œæ¯æ¬¡å¯ä»¥å°†é›†åˆçš„ä¸¤åŠåˆå¹¶æˆå½“å‰é›†åˆçš„ç­”æ¡ˆï¼ˆåªéœ€è¦è€ƒè™‘ 444 ä¸ªå¯èƒ½çš„ç›´å¾„ï¼‰ï¼Œé“¾ä¸Šè·ç¦»ä½¿ç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤å³å¯ã€‚ 59 C. Cubeword å‘ç°åªæœ‰å­—ç¬¦ä¸²çš„å¤´å°¾ä¼šå½±å“ç­”æ¡ˆï¼Œç”¨å››ä¸ªå››ä¸ªç‚¹çš„å¹³é¢æ¥é™åˆ¶ç­”æ¡ˆï¼Œå¹³é¢çš„ç­”æ¡ˆå¯ä»¥ç›´æ¥ O(V4)O(V^4)O(V4) æšä¸¾ã€‚ * 60 A. Building Skyscrapers åˆ«æ€¥ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/27(#44)ï¼šè®°å¿†çš„è´§å“å• è¿™ä¸€æ¬¾æ—©å”®å®Œ","slug":"default/è®°å½•/2024/5/2024-05-27","date":"2024-05-27T00:00:00.000Z","updated":"2024-05-27T00:00:00.000Z","comments":true,"path":"9f3b8d51/","link":"","permalink":"https://james1badcreeper.github.io/9f3b8d51/","excerpt":"â€”â€” å‘¨æ·±ã€Šè®°å¿†å•†åº—ã€‹ ä»Šå¤©ç¨å¾®å†™ç‚¹é—²è¯ã€‚","text":"â€”â€” å‘¨æ·±ã€Šè®°å¿†å•†åº—ã€‹ ä»Šå¤©ç¨å¾®å†™ç‚¹é—²è¯ã€‚ ä»Šå¤©æ‰“äº†ä¸€åœºæ¨¡æ‹Ÿèµ›ã€‚ä½†æ˜¯æˆ‘è§‰å¾—é¢˜å®åœ¨æ˜¯å¤ªæ°´äº†ï¼ä¸æƒ³å†™ï¼Œéšä¾¿ç­¾äº†ä¸ªåˆ°ä¸‹ç­äº†ã€‚æ€ä¹ˆæœ‰äººå¿™äº†ä¸€æ•´åœºï¼Œå¾—åˆ†è¿˜ä¸å¦‚æˆ‘ 5min éšä¾¿å†™çš„ä¸œè¥¿å•Šï¼Ÿï¼Ÿï¼Ÿï¼Ÿ ä»¥ä¸Šå†…å®¹æ˜¯æˆ‘çš„ä¸€ä¸ªæœ‹å‹æ¥å†™çš„ï¼Œå‡ºäºå¯¹è¡ªçš„å°Šé‡ï¼Œè¿™é‡Œä¿ç•™ã€‚ä»¥ä¸‹å¼€å§‹æ˜¯æ­£å¸¸å†…å®¹ã€‚ äº‹æƒ…æ˜¯è¿™æ ·çš„ï¼ŒT1 æ˜¯ç­¾åˆ°é¢˜ï¼Œä½†æ˜¯å› ä¸ºå¤§æ ·ä¾‹æ˜¯é”™çš„æ‰€ä»¥å—åˆ°äº†ä¸€ç‚¹å½±å“ï¼Œä½†æ˜¯ 1h ä¹Ÿå®Œæˆäº†ã€‚T3 æ˜¯ã€æ¨¡æ¿ã€‘æ ‘ä¸ŠåŠåœ¨çº¿å·ç§¯ï¼Œä¸€å¼€å§‹æƒ³åºåˆ—æƒ³åˆ°äº†ä¸€äº›æ ¹å·é‡æ„çŠ¶ç‰©ï¼Œä½†æ˜¯æˆ‘è¿å·ç§¯éƒ½ä¸ä¼šï¼Œæ‰€ä»¥è¿˜æ˜¯ç®—äº†ã€‚ æ‰€ä»¥ T3 æ”¾æ¿å­æ˜¯ä»€ä¹ˆæ„æ€å•Šï¼Œæ„Ÿè§‰ä¸å¦‚å„ç±»è¶…çº§ç‰›é©¬é¢˜ä¸€æ ¹æ¯›ã€‚ T2 ä¸ä¼šçŸ©é˜µå¿«é€Ÿå¹‚æ˜¯é¹…åœ°é”…ï¼Œæˆ‘è¿˜åœ¨æƒ³è¿™ç©æ„å„¿éœ€è¦æ±‚å’Œæ€ä¹ˆåšï¼Œä½†å®é™…ä¸Šæ— æ‰€è°“ï¼Œç›´æ¥åšå°±è¡Œäº† 53 APIO2024 é­”æœ¯è¡¨æ¼” ä¸ºå•¥æˆ‘ä¸ä¼šæ¥ç€ã€‚ä»£ç ã€‚ 53 SNOI2020 åŒºé—´å’Œ å‰å¸æœº KTTã€‚ä»£ç ã€‚ è®°å¾—é”ç”µè„‘ã€‚ 54 ã€ŒWdoi-1ã€è“¬è±ç‰æ ç›´æ¥ D å°±è¡Œäº†ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/24(#43)ï¼šé‚£åšå®ˆ æŸä¸€åˆ»åŒ–ä½œä¹Œæœ‰","slug":"default/è®°å½•/2024/5/2024-05-24","date":"2024-05-24T00:00:00.000Z","updated":"2024-05-24T00:00:00.000Z","comments":true,"path":"f66c938e/","link":"","permalink":"https://james1badcreeper.github.io/f66c938e/","excerpt":"è¢«æ‰“çˆ†äº†ã€‚","text":"è¢«æ‰“çˆ†äº†ã€‚ 50 CCO2020 Shopping Plans æ¥åšç»å…¸é¢˜ï¼ï¼ ä¸€ä¸ªåºåˆ—çš„å¾ˆå®¹æ˜“å§ï¼Œè®°å½“å‰é•¿åº¦ã€å½“å‰æ¡ç€çš„å…ƒç´ ã€æ¡ç€çš„å…ƒç´ æœ€å¤šèƒ½æ‰©å±•åˆ°çš„ä½ç½®ï¼Œå°±æ²¡æœ‰é‡å¤çš„äº†ã€‚ ç„¶åå°±æ˜¯ä¸€äº›åºåˆ—ï¼Œæ¯ä¸ªåºåˆ—é€‰æ‹©ä¸€ä¸ªæ•°çš„ kkk å°ã€‚å¥½åšï¼è®°å½•å½“å‰æ‰©å±•åˆ°äº†ç¬¬å‡ ä¸ªåºåˆ—ï¼Œè¿™ä¸ªåºåˆ—é€‰æ‹©åˆ°äº†å“ªä¸€ä¸ªï¼Œåé¢çš„åºåˆ—é»˜è®¤é€‰æ‹©æœ€å°ã€‚ä½†æ˜¯è¿™æ ·é€‰æœ€å°çš„å°±ç®—é‡å¤äº†ï¼Œäºæ˜¯ç›´æ¥é€‰æ¬¡å°ï¼ŒçœŸçš„éœ€è¦é€‰æœ€å°çš„åæ‚”ä¸€ä¸‹å°±è¡Œäº†ã€‚ä»£ç ã€‚ 51 CmdOI2019 ä»»åŠ¡åˆ†é…é—®é¢˜ å†™ä¸€é“æ¨¡æ¿é¢˜ã€‚ 52 NOI2019 I å›çš„æ¢é™© å—åˆ°äº†æ¯”è¾ƒå¤§çš„æç¤ºå•Šã€‚ å—åˆ° IOI2017 Simurgh çš„å½±å“ï¼Œå…ˆæ€è€ƒç”Ÿæˆæ ‘æ€ä¹ˆæ‰¾ã€‚ å‘ç°ä¾ç„¶ä¸å¥½æ‰¾ï¼Œä½†æ˜¯éƒ¨åˆ†åˆ†æœ‰ä¸€æ¡£ fai&lt;ifa_i&lt;ifaiâ€‹&lt;iï¼Œè¿™ä¸ªæ˜¯å¯ä»¥ç›´æ¥æ•´ä½“äºŒåˆ†è§£å†³çš„ã€‚ å›¾å¯ä»¥ç”±è‹¥å¹²æ£µæ ‘æ‹¼æˆï¼Œé‚£ä¹ˆéšæœºåŒ–è¿›è¡Œé‡ç¼–å·ï¼Œæ¥å¥—ç”¨ä¸Šè¿°åšæ³•å³å¯ã€‚ è¯¶ç­‰ç­‰å¥½åƒä¸å¤ªå¯¹ï¼Œå›å®¶å†ä¿®ä¿®ã€‚ é”™äº†ï¼Œæ²¡é—®é¢˜ã€‚ æ€ä¹ˆå†™äº†è¿™ä¹ˆä¹…ï¼Œè¿˜æ˜¯è¦å¤šç»ƒã€‚ éœ€è¦æ‹¼ä¸Š O(n2)O(n^2)O(n2) query çš„ç­–ç•¥ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/23(#42)ï¼šIt's OKï¼","slug":"default/è®°å½•/2024/5/2024-05-22","date":"2024-05-23T00:00:00.000Z","updated":"2024-05-23T00:00:00.000Z","comments":true,"path":"c6fff67e/","link":"","permalink":"https://james1badcreeper.github.io/c6fff67e/","excerpt":"æˆ‘ä»¬æ¥æ¬£èµä¸€äº›æœ‰è¶£çš„ä¸œè¥¿ã€‚","text":"æˆ‘ä»¬æ¥æ¬£èµä¸€äº›æœ‰è¶£çš„ä¸œè¥¿ã€‚ ä»Šå¤©ï¼Œäº‰å–å·ä¸€ç‚¹ï¼ 49 CF1761G Centroid Guess å¦‚æœæˆ‘ä»¬çŸ¥é“é‡å¿ƒåœ¨ä¸€æ¡é“¾ (x,y)(x,y)(x,y) ä¸Šï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨ 2n2n2n æ¬¡è¯¢é—®ç»“æŸã€‚ å¦‚æœæˆ‘ä»¬é€‰æ‹©ä¸€æ¡ä¸å«é‡å¿ƒçš„é“¾ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä¸€å®šä¼šæœ‰ä¸€æ£µå­æ ‘çš„ç‚¹çš„ä¸ªæ•°è¶…è¿‡ âŒŠn2âŒ‹\\left\\lfloor\\frac n 2\\right\\rfloorâŒŠ2nâ€‹âŒ‹ã€‚é‚£ä¹ˆéšæœº S=157S=157S=157 ä¸ªé‡‡æ ·ç‚¹ï¼Œå¦‚æœæœ‰ä¸€ä¸ªç‚¹æŒ‚è½½äº†è¶…è¿‡ä¸€åŠçš„ç‚¹ï¼Œé‚£ä¹ˆéœ€è¦è°ƒæ•´ã€‚ ä½†æ˜¯å¦‚æœæŠŠä¸­å¿ƒè°ƒä¸¢äº†æ€ä¹ˆåŠï¼Ÿåˆ«æ‹…å¿ƒï¼Œåªè¦é‡å¿ƒæŒ‚äº†è¶…è¿‡ 1/41/41/4 çš„ç‚¹ï¼Œå®ƒå°±ä¸ä¼šè°ƒä¸¢ã€‚ å¤šä¹…èƒ½è°ƒæ•´åˆ°é‡å¿ƒå‘¢ï¼ŸæŒ‚åœ¨äº†è¶…è¿‡ 1/21/21/2 ä¸ªé‡‡æ ·ç‚¹çš„æ¦‚ç‡åœ¨é‡å¿ƒä¸åœ¨é“¾ä¸Šæ—¶çš„æ¦‚ç‡ â‰¥1/2\\ge 1/2â‰¥1/2ï¼Œè€Œè¿™äº›å…¶ä¸­éšæœºçš„ä¸€ä¸ªé‡‡æ ·ç‚¹åœ¨é‡å¿ƒå­æ ‘å†…çš„æ¦‚ç‡ â‰¥1/2\\ge 1/2â‰¥1/2ï¼Œå› æ­¤ 1/41/41/4 çš„æ¦‚ç‡å¯ä»¥è°ƒæ•´åˆ°ï¼ åäº‹äº†ï¼Œæ‘†å®Œäº†ğŸ˜… äººè¦ä¼‘æ¯å¥½ï¼ï¼","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/21(#41)ï¼šå‡å¦‚å¯ä»¥è®©ä¸–ç•Œæ²‰é»˜ åˆ«åµé†’è¿™ä¸ªæ¢¦","slug":"default/è®°å½•/2024/5/2024-05-21","date":"2024-05-21T00:00:00.000Z","updated":"2024-05-21T00:00:00.000Z","comments":true,"path":"e2b61889/","link":"","permalink":"https://james1badcreeper.github.io/e2b61889/","excerpt":"â€”â€”ã€Šå½“å…¨ä¸–ç•Œå¿˜äº†æˆ‘ã€‹","text":"â€”â€”ã€Šå½“å…¨ä¸–ç•Œå¿˜äº†æˆ‘ã€‹ 45 AGC021E Ball Eat Chameleons ç”±äºæ–¹æ¡ˆä¸åŒä»…å½“é¢œè‰²ä¸åŒï¼Œå› æ­¤æˆ‘ä»¬ä»çƒçš„é¢œè‰²è§’åº¦è€ƒè™‘å»è®¡æ•°ã€‚ æœ‰ RRR ä¸ªçº¢çƒï¼ŒBBB ä¸ªè“çƒï¼Œé‚£ä¹ˆ Râ‰¥B+nR\\ge B+nRâ‰¥B+n æ—¶å¿…å®šæœ‰è§£ï¼Œå¦åˆ™æœ‰è§£æ»¡è¶³ Bâ‰¤R&lt;B+nB\\le R&lt;B+nBâ‰¤R&lt;B+nã€‚æ­¤æ—¶è®© Râˆ’BR-BRâˆ’B åªé¾™çº¢çƒåƒçš„æ¯”è“çƒå¤šä¸€ä¸ªï¼Œnâˆ’(Râˆ’B)n-(R-B)nâˆ’(Râˆ’B) åªé¾™åƒçš„çº¢çƒå’Œè“çƒä¸€æ ·å¤šï¼Œä½†æœ€åä¸€ä¸ªåƒäº†ä¸ªè“çƒã€‚ R=BR=BR=B çš„æƒ…å†µç­‰ä»·äº (R,Bâˆ’1)(R,B-1)(R,Bâˆ’1)ã€‚ æˆ‘ä»¬å¼ºåˆ¶è¦æ±‚è“çº¢åƒçš„ä¸€æ ·å¤šçš„é¾™åƒçš„åºåˆ—å½¢å¦‚ RBRBRBRBï¼Œå¦åˆ™æˆ‘ä»¬å¯ä»¥å°†å…¶ä¸­ä¸æ»¡è¶³çš„æ‹‰å‡ºæ¥ï¼Œå–‚ç»™å¤šåƒäº†çº¢è‰²çƒçš„é¾™åƒã€‚ ç°åœ¨è¦æ±‚åœ¨åºåˆ—ä¸­å¯ä»¥æå–å‡ºè‡³å°‘ nâˆ’(Râˆ’B)n-(R-B)nâˆ’(Râˆ’B) ä¸ª RB å­åºåˆ—ã€‚å¯ä»¥çœ‹ä½œæ¨ªç€çš„æ ¼è·¯è®¡æ•°ï¼Œä¸èƒ½è¶Šè¿‡ y=âˆ’(nâˆ’R)y=-(n-R)y=âˆ’(nâˆ’R)ã€‚ä»£ç ã€‚ 46 AGC043D Merge Triplets è€ƒè™‘æŒ‰ç…§æ•°ä»å°åˆ°å¤§è¿›è¡Œ DPã€‚å‘ç°å‰ç¼€æœ€å¤§å€¼æ®µçš„é•¿åº¦ â‰¤3\\le 3â‰¤3ï¼Œç„¶åé•¿åº¦ä¸º 222 çš„æ®µä¸ªæ•°ä¸è¶…è¿‡é•¿åº¦ä¸º 111 çš„æ®µä¸ªæ•°ã€‚ä»£ç ã€‚ 47 ARC082C ConvexScore è´¡çŒ®æ˜¯åˆæ³•ç‚¹é›†çš„æ•°é‡ï¼Œå…¶ä¸­åˆæ³•çš„å®šä¹‰æ˜¯å®ƒä»¬ä¸­å¯ä»¥é€‰å‡ºä¸€äº›ç‚¹æ„æˆä¸€ä¸ªå‡¸å¤šè¾¹å½¢å›´ä½æ‰€æœ‰çš„ç‚¹ã€‚å› æ­¤ç›´æ¥ç»Ÿè®¡æ‰€æœ‰çš„çº¿æ®µå³å¯ã€‚ 48 JOISC2023 Tourism ç»´æŠ¤æ¯æ¡é‡é“¾ä¸Šçš„é¢œè‰²æ®µï¼Œæ‰«æçº¿ï¼ŒæŸ¥è¯¢çš„æ—¶å€™æŸ¥è¯¢ â‰¥l\\ge lâ‰¥l çš„é¢œè‰²çš„ç‚¹çš„æ•°é‡ï¼Œå‡å» LCA çš„æ·±åº¦ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/19(#40)ï¼šæ•£è½é£ä¸­çš„äºº è¯¥å¦‚ä½•æ€è€ƒ","slug":"default/è®°å½•/2024/5/2024-05-17","date":"2024-05-19T00:00:00.000Z","updated":"2024-05-19T00:00:00.000Z","comments":true,"path":"f4b9539b/","link":"","permalink":"https://james1badcreeper.github.io/f4b9539b/","excerpt":"â€”â€” åæ™¨å®‡ã€Šé‚£äº›æˆ‘å°šæœªçŸ¥é“çš„ç¾ä¸½ã€‹","text":"â€”â€” åæ™¨å®‡ã€Šé‚£äº›æˆ‘å°šæœªçŸ¥é“çš„ç¾ä¸½ã€‹ ä¸æƒ³è¯´ä»€ä¹ˆäº†ï¼Œé‚£å°±ä¸è¯´äº†ã€‚ 43 APIO 2022 æ’åˆ— é‡‡ç”¨ä¹‹å­—å½¢æ„é€ ï¼Œä¸‹æ–¹çš„ä¸¤ä¸ªå¯ä»¥åˆå¹¶æˆä¸€ä¸ªã€‚ 44 AGC012C Tautonym Puzzle å…ˆå¡« 1âˆ¼1001\\sim 1001âˆ¼100ï¼Œè½¬åŒ–ä¸ºä½¿å¾—ä¸Šå‡å­åºåˆ—ä¸º nnnã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/07(#39)ï¼šå‡é‡çš„ å‘œå’½çš„é»‘","slug":"default/è®°å½•/2024/5/2024-05-06","date":"2024-05-07T00:00:00.000Z","updated":"2024-05-07T00:00:00.000Z","comments":true,"path":"214da479/","link":"","permalink":"https://james1badcreeper.github.io/214da479/","excerpt":"å®Œå…¨ä¸ä¼šåšè¿™ç§é¢˜å•Šã€‚","text":"å®Œå…¨ä¸ä¼šåšè¿™ç§é¢˜å•Šã€‚ 41 QOJ6370 Slot Machine ä¼šäº†ï¼Œä¸ºå•¥æ²¡è¿‡æ¥ç€ï¼Ÿ æ’åºå³å¯ã€‚ 42 ABC240H Sequence of Substrings å‘ç°åªæœ‰é•¿åº¦ â‰¤O(n)\\le O(\\sqrt{n})â‰¤O(nâ€‹) çš„å­ä¸²æ˜¯æœ‰ç”¨çš„ï¼Œä½†æ˜¯æŠŠå®ƒä»¬éƒ½æ‹‰å‡ºæ¥ç„¶åæ’åºå°±çˆ†ç‚¸äº†ï¼Œæ•…è€ƒè™‘æ‰”åˆ° Trie æ ‘ä¸Šï¼Œç„¶åæ ‘çŠ¶æ•°ç»„ä¼˜åŒ– DP å°±è¡Œäº†ã€‚ VP SHCPC2022ã€‚ è®°å¾—æŠŠå‰©ä¸‹çš„é¢˜è¡¥äº†ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/05(#38)ï¼šå°±åœ¨è¿™é•¿å¤œä¹‹å å‡ç»“ä¸€åº§ æ–°å®‡å®™","slug":"default/è®°å½•/2024/5/2024-05-05","date":"2024-05-05T00:00:00.000Z","updated":"2024-05-05T00:00:00.000Z","comments":true,"path":"e0ab227/","link":"","permalink":"https://james1badcreeper.github.io/e0ab227/","excerpt":"æŠ±æ­‰ï¼Œåº”è¯¥æ˜¨å¤©å°±å‘çš„","text":"æŠ±æ­‰ï¼Œåº”è¯¥æ˜¨å¤©å°±å‘çš„ å¤ªä¼Ÿå¤§äº†ï¼ï¼ å…¶å®æœ‰äº›åšçš„é¢˜å¹¶ä¸åœ¨è¿™é‡Œï¼Œå› ä¸ºå®ƒä»¬æ›´é€‚åˆæ”¾åœ¨ä¸€è½®å¤ä¹ é‡Œã€‚ 40 PA2024 Desant 3 å¯¹ 222 å–æ¨¡ï¼Œå¥½åƒè§è¿‡å¾ˆå¤šï¼Œä½†è¿™æ˜¯ç¬¬ä¸€ä¸ªå†™çš„ã€‚ æœåˆ°ä¸¤ä¸ªç›¸åŒçš„çŠ¶æ€åé¢å°±ä¸ç”¨æœäº†ã€‚ æœç´¢æ“ä½œåºåˆ—ï¼Œå¦‚æœéƒ½æ²¡ç¡®å®šï¼Œé‚£ä¹ˆ aaa å’Œ bbb å‡†å¤‡çŠ¶æ€ä¸åŒè¿™ä¸¤ç§æ˜¯ç­‰ä»·çš„ï¼Œæœå‰©ä¸‹çš„ã€‚å¦‚æœåªæœ‰ä¸€ä¸ªç¡®å®šï¼Œé‚£ä¹ˆä¹Ÿæ˜¯æœä¸¤ç§ã€‚ä¸¤ä¸ªç¡®å®šç›´æ¥å¾€ä¸‹æœã€‚ åªæäº† n2\\frac n 22nâ€‹ æ¬¡æšä¸¾ï¼Œæ—¶é—´å¤æ‚åº¦æ­£ç¡®ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/05/04(#37)ï¼šåœæ»åœ¨æ­¤å¤„çš„è„šæ­¥","slug":"default/è®°å½•/2024/5/2024-05-01","date":"2024-05-01T00:00:00.000Z","updated":"2024-05-01T00:00:00.000Z","comments":true,"path":"2e62a54e/","link":"","permalink":"https://james1badcreeper.github.io/2e62a54e/","excerpt":"åˆå›æ¥äº†ã€‚","text":"åˆå›æ¥äº†ã€‚ å¥½ç†Ÿæ‚‰çš„åœ°æ–¹å•Šï¼Œç‰¹äº§æ˜¯èŸ‘è‚ï¼ï¼ 34 CF1342F Make It Ascending ç›´æ¥ç¡¬ Dï¼Œfi,j,Sf_{i,j,S}fi,j,Sâ€‹ ä»£è¡¨æ±‡èšæˆ iii ä¸ªé›†åˆï¼Œæœ€ååœ¨ jjj å¤„èšé›†ï¼Œå½“å‰ä½¿ç”¨çš„ SSS çš„æœ«å°¾æœ€å°æ•°å³å¯ã€‚ 35 CF666D Chain Reaction åˆ†è®¨ã€‚ ç„¶åç›´æ¥æšä¸¾ç‚¹çš„å…¨æ’åˆ—å¯ä»¥è§£å‡º ddd å’Œ rrrã€‚ç›´æ¥ç®—å³å¯ã€‚ 36 CF1698F Equal Reversal å‘ç°æ˜¯æ— å‘å›¾é‡å®šå‘è·¯å¾„ã€‚ ç›´æ¥æ‰«è¿‡å»ï¼ŒO(n3)O(n^3)O(n3) ç»´æŠ¤å³å¯ã€‚ èƒ½ä¸èƒ½æ…¢ä¸‹æ¥ã€‚ å†™å‡åŠè­¦æŠ¥å™¨çš„åšå®¢ã€‚Call Me Call Me ç•™åˆ°ä»¥ååšã€‚ 37 CF1110G Tree-Tac-Toe åˆ†ç±»è®¨è®ºã€‚ 38 CF1470F Strange Covering åˆ¶è£é‚ªæ¶æ•°æ®ç»“æ„ï¼ï¼ï¼ ç›´æ¥åšã€‚æ²¡äº†ã€‚ä»£ç ã€‚ è¯´ä¸€ä¸‹æ­£ç»åšæ³•ã€‚ æˆ‘ä¼šçŸ©å½¢åå­—ã€‚ ç„¶åä¸¤ä¸ªçŸ©å½¢éƒ½æœ‰ä¸€ä¸ªè§’åœ¨å¦ä¸€ä¸ªçŸ©å½¢çš„ç›´æ¥æšä¸¾ä¸¤ä¸ªè§’ï¼Œç„¶åéƒ½èƒ½ç®—ã€‚ä½¿ç”¨ç¥ç§˜æ•°æ®ç»“æ„ç»´æŠ¤ä¸€ä¸‹ï¼Œä¸è¿‡æˆ‘ä¸ä¼šã€‚ 39 PA2024 Å»elki å…ˆé€šè¿‡ DP æ±‚å‡ºæ¯ç§é¢œè‰²çš„ç‰©å“éƒ½ä¹°ä¸€ä¸ªï¼Œå‡‘å‡º iii çš„ä½“ç§¯ï¼ˆæ¨¡ mmm æ„ä¹‰ä¸‹çš„æœ€å°ä»£ä»·ï¼‰ï¼ŒO(nm)O(nm)O(nm) å¯ä»¥å®Œæˆã€‚ æœ€ç»ˆè¦æ±‚çš„ä¸œè¥¿ç›¸å½“äºä½“ç§¯æ¨¡ mmm æ„ä¹‰ä¸‹çš„å®Œå…¨èƒŒåŒ…ï¼Œç›´æ¥è·‘åŒä½™æœ€çŸ­è·¯å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ O(nm)O(nm)O(nm)ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/29(#36)ï¼šä¸–ç•Œåƒä¸ªåŠ¨ç‰©ä¹å›­ï¼Œé‚£ä¹ˆé‚£ä¹ˆå¤§è¶…çº§ä¹å›­","slug":"default/è®°å½•/2024/4/2024-04-29","date":"2024-04-29T00:00:00.000Z","updated":"2024-04-29T00:00:00.000Z","comments":true,"path":"757c0058/","link":"","permalink":"https://james1badcreeper.github.io/757c0058/","excerpt":"è¿™é‡Œä»€ä¹ˆéƒ½æœ‰ï¼","text":"è¿™é‡Œä»€ä¹ˆéƒ½æœ‰ï¼ VP Petrozavodsk Summer 2019. Day 2. 300iq Contest 2, Grand Prix of Kazanã€‚ è¿™ä¸‹çœŸçš„èœå°±å¤šç»ƒäº† B. Bitwise Xor å»ºå‡º Trie æ ‘å¯ä»¥å‘ç° DFS åºç›¸é‚»çš„æ•°èƒ½è¾¾åˆ°æœ€å°å€¼ï¼Œå› æ­¤ç›´æ¥ Trie + DP å³å¯ã€‚ I. Interactive Vertex ç›´æ¥ç‚¹åˆ†æ²»ä¸‹å»ï¼Œæ¯æ¬¡éœ€è¦äºŒåˆ†ï¼Œè¯¢é—®æ¬¡æ•°æ˜¯ O(logâ¡2n)O(\\log^2 n)O(log2n) çš„ï¼Œæ¯æ¬¡éœ€è¦æ’é™¤è‡³å°‘ä¸€åŠçš„å¤§å°ï¼Œå› æ­¤äºŒåˆ†æ—¶å€™å¸¦ä¸ªæƒå€¼å³å¯ã€‚ G. Grammarly æ­£å¸¸ç­”æ¡ˆæ˜¯ 2nâˆ’12^n-12nâˆ’1ï¼Œå¯¹äºä¸€ä¸ªè¿ç»­å­—ç¬¦çš„çŠ¶æ€ [l,r][l,r][l,r]ï¼Œèƒ½å¤Ÿåˆ°è¾¾å®ƒçš„æ–¹æ¡ˆæ•°æ˜¯ (nâˆ’lenlâˆ’1)\\binom{n-len}{l-1}(lâˆ’1nâˆ’lenâ€‹)ï¼Œå…¶ç°åœ¨çš„æ–¹æ¡ˆæ•°æ˜¯ lenlenlenã€‚ç„¶åå¯¹äºæ¯ä¸ªèƒ½å¤Ÿåˆ°è¾¾çš„è¿ç»­å­—ç¬¦çŠ¶æ€çš„å‰ç¼€åç¼€çš„ç­”æ¡ˆä¹Ÿè¦å‡å»ã€‚ E. Easy Win çº¿æ€§ä»£æ•°ï¼Œæ»šã€‚ æˆ‘åªèƒ½ç›¸ä¿¡ä»–ä¸å¯èƒ½è€ƒæ‹Ÿé˜µã€‚ è¦å­¦çš„ï¼ˆå¯èƒ½ä¸æ˜¯å¾ˆé‡è¦ï¼‰ï¼š çº¿æ€§åŸºç›¸å…³åº”ç”¨ è¡Œåˆ—å¼ LGVï¼ŒBESTï¼ŒçŸ©é˜µæ ‘ F. Fast Spanning Tree ä¹‹å‰å¬è¯´è¿‡å‡åŠè­¦æŠ¥å™¨çš„åå­—ï¼Œæ²¡æƒ³åˆ°è¿™æ¬¡çœŸçš„ç¢°åˆ°äº†ã€‚ å°†éœ€è¦çš„æƒå€¼å„è‡ªåˆ†ä¸€åŠï¼Œç„¶åæ¥ç€è·‘å³å¯ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/27(#35)ï¼šæˆ‘è¦ä»å—èµ°åˆ°åŒ— ä¹Ÿè¦ä»ç™½èµ°åˆ°é»‘","slug":"default/è®°å½•/2024/4/2024-04-27","date":"2024-04-27T00:00:00.000Z","updated":"2024-04-27T00:00:00.000Z","comments":true,"path":"714b05b5/","link":"","permalink":"https://james1badcreeper.github.io/714b05b5/","excerpt":"â€”â€”ã€Šå‡è¡Œåƒ§ã€‹","text":"â€”â€”ã€Šå‡è¡Œåƒ§ã€‹ 32 P3766 æ ¸å¿ƒå¯†ç B Portal. å¯¹äº kâ‰¥3k\\ge 3kâ‰¥3 çš„ç›´æ¥æ‰«ä¸€éç»Ÿè®¡ã€‚ k=2,iâ‰¥2Ã—107k=2,i\\ge 2\\times 10^7k=2,iâ‰¥2Ã—107 çš„è¯¯å·®å·²ç»è¶³å¤Ÿå°ï¼Œç›´æ¥å¹²å³å¯ã€‚ æ€ä¹ˆ ABC G å†™ä¸å‡ºæ¥çš„å•Šã€‚ æ€ä¹ˆä¸ä¼š A å•Šã€‚æ˜å¤©è¡¥ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/26(#34)ï¼šæˆ‘è¦è¿™æ°´æŒ¡ä¸ä½å½’é€” æˆ‘è¦å¤©åœ°éƒ½ä¸ºæˆ‘è®©æ­¥","slug":"default/è®°å½•/2024/4/2024-04-24","date":"2024-04-24T00:00:00.000Z","updated":"2024-04-26T00:00:00.000Z","comments":true,"path":"f6a9e8e1/","link":"","permalink":"https://james1badcreeper.github.io/f6a9e8e1/","excerpt":"åŸæ¥ä¸€æ— æ‰€æœ‰ å°±å«åš é½å¤©å¤§åœ£ã€‚","text":"åŸæ¥ä¸€æ— æ‰€æœ‰ å°±å«åš é½å¤©å¤§åœ£ã€‚ æ—¶é—´çœŸçš„è¿˜å¤Ÿå—ã€‚ å‰è¾ˆä»¬åšå¾—å¾ˆå¥½ï¼Œæˆ‘èƒ½å¤Ÿåšå¾—åˆ°å—ã€‚ ç°åœ¨çœŸçš„æ‘†å®Œäº†å•Šï¼Œæ€ä¹ˆæ‰èƒ½å½»åº•æ¸…é†’ã€‚ ä»–ä»¬éƒ½å¥½å‰å®³ã€‚ æˆ‘ä¹Ÿæƒ³ï¼Œåšåˆ°å•Šã€‚ æ‰€ä»¥ï¼Œä»Šå¤©çš„ä»»åŠ¡åšå®Œæœ‰å¥–åŠ±ï¼ 29 å…­çœè”è€ƒ 2017 åˆ†æ‰‹æ˜¯ç¥æ„¿ åªä¼šåšæ°´é¢˜ã€‚ 30 AGC047F Rooks Portal. å¤ªç²¾å½©å•¦ï¼ ä¸€ä¸ªæš´åŠ›åšæ³•æ˜¯ï¼Œæšä¸¾æ¯ä¸ª sss æ±‚ç­”æ¡ˆï¼Œç„¶åç”¨ä¸€ä¸ª O(n2)O(n^2)O(n2) çš„åŒºé—´ DP ä»£è¡¨åƒæ‰ [i,j][i,j][i,j] å†…çš„è½¦ã€‚ ä½†æ˜¯æˆ‘ä»¬ä¸éœ€è¦å¯¹äºæ¯ä¸ªèµ·ç‚¹éƒ½æ±‚ä¸€éç­”æ¡ˆï¼Œç›´æ¥å°†æ•´ä¸ªåŒºé—´ DP çš„è¿‡ç¨‹å€’è¿‡æ¥å³å¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé¢„å¤„ç†å‡ºæ¯ä¸ªç‚¹èƒ½èµ°åˆ°çš„åŒºé—´ï¼Œç„¶åæ‰©å±•è¿™ä¸ªä¸œè¥¿ã€‚ çŠ¶æ€æ•°æ˜¯ O(n2)O(n^2)O(n2) çš„ï¼Œä¼¼ä¹æ˜¯å°½å¤´ï¼Ÿå¦ï¼è§‚å¯Ÿè½¬ç§»çš„å½¢å¼ï¼Œä¸€å®šå½¢å¦‚ä¸‹å›¾ï¼š çŠ¶æ€æ•°åªæœ‰ O(2n)O(2n)O(2n)ï¼Œç›´æ¥è½¬ç§»å³å¯ã€‚ 31 UVA11671 Sign of Matrix å·®åˆ†çº¦æŸï¼Œç„¶åå‘ç°æ±‚ä¸­ä½æ•°å°±æ˜¯è§£ã€‚ å¤ä¹ æ•´ä½“ DPï¼Œæ ‘ä¸Šå¯å‘å¼åˆå¹¶ï¼ˆé•¿é“¾å‰–åˆ†ï¼‰ç­‰å†…å®¹ï¼","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/23(#33)ï¼šä¸¾æª æ”»å‡» æ›¿ä»£çˆ±æ„","slug":"default/è®°å½•/2024/4/2024-04-23","date":"2024-04-23T00:00:00.000Z","updated":"2024-04-23T00:00:00.000Z","comments":true,"path":"3e29b74b/","link":"","permalink":"https://james1badcreeper.github.io/3e29b74b/","excerpt":"ç»™ç”µè„‘æ¢äº†ä¸ªå£çº¸ï¼Œå¸Œæœ›è‡ªå·±èƒ½å¤Ÿåšå¾—æ›´å¥½ï¼è€Œä¸æ˜¯åƒä¸€ä¸ªæ‘†æ€ªï¼","text":"ç»™ç”µè„‘æ¢äº†ä¸ªå£çº¸ï¼Œå¸Œæœ›è‡ªå·±èƒ½å¤Ÿåšå¾—æ›´å¥½ï¼è€Œä¸æ˜¯åƒä¸€ä¸ªæ‘†æ€ªï¼ 25 IOI2014 å‡æœŸ Portal. é¦–å…ˆèµ°çš„ç­–ç•¥æ˜¯ä¸€å®šçš„ï¼Œä»èµ·ç‚¹å‘å·¦èµ°ä¸€æ®µç„¶åå‘å³ã€‚ç„¶åè¿™ä¸ªæœ‰å†³ç­–å•è°ƒæ€§ï¼Œä¸»å¸­æ ‘é€‰æ‹©å‰ kkk å¤§å³å¯ã€‚ä»£ç ã€‚ 26 CF1290E Cartesian Tree Portal. å»ºå‡ºå¤§æ ¹ç¬›å¡å°”æ ‘ï¼Œå­æ ‘å¤§å°ç›¸å½“äºä»¤å…¶å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå¤§çš„æ•°ä¸º lllï¼Œå³è¾¹ä¸º rrrï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ âˆ‘râˆ’lâˆ’1\\sum r-l-1âˆ‘râˆ’lâˆ’1ã€‚æ‰€æœ‰çš„æ“ä½œéƒ½å¯ä»¥ç”¨ SGT Beats ç»´æŠ¤ã€‚ä»£ç ã€‚ 27 SCOI2016 å¹¸è¿æ•°å­— å€å¢ï¼Œæš´åŠ›åˆå¹¶çº¿æ€§åŸºã€‚ä»£ç ã€‚ 28 Ynoi2014 ä¸å½’ä¹‹äººä¸æœ›çœ¼æ¬²ç©¿çš„äººä»¬ Portal. ä¸ºå•¥æˆ‘ä¸ä¼šå•Šï¼Œç†¬å¤œç†¬å‚»äº†ã€‚ åˆ†å—ç»´æŠ¤å‰ç¼€åç¼€ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨å¤§åŒæŒ‡é’ˆæ‰«äº†ã€‚ æ˜å¤©ç»™è‡ªå·±æ”¾æ¾ä¸€ä¸‹ï¼ŒæŠŠ DP ä¼˜åŒ–ç›¸å…³çš„åšå®¢æ•´ç†ä¸€ä¸‹ï¼é¡ºä¾¿å¸¦ä¸Šè½®å»“çº¿ DPï¼ P3290 è¦å†™ã€‚ è¿‘æœŸè¿˜è¦è¡¥å……çš„çŸ¥è¯†ç‚¹ï¼š æ•°æ®ç»“æ„ï¼šåŠ¨æ€æ ‘åˆ†æ²»ï¼Œè™šæ ‘ï¼Œè«é˜Ÿæ€»ç»“ï¼Œé¢˜ã€‚ æ€»ç»“å›¾è®ºç›¸å…³çš„å†…å®¹ã€‚ DP çŠ¶æ€æ•°ä¼˜åŒ–ç›¸å…³ã€‚ ç®€å•å­—ç¬¦ä¸²ã€‚ æ•°å­¦æ‚é¡¹ã€‚ ç„¶åè¿˜éœ€è¦è®­ç»ƒä¸€äº›æ‚é¢˜ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/22(#32)ï¼šæ”¾çºµçš„æ„Ÿè§‰ è¶…è¶Šä¸€åˆ‡ ä¸å†èƒ†æ€¯","slug":"default/è®°å½•/2024/4/2024-04-22","date":"2024-04-22T00:00:00.000Z","updated":"2024-04-22T00:00:00.000Z","comments":true,"path":"ad383229/","link":"","permalink":"https://james1badcreeper.github.io/ad383229/","excerpt":"ä¸èƒ½å†æ‘†äº†ã€‚","text":"ä¸èƒ½å†æ‘†äº†ã€‚ å¼ºè¿«ç—‡ã€‚ 20 IOI2014 Rail Portal. æƒ³äº†ä¸¤ä¸ªå°æ—¶ç»ˆäºä¼šäº†ï¼Œç›´çº¿æƒ³ä¸‹å»ç®€ç›´æ˜¯æ™ºéšœé¢˜ã€‚ä½†ä¸ºä»€ä¹ˆæˆ‘è¿™ä¹ˆæ…¢å‘¢ï¼Ÿï¼Ÿï¼Ÿ å…ˆé—®ä¸€è½® nnn å¯ä»¥é—®å‡º 000 èµ°åˆ°çš„ç¬¬ä¸€ä¸ªå‘ä¸Šé“é“ï¼Œæ ¹æ®è¿™ä¸ªå¯ä»¥åŒºåˆ†å‡ºåœ¨ 000 å·¦è¾¹è¿˜æ˜¯å³è¾¹ï¼Œç„¶åå‰©ä¸‹çš„é¡ºç€é—®ï¼Œåˆ¤æ–­å®ƒæ˜¯ä¸æ˜¯å…¶ä¸­ä¸€ç§ç±»å‹å³å¯ã€‚ä»£ç ã€‚ 21 IOI2014 Wall Portal. ç›´æ¥åšå°±è¡Œäº†ã€‚ 22 IOI2014 Game æ°´ã€‚ 23 IOI2014 Gondola Portal. ç›´æ¥æ¨¡æ‹Ÿå³å¯ã€‚æ•°æ•°çš„æ—¶å€™æ³¨æ„åˆå§‹æ˜¯å¦ä¹˜ nnnã€‚ä»£ç ã€‚ 24 IOI2014 friend Portal. ç›´æ¥æ²¡æœ‰ä¸Šå¸çš„èˆä¼šï¼Œç¬¬äºŒç§ç›¸å½“äºä¸é€‰ xxxï¼Œé€‰æ‹© yyy æ—¶å°±ç”¨é€‰æ‹©äº† xxx åšé™åˆ¶ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/17(#31)ï¼šé£å¹è¿‡è€³æ— å¤è¿œçš„æ­Œå”±å•Š","slug":"default/è®°å½•/2024/4/2024-04-17","date":"2024-04-17T00:00:00.000Z","updated":"2024-04-17T00:00:00.000Z","comments":true,"path":"a65f0e35/","link":"","permalink":"https://james1badcreeper.github.io/a65f0e35/","excerpt":"â€”â€” å‘¨æ·±ã€Šæµ®å…‰ã€‹","text":"â€”â€” å‘¨æ·±ã€Šæµ®å…‰ã€‹ 16 CF1098D Eels é•¿æˆä¸€ä¸ªå€å¢çš„ç»“æ„ã€‚æˆ‘ä¸ºä»€ä¹ˆæ…¢ä¸€æ‹æ¥ç€ã€‚ 17 JOISC 2023 Council æšä¸¾ä¸€ä¸ªä¸»å¸­ï¼Œè€ƒè™‘å‰¯ä¸»å¸­å¯¹ç­”æ¡ˆçš„å½±å“ï¼šé‚£äº›åªè¦å‰¯ä¸»å¸­ä¸æŠ•ç¥¨å°±æ— æ³•é€šè¿‡çš„ä¸œè¥¿ã€‚è®¾è¿™ä¸ªé›†åˆä¸º SSSï¼Œé‚£ä¹ˆæ‰€æœ‰ SSS çš„å­é›†éƒ½å¯ä»¥ä¸º SSS æ›´æ–°ç­”æ¡ˆã€‚è¿˜æœ‰ SSS çš„è¶…é›†ï¼ä¸€å¼€å§‹å…ˆè·‘é«˜ç»´åç¼€å’Œæ¥å°†åç¼€ SSS ç§»åˆ°å½“å‰ä½ç½®ä¸Šï¼Œç„¶åå†è·‘é«˜ç»´å‰ç¼€ maxâ¡\\maxmax å³å¯ã€‚ä»£ç ã€‚ 18 å¸¦æ’å…¥åŒºé—´ k å° è®¾ si,js_{i,j}si,jâ€‹ ä»£è¡¨å‰ iii ä¸ªå—è½åœ¨ç¬¬ jjj ä¸ªå€¼åŸŸå—çš„æ•°çš„ä¸ªæ•°ï¼Œvi,jv_{i,j}vi,jâ€‹ ä»£è¡¨ iii å—å†…å€¼ä¸º jjj çš„ä¸ªæ•°ã€‚ç„¶åæ‰€æœ‰ä¿¡æ¯éƒ½èƒ½å¤Ÿç»Ÿè®¡ï¼Œå—å¤§çš„æ—¶å€™ç›´æ¥åˆ†è£‚å³å¯ã€‚ 19 AT_wtf19_b Multiple of Nine Portal. å°† lâˆ’1,rl-1,rlâˆ’1,r ç¦»æ•£åŒ–ï¼Œæ’åºä¹‹åç®—ç›¸é‚»ä¹‹é—´çš„å·®ï¼Œè´¡çŒ®æ˜¯ 10yâˆ’xâˆ’19\\dfrac{10^{y-x}-1}{9}910yâˆ’xâˆ’1â€‹ï¼Œè¦ä¹ˆæ˜¯ 10yâˆ’xâˆ’19+1\\dfrac{10^{y-x}-1}{9} + 1910yâˆ’xâˆ’1â€‹+1ï¼Œå½“ä¸”ä»…å½“ sr=slâˆ’1s_r=s_{l-1}srâ€‹=slâˆ’1â€‹ã€‚ ç›¸å½“äºæˆ‘ä»¬åªéœ€è¦è€ƒè™‘æœ‰å“ªäº›ç­‰ä»·ç±»ã€‚é‚£ä¹ˆæšä¸¾ 999 è½®å­é›†ï¼Œç¬¬ kkk è½®ä»£è¡¨æ–°å¢ä¸€ä¸ªé›†åˆæ»¡è¶³ sr=slâˆ’1=ks_r=s_{l-1}=ksrâ€‹=slâˆ’1â€‹=kï¼Œç›´æ¥è®¡ç®—è´¡çŒ®å³å¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/12(#30)ï¼šåƒé‚£å‘¼å•¸è€Œæ¥çš„ç‹‚é£ä¸­é«˜æ­Œçš„æµ·ç‡•","slug":"default/è®°å½•/2024/4/2024-04-12","date":"2024-04-12T00:00:00.000Z","updated":"2024-04-14T00:00:00.000Z","comments":true,"path":"4eb89962/","link":"","permalink":"https://james1badcreeper.github.io/4eb89962/","excerpt":"å‘ç°å¯ä»¥æŠŠ To Do List ç›´æ¥åˆ—åœ¨è¿™é‡Œï¼Œç¬¬äºŒå¤©å¼ºè¿«è‡ªå·±å®Œæˆï¼","text":"å‘ç°å¯ä»¥æŠŠ To Do List ç›´æ¥åˆ—åœ¨è¿™é‡Œï¼Œç¬¬äºŒå¤©å¼ºè¿«è‡ªå·±å®Œæˆï¼ æœ‰ç‚¹æƒ³ã€ã€‘äº†ï¼Œæ€»æ„Ÿè§‰å°‘äº†ç‚¹ä»€ä¹ˆã€‚ è‡ªå·±æ¸ºå°å¾—å¦‚èœ‰è£ï¼Œä¹Ÿæ›¾æƒ³ä»°æœ›å®‡å®™ã€‚ ç„¶åè¢«ç°å®æ‰€æ‰“å‡»ã€‚ ä¸€å®šè¦ä¿æŠ¤å¥½è‡ªå·±çš„ç²¾ç¥ä¸–ç•Œå•Šï¼Œæˆ‘ä»¬éƒ½æ˜¯ã€‚ è°¢è°¢å¤§å®¶çš„é™ªä¼´ï¼Œå¸Œæœ›æˆ‘ä»¬éƒ½èƒ½èµ°åˆ°æœ€åã€‚ æˆ‘ä»¬å°±æ˜¯æˆ‘ä»¬ï¼Œæœ€å¥½çš„è‡ªå·±ï¼Œæ˜¯å®‡å®™ä¸­çš„å”¯ä¸€ï¼ ä¸€äº›æ­Œè¯ï¼š æ˜¨å¤©è¢«åŒ†åŒ†åœ°è£å‰ª ä¸å‰æ—¥ç™½æ˜¼æ¢¦æ‹¼è´´è°éœ€è¦è¿™ä¸è§£é£æƒ…åˆæ½¦è‰çš„æ€»ç»“â€”â€” ã€Šä¸–ç•Œæ²‰ç¡ç«¥è¯ã€‹æƒ³è¿‡ç¦»å¼€ å½“é˜³å…‰è´¥ç»™é˜´éœ¾æ²¡æƒ³åˆ°ä½ ä¼šæ‹¼å‘½ä¸ºæˆ‘æ‹¨å¼€â€”â€” ã€Šå¥½æƒ³çˆ±è¿™ä¸ªä¸–ç•Œå•Šã€‹ç­‰ä¸åˆ°å¤©é»‘çƒŸç«ä¸ä¼šå¤ªå®Œç¾å›å¿†çƒ§æˆç°è¿˜æ˜¯ç­‰ä¸åˆ°ç»“å°¾å¥¹æ›¾è¯´çš„æ— æ‰€è°“æˆ‘æ€•ä¸€å¤©ä¸€å¤©è¢«æ‘§æ¯â€”â€” ã€Šå¥¹è¯´ã€‹æ¢¦æœªæ¯ å°±ç®—å¤œæœ‰ å°½å¤´é†’æ¥å å¼€æ€€äº«å— æ‰€æœ‰é‚£åšå®ˆ æŸä¸€åˆ»åŒ– ä½œ ä¹Œ æœ‰å´è¿˜æœ‰ é‚£äº›æ´—ç¤¼ é‚£å‡ å¥é—®å€™ é‚£ä»½æ¸©æŸ”å°†æŸä¸ªæˆ‘ æ‹¯æ•‘â€”â€” ã€Šè™šå¹»ä¸ç°å®ã€‹ 4 [POI 2023/2024 R1] Zapobiegliwy student Portal. æ¨¡æ‹Ÿé¢˜ã€‚ä»£ç ã€‚ 5 [POI 2023/2024 R1] Satelity Portal. ç‰¹æŠ€å¡å¸¸æ•°é¢˜ï¼Œå†™åˆ° M=n+2M=n+2M=n+2 æ‘†çƒ‚äº†ã€‚ä»£ç ã€‚ 6 ä¸å¼ºåˆ¶åœ¨çº¿çš„åŠ¨æ€å¿«é€Ÿæ’åº Portal. è¿™ä¸ªä¸œè¥¿å¯ä»¥ç›´æ¥è®¡ç®—ï¼ŒåŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ç»´æŠ¤ä¸€ä¸‹å³å¯ã€‚ä»£ç ã€‚ 7 CF698F Coprime Permutation Portal. ä¸¤ä¸ªè´¨å› æ•°é›†åˆç›¸åŒçš„æ•°å¯ä»¥éšä¾¿æ¢ï¼Œå†å°±æ˜¯ n/pn/pn/p ç›¸åŒçš„è´¨æ•° ppp å¯ä»¥å°†å€æ•°ä¸€èµ·æ¢ï¼ˆç‰¹åˆ¤ n/p=1n/p=1n/p=1 è¿˜å¯ä»¥å’Œ 111 æ¢ï¼‰ã€‚ å¤„ç†çš„æ—¶å€™ç›´æ¥åˆ¤æ–­é™¤äº†å¤§è´¨æ•°å› å­æ˜¯å¦ç›¸ç­‰ï¼Œåé¢è®°å½•æ˜¯å¦å·²ç»äº¤æ¢å³å¯ã€‚ä»£ç ã€‚ ByteDance-Moscow Workshops Camp 2022. The Final Contest çš„é¢˜ã€‚æ„Ÿè§‰è´¨é‡è¿˜æ˜¯æ¯”è¾ƒé«˜çš„ã€‚ è‰æ‘†å¤§äº†å†™ä¸å®Œäº†ï¼Œæ˜å¤©åœ¨è¿™é‡Œæ¥ç€å†™ã€‚ 8 B. Longest Increasing Subsequence æŒºå¥½çš„ç­¾åˆ°é¢˜ï¼Œå½“æ—¶åœ¨å¹²ä»€ä¹ˆå‘¢ï¼Ÿ è®¾æ¯æ¬¡æ“ä½œç”Ÿæˆçš„æ•°åˆ—ä¸º Si,0,â‹¯ ,Si,ciS_{i,0},\\cdots,S_{i,c_i}Si,0â€‹,â‹¯,Si,ciâ€‹â€‹ï¼Œé‚£ä¹ˆ ci=logâ¡(ai+1âˆ’ai)c_i=\\log (a_{i+1}-a_i)ciâ€‹=log(ai+1â€‹âˆ’aiâ€‹)ã€‚ç›´æ¥ DPï¼Œæ³¨æ„ä¸€åˆ—å¯ä»¥å°†ä¸¤ä¸ª Si,jâˆ’1,Si,jS_{i,j-1},S_{i,j}Si,jâˆ’1â€‹,Si,jâ€‹ æ‹¼èµ·æ¥ï¼ˆå…¶ä¸­ä¸€ä¸ªé€‰ä¸€ä¸ªï¼‰ã€‚ä»£ç ã€‚ 9 C. New Equipments III è¯¥å®Œå–„ä¸€ä¸‹ç½‘ç»œæµçš„éƒ¨åˆ†äº†ã€‚ 10 G. Factor 11 H. Graph Operation 12 I. Optimal Assortment å‘ç°ç›¸å½“äºåŠ¨æ€ 01 åˆ†æ•°è§„åˆ’ï¼Œç›´æ¥çº¿æ®µæ ‘äºŒåˆ†ï¼Œæ³¨æ„ç‰¹åˆ¤ R0=0R_0=0R0â€‹=0ã€‚ä»£ç ã€‚ 13 J. Cell Tower çœ‹ä¸Šå»ä¸é”™çš„é¢˜ï¼Œåšå®Œä¹‹åæŠŠåˆå¹¶ä¹¦æœ¬ä¹Ÿç»™åšäº†ã€‚ æœ‰æ•ˆçŠ¶æ€åªæœ‰ 2Ã—1062\\times 10^62Ã—106 ä¸ªï¼Œç›´æ¥è½¬ç§»å³å¯ã€‚map ä¼š TLEï¼Œunordered_map ä¸ä¼šï¼ŒçœŸçš„æ˜¯å¤ªä¼˜ç§€å•¦ï¼ä»£ç ã€‚ 14 K. Xiangqi 15 D. Interesting String Problem æˆ‘ä¼šå»å­¦ä¹ ä¸€ä¸‹å­—ç¬¦ä¸²çŸ¥è¯†ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/08(#29)ï¼šæˆ‘æ„Ÿåº”è¿™æµ·å•¸æ‚²å‡‰ æ‹†ç¢è¿™åº§ä¸‡ç±çš„ç‰¢æˆ¿","slug":"default/è®°å½•/2024/4/2024-04-08","date":"2024-04-08T00:00:00.000Z","updated":"2024-04-08T00:00:00.000Z","comments":true,"path":"1ef201c2/","link":"","permalink":"https://james1badcreeper.github.io/1ef201c2/","excerpt":"Come onï¼","text":"Come onï¼ 1 CF1364E X-OR Portal. ä¹‹å‰è§è¿‡ã€‚ç›´æ¥éšæœºå°±è¡Œã€‚ 2 CF1439B Graph Subset Problem Portal. å¦‚æœå›¢å­˜åœ¨ï¼Œkkk åªæœ‰ O(m)O(\\sqrt{m})O(mâ€‹)ï¼Œé‚£ä¹ˆå¯ä»¥æš´åŠ›ã€‚æœ€ååªç•™ä¸‹åº¦æ•° â‰¥k\\ge kâ‰¥k çš„ç‚¹å³å¯ã€‚ 3 CF925D Aztec Catacombs Portal. å¦‚æœæœ€çŸ­è·¯ â‰¤4\\le 4â‰¤4 å°±ç›´æ¥ç”¨æœ€çŸ­è·¯ï¼Œå¦åˆ™ 1â†’n1\\to n1â†’n çš„è¾¹ä¸å­˜åœ¨ï¼Œå¯èƒ½å­˜åœ¨ä¸€ç»„å½¢å¦‚ 1â†’xâ†’yâ†’xâ†’n1\\to x\\to y\\to x\\to n1â†’xâ†’yâ†’xâ†’n çš„è§£ï¼Œå¦åˆ™å°±åªèƒ½å­˜åœ¨ 1â†’xâ†’yâ†’zâ†’xâ†’n1\\to x\\to y\\to z\\to x\\to n1â†’xâ†’yâ†’zâ†’xâ†’n çš„è§£äº†ã€‚ æ­¤æ—¶çš„ 1â†’x1\\to x1â†’x èƒ½åˆ°è¾¾æ‰€æœ‰çš„ xxxï¼Œå› ä¸ºå¦‚æœä¸èƒ½ç›´æ¥åˆ°è¾¾ï¼Œå¯ä»¥åœ¨ 1â†’x1\\to x1â†’x çš„è·¯å¾„ä¸­é—´æ‰¾ä¸€ä¸ª yyy å½¢æˆ 1â†’yâ†’xâ†’1â†’n1\\to y\\to x\\to 1\\to n1â†’yâ†’xâ†’1â†’n çš„æ›´ä¼˜ç­”æ¡ˆï¼Œå› æ­¤è¿™æ ·åšå¯ä»¥éå†æ‰€æœ‰çš„ä¸‰å…ƒç¯ï¼Œæ­£ç¡®æ€§å¾—åˆ°ä¿è¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/07(#28)ï¼šç”¨æ¸—é€çš„å¢¨æ°´æ¥è½»è½»æç»˜","slug":"default/è®°å½•/2024/4/2024-04-05","date":"2024-04-05T00:00:00.000Z","updated":"2024-04-07T00:00:00.000Z","comments":true,"path":"4b668530/","link":"","permalink":"https://james1badcreeper.github.io/4b668530/","excerpt":"è¯¥å·å·äº†ã€‚","text":"è¯¥å·å·äº†ã€‚ [CF293C] Cube Problem Dino Bot æ˜¨å¤©çš„æ—¥æ¨é¢˜ã€‚ä»£ç ã€‚ [Ynoi2011] ODT Portal. æ¯ä¸ªç‚¹ç»´æŠ¤ä¸€æ£µ Treapï¼Œç„¶ååªç»´æŠ¤è½»å„¿å­çš„ä¿¡æ¯å³å¯ã€‚ [CF715E] Complete the Permutations Portal. è¾¹å¯ä»¥åˆ†ä¸ºå››ç§ç±»å‹ï¼Œaâ†’b,aâ†’0,0â†’b,0â†’0a\\rightarrow b,a\\rightarrow 0,0\\rightarrow b,0\\rightarrow 0aâ†’b,aâ†’0,0â†’b,0â†’0ã€‚ è®°åä¸‰ç§è¾¹çš„æ•°é‡ä¸º n1,n2,mn_1,n_2,mn1â€‹,n2â€‹,mã€‚aâ†’0a\\rightarrow 0aâ†’0 è¾¹æœ‰ä¸¤ç§é€‰æ‹©ï¼Œèè¿› 0â†’00\\rightarrow 00â†’0ï¼Œæˆ–è€…è‡ªæˆ‘åˆå¹¶ã€‚æ–¹æ¡ˆæ•°æ˜¯ï¼š F1[k]=âˆ‘i=kn1(n1i)[ik](n1+mâˆ’iâˆ’1)n1âˆ’iâ€¾F_1[k]=\\sum\\limits_{i=k}^{n_1}\\dbinom{n_1}{i}\\begin{bmatrix}i\\\\k\\end{bmatrix}(n_1+m-i-1)^{\\underline{n_1-i}} F1â€‹[k]=i=kâˆ‘n1â€‹â€‹(in1â€‹â€‹)[ikâ€‹](n1â€‹+mâˆ’iâˆ’1)n1â€‹âˆ’iâ€‹ F3F_3F3â€‹ ç›´æ¥ç®—ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•°ï¼Œç„¶åå¯ä»¥å…¨æ’åˆ— mmmã€‚æš´åŠ›å·å³å¯ã€‚ä»£ç ã€‚ [AGC040F] Two Pieces Portal. ä»£æ•°æ¨å¯¼å¤©åœ°ç­ã€‚ è€ƒè™‘æ²¡æœ‰ 222 æ“ä½œæ€ä¹ˆåšã€‚ä¸ºäº†é¿å…é‡å¤è®¡æ•°ï¼Œå¼ºåˆ¶è®© a,ba,ba,b è·ç¦» â‰¥1\\ge 1â‰¥1ï¼ˆæˆ‘ä»¬åªåŒºåˆ†æ“ä½œæ—¶çš„ä½ç½®ï¼Œå› æ­¤ =0=0=0 çš„ä¼šåœ¨è€ƒè™‘ 222 æ“ä½œæ—¶ç»Ÿè®¡ï¼‰ã€‚åå°„å®¹æ–¥åšä¸€ä¸‹å³å¯ã€‚ è€ƒè™‘åŠ å…¥æ“ä½œ 222ã€‚è€ƒè™‘æšä¸¾ä¸€æ¬¡æ“ä½œ 222 é€ æˆçš„ç§»ç‚¹è´¡çŒ®ï¼Œä¹Ÿå°±æ˜¯æšä¸¾æœ€åä¸€æ¬¡è¿›è¡Œæ“ä½œ 222 æ—¶çš„ k=xâˆ’yk=x-yk=xâˆ’yï¼Œé‚£ä¹ˆå¯ä»¥è§†ä½œå°†ç»ˆç‚¹æ‹‰åˆ° (A,Bâˆ’k)(A,B-k)(A,Bâˆ’k)ï¼Œå°†æ­¤è§†ä¸ºæ–°çš„æ ¼è·¯ã€‚ å°†å‰©ä½™çš„ nâˆ’Aâˆ’(Bâˆ’k)âˆ’1n-A-(B-k)-1nâˆ’Aâˆ’(Bâˆ’k)âˆ’1 ä¸ª 333 æ“ä½œåˆ†é…åˆ°æ“ä½œåºåˆ—ä¸­ï¼Œå®é™…ä¸Šæ˜¯è¦ç»™åˆ° k+1k+1k+1 ä¸ªç‚¹ï¼ˆåœ¨å®ƒä»¬èº«ä¸Šè¿›è¡Œ 333 æ“ä½œï¼‰ï¼Œå®ƒä»¬æ˜¯ç›´çº¿ y=xâˆ’dy=x-dy=xâˆ’dï¼ˆdâˆˆ[0,k]d\\in [0,k]dâˆˆ[0,k]ï¼Œd&gt;kd&gt;kd&gt;k è¶Šè¿‡äº†ä¹‹å‰é’¦å®šçš„æœ€åä¸€æ¬¡ 333 æ“ä½œï¼‰ä¸æ–°çš„æ ¼è·¯çš„æœ€åä¸€ä¸ªäº¤ç‚¹ï¼Œåªæœ‰æœ€åä¸€ä¸ªäº¤ç‚¹æ˜¯åˆæ³•çš„ï¼Œå¦åˆ™ä¼šæœ‰å°† yyy åæ ‡ +1 ç±»çš„æ“ä½œæ— æ³•è¿›è¡Œã€‚åˆ†é…ä¹‹åï¼Œä¼šå°†ç§»åŠ¨ kkk çš„è´¡çŒ®åˆ†æ‘Šæ‰ã€‚ ç‰¹åˆ¤ A+B=nA+B=nA+B=n çš„æƒ…å†µå³å¯ã€‚ä»£ç ã€‚ L. Completely Multiplicative Function Portal. ç›´æ¥ä»å°è´¨æ•°è´ªå³å¯ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆæ˜¯å¯¹ï¼ˆæˆ–è€…æ•°æ®æ°´ï¼‰çš„ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/03(#27)ï¼šå¼¹æŒ‡é—´æ¹®ç­æˆ‘ ä½†å‘½è¿æ‰“ä¸è´¥æ´»ç€","slug":"default/è®°å½•/2024/4/2024-04-02","date":"2024-04-02T00:00:00.000Z","updated":"2024-04-03T00:00:00.000Z","comments":true,"path":"bb2987d9/","link":"","permalink":"https://james1badcreeper.github.io/bb2987d9/","excerpt":"æ‘˜è¦ï¼šæ— ã€‚","text":"æ‘˜è¦ï¼šæ— ã€‚ è®©ç”Ÿå‘½å¦‚å‰§çƒˆçš„çƒŸç« / ç’€ç’¨ç†„ç­å‰ä¹Ÿå°†ç‚¹äº® / å­©ç«¥çš„åŒçœ¸ æ„Ÿè§‰è¿˜æ˜¯è¢«è´Ÿèƒ½é‡ä¸»å¯¼äº†å•Šã€‚ æˆ‘æœªæ›¾æƒ³è¿‡è‡ªå·±ä¼šæœ‰è¿™ä¸ªé—®é¢˜ï¼Œæ›¾å¤¸ä¸‹æµ·å£è¯´è‡ªå·±â€œæ¯”ä¸€èˆ¬äººçš„æŠ—æŒ«èƒ½åŠ›æ›´å¼ºâ€ï¼Œä½†ç°åœ¨çœ‹æ¥ï¼Œæˆ‘ä¹Ÿåªæ˜¯è‡­é±¼çƒ‚è™¾ç½¢äº†ã€‚ ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Ÿæˆ‘èƒ½æƒ³åˆ°çš„æ˜¯è‡ªå·±çš„èƒ½åŠ›ä¸ç°å®çš„å·¨å¤§å·®è·ï¼Œä½†è¿™æ—¶å€™ç†åº”çˆ†å‘å‡ºæ›´åŠ å¼ºå¤§çš„æ‰§è¡ŒåŠ›ï¼Œè€Œä¸æ˜¯åœ¨åŸåœ°ç­‰å¾…ã€‚ ä¸åƒé¥­ï¼Ÿè¿˜æœ‰å¯¹å…¥çœ çš„ææƒ§æ„Ÿï¼Ÿ æ²¡æœ‰é€‰æ‹©â€œåœ¨å½“å‰å±€é¢ä¸‹æ›´ä¼˜çš„è§£å†³åŠæ³•â€ï¼Œç”¨ä¸€ä¸ªæˆ‘éå¸¸ä¸æƒ³ç”¨åœ¨æˆ‘è‡ªå·±èº«ä¸Šçš„å½¢å®¹è¯ï¼Œè‡ªæš´è‡ªå¼ƒã€‚ å°†å®ƒä»¬ä¿®å¤ã€æŠ¹é™¤æ‰ã€‚æ²¡æœ‰ä»€ä¹ˆæ˜¯æˆ‘åšä¸åˆ°çš„ã€‚ ç¥ç½šå¹¶æ²¡æœ‰åœæ­¢ï¼Œç©ºå‰çš„ç»æœ›å¦‚æœŸè€Œè‡³ã€‚ä½†æ˜¯å¾ˆå¯æƒœï¼Œæˆ‘çš„åå­—å«ä¸æ­»ä¹‹äººã€‚ [USACO20OPEN] Circus P | AGC066E Portal. é¦–å…ˆï¼Œå¥¶ç‰›ä¹‹é—´æ²¡æœ‰åŒºåˆ«ï¼Œæˆ‘ä»¬æ€»å¯ä»¥ç§»åŠ¨è¿™äº›å¥¶ç‰›ä½¿å¾—å®ƒä»¬åˆ°è¾¾å‰ KKK ä¸ªç‚¹ã€‚ K=iK=iK=i æ—¶ï¼Œç­”æ¡ˆçš„ä¸Šç•Œæ˜¯ i!i!i!ï¼Œä½†æ˜¯æ— æ³•è¾¾åˆ°ï¼ŒåŸå› æ˜¯å­˜åœ¨ä¸€äº›ä½ç½®å¯¹ (x,y)(x,y)(x,y) å®ƒä»¬å¯ä»¥åœ¨ä¸æ”¹å˜å…¶å®ƒå¥¶ç‰›çš„ä½ç½®çš„å‰æä¸‹è¿›è¡Œäº¤æ¢ï¼Œé‚£ä¹ˆå¯¹å®ƒä»¬è¿è¾¹ï¼Œå®ƒä»¬ä¼šæ„æˆä¸€äº›å›¢ï¼Œè®¾å›¢çš„å¤§å°ä¸º sis_isiâ€‹ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ k!/âˆsi!k!/\\prod s_i!k!/âˆsiâ€‹!ã€‚ è€ƒè™‘ä¸€æ¡è·¯å¾„ï¼Œä¸¤ç«¯ä¸ä¸ºäºŒåº¦ç‚¹ï¼Œä¸­é—´å…¨ä¸ºäºŒåº¦ç‚¹ã€‚è®¾å…¶å·¦ç«¯ç‚¹çš„å­æ ‘å¤§å°ä¸º AAA å³è¾¹ä¸º BBB é“¾ä¸Šæœ‰ CCC ä¸ªç‚¹ï¼Œå½“ xâ†’yx\\rightarrow yxâ†’y ä¸Šçš„æ‰€æœ‰é“¾éƒ½æ»¡è¶³ k&lt;Aâˆ’1+Bâˆ’1=nâˆ’Ck&lt;A-1+B-1=n-Ck&lt;Aâˆ’1+Bâˆ’1=nâˆ’C åˆ™å¯ä»¥è¿é€šã€‚ å°†æ ‘ä¸Šçš„äºŒåº¦ç‚¹è·¯å¾„ç¼©èµ·æ¥æˆä¸ºä¸€æ£µæ–°æ ‘ã€‚å°†æ‰€æœ‰ kâ‰¥nâˆ’Ck\\ge n-Ckâ‰¥nâˆ’C çš„è¾¹æ–­æ‰ï¼Œå‰©ä¸‹çš„æ¯ä¸ªè¿é€šå—å°±éƒ½æ˜¯å›¢ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—æ¯ä¸ªè¿é€šå—å¯¹åº”çš„å›¢çš„å¤§å°ï¼ˆæœ‰å¤šå°‘ä¸ªå¥¶ç‰›åœ¨è¿™é‡Œé¢å¯ä»¥äº’æ¢ï¼‰ã€‚ è®¾è¿é€šå—å†…çš„å­æ ‘ä¸º BBBï¼Œé‚£ä¹ˆæˆ‘ä»¬è®©å…¶å¡«æ»¡ï¼Œæ— æ³•è¿æ¥åˆ°è¿é€šå—çš„ç‚¹çš„æ•°é‡ä¸ºï¼š kâˆ’âˆ‘(kâˆ’(Bâˆ’1))= kâˆ’âˆ‘(kâˆ’(nâˆ’Câˆ’A+1))= kâˆ’âˆ‘(kâˆ’(nâˆ’1âˆ’p))\\begin{aligned} &amp; k - \\sum (k-(B-1))\\\\ =\\ &amp; k-\\sum(k-(n-C-A+1))\\\\ =\\ &amp; k-\\sum(k-(n-1-p))\\\\ \\end{aligned} = = â€‹kâˆ’âˆ‘(kâˆ’(Bâˆ’1))kâˆ’âˆ‘(kâˆ’(nâˆ’Câˆ’A+1))kâˆ’âˆ‘(kâˆ’(nâˆ’1âˆ’p))â€‹ å…¶ä¸­ ppp è¿æ¥åˆ°å½“å‰è¿é€šå—å¤–çš„é‚£ä¸ªçš„å­æ ‘å¤§å°ï¼Œ111 æ˜¯è¿æ¥ç‚¹ï¼ˆåœ¨è¿é€šå—å†…ï¼‰ï¼Œä¸éš¾å‘ç° âˆ‘p=âˆ‘nâˆ’x\\sum p=\\sum n - xâˆ‘p=âˆ‘nâˆ’xã€‚ æœ€åç”¨ kkk å‡å»å°±æ˜¯å›¢çš„å¤§å°ã€‚ç”±äºé“¾é•¿æ€»å’Œæ˜¯ O(n)O(n)O(n) çš„ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚ä»£ç ã€‚ å¯¹äº AGC066Eï¼Œæ²¡æœ‰æœ¬è´¨åŒºåˆ«ã€‚ç­”æ¡ˆçš„ä¸‹ç•Œæ˜¯ (nk)\\binom n k(knâ€‹)ï¼ˆå“ªäº›ä½ç½®æ”¾çŸ³å¤´ï¼‰ï¼Œåˆ°æœ€ç»ˆå±€é¢ä¸‹æ¯ä¸ªå›¢å†…éƒ¨å¯ä»¥ä»»æ„æ’åˆ—çš„ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/01(#26)ï¼šæ¸ºå°å¾—å¦‚èœ‰è£ ä¹Ÿä»°æœ›ç€å®‡å®™","slug":"default/è®°å½•/2024/4/2024-04-01","date":"2024-04-01T00:00:00.000Z","updated":"2024-04-01T00:00:00.000Z","comments":true,"path":"dfe8ff4c/","link":"","permalink":"https://james1badcreeper.github.io/dfe8ff4c/","excerpt":"å‘¨æ·±å¤ªç‰›äº†ã€‚","text":"å‘¨æ·±å¤ªç‰›äº†ã€‚ æœ‰é‚£ç§ä¸Šå¸æ„Ÿäº†ã€‚ ç”Ÿå‘½ä½•å°ä¸æ˜¯ä»ä¹Œæœ‰åˆ°ä¹Œæœ‰ï¼Œå¯¹å¾—èµ·è‡ªå·±å—ï¼Ÿ æ²¡æœ‰é€€è·¯å¯è¨€ã€‚ [ABC347F] Non-overlapping Squares Portal. å¡ Cï¼Œå¡ C [ABC347G] Grid Coloring 2 Portal. åˆ‡ç³•ã€‚ [AGC066A] Adjacent Difference Portal. æ€ä¹ˆè¿™ä¹ˆæŠ½è±¡ã€‚ ç”± 12\\frac 1 221â€‹ çš„é™åˆ¶ä¸éš¾æƒ³åˆ°è¿›è¡Œé»‘ç™½æŸ“è‰²ï¼Œé‚£ä¹ˆåªéœ€è¦æ”¹æˆ mod 2d=0 or d\\bmod\\ 2d=0 \\text{ or } dmod 2d=0 or d å³å¯ã€‚ç”±äºä»£ä»·å’Œæ˜¯ dn2dn^2dn2ï¼Œå› æ­¤å¿…æœ‰ä¸€ç§é»‘ç™½æŸ“è‰²æ–¹æ¡ˆæ»¡è¶³ã€‚ä»£ç ã€‚ [AGC066B] Decreasing Digit Sums Portal. ans=550ans=5^{50}ans=550 çš„æ—¶å€™å¾ˆåƒç­”æ¡ˆï¼Œä½†æ˜¯æœ‰å™ªå£°ã€‚å¯ä»¥é€‰æ‹© âˆ‘kÃ—550\\sum k\\times 5^{50}âˆ‘kÃ—550 ä½œä¸ºç­”æ¡ˆï¼Œå…¶ä¸­ kkk æ˜¯å‡ ç™¾ä¸ªéšæœºæ•´æ•°ã€‚ ä¹Ÿå¯ä»¥ç®€å•çš„é€‰æ‹© 5,52,535,5^2,5^35,52,53 çš„æ‹¼æ¥ä½œä¸ºç­”æ¡ˆï¼Œè¿™å¯ä»¥è§†ä¸ºå™ªå£°çš„æ¶ˆé™¤ã€‚ç”±äº nnn åªæœ‰ 505050ï¼Œå› æ­¤è¿™æ ·å®Œå…¨æ²¡é—®é¢˜ã€‚ [AGC066C] Delete AAB or BAA Portal. ä¸éš¾è€ƒè™‘å¯¹è¿™ä¸ªä¸œè¥¿è®¾è®¡ DPã€‚è®¾ fif_ifiâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªå­—ç¬¦è¿˜å‰©å¤šå°‘ä¸èƒ½åˆ æ‰çš„ä¸œè¥¿ã€‚é‚£ä¹ˆå¦‚æœ [i+1,j][i+1,j][i+1,j] éƒ½èƒ½åˆ æ‰ï¼Œé‚£ä¹ˆ fjâ†fif_j\\leftarrow f_ifjâ€‹â†fiâ€‹ã€‚ å¦‚ä½•æ‰¾åˆ°èƒ½å®Œæ•´åˆ æ‰çš„æ®µï¼Ÿå……è¦æ¡ä»¶æ˜¯ï¼Œå¯ä»¥åˆ†è§£æˆè‹¥å¹²ä¸ªèƒ½åˆ é™¤çš„å­æ®µï¼Œå¹¶ä¸”å­æ®µçš„å·¦ç«¯æˆ–è€…å³ç«¯æ˜¯ Bã€‚ç›´æ¥ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/03/25(#25)ï¼šç»å—çš„ä¸€åˆ‡ï¼Œç»å¯¹æ˜¯æœ‰æ„ä¹‰çš„","slug":"default/è®°å½•/2024/3/2024-03-25","date":"2024-03-25T00:00:00.000Z","updated":"2024-03-25T00:00:00.000Z","comments":true,"path":"6d4ac666/","link":"","permalink":"https://james1badcreeper.github.io/6d4ac666/","excerpt":"è¢«æ‰“çˆ†äº†ã€‚","text":"è¢«æ‰“çˆ†äº†ã€‚ [USACO24OPEN] Identity Theft P Portal. å»ºå‡º Trieï¼Œç„¶åç›¸å½“äºæ‰€æœ‰çš„ç‚¹éƒ½éœ€è¦ç§»åŠ¨åˆ°å¶å­ï¼Œè´ªå¿ƒå³å¯ã€‚ä»£ç ã€‚ [ARC111D] Orientation Portal. ç›´æ¥å®šå‘ï¼Œå¦åˆ™å°±æ˜¯æœ‰ç¯ã€‚ä»£ç ã€‚ [ARC114C] Sequence Scores Portal. è€ƒè™‘ç»™åºåˆ— AAA æœ«å°¾åŠ ä¸Šä¸€ä¸ªæ•° jjj çš„è´¡çŒ®ï¼Œåªæœ‰å½“ âˆ€p&gt;lsti\\forall p&gt;lst_iâˆ€p&gt;lstiâ€‹ï¼Œéƒ½æœ‰ ap&gt;ja_p&gt;japâ€‹&gt;jï¼Œæœ€å°æ“ä½œæ•°æ‰ä¸å˜ï¼Œé‚£ä¹ˆè´¡çŒ® fi,xf_{i,x}fi,xâ€‹ å¯ä»¥è¡¨è¾¾ä¸ºï¼š fi,x=miâˆ’1âˆ’âˆ‘k=1iâˆ’1(mâˆ’x)iâˆ’kâˆ’1Ã—mkâˆ’1f_{i,x} = m^{i-1}-\\sum_{k=1}^{i-1}(m-x)^{i-k-1} \\times m^{k-1} fi,xâ€‹=miâˆ’1âˆ’k=1âˆ‘iâˆ’1â€‹(mâˆ’x)iâˆ’kâˆ’1Ã—mkâˆ’1 ç„¶åæ ¹æ® fff è®¡ç®—å‡º ansansans å³å¯ã€‚ä»£ç ã€‚ [ARC114E] Paper Cutting 2 Portal. å’Œ CF1924E å‡ ä¹ä¸€è‡´ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/03/23(#24)ï¼šå‘å‘½è¿æ‹’ç»åœ¨é»‘æš—ä¸­æ¹®ç­","slug":"default/è®°å½•/2024/3/2024-03-15","date":"2024-03-15T00:00:00.000Z","updated":"2024-03-23T00:00:00.000Z","comments":true,"path":"4f7132d9/","link":"","permalink":"https://james1badcreeper.github.io/4f7132d9/","excerpt":"å†æ¥ä¸€æ¬¡å§ï¼","text":"å†æ¥ä¸€æ¬¡å§ï¼ [CF1707E] Replace Portal. é¦–å…ˆç­”æ¡ˆä¸Šç•Œæ˜¯ 2n2n2nï¼Œå¤§æ¦‚æ˜¯å…ˆè½¬ä¸€åœˆç„¶åå†ä¾æ¬¡æ‰©å±•ã€‚ æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ª f2k(l,r)f^{2^k}(l,r)f2k(l,r) æ¥ç”¨äºåœ¨è¯¢é—®çš„æ—¶å€™å¿«é€Ÿå›ç­”ï¼Œä½†æ˜¯ (l,r)(l,r)(l,r) çš„æ•°é‡æ˜¯çˆ†ç‚¸çš„ O(n2)O(n^2)O(n2)ã€‚ç°åœ¨çš„é—®é¢˜æ˜¯å¦‚ä½•å‡å°‘ f(l,r)f(l,r)f(l,r) éœ€è¦çš„æ•°é‡ã€‚ æ‰€ä»¥è¦æ‰¾æ€§è´¨ã€‚æˆ‘ä»¬æœ‰åœ¨ [l1,r1][l_1,r_1][l1â€‹,r1â€‹] å’Œ [l2,r2][l_2,r_2][l2â€‹,r2â€‹] æœ‰äº¤æ—¶ï¼Œä»¤ [l,r]=[l1,r1]âˆª[l2,r2][l,r] = [l_1,r_1]\\cup [l_2,r_2][l,r]=[l1â€‹,r1â€‹]âˆª[l2â€‹,r2â€‹]ï¼Œé‚£ä¹ˆ fk([l,r])=fk([l1,r1])âˆªfk([l2,r2])f^k ([l,r])=f^k ([l_1,r_1]) \\cup f^k ([l_2,r_2])fk([l,r])=fk([l1â€‹,r1â€‹])âˆªfk([l2â€‹,r2â€‹])ã€‚ å› ä¸ºå®ƒä»¬çš„å€¼åŸŸç›¸äº¤ï¼Œæ‰€ä»¥ f(l1,r1)âˆ©f(l2,r2)â‰ âˆ…f (l_1,r_1) \\cap f (l_2,r_2)\\ne \\varnothingf(l1â€‹,r1â€‹)âˆ©f(l2â€‹,r2â€‹)î€ =âˆ…ï¼Œè€Œåœ¨å®ƒä»¬æœ‰äº¤é›†çš„å‰æä¸‹ï¼Œæœ‰ f(l1,r1)âˆªf(l2,r2)=f(minâ¡{l1,l2},maxâ¡{r1,r2})f (l_1,r_1) \\cup f (l_2,r_2)=f(\\min\\{l_1,l_2\\},\\max\\{r_1,r_2\\})f(l1â€‹,r1â€‹)âˆªf(l2â€‹,r2â€‹)=f(min{l1â€‹,l2â€‹},max{r1â€‹,r2â€‹})ï¼Œå¯¹è¿™ä¸ªä¸œè¥¿è¿›è¡Œæ•°å­¦å½’çº³ï¼Œæ‰€ä»¥ä¸Šé¢çš„é‚£ä¸ªæ˜¯å¯¹çš„ã€‚ ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬ä½¿ç”¨ ST è¡¨ç»´æŠ¤æ¯ä¸ª f2kf^{2^k}f2k çš„å€¼å³å¯ï¼Œå†…éƒ¨çš„æ•°é‡çº§ä» O(n2)O(n^2)O(n2) é™ä½åˆ°äº† O(nlogâ¡n)O(n\\log n)O(nlogn)ï¼Œæ€»æ—¶é—´å¤æ‚åº¦ O((n+q)logâ¡2n)O((n+q)\\log ^2 n)O((n+q)log2n)ã€‚ä»£ç ã€‚ [CF1844G] Tree Weights Portal. è€ƒè™‘ä¾æ¬¡å¯¹æ–¹ç¨‹åœ¨æ¨¡ 2k2^k2k æ„ä¹‰ä¸‹è¿›è¡Œæ±‚è§£ï¼Œç„¶åé€’æ¨å³å¯ã€‚ä»£ç ã€‚ [CF1918F] Caterpillar on a Tree Portal. ç›´æ¥è´ªå¿ƒå°±è¡Œäº†ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/03/13(#23)ï¼šæ˜Ÿè§£","slug":"default/è®°å½•/2024/3/2024-03-13","date":"2024-03-13T00:00:00.000Z","updated":"2024-03-13T00:00:00.000Z","comments":true,"path":"3eb73673/","link":"","permalink":"https://james1badcreeper.github.io/3eb73673/","excerpt":"åŠ è®­ã€‚","text":"åŠ è®­ã€‚ [CF1091G] New Year and the Factorisation Collaboration Portal. è¯¢é—® sqrt(x * x)ï¼Œæˆ‘ä»¬æœ‰ (xâˆ’y)(x+y)â‰¡0(modn)(x-y)(x+y)\\equiv 0\\pmod n(xâˆ’y)(x+y)â‰¡0(modn)ã€‚æ’é™¤å…¶ä¸­æœ‰ 000 å’Œ nnn çš„æƒ…å†µï¼Œè¿™æ ·æˆ‘ä»¬å°† nnn çš„è´¨å› å­åˆ†æˆä¸¤ç»„ S1S_1S1â€‹ã€‚ ä¸€ä¸ªè´¨å› æ•° pip_ipiâ€‹ èƒ½è¢«æ±‚å‡ºï¼Œä»…å½“æ‰€æœ‰ pj(jâ‰ i)p_j(j\\ne i)pjâ€‹(jî€ =i)ï¼Œå­˜åœ¨ä¸€ä¸ª SSS ä½¿å¾— pjp_jpjâ€‹ åœ¨ SSS ä¸­å‡ºç°ä½† pip_ipiâ€‹ æœªå‡ºç°ï¼ˆæ³¨æ„ S=1S=1S=1 æ˜¯åºŸç¥¨ï¼‰ã€‚ åˆ†è§£æˆ kkk ä¸ª x2âˆ’xâ€²2â‰¡0(modpi)x^2-x&#x27;^2\\equiv 0\\pmod {p_i}x2âˆ’xâ€²2â‰¡0(modpiâ€‹)ï¼Œå¯ä»¥å¾—çŸ¥æ¨¡ nnn æ„ä¹‰ä¸‹çš„äºŒæ¬¡å‰©ä½™æœ‰ 2k2^k2k ä¸ªï¼Œä½†æ˜¯äº¤äº’åº“å¹¶ä¸çŸ¥é“æˆ‘ä»¬çš„ xxx æ˜¯å“ªä¸ªï¼Œå› æ­¤æœ‰ 1âˆ’2âˆ’k1-2^{-k}1âˆ’2âˆ’k çš„æ¦‚ç‡è¿”å›ä¸€ä¸ªä¸åŒçš„ã€‚ åŒæ—¶ï¼Œpip_ipiâ€‹ åœ¨ xâˆ’xâ€²x-x&#x27;xâˆ’xâ€² é‡Œæ—¶ï¼Œpjp_jpjâ€‹ ä¹Ÿåœ¨ xâˆ’xâ€²x-x&#x27;xâˆ’xâ€² çš„æ¦‚ç‡æ˜¯ 50%50\\%50%ï¼Œå› æ­¤ SSS æ˜¯éšæœºåˆ†é…çš„ã€‚ éšæœºåš ttt æ¬¡ï¼Œä¸€ä¸ª (i,j)(i,j)(i,j) çš„æ­£ç¡®ç‡ä¸º 1âˆ’2âˆ’t1-2^{-t}1âˆ’2âˆ’tã€‚æœ€ç»ˆæ­£ç¡®ç‡æ˜¯ (1âˆ’2âˆ’t)k2(1-2^{-t})^{k^2}(1âˆ’2âˆ’t)k2ã€‚ [CF1286C2] Madhouse (Hard version) Portal. æ²¡è¡¥è¿‡ Hard ver.ï¼Œæˆ‘æ˜¯æ‘†æ€ªã€‚ Easy Ver. åšè¿‡ï¼Œè¿™ä¸ªä¹Ÿå·®ä¸å¤šï¼Œå°±é—® [1,n2],[1,n2+1][1,\\frac n 2],[1,\\frac n 2 + 1][1,2nâ€‹],[1,2nâ€‹+1]ï¼Œç„¶åå‰©ä¸‹çš„ä¾æ¬¡è€ƒè™‘é•¿åº¦ä¸º 2âˆ¼n22\\sim \\frac n 22âˆ¼2nâ€‹ çš„å­ä¸²ï¼Œ222 çš„æ—¶å€™æ’é™¤æ‰åœ¨ [1,n2+1][1,\\frac n 2 + 1][1,2nâ€‹+1] é‡Œçš„ï¼Œç„¶ååˆ æ‰ n2+1\\frac n 2 + 12nâ€‹+1 è¿™ä¸ªä½ç½®çš„æ•°ï¼Œå°±åªæœ‰ sns_nsnâ€‹ å‡ºç°äº†å¥‡æ•°æ¬¡ï¼Œä»¥æ­¤ç±»æ¨ã€‚ äºæ˜¯æ°å¥½é¢„å¤„ç†åˆ°è¿™ä¸ªä½ç½®ï¼ŒååŠéƒ¨åˆ†å°±å¯åšäº†ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/03/11(#22)ï¼šä»æ¥æ²¡æœ‰ä»»ä½•è›®è’ä¹‹åœ° èƒ½ä¸è¿™æ¡ƒæºåª²ç¾","slug":"default/è®°å½•/2024/3/2024-03-11","date":"2024-03-11T00:00:00.000Z","updated":"2024-03-11T00:00:00.000Z","comments":true,"path":"309ed68c/","link":"","permalink":"https://james1badcreeper.github.io/309ed68c/","excerpt":"â€”â€”ã€Šè™šå¹»ä¸ç°å®ã€‹","text":"â€”â€”ã€Šè™šå¹»ä¸ç°å®ã€‹ ç»§ç»­åŠ æ²¹å§ã€‚ [WC2024] ä»£ç å µå¡ ä¸ºä»€ä¹ˆå½“æ—¶ä¸ä¼šã€‚ [CF1835B] Lottery Portal. è¿™åœºå¥½æŠ½è±¡ã€‚ é¦–å…ˆè¿™ä¸ªé¬¼ç•œçš„ä¸œè¥¿åˆ°åº•æ˜¯ä»€ä¹ˆï¼šå‡å®š xâ‰¤cx\\le cxâ‰¤cï¼Œé‚£ä¹ˆåº”è¯¥æ»¡è¶³æ•°è½´ä¸Šå·¦èµ·ç¬¬ kkk ä¸ªæ»¡è¶³ âˆ£câˆ’xâˆ£â‰¤âˆ£câˆ’vlâˆ£|c-x|\\le |c-v_l|âˆ£câˆ’xâˆ£â‰¤âˆ£câˆ’vlâ€‹âˆ£ï¼Œç„¶åå³é¢æ²¡åˆæ³•çš„ä¸œè¥¿ã€‚ ç„¶åå‘ç° xxx åº”è¯¥å–åœ¨ 0,m,v0,m,v0,m,v é™„è¿‘ã€‚ä»£ç ã€‚ [CF1835C] Twin Clusters Portal. æœ‰ç‚¹åƒ CF618Fï¼Œä¸€å®šæœ‰è§£ã€‚ ç„¶åä½¿ç”¨ P7842 çš„æ–¹å¼ä¼˜åŒ–æšä¸¾ï¼Œæˆ‘ä»¬æŒ‰ç…§å‰ kkk ä½çš„å€¼è¿›è¡Œåˆ†ç±»ï¼Œæ€»å…±æœ‰ 2k+1+12^{k+1}+12k+1+1 ä¸ªå‰ç¼€å¼‚æˆ–å’Œï¼Œä¼šä½¿å¾—åç¼€å‰©ä¸‹çš„æœ‰ 2k+12^k+12k+1 å¯¹ç›¸åŒçš„ï¼Œé‚£ä¹ˆè‡³å°‘èƒ½å¤Ÿæ‰¾åˆ°ä¸€ä¸ªç›¸åŒçš„ã€‚ äºæ˜¯ç›´æ¥çº¿æ€§æ‰«è¿‡å»å°±èƒ½æ‰¾åˆ° 2k+12^k+12k+1 å¯¹ç›¸åŒçš„å‰ kkk ä½ã€‚ä»£ç ã€‚ [CF1599A] Weights Portal. å¦‚æœæ˜¯ LRLRLR çš„è¯é‚£ä¹ˆå°† AAA æ’åºï¼Œç„¶åäº¤æ›¿æ”¾ç½®å³å¯ã€‚ å¦åˆ™å€’ç€åšï¼Œç­”æ¡ˆä¸å˜åˆ æœ€å°ï¼Œç­”æ¡ˆå˜åˆ æœ€å¤§ã€‚ [CF1887D] Split Portal. æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§å‘é‡ŒåŠ ä½œä¸ºåˆ†ç•Œç‚¹ï¼Œå¯ä»¥ç®—å‡º nnn ä¸ªçŸ©å½¢ï¼Œæ‰«æçº¿è®¡ç®—è´¡çŒ®å³å¯ã€‚ä»£ç ã€‚ [2023 Shenzhen] Two in One Portal. æ‰€ä»¥ä¸ºå•¥åœºä¸Šæ²¡è¿‡ï¼Ÿ ä¸€å®šæœ‰ä¸€ä¸ªé¢œè‰²æ˜¯é€‰æ»¡çš„ï¼Œå‰©ä¸‹é‚£ä¸ªå¯ä»¥é€‰æ‹©ä¸€ä¸ª x,yx,yx,y éƒ½æœ‰çš„å¡«è¡¥ä¸€æ®µåç¼€ 111ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"LNOI2024 æ¸¸è®°","slug":"summaries/æ¸¸è®°/SX2024","date":"2024-03-07T00:00:00.000Z","updated":"2024-03-07T00:00:00.000Z","comments":true,"path":"57b83896/","link":"","permalink":"https://james1badcreeper.github.io/57b83896/","excerpt":"æˆ‘å°±æ˜¯è¦æ‰“ç ´è¿™è½®å›ã€‚","text":"æˆ‘å°±æ˜¯è¦æ‰“ç ´è¿™è½®å›ã€‚ Day -? THUWC å’Œ WC å…¨å¯„äº†ã€‚ ä¸æ˜ç™½ä¸ºä»€ä¹ˆä¼šè¿™æ ·ã€‚ ä¹Ÿåªèƒ½å‘å‰çœ‹äº†ã€‚ Day -3 ä» ZJ é£äº†å›æ¥ã€‚å›å®¶ï¼ ç†¬å¤œï¼Œ3:00ã€‚ ç„¶åæ¬¡æ—¥ï¼Œ0:00ã€‚ Day -1 åˆ°é…’åº—ï¼Œä»€ä¹ˆéƒ½ä¸æƒ³ã€‚ æ‰“äº†ä¸€ä¸ªè´¹ç”¨æµï¼Œç„¶åæƒ³æƒ³æˆ‘å¥½åƒä¹Ÿåªä¼šè¿™ç‚¹äº†ã€‚ ä¸æƒ³å†™æ¯”èµ›è¿‡ç¨‹ï¼Œè·³è¿‡ã€‚ Day Mid çœ‹äº‘æ–—æ•°æ®ï¼Œæˆ‘åœ¨ä¸€ä¸ªå¾ˆå±é™©çš„è¾¹ç¼˜ã€‚ ç²¾ç¥çŠ¶æ€æœ‰ç‚¹ä¸å¤ªæ­£å¸¸ï¼Œå¹¸å¥½è€å¸ˆä»¬å¯¹æˆ‘è¿˜æ˜¯æ¯”è¾ƒå®½å®¹çš„ã€‚ Day ? - 1 å‘ç°æˆ‘å‰é¢æœ‰ä¸¤ä¸ªåˆä¸­ç”Ÿï¼Œæ€ä¹ˆè¿™ä¹ˆå‰å®³ã€‚ è¿™æ ·è‡³å°‘èƒ½æœ‰ä¸€ä¸ª Bï¼Œæ²¡æ­»ã€‚ Day ? 2024 å¹´ 3 æœˆ 7 æ—¥ã€‚ ä¸çŸ¥é“ä¸ºä»€ä¹ˆè‹Ÿè¿›äº† Aã€‚ ä¸€äº›æ‚è°ˆ ç›®å‰æˆ‘ç”šè‡³æ²¡æœ‰ä¸€ä¸ª Cu çš„æ°´å¹³ï¼ˆå¾ˆå¤šå¼±çœéƒ½æœ‰è‹¥å¹²äººè¿‡äº† D2T1ï¼Œä½†æ˜¯æˆ‘å‹æ ¹ä¸ä¼šè¿™ä¸ªä¸œè¥¿ï¼‰ã€‚å¦‚æœæƒ³è¦è¾¾åˆ°ç†æƒ³çš„ç›®æ ‡ï¼Œä¸¤å¤©çš„ T2 éœ€è¦éƒ½ä¼šã€‚ è¿™çœ‹ä¸Šå»ç¡®å®ååˆ†é¥è¿œï¼Œä¹Ÿéœ€è¦å»ä»˜å‡ºæ›´å¤šçš„åŠªåŠ›å§ã€‚ ä»¥åä¼šå°½é‡åšåˆ°æ—¥æ›´çš„ï¼Œä¸€è½®å¤ä¹ ä¹Ÿéœ€è¦ä»¥ä¸€ä¸ªæ›´å…¨é¢å®Œæ•´çš„æ–¹å¼å»å®Œæˆã€‚ æ„Ÿè°¢åŒå­¦ä»¬çš„é¼“åŠ±ä¸é™ªä¼´ï¼Œé—æ†¾é€€å½¹çš„åŒå­¦ä»¬æ–‡åŒ–è¯¾åŠ æ²¹å•Šï¼ï¼","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"2024/03/01(#22)ï¼šä»æ¥æ²¡æœ‰ä»»ä½•è›®è’ä¹‹åœ° èƒ½ä¸è¿™æ¡ƒæºåª²ç¾","slug":"default/è®°å½•/2024/2/2024-02-28","date":"2024-02-27T00:00:00.000Z","updated":"2024-02-29T00:00:00.000Z","comments":true,"path":"87bbfefz/","link":"","permalink":"https://james1badcreeper.github.io/87bbfefz/","excerpt":"â€”â€”åæ™¨å®‡ã€Šè™šå¹»ä¸ç°å®ã€‹","text":"â€”â€”åæ™¨å®‡ã€Šè™šå¹»ä¸ç°å®ã€‹ [WC2024] ä»£ç å µå¡ æ‰€ä»¥ä¸ºä»€ä¹ˆè€ƒåœºä¸Šä¸ä¼šã€‚ [CTS2024] æ°´é•œ [CTS2024] çº¿æ®µæ ‘ [CTS2024] ä¼—ç”Ÿä¹‹é—¨ [çœé€‰è”è€ƒ 2023] è¿‡æ²³å’ Portal. [P9682] Electro Master Portal. æ¨¡æ‹Ÿèµ›æœ‰ä¸€ä¸ªé¢˜æ˜¯ä»è¿™ä¸ªæ”¹è¿‡æ¥çš„ï¼Œæ•´ä½“ä¸Šæ¥è¯´å·®ä¸å¤šã€‚ ç¬¬ iii ä¸ªèƒ½æˆä¸ºåˆ°å·¦è¾¹çš„ bï¼Œå½“ä¸”ä»…å½“åˆå§‹æ—¶æœ‰è‡³å°‘ iii ä¸ªæ­£çš„ï¼Œå¹¶ä¸”å®ƒå‘ç”Ÿäº†å¥‡æ•°æ¬¡ç¢°æ’ã€‚è®¨è®º iâˆ’1,i,i+1i-1,i,i+1iâˆ’1,i,i+1 çš„æƒ…å†µï¼š +++ï¼Œ---ï¼šå•¥ä¹Ÿä¸æ˜¯ï¼› LNOI2024 rp++ åœ¨å…‰æ€ªé™†ç¦»ä¸­ï¼Œå¯»æ‰¾å†…å¿ƒçš„å‡ºå£ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/24(#21)ï¼šå¤©ä½¿å¸å›½","slug":"default/è®°å½•/2024/2/2024-02-21","date":"2024-02-21T00:00:00.000Z","updated":"2024-02-24T00:00:00.000Z","comments":true,"path":"1a13baf9/","link":"","permalink":"https://james1badcreeper.github.io/1a13baf9/","excerpt":"ä¾¿ä¸€å»ä¸å›ã€‚","text":"ä¾¿ä¸€å»ä¸å›ã€‚ æ¨¡æ‹Ÿèµ›ï¼Œå››å¤©å¹¶åˆ°äº†ä¸€å¤©ã€‚ æœ€è¿‘æ°”æ¸©æ˜¯æœ‰ç‚¹ç¦»è°±äº†ï¼Œè¾¾åˆ°äº† Î”=âˆ’25âˆ˜C\\Delta=-25^{\\circ}\\text{C}Î”=âˆ’25âˆ˜Cã€‚ [CCO2023] Binaria Portal. ç›´æ¥å¹¶æŸ¥é›†åˆå¹¶å°±æ²¡äº†ã€‚ä»£ç ã€‚ [CCO2023] Real Mountains Portal. è”è€ƒè€ƒè¿‡ï¼Œæ²¡è¡¥ï¼Œæˆ‘æ˜¯æ‘†æ€ªã€‚ è€ƒè™‘æœ€ç»ˆåºåˆ—çš„æœ€å¤§å€¼ä¸€å®šä¸ä¼šå¤§äºåŸåºåˆ—ä¸­çš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆä»»å–ä¸€ä¸ªæœ€å¤§å€¼ä½ç½®ä½œä¸ºå³°é¡¶ï¼Œå·¦å³ä¸¤è¾¹åˆ†å¼€å¤„ç†ã€‚ å¯¹äºå·¦è¾¹æ¥è¯´ï¼ˆå³è¾¹åŒç†ï¼‰ï¼Œä¸€ä¸ªä½ç½®çš„æœ€ç»ˆå€¼æ˜¯å®ƒå·¦è¾¹æ‰€æœ‰å€¼çš„æœ€å¤§å€¼ã€‚æ¯æ¬¡æ‰¾åˆ°è¿˜æœªè¾¾åˆ°æœ€ç»ˆå€¼çš„æ‰€æœ‰æœ€å°å€¼ï¼Œå°è¯•å°†å…¶å…¨éƒ¨åŠ ä¸€ã€‚å‘ç°æœ€ä¼˜æƒ…å†µæ˜¯ä»ä¸¤ç«¯åŠ åˆ°ä¸­é—´ï¼Œäºæ˜¯ä»å°åˆ°å¤§æ‰«ï¼Œç›´æ¥è®¡ç®—è´¡çŒ®å³å¯ã€‚ä»£ç ã€‚ [CF1545F] AquaMoon and Potatoes | [Ynoi2007] tmpq Portal. Technoï¼ŒåœŸè±†ã€‚ æš´åŠ› DP å¯ä»¥å°† i,ki,ki,k çš„è´¡çŒ®æ‹†å¼€ç„¶åæš´åŠ›æ‰«ç„¶åä¹˜èµ·æ¥å³å¯ã€‚ çœ‹ä¸Šå»å°±éå¸¸çš„ç¦»è°±ï¼Œä»¥å‰ç»™å‡ºçš„åšæ³•å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š ç›´æ¥æ“ä½œåˆ†å—ï¼Œæ¯æ¬¡åªæœ‰ O(m)O(\\sqrt{m})O(mâ€‹) ä¸ªè¢«ä¿®æ”¹çš„æ•°ï¼Œç„¶åå°±æœ‰çœ‹æ¯ä¸ªæ•°æ˜¯å¦æ˜¯åœ¨è¿™ä¸ªå—å†…è¢«ä¿®æ”¹çš„ï¼Œ888 ç§æƒ…å†µéƒ½èƒ½åšï¼Œå°±æ˜¯æœ‰ç‚¹æ— è¯­ã€‚ zak æœ‰ä¸€ç§èªæ˜çš„åšæ³•ï¼š ç®—äº†ï¼Œæ˜å¤©å†™ã€‚ ä»Šå¤©åƒæ™šé¥­çš„æ—¶å€™ä¸€äººé¡¶ç€ä¼èµ°äº†ä¸€åœˆï¼Œæœ‰ç§å°†ä¸–é—´ä¸‡ç‰©éƒ½æ”¶åœ¨ä¸€èµ·çš„æ„Ÿè§‰ã€‚è§†é‡æ²¡æœ‰é‚£ä¹ˆå¼€é˜”ï¼Œå´ä¹Ÿä¸è§‰é®æŒ¡ã€‚ æ¸©åº¦åœ¨å¿ƒä¸­èšé›†ï¼Œåœ¨ä¸€ä¸ªä¸å¤§çš„ä¸–ç•Œä¸­ï¼Œåƒç™»å±±è€…çœ‹åˆ°äº†åœ¨å±±é¡¶å¼€æ”¾çš„èŠ±ä¸€èˆ¬æ¬£å–œã€‚ èµ°å§ï¼Œä¸ç®¡èµ°åˆ°å“ªé‡Œï¼Œè¿™ä¸€åˆ‡éƒ½å¾ˆç¾çš„ã€‚ å¤©ä½¿å¸å›½ã€‚ ä»¥ä¸Šéƒ½æ˜¯ 21 æ—¥çš„ï¼Œä¸‹é¢å¼€å§‹æ˜¯ 22 æ—¥å’Œ 23 æ—¥çš„ã€‚ å…ˆç»§ç»­å†™é‚£ä¸ªåœŸè±†é¢˜ã€‚ è½¬åŒ–ä¸º a,b,ca,b,ca,b,c å•ç‚¹ä¿®æ”¹ï¼Œbi=aj=ckb_i=a_j=c_kbiâ€‹=ajâ€‹=ckâ€‹ çš„ä¸ªæ•°ã€‚å…ˆå†™ä¸€ä¸ªåŠ¨æ€ DP ç»´æŠ¤è½¬ç§»ã€‚ å¯¹äºæ¯ä¸ªå‡ºç°çš„ www çš„æ¬¡æ•°è¿›è¡Œæ ¹å·åˆ†æ²»ã€‚å¯¹äº cntwâ‰¤Bcnt_w\\le Bcntwâ€‹â‰¤Bï¼Œé‚£ä¹ˆè¿›è¡Œæš´åŠ› DPï¼Œç„¶åå·®åˆ†è´¡çŒ®ï¼Œæ‰”åˆ°ç›¸åº”çš„ä½ç½®ä¸Šï¼Œè¯¢é—®ç›¸å½“äºæ±‚å‰ç¼€å’Œï¼ŒO(nn)O(n\\sqrt{n})O(nnâ€‹) æ¬¡ä¿®æ”¹ï¼ŒO(m)O(m)O(m) æ¬¡æŸ¥è¯¢ï¼Œä½¿ç”¨ O(1)âˆ’O(n)O(1)-O(\\sqrt{n})O(1)âˆ’O(nâ€‹) çš„åˆ†å—ç»´æŠ¤ã€‚ å¯¹äº cntw&gt;Bcnt_w&gt;Bcntwâ€‹&gt;Bï¼Œç¦»çº¿æ‰«ä¸€éæ“ä½œåºåˆ—ï¼Œå•ç‚¹ä¿®æ”¹å‰ç¼€æŸ¥è¯¢ï¼Œç”±äºä¿®æ”¹çš„æ€»ä¸ªæ•°æ˜¯ O(m)O(m)O(m)ï¼Œè¯¢é—®ä¸ªæ•°æ˜¯ O(mn)O(m\\sqrt n)O(mnâ€‹)ï¼Œå› æ­¤ä½¿ç”¨ O(n)âˆ’O(1)O(\\sqrt{n})-O(1)O(nâ€‹)âˆ’O(1) çš„åˆ†å—ç»´æŠ¤å³å¯ã€‚ å†™èµ·æ¥æ¯”è¾ƒæ–¹ä¾¿ï¼ŒåœŸè±†è¿˜æ˜¯å¾ˆç¾å‘³çš„ï¼ï¼ä»£ç ã€‚ [JOISC2020] Ruins 3 Portal. æ—‹é£ç‰›é©¬å¤§æ•°æ•°ã€‚ è€ƒè™‘ä»åå¾€å‰æ‰«ï¼Œç„¶åå‡å®š 1âˆ¼h1\\sim h1âˆ¼h çš„çŸ³æŸ±å„å‡ºç°äº†ä¸€æ ¹ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥å‡ºç°çš„ â‰¤h\\le hâ‰¤h çš„æŸ±å­ï¼Œéƒ½ä¼šç›´æ¥éœ‡æ²¡ã€‚é‚£äº›æ²¡æœ‰è¢«éœ‡æ­»çš„æŸ±å­ç§°ä¸ºâ€œæ ‡å‡†æŸ±â€ã€‚ ç»§ç»­è§‚å¯Ÿæ€§è´¨ã€‚å¦‚æœå½“å‰ä½ç½®ä¸º xxxï¼Œåé¢å­˜åœ¨ xâˆ¼xâˆ’kx\\sim x-kxâˆ¼xâˆ’kï¼Œé‚£ä¹ˆ xxx ä¼šä¸‹é™åˆ° xâˆ’kâˆ’1x-k-1xâˆ’kâˆ’1ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨å iii ä¸ªæŸ±å­ï¼Œæ­¤æ—¶ h=jh=jh=j çš„æ–¹æ¡ˆæ•°ã€‚ æˆ‘ä»¬å…ˆå‡å®šä¸¤æ ¹é«˜åº¦ç›¸åŒçš„æŸ±å­å®é™…ä¸Šæ˜¯ä¸åŒçš„ï¼Œé‚£ä¹ˆæœ€ç»ˆç­”æ¡ˆé™¤ä»¥ 2n2^n2n å³å¯ã€‚ å€’ç€ DPï¼Œè®¾æ­¤æ—¶æœ‰ c0c_0c0â€‹ ä¸ªé’¦å®šæ¶ˆå¤±ï¼Œc1c_1c1â€‹ ä¸ªé’¦å®šå­˜åœ¨ã€‚ iii é’¦å®šæ¶ˆå¤±ï¼Œæ­¤æ—¶ jjj ä¸å˜ï¼Œæœ‰ jjj ä¸ªå¯ç”¨é«˜åº¦ï¼Œé‚£ä¹ˆä¸ç®—å½“å‰è¿™ä¸ªæ²¡æ¶ˆå¤±çš„ï¼Œè¿™é‡Œå¯ä»¥å¡«å†™ jâˆ’(c0âˆ’1)j-(c_0-1)jâˆ’(c0â€‹âˆ’1) ä¸ªæœ‰æ•ˆçš„ã€‚ iii é’¦å®šä¿ç•™ï¼Œä»¤ hih_ihiâ€‹ ä»£è¡¨ iii æœ€åçš„é«˜åº¦ï¼Œåˆ†è®¨ï¼š å¦‚æœ hi&gt;j+1h_i&gt;j+1hiâ€‹&gt;j+1ï¼Œé‚£ä¹ˆä» fi+1,jf_{i+1,j}fi+1,jâ€‹ è½¬ç§»ï¼Œè¿™é‡Œçš„è´¡çŒ®ç•™ç»™ä»¥åå†è®¡ç®—ã€‚ å¦åˆ™æ­¤æ—¶ hi=j+1h_i=j+1hiâ€‹=j+1ï¼Œé‚£ä¹ˆæ­¤æ—¶æšä¸¾ä¸€ä¸ªæ–°å¢çš„å¤§å° kkkï¼Œè½¬ç§»åˆ° fi,j+kf_{i,j+k}fi,j+kâ€‹ï¼Œç³»æ•°æ˜¯ï¼š é€‰æ‹©å“ªäº›ä½ç½®çš„å€¼è¢«è®°å…¥äº†å½“å‰ jjjã€‚é’¦å®šé™¤äº†å½“å‰ä½ç½®çš„é‚£ kâˆ’1k-1kâˆ’1 ä¸ªä½ç½®çš„æ–¹æ¡ˆæ•° (c1âˆ’1âˆ’jkâˆ’1)\\dbinom{c_1-1-j}{k-1}(kâˆ’1c1â€‹âˆ’1âˆ’jâ€‹)ï¼› j+2âˆ¼j+kj+2\\sim j+kj+2âˆ¼j+k çš„é«˜åº¦ä¹‹å‰å‡æœ‰å‡ºç°è¿‡ä¸€æ¬¡ï¼Œè¿™é‡Œè¿˜å¯ä»¥é€‰æ‹©å„ä¸€æ¬¡ï¼Œç„¶åè¿˜å¯ä»¥é€‰æ‹©ä¸¤ä¸ª j+1j+1j+1 çš„é«˜åº¦ï¼Œæ–¹æ¡ˆæ•°æ˜¯ k+1k+1k+1ï¼› å›ºå®šé‚£ kâˆ’1k-1kâˆ’1 ä¸ªä½ç½®ä¸Šçš„æ•°çš„æ’åˆ—ï¼Œé‚£äº›æ•°éƒ½æ²¡æœ‰è¢«éœ‡æ²¡ã€‚å› æ­¤å°±æ˜¯è¦æ±‚ä¸€ä¸ª gng_ngnâ€‹ ä»£è¡¨æœ‰ 2n2n2n ä¸ªæ•°è¿›è¡Œé€‰æ‹©ï¼Œç„¶åéœ‡æˆå€¼åŸŸè¿ç»­æ®µçš„åˆå§‹æ–¹æ¡ˆæ•°ã€‚ è®¾ gi,jg_{i,j}gi,jâ€‹ ä»£è¡¨ç”¨ 1âˆ¼i1\\sim i1âˆ¼i çš„æ•°å¡« jjj ä¸ªä½ç½®ï¼Œæ”¾è¿›å»çš„æœ€å¤§æ•°ä¸å½±å“åŸæ¥èƒ½éœ‡æˆçš„å€¼åŸŸè¿ç»­æ®µï¼Œé‚£ä¹ˆèƒ½éœ‡æˆå€¼åŸŸè¿ç»­æ®µçš„å……è¦æ¡ä»¶æ˜¯ iâ‰¥ji\\ge jiâ‰¥jã€‚æšä¸¾ç¬¬ iii ä¸ªæ•°å¡«äº† 0/1/20/1/20/1/2 çš„è½¬ç§»æ–¹å¼ï¼š gi,j=giâˆ’1,j+2jÃ—giâˆ’1,jâˆ’1+j(jâˆ’1)giâˆ’1,jâˆ’2g_{i,j}=g_{i-1,j}+2j\\times g_{i-1,j-1}+j(j-1) g_{i-1,j-2} gi,jâ€‹=giâˆ’1,jâ€‹+2jÃ—giâˆ’1,jâˆ’1â€‹+j(jâˆ’1)giâˆ’1,jâˆ’2â€‹ ä»£ç ã€‚ [Ynoi1999] XM66F å°±æ˜¯æ±‚ âˆ‘i=lr[aj=ar](brâˆ’bj)\\sum_{i=l}^r [a_j=a_r](b_r-b_j)âˆ‘i=lrâ€‹[ajâ€‹=arâ€‹](brâ€‹âˆ’bjâ€‹) ç›´æ¥è«é˜Ÿæ²¡æœ‰äº†ï¼Œè¿™ä¸œè¥¿ä¸ºä»€ä¹ˆå¯ä»¥ä¸ä¸¢ Easy Roundï¼Ÿï¼Ÿï¼Ÿï¼Ÿä»£ç ã€‚ æ•™ç»ƒé¢†ç€å»æŸä¸ªç¥ç§˜çš„åœ°æ–¹åƒäº†ä¸€é¡¿ï¼ŒæŒºå¼€å¿ƒçš„ã€‚ ä¸è¿‡é‚£é‡Œçš„çŒ«ä¸€ä¸ªéƒ½ä¸ç†æˆ‘ ä»Šå¤©ä¸‹åˆå¬äº†å¾ˆå¤šéã€Šæ–—ç‰›ã€‹ï¼ï¼ é‡æ€§å¦éœ²ç€çµé­‚çº¯ç²¹ æˆ–è€…è‚†æ„å¦„ä¸ºç›´åˆ°äº²æ‰‹æ ½åŸ¹äº†åŸç½ªä»¥å åˆè¦å°†å®ƒæ‘§æ¯ å¥½å¥½ä¼‘æ¯ä¸€ä¸‹å‘¢ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/20(#20)ï¼šåœ¨æ— å°½çš„é»‘æš—ä¹‹ä¸­ è‚†æ„ç”Ÿé•¿ç€","slug":"default/è®°å½•/2024/2/2024-02-20","date":"2024-02-20T00:00:00.000Z","updated":"2024-02-20T00:00:00.000Z","comments":true,"path":"b389ed0b/","link":"","permalink":"https://james1badcreeper.github.io/b389ed0b/","excerpt":"è¿™æ˜¯å®‡å®™åŸæœ¬çš„é¢œè‰²ã€‚","text":"è¿™æ˜¯å®‡å®™åŸæœ¬çš„é¢œè‰²ã€‚ å”‰ï¼Œå¯¹æ‹ï¼Œæš´åŠ›å†™æŒ‚ã€‚ èƒ½ä¸èƒ½æ‰“å‡ºä¸€ä¸ªæ­£å¸¸çš„ perf å•Šï¼ˆç¬‘ï¼‰ [ABC314F] Breakdown å½“æ—¶æŠŠ âˆ‘\\sumâˆ‘ çœ‹æˆ âˆ€\\forallâˆ€ äº†ï¼Œä¸æ„§æ˜¯æˆ‘ã€‚ ç›´æ¥èƒŒåŒ…å°±è¡Œäº†ã€‚ [ABC314G] Highest Ratio è¯»é”™ F å¹²æ²¡æ—¶é—´äº†ã€‚ è€ƒè™‘å›ºå®šçš„å³ç«¯ç‚¹å¯¹åº”çš„å·¦ç«¯ç‚¹æ˜¯å•è°ƒçš„ï¼Œé‚£ä¹ˆç›´æ¥å•è°ƒæ ˆï¼Œåé¢ä¸€æ®µä¸ä¼˜ç›´æ¥æ‰”æ‰ã€‚ä»£ç ã€‚ [Ynoi2011] æˆéƒ½ä¸ƒä¸­ Portal. å»å¹´è¢«é•¿å¤´é¾™ç—…æ¯’æœºæƒ¨äº¤çš„é¢˜ç°åœ¨æ‰è¡¥ï¼Œèƒ½ä¸èƒ½æ”¹ä¸€æ”¹å®‡å®™è¶…çº§æ— æ•Œæ—‹é£ç‰›é©¬æ‘†æ€ªçš„æ¯›ç—…å•Šã€‚ ä½ ç›´æ¥ç‚¹åˆ†æ²»ä¸‹å»ï¼Œä¸€ä¸ªè¯¢é—®ç¬¬ä¸€æ¬¡ç»Ÿè®¡åœ¨åˆæ³•è·¯å¾„èƒ½è¦†ç›–åˆ°å®ƒçš„æ—¶å€™ï¼Œç„¶åäºŒç»´æ•°ç‚¹ã€‚æ—¶é—´å¤æ‚åº¦ O((n+m)logâ¡2n)O((n+m)\\log^2 n)O((n+m)log2n)ã€‚ä»£ç ã€‚ [CF983D] Arkady and Rectangles Portal. æ‰«ææ¯’ç˜¤çº¿ï¼Œçº¿æ®µæ ‘ä¸Šå¼€ set ç»´æŠ¤å®Œå…¨è¦†ç›–å½“å‰åŒºé—´çš„é¢œè‰²ï¼Œä»¥åŠåŒºé—´æ²¡æœ‰çœ‹åˆ°è¿‡çš„æœ€å¤§é¢œè‰²å’Œçœ‹åˆ°è¿‡çš„æœ€å¤§é¢œè‰²ï¼Œéƒ½èƒ½ç›´æ¥ç®—ã€‚ æ³¨æ„æ²¡æœ‰å®Œå…¨è¦†ç›–çš„ï¼Œçœ‹åˆ°è¿‡çš„æœ€å¤§é¢œè‰²ï¼Œpushup çš„æ—¶å€™å–çš„æ˜¯æœ€å°å€¼ã€‚ä»£ç ã€‚ ä¸åœåœ°åœ¨æ‡Šæ‚”ï¼Œä¸ºä»€ä¹ˆä¼šè¿™æ ·å‘¢ï¼Ÿ å°±æ˜¯è¯´ï¼Œä¸ºä»€ä¹ˆè¦åœ¨æ„é‚£ä¹ˆå¤šäº‹æƒ…å‘¢ï¼Ÿ","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/19(#19)ï¼šå­¤ç‹¬è¢«æŸ“ä¸Šç«¥è¯åº•è‰²","slug":"default/è®°å½•/2024/2/2024-02-19","date":"2024-02-19T00:00:00.000Z","updated":"2024-02-19T00:00:00.000Z","comments":true,"path":"fc189a8d/","link":"","permalink":"https://james1badcreeper.github.io/fc189a8d/","excerpt":"ä»Šå¤©å°è¯•èƒ½ä¸èƒ½æ•ˆç‡æ­£å¸¸ä¸€ç‚¹ï¼ï¼","text":"ä»Šå¤©å°è¯•èƒ½ä¸èƒ½æ•ˆç‡æ­£å¸¸ä¸€ç‚¹ï¼ï¼ [çœé€‰è”è€ƒ 2023] äººå‘˜è°ƒåº¦ Portal. ç±»ä¼¼äº Conquer The Worldï¼Œç›´æ¥æ¯æ¬¡åæ‚”è´ªå¿ƒéå†æ•´æ£µæ ‘æœ‰ 48 åˆ†ã€‚æ‰€ä»¥ä¸ºå•¥å»å¹´ä¸ä¼šå•Šã€‚ åˆ é™¤çš„è¯å¥—ä¸€å±‚çº¿æ®µæ ‘åˆ†æ²»å°±å¯ä»¥äº†ï¼Œç°åœ¨æƒ³ä¸€æƒ³æ€ä¹ˆåŠ å…¥ã€‚ è€ƒè™‘æ¨¡æ‹Ÿåæ‚”è´ªå¿ƒï¼Œæ‰¾åˆ° xxx çš„ç¥–å…ˆä¸­æ·±åº¦æœ€æ·±çš„æ»¡è¶³ s(u)=sizâ¡us(u)=\\operatorname{siz}_us(u)=sizuâ€‹ çš„ uuuï¼Œç„¶åæ›¿æ¢å­æ ‘å†…çš„æœ€å°å€¼ã€‚ æ ‘å‰–çº¿æ®µæ ‘ç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹çš„ sizuâ¡âˆ’ s(u)\\operatorname{siz_u}-\\ s(u)sizuâ€‹âˆ’ s(u) çš„æœ€å°å€¼ä»¥åŠå­æ ‘å†…çš„æœ€å°æƒå€¼ï¼Œç›´æ¥æ›¿æ¢å³å¯ã€‚ sjy èƒ½ä¸èƒ½åšä¸ªäººå•Šï¼ŒæŠŠæ ‘å‰–å¡æ»¡çš„æ„ä¹‰ä½•åœ¨å•Šã€‚ä»£ç ã€‚ åŠå½©ä¸‰é‡å¥ ä»Šå¤©æ‰“äº†ä¸€ä¸‹æœˆèµ› Div.2ï¼éå¸¸æç¬‘ï¼ ä»¥åå¯ä»¥å°è¯•æŠŠ E è¡¥äº†ï¼F æ˜¯ä»€ä¹ˆç‰›é©¬é¢˜ï¼ å¹¶æŸ¥é›†æš´åŠ›æ¨¡æ‹Ÿå³å¯ï¼Œæ³¨æ„è¯¢é—®ç¦»çº¿æ¥å‡å°å¸¸æ•°ã€‚ [HNOI2019] æ ¡å›­æ—…è¡Œ Portal. è€ƒè™‘æš´åŠ›ï¼Œfx,yf_{x,y}fx,yâ€‹ æ˜¯å¦å­˜åœ¨ xâ†’yx\\rightarrow yxâ†’y çš„å›æ–‡è·¯å¾„ï¼Œç›´æ¥è®°å¿†åŒ–æœç´¢ O(n2+m2)O(n^2 + m^2)O(n2+m2)ã€‚ é—®é¢˜æ˜¯æˆ‘ä»¬çš„è¾¹æ•°å¤ªå¤šäº†ï¼æ³¨æ„åˆ°è·¯å¾„é•¿åº¦å…¶æ˜¯ä¸å¤ªè¦ç´§ï¼Œå› ä¸ºå¯ä»¥æ¥å›èµ°åˆ·åˆ†ã€‚é¦–å…ˆè€ƒè™‘ä¸€ä¸ªäº‹æƒ…ï¼Œå¦‚æœæˆ‘åªèƒ½èµ°åŒè‰²ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¥½åƒä¸èƒ½æ”¹å˜æˆ‘ä»¬å½“å‰åˆ·çš„è·¯å¾„é•¿åº¦çš„å¥‡å¶æ€§â€”â€”é™¤éæœ‰å¥‡ç¯ã€‚é™¤éâ€¦â€¦é™¤éä¸æ˜¯äºŒåˆ†å›¾ï¼ é‚£ä¹ˆå¯¹äºäºŒåˆ†å›¾çš„åŒè‰²è¿é€šå—ï¼Œå¯ä»¥åªä¿ç•™ä¸€æ£µç”Ÿæˆæ ‘ï¼ˆå› ä¸ºå­å›¾ä¹Ÿæ˜¯äºŒåˆ†å›¾ï¼‰ï¼Œå…¶å®ƒåŒè‰²è¿é€šå—å¯ä»¥è¡¨ç¤ºä¸ºä¸€æ£µç”Ÿæˆæ ‘ï¼Œç„¶åæœ‰ä¸€ä¸ªè‡ªç¯ã€‚ è€Œå¼‚è‰²ç‚¹æ˜¯è‡ªç„¶äºŒåˆ†å›¾ï¼Œç›´æ¥ä¿ç•™ç”Ÿæˆæ ‘å³å¯ã€‚ä»£ç ã€‚ å”‰ï¼Œå¤§æ„äº†ğŸ˜… ä¸è¦è®©æ¬²æœ›ä¾µå äº†æ„å¿—ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/18(#18)ï¼šæ—¥è½è‰²ç ‚ç³–","slug":"default/è®°å½•/2024/2/2024-02-16","date":"2024-02-16T00:00:00.000Z","updated":"2024-02-18T00:00:00.000Z","comments":true,"path":"bc00b8e/","link":"","permalink":"https://james1badcreeper.github.io/bc00b8e/","excerpt":"ç”±äºä¸¤å¤©æ¨¡æ‹Ÿèµ›æ²¡åšä»€ä¹ˆé¢˜ï¼Œæ‰€ä»¥ä¸€èµ·å¹¶åˆ° Day3 äº†ã€‚","text":"ç”±äºä¸¤å¤©æ¨¡æ‹Ÿèµ›æ²¡åšä»€ä¹ˆé¢˜ï¼Œæ‰€ä»¥ä¸€èµ·å¹¶åˆ° Day3 äº†ã€‚ 30 min è¿‡æ‰ T1ï¼Œç„¶åå°‘å†™ä¸€ä¸ªç­‰å·çˆ†é›¶äº†ï¼ å‰©ä¸‹ 4h T2 T3 ç‹‚ç é›¶åˆ†ï¼ï¼ å“‡å“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆï¼ï¼ æ˜å¤©èƒ½ä¸èƒ½ç¨å¾®è°ƒæ•´ä¸€ä¸‹å•Šï¼Œå¦åˆ™éƒ½å¯¹ä¸èµ·é˜ç‹æ²¡åœ¨è‡ªå·±çš„ç”Ÿæ­»ç°¿ä¸Šæ‰“å‰äº†ã€‚ å•Šç±³è¯ºæ–¯åˆæ­»äº†ï¼Œæ²¡è„¸æ´»äº†ã€‚ è¿™æ˜¯èƒ½æº¶è§£ä¸€åˆ‡çš„é»„æ˜ã€‚ [CF1916F] Group Division Portal. ç”¨æ—¶ 3min æƒ³å®Œäº†ï¼Œä¸è¿‡å‡äº† ä½†æ˜¯æ¯æ¬¡è·‘ä¸€é Tarjan å°±æ˜¯å¯¹çš„äº†ï¼Œå› ä¸ºåŸå›¾æ˜¯ä¸ªç‚¹åŒï¼Œæ‰€ä»¥å¿…ç„¶èƒ½èµ°ä¸€ä¸ªï¼Œå‰©ä¸‹çš„è¿˜æ˜¯ä¸ªç±»ç‚¹åŒï¼Œå…¶å‰²ç‚¹è¿åœ¨å·²é€‰é›†åˆä¸Šï¼Œæ„Ÿè§‰ä¸Šä¹Ÿå·®ä¸å¤šï¼Œä»£ç ã€‚ [CF1437F] Emotional Fishermen Portal. è®¾ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤ºå½“å‰æœ€å¤§å€¼æ˜¯ aia_iaiâ€‹ï¼Œç„¶åç¡®å®šäº†æ’åˆ—çš„å‰ jjj ä¸ªï¼Œè½¬ç§»çš„æ—¶å€™å¯ä»¥æ–°åŠ å…¥ä¸€ä¸ªæœ€å¤§å€¼ï¼Œä¹Ÿå¯ä»¥åŠ å…¥ 2akâ‰¤ai2a_k\\le a_i2akâ€‹â‰¤aiâ€‹ çš„å€¼ï¼Œä»£ç ã€‚ æ‰“äº† 2023 Shanghaiã€‚ B. Roman Master å€’ç€åšå°±å¥½äº†ã€‚ä»£ç ã€‚ F. Dot Product çŒœç»“è®ºï¼Œä¸¤ä¸ªå€¼åŸŸç›¸é‚»çš„æ•°å¯ä»¥äº¤æ¢ä½ç½®ï¼Œç”¨é€†åºå¯¹å‡å»è¿™äº›æ•°å³å¯ã€‚ä»£ç ã€‚ å‰©ä¸‹çš„ qoj ä¼ äº†ä¹‹åå†è¯´ã€‚ [CF1801E] Gasoline prices Portal. å°±æ˜¯èŒèŒå“’ï¼Œæ¬åˆ°æ ‘ä¸Šå¹¶æŸ¥é›†ç»´æŠ¤æ­£åé“¾å³å¯ã€‚ä»£ç ã€‚ [AGC030D] Inversion Sum Portal. å¯¹äºæ“ä½œ D ä¸å‡ºæ¥ä»€ä¹ˆ Pï¼Œæ‰€ä»¥è€ƒè™‘æšä¸¾é€†åºå¯¹ã€‚å¯¹æ‰€æœ‰çš„ fff å¯ä»¥ç›´æ¥è¿›è¡Œè½¬ç§»ï¼Œä»£ç ã€‚ [AGC026E] Synchronized Subsequence Portal. æ­£ç€åšå¯èƒ½ä¼šå¿½ç•¥åé¢æœ‰æ›´å¥½çš„ bbbï¼Œè€ƒè™‘å€’ç€åšã€‚ è®¾ fif_ifiâ€‹ ä¸ºè€ƒè™‘ iâˆ¼ni\\sim niâˆ¼n ä¸ª a,ba,ba,b çš„å­—ç¬¦ä¸²ï¼Œç„¶å ba ä¸€å®šè¦å¡«ï¼Œåœ¨é‚£ä¸ª a ä¹‹å‰å‡ºç°çš„ ba ä¸€å®šè¦å¡«ï¼›å¯¹äº ab åœ¨ b ä¹‹å‰å‡ºç°çš„ä¸œè¥¿ä¸€å®šä¸èƒ½å¡«ï¼Œä»£ç ã€‚ [é›†è®­é˜Ÿäº’æµ‹ 2021]ã€Šå…³äºå› ä¸ºä¸å»å¹´äº’æµ‹zjkæ’é¢˜è€Œä¸å¾—ä¸æ”¹é¢˜è¿™å›äº‹ã€‹ Portal. è¶…çº§é’¢ç´éƒ½åšè¿‡å§ï¼Ÿ æ±‚çš„æ˜¯ ANDï¼Œæ‰€ä»¥æŠŠæœ€å¤§å€¼æå‡ºæ¥å°±è¡Œäº†ã€‚çº¿æ®µæ ‘æ¯ä¸ªèŠ‚ç‚¹å¼€ä¸€ä¸ª vector å­˜å‚¨æ‰€æœ‰çš„å€¼ï¼Œè¯¢é—®çš„æ—¶å€™è´ªå¿ƒå°±å¥½äº†ã€‚ æ·¦ vector è¶Šç•Œè°ƒäº†ä¸€ä¸‹åˆï¼ï¼ï¼ï¼ï¼ï¼ä»£ç ã€‚ [ARC172A] Chocolate Portal. å¤§çš„ä¸€å®šæ›´å¥½åˆ†ï¼Œç›´æ¥è´ªå¿ƒå³å¯ã€‚ä»£ç ã€‚ [ARC172B] AtCoder Language Portal. ç­”æ¡ˆå½¢å¦‚ lÃ—(lâˆ’1)Ã—(lâˆ’2)Ã—â‹¯Ã—(lâˆ’(nâˆ’k))xl\\times (l-1)\\times (l-2)\\times \\cdots \\times (l-(n-k))^xlÃ—(lâˆ’1)Ã—(lâˆ’2)Ã—â‹¯Ã—(lâˆ’(nâˆ’k))xï¼Œä»£ç ã€‚ nmm å¤ä¹ ä¸å®Œäº†ï¼Œé¢˜åšä¸å®Œäº†ã€‚ æ€ä¹ˆ To do List çš„å¢é•¿é€Ÿåº¦éƒ½æ¯”æˆ‘åšå¾—å¿«å•Šã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/15(#17)ï¼šå •å…¥è¿™æ— å°½çš„é»‘å¤œ","slug":"default/è®°å½•/2024/2/2024-02-15","date":"2024-02-15T00:00:00.000Z","updated":"2024-02-15T00:00:00.000Z","comments":true,"path":"295d17d/","link":"","permalink":"https://james1badcreeper.github.io/295d17d/","excerpt":"å˜¿å˜¿ï¼Œé¢˜å†™ä¸å®Œäº†ï¼","text":"å˜¿å˜¿ï¼Œé¢˜å†™ä¸å®Œäº†ï¼ æˆ‘å¡èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº†èšŒåŸ ä½äº† [Ptz Winter 2020 Day3] Cells Blocking Portal. æ­»è·¯ä¸€æ¡å’Œå¿…ç»ä¹‹è·¯çš„è´¡çŒ®å¾ˆå¥½ç»Ÿè®¡ã€‚ åªèƒ½å µæ­»æ–œçº¿çš„å·¦ä¸‹æˆ–è€…å³ä¸Šï¼Œæ¯”å¦‚å µå·¦ä¸‹çš„æ—¶å€™ï¼Œå³ä¸Šå°½å¯èƒ½å‘å³èµ°ï¼Œå·¦ä¸‹çš„å³ä¸Šä¸€ä¸ªå°½å¯èƒ½å¾€ä¸‹èµ°ï¼Œè¿™ä¸¤ä¸ªæ’åœ¨ä¸€èµ·å°±æ­»äº†ã€‚ä»£ç ã€‚ [AGC012E] Camel and Oases Portal. VVV åªæœ‰ logâ¡\\loglog ä¸ªï¼Œé‚£ä¹ˆæŠŠè¿™ä¸ªç»™æ±‚å‡ºæ¥ï¼Œç„¶åç»Ÿè®¡ L,RL,RL,R ä»£è¡¨æ¯ä¸ª vvv èƒ½æ‰©å±•åˆ°çš„æœ€å·¦è¾¹å’Œæœ€å³è¾¹ï¼Œå†çŠ¶å‹å‡º fS,gSf_S,g_SfSâ€‹,gSâ€‹ ä»£è¡¨å‰åç¼€æœ€è¿œèƒ½èµ°å¤šå°‘ï¼Œç„¶åå¤„ç†å‡ºæ‰€æœ‰åˆå§‹ VVV èƒ½èµ°åˆ°çš„çº¿æ®µï¼Œå­é›†åˆå¹¶å‰åç¼€å³å¯ã€‚ä»£ç ã€‚ è¿˜æœ‰æ²¡å®Œæˆçš„å†…å®¹ï¼ B. Festival Decorating Portal. çœ‹ä¸Šå»å°±æ˜¯é—¹é¬¼çš„å‘¢ï¼å®é™…ä¸Šå®ƒçš„è§£æ³•æ›´ä¸ºé—¹é¬¼ï¼ æˆ‘ä»¬è€ƒè™‘å¯¹äºæ¯ä¸ªç¯å¼€ä¸€ä¸ª bitset ç»´æŠ¤è·ç¦»å®ƒå³è¾¹ xxx çš„ç¯æ˜¯å¦å­˜åœ¨ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ O(n2/w)O(n^2/w)O(n2/w)ï¼Œç©ºé—´å¼€ä¸ä¸‹ã€‚æˆ‘ä»¬å¯ä»¥æœ‰ 50%50\\%50% çš„è¯¯å·®ï¼Œå› æ­¤å¼€å¯¹æ•°ä¸ª bitsetï¼Œå­˜åˆ°å¯¹æ•°é‡Œå³å¯ã€‚ä»£ç ã€‚ E. Period of a String Portal. è¿˜æ˜¯å¾ˆæœ‰æ„æ€çš„ã€‚ å‘ç°å¯ä»¥è½¬åŒ–ä¸ºå¯¹ä¸€ä¸ªå‰ç¼€å­—ç¬¦é›†çš„é™åˆ¶ï¼Œä½¿ç”¨ä¸€ä¸ª vector ç»´æŠ¤å­—ç¬¦é›†è¢«æ‹†æˆçš„æ¯ä¸€æ®µï¼Œæ—¶é—´å¤æ‚åº¦ O(nlogâ¡âˆ£Sâˆ£(logâ¡(n)+26))O(n\\log |S|(\\log (n) + 26))O(nlogâˆ£Sâˆ£(log(n)+26))ï¼Œä»£ç ã€‚ æ‘†æ‘†æ‘†æ‘†æ‘†æ‘†æ‘†ï¼Œæ€ä¹ˆä¼šæ˜¯ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/14(#16)ï¼šç‰ç±³æ·±æµ·","slug":"default/è®°å½•/2024/2/2024-02-14","date":"2024-02-14T00:00:00.000Z","updated":"2024-02-14T00:00:00.000Z","comments":true,"path":"1573c055/","link":"","permalink":"https://james1badcreeper.github.io/1573c055/","excerpt":"çœæµï¼šè§é¬¼äº†ã€‚","text":"çœæµï¼šè§é¬¼äº†ã€‚ å°±åƒä¸€å¹…æ‹¼å›¾ä¸¢äº†ä¸€å—ä¸€æ ·ï¼Œæœ‰åäºŒåº§æ²ƒå°”ç›è¢«æ´—åŠ«ä¸€ç©ºã€‚ æ®è¯´ï¼Œæ˜¯ç©ºé—´å¤§ç›—åœ¨å‡†å¤‡å¹´è´§ã€‚ ç‰ç±³æŠ•æ‰‹æ˜¯å¦‚ä½•ç”Ÿäº§é»„æ²¹çš„å‘¢ï¼Ÿ ç‰ç±³æ·±æµ·çš„æµ·æ°´æ˜¯ç”±èåŒ–çš„é»„æ²¹æ„æˆçš„ï¼ H. Sugar Sweet II Portal. ç»Ÿè®¡å¿…ç„¶å‘ç”Ÿçš„å’Œå¿…ç„¶ä¸å‘ç”Ÿçš„ï¼Œå‰©ä¸‹çš„åœ¨åŸºç¯æ ‘ä¸Šè·‘ä¸€ä¸‹å³å¯ã€‚ä»£ç ã€‚ G. Snake Move Portal. ç›´æ¥æœ€çŸ­è·¯æ‰©å±•è¿™ä¸ªä¸œè¥¿ï¼Œè®°å¾—å’Œåˆå§‹æ—¶è·ç¦»è›‡å°¾çš„ä½ç½®å–ä¸€ä¸ª maxâ¡\\maxmaxã€‚ä»£ç ã€‚ è¿˜æœ‰è®²çš„é¢˜ã€‚ [ARC168E] Subsegments with Large Sums Portal. ç›´æ¥ wqsï¼Œé”™äº†ï¼Œå› ä¸ºä¸æ˜¯å‡¸çš„ã€‚ äºŒåˆ†ç­”æ¡ˆï¼Œç°åœ¨æ˜¯è¯´ï¼Œç­”æ¡ˆä¸º xxxï¼Œæ˜¯å¦èƒ½å¤Ÿåˆ’å‡º kkk ä¸ªè¿ç»­æ®µï¼Ÿè®¾ fnf_nfnâ€‹ åˆ’å‡º xxx ä¸ªæ®µæ»¡è¶³æ¡ä»¶ï¼Œæœ€å°çš„ä»£ä»·ã€‚ä¸º fnâ‰¤nâˆ’kf_n\\le n -kfnâ€‹â‰¤nâˆ’k æ—¶åˆæ³•ï¼Œwqs äºŒåˆ†å³å¯ã€‚ä»£ç ã€‚ [Ptz 2020 Winter Day 6] The Destruction of the Crystals Portal. é™¤äº†ç¬¬ä¸€ä¸ªå¼•çˆ†çš„ç‚¸å¼¹ï¼Œå‰©ä¸‹çš„ç‚¸å¼¹éƒ½å¯ä»¥è§†ä½œåå­—ç‚¸å¼¹ã€‚ ç„¶åç¯å¯ä»¥ç›´æ¥ç®—è´¡çŒ®ã€‚å¦‚æœè¿™ä¸ªåˆ—åªæœ‰ä¸€ä¸ªé‚£ä¹ˆå¯ä»¥æ¨ªç€ç‚¸ï¼Œå¦åˆ™ä¸€å®šè¦ç«–ç€ç‚¸ã€‚å¹¶æŸ¥é›†ç»´æŠ¤å³å¯ã€‚æ³¨æ„ç»Ÿè®¡ç¯çš„è´¡çŒ®ï¼Œä»£ç ã€‚ [XXI Open Cup, GP of Korea] Query On A Tree 17 Portal. é¦–å…ˆæ˜¯é‡å¿ƒçš„æ€§è´¨ï¼Œå­æ ‘æƒå€¼å’Œä¸€å®šä¸¥æ ¼å¤§äºæ‰€æœ‰ç‚¹æƒå€¼å’Œçš„ä¸€åŠã€‚ å†™ DFS åºï¼Œç¬¬ iii ä¸ªæ•°å†™ aia_iaiâ€‹ æ¬¡ï¼Œæœ€ä¸­é—´çš„æ•°ä¸€å®šæ˜¯å­æ ‘é‡Œçš„ï¼Œå€å¢è·³çˆ¶äº²å³å¯ã€‚ä»£ç ã€‚ å‰©ä¸‹çš„å†™ä¸åŠ¨äº†ï¼Œå†™ç‚¹æœ‰æ„æ€çš„ã€‚ æ€ä¹ˆæ˜å¤©è¿˜æœ‰å•Šï¼Œå¥½æƒ³å¿µæ¨¡æ‹Ÿèµ›ã€‚ [PA2021] Poborcy podatkowi Portal. çœ‹ä¸Šå»æœ‰ç‚¹é—¹é¬¼ï¼Œä½†å®é™…ä¸Šä¹Ÿæ¯”è¾ƒé—¹é¬¼ã€‚ è®¾ fi,0âˆ¼3f_{i,0\\sim 3}fi,0âˆ¼3â€‹ ä»£è¡¨èŠ‚ç‚¹ iii å‘ä¸Šä¼ é•¿åº¦çš„é“¾çš„æœ€å¤§è´¡çŒ®ï¼Œåˆå¹¶çš„æ—¶å€™æ˜¯æ ‘å½¢èƒŒåŒ…çš„å½¢å¼ï¼Œæ­»äº†ã€‚ ä½†æ˜¯æ‰“ä¹±å„¿å­é¡ºåºï¼Œ1,31,31,3 é•¿åº¦é“¾çš„å·®å€¼åœ¨åˆå¹¶çš„è¿‡ç¨‹ä¸­ä¸ä¼šå˜å¾—å¾ˆå¤§ï¼Œè®¾ä¸€ä¸ª BBB å³å¯ã€‚ä»£ç ã€‚ æœ€è¿‘åº”è¯¥ä¼šæŠ½å‡ºæ—¶é—´è¡¥ä¸€è¡¥å¤ä¹ ç¬”è®°ï¼Œå†çœ‹çœ‹å§ï¼","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/13(#15)ï¼šç«å±±å¯ä¹","slug":"default/è®°å½•/2024/2/2024-02-13","date":"2024-02-13T00:00:00.000Z","updated":"2024-02-13T00:00:00.000Z","comments":true,"path":"5fc9eb51/","link":"","permalink":"https://james1badcreeper.github.io/5fc9eb51/","excerpt":"å°æ—¶å€™ç©è¿‡ä¸€ä¸ªåå­—å«åšâ€œå¯ä¹â€çš„æ¸¸æˆï¼Œä¸€ä¸ªå›åˆå†…å¯ä»¥è·å¾—ä¸€ç“¶å¯ä¹ï¼Œæ‘‡æ™ƒä¸€ç“¶å¯ä¹ï¼Œå–·å‡ºä¸€ç“¶å¯ä¹æˆ–è€…é˜²å¾¡ã€‚è°è¢«å¯ä¹å–·åˆ°äº†è°å°±æ­»äº†ï¼Œå¥½åƒè¿˜æ˜¯æ¯”è¾ƒæœ‰è¶£çš„ã€‚","text":"å°æ—¶å€™ç©è¿‡ä¸€ä¸ªåå­—å«åšâ€œå¯ä¹â€çš„æ¸¸æˆï¼Œä¸€ä¸ªå›åˆå†…å¯ä»¥è·å¾—ä¸€ç“¶å¯ä¹ï¼Œæ‘‡æ™ƒä¸€ç“¶å¯ä¹ï¼Œå–·å‡ºä¸€ç“¶å¯ä¹æˆ–è€…é˜²å¾¡ã€‚è°è¢«å¯ä¹å–·åˆ°äº†è°å°±æ­»äº†ï¼Œå¥½åƒè¿˜æ˜¯æ¯”è¾ƒæœ‰è¶£çš„ã€‚ æ¯•ä¸šå…¸ç¤¼çš„æ—¶å€™å¥½åƒæŠŠæ›¼å¦¥æ€æ”¾åˆ°äº†å¯ä¹é‡Œã€‚ [Ynoi E2023] TEST_90 Portal. æ‰«æçº¿ï¼Œç„¶åç»´æŠ¤ä¸€æ£µçº¿æ®µæ ‘ä»£è¡¨å½“å‰ä½ç½® [i,r][i,r][i,r] çš„å‡ºç°æ¬¡æ•°ï¼Œæ¯æ¬¡ç›¸å½“äºåŒºé—´ç¿»è½¬ï¼Œç„¶åç»´æŠ¤å†å²ç‰ˆæœ¬å’Œã€‚ å¸¸æ•°å¥½åƒæœ‰ç‚¹å¤§ï¼ŒæŠŠçŸ©é˜µç»™æ‹†äº†å°±è¡Œäº†ï¼Œå‚»ç‹—é¢˜ç›®ä¸å†™äº†ã€‚ VP The 2nd Universal Cup. Stage 22: Hangzhouã€‚ ä¸€äººæ‰“ ICPCï¼Œæ‰“ä¸åŠ¨ã€‚ M. V-Diagram Portal. ç­”æ¡ˆçš„å–å€¼åªæœ‰ [1,n],[1,mn+1],[mnâˆ’1,n][1,n],[1,mn+1],[mn-1,n][1,n],[1,mn+1],[mnâˆ’1,n] ä¸‰ç§ï¼Œç›´æ¥è®¡ç®—ã€‚ D. Operator Precedence Portal. æ„é€ ä¸€ä¸ª x,2,âˆ’1,2,âˆ’1,â‹¯ ,2,âˆ’1,1x, 2, -1, 2, -1, \\cdots, 2, -1, 1x,2,âˆ’1,2,âˆ’1,â‹¯,2,âˆ’1,1 å³å¯ã€‚ J. Mysterious Tree Portal. å…ˆé—® (1,2),â‹¯ ,(nâˆ’1,n)(1,2),\\cdots,(n-1,n)(1,2),â‹¯,(nâˆ’1,n) æ¥æ£€æµ‹è¾¹çš„å­˜åœ¨æ€§ï¼Œå¦‚æœéƒ½ä¸å­˜åœ¨å°±éƒ½ä¸æ˜¯èŠèŠ±ã€‚ æ‰¾ä¸€æ¡è¾¹ï¼Œç„¶åå¼€å§‹å››å¤„é—®å³å¯ã€‚ åšç‚¹æ˜å¤©è®²è¯¾çš„é¢˜ã€‚ [ARC167E] One Square in a Triangle Portal. SSS ä¸ºå¶æ•°æ˜¯å¥½é€ çš„ã€‚ å¥‡æ•°æ—¶ç”¨å¶æ•°çš„é€ æ³•é€ å‡ºäº†å°æ•°ï¼Œäºæ˜¯å°† BBB ç§»åˆ°ä¸€ä¸ª x,yx,yx,y éƒ½æ˜¯å¥‡æ•°çš„åœ°æ–¹é‡æ–°ç®—ä¸€ä¸ªã€‚ æ‘†äº†ï¼Œå‰©ä¸‹çš„é¢˜æ˜å¤©å†è¯´ã€‚ ä»Šå¤©å­¦ä¹ äº†ä¸€ä¸‹å…³äºè‹è‡çš„äº‹æƒ…ï¼šhttps://www.bilibili.com/video/BV1ba41177Sg/ã€‚ æœ‰ç‚¹å¯æ€•ï¼ŒåŒç¿…ç›®å¤ªå¯æ€•äº†ï¼ˆç‘Ÿç‘Ÿå‘æŠ–ï¼‰ï¼","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/12(#14)ï¼šä¸‡ç‰©ç”Ÿè¾‰","slug":"default/è®°å½•/2024/2/2024-02-07","date":"2024-02-07T00:00:00.000Z","updated":"2024-02-12T00:00:00.000Z","comments":true,"path":"f7c7b48f/","link":"","permalink":"https://james1badcreeper.github.io/f7c7b48f/","excerpt":"ä¼ªé€ çš„ã€‚","text":"ä¼ªé€ çš„ã€‚ Fake Love. æœ€è¿‘åœ¨ç©ã€Šç§½ç¿¼ã€‹ï¼Œæ„Ÿè§‰æ˜¯éå¸¸å‰å®³çš„ä½œå“ï¼æ•´ä¸ªä½œå“çš„ä¸–ç•Œè§‚ç›®å‰æ„Ÿè§‰éå¸¸éœ‡æ’¼ï¼ å¯ä»¥è”æƒ³åˆ°ã€Šæ–—ç‰›ã€‹çš„æ­Œè¯ï¼š æ€§å‘å–„ï¼Œæ‰æ˜¯äººç±»æœ€åçš„éª„å‚²å’Œèƒœç®—ï¼ æ‰¾åˆ°è‡ªå·±è®¤ä¸ºå¯¹çš„äº‹æƒ…ï¼Œç„¶åä¸€ç›´åšæŒä¸‹å» [PKUWC2024] Caught in the Middle Portal. å‘ç° Bob æƒ³è¦èµ¢æ˜¯éå¸¸å›°éš¾çš„ï¼Œå°† R è§†ä¸ºå·¦æ‹¬å·ä¿ç•™å³é¢çš„ä¸œè¥¿ï¼ŒL è§†ä¸ºå³æ‹¬å·ä¿ç•™å·¦é¢çš„ä¸œè¥¿ï¼Œç„¶åå®Œç¾æ‹¬å·åŒ¹é…æ˜¯åæ‰‹èµ¢ï¼Œå› ä¸ºå¯ä»¥ä¸‹æ¨¡ä»¿æ£‹æ€æ‰ä¸€ä¸ªå®Œç¾æ‹¬å·åŒ¹é…ï¼Œå¦åˆ™å…ˆæ‰‹å¯ä»¥å…ˆæŠŠå®ƒå˜æˆå®Œç¾æ‹¬å·åŒ¹é…ã€‚ä»£ç ã€‚ [Baltic OI 2018] Love Polygon Portal. ä¸€å¼€å§‹å½¢æˆäºŒå…ƒç¯å¾—æ‰”äº†ï¼Œç›´æ¥æ¨¡æ‹Ÿå³å¯ã€‚æ³¨æ„è‡ªç¯ä¸èƒ½è¿ï¼Œå¯èƒ½ä¸¤ä¸ªè‡ªç¯åˆ†æˆä¸€ç»„ï¼Œä¹Ÿå¯èƒ½è‡ªç¯è¢«å…¶å®ƒæ‹“æ‰‘æ’åºæ—¶éå†åˆ°å¾—èŠ‚ç‚¹æ‹¯æ•‘ã€‚ä»£ç ã€‚ ä»¥åå°è¯•èƒ½ä¸èƒ½å°†ä½œæ¯è°ƒæ•´çš„æ­£å¸¸ä¸€ç‚¹ï¼ æƒ³åœ¨è¿™é‡Œæ”¾ä¸€å¼ å›¾ï¼Œä½†æ˜¯ä¸çŸ¥é“æ”¾ä»€ä¹ˆå¥½ï¼ ä»Šå¤©è¿˜å†æ¬¡å¬äº†å‡ æ¬¡ã€Šç¥æ ‘ã€‹ï¼Œä¼¼ä¹ç»ˆäºèƒ½ç†è§£ä¸€ç‚¹è¿™é¦–æ­Œäº†ï¼ï¼ æˆ‘æ·¹æ²¡åœ¨ä¸‡äººå£°å“çœ¼æ³ªå·²ç»ç›–ä¸ä½å“€ä¼¤Never Give UpNever Give Up [UOJ838] é¾™é—¨å¯¹å†³ Portal. æ ‘å½¢ DP è®¡ç®—å‡ºæ— å¤´éª‘å£«å’Œæœ‰å¤´éª‘å£«çš„æ•°é‡å°±è¡Œäº†ï¼Œæ³¨æ„é€†å…ƒä¼šçˆ†ç‚¸ã€‚ä»£ç ã€‚ [BalticOI 2018] Genetics Portal. è¶…çº§æ— æ•Œç‚«é…·ç‰› X ä¹±æé¢˜ï¼ŒæƒŠè®¶åˆ°äº†ã€‚ å¥½åƒåªä¼š O(n3)O(n^3)O(n3)ï¼Œäº‹å®ä¸Šä¹Ÿçš„ç¡®å¦‚æ­¤ã€‚ç”¨ 4Ã—n4\\times n4Ã—n ä¸ª bitset ç»´æŠ¤æ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ï¼Œéšæœºä¸€ä¸ªé¡ºåºå¯ä»¥åœ¨ LG ä¸Šè¿‡æ‰ï¼Œä½†æ˜¯è¿˜æ˜¯æ¯”è¾ƒæ…¢ã€‚ä»£ç ã€‚ éœ€è¦èªæ˜ä¸€ç‚¹çš„åšæ³•ã€‚æ¯”å¦‚ï¼Œç»Ÿè®¡å·®å¼‚çš„å’Œï¼Ÿéšæœºåˆ†å‡ ç»„çœ‹ä¸Šå»å°±ä¸é”™ï¼Œä½†æ˜¯å¾ˆå¯æƒœï¼Œä¼šè¢«æ„é€ ä¸€ç§æ»¡è¶³æœ‰å¾ˆå¤šè¿‘ä¼¼è§£çš„æ•°æ®ç»™å¡æ‰ã€‚é‚£ä¹ˆåŠ æƒ Hash ç»™å­—ç¬¦ä¸²åŠ æƒå°±å¯ä»¥äº†ï¼Œå¯ä»¥åœ¨ QOJ ä¸Šé€šè¿‡ã€‚ä»£ç ã€‚ [eJOI2022] Adjacent Pairs Portal. é¦–å…ˆï¼Œå¦‚æœåœ¨ä¿®æ”¹çš„è¿‡ç¨‹ä¸­ä¸å­˜åœ¨å·²ç»åˆå§‹å­˜åœ¨çš„å¯¹ï¼Œé‚£ä¹ˆç›´æ¥æšä¸¾å¯¹çš„å…¶ä¸­ä¸€ä¸ªæ•°å‡ ä¸ªã€‚å¦åˆ™æšä¸¾æœ€ç»ˆä¿®æ”¹å¯¹æ¥ç»Ÿè®¡ç­”æ¡ˆå³å¯ã€‚ä»£ç ã€‚ [eJOI2022] Where Is the Root? Portal. å°±æ˜¯ä½ è¦å»é—® 999 æ¬¡ä¸€ä¸ªé›†åˆçš„ LCA æ˜¯å¦åœ¨é›†åˆå†…å»æ‰¾ä¸€ä¸ª 500500500 çš„å·²çŸ¥æ ‘çš„å½¢æ€çš„æ ‘çš„æ ¹ã€‚ é¦–å…ˆæ˜¯ä¸€ä¸ªäº‹å®ï¼Œå¦‚æœæˆ‘å¸¦ä¸Šæ‰€æœ‰å¶å­å»é—®çš„è¯ï¼Œé‚£ä¹ˆ LCA ä¸€å®šæ˜¯æ ¹ã€‚ é‚£ä¹ˆç›´æ¥å°†æ‰€æœ‰çš„å¶å­åŠ å…¥è¯¢é—®ï¼ŒäºŒåˆ†å³å¯ã€‚ä½†æ˜¯è¿™æ ·ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯åœ¨å‰©ä¸‹ä¸¤ä¸ªç‚¹çš„æ—¶å€™ï¼Œå®ƒä»¬éƒ½æ˜¯å¶å­ï¼Œç„¶åå°±æŠŠå¦ä¸€ä¸ªå¶å­æ‰”äº†ï¼Œå°±å¯„äº†ã€‚ æŠŠåˆ°å…¶ä¸­ä¸€ä¸ªå¶å­çš„å­¤ç‹¬é“¾ï¼ˆè¾¹ä¸Šä¸å«æœ‰ä»»ä½•ä¸œè¥¿ï¼‰ç»™æ€äº†ï¼Œç„¶åé—®å‰©ä¸‹çš„å°±å¯ä»¥äº†ã€‚ä»£ç ã€‚ [eJOI2022] Game With Numbers Portal. å¯ä»¥å‘ç°è¿™ä¸ªä¸œè¥¿æ˜¯è¿™æ ·çš„ï¼Œå¦‚æœ mmm æ¯”è¾ƒå¤§ï¼Œé‚£ä¹ˆæ¯æ¬¡è‡³å°‘ç©å®¶äºŒèƒ½æ€æ‰ä¸€åŠçš„æ•°ï¼Œç­”æ¡ˆæœ€åå°±å˜æˆ 000 äº†ã€‚ ç„¶ååªæœ‰ 01 å…³ç³»ï¼ŒO(nm)O(nm)O(nm) å»ºç«‹ 01 Trieï¼Œç›´æ¥ DP å³å¯ã€‚ä»£ç ã€‚ [CF1768F] Wonderful Jump Portal. ç›´æ¥ DPï¼š fi=minâ¡j&lt;i{fj+(iâˆ’j)2Ã—minâ¡aiâ‹¯j}f_i=\\min_{j&lt;i}\\{f_j+(i-j)^2 \\times \\min a_{i\\cdots j}\\} fiâ€‹=j&lt;iminâ€‹{fjâ€‹+(iâˆ’j)2Ã—minaiâ‹¯jâ€‹} å¦‚ä½•ä¼˜åŒ–ï¼Ÿé¦–å…ˆå¯ä»¥å‘ç°ï¼Œæœ€å°å€¼çš„å–å€¼ä¸€å®šåœ¨è·³çš„åŒºé—´çš„å·¦ç«¯æˆ–è€…å³ç«¯ï¼Œå¦åˆ™æ‹†å¼€è·³ä¸€å®šæ›´ä¼˜ã€‚ è¿˜æœ‰ä¸€ä¸ªè¯¡å¼‚çš„æ˜¯ aaa çš„å€¼åŸŸï¼Œè€ƒè™‘ä¸€ä¸ªä¸€ä¸ªè·³ï¼Œæœ‰ï¼š (iâˆ’j)2Ã—minâ¡aiâ‹¯jâ‰¤(iâˆ’j)Ã—n iâˆ’jâ‰¤nminâ¡aiâ‹¯j(i-j)^2 \\times \\min a_{i\\cdots j}\\le (i-j)\\times n\\\\ ~ \\\\ i-j \\le \\frac{n}{\\min a_{i\\cdots j}} (iâˆ’j)2Ã—minaiâ‹¯jâ€‹â‰¤(iâˆ’j)Ã—n iâˆ’jâ‰¤minaiâ‹¯jâ€‹nâ€‹ æšä¸¾æ¯ä¸ª aia_iaiâ€‹ ä½œä¸ºæœ€å°å€¼è¿›è¡Œè½¬ç§»ï¼Œæ ¹å·åˆ†æ²»ä¸€ä¸‹å¯ä»¥å¾—åˆ° O(nn)O(n\\sqrt{n})O(nnâ€‹)ã€‚ä»£ç ã€‚ [CF1764H] Doremyâ€™s Paint 2 Portal. é¦–å…ˆç ´ç¯æˆé“¾ï¼Œç„¶åä»åå¾€å‰æ¨ï¼Œfif_ifiâ€‹ è¡¨ç¤º iii èƒ½å¤Ÿå­˜æ´»åˆ°çš„æ—¶é—´ï¼Œä½¿ç”¨ç‚æœµè‰æ ‘ç»´æŠ¤ fff çš„è¿ç»­æ®µï¼Œæ¯æ¬¡ç›¸å½“äº lll å– maxâ¡\\maxmaxï¼Œl+1âˆ¼rl+1\\sim rl+1âˆ¼r åŒºé—´æŸ“è‰²ï¼Œåœ¨ BIT ä¸Šç»´æŠ¤ç­”æ¡ˆå³å¯ã€‚ä»£ç ã€‚ ã€Šç§½ç¿¼ã€‹çœŸçš„æ˜¯å¤ªæ„Ÿäººäº† å¯¹æˆ‘æ¥è¯´å¥½åƒæœ‰ç‚¹æ„Ÿäººè¿‡åº¦äº†ã€‚ äººçš„ä¸€ç”Ÿä¸­ï¼Œæœ€é‡è¦çš„å°±æ˜¯æ‹¼å‘½åœ°å»æ´»ç€ï¼Œå»å¯»æ‰¾è‡ªå·±ç”Ÿå­˜çš„æ„ä¹‰ã€‚å¦‚ä»Šï¼Œæˆ‘ç»ˆäºæ˜ç™½é‚£å¥è¯çš„æ„æ€ï¼Œé‚£å¹¶ä¸æ˜¯ä»€ä¹ˆå¤æ‚çš„äº‹æƒ…ã€‚åªè¦åšå‡ºé€‰æ‹©å°±å¥½ï¼Œå‘ç€è‡ªå·±æ— è®ºä½•äº‹å‘ç”Ÿï¼Œéƒ½ä¼šå¥‹ä¸é¡¾èº«å‰è¿›çš„é“è·¯ã€‚ æˆ‘ï¼Œå­˜åœ¨çš„æ„ä¹‰æ˜¯ä»€ä¹ˆï¼Ÿ ä¹Ÿè®¸ç°åœ¨ä¼šæœ‰äº›è®¸è¿·èŒ«å§ï¼Œæ‰€ä»¥æ‰è¦å»æ‹¼å‘½çš„å¯»æ‰¾ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/06(#13)ï¼šä¸€ç‚¹æ€è€ƒ","slug":"default/è®°å½•/2024/1/2024-01-28","date":"2024-01-28T00:00:00.000Z","updated":"2024-02-06T00:00:00.000Z","comments":true,"path":"5246d897/","link":"","permalink":"https://james1badcreeper.github.io/5246d897/","excerpt":"æ‘˜è¦ï¼šä¸çŸ¥é“å†™ç‚¹ä»€ä¹ˆã€‚","text":"æ‘˜è¦ï¼šä¸çŸ¥é“å†™ç‚¹ä»€ä¹ˆã€‚ æ€è€ƒå°‘äº†ã€‚ å¥½å¥‡æ€ªå•Šã€‚ [Ptz 2022 Day 2] Ternary Search Portal. æˆ‘ä»¬åªéœ€è¦è€ƒè™‘å•è°·ã€‚ è°·çš„å€¼æ˜¯å¯ä»¥ç¡®å®šçš„ã€‚å¦‚æœæˆ‘ä»¬å°†è°·å·¦è¾¹çš„æ•°å…¨éƒ¨å–ç›¸åæ•°ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯å…¨å±€çš„é€†åºå¯¹æ•°ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬é€šè¿‡æ˜¯å¦å–ç›¸åæ•°æ¥ç¡®å®šå…¶åº”è¯¥æ˜¯åœ¨è°·å€¼çš„å·¦è¾¹è¿˜æ˜¯å³è¾¹ã€‚å¦‚æœå–ç›¸åæ•°ï¼Œé‚£ä¹ˆå®ƒåœ¨å·¦è¾¹ï¼Œå®ƒå¯¹ç­”æ¡ˆçš„è´¡çŒ®æ˜¯åœ¨å®ƒå·¦è¾¹æ¯”å…¶å°çš„ä¸ªæ•° LiL_iLiâ€‹ï¼›å¦‚æœä¸å–ç›¸åæ•°ï¼Œé‚£ä¹ˆå…¶å¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯æ­£å¸¸è®¡å…¥é€†åºå¯¹ç»Ÿè®¡äº†ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥æ­£å¸¸æ±‚é€†åºå¯¹çš„ä¸ªæ•°ï¼Œå½“å…¶èµ°åˆ°å·¦è¾¹çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±åœ¨æ ‘çŠ¶æ•°ç»„ä¸Šæ’¤é”€å®ƒçš„è´¡çŒ®ã€‚ä½•æ—¶å®ƒä¼šè·‘åˆ°å·¦è¾¹ï¼Ÿå½“åœ¨å®ƒå·¦è¾¹æœ‰ xxx ä¸ªæ¯”å®ƒå°çš„æ•°ï¼Œå³è¾¹æœ‰ xxx ä¸ªæ¯”å®ƒå°çš„æ•°çš„æ—¶å€™ï¼Œå°±ä¼šåˆ‡æ¢ï¼Œæ­¤æ—¶ç›´æ¥ç»§æ‰¿åŸæ¥çš„è´¡çŒ®å³å¯ã€‚æ ‘çŠ¶æ•°ç»„ä¸Šå€å¢å³å¯ã€‚ä»£ç ã€‚ [Ptz 2022 Day 2] Floor Tiles in a Park Portal. å¤§åˆ†è®¨é¢˜ã€‚ k=1k=1k=1 æ—¶ç­”æ¡ˆæ˜¯ 111ï¼Œk=2k=2k=2 æ—¶ç­”æ¡ˆæ˜¯ w+hâˆ’1w+h-1w+hâˆ’1ã€‚k=3,k=4k=3,k=4k=3,k=4 æ–¹å¼å’Œ k=5k=5k=5 ä¸€æ ·ã€‚ k=5k=5k=5 æ—¶å¯ä»¥æœ‰ä¸‰æ¡æ¨ªçº¿ç©¿è¿‡å»ï¼Œæ–¹æ¡ˆæ•°å¦‚ä¸‹ï¼š å¯ä»¥æœ‰ä¸¤æ¡æ¨ªçº¿ï¼Œä¸¤æ¡ç«–çº¿ç©¿è¿‡å»ï¼Œå¯¹ç…§æ ·ä¾‹å³å¯æ‰¾åˆ°ç³»æ•°ã€‚ä»£ç ã€‚ [CF1924C] Fractal Origami Portal. æŒºæœ‰è¶£çš„ã€‚ æŠ˜ä¸€æŠ˜å°±çŸ¥é“äº† M=âˆ‘i=0nâˆ’222i,V=22+âˆ‘i=0nâˆ’222iM=\\sum_{i=0}^{n-2} 2\\sqrt{2}^i,V=2\\sqrt{2}+\\sum_{i=0}^{n-2} 2\\sqrt{2}^iM=âˆ‘i=0nâˆ’2â€‹22â€‹i,V=22â€‹+âˆ‘i=0nâˆ’2â€‹22â€‹iã€‚ ç„¶å’Œéšä¾¿åˆä¸€åˆå°±è¡Œäº†ã€‚ä»£ç ã€‚ [CF1924E] Paper Cutting Again Portal. è€ƒè™‘éšæœºå‡ºä¸€ä¸ªæ“ä½œåºåˆ— pppï¼Œæ˜¯ä¸€ä¸ª 1âˆ¼n+mâˆ’21\\sim n + m - 21âˆ¼n+mâˆ’2 çš„æ’åˆ—ã€‚æšä¸¾æ‰€æœ‰åˆ‡çš„ä½ç½®ç§°ä¸ºç­”æ¡ˆçš„æœ€åä¸€æ­¥ï¼Œè€ƒè™‘è®¡ç®—å…¶æ¦‚ç‡ã€‚ åº”è¯¥æ»¡è¶³ [1,iâˆ’1][1,i-1][1,iâˆ’1] çš„è¡Œï¼Œ[1,k/i][1,k/i][1,k/i] çš„åˆ—éƒ½åœ¨ iii è¡Œåå°±å‡ºç°ï¼Œæ¦‚ç‡å¯ä»¥ç›´æ¥è®¡ç®—ä¸º 1m\\frac 1 mm1â€‹ï¼Œç„¶ååŠ ä¸Šå½“å‰è¿™ä¸€æ­¥çš„ 111ï¼Œå³å¯æ±‚å‡ºç­”æ¡ˆã€‚ä»£ç ã€‚ [CF1924F] Anti-Proxy Attendance Portal. Joking åŸºæœ¬ä¸Šå’Œè¿™é“é¢˜ä¸€è‡´ã€‚ å®é™…ä¸Šè¯¢é—®å‘Šè¯‰æˆ‘ä»¬çš„æ˜¯ï¼Œä¸ç®¡æ˜¯çœŸæ˜¯å‡ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ç¼ºå¸­çš„å­¦ç”Ÿåœ¨æŸä¸€ä¸ªé›†åˆé‡Œã€‚ å…è®¸æˆ‘ä»¬çŒœæµ‹ä¸¤æ¬¡çš„åŸå› æ˜¯æ˜æ˜¾çš„ï¼šåœ¨åªå‰©ä¸¤ä¸ªäººçš„æ—¶å€™æˆ‘ä»¬æ²¡æœ‰åŠæ³•å¾—çŸ¥è°æ˜¯ç¼ºå¸­çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çœ‹çœ‹æ€ä¹ˆåœ¨åªå‰©ä¸‰ä¸ªäººçš„æ—¶å€™æ’é™¤ä¸€ä¸ªäººã€‚ ç”±äºè¿™é“é¢˜æ˜¯å¯¹äºè¿ç»­ä¸‰æ¬¡è¯¢é—®çš„æƒ…å†µæœ‰é™åˆ¶ï¼Œæƒ…å†µéå¸¸å¤æ‚ã€‚å› æ­¤æˆ‘ä»¬å…ˆä¸€ç‚¹ä¸€ç‚¹æ¥ï¼š å…ˆé—®ä¸€æ‰‹ Q(1,2)Q(1,2)Q(1,2)ï¼Ÿç¡®å®ï¼Œæ— è®ºå›ç­”æ˜¯ä»€ä¹ˆï¼Œéƒ½æ²¡ä»€ä¹ˆæ„ä¹‰ã€‚é‚£ä¸å¦‚å‡å®šå®ƒçš„å›ç­”å°±æ˜¯ 111ï¼Œå‰©ä¸‹çš„åº”è¯¥æ˜¯å¯¹ç§°çš„ã€‚ å†é—®ä¸€æ‰‹ Q(1,1)Q(1,1)Q(1,1)ï¼Ÿ å¦‚æœå®ƒå›ç­”äº†ä¸€ä¸ª 111ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦å†é—®ä¸€ä¸ª Q(1,3)Q(1,3)Q(1,3)ï¼Œå¦‚æœå®ƒçš„å›ç­”ä¹Ÿæ˜¯ 111ï¼Œé‚£ä¹ˆ 111 å°±ä¸€å®šä¸æ˜¯ç¼ºå¸­çš„ï¼Œå¦åˆ™è¿ç»­ä¸‰æ¬¡å›ç­”éƒ½æ˜¯çœŸçš„äº†ï¼›å¦‚æœ Q(1,3)Q(1,3)Q(1,3) å›ç­”äº†ä¸€ä¸ª 000ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€ä¸ªå‡çš„ï¼Œå‰ä¸¤é—® Q(1,2)Q(1,2)Q(1,2) å’Œ Q(1,1)Q(1,1)Q(1,1) ä¸€å®šä¸èƒ½éƒ½æ˜¯å‡çš„ï¼Œå¦‚æœå®ƒä»¬éƒ½æ˜¯å‡çš„ï¼Œé‚£ä¹ˆå°±è¯æ˜äº† 333 æ˜¯ç¼ºå¸­çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ333 ä¸€å®šä¸æ˜¯ç¼ºå¸­çš„ã€‚ å¦‚æœå®ƒå›ç­”äº†ä¸€ä¸ª 000ï¼Œå°±ç›¸å½“äº Q(2,3)Q(2,3)Q(2,3) å›ç­”äº† 111ã€‚é‚£ä¹ˆè¿™æ—¶å€™å†é—®ä¸€æ‰‹ Q(1,2)Q(1,2)Q(1,2)ï¼Œå¦‚æœæ­¤æ—¶å›ç­”çš„æ˜¯ 111ï¼Œé‚£ä¹ˆä¸‰æ¬¡å›ç­”ä¸èƒ½éƒ½ä¸ºçœŸï¼Œ222 å°±ä¸€å®šä¸æ˜¯ç¼ºå¸­çš„ï¼›å¦‚æœ Q(1,2)Q(1,2)Q(1,2) å›ç­”äº† 000ï¼Œå°±ç›¸å½“äº Q(3,3)Q(3,3)Q(3,3) å›ç­”äº† 111ã€‚æ­¤æ—¶èƒ½ç¡®å®šä»€ä¹ˆå—ï¼Ÿè¿˜çœŸä¸èƒ½ï¼Œåªå¥½åœ¨é—®ä¸€æ¬¡ Q(1,3)Q(1,3)Q(1,3)ï¼Œå°±å›åˆ°äº†ä¸Šä¸€ç§æƒ…å†µã€‚ å³ä½¿æˆ‘ä»¬æ’é™¤äº†ä¸­é—´çš„ 222ï¼Œå…¶å¹¶ä¸ä¼šå½±å“æ¥ä¸‹æ¥çš„è¯¢é—®çš„ç­”æ¡ˆï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥ä¸‰åˆ†ï¼Œæ¯æ¬¡ä½¿ç”¨å››æ¬¡è¯¢é—®æ¥æ’é™¤æ‰ 1/31/31/3 çš„ç­”æ¡ˆï¼Œå¤§çº¦ä¼šä½¿ç”¨ 112112112 æ¬¡è¯¢é—®ï¼Œè€Œé¢˜ç›®åªå…è®¸æˆ‘ä»¬ä½¿ç”¨ 102102102 æ¬¡è¯¢é—®ï¼å¥½åƒåºŸæ‰äº†ï¼ ä½†æ˜¯æˆ‘ä»¬çœŸçš„æ¯æ¬¡å¿…é¡»ç”¨ 444 æ¬¡è¯¢é—®å—ï¼Ÿæˆ‘ä»¬è§‚å¯Ÿä¸€ä¸‹éœ€è¦ä½¿ç”¨å››æ¬¡è¯¢é—®çš„æƒ…å†µï¼Œå‘ç°å®ƒä»¬æœ‰ä¸€ä¸ªç‰¹ç‚¹ï¼šæ’é™¤çš„ä¸€å®šä¸æ˜¯ 222ã€‚ ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬è®© 222 åˆ†çš„å°ä¸€ç‚¹å°±å¯ä»¥äº†ï¼æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ DP æ¥æ±‚è§£ 222 åˆ†å¤šå°‘ã€‚è®¾ fnf_nfnâ€‹ ä»£è¡¨é—®é¢˜è§„æ¨¡ä¸º nnn çš„æ—¶å€™ï¼Œè‡³å°‘ä½¿ç”¨å¤šå°‘æ¬¡è¯¢é—®ï¼Œæšä¸¾ 222 åˆ†çš„ä¸ªæ•° jjjï¼Œé‚£ä¹ˆ fn=minâ¡j=1nâˆ’2{maxâ¡{fnâˆ’j+3,fnâˆ’(nâˆ’j)/2+4}}f_n=\\min_{j=1}^{n-2}\\{\\max\\{f_{n-j}+3,f_{n-(n-j)/2}+4\\}\\}fnâ€‹=minj=1nâˆ’2â€‹{max{fnâˆ’jâ€‹+3,fnâˆ’(nâˆ’j)/2â€‹+4}}ï¼Œè·‘ä¸åŠ¨ã€‚ ä½†æ˜¯æˆ‘ä»¬å¯ä»¥è§‚æµ‹è½¬ç§»ç‚¹ï¼è·‘ n=104n=10^4n=104ï¼Œè½¬ç§»ç‚¹çš„å¹³å‡å€¼æ˜¯ 0.3n0.3n0.3nï¼Œäºæ˜¯ç›´æ¥æŒ‰ç…§æ¯”ä¾‹åˆ†å°±è¡Œäº†ã€‚ä»£ç ã€‚ [CF1056H] Detect Robots Portal. å°±æ˜¯è¦åˆ¤æ–­æ˜¯å¦å‡ºç°è¿‡ xâ†’aâ†’â‹¯â†’y,xâ†’bâ†’â‹¯â†’yx\\rightarrow a\\rightarrow \\cdots\\rightarrow y,x\\rightarrow b\\rightarrow \\cdots\\rightarrow yxâ†’aâ†’â‹¯â†’y,xâ†’bâ†’â‹¯â†’y çš„æƒ…å†µã€‚ æ ¹å·åˆ†æ²»ã€‚å¯¹äºå°ä¸²ï¼Œå¯¹äºæ¯ä¸ªç»ˆç‚¹ yyy å¼€ä¸€ä¸ª vectorï¼Œpush_back æ‰€æœ‰çš„èµ·ç‚¹å¯¹åº”çš„ (x,t)(x,t)(x,t) å¯¹ï¼Œæ€»ä¸ªæ•°æ˜¯ O(nn)O(n\\sqrt{n})O(nnâ€‹) çš„ã€‚å¯¹äºå¤§ä¸²ï¼Œè®°å½•æ‰€æœ‰ç‚¹çš„å‡ºç°ä½ç½®ï¼Œå¯¹äºæ¯ä¸ªä¸²ä»åå¾€å‰æ‰«ï¼Œè®°å½•å½“å‰æœ€å¤§çš„ç»ˆç‚¹ä½ç½®ç„¶ååˆ¤æ–­å³å¯ã€‚ä»£ç ã€‚ æ°´ä¸€ä¸‹ Div.3ï¼Œç»™å°å·ä¸Šä¸Šåˆ†ï¼ å®Œè›‹ï¼Œå¤§æ„äº†ğŸ˜…","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/01/23(#12)ï¼šå‰å¾€æœ«æ—¥çš„æ—…è¡Œ","slug":"default/è®°å½•/2024/1/2024-01-23","date":"2024-01-23T00:00:00.000Z","updated":"2024-01-23T00:00:00.000Z","comments":true,"path":"4d6f0c5/","link":"","permalink":"https://james1badcreeper.github.io/4d6f0c5/","excerpt":"åˆæ€èƒ½å¾—çŸ¥ã€‚","text":"åˆæ€èƒ½å¾—çŸ¥ã€‚ æœ€åå‰©ä¸‹æˆ‘ æˆ‘ä»€ä¹ˆéƒ½æ²¡æœ‰ æœ«æ—¥çš„é£èˆ¹ è½½ç€æˆ‘çš„éª¨å¤´ å°†è‡ªç”±å’Œå æœ‰ï¼Œæ‘§æ¯å¾—ç‰‡ç”²ä¸ç•™ã€‚ [ARC106E] Medals Portal. ç›´æ¥å°†æ¯ä¸ªäººæ‹†æˆ kkk ä¸ªç‚¹ï¼Œå‘å³éƒ¨çš„äºŒåˆ†å‡ºçš„ç­”æ¡ˆå¤©è¿›è¡ŒåŒ¹é…ï¼Œè¿‡ä¸å»ã€‚ å‘ç°æˆ‘ä»¬è¦æ±‚å®Œç¾åŒ¹é…ï¼Œæ‰€ä»¥ç›´æ¥ Hall å®šç†åˆ¤æ–­æ˜¯å¦å­˜åœ¨å³å¯ã€‚ä»£ç ã€‚ [ARC106F] Figures Portal. æšä¸¾æ¯ä¸ªç‚¹çš„åº¦æ•° rir_iriâ€‹ï¼Œå¯ä»¥è®¡æ•°ï¼š Ans=âˆ‘âˆ‘ri=2nâˆ’2(nâˆ’2)!âˆ(riâˆ’1)!Ã—âˆAdiri=âˆ‘âˆ‘ri=2nâˆ’2(nâˆ’2)!Ã—âˆAdiri(riâˆ’1)!\\begin{aligned} Ans&amp;=\\sum_{\\sum r_i=2n-2}\\dfrac{(n-2)!}{\\prod(r_i-1)!}\\times \\prod A_{d_i}^{r_i}\\\\ &amp;=\\sum_{\\sum r_i=2n-2}(n-2)!\\times \\prod \\frac{A_{d_i}^{r_i}}{(r_i-1)!} \\end{aligned} Ansâ€‹=âˆ‘riâ€‹=2nâˆ’2âˆ‘â€‹âˆ(riâ€‹âˆ’1)!(nâˆ’2)!â€‹Ã—âˆAdiâ€‹riâ€‹â€‹=âˆ‘riâ€‹=2nâˆ’2âˆ‘â€‹(nâˆ’2)!Ã—âˆ(riâ€‹âˆ’1)!Adiâ€‹riâ€‹â€‹â€‹â€‹ æŠŠåé¢é‚£ä¸ªä¸œè¥¿å†™æˆ EGFï¼Œä¹Ÿå°±æ˜¯è¯´ï¼š Fi(x)=âˆ‘k=0âˆAdik(kâˆ’1)!xk=âˆ‘k=0âˆ(dik)k xk=diâˆ‘k=1âˆ(diâˆ’1kâˆ’1) xk=dixâˆ‘k=0âˆ(diâˆ’1k) xk=dix(1+x)diâˆ’1\\begin{aligned} F_i(x) &amp;= \\sum_{k=0}^{\\infty} \\frac{A_{d_i}^k}{(k - 1)!}x^k \\\\ &amp; = \\sum_{k=0}^{\\infty} \\binom{d_i} k k \\ x^k \\\\ &amp; = d_i \\sum_{k=1}^{\\infty} \\binom{d_i - 1} {k - 1}\\ x^k \\\\ &amp; = d_i x \\sum_{k=0}^{\\infty} \\binom{d_i - 1} {k} \\ x^k \\\\ &amp; = d_i x (1 + x)^{d_i - 1} \\end{aligned} Fiâ€‹(x)â€‹=k=0âˆ‘âˆâ€‹(kâˆ’1)!Adiâ€‹kâ€‹â€‹xk=k=0âˆ‘âˆâ€‹(kdiâ€‹â€‹)k xk=diâ€‹k=1âˆ‘âˆâ€‹(kâˆ’1diâ€‹âˆ’1â€‹) xk=diâ€‹xk=0âˆ‘âˆâ€‹(kdiâ€‹âˆ’1â€‹) xk=diâ€‹x(1+x)diâ€‹âˆ’1â€‹ è®° S=âˆ‘diS=\\sum d_iS=âˆ‘diâ€‹ï¼Œé‚£ä¹ˆï¼š Ans=(nâˆ’2)!Ã—[x2(nâˆ’1)]âˆi=1nFi(x)=(nâˆ’2)!Ã—[x2(nâˆ’1)]âˆi=1ndix(1+x)diâˆ’1=(nâˆ’2)!Ã—âˆi=1ndiÃ—[xnâˆ’2]âˆi=1n(1+x)diâˆ’1=(nâˆ’2)!Ã—âˆi=1ndiÃ—[xnâˆ’2](1+x)Sâˆ’n=(nâˆ’2)!Ã—âˆi=1ndiÃ—(Sâˆ’nnâˆ’2)\\begin{aligned} Ans&amp;= (n - 2)!\\times [x^{2(n-1)}] \\prod_{i=1}^nF_i(x)\\\\ &amp;= (n - 2)!\\times [x^{2(n-1)}] \\prod_{i=1}^n d_i x (1 + x)^{d_i - 1}\\\\ &amp;= (n - 2)!\\times\\prod_{i=1}^n d_i \\times [x^{n - 2}] \\prod_{i=1}^n (1 + x)^{d_i - 1} \\\\ &amp;= (n - 2)!\\times\\prod_{i=1}^n d_i \\times [x^{n - 2}] (1 + x)^{S - n} \\\\ &amp;= (n - 2)!\\times\\prod_{i=1}^n d_i \\times \\binom{S - n}{n-2} \\end{aligned} Ansâ€‹=(nâˆ’2)!Ã—[x2(nâˆ’1)]i=1âˆnâ€‹Fiâ€‹(x)=(nâˆ’2)!Ã—[x2(nâˆ’1)]i=1âˆnâ€‹diâ€‹x(1+x)diâ€‹âˆ’1=(nâˆ’2)!Ã—i=1âˆnâ€‹diâ€‹Ã—[xnâˆ’2]i=1âˆnâ€‹(1+x)diâ€‹âˆ’1=(nâˆ’2)!Ã—i=1âˆnâ€‹diâ€‹Ã—[xnâˆ’2](1+x)Sâˆ’n=(nâˆ’2)!Ã—i=1âˆnâ€‹diâ€‹Ã—(nâˆ’2Sâˆ’nâ€‹)â€‹ [QOJ 4800] Oscarâ€™s Round Must Have a Constructive Problem Portal. å€’ç€æ„é€ ï¼Œæœ‰ä¸åˆæ³•çš„ç›´æ¥ swap ä¸€ç»„å³å¯ã€‚ [QOJ 4803] Candies Portal. ä»¤ ai&gt;x/2a_i&gt;x/2aiâ€‹&gt;x/2 çš„å˜æˆ xâˆ’aix-a_ixâˆ’aiâ€‹ï¼Œdeque æ¨¡æ‹ŸåŒ¹é…å³å¯ã€‚ [Ynoi E2024] TEST_133 Portal. åˆ†å—ï¼Œæ¯ä¸ªå—å†…æ­£å¸¸ç»´æŠ¤å†å²æœ€å¤§ tagï¼Œç„¶åå†ç»´æŠ¤ä¸€ä¸‹æ’åºåçš„ç»“æœï¼Œæ¯æ¬¡æŸ¥è¯¢çš„æ—¶å€™æš´åŠ›äºŒåˆ†ä¸€ä¸‹ï¼Œæ•£å—ç›´æ¥ pushdown æ•´å—çš„æ ‡è®°ã€‚æ³¨æ„æŸ¥è¯¢çš„æ•´å—æ²¡æœ‰é‡æ„ï¼Œéœ€è¦è®¡ç®—äºŒåˆ†å‡ºçš„ä½ç½®çš„å†å²æœ€å€¼ã€‚ä»£ç ã€‚ [QOJ 4807] Melborp Lacissalc Portal. å…ˆè§£å†³åˆ¤å®šé—®é¢˜ã€‚åšä¸€éæ¨¡ kkk æ„ä¹‰ä¸‹çš„å‰ç¼€å’Œï¼Œç„¶åç»„åˆæ•°éšä¾¿ç®—ä¸€ä¸‹å³å¯ã€‚ å› æ­¤å¯ä»¥ç›´æ¥å¯¹ç€å‰ç¼€å’Œæ•°ç»„è¿›è¡Œ DPã€‚è®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ è¡¨ç¤ºè€ƒè™‘å‰ iii ç§æ•°ï¼Œæ”¾è¿›äº† jjj ä¸ªä½ç½®ï¼Œå½“å‰è´¡çŒ®ä¸º kkkï¼Œç›´æ¥è·‘å³å¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"NOI äºŒè½®å¤ä¹  IIï¼šæ„é€ ä¸åˆ›é€ æ€§æ€ç»´","slug":"notes/NOI å¤ä¹ /noi-2-2","date":"2024-01-05T00:00:00.000Z","updated":"2024-01-09T00:00:00.000Z","comments":true,"path":"da93401a/","link":"","permalink":"https://james1badcreeper.github.io/da93401a/","excerpt":"æœ¬æ–‡æ˜¯ NOI äºŒè½®å¤ä¹ çš„ç¬¬äºŒç¯‡ï¼Œä»‹ç»äº†æœ‰å…³äºéä¼ ç»Ÿé¢˜ç›®çš„æ€è€ƒæ–¹å¼ã€‚","text":"æœ¬æ–‡æ˜¯ NOI äºŒè½®å¤ä¹ çš„ç¬¬äºŒç¯‡ï¼Œä»‹ç»äº†æœ‰å…³äºéä¼ ç»Ÿé¢˜ç›®çš„æ€è€ƒæ–¹å¼ã€‚ å¹¿ä¹‰æ¥è¯´ï¼Œæ‰€æœ‰é—®é¢˜éƒ½å±äºæ„é€ ç±»é—®é¢˜â€”â€”å®ƒä»¬éƒ½éœ€è¦æ„é€ è§£ã€‚ æ­¤ç±»é¢˜ç›®ä¸­ä¹Ÿæœ‰è¾ƒå¤š ad-hoc é¢˜ï¼Œéœ€è¦æˆ‘ä»¬ä»å¤šä¸ªè§’åº¦æ€è€ƒï¼Œå‘æŒ¥è‡ªå·±çš„æƒ³è±¡åŠ›ã€‚ æˆ‘ä»¬ä¸èƒ½å¯¹äºæ¯é“é¢˜éƒ½æšä¸¾æ‰€æœ‰å¥—è·¯é€ä¸€è¯•é”™ï¼Œè€Œéœ€è¦å…·ä½“æƒ…å†µå…·ä½“åˆ†æã€‚ä¸åº”å½“å®Œå…¨ä¾é çŒœæˆ–è¯•æ‰¾å‡ºæ¥ï¼Œè€Œæ˜¯ä¸»è¦é€šè¿‡çº¿ç´¢æ¨æ–­å‡ºæ¥ã€‚å®ƒä»¬åŒ…æ‹¬ä½†ä¸é™äºï¼š ç‰¹æ®Šçš„é¢˜ç›®æ¡ä»¶ã€æ•°æ®èŒƒå›´ ç‰¹æ®Šæ€§è´¨ã€éƒ¨åˆ†åˆ† å¿…ç„¶æ€§ã€å……åˆ†æ€§ æ¨¡å‹çš„è§‚å¯Ÿä¸è½¬åŒ– æ‰“è¡¨çš„ç»“æœ æ³¨æ„åœ¨åšæ­¤ç±»é¢˜ç›®æ—¶ï¼Œè¦é¿å…è‡ªå·±é™·å…¥æ€ç»´æ­»å±€ã€‚ å¸¸è§æ¨¡å‹ ä¸€äº›é—®é¢˜å¸¸åœ¨ç‰¹å®šç»“æ„ä¸Šå‡ºç°ã€‚ DFS æ ‘ æ— å‘å›¾çš„ DFS æ ‘æ˜¯æ²¡æœ‰æ¨ªå‰è¾¹çš„ï¼Œå¯ä»¥æ ¹æ®æ­¤æ¥å®Œæˆä¸€äº›é¢˜ç›®ã€‚ ã€ŒPMOI-4ã€å¯æ€œçš„å›¢ä¸»ã€‚ç›´æ¥è·‘ DFS æ ‘ï¼Œå¦‚æœå¶å­è¶³å¤Ÿå°±ç›´æ¥æ„é€ ï¼ˆå› ä¸ºæ²¡æ¨ªå‰è¾¹ï¼‰ï¼Œå¦åˆ™ä¾æ¬¡è¿è¾¹å³å¯ã€‚ä»£ç ã€‚ å›¾è®ºç›¸å…³ å›¾è®ºç›¸å…³çš„å†…å®¹éå¸¸å¤šï¼Œå¯ä»¥å‚è§ä»¥ä¸‹è¡¨æ ¼ã€‚ åŸºç¡€æ€§è´¨CF1444Cã€‚æˆ‘ä»¬çŸ¥é“ âˆ‘degâ¡=O(m)\\sum \\operatorname{deg}=O(m)âˆ‘deg=O(m)ï¼Œå› æ­¤å†…éƒ¨åˆ¤æ–­å®Œä¹‹åï¼Œç›´æ¥æšä¸¾å°±æ˜¯å¯¹çš„ã€‚ zig-zag pattern å³ä¹‹å­—å½¢æ„é€ ã€‚ P9837 æ±ªäº†ä¸ªæ±ªã€‚æ‰€æœ‰çš„æ— åºæ•°å¯¹éƒ½è¦æ°å¥½å‡ºç°ä¸€æ¬¡ï¼Œé‚£ä¹ˆæŒ‰ç…§é¡ºåºå¡«ï¼ŒæŒ‰ç…§æ— åºæ•°å¯¹çš„å·®åˆ†ç±»å³å¯ã€‚ Coprime Matricesã€‚æ„é€ æ—¶ç›´æ¥å°†æ¯ä¸¤åˆ—æŒ‰ç…§ä¹‹å­—å½¢å·¦å³æ¥å›èµ°å³å¯ï¼Œä¾èµ– gcdâ¡(x,x+1)=1\\gcd(x,x+1)=1gcd(x,x+1)=1ï¼Œå› æ­¤å¯¹äº www çš„å¤„ç†åç§»ä¸€ä¸‹å³å¯ã€‚ä»£ç ã€‚ ç»¼åˆåº”ç”¨ ä¸€äº›æ‚é¢˜ã€‚ æ„é€ é¢˜ç»„ 1 ä¸€äº›é¢˜ã€‚ [CF1503F] Balance the Cards Portal. è€ƒè™‘å¯¹äºæ­£åé¢éƒ½åˆ†åˆ«è¿ aâ†’âˆ’aa\\to -aaâ†’âˆ’aï¼Œé‚£ä¹ˆå¦‚æœä¸€å¼ ç‰Œå…¥åº¦ä¸ºä¸€å‡ºåº¦ä¸ºä¸€åˆ™å¯ä»¥ç¼©ç‚¹ï¼Œå¦åˆ™ä¸€å®šå…¥åº¦ä¸ºäºŒæˆ–è€…å‡ºåº¦ä¸ºäºŒï¼Œå‡ºåº¦ä¸ºäºŒå¿…é¡»å‡ºåˆ°ç›¸åŒçš„åœ°æ–¹ï¼Œå¦åˆ™æ— è§£ã€‚æ ¹æ®æ­¤ç›´æ¥æ„é€ å³å¯ï¼Œèƒ½è¯æ˜è¿™æ˜¯æœ‰è§£çš„å……è¦æ¡ä»¶ï¼Œå¯ä»¥å‚è€ƒå®˜æ–¹é¢˜è§£ã€‚ä»£ç ã€‚ äº¤äº’é¢˜ç»„ 1 ä¸€äº›é¢˜ã€‚ [IOI2022] æœ€ç½•è§çš„æ˜†è™« Portal. ç›´æ¥æ‰«ä¸€éè¿‡å»å¯ä»¥å¾—åˆ°é¢œè‰²æ•°ï¼Œç„¶åå¯ä»¥äºŒåˆ†ç­”æ¡ˆï¼ŒäºŒåˆ†çš„æ—¶å€™æ¯æ¬¡å¯ä»¥æ’é™¤æ‰ä¸€åŠä»¥ä¸Šçš„åŒºé—´ä¸å†è€ƒè™‘ï¼Œé‚£ä¹ˆè¯¢é—®æ¬¡æ•°æ˜¯å¯¹çš„ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"NOI äºŒè½®å¤ä¹  Iï¼šæ·±å…¥åˆ†æé—®é¢˜","slug":"notes/NOI å¤ä¹ /noi-2-1","date":"2024-01-04T00:00:00.000Z","updated":"2024-01-05T00:00:00.000Z","comments":true,"path":"Infinity/","link":"","permalink":"https://james1badcreeper.github.io/Infinity/","excerpt":"æœ¬æ–‡æ˜¯ NOI äºŒè½®å¤ä¹ çš„ç¬¬ä¸€ç¯‡ï¼Œæ€»ç»“äº†ä¸€äº›åˆ†æé—®é¢˜çš„åŸºæœ¬å¥—è·¯ã€‚","text":"æœ¬æ–‡æ˜¯ NOI äºŒè½®å¤ä¹ çš„ç¬¬ä¸€ç¯‡ï¼Œæ€»ç»“äº†ä¸€äº›åˆ†æé—®é¢˜çš„åŸºæœ¬å¥—è·¯ã€‚ é—®é¢˜çš„è½¬åŒ– å¸¸è§çš„æƒ…å†µæ˜¯ï¼šåŸé—®é¢˜ä¸å¥½å¤„ç†ï¼Œæˆ‘ä»¬å°†å…¶è½¬åŒ–ä¸ºå…¶å®ƒå½¢å¼çš„é—®é¢˜ã€‚ æ“ä½œè½¬åŒ– å°†æ“ä½œç”¨å½¢è±¡çš„æ–¹å¼æè¿°å‡ºæ¥ã€‚ [ARC110E] Shorten ABC Portal. å¦‚ä½•ç”¨ä¸€ç§æ–¹ä¾¿çš„æ–¹å¼åˆ»ç”»æ“ä½œï¼Ÿè€ƒè™‘å°† a,b,ca,b,ca,b,c å¯¹åº”æˆ 1,2,31,2,31,2,3ï¼Œå‘ç°æ“ä½œç›¸å½“äºç”¨ xâŠ•yx\\oplus yxâŠ•y æ›¿æ¢ x,yx,yx,yã€‚ é‚£ä¹ˆç›´æ¥å€’åº DPï¼Œè½¬ç§»çš„æ—¶å€™æ³¨æ„è½¬ç§»æœ€å°çš„å‰ç¼€å°±å¯ä»¥äº†ï¼Œå› ä¸ºè¿™æ ·çš„æ–¹æ¡ˆæ˜¯è½¬ç§»å…¶å®ƒå‰ç¼€çš„è¶…é›†ï¼Œæ³¨æ„å¦‚æœåˆå§‹æ—¶ä¸èƒ½å¯åŠ¨é‚£ä¹ˆç­”æ¡ˆæ˜¯ 111ã€‚ä»£ç ã€‚ å®ä¾‹ æˆ‘ä»¬çœ‹ä¸€äº›ä¾‹å­ï¼Œæ¥è¯´æ˜å¦‚ä½•ç”¨â€œå¥—è·¯â€å»è§£å†³é—®é¢˜ã€‚ æ•°æ®ç»“æ„ æ•°æ®ç»“æ„é¢˜ã€‚ [P9152] å¾…é»‘ç™½åˆ†æ˜ Portal. åœ¨é›†åˆä¸­ä¸¤ä¸ªç›¸é‚»çš„åŸå¸‚ i,ji,ji,jï¼ˆå‡å®š i&lt;ji&lt;ji&lt;jï¼‰åº”è¯¥æ»¡è¶³ minâ¡{ai,aj}&gt;maxâ¡k=i+1jâˆ’1ak\\min\\{a_i,a_j\\}&gt;\\max_{k=i+1}^{j-1}a_kmin{aiâ€‹,ajâ€‹}&gt;maxk=i+1jâˆ’1â€‹akâ€‹ã€‚ å¼å­ä¸­åé¢è¿™ä¸ªä¸œè¥¿æŠ½æçš„æ ·å­ä¸éš¾æƒ³åˆ°å°†å…¶æ‰”åˆ°å¤§æ ¹ç¬›å¡å°”æ ‘ä¸Šã€‚ è€ƒè™‘ i,ji,ji,j åœ¨æ ‘ä¸Šçš„ä½ç½®ï¼Œå®ƒä»¬ä¸€å®šå­˜åœ¨ç¥–å…ˆå…³ç³»ï¼Œå¦åˆ™å®ƒä»¬çš„ LCA å°±æŠŠé™åˆ¶å¹²çƒ‚äº†ã€‚å¦‚æœè¯´ jjj æ˜¯ iii çš„ç¥–å…ˆï¼Œé‚£ä¹ˆ iii åº”è¯¥åœ¨ jjj å·¦å„¿å­çš„å³å„¿å­é“¾ä¸Šï¼Œå¦åˆ™è¿™æ¡é“¾ä¸Šçš„ç‚¹ä¼šæŠŠé™åˆ¶å¹²çƒ‚ã€‚å½“ç„¶è¿™é‡Œé’¦å®šäº† i&lt;ji&lt;ji&lt;jï¼Œå¦åˆ™åœ¨å³å„¿å­çš„å·¦å„¿å­é“¾ä¸Šä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ è€ƒè™‘åˆ° SSS çš„é€‰å–æ¡ä»¶æ˜¯æŒ‰ç…§é«˜åº¦æ’åºï¼Œè¿™é‡Œé’¦å®šä»å¤§åˆ°å°æ’åºï¼Œç›¸é‚»çš„èŠ‚ç‚¹å¿…ç„¶æ»¡è¶³ aaa æ˜¯ bbb çš„ç¥–å…ˆï¼Œä¸” bbb åœ¨ aaa çš„å·¦å„¿å­çš„å³å„¿å­é“¾æˆ–è€…å³å„¿å­çš„å·¦å„¿å­é“¾ä¸Šã€‚ å¦‚ä½•å¤„ç†å•æ¬¡è¯¢é—®ï¼Ÿè€ƒè™‘æ ‘å½¢ DPï¼Œä»¤ fxf_xfxâ€‹ ä»£è¡¨ä»¥ xxx å¼€å¤´çš„åˆæ³•å­é›†æ•°é‡ï¼Œgx,0/1g_{x,0/1}gx,0/1â€‹ ä»£è¡¨ xxx å·¦å„¿å­é“¾/å³å„¿å­é“¾çš„ fff å€¼çš„å’Œï¼Œç›´æ¥è®¡ç®— fx=gx,0+gx,1+1,gx,0=glsx,0+fxf_x=g_{x,0}+g_{x,1}+1,g_{x,0}=g_{ls_x,0}+f_xfxâ€‹=gx,0â€‹+gx,1â€‹+1,gx,0â€‹=glsxâ€‹,0â€‹+fxâ€‹ å³å¯ï¼Œåˆå§‹æ—¶åªç»™åœ¨è¯¢é—®åŒºé—´å†…çš„ fff åˆå§‹åŒ–ï¼Œç„¶åæ ‘å½¢ DP ä¸€æ¬¡å³å¯ã€‚ æ‰«æçº¿ç»´æŠ¤å€¼åŸŸç»´ï¼Œä»å¤§åˆ°å°ä¾æ¬¡åŠ å…¥æ–°çš„æ•°å¹¶é‡æ–°è®¡ç®— fff çš„å€¼ï¼Œç„¶åè¾ƒå¤§æ•°ä¸ä¼šå½±å“å°æ•°çš„ç­”æ¡ˆï¼Œå› æ­¤ç›´æ¥æ ‘çŠ¶æ•°ç»„ä¸ŠæŸ¥è¯¢å³å¯ã€‚ è‹¥æ•°æ®éšæœºï¼Œé‚£ä¹ˆæ¯ä¸ªæ•°åœ¨ç¬›å¡å°”æ ‘ä¸Šçš„æœŸæœ›æ·±åº¦æ˜¯ O(logâ¡n)O(\\log n)O(logn) çš„ï¼Œå› æ­¤ç›´æ¥æš´åŠ›ç»´æŠ¤å°±æ˜¯å¯¹çš„ã€‚ ä½¿ç”¨æ ‘ä¸Šéšæœºæ’’ç‚¹åˆ†å—ï¼Œé¢„å¤„ç†å‡ºæ¯ä¸ªå…³é”®ç‚¹ +1+1+1 åå¯¹æ¯ä¸ªç‚¹ f/g0/g1f/g_0/g_1f/g0â€‹/g1â€‹ å¯¹äºæ¯ä¸ªç‚¹ fff é€ æˆçš„å½±å“å¹¶ç»Ÿè®¡å½±å“çš„æ ‘ä¸Šå‰ç¼€å’Œï¼Œç„¶åæ¯æ¬¡ä¿®æ”¹å…ˆæš´åŠ›æ”¹åˆ°å…³é”®ç‚¹ï¼Œè¿™ä¸€éƒ¨åˆ†æ˜¯ O(n)O(\\sqrt{n})O(nâ€‹) çš„ï¼Œç„¶åè·³ O(n)O(\\sqrt{n})O(nâ€‹) æ¬¡ï¼Œæ‰“ä¸€ä¸ªæ ‡è®°ï¼Œå¹¶åŒæ—¶ç»Ÿè®¡ fff çš„å‰ç¼€å’Œã€‚æŸ¥è¯¢çš„æ—¶å€™æšä¸¾æ‰€æœ‰å…³é”®ç‚¹ï¼Œå°†æ‰€æœ‰ fff åŠ èµ·æ¥å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦ O(nn+qn)O(n\\sqrt{n}+q\\sqrt{n})O(nnâ€‹+qnâ€‹)ï¼Œç©ºé—´å¤æ‚åº¦ O(nn)O(n\\sqrt{n})O(nnâ€‹) ã€‚é€å—å¤„ç†å¯ä»¥åšåˆ° O(n)O(n)O(n) çš„ç©ºé—´ï¼Œè¿™æ˜¯æœ€å¸¸è§„çš„æ€è·¯ã€‚ ä¹Ÿæœ‰å…¶å®ƒåšæ³•ï¼Œè¿™é‡Œå†™ä¸€ç§ã€‚ é¦–å…ˆæˆ‘ä»¬è¦æ±‚å‡ºåºåˆ—ä¸­æ¯ä¸ªå€¼çš„å·¦è¾¹å’Œå³è¾¹åˆ†åˆ«ç¬¬ä¸€ä¸ªå¤§äºå®ƒçš„å€¼ li,ril_i,r_iliâ€‹,riâ€‹ã€‚ æŒ‰ç…§é«˜åº¦çš„å€¼åŸŸè¿›è¡Œåˆ†å—ã€‚æå‰é¢„å¤„ç†å‡ºä»æŸä¸ªç‚¹å‡ºå‘ï¼Œåˆ°è¾¾å’Œå½“å‰ç‚¹åŒå—çš„æ‰€æœ‰æ–¹æ¡ˆæ•° sumisum_isumiâ€‹ï¼Œä»¥åŠæŸä¸ªç‚¹åˆ°è¾¾å®ƒå·¦è¾¹å’Œå³è¾¹ä¸¤ä¸ªæ–¹å‘ç¬¬ä¸€ä¸ªå’Œå½“å‰å€¼ä¸å±äºä¸€ä¸ªå€¼åŸŸå—çš„æ–¹æ¡ˆæ•° sumli,sumrisuml_i ,sumr_isumliâ€‹,sumriâ€‹ï¼Œä»¥åŠå®ƒä»¬æ‰€å¯¹åº”çš„ä½ç½® lidi,ridilid_i,rid_ilidiâ€‹,ridiâ€‹ã€‚å¯ä»¥ O(n)O(n)O(n) å®Œæˆã€‚ ä¿®æ”¹æ—¶å°†é¢„å¤„ç†å¥½çš„å€¼æ‰”åˆ°ä¸‹ä¸€ä¸ªå—é‡Œï¼Œæ›´æ–° gig_igiâ€‹ ä»£è¡¨ç¬¬ iii ä¸ªå€¼åŸŸå—æ‰€å½±å“çš„å€¼åŸŸå‰ç¼€ï¼ˆ1âˆ¼Ri1\\sim R_i1âˆ¼Riâ€‹ï¼‰çš„ç­”æ¡ˆã€‚å…¶åªä¼šè·³æœ€å¤šä¸è¶…è¿‡ä¸¤å€å—æ•°æ¬¡ã€‚åŒæ—¶å¯ä»¥å¤„ç†å‡ºæ¯” iii å°çš„å€¼è·³åˆ° iii çš„æ–¹æ¡ˆæ•° fif_ifiâ€‹ã€‚ æ¯æ¬¡æŸ¥è¯¢ï¼Œå› ä¸ºå°çš„å€¼æ¯åŠ å…¥ï¼Œæ‰€ä»¥ç›´æ¥ä»å°åˆ°å¤§åŠ ä¸ŠåŒºé—´åŒ…å«çš„æ‰€æœ‰æ•´å—çš„æ–¹æ¡ˆ gidg_{id}gidâ€‹ã€‚ç„¶åå°±æ˜¯å”¯ä¸€çš„é‚£ä¸ªæ•£å—ï¼Œç›´æ¥æš´åŠ› DP å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ O((n+q)n)O((n+q)\\sqrt{n})O((n+q)nâ€‹)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)O(n)O(n)ã€‚ä»£ç ã€‚ ç»¼åˆåº”ç”¨ æŒ‘æˆ˜è‡ªæˆ‘å§ï¼","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"2024/01/22(#11)ï¼šä¸‹æ–¹","slug":"default/è®°å½•/2024/1/2024-01-07","date":"2024-01-04T00:00:00.000Z","updated":"2024-01-20T00:00:00.000Z","comments":true,"path":"1cf7feb5/","link":"","permalink":"https://james1badcreeper.github.io/1cf7feb5/","excerpt":"æ˜¯çš„ã€‚","text":"æ˜¯çš„ã€‚ æ‹–æ›´äº† INF å¹´ï¼Œæ‘†å®Œäº†ã€‚ ã“ã®ã¾ã¾ å¥ªã£ã¦ éš ã—ã¦ å¿˜ã‚ŒãŸã„ å°±è¿™æ ·è¢«å‰¥å¤º éšè—èµ·æ¥ æƒ³å¿˜å´ä¸€åˆ‡ ****ï¼Œä¸€ç¯‡éƒ½å‡‘ä¸é½äº†å—ã€‚ [CF1558F] Strange Sort Portal. å°†æ•°å­—æ’åºè½¬åŒ–ä¸º 01 æ’åºï¼Œç­”æ¡ˆæ˜¯æœ€å³ä¾§çš„ 000 çš„å°±ä½æ—¶é—´ã€‚ è®¾ç¬¬ iii ä¸ª 000 çš„å°±ä½æ—¶é—´æ˜¯ fif_ifiâ€‹ï¼Œå¦‚æœå…¶å‘å·¦äº¤æ¢çš„è¿‡ç¨‹ä¸­ç¢°åˆ°äº† 000ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ fiâˆ’1+1f_{i-1}+1fiâˆ’1â€‹+1ï¼Œå¦åˆ™å°±æ˜¯å‰é¢ 111 çš„ä¸ªæ•° piâˆ’ip_i-ipiâ€‹âˆ’i åŠ ä¸Šä¸€ä¸ª pi mod 2p_i\\bmod 2piâ€‹mod2ï¼ˆpip_ipiâ€‹ ä»£è¡¨å…¶ä½ç½®ï¼‰ã€‚ è€ƒè™‘å½“å‰æœ‰ iii ä¸ª 000ï¼Œä»ç¬¬ preprepre ä¸ª 000 å¼€å§‹æ²¡æœ‰å½’ä½ï¼Œå…¶ä»£ä»·æš´åŠ›æ‹†å¼€åæ˜¯ mâˆ’im-imâˆ’iï¼Œé•¿æˆè¿™æ ·ï¼š fm=maxâ¡i=prem{piâˆ’i+(pi mod 2)+(mâˆ’i)}f_m = \\max_{i=pre}^m \\{p_i-i+(p_i \\bmod 2) + (m - i)\\} fmâ€‹=i=premaxmâ€‹{piâ€‹âˆ’i+(piâ€‹mod2)+(mâˆ’i)} æšä¸¾ mmmï¼Œçº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ [CF55D] Beautiful numbers Portal. æˆ‘ä»¬ç»´æŠ¤å½“å‰å‡ºç°æ‰€æœ‰æ•°çš„ lcmâ¡\\operatorname{lcm}lcm å³å¯å¾ˆæ–¹ä¾¿åœ°åˆ¤æ–­ï¼Œç›´æ¥æ•°ä½ DP å³å¯ã€‚ä»£ç ã€‚ [CEOI2011] Matching Portal. ç›¸å½“äºæ±‚å‡º aaa çš„ç½®æ¢å†è¿›è¡Œå­—ç¬¦ä¸²åŒ¹é…ã€‚å¯ä»¥åŠ¨æ€å¯¹ bbb è¿›è¡Œæ‰«æï¼Œä½¿ç”¨æƒå€¼æ ‘çŠ¶æ•°ç»„å°† KMP çš„ç›¸ç­‰åˆ¤å®šæ”¹æ‰ï¼Œè®°å½•å…¶å€¼åŸŸçš„å‰é©±åç»§çš„ä½ç½®ï¼Œç„¶ååŒ¹é…çš„æ—¶å€™è¦æ»¡è¶³å®ƒä»¬ä¹‹é—´çš„ä½ç½®å…³ç³»ã€‚ä»£ç ã€‚ [QOJ4829] Mark on a Graph Portal. ç”±äºå®ƒç»™çš„æ˜¯éšæœºå›¾ï¼Œå› æ­¤æˆ‘ä»¬è¦ç»™ä»–æä¸€äº›ç‰¹æ®Šæ ‡è¯†ä½¿å¾—è¿™å¼ å›¾å¯ä»¥è¢«æˆ‘ä»¬è¯†åˆ«ã€‚æ‰¾åˆ°åº¦æ•°æœ€å¤§çš„äº”ä¸ªç‚¹ï¼Œç„¶åç»™å®ƒä¸Šä¸€ä¸ªç¯å³å¯ã€‚ä»£ç ã€‚ æ‰€ä»¥è¿™ç©æ„å„¿èƒ½è¿‡æ˜¯ä»€ä¹ˆé¬¼å•Šï¼Ÿï¼Ÿ #import&lt;time.h> main()&#123;int t=time(0);puts(t&amp;1?\"mark 0\":\"ok\");while(t==time(0));&#125; [Ynoi E2024] TEST_132 Portal. ç›´æ¥æ ¹å·åˆ†æ²»åšå®Œäº†ï¼Œå¡å¸¸é¢˜ã€‚ä»£ç ã€‚ å¥½åƒï¼Œè¿™ç§ä¸œè¥¿ä¸æ›´æ–°ï¼Œå°±æ²¡æœ‰æ•ˆç‡ã€‚ ä»Šå¤©å°±è¿™æ ·å§ï¼Œæ˜å¤©å†åŠ æ›´ï¼ï¼","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023 å¹´åº¦æ€»ç»“ï¼šæ–°ä¸–ç•Œ","slug":"summaries/hello2024","date":"2024-01-01T00:00:00.000Z","updated":"2024-01-01T00:00:00.000Z","comments":true,"path":"1424643c/","link":"","permalink":"https://james1badcreeper.github.io/1424643c/","excerpt":"Goodbyeï¼Œ2023ï¼ŒForeverã€‚","text":"Goodbyeï¼Œ2023ï¼ŒForeverã€‚ å…ƒæ—¦è¿™å¤©å‘ç°è‡ªå·±ç«Ÿç„¶æ²¡å†™å¹´åº¦æ€»ç»“ï¼Œäºæ˜¯èµ¶ç´§æ¥å‡‘æ•°ã€‚ åºæ›² ç«¥çœŸã€æ®‹å¿ã€ç†æ€§ã€æ§åˆ¶ã€æµªæ¼«ã€æ‚²è§‚ã€ç™«ç‹‚â€¦â€¦åœ¨å¤šé‡äººæ ¼çš„çº ç¼ ä¸­ï¼Œå†²ç ´æ·é”ï¼Œè¿½å¯»æè‡´çš„è‡ªæˆ‘ã€‚ è™½ç„¶ç¼ºé™·å¾ˆå¤šï¼Œä½†è¿™æ˜¯æˆ‘é€ å°±çš„æœ€ä¸å¹³å‡¡çš„ä¸€å¹´ã€‚ å¦‚æœé€‰æ‹©äº†ä¸å‡¡ï¼Œé‚£ä¹ˆè·¯ä¸Šå¿…å®šæ»¡æ˜¯è†æ£˜ã€‚å€¼å¾—åº†å¹¸çš„æ˜¯ï¼Œæˆ‘èµ°è¿‡æ¥äº†ã€‚æ¥ä¸‹æ¥çš„è·¯ä¹Ÿè®¸æ›´ä¸ºåå·ï¼Œä½†åªè¦æˆ‘è¿˜æ˜¯é‚£ä¸ªç–¯å­ï¼Œæˆ‘å¿…ç„¶èƒ½èµ°åˆ°æˆ‘æ‰€èƒ½å¤Ÿèµ°åˆ°çš„å°½å¤´ã€‚ éœ€è¦å­¦ä¹ çš„çœŸçš„å¾ˆå¤šï¼Œåœ¨è¿™ä¸€å¹´é‡Œï¼Œè®¤è¯†äº†ä¸€äº›æ–°çš„äººï¼Œä¹Ÿé‡æ–°è®¤è¯†äº†è®¸å¤šäººã€‚èƒ½é‡åˆ°ä»–ä»¬ï¼Œæˆ‘è¡¨ç¤ºè¡·å¿ƒçš„æ„Ÿè°¢ã€‚ åˆºå®¢ å¼±å°å’Œæ— çŸ¥ä¸æ˜¯ç”Ÿå­˜çš„éšœç¢ï¼Œå‚²æ…¢æ‰æ˜¯ã€‚â€”â€”åˆ˜æ…ˆæ¬£ã€Šä¸‰ä½“ã€‹ è´¥äº†ï¼Œéœ€è¦æ‰¿è®¤çš„ã€‚ åŸå› å·²ç»åæ€è¿‡äº†ï¼Œä¹Ÿå·²ç»åˆ»åœ¨éª¨å¤´é‡Œï¼Œè¿™é‡Œæ²¡ä»€ä¹ˆéœ€è¦é‡å¤çš„ã€‚ ä¹Ÿè®¸å½“æ—¶çš„å¤±è´¥å¯¹æˆ‘æ˜¯ä¸€ä»¶å¥½äº‹ï¼Œå¦åˆ™æˆ‘å¯èƒ½åˆ°ç°åœ¨éƒ½æ— æ³•ç†è§£ä¸€äº›äº‹æƒ…ï¼šåœ¨é‚£ä¹‹åçš„æ–‡åŒ–è¯¾å­¦ä¹ è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½å¯¹æˆ‘è®¤çŸ¥çš„å½±å“è¿œæ¯”ä¸€ä¸ªå­¦æœŸçš„åœè¯¾å¤§ã€‚ è¿™ä¼¼ä¹æ˜¯æˆ‘ç¬¬ä¸€æ¬¡æ¥åˆ°æˆ‘çš„æ–°ç­çº§ï¼Œä¹Ÿè®¸æ˜¯æˆ‘ç¬¬ä¸€æ¬¡æ¥åˆ°æˆ‘ä»¬å­¦æ ¡çš„äºŒæ¥¼çš„å¦ä¸€ä¾§ã€‚æˆ‘åªå»è¿‡å®éªŒæ¥¼å…¥å£çš„é‚£ä¸€ä¾§ï¼Œè¿™æ¬¡æˆ‘æ¥åˆ°çš„æ˜¯å¼ºåŸºç­çš„æ•™å®¤è¿™ä¸€ä¾§ã€‚ æˆ‘è®¤è¯†äº†è®¸å¤šä»¥å‰â€œæ— æ³•ç†è§£â€çš„å†…å®¹ï¼Œè®°å¾—æˆ‘ä»¬è¯­æ–‡è€å¸ˆæ›¾åœ¨æ™šè¯¾æ—¶çš„æ¿€æƒ…æ¼”è®²ã€‚è¿˜æœ‰æˆ‘çš„åŒæ¡Œï¼ˆç­çº§ï¼ˆè¿˜æ˜¯å¹´çº§ï¼Œå¿˜äº†ï¼‰è¯­æ–‡æœ€é«˜åˆ†ï¼‰å› ä¸å†™è¯­æ–‡ä½œä¸šè¢«ç½šæŠ„ã€Šä¿ƒç»‡ã€‹ï¼Œç„¶åæŠŠé‚£å¹…äº•çš„æ’ç”»ä¹Ÿç»™ç”»ä¸‹æ¥çš„æ•…äº‹ã€‚è¿˜æœ‰ç‰©ç†è¯¾ä¸Šç”ŸåŠ¨å½¢è±¡çš„èˆè¹ˆï¼Œæ•°å­¦ç‹çš„è°†è°†æ•™è¯²â€¦â€¦ ä¸€å¼€å§‹æˆ‘ç”šè‡³æ˜¯æƒ³æ··è¿‡è¿™ä¸ªå­¦æœŸçš„ï¼Œä½†æ˜¯æ²¡æƒ³åˆ°æˆ‘ç«Ÿç„¶å­¦åˆ°äº†è¿™ä¹ˆå¤šã€‚ é‚£æ®µæ—¶é—´å°±åƒä¸€ä¸ªåˆ€æ³•ç²¾å‡†çš„åˆºå®¢ï¼Œåˆºæ­»äº†è®¸å¤šä¸œè¥¿ã€‚ æ—§åœ° æˆ‘å’Œé«˜ä¸€çš„åŒå­¦ä»¬ä¸€èµ·å›åˆ°äº†é‚£ä¸ªä»¤äººéš¾ä»¥å¿˜æ€€çš„åœ°æ–¹ï¼Œå……æ»¡äº†åŸç¥ã€å´©é“å’ŒèŸ‘è‚çš„åœ°æ–¹ã€‚é‚£é‡Œæœ‰å¾ˆå¥½åƒçš„å¹²è±†è…ã€‚ è¿™æ®µæ—¶é—´æœ‰å¾ˆå¤šéš¾å¿˜çš„äº‹æƒ…ï¼Œæ¯”å¦‚æˆ‘é¡¶ç€ 38 åº¦çš„é«˜æ¸©ç¡åˆ°äº†å¤©äº®ï¼Œå’ŒæŸåŒå­¦é¡¶ç€æš´é›¨ä»æœºæˆ¿èµ¶å›äº†å®¿èˆï¼Œå‡Œæ™¨çš„æ¼”å”±ä¼šâ€¦â€¦ æˆ‘æ˜¯æ˜Ÿï¼Œåˆ©å‰‘å¼€åˆƒå¯’å…‰é”‹èŠ’çš„é“¶æ˜Ÿï¼Œç»ä¸æ¶ˆéšâ€”â€”ã€Šå¤œèˆªæ˜Ÿã€‹ ç»ˆç«  CSP2023ï¼ŒNOIP 2023ï¼Œæˆç»©éƒ½ä¸æ˜¯å¾ˆç†æƒ³ï¼Œä½†ä¹Ÿè®¸è¿™å°±æ˜¯æˆ‘çš„çœŸå®æ°´å¹³ã€‚ éœ€è¦ç»§ç»­åŠªåŠ›å•Šï¼Œå‰é¢çš„æŒ‘æˆ˜è¿˜å¾ˆå¤šå‘¢ã€‚ 2023 å¹´çš„æœ€åä¸€å¤©ï¼Œ24 OI å›¢å»ºã€‚ è¿™ä¸€å¤©æ˜¾å¾—å¦‚æ­¤åŒ†å¿™ï¼Œç«Ÿæ²¡æœ‰ä»€ä¹ˆæ—¶é—´ç”¨æ¥æ„Ÿæ…¨å³å°†é€å»çš„ 2023ã€‚å¾ˆå¤§åŸå› æ˜¯å› ä¸º 74TrAkToRï¼Œè¿™ä¸ªä¸è´Ÿè´£ä»»çš„ç»„ç»‡è€…å‡ºçš„åƒåœ¾åœº Goodbye 2023ï¼Œå¸Œæœ›ä»–èƒ½å¥½å¥½åæ€åæ€ï¼Œå¸Œæœ›ä»–èƒ½ç»™å¤§å®¶å¸¦æ¥æ›´å¥½çš„ä¸œè¥¿ï¼Œè€Œä¸æ˜¯â€œå¯¹ä¸èµ·ï¼Œæˆ‘é”™äº†ï¼Œä½†æ˜¯æˆ‘åšå†³ä¸æ”¹â€ï¼Œåƒæ›¾ç»çš„æˆ‘é‚£æ ·ã€‚ ä»è¯´ä¹¦äººçš„è§†è§’æ¥çœ‹ï¼Œå¤§å®¶ä¼¼ä¹éƒ½å¾ˆå¼€å¿ƒï¼Œè¿™å°±è¶³å¤Ÿäº†ã€‚ å‚è€ƒèµ„æ–™ æˆ‘è‡ªå·±å†™çš„é—²è¯ã€‚ å„ä¸ªå¹³å°çš„å¹´åº¦æ€»ç»“ã€‚ æœ€åï¼Œå†æ¬¡æ„Ÿè°¢å±å¹•å‰çš„ä½ ä»¬ã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"éšç¬”","slug":"éšç¬”","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"NOI ä¸€è½®å¤ä¹  IXï¼šæ•°æ®ç»“æ„ B","slug":"notes/NOI å¤ä¹ /noi-1-9","date":"2023-12-30T00:00:00.000Z","updated":"2023-12-11T00:00:00.000Z","comments":true,"path":"ba44503d/","link":"","permalink":"https://james1badcreeper.github.io/ba44503d/","excerpt":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç»ˆç« ï¼ŒåŒ…æ‹¬å„ç±»æ ¹å·æ•°æ®ç»“æ„ï¼ˆä»¥åŠå…¶å®ƒæ•°æ®ç»“æ„æ‚é¡¹ï¼‰ã€‚","text":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç»ˆç« ï¼ŒåŒ…æ‹¬å„ç±»æ ¹å·æ•°æ®ç»“æ„ï¼ˆä»¥åŠå…¶å®ƒæ•°æ®ç»“æ„æ‚é¡¹ï¼‰ã€‚ åœ¨ä»‹ç»ä¸€åˆ‡å†…å®¹ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆä»‹ç»ä¸€ç§æ€æƒ³ï¼šå¹³è¡¡æ€æƒ³ã€‚ æˆ‘ä»¬å¯¹äº â‰¥B\\ge Bâ‰¥B å’Œ &lt;B&lt;B&lt;B çš„é—®é¢˜å¦‚æœéƒ½æœ‰é«˜æ•ˆåšæ³•ï¼Œé‚£ä¹ˆå¯ä»¥è€ƒè™‘å°†å®ƒä»¬æ‹¼èµ·æ¥ï¼Œå¯¹äºä¸åŒçš„éƒ¨åˆ†ä½¿ç”¨ä¸åŒçš„åšæ³•ï¼Œä»è€Œå¾—åˆ°ä¸€ä¸ªæ±‚è§£æ•´ä¸ªé—®é¢˜çš„é«˜æ•ˆåšæ³•ã€‚ åºåˆ—åˆ†å— åˆ†å—æ˜¯ä¸€ç§æ ‘å½¢ç»“æ„ï¼Œå¯ä»¥è§†ä½œä¸€æ£µåªæœ‰ä¸‰å±‚çš„æ ‘ã€‚ åˆ†ç±» åŠ¨æ€åˆ†å—å¯ä»¥æ”¯æŒä¿®æ”¹ï¼Œæœ¬è´¨ä¸Šæ˜¯é€šè¿‡åˆ†å—è¾¾åˆ°â€œå¤§å—ç»´æŠ¤ï¼Œå°å—æš´åŠ›â€çš„æ–¹å¼æ¥åŠ é€Ÿæ•°æ®ç»“æ„ã€‚ é™æ€åˆ†å—ä¸æ”¯æŒä¿®æ”¹ï¼Œé€šè¿‡é¢„å¤„ç†ä¸€äº›ä¿¡æ¯æ¥åŠ é€ŸæŸ¥è¯¢ã€‚æœ¬èº«åŠŸèƒ½æ˜¯è«é˜Ÿçš„å­é›†ï¼Œä½†æ˜¯å…¶å¯ä»¥åœ¨çº¿ã€‚ ä¾‹é¢˜ ä¸€äº›é¢˜ï¼Œæœ‰äº›æ¯”è¾ƒå¤æ‚ã€‚ [Ynoi2019 æ¨¡æ‹Ÿèµ›] Yuno loves sqrt technology III Portal. æˆ‘ä»¬è®°å½• f(i,j)f(i,j)f(i,j) ä»£è¡¨ç¬¬ [i,j][i,j][i,j] å—çš„åŒºé—´ä¼—æ•°å‡ºç°æ¬¡æ•°ã€‚æˆ‘ä»¬å¯¹æ¯ä¸€ä¸ªæ•°éƒ½å¼€ä¸€ä¸ª STL vectorï¼Œè®°å½•å…¶å‡ºç°çš„ä½ç½®ï¼Œå¹¶è®° ax[i]ax[i]ax[i] ä¸ºç¬¬ iii ä¸ªæ•°å‡ºç°åœ¨å…¶ vector ä¸­çš„ä½ç½®ã€‚ æ•´å—çš„ç­”æ¡ˆæ˜¯å¯ä»¥ç›´æ¥ç»Ÿè®¡çš„ï¼Œè€Œå¯¹äºé›¶æ•£å—ï¼Œåˆ™è·å–å½“å‰çš„æ•°åœ¨ vector ä¸­çš„ä½ç½®ï¼Œè€ƒè™‘ ansansans æ˜¯å¦å¯ä»¥å˜å¤§ï¼Œè¿›è¡Œæš´åŠ›æ›´æ–°å³å¯ã€‚ç”±äº ansansans æœ€å¤šå˜å¤§ 2n2\\sqrt{n}2nâ€‹ï¼Œå› æ­¤è¯¢é—®çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)O(\\sqrt{n})O(nâ€‹)ã€‚ æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(nn)O(n\\sqrt{n})O(nnâ€‹)ã€‚ä»£ç ã€‚ [Ynoi2019 æ¨¡æ‹Ÿèµ›] Yuno loves sqrt technology I Portal. å¼ºåˆ¶åœ¨çº¿çš„åŒºé—´é€†åºå¯¹ï¼ æ•´å—å†…éƒ¨ï¼šé¢„å¤„ç†ï¼› æ•£å—å†…éƒ¨ï¼šç”¨æ ‘çŠ¶æ•°ç»„é¢„å¤„ç†å‰åç¼€ï¼› æ•£å—å¯¹æ•£å—ï¼šå¤„ç†å¥½æ¯ä¸ªæ•°çš„æ’åï¼Œç›´æ¥å½’å¹¶ï¼› æ•£å—å¯¹æ•´å—ï¼šé¢„å¤„ç†å‡º gi,jg_{i,j}gi,jâ€‹ ä»£è¡¨ 1âˆ¼j1\\sim j1âˆ¼j å¯¹ iii å—çš„è´¡çŒ®ã€‚ ä»£ç ã€‚ [CF453E] Little Pony and Lord Tirek Portal. é¢„å¤„ç† fi,kf_{i,k}fi,kâ€‹ è¡¨ç¤ºç¬¬ iii å—ä»å…¨ 000 å¼€å§‹ï¼Œkkk ä¸ªå•ä½æ—¶é—´åçš„å’Œã€‚ç”±äºåŒºé—´æ¨å¹³æ“ä½œçš„å­˜åœ¨ï¼Œé¢œè‰²æ®µå‡æ‘Šåå¤æ‚åº¦æ˜¯æ­£ç¡®çš„ã€‚ä»£ç ã€‚ å¸¦æ’å…¥åŒºé—´ k å° Portal. è®¾ si,js_{i,j}si,jâ€‹ ä»£è¡¨å‰ iii ä¸ªå—è½åœ¨ç¬¬ jjj ä¸ªå€¼åŸŸå—çš„æ•°çš„ä¸ªæ•°ï¼Œvi,jv_{i,j}vi,jâ€‹ ä»£è¡¨ iii å—å†…å€¼ä¸º jjj çš„ä¸ªæ•°ã€‚ç„¶åæ‰€æœ‰ä¿¡æ¯éƒ½èƒ½å¤Ÿç»Ÿè®¡ï¼Œå—å¤§çš„æ—¶å€™ç›´æ¥åˆ†è£‚å³å¯ã€‚ä»£ç ã€‚ è«é˜Ÿ è«é˜Ÿï¼Œå³é«˜ç»´æ‰«æçº¿ï¼Œç”¨ä¸€ç§åˆç†çš„æ’åºæ–¹å¼ä½¿å¾—å¤æ‚åº¦å¯ä»¥æ¥å—ã€‚ æ™®é€šè«é˜Ÿ å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿä»å¾—çŸ¥å¯¹äºå½“å‰åŒºé—´ï¼Œå¢åŠ ä¸€ä¸ªæ•°å’Œå‡å°‘ä¸€ä¸ªæ•°å¯¹ç­”æ¡ˆçš„å¢é‡ï¼Œä¾¿å¯ä»¥ç›´æ¥è«é˜Ÿã€‚ è«é˜Ÿå¯ä»¥å¡å¸¸æ•°ã€‚å—çš„ç¼–å·å¯ä»¥æŒ‰ç…§å¥‡å¶è¿›è¡Œæ’åºã€‚ è«é˜Ÿå¯ä»¥æ”¯æŒä¿®æ”¹ï¼Œæœ¬è´¨ä¸Šå°±å˜æˆäº†ä¸‰ç»´æ‰«æçº¿ã€‚ å¤æ‚åº¦åˆ†æ å¯¹äºäºŒç»´æ‰«æçº¿ï¼Œè®¾å—é•¿ä¸º BBBï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ä¸º O(n2B+mB)O\\left(\\cfrac{n^2}{B}+mB\\right)O(Bn2â€‹+mB)ï¼Œå‰è€…æ˜¯æœ‰ n/Bn/Bn/B ä¸ªå—ï¼Œå—çš„ç§»åŠ¨éœ€è¦ nnn æ¬¡ï¼Œåè€…æ˜¯æ¯ä¸ªè¯¢é—®éœ€è¦ BBB æ¬¡ç§»åŠ¨ã€‚å‘ç° BBB å– nm\\cfrac{n}{\\sqrt{m}}mâ€‹nâ€‹ å¯ä»¥åšåˆ° O(nm)O(n\\sqrt{m})O(nmâ€‹) çš„æœ€ä¼˜å¤æ‚åº¦ã€‚ å¯¹äºä¸‰ç»´æ‰«æçº¿ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n2tB2+mB)O\\left(\\cfrac{n^2 t}{B^2}+mB\\right)O(B2n2tâ€‹+mB)ï¼Œå› æ­¤å¯ä»¥å– B=n23t13m13B=\\cfrac{n^{\\frac 2 3}t^{\\frac 1 3}}{m^{\\frac 1 3}}B=m31â€‹n32â€‹t31â€‹â€‹ã€‚ æ ‘ä¸Šè«é˜Ÿ å¯¹äºæŸ¥è¯¢é“¾ä¸Šçš„ä¿¡æ¯ï¼Œæœ‰ä¸¤ç§å®ç°æ–¹å¼ï¼Œä¸€ç§æ˜¯åˆ©ç”¨æ‹¬å·åºå°†å…¶æ‹åˆ°é“¾ä¸Šå†åšå¤„ç†ï¼Œå¦ä¸€ç§æ˜¯æ­£ç»çš„æ ‘åˆ†å—åšæ³•ã€‚ä¸€èˆ¬æƒ…å†µä¸‹é‡‡ç”¨å‰è€…è¶³çŸ£ã€‚ å¯¹äºæŸ¥è¯¢å­æ ‘ä¿¡æ¯ï¼Œæ­¤æ—¶ä¸å¦‚ç›´æ¥æ ‘ä¸Šå¯å‘å¼åˆå¹¶ã€‚ å›æ»šè«é˜Ÿ è«é˜ŸäºŒæ¬¡ç¦»çº¿ æ­£å¸¸è«é˜Ÿçš„è¯ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦ O(\\nmlogâ¡n+m)O(\\n\\sqrt{m}\\log n+m)O(\\nmâ€‹logn+m) æ¥å®ŒæˆåŒºé—´é€†åºå¯¹ï¼ˆä½¿ç”¨æ ‘çŠ¶æ•°ç»„ï¼‰ã€‚ å°†è«é˜Ÿçš„ç§»åŠ¨æŒ‡é’ˆçš„æ±‚è§£è¿‡ç¨‹è§†ä½œ nmn\\sqrt{m}nmâ€‹ æ¬¡æŸ¥è¯¢åŒºé—´ä¸­æ»¡è¶³ç‰¹å®šç‰¹å¾çš„æ•°çš„æŸä¸ªä¿¡æ¯ï¼Œå¦‚æœè¿™ä¸ªä¿¡æ¯å¯ä»¥å·®åˆ†ï¼Œé‚£ä¹ˆå°±æˆäº†å¯¹äºå‰ç¼€æ±‚è§£æ»¡è¶³ç‰¹å®šç‰¹å¾çš„æ•°çš„æŸä¸ªä¿¡æ¯ã€‚ è€ƒè™‘æ¯æ¬¡è«é˜ŸåŒºé—´æ”¹å˜æ—¶ç­”æ¡ˆçš„æ”¹å˜ã€‚æˆ‘ä»¬å°†æ›´æ–°çš„è¿‡ç¨‹å†æ¬¡ç¦»çº¿ï¼Œæ¥åŠ é€ŸæŸ¥è¯¢ã€‚è®¾ f(x,[l,r])f(x,[l,r])f(x,[l,r]) ä»£è¡¨å¢åŠ  xxx å¯¹äºåŒºé—´ [l,r][l,r][l,r] çš„è´¡çŒ®å½±å“ã€‚é‚£ä¹ˆå·®åˆ†æ‰ï¼Œè¿™æ ·åªéœ€è¦æŒ‚ O(2nm)O(2n\\sqrt{m})O(2nmâ€‹) ä¸ªè¯¢é—®ï¼ç©ºé—´çˆ†ç‚¸äº†ï¼ä¸”ç”±äºç©ºé—´çˆ†ç‚¸å¯¼è‡´æ—¶é—´çˆ†ç‚¸ï¼ è§‚å¯Ÿè´¡çŒ®å·®åˆ†åçš„å½¢å¼ï¼šf(x,[1,xâˆ’1])âˆ’f(x,[1,lâˆ’1])f(x,[1,x-1])-f(x,[1,l-1])f(x,[1,xâˆ’1])âˆ’f(x,[1,lâˆ’1])ã€‚å‘ç°è´¡çŒ®åªæœ‰ä¸¤ç±»ï¼š å‡å·å·¦è¾¹çš„è´¡çŒ®æ°¸è¿œæ˜¯ä¸€ä¸ªå‰ç¼€å’Œå®ƒåé¢ä¸€ä¸ªæ•°çš„è´¡çŒ®ã€‚è¿™å¯ä»¥é¢„å¤„ç†å‡ºæ¥ã€‚ å‡å·å³è¾¹çš„è´¡çŒ®å¯¹äºä¸€æ¬¡ç§»åŠ¨ä¸­æ‰€æœ‰çš„ xxx æ¥è¯´ï¼Œ[1,lâˆ’1][1,l-1][1,lâˆ’1] éƒ½æ˜¯ä¸å˜çš„ã€‚æˆ‘ä»¬æ‰“æ ‡è®°çš„æ—¶å€™ï¼Œå¯ä»¥åªæ ‡è®°ä¸€ä¸ªåŒºé—´ã€‚ æ¨¡æ¿ï¼Œæ‰€æœ‰çš„è´¡çŒ®éƒ½å¾ˆæ–¹ä¾¿è®¡ç®—ï¼Œä»£ç ã€‚ åŒºé—´ä¼—æ•°ã€‚åŒæ ·é‡‡ç”¨äºŒæ¬¡ç¦»çº¿è«é˜Ÿï¼Œè¿™æ¬¡éœ€è¦å¯¹äº L,RL,RL,R çš„ç§»åŠ¨åˆ†åˆ«è®¡ç®—è´¡çŒ®ã€‚ä»£ç ã€‚ ä¾‹é¢˜ ä¸€äº›é¢˜ã€‚ [Ynoi2015] ç›¼å›å‹¿å¿˜ Portal. è€ƒè™‘ç»Ÿè®¡æ¯ä¸ªæ•° xxx å‡ºç° yyy æ¬¡çš„è´¡çŒ®ï¼Œå…¶ä¸º x((2yâˆ’1)Ã—2lenâˆ’y)=x(2lenâˆ’2lenâˆ’y)x((2^{y}-1)\\times 2^{len-y})=x(2^{len}-2^{len-y})x((2yâˆ’1)Ã—2lenâˆ’y)=x(2lenâˆ’2lenâˆ’y)ã€‚å¯¹äºå‡ºç°æ¬¡æ•°ç›¸åŒçš„æ•°ä¸€èµ·ç»Ÿè®¡ï¼Œè¿™æ ·çš„æ•°åªæœ‰ O(n)O(\\sqrt{n})O(nâ€‹) ä¸ªï¼Œé“¾è¡¨ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ å¸¸è§å¥—è·¯æ€»ç»“ æ ¹å·åˆ†æ²»ï¼ˆå¹³è¡¡ï¼‰ è€ƒè™‘è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼š O(1)O(1)O(1) å•ç‚¹ä¿®æ”¹ï¼ŒO(n)O(\\sqrt{n})O(nâ€‹) æŸ¥è¯¢åŒºé—´å’Œã€‚ ç®€å•ï¼åˆ†å—ç»´æŠ¤å—å†…çš„å’Œï¼Œæ¯æ¬¡ä¿®æ”¹çš„æ—¶å€™æ›´æ–°å—å†…å’Œå³å¯ã€‚ O(n)O(\\sqrt{n})O(nâ€‹) å•ç‚¹ä¿®æ”¹ï¼ŒO(1)O(1)O(1) æŸ¥è¯¢åŒºé—´å’Œã€‚ åˆ†å—ç»´æŠ¤å—å†…å—å¤–å‰ç¼€å’Œï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªå—å†…å‰ xxx ä¸ªæ•°çš„å’Œå’Œå‰ xxx å—çš„å’Œï¼Œé‚£ä¹ˆæŸ¥è¯¢å°±æ˜¯ O(1)O(1)O(1) çš„äº†ã€‚ O(1)O(1)O(1) åŒºé—´ä¿®æ”¹ï¼ŒO(n)O(\\sqrt{n})O(nâ€‹) æŸ¥è¯¢å•ç‚¹ã€‚ å°†ç¬¬ä¸€ä¸ªå·®åˆ†æ‰ç›´æ¥åšå³å¯ã€‚ ç»´æŠ¤ä¸€ä¸ªé›†åˆï¼ŒO(n)O(\\sqrt{n})O(nâ€‹) æ’å…¥æ•°ï¼ŒO(1)O(1)O(1) æŸ¥è¯¢ kkk å°ã€‚ è€ƒè™‘å€¼åŸŸåˆ†å—ï¼Œæ¯ä¸ªæ•°ç»´æŠ¤å…¶æ‰€åœ¨çš„å—ï¼Œå¯¹å—ç»´æŠ¤ä¸€ä¸ªæœ‰åºè¡¨ï¼Œæ’å…¥çš„æ—¶å€™ç›´æ¥å½’å¹¶ï¼Œkkk å°å°±å¯ä»¥ç›´æ¥æŸ¥è¯¢ã€‚ [IOI2009] Regions Portal. å¯¹é›†åˆå¤§å°è¿›è¡Œæ ¹å·åˆ†æ²»ï¼Œå¤§é›†åˆé¢„å¤„ç†å‡ºç­”æ¡ˆï¼Œå°é›†åˆå¯ä»¥å¯¹åº”åˆ°æ—¶é—´æˆ³åŒºé—´ï¼Œå…ˆæ’åºåå†åŒæŒ‡é’ˆæ‰«æå³å¯ã€‚ä»£ç ã€‚ [POI2015] ODW Portal. k&gt;Bk&gt;Bk&gt;B çš„éƒ¨åˆ†æš´åŠ›è·³ï¼Œkâ‰¤Bk\\le Bkâ‰¤B é¢„å¤„ç†å³å¯ã€‚ä»£ç ã€‚ [CF840E] In a Trap Portal. å¼å­ä¸­æœ‰ä¸€ä¸ªæ ‘ä¸Šè·ç¦»ä¸å¤ªå¥½å¤„ç†ï¼Œæˆ‘ä»¬è€ƒè™‘æŒ‰ç…§è·ç¦»è¿›è¡Œæ ¹å·åˆ†æ²»ã€‚ å°†æ¯ä¸ªç‚¹å‘ä¸Š 282^828 ä¸ªç‚¹ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰åˆ†ä¸ºä¸€å—ï¼Œè¿™æ ·å‘ä¸Šè·³çš„æ—¶å€™ï¼Œæ¯ä¸€å—çš„å 888 ä½ä¸ä¼šäº§ç”Ÿå½±å“ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬é¢„å¤„ç†å‡º gx,i=maxâ¡j=0255afx,jâŠ•(256i+j)g_{x,i}=\\max_{j=0}^{255} a_{f_{x,j}}\\oplus (256i+j)gx,iâ€‹=maxj=0255â€‹afx,jâ€‹â€‹âŠ•(256i+j) ä»£è¡¨ xxx æ‰€å±çš„å—å†…ï¼Œiii çš„å€¼ç»™å®šæ—¶çš„å—å†…æœ€å¤§ç­”æ¡ˆï¼Œå…¶ä¸­ fff è¡¨ç¤º xxx çš„ jjj çº§çˆ¶äº²ã€‚ å¯ä»¥æ³¨æ„åˆ°åŠ å·å‰åä¸¤éƒ¨åˆ†æ˜¯äº’ä¸å½±å“çš„ï¼Œé‚£ä¹ˆå°† aaa æ‹†æˆå‰ 888 ä½å’Œå 888 ä½ï¼Œå‰åŠéƒ¨åˆ†å°†å—å†…æ‰€æœ‰æ•°å€¼æ’å…¥ 01 Trieï¼Œç„¶åæŸ¥è¯¢å‰åŠéƒ¨åˆ†çš„æœ€å¤§å€¼ ansansansï¼ŒååŠéƒ¨åˆ†ç›´æ¥å¼€ä¸ªæ¡¶ï¼ŒæŸ¥è¯¢ ansâŠ•ians\\oplus iansâŠ•i çš„æœ€å¤§å€¼å³å¯ã€‚ æŸ¥è¯¢çš„æ—¶å€™ç›´æ¥ä» vvv å¼€å§‹å‘ä¸Šè·³ï¼Œæ•´å—ç›´æ¥è·å¾—ç­”æ¡ˆï¼Œæ•£å—æš´åŠ›å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦ O(nnlogâ¡n+qn)O(n\\sqrt{n}\\log n+q\\sqrt{n})O(nnâ€‹logn+qnâ€‹)ã€‚ä»£ç ã€‚ [CF1056H] Detect Robots Portal. å°±æ˜¯è¦åˆ¤æ–­æ˜¯å¦å‡ºç°è¿‡ xâ†’aâ†’â‹¯â†’y,xâ†’bâ†’â‹¯â†’yx\\rightarrow a\\rightarrow \\cdots\\rightarrow y,x\\rightarrow b\\rightarrow \\cdots\\rightarrow yxâ†’aâ†’â‹¯â†’y,xâ†’bâ†’â‹¯â†’y çš„æƒ…å†µã€‚ æ ¹å·åˆ†æ²»ã€‚å¯¹äºå°ä¸²ï¼Œå¯¹äºæ¯ä¸ªç»ˆç‚¹ yyy å¼€ä¸€ä¸ª vectorï¼Œpush_back æ‰€æœ‰çš„èµ·ç‚¹å¯¹åº”çš„ (x,t)(x,t)(x,t) å¯¹ï¼Œæ€»ä¸ªæ•°æ˜¯ O(nn)O(n\\sqrt{n})O(nnâ€‹) çš„ã€‚å¯¹äºå¤§ä¸²ï¼Œè®°å½•æ‰€æœ‰ç‚¹çš„å‡ºç°ä½ç½®ï¼Œå¯¹äºæ¯ä¸ªä¸²ä»åå¾€å‰æ‰«ï¼Œè®°å½•å½“å‰æœ€å¤§çš„ç»ˆç‚¹ä½ç½®ç„¶ååˆ¤æ–­å³å¯ã€‚ä»£ç ã€‚ æ•°æ®ç»“æ„æ‚é¡¹ ä»¥ä¸‹å†…å®¹å¯èƒ½ä¸å¤ªå¸¸ç”¨ï¼Œä½†æ˜¯å› ä¸ºæŸäº›åŸå› æˆ‘ä»¬é€‰æ‹©å°†å…¶è®°å½•åœ¨è¿™é‡Œã€‚éšç¼˜å¡«å‘ã€‚ æ ¹å·é‡æ„ å³æ‰€è°“çš„â€œæ“ä½œåˆ†å—â€ï¼šåœ¨æ ¹å·æ¬¡æ“ä½œåé‡æ„æ•°æ®ç»“æ„æ¥è®¡ç®—å½±å“ã€‚ [APIO2019] æ¡¥æ¢ã€‚ æ“ä½œåˆ†å—ã€‚å—ä¹‹å‰çš„ä¿®æ”¹ç›´æ¥å¤„ç†æ‰ï¼Œå—å†…éƒ¨çš„æŒ‰ç…§é‡é‡é™åˆ¶æ’åºç„¶åæšä¸¾æ‰€æœ‰è¯¢é—®ï¼Œä¸éœ€è¦ä¿®æ”¹çš„è¾¹æŒ‰ç…§é‡é‡é™åˆ¶ä¾æ¬¡æ·»åŠ ï¼Œå†æšä¸¾éœ€è¦ä¿®æ”¹çš„è¾¹æŒ‰ç…§æ—¶é—´è¿›è¡Œä¿®æ”¹ï¼Œç„¶åç›´æ¥å¯æ’¤é”€å¹¶æŸ¥é›†ç»´æŠ¤è¿™ä¸€é˜¶æ®µçš„ä¿®æ”¹ï¼Œå¯¹äºä¸€ä¸ªå—å†…è¿™ä¸€æ­¥æ˜¯ O(mlogâ¡m+m+B2)O(m\\log m + m +B^2)O(mlogm+m+B2) çš„ã€‚ä»£ç ã€‚ æ ‘åˆ†å— å¤–æ˜Ÿæ—…è€…ç¦»å¼€äº†åœ°çƒã€‚Top Cluster æ ‘åˆ†å—çš„ç›¸å…³å†…å®¹ä¸ä¼šåœ¨ NOI 2024 å‰æ›´æ–°ã€‚æ‰€æœ‰æ ‘åˆ†å—çš„ç›¸å…³å†…å®¹ä¸ä¼šåœ¨çœé€‰è”è€ƒ 2024 å‰æ›´æ–°ã€‚ å€å¢å€¼åŸŸåˆ†å— å³é€šè¿‡ [Bi,Bi+1)[B^i,B^{i+1})[Bi,Bi+1) çš„æ–¹å¼è¿›è¡Œåˆ†å—ï¼Œåœ¨ç‰¹å®šé—®é¢˜ä¸Šæœ‰ç€ç‰¹å®šçš„ç”¨é€”ã€‚ [Ynoi2007] rgxsxrs Portal. æš´åŠ›åšæ³•æ˜¯ç›´æ¥åŠ¿èƒ½çº¿æ®µæ ‘ï¼Œä½†å¾ˆé—æ†¾ï¼ŒåŠ¿èƒ½æ˜¯ O(nV)O(nV)O(nV) çš„ã€‚ æˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†æ•°æŒ‰ç…§å¤§å°åˆ†ä¸ºå‡ ç»„ï¼Œè¿™æ ·åªéœ€è¦æ¯æ¬¡å¯¹æ¯ç»„è¿›è¡Œå‡æ‘Šã€‚æŒ‰ç…§å€¼åŸŸå€å¢å°±å¾ˆå¯¹ï¼Œè·³å‡ºå½“å‰å€¼åŸŸå—çš„æ•°å°±ä¸‹æ–¹åˆ°ä¸‹ä¸€ä¸ªå€¼åŸŸå—ï¼Œæ¯ä¸ªæ•°æœ€å¤šè·Œè½ logâ¡BV\\log_B VlogBâ€‹V æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(Bmlogâ¡nlogâ¡BV)O(B m\\log n\\log_B V)O(BmlognlogBâ€‹V)ã€‚ ç”±äºå¡ç©ºé—´ï¼Œæ‰€ä»¥éœ€è¦åº•å±‚åˆ†å—ã€‚ ä»£ç ã€‚ é¢˜è½¦ å…¶å®æ²¡ä»€ä¹ˆä¸œè¥¿äº†ã€‚ åˆ·åŸºç¡€ ä¸€äº›åŸºç¡€é¢˜ã€‚ [CF1406E] Deleting Numbers Portal. è€ƒè™‘æ±‚å‡º xxx çš„è´¨å› æ•°å¹‚æ¬¡ã€‚ å¯¹ n\\sqrt{n}nâ€‹ ä»¥å†…çš„è´¨æ•°å¯ä»¥æš´åŠ›æã€‚ç„¶åå‰©ä¸‹çš„éƒ½æ˜¯å¤§è´¨æ•°ï¼Œæœ€å¤šåªä¼šå‡ºç°ä¸€æ¬¡ã€‚å¦‚æœç›´æ¥æ‰«è¿‡å»éœ€è¦ 2m2m2m æ¬¡è¯¢é—®ï¼ˆmmm ä¸ºè´¨æ•°ä¸ªæ•°ï¼‰ï¼Œé‚£ä¹ˆå°† BBB ä¸ªè´¨æ•°åˆ†ä¸ºä¸€å—ï¼Œä¸€å—ä¸€å—åœ°å»æ£€æŸ¥ï¼Œå°±åªéœ€è¦ m+2mm+2\\sqrt{m}m+2mâ€‹ æ¬¡è¯¢é—®ã€‚ä»£ç ã€‚ [Ynoi2014] ä¸å½’ä¹‹äººä¸æœ›çœ¼æ¬²ç©¿çš„äººä»¬ Portal. åˆ†å—ç»´æŠ¤æ¯ä¸ªå—çš„å‰åç¼€ä¿¡æ¯å’Œå—å†…ç­”æ¡ˆï¼Œç„¶åè¯¢é—®ç›´æ¥ç”¨å¤§åŒæŒ‡é’ˆæ‰«ã€‚åªä¼šä¿ç•™ O(logâ¡a)O(\\log a)O(loga) ä¸ªæœ‰æ•ˆå‰ç¼€å’Œåç¼€ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ O(nnlogâ¡a)O(n\\sqrt{n}\\log a)O(nnâ€‹loga)ã€‚ä»£ç ã€‚ åˆ·æå‡ 1 å…¨é¢åº”ç”¨æ•°æ®ç»“æ„ï¼ [Ynoi2018] æœªæ¥æ—¥è®° Portal. ä½¿ç”¨å¸¦æ’å…¥ kkk å°çš„æ–¹å¼æ¥ç»´æŠ¤ kkk å°å€¼ï¼Œç”¨å¹¶æŸ¥é›†ç»´æŠ¤å°†ä¸€ä¸ªæ•°æ”¹ä¸ºå¦ä¸€ä¸ªæ•°ï¼Œæ•´å—æ”¹å€¼ï¼Œæ•£å—ç›´æ¥é‡æ„ã€‚ æ³¨æ„è¦è·³è¿‡æ— æ•ˆä¿®æ”¹ï¼Œè¿™ä¸ªå¡å¸¸å¾ˆæœ‰æ•ˆã€‚ä»£ç ã€‚ [Ynoi2018] äº”å½©æ–‘æ–“çš„ä¸–ç•Œ Portal. ç¦»çº¿ï¼Œé€å—å¤„ç†ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥åœ¨ O(m)O(m)O(m) å®Œæˆå•ä¸ªå—å†…å¤„ç†çš„ç®—æ³•ã€‚ è®°å—å†…æœ€å¤§å€¼ä¸º kkkï¼Œé‚£ä¹ˆï¼š kâ‰¤2xk\\le 2xkâ‰¤2xï¼Œä»¤å¤§äº xxx çš„æ•°å‡å» xxx åå°±æ²¡æœ‰æ¯” xxx å¤§çš„æ•°äº†ï¼Œkkk ä¼šå‡å°è‡³å°‘ kâˆ’xk-xkâˆ’xï¼› k&gt;2xk&gt;2xk&gt;2xï¼Œä»¤å°äºç­‰äº xxx çš„æ•°åŠ ä¸Š xxxï¼Œå°±æ²¡æœ‰æ¯” xxx å°çš„æ•°äº†ã€‚ç„¶åæ‰“ä¸Šå…¨å±€å‡æ ‡è®°ï¼Œkkk åœ¨æ“ä½œåå‡å°‘è‡³å°‘ xxxã€‚ å‘ç°è¿™ä¸ª kkk å•è°ƒä¸å¢ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸º O(V)O(V)O(V)ã€‚ ç»´æŠ¤æ•°å€¼æ—¶ç›´æ¥é‡‡ç”¨å¹¶æŸ¥é›†ï¼Œè®°å½•é›†åˆçš„å¤§å°ã€‚é›¶æ•£å—ä¿®æ”¹ç›´æ¥é‡æ„ï¼Œæ•´å—åˆ™ç›´æ¥ç»´æŠ¤ã€‚ä»£ç ã€‚ åˆ·æå‡ 2 è¿›ä¸€æ­¥æå‡æ•°æ®ç»“æ„èƒ½åŠ›ï¼ï¼ [Ynoi2007] tmpq Portal. æš´åŠ› DP å¯ä»¥å°† i,ki,ki,k çš„è´¡çŒ®æ‹†å¼€ç„¶åæš´åŠ›æ‰«ç„¶åä¹˜èµ·æ¥å³å¯ã€‚ çœ‹ä¸Šå»å°±éå¸¸çš„ç¦»è°±ï¼Œä»¥å‰ç»™å‡ºçš„åšæ³•å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š ç›´æ¥æ“ä½œåˆ†å—ï¼Œæ¯æ¬¡åªæœ‰ O(m)O(\\sqrt{m})O(mâ€‹) ä¸ªè¢«ä¿®æ”¹çš„æ•°ï¼Œç„¶åå°±æœ‰çœ‹æ¯ä¸ªæ•°æ˜¯å¦æ˜¯åœ¨è¿™ä¸ªå—å†…è¢«ä¿®æ”¹çš„ï¼Œ888 ç§æƒ…å†µéƒ½èƒ½åšï¼Œå°±æ˜¯æœ‰ç‚¹æ— è¯­ã€‚ æœ‰ä¸€ç§èªæ˜çš„åšæ³•ï¼Œè½¬åŒ–ä¸º a,b,ca,b,ca,b,c å•ç‚¹ä¿®æ”¹ï¼Œbi=aj=ckb_i=a_j=c_kbiâ€‹=ajâ€‹=ckâ€‹ çš„ä¸ªæ•°ã€‚å…ˆå†™ä¸€ä¸ªåŠ¨æ€ DP ç»´æŠ¤è½¬ç§»ã€‚ å¯¹äºæ¯ä¸ªå‡ºç°çš„ www çš„æ¬¡æ•°è¿›è¡Œæ ¹å·åˆ†æ²»ã€‚å¯¹äº cntwâ‰¤Bcnt_w\\le Bcntwâ€‹â‰¤Bï¼Œé‚£ä¹ˆè¿›è¡Œæš´åŠ› DPï¼Œç„¶åå·®åˆ†è´¡çŒ®ï¼Œæ‰”åˆ°ç›¸åº”çš„ä½ç½®ä¸Šï¼Œè¯¢é—®ç›¸å½“äºæ±‚å‰ç¼€å’Œï¼ŒO(nn)O(n\\sqrt{n})O(nnâ€‹) æ¬¡ä¿®æ”¹ï¼ŒO(m)O(m)O(m) æ¬¡æŸ¥è¯¢ï¼Œä½¿ç”¨ O(1)âˆ’O(n)O(1)-O(\\sqrt{n})O(1)âˆ’O(nâ€‹) çš„åˆ†å—ç»´æŠ¤ã€‚ å¯¹äº cntw&gt;Bcnt_w&gt;Bcntwâ€‹&gt;Bï¼Œç¦»çº¿æ‰«ä¸€éæ“ä½œåºåˆ—ï¼Œå•ç‚¹ä¿®æ”¹å‰ç¼€æŸ¥è¯¢ï¼Œç”±äºä¿®æ”¹çš„æ€»ä¸ªæ•°æ˜¯ O(m)O(m)O(m)ï¼Œè¯¢é—®ä¸ªæ•°æ˜¯ O(mn)O(m\\sqrt n)O(mnâ€‹)ï¼Œå› æ­¤ä½¿ç”¨ O(n)âˆ’O(1)O(\\sqrt{n})-O(1)O(nâ€‹)âˆ’O(1) çš„åˆ†å—ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"2023/12/27(#10)ï¼šPower Of Darkness","slug":"default/è®°å½•/2023/12/2023-12-27","date":"2023-12-26T00:00:00.000Z","updated":"2023-12-27T00:00:00.000Z","comments":true,"path":"c05a826b/","link":"","permalink":"https://james1badcreeper.github.io/c05a826b/","excerpt":"é‚£ä¾¿æ— éœ€å»æ€€ç–‘ã€‚","text":"é‚£ä¾¿æ— éœ€å»æ€€ç–‘ã€‚ åœ¨é»‘å¤œçš„å°½å¤´ï¼Œæ˜¯å¦å……æ»¡äº†å­¤ç‹¬ã€‚ å…¶å®æˆ‘è¿˜æƒ³èµ·äº†ä¸€äº›ä¸œè¥¿ï¼š å •å…¥è¿™æ— å°½çš„é»‘å¤œï¼Œè½å¹•æ˜¯æ— å çš„é£é›ªã€‚å´©å¡Œä¹‹é—´ï¼Œåœ¨ä½ èº«è¾¹ï¼Œä»¥ä»€ä¹ˆå½¢æ€è‡´æ­»ç¼ ç»µï¼Œä½ è¯´è¦æ–‡æ˜è¯ç”Ÿäºå²æœˆã€‚ å¼€å§‹å–œæ¬¢ä¸Šäº†å£èƒ¡ï¼Œæ„Ÿè§‰è‡ªå·±éœ€è¦æƒ³æ›´å¤šçš„ä¸œè¥¿ã€‚ [BalticOI 2017] Political Development Portal. å¯¼å‡ºå­å›¾ä¸­çš„ç‚¹è‡³å°‘æœ‰ä¸€ä¸ªå°äº kkkï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä»åº¦æ•°å°çš„ç‚¹å¼€å§‹è·‘æš´åŠ›ï¼Œç„¶åæŠŠå®ƒåˆ æ‰ã€‚ä»£ç ã€‚ [BalticOI 2017] Railway å¤„ç†å‡º DFS åºï¼Œç„¶åç»å…¸åœ°ï¼Œç›¸å½“äºæ¯æ¡è¾¹éƒ½ç»è¿‡äº†ä¸¤æ¬¡ã€‚ç»´æŠ¤æ—¶è®°å½•ä¸€ä¸‹è¾¹çš„ç¼–å·ï¼ŒBIT æä¸€ä¸‹å³å¯ã€‚ [BalticOI 2017] Toll Portal. æœ¬è´¨ä¸Šæ˜¯åˆ†æˆ kkk å±‚çš„å›¾ï¼Œå¯¹äºæ¯ä¸€å±‚ç»´æŠ¤ä¸€ä¸ªçŸ©é˜µï¼Œç„¶ååŠ¨æ€ DP çš„æ–¹å¼è½¬ç§»ï¼Œå€å¢é¢„å¤„ç†å³å¯ã€‚ æ€ä¹ˆåªæœ‰ä¸€ä¸ªæ¯”è¾ƒä¸é”™çš„é¢˜å•Šã€‚ çœ‹ä¸Šå» 2018 å¹´çš„é¢˜ä¸é”™ï¼Œè¿‡å‡ å¤©åšåšã€‚ [CF526E] Transmitting Levels Portal. ç›´æ¥æš´åŠ›å°±æ˜¯å¯¹çš„ï¼Œä¸‹é¢æ˜¯è¯æ˜ï¼š è®¾ iii èŠ‚ç‚¹è·³ä¸è¶…è¿‡ KKK å¯ä»¥åˆ°è¾¾ toito_itoiâ€‹ï¼Œé‚£ä¹ˆ nâ‰¤âˆ‘toiâˆ’in\\le \\sum to_i-inâ‰¤âˆ‘toiâ€‹âˆ’iï¼Œå› æ­¤å¿…æœ‰è‡³å°‘ä¸€ä¸ª toiâˆ’iâ‰¤n/ansto_i-i\\le n/anstoiâ€‹âˆ’iâ‰¤n/ansï¼Œæšä¸¾ n/ansn/ansn/ans ä¸ªæ•°ï¼Œæ¯æ¬¡ä¼šè·³ ansansans æ¬¡ã€‚ä»£ç ã€‚ ED æ‚æ´»å¥½å¤šã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/24(#9)ï¼šWelcome to the Elegant World","slug":"default/è®°å½•/2023/12/2023-12-24","date":"2023-12-23T00:00:00.000Z","updated":"2023-12-24T00:00:00.000Z","comments":true,"path":"b9d6a2f8/","link":"","permalink":"https://james1badcreeper.github.io/b9d6a2f8/","excerpt":"é†‰ä¹Ÿä»å®¹ï¼Œæˆ‘ä¹Ÿä»å®¹ã€‚","text":"é†‰ä¹Ÿä»å®¹ï¼Œæˆ‘ä¹Ÿä»å®¹ã€‚ æ²‰é†‰è¿™é£å…‰è®²ç©¶ æ˜æš—æ˜¯å‡è±¡ å‘Šåˆ«è¿™æ˜Ÿå…‰é»¯æ·¡ æ¥å»æ˜¯å‡è±¡ åæ‹¥è¿™æŒå£°æ•£å» èµ·è½æ˜¯å‡è±¡ ç¬‘å¯¹è¿™å†·çœ¼è§‚æœ› å¤©åœ°æ˜¯å‡è±¡ åˆ«å¼¯è…° æ¥å—æ—¶é—´ èº²ä¸å¼€çš„é‚£ä¸€åˆ€ äººç”Ÿæ¸ºæ¸º ä¸€ç§è„šæ­¥å…¥ä¸€å±± ç»“å±€æ²¡äººæ•¢èµŒç©¿ å¬‰ç¬‘è°¢å¹•å‹‰ä¸ºéš¾ åå¤ä¸Šæ¼” éš¾æ€ªç‰‡åˆ»æ–°é²œæ˜¯å‡è±¡ ç¬”å¢¨å†å¤šæ¸²æŸ“ æ˜æš—æ˜¯å‡è±¡ åŸè°…å¨±ä¹çœ‹å®˜ æ¥å»æ˜¯å‡è±¡ å¼€åœºæœ‰å¤šå–§é—¹ èµ·è½æ˜¯å‡è±¡ ç»“å°¾æœ‰å¤šå¯‚å¯¥ å¤©åœ°æ˜¯å‡è±¡ è®ºè‹±é›„ åªæœ‰æ•…äº‹ ä»æ¥æ²¡æœ‰åæ¥ åŠæ™Œè´ªæ¬¢å‡ æ¬¡ ç¼…æ€€éƒ½æ˜¯è°ˆèµ„ æ—è§‚éƒ½æ˜¯ä¸€æ—¶ å¹¸å…æ‰å«å†å² ä¸å¦‚ä¸‹å±± ç¬‘çœ‹ä¸‡ç‰©æ˜¯å‡è±¡ Oh itâ€™s a new world â€”â€” åæ™¨å®‡ã€Šæ–°ä¸–ç•Œã€‹ å¤ªæœ‰æ„Ÿè§‰äº†ï¼ æ–­æ›´æ— æ•°å¤©ï¼Œæˆ‘åˆå›æ¥äº†ï¼ï¼ [ARC104E] Random LIS Portal. å‘ç° nâ‰¤6n\\le 6nâ‰¤6ï¼Œå› æ­¤çŸ¥é“å¿…å®šæœ‰é¬¼ã€‚å¯ä»¥ O(nn)O(n^n)O(nn) æšä¸¾æ•°åˆ—çš„ç›¸å¯¹å¤§å°å…³ç³»ï¼Œç„¶åæˆ‘ä»¬å¯ä»¥å°†æ•°åˆ’åˆ†æˆè‹¥å¹²å€¼åŸŸæ®µã€‚å¯¹äºè½åœ¨ç›¸åŒå€¼åŸŸæ®µé‡Œçš„æšä¸¾ä¸‹ç•Œï¼Œç„¶åç»„åˆæ•°ç›´æ¥ç®—å³å¯ã€‚ä»£ç ã€‚ [ABC176F] Brave CHAIN Portal. è®¾ fi,x,yf_{i,x,y}fi,x,yâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii æ¬¡åˆ ç‰Œç•™ä¸‹ x,yx,yx,y çš„æœ€å¤§åˆ†æ•°ã€‚æš´åŠ›åšæ˜¯ O(n3)O(n^3)O(n3) çš„ï¼Œç»Ÿè®¡ä¸€ä¸‹å‰ç¼€æœ€å€¼å³å¯ã€‚ä»£ç ã€‚ [CEOI2012] å·¥ä½œè§„åˆ’ Portal. äºŒåˆ† + è´ªå¿ƒï¼Œç„¶åè®°ä¸€ä¸‹ç¼–å·è¾“å‡ºæ–¹æ¡ˆå³å¯ã€‚ ED è™½ç„¶æœ‰ç‚¹æ‘†ï¼ˆæ„Ÿè§‰è‡ªå·±æ²¡è¿›çŠ¶æ€ï¼‰ï¼Œä½†ä»Šå¤©çœ‹äº†äººæ°‘æ—¥æŠ¥å‘çš„ 2023 å¹´åº¦æ€»ç»“ï¼šhttps://www.bilibili.com/video/BV1HC4y1M7SE/ã€‚ å¥½æ„Ÿäººå•Šï¼Œæ²¡æƒ³åˆ°æˆ‘ä»¬å‘å±•äº†è¿™ä¹ˆå¤šå‘¢ã€‚ å‘½è¿ï¼Œå–å†³äºæˆ‘ä»¬è‡ªå·±çš„æŠ‰æ‹©ã€‚ æˆ‘ä»¬ä¼šç»§ç»­å‰è¡Œï¼","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"NOI ä¸€è½®å¤ä¹  VIIIï¼šæ•°å­¦ C","slug":"notes/NOI å¤ä¹ /noi-1-8","date":"2023-12-19T00:00:00.000Z","updated":"2024-01-19T00:00:00.000Z","comments":true,"path":"8c95d298/","link":"","permalink":"https://james1badcreeper.github.io/8c95d298/","excerpt":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬å…«ç¯‡ï¼Œä¸»è¦ä»‹ç»äº†æ•°è®ºã€çº¿æ€§ä»£æ•°ã€è®¡ç®—å‡ ä½•å’Œå…¶å®ƒæ•°å­¦çŸ¥è¯†ã€‚","text":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬å…«ç¯‡ï¼Œä¸»è¦ä»‹ç»äº†æ•°è®ºã€çº¿æ€§ä»£æ•°ã€è®¡ç®—å‡ ä½•å’Œå…¶å®ƒæ•°å­¦çŸ¥è¯†ã€‚ æ­£æ•´æ•°ä¸­çš„æ•°è®º ä¸»è¦æ˜¯é’ˆå¯¹ç´ æ•°çš„ç ”ç©¶ã€‚ ç´ æ•°ä¸åˆæ•° å¦‚æœä¸€ä¸ªæ•° x(xâˆˆN)x(x\\in\\mathbb{N})x(xâˆˆN) çš„çº¦æ•°ä»…æœ‰ 111 å’Œå®ƒæœ¬èº«ï¼Œé‚£ä¹ˆå°±ç§° xxx æ˜¯è´¨æ•°ï¼ˆç´ æ•°ï¼‰ï¼Œç‰¹åˆ«åœ°ï¼Œ000 å’Œ 111 ä¸æ˜¯è´¨æ•°ï¼Œå¦‚æœä¸€ä¸ªè‡ªç„¶æ•°ä¸æ˜¯è´¨æ•°ï¼Œä»–å°±æ˜¯åˆæ•°ã€‚ å¯ä»¥ç”¨çº¿æ€§ç­›åœ¨ O(n)O(n)O(n) çš„æ—¶é—´å†…ç­›å‡ºæ‰€æœ‰è´¨æ•°ï¼Œç”¨ O(r+(râˆ’l+1)logâ¡(râˆ’l+1))O(\\sqrt{r}+(r-l+1)\\log(r-l+1))O(râ€‹+(râˆ’l+1)log(râˆ’l+1)) çš„æ—¶é—´ç­›å‡ºåŒºé—´å†…çš„æ‰€æœ‰è´¨æ•°ã€‚ ppp è¿›èµ‹å€¼åºåˆ—æ˜¯åˆ»ç”»æ­£æ•´æ•°çš„é‡è¦æ–¹å¼ã€‚å¯ä»¥å°†æ­£æ•´æ•°è¡¨ç¤ºåˆ° ppp ç»´ç©ºé—´ä¸Šã€‚ å¤§è´¨å› æ•° ä¸€ä¸ªæ•°æœ€å¤šåªæœ‰ä¸€ä¸ª â‰¥v\\ge \\sqrt{v}â‰¥vâ€‹ çš„è´¨æ•°å› å­ï¼Œè¿™ä¸ªæ€è·¯éå¸¸ç»å…¸ã€‚ [NOI2015] å¯¿å¸æ™šå®´ã€‚æœ€æš´åŠ›çš„åšæ³•å°±æ˜¯è®¾ fS1,S2f_{S_1,S_2}fS1â€‹,S2â€‹â€‹ ä»£è¡¨ä¸¤äººé€‰çš„è´¨å› æ•°çŠ¶å‹ååˆ†åˆ«ä¸º S1,S2S_1,S_2S1â€‹,S2â€‹ï¼Œå‘ç° nâ‰¤500n\\le 500nâ‰¤500ï¼Œæ¯” 191919 å¤§çš„è´¨å› æ•°æœ€å¤šå‡ºç°ä¸€æ¬¡ï¼Œå¯ä»¥å•ç‹¬è®°å½•è¿™ä¸ªå¤§è´¨å› æ•°ï¼Œç„¶åæŠŠæ¯ä¸€ä¸ªæœ‰è¿™ä¸ªå¤§è´¨å› æ•°çš„å¯¿å¸è®¾ä¸ºä¸€ç»„ï¼Œåœ¨è¿™ä¸€ç»„è¿›è¡Œè½¬ç§»æ—¶å¦è®° g1,g2g_1,g_2g1â€‹,g2â€‹ åˆ†åˆ«ä»£è¡¨åªå…è®¸è¿™ä¸¤ä¸ªäººå…¶ä¸­ä¸€ä¸ªåƒæœ‰è¿™ä¸ªå¤§è´¨å› æ•°çš„å¯¿å¸ï¼Œæœ€ååˆå¹¶ç­”æ¡ˆçš„æ—¶å€™è¿˜è¦å‡å»æœ€åˆçš„ fffï¼Œå› ä¸ºä¸¤ä¸ªäººéƒ½ä¸åƒçš„ç®—äº†ä¸¤æ¬¡ã€‚ä»£ç ã€‚ æ•´é™¤æ€§ ç ”ç©¶æ•´é™¤ç›¸å…³çš„æ•°è®ºã€‚ æ•°è®ºåˆ†å— æ•°è®ºåˆ†å—ã€‚âŒŠniâŒ‹\\left\\lfloor\\frac{n}{i}\\right\\rfloorâŒŠinâ€‹âŒ‹ åªæœ‰ O(n)O(\\sqrt{n})O(nâ€‹) ä¸­ä¸åŒçš„å–å€¼ï¼Œå¹¶ä¸”æ¯ä¸€ç§å–å€¼éƒ½æ˜¯ä¸€ä¸ªè¿ç»­çš„åŒºé—´ã€‚ æ¯”å¦‚å…‰é€Ÿå¹‚æ˜¯åˆ©ç”¨è¿™ä¸€ç‚¹æ¥å®ç°çš„ï¼Œè¿™ä¸ªæŠ€å·§ä¹Ÿå¯ä»¥åœ¨ O(n)O(\\sqrt{n})O(nâ€‹) æ—¶é—´å†…æšä¸¾åˆ°æ‰€æœ‰åŒºé—´ã€‚ æœ€ç»å…¸çš„åº”ç”¨å°±æ˜¯å¿«é€Ÿè®¡ç®— âˆ‘i=1nf(i)g(âŒŠniâŒ‹)\\sum_{i=1}^n f(i)g\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)âˆ‘i=1nâ€‹f(i)g(âŒŠinâ€‹âŒ‹)ï¼Œéœ€è¦ O(1)O(1)O(1) è®¡ç®— âˆ‘i=lrf(i)\\sum_{i=l}^{r}f(i)âˆ‘i=lrâ€‹f(i)ï¼Œç„¶åå°† ggg ç›¸åŒçš„æ‰“åŒ…è®¡ç®—ã€‚ ä½¿å¾— âŒŠniâŒ‹=âŒŠnjâŒ‹\\lfloor\\frac{n}{i}\\rfloor=\\lfloor\\frac{n}{j}\\rfloorâŒŠinâ€‹âŒ‹=âŒŠjnâ€‹âŒ‹ æˆç«‹çš„æœ€å¤§æ»¡è¶³ iâ‰¤jâ‰¤ni\\le j\\le niâ‰¤jâ‰¤n çš„å—çš„å³ç«¯ç‚¹ä¸º âŒŠnâŒŠniâŒ‹âŒ‹\\left\\lfloor\\cfrac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloorâŒŠâŒŠinâ€‹âŒ‹nâ€‹âŒ‹ã€‚ä¸ºä»€ä¹ˆï¼Ÿä»¤ k=âŒŠniâŒ‹k=\\lfloor\\frac{n}{i}\\rfloork=âŒŠinâ€‹âŒ‹ï¼Œå¯çŸ¥ kâ‰¤nik\\le \\frac{n}{i}kâ‰¤inâ€‹ï¼Œé‚£ä¹ˆ âŒŠnkâŒ‹â‰¥i\\lfloor\\frac{n}{k}\\rfloor\\ge iâŒŠknâ€‹âŒ‹â‰¥iï¼Œæ‰€ä»¥ j=nij=\\frac{n}{i}j=inâ€‹ã€‚æ—¶é—´å¤æ‚åº¦ O(n)O(\\sqrt{n})O(nâ€‹)ã€‚ æ¬§å‡ é‡Œå¾·ç®—æ³• è¾—è½¬ç›¸å‡æ³•å¯ä»¥ç”¨æ¥æ±‚è§£ä¸¤ä¸ªæ•°çš„ gcdâ¡\\gcdgcdï¼š int gcd(int a, int b) &#123; if (a == b) return a; if (!a || !b) return a | b; if (!(a &amp; 1)) &#123; if (b &amp; 1) return gcd(a >> 1, b); return gcd(a >> 1, b >> 1) &lt;&lt; 1; &#125; if (!(b &amp; 1)) return gcd(a, b >> 1); if (a > b) return gcd((a - b) >> 1, b); return gcd((b - a) >> 1, a); &#125; è¾—è½¬ç›¸å‡ï¼ˆé™¤ï¼‰æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„ç»“æ„ï¼Œå‡ºç°æ—¶å¾€å¾€ä¼´éšç€ä¸ gcdâ¡\\gcdgcd ç›¸å…³çš„ç»“è®ºã€‚ ç±»æ¬§å‡ é‡Œå¾·ç®—æ³• ä¸‡èƒ½æ¬§å‡ é‡Œå¾·ç®—æ³• æ•°è®ºå‡½æ•° å®šä¹‰åŸŸä¸ºæ•´æ•°çš„å‡½æ•°æ˜¯æ•°è®ºå‡½æ•°ï¼Œä¸€èˆ¬æˆ‘ä»¬ç ”ç©¶æ•°è®ºå‡½æ•°ä¸­çš„ç§¯æ€§å‡½æ•°ã€‚å¯¹äºæ‰€æœ‰ç§¯æ€§å‡½æ•° fffï¼Œéƒ½æœ‰ f(1)=1f(1)=1f(1)=1ã€‚ å¸¸è§ç§¯æ€§å‡½æ•°ï¼š å•ä½å‡½æ•° Ïµ(n)=[n=1]\\epsilon(n)=[n=1]Ïµ(n)=[n=1]ï¼Œæ˜¯å®Œå…¨ç§¯æ€§å‡½æ•°ã€‚ å¸¸æ•°å‡½æ•° 1(n)=11(n)=11(n)=1ï¼Œæ˜¯å®Œå…¨ç§¯æ€§å‡½æ•°ã€‚ æ’ç­‰å‡½æ•° idâ¡k(n)=nk\\operatorname{id}_k(n)=n^kidkâ€‹(n)=nkï¼Œæ˜¯å®Œå…¨ç§¯æ€§å‡½æ•°ï¼Œå½“ k=1k=1k=1 æ—¶å¯ä»¥çœç•¥ä¸å†™ã€‚ é™¤æ•°å‡½æ•° Ïƒk(n)=âˆ‘dâˆ£ndk\\sigma_k(n)=\\sum_{d\\mid n}d^kÏƒkâ€‹(n)=âˆ‘dâˆ£nâ€‹dkã€‚è¿™æ ·çš„è¯ï¼ŒÏƒ0(n)=Ï„(n)\\sigma_0(n)=\\tau(n)Ïƒ0â€‹(n)=Ï„(n)ï¼ŒÏƒ1(n)\\sigma_1(n)Ïƒ1â€‹(n) ä»£è¡¨çº¦æ•°å’Œï¼Œæœ‰ Ïƒk(n)=âˆi=1s(âˆ‘j=0Î±ipijk)=âˆi=1sÏƒk(piÎ±i)\\sigma_k(n)=\\prod_{i=1}^s\\left(\\sum_{j=0}^{\\alpha_i}p_i^{jk}\\right)=\\prod_{i=1}^s\\sigma_k(p_i^{\\alpha_i})Ïƒkâ€‹(n)=âˆi=1sâ€‹(âˆ‘j=0Î±iâ€‹â€‹pijkâ€‹)=âˆi=1sâ€‹Ïƒkâ€‹(piÎ±iâ€‹â€‹)ã€‚ æ¬§æ‹‰å‡½æ•°ï¼ŒÏ†(n)\\varphi(n)Ï†(n) ä»£è¡¨ 1âˆ¼n1\\sim n1âˆ¼n ä¸­ä¸ nnn äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚ æœ¬è´¨ä¸åŒè´¨å› å­ä¸ªæ•°å‡½æ•° Ï‰(n)=âˆ‘p[pâˆ£n]\\omega(n)=\\sum_{p}[p\\mid n]Ï‰(n)=âˆ‘pâ€‹[pâˆ£n]ã€‚ çº¿æ€§ç­›å¯ä»¥è®¡ç®—æ‰€æœ‰çš„ç§¯æ€§å‡½æ•°ï¼ˆå‰ææ˜¯å¯ä»¥å¿«é€Ÿæ±‚å‡º f(pk+1)f(p^{k+1})f(pk+1)ï¼Œåªéœ€è¦è®°å½• lowlowlow ä»£è¡¨æœ€å°è´¨å› å­çš„æœ€é«˜æ¬¡å¹‚ï¼š for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[++tot] = i, f[i] = ..., low[i] = i; // å•ç‹¬ç®— f(p) for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; // i ä¸ p ä¸äº’è´¨ low[i * prime[j]] = low[i] * prime[j]; if (i == low[i]) f[i * prime[j]] = ...; // i = p^kï¼Œå•ç‹¬ç®— f(p^&#123;k+1&#125;) else f[i * prime[j]] = f[i / low[i]] * f[low[i] * prime[j]]; break; &#125; low[i * prime[j]] = prime[j]; f[i * prime[j]] = f[i] * f[prime[j]]; // i ä¸ p äº’è´¨ï¼Œf(ip) = f(i)f(p) &#125; &#125; ç‹„åˆ©å…‹é›·å·ç§¯æ˜¯æ•°è®ºå‡½æ•°çš„åŸºæœ¬è¿ç®—ã€‚å®šä¹‰ï¼š h(n)=âˆ‘dâˆ£nf(d)g(nd)h(n)=\\sum_{d\\mid n}f(d)g\\left(\\frac{n}{d}\\right) h(n)=dâˆ£nâˆ‘â€‹f(d)g(dnâ€‹) ç®€è®°ä¸º h=fâˆ—gh=f*gh=fâˆ—gã€‚ ç‹„åˆ©å…‹é›·å·ç§¯å…·æœ‰äº¤æ¢å¾‹ã€ç»“åˆå¾‹å’Œåˆ†é…å¾‹ã€‚ é¦–å…ˆï¼ŒÏµâˆ—f=f\\epsilon*f=fÏµâˆ—f=fã€‚å› æ­¤å•ä½å‡½æ•° Ïµ\\epsilonÏµ ä¸ºç‹„åˆ©å…‹é›·å·ç§¯çš„å•ä½å…ƒï¼Œé‚£ä¹ˆå°±å¯ä»¥å®šä¹‰æ•°è®ºå‡½æ•°çš„é€†å…ƒ fâˆ’1f^{-1}fâˆ’1ï¼Œæ»¡è¶³ fâˆ—fâˆ’1=Ïµf*f^{-1}=\\epsilonfâˆ—fâˆ’1=Ïµã€‚ ä¸€ä¸ª fff å­˜åœ¨é€†å…ƒï¼Œå½“ä¸”ä»…å½“ f(1)â‰ 0f(1)\\ne 0f(1)î€ =0ï¼Œå¹¶ä¸”é€†å…ƒå”¯ä¸€ã€‚f=gf=gf=g çš„å……è¦æ¡ä»¶æ˜¯ fâˆ—h=gâˆ—h(h(1)â‰ 1)f*h=g*h(h(1)\\ne 1)fâˆ—h=gâˆ—h(h(1)î€ =1)ã€‚è¿™æ ·ä¸€æ¥æœ‰ g(n)=âˆ’âˆ‘dâˆ£n,dâ‰ ng(d)f(nd)f(1)g(n) = -\\cfrac{\\sum\\limits_{d \\mid n, d \\neq n} g(d)f\\left(\\dfrac n d\\right)} {f(1)}g(n)=âˆ’f(1)dâˆ£n,dî€ =nâˆ‘â€‹g(d)f(dnâ€‹)â€‹ã€‚ ç§¯æ€§å‡½æ•°çš„ç‹„åˆ©å…‹é›·å·ç§¯æ˜¯ç§¯æ€§å‡½æ•°ï¼Œç§¯æ€§å‡½æ•°çš„é€†å…ƒä¹Ÿæ˜¯ç§¯æ€§å‡½æ•°ã€‚ ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸ç”¨çš„ç‹„åˆ©å…‹é›·å·ç§¯ï¼š 1âˆ—1=Ï„1*1=\\tau1âˆ—1=Ï„ï¼Œ Ï†âˆ—1=idâ¡\\varphi *1=\\operatorname{id}Ï†âˆ—1=idã€‚ ä»»æ„æ•°è®ºå‡½æ•° fff å·å¸¸æ•°å‡½æ•° 111 ç­‰ä»·äºåš fff çš„ç‹„åˆ©å…‹é›·å‰ç¼€å’Œï¼Œå³ï¼šg=fâˆ—1,g(n)=âˆ‘dâˆ£nf(d)g=f*1,g(n)=\\sum_{d\\mid n}f(d)g=fâˆ—1,g(n)=âˆ‘dâˆ£nâ€‹f(d)ã€‚å«ä¹‰æ˜¯å¯¹æ¯ä¸ª nnn è®¡ç®—ç»™å®šæ•°è®ºå‡½æ•°åœ¨å…¶æ‰€å› æ•°å¤„çš„å–å€¼å’Œã€‚ å°†æ¯ä¸ªæ•°å†™æˆæ— ç©·åºåˆ— an={c1,c2,â‹¯ }a_n=\\{c_1,c_2,\\cdots\\}anâ€‹={c1â€‹,c2â€‹,â‹¯} è¡¨ç¤º n=âˆpicin=\\prod p_i^{c_i}n=âˆpiciâ€‹â€‹ã€‚ç”±äº xâˆ£yx\\mid yxâˆ£y çš„å……è¦æ¡ä»¶ä¸º ax(ci)â‰¤ay(ci)a_x(c_i)\\le a_y(c_i)axâ€‹(ciâ€‹)â‰¤ayâ€‹(ciâ€‹)ï¼Œå› æ­¤ fâˆ—1f*1fâˆ—1 å¯ä»¥çœ‹æˆå¯¹ä¸‹æ ‡åšå…¶æ— ç©·åºåˆ—çš„é«˜ç»´å‰ç¼€å’Œã€‚ æ¨¡æ¿ï¼Œè¿™é‡Œæ˜¯å¯¹ aaa åšç‹„åˆ©å…‹é›·å‰ç¼€å’Œï¼Œæœ¬è´¨ä¸Šæ˜¯åˆ†ç»„èƒŒåŒ…ï¼Œæ¯ä¸ªè´¨æ•°æ˜¯ä¸€ç»„ï¼Œæ¯ç»„çš„ä½“ç§¯æ˜¯ pkp^kpkï¼Œä»£ç ã€‚ æ¬§æ‹‰å‡½æ•° æ¬§æ‹‰å‡½æ•°ï¼Œå³ Ï†(n)\\varphi(n)Ï†(n)ï¼Œä»£è¡¨ 1âˆ¼n1\\sim n1âˆ¼n ä¸­ä¸ nnn äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚ è®¾ n=âˆpikin=\\prod p_i^{k_i}n=âˆpikiâ€‹â€‹ï¼Œåˆ™æœ‰ï¼š Ï†(n)=nâˆ(1âˆ’1pi)=nâˆpiâˆ’1pi\\varphi(n)=n\\prod(1-\\cfrac{1}{p_i})=n\\prod \\cfrac{p_i-1}{p_i} Ï†(n)=nâˆ(1âˆ’piâ€‹1â€‹)=nâˆpiâ€‹piâ€‹âˆ’1â€‹ æ¬§æ‹‰åæ¼”ï¼šn=âˆ‘dâˆ£nÏ†(d)n = \\sum_{d\\mid n} \\varphi(d)n=âˆ‘dâˆ£nâ€‹Ï†(d)ã€‚ è«æ¯”ä¹Œæ–¯å‡½æ•° æˆ‘ä»¬å®šä¹‰è«æ¯”ä¹Œæ–¯å‡½æ•°ï¼š Î¼(n)={1,n=1,0,âˆƒd&gt;1,d2âˆ£n,(âˆ’1)Ï‰(n),otherwise.\\mu(n)=\\begin{cases}1,&amp;n=1,\\\\0,&amp;\\exists d&gt;1,d^{2}\\mid n, \\\\(-1)^{\\omega(n)},&amp;\\mathrm{otherwise}. \\end{cases} Î¼(n)=â©â¨â§â€‹1,0,(âˆ’1)Ï‰(n),â€‹n=1,âˆƒd&gt;1,d2âˆ£n,otherwise.â€‹ å®é™…ä¸Šå®ƒæ˜¯åœ¨å¯¹ N\\mathbb{N}N åšå®¹æ–¥ã€‚è®¾ g(n)=âˆ‘nâˆ£df(d)g(n)=\\sum_{n\\mid d} f(d)g(n)=âˆ‘nâˆ£dâ€‹f(d)ï¼Œå·²çŸ¥ gggï¼Œè¦æ±‚ f(1)f(1)f(1)ã€‚f(1)f(1)f(1) ç­‰äº ggg åœ¨ 111 çš„å€æ•°å¤„å–çš„å–å€¼å’Œï¼Œå‡å»è´¨æ•°å¤„çš„å–å€¼å’Œï¼Œä½†æ˜¯å¤šå‡äº†ä¸¤ä¸ªè´¨æ•°ä¹˜ç§¯çš„åœ°æ–¹ï¼Œå› æ­¤è¿˜è¦åŠ å›æ¥ã€‚è¿™å°±æ˜¯å®¹æ–¥åŸç†ï¼Œå®¹æ–¥ç³»æ•°æ˜¯ (âˆ’1)Ï‰(n)(-1)^{\\omega(n)}(âˆ’1)Ï‰(n)ã€‚ å®ƒä¸ä»…æ˜¯ç§¯æ€§å‡½æ•°ï¼Œè¿˜æ»¡è¶³ï¼š âˆ‘dâˆ£nÎ¼(d)={1,n=1,0,nâ‰ 1.\\sum_{d\\mid n}\\mu(d)=\\begin{cases} 1,&amp;n=1,\\\\ 0,&amp;n\\neq 1. \\end{cases} dâˆ£nâˆ‘â€‹Î¼(d)={1,0,â€‹n=1,nî€ =1.â€‹ ä¸Šè¿°å¼å­æè¿°çš„å…¶å®æ˜¯ Î¼âˆ—1=Ïµ\\mu*1=\\epsilonÎ¼âˆ—1=Ïµï¼Œä¹Ÿå°±æ˜¯è¯´ Î¼\\muÎ¼ æ˜¯ 111 çš„é€†å…ƒã€‚è¿™æ˜¯è«æ¯”ä¹Œæ–¯å‡½æ•°æœ€é‡è¦çš„æ€§è´¨ï¼Œå…¶å¼•å‡ºäº†æ€§è´¨ï¼šâˆ‘dâˆ£nÎ¼(d)=[n=1]\\sum_{d\\mid n}\\mu(d)=[n=1]âˆ‘dâˆ£nâ€‹Î¼(d)=[n=1]ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªè‰¾å¼—æ£®æ‹¬å·è½¬åŒ–ä¸ºå’Œå¼ï¼Œè¿™æ ·æ›´åŠ æ–¹ä¾¿è®¡ç®—ã€‚ä¸¤è€…çš„è½¬åŒ–ç§°ä¹‹ä¸ºè«æ¯”ä¹Œæ–¯åæ¼”ã€‚ è«æ¯”ä¹Œæ–¯åæ¼”æœ‰ä»¥ä¸‹ç»“è®ºï¼š è‹¥ g=fâˆ—1g=f*1g=fâˆ—1ï¼Œåˆ™ f=gâˆ—Î¼f=g*\\muf=gâˆ—Î¼ã€‚ è‹¥ g(n)=âˆ‘nâˆ£df(d)g(n)=\\sum_{n\\mid d}f(d)g(n)=âˆ‘nâˆ£dâ€‹f(d)ï¼Œåˆ™ f(n)=âˆ‘nâˆ£dÎ¼(dn)g(d)f(n)=\\sum_{n\\mid d} \\mu\\left(\\dfrac d n\\right) g(d)f(n)=âˆ‘nâˆ£dâ€‹Î¼(ndâ€‹)g(d)ã€‚è¿™ä¹Ÿè¢«ç§°ä¸ºè«æ¯”ä¹Œæ–¯å˜æ¢ï¼Œå®é™…ä¸Šå°±æ˜¯æŠŠä¸Šé¢é‚£ä¸€æ¡ç»™å†™å‡ºæ¥ã€‚ ç”±äº Ï†âˆ—1=idâ¡\\varphi * 1 = \\operatorname{id}Ï†âˆ—1=idï¼Œå› æ­¤ idâ¡âˆ—Î¼=Ï†\\operatorname{id} * \\mu =\\varphiidâˆ—Î¼=Ï†ã€‚ ä¸€ä¸ªå¸¸è§çš„åº”ç”¨æ˜¯ï¼Œ[gcdâ¡(i,j)=1]=âˆ‘dâˆ£gcdâ¡(i,j)Î¼(d)[\\gcd(i,j)=1]=\\sum_{d\\mid \\gcd(i,j)}\\mu(d)[gcd(i,j)=1]=âˆ‘dâˆ£gcd(i,j)â€‹Î¼(d)ã€‚è™½ç„¶çœ‹èµ·æ¥è¿™åƒæ˜¯åºŸè¯ï¼Œä½†è¿™ä¸€æ­¥å°† i,ji,ji,j äº’è´¨è½¬åŒ–ä¸ºäº†æšä¸¾ gcdâ¡(i,j)\\gcd(i,j)gcd(i,j) çš„çº¦æ•° dddã€‚å¦‚æœ i,ji,ji,j åŒæ ·éœ€è¦æšä¸¾ï¼Œé‚£ä¹ˆæšä¸¾ ddd å¹¶è®¡ç®—åˆæ³•çš„ i,ji,ji,j ä¸ªæ•°ï¼ˆå½“ä¸”ä»…å½“ dâˆ£i,dâˆ£jd\\mid i,d\\mid jdâˆ£i,dâˆ£jï¼‰å³å¯ã€‚å…·ä½“æ¥è¯´ï¼š âˆ‘i=1nâˆ‘j=1m[gcdâ¡(i,j)=1]=âˆ‘i=1nâˆ‘j=1mâˆ‘dâˆ£gcdâ¡(i,j)Î¼(d)=âˆ‘d=1minâ¡(n,m)Î¼(d)âˆ‘i=1nâˆ‘j=1m[dâˆ£iâˆ§dâˆ£j]=âˆ‘d=1minâ¡(n,m)Î¼(d)âŒŠndâŒ‹âŒŠmdâŒ‹\\begin{aligned} \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [\\gcd(i, j) = 1] &amp; = \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m \\sum\\limits_{d\\mid \\gcd(i, j)} \\mu(d) \\\\ &amp; = \\sum\\limits_{d = 1} ^ {\\min(n, m)} \\mu(d) \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [d\\mid i\\land d\\mid j] \\\\ &amp; = \\sum\\limits_{d = 1} ^ {\\min(n, m)} \\mu(d) \\left\\lfloor \\dfrac n d \\right\\rfloor \\left\\lfloor \\dfrac m d \\right\\rfloor \\\\ \\end{aligned} i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹[gcd(i,j)=1]â€‹=i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹dâˆ£gcd(i,j)âˆ‘â€‹Î¼(d)=d=1âˆ‘min(n,m)â€‹Î¼(d)i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹[dâˆ£iâˆ§dâˆ£j]=d=1âˆ‘min(n,m)â€‹Î¼(d)âŒŠdnâ€‹âŒ‹âŒŠdmâ€‹âŒ‹â€‹ å°±å¯ä»¥ç›´æ¥ä½¿ç”¨æ•°è®ºåˆ†å—åœ¨ O(n+m)O(\\sqrt{n}+\\sqrt{m})O(nâ€‹+mâ€‹) çš„æ—¶é—´å†…è®¡ç®—ã€‚ æœæ•™ç­› æˆ‘ä»¬è¦æ±‚ç§¯æ€§å‡½æ•° fff çš„å‰ç¼€å’Œï¼Œè®¾ S(n)=âˆ‘i=1nfiS(n)=\\sum_{i=1}^{n}f_iS(n)=âˆ‘i=1nâ€‹fiâ€‹ï¼Œå†æ‰¾ä¸€ä¸ªç§¯æ€§å‡½æ•° gggï¼Œè€ƒè™‘å®ƒä»¬çš„ç‹„åˆ©å…‹é›·å·ç§¯çš„å‰ç¼€å’Œï¼š âˆ‘i=1nâˆ‘dâˆ£if(d)g(id)=âˆ‘d=1ng(d)âˆ‘i=1âŒŠndâŒ‹f(i)=âˆ‘d=1ng(d)S(âŒŠndâŒ‹)\\begin{aligned} &amp;\\sum_{i=1}^{n} \\sum_{d\\mid i} f(d)g\\left(\\frac i d\\right)\\\\ =&amp;\\sum_{d=1}^n g(d)\\sum_{i=1}^{\\left\\lfloor\\frac n d\\right\\rfloor} f(i)\\\\ =&amp;\\sum_{d=1}^n g(d)S\\left(\\left\\lfloor\\frac n d\\right\\rfloor\\right) \\end{aligned} ==â€‹i=1âˆ‘nâ€‹dâˆ£iâˆ‘â€‹f(d)g(diâ€‹)d=1âˆ‘nâ€‹g(d)i=1âˆ‘âŒŠdnâ€‹âŒ‹â€‹f(i)d=1âˆ‘nâ€‹g(d)S(âŒŠdnâ€‹âŒ‹)â€‹ è€Œæˆ‘ä»¬æœ‰ï¼š g(1)S(n)=âˆ‘i=1ng(i)S(âŒŠniâŒ‹)âˆ’âˆ‘i=2ng(i)S(âŒŠniâŒ‹)=âˆ‘i=1n(fâˆ—g)(i)âˆ’âˆ‘i=2ng(i)S(âŒŠniâŒ‹)\\begin{aligned} g(1)S(n)&amp;=\\sum \\limits _{i=1}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor) - \\sum \\limits _{i=2}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor)\\\\ &amp;=\\sum\\limits_{i=1}^{n}(f*g)(i) - \\sum \\limits _{i=2}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor) \\end{aligned} g(1)S(n)â€‹=i=1âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹)âˆ’i=2âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹)=i=1âˆ‘nâ€‹(fâˆ—g)(i)âˆ’i=2âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹)â€‹ æ—¶é—´å¤æ‚åº¦ä¸º O(n34)O(n^{\\frac 3 4})O(n43â€‹)ï¼Œæˆ‘ä»¬å…ˆçº¿æ€§ç­›å‡ºå‰ mmm ä¸ªçš„ç­”æ¡ˆï¼Œé‚£ä¹ˆ m=n23m=n^{\\frac 2 3}m=n32â€‹ æ—¶ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n23)O(n^{\\frac 2 3})O(n32â€‹)ã€‚ æ¨¡æ¿ã€‚æœ‰ Î¼âˆ—1=Ïµ,Ï†âˆ—1=idâ¡\\mu * 1 =\\epsilon,\\varphi * 1 =\\operatorname{id}Î¼âˆ—1=Ïµ,Ï†âˆ—1=idï¼Œé‚£ä¹ˆç›´æ¥æœæ•™ç­›å³å¯ã€‚ä»£ç ã€‚ Min_25 ç­› ä¾‹é¢˜ å·©å›ºä¸€äº›åŸºç¡€å†…å®¹ã€‚ [CF1656H] Equal LCM Subsets Portal. ä»è´¨å› æ•°å¹‚æ¬¡çš„è§’åº¦è€ƒè™‘ï¼Œæ€è€ƒå“ªäº›æ˜¯é›†åˆä¸­ä¸èƒ½è¦çš„åœ°é›·ã€‚ å¦‚æœ aia_iaiâ€‹ ä¸èƒ½ç•™åœ¨é›†åˆä¸­ï¼Œé‚£ä¹ˆå®ƒè‡³å°‘æœ‰ä¸€ä¸ªè´¨å› å­çš„å¹‚æ¬¡æ¯” bbb ä¸­å…¶å®ƒæ‰€æœ‰æ•°éƒ½å¤§ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœ gcdâ¡aigcdâ¡(ai,bj)&gt;1\\gcd \\cfrac{a_i}{\\gcd(a_i,b_j)}&gt;1gcdgcd(aiâ€‹,bjâ€‹)aiâ€‹â€‹&gt;1ï¼Œé‚£ä¹ˆ aia_iaiâ€‹ å°±è¯¥è¢«ä»é›†åˆä¸­åˆ é™¤ã€‚ç›¸å½“äºå•ç‚¹ä¿®æ”¹ï¼ŒæŸ¥è¯¢å…¨å±€ gcdâ¡\\gcdgcdï¼Œè¿™ä¸ªè¿‡ç¨‹åªèƒ½è¿›è¡Œ O(n+m)O(n+m)O(n+m) è½®ï¼Œçº¿æ®µæ ‘ç›´æ¥ç»´æŠ¤ï¼Œæ¯è½®ä¿®æ”¹æ˜¯ O((n+m)logâ¡(n+m))O((n+m)\\log (n + m))O((n+m)log(n+m)) çš„ï¼Œå¯ä»¥æ¥å—ã€‚ä»£ç ã€‚ * [Luogu P5435] åŸºäºå€¼åŸŸé¢„å¤„ç†çš„å¿«é€Ÿ GCD Portal. æ¨¡æ„ä¹‰ä¸‹çš„æ•°è®º å°½ç®¡æ•°è®ºç›¸å…³çš„é¢˜ç›®ä¼¼ä¹å·²ç»é€€å‡ºç¯å¢ƒï¼Œä½†æ˜¯æœ¬èº«è¿˜æ˜¯æ¯”è¾ƒæœ‰æ„æ€çš„ã€‚ çº¿æ€§åŒä½™æ–¹ç¨‹ç»„ å¯ä»¥ä½¿ç”¨ CRT è§£å†³æ¨¡æ•°äº’è´¨çš„æƒ…å†µï¼ŒexCRT è§£å†³æ¨¡æ•°ä¸äº’è´¨çš„æƒ…å†µã€‚ {xâ‰¡a1(modm1)xâ‰¡a2(modm2)â‹¯xâ‰¡a3(modm3)\\begin{cases} x\\equiv a_1 \\pmod {m_1}\\\\ x\\equiv a_2 \\pmod {m_2}\\\\ \\cdots\\\\ x\\equiv a_3 \\pmod {m_3}\\\\ \\end{cases} â©â¨â§â€‹xâ‰¡a1â€‹(modm1â€‹)xâ‰¡a2â€‹(modm2â€‹)â‹¯xâ‰¡a3â€‹(modm3â€‹)â€‹ æ¨¡æ•°äº’è´¨ è®¾ M=âˆi=1nmi,Mi=mÃ·miM=\\prod_{i=1}^{n}m_i,M_i=m\\div m_iM=âˆi=1nâ€‹miâ€‹,Miâ€‹=mÃ·miâ€‹ï¼Œtit_itiâ€‹ æ˜¯çº¿æ€§åŒä½™æ–¹ç¨‹ Mitiâ‰¡1(modmi)M_it_i\\equiv 1 \\pmod{m_i}Miâ€‹tiâ€‹â‰¡1(modmiâ€‹) çš„ä¸€ä¸ªè§£ï¼Œä¹Ÿå°±æ˜¯è¯´ tit_itiâ€‹ æ˜¯ MiM_iMiâ€‹ æ¨¡ mim_imiâ€‹ çš„é€†å…ƒï¼ˆæ˜¾ç„¶ MiâŠ¥miM_i \\perp m_iMiâ€‹âŠ¥miâ€‹ å½“ä¸”ä»…å½“ mim_imiâ€‹ ä¸¤ä¸¤äº’è´¨ï¼‰ï¼Œé‚£ä¹ˆ x=âˆ‘i=1naiMiti+kMx=\\sum_{i=1}^{n}a_iM_it_i + kMx=âˆ‘i=1nâ€‹aiâ€‹Miâ€‹tiâ€‹+kMï¼Œæœ€å°éè´Ÿæ•´æ•°è§£éœ€è¦æ±‚ âˆ‘i=1naiMiti mod M\\sum_{i=1}^{n}a_iM_it_i\\bmod Mâˆ‘i=1nâ€‹aiâ€‹Miâ€‹tiâ€‹modMã€‚ i64 CRT(void) &#123; // x === a[i] (mod m[i]) i64 ans = 0, x; for (int i = 1; i &lt;= n; ++i) &#123; M[i] = mm / m[i]; t[i] = inv(M[i], m[i]); ans = (ans + a[i] * M[i] * t[i]) % mm; &#125; return (ans % mm + mm) % mm; &#125; æ¨¡æ•°ä¸äº’è´¨ è€ƒè™‘å¦‚ä½•åˆå¹¶ä¸¤ä¸ªæ–¹ç¨‹ç»„ã€‚æˆ‘ä»¬å…ˆå‡å®šä¸€å®šå¯ä»¥åˆå¹¶ï¼Œç„¶åçœ‹çœ‹ä»€ä¹ˆæ—¶å€™åˆå¹¶ä¹‹åçš„è§£æ˜¯ âˆ…\\varnothingâˆ…ã€‚ è¿™ç©æ„å„¿ç­‰ä»·äº a=k1m1+r1=k2m2+r2âŸ¹k1m1âˆ’k2m2=r2âˆ’r1a=k_1m_1+r_1=k_2m_2+r_2 \\Longrightarrow k_1m_1-k_2m_2=r_2-r_1a=k1â€‹m1â€‹+r1â€‹=k2â€‹m2â€‹+r2â€‹âŸ¹k1â€‹m1â€‹âˆ’k2â€‹m2â€‹=r2â€‹âˆ’r1â€‹ã€‚è¿™ä¸ªç†Ÿæ‚‰ï¼äºŒå…ƒä¸€æ¬¡ä¸å®šæ–¹ç¨‹ï¼ç›´æ¥ä½¿ç”¨ exgcd è®¡ç®—å³å¯ã€‚ äºæ˜¯ï¼š å¦‚æœ gcdâ¡(m1,m2)âˆ£(r2âˆ’r1)\\gcd(m_1,m_2)\\mid (r_2-r_1)gcd(m1â€‹,m2â€‹)âˆ£(r2â€‹âˆ’r1â€‹)ï¼Œé‚£ä¹ˆå¯ä»¥åˆå¹¶ï¼› å¦åˆ™ï¼ŒexCRT æ˜¯æ— è§£çš„ã€‚ ç°åœ¨æœ‰å¼•ç†ï¼šåˆå¹¶ä¹‹åçš„æ¨¡æ•°æ˜¯åŸæ¥ä¸¤ä¸ªæ¨¡æ•°çš„ lcmã€‚ å…·ä½“æ¥è¯´ï¼Œè®¾å½“å‰åˆå¹¶çš„ä½™æ•°ä¸º MMMï¼Œå½“å‰ç­”æ¡ˆä¸º ansansansï¼Œé‚£ä¹ˆä»»æ„ä¸€ä¸ª ans+Mxans+Mxans+Mx éƒ½æ»¡è¶³ç­”æ¡ˆï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ä¸ªæœ€å°çš„ xxx ä½¿å¾— ans+Mxâ‰¡ai(modmi)ans+Mx\\equiv a_i\\pmod {m_i}ans+Mxâ‰¡aiâ€‹(modmiâ€‹)ï¼Œå¯ä»¥ä½¿ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—æ¥è§£å†³ã€‚ i64 exCRT(void) &#123; // x === A (mod B) i64 M = 1, ans = 0; // M ä¸ºå½“å‰åˆå¹¶çš„æ¨¡æ•°ï¼Œans ä¸ºå½“å‰ç­”æ¡ˆ for (int i = 1; i &lt;= n; ++i) &#123; i64 b = B[i], x, y, c = (A[i] - ans + b) % b; i64 g = exgcd(M, b, x, y); // Mx + by = gcd(M, b) if (c % g != 0) return -1; x = (__int128)x * (c / g) % (b / g); ans = ans + M * x; M = b / g * M; ans %= M; &#125; return (ans % M + M) % M; &#125; ä¾‹é¢˜ å·©å›ºä¸€äº›åŸºç¡€å†…å®¹ã€‚ [CF1848E] Vika and Stone Skipping Portal. å¦‚æœè·³ ggg æ¬¡ï¼Œéœ€è¦æ»¡è¶³ï¼š 2xâˆXi=(2fâˆ’g+1)g2x\\prod X_i=(2f-g+1)g 2xâˆXiâ€‹=(2fâˆ’g+1)g æ±‚çš„å°±æ˜¯ 2xâˆXi2x\\prod X_i2xâˆXiâ€‹ çš„å¥‡å› æ•°ä¸ªæ•°ã€‚æå‰å°† xxx é™¤æ‰å…¶ lowbitâ¡\\operatorname{lowbit}lowbit å³å¯ç›´æ¥ç»Ÿè®¡å…¶å› æ•°ã€‚ ç›´æ¥ç»´æŠ¤å³å¯ã€‚æ³¨æ„æ¨¡æ•°è¿‡å°æ—¶é€†å…ƒçš„çˆ†ç‚¸é—®é¢˜ã€‚ä»£ç ã€‚ [NOI2018] å± é¾™å‹‡å£« Portal. ç”±äºæˆ‘ä»¬é€‰æ‹©çš„æ­¦å™¨æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥å®é™…ä¸Šä¾ç„¶æ˜¯ exCRTï¼Œåªä¸è¿‡æ–¹ç¨‹æ¢æˆäº† bxâ‰¡a(modp)bx\\equiv a\\pmod pbxâ‰¡a(modp)ã€‚è¿™æ ·æ˜¯ä¸€æ ·çš„ï¼Œè®¾å½“å‰åˆå¹¶çš„æ¨¡æ•°ä¸º MMMï¼Œç­”æ¡ˆä¸º ansansansï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªåˆå¹¶è¦æ»¡è¶³ b(ans+Mx)â‰¡a(modp)b(ans+Mx)\\equiv a\\pmod pb(ans+Mx)â‰¡a(modp)ï¼Œä¹Ÿå°±æ˜¯ bMxâˆ’py=aâˆ’bÃ—ansbMx-py=a-b\\times ansbMxâˆ’py=aâˆ’bÃ—ansã€‚ æ³¨æ„ä¸€ä¸ªç»†èŠ‚ï¼šè§£å‡ºæ¥çš„è§£å¿…é¡»èƒ½å°†é¾™æ‰“æ‰ï¼Œä¹Ÿå°±æ˜¯èƒ½å°†è¡€æ‰“æˆå°äºç­‰äº 000ï¼Œå¦åˆ™å³ä½¿æ»¡è¶³åŒä½™æ–¹ç¨‹ä¹Ÿæ²¡ç”¨ã€‚è®°å½•ä¸€ä¸ªèƒ½æŠŠè¡€é‡æ‰“æˆè´Ÿæ•°çš„æœ€å°æ”»å‡»æ¬¡æ•°ï¼Œç„¶åå¦‚æœç­”æ¡ˆå°äºè¿™ä¸ªæ”»å‡»æ¬¡æ•°ï¼Œç­”æ¡ˆå°±åŠ ä¸Šè¿˜éœ€è¦æ‰“çš„æ¬¡æ•°ã€‚ä»£ç ã€‚ [CF338D] GCD Table Portal. é¦–å…ˆå¦‚æœæœ‰è§£ï¼Œé‚£ä¹ˆé‚£ä¸ª xxx åº”è¯¥æ»¡è¶³ lcmâ¡(a1,a2,â‹¯ ,ak)âˆ£x\\operatorname{lcm}(a_1,a_2,\\cdots,a_k) \\mid xlcm(a1â€‹,a2â€‹,â‹¯,akâ€‹)âˆ£xã€‚å®é™…ä¸Š xxx å°±åº”è¯¥ç­‰äº lcmâ¡\\operatorname{lcm}lcmï¼Œå› ä¸ºå¦‚æœå¢åŠ å€æ•°ï¼Œyyy çš„æ„é€ åªä¼šå˜å¾—æ›´åŠ å›°éš¾ã€‚ è¿™æ ·æˆ‘ä»¬åªéœ€è¦æ»¡è¶³ aiâˆ£y+iâˆ’1a_i\\mid y+i-1aiâ€‹âˆ£y+iâˆ’1ï¼ŒexCRT æ±‚ä¸€ä¸‹å³å¯ã€‚ä»£ç ã€‚ çº¿æ€§ä»£æ•° æ¦‚å¿µ é«˜æ–¯æ¶ˆå…ƒæ³• æˆ‘ä»¬å¯ä»¥ä½¿ç”¨é«˜æ–¯æ¶ˆå…ƒä»¥ O(n3)O(n^3)O(n3) çš„æ—¶é—´æ±‚è§£æ–¹ç¨‹ç»„çš„è§£ã€‚å…·ä½“æ¥è¯´å°±æ˜¯ä¸€ä¸ªä¸€ä¸ªåœ°åŠ å‡æ¶ˆå…ƒï¼Œè½¬åŒ–æˆä¸Šä¸‰è§’å½¢å¼ï¼Œç„¶åå†ä»£å…¥å³å¯ã€‚ çº¿æ€§åŸº å¯¹äºå¼‚æˆ–çº¿æ€§åŸºï¼Œæˆ‘ä»¬ä½¿ç”¨è´ªå¿ƒæ³•æ„å»ºï¼š void insert(i64 x) &#123; for (int i = 50; i >= 0; --i) if (x &amp; (1ll &lt;&lt; i)) &#123; if (!p[i]) &#123; p[i] = x; ++cnt; break; &#125; else x ^= p[i]; &#125; &#125; i64 askmx(void) &#123; i64 ans = 0; for (int i = 50; i >= 0; --i) if ((ans ^ p[i]) > ans) ans ^= p[i]; return ans; &#125; æœ€å°å¼‚æˆ–å€¼æ˜¯ minâ¡{pi}\\min\\{p_i\\}min{piâ€‹}ã€‚ çº¿æ€§åŸºçš„åˆå¹¶ç›´æ¥æš´åŠ›åˆå¹¶å³å¯ã€‚ LGV å¼•ç† å¯¹äºä¸€ä¸ª DAGï¼Œ ç®€å•è®¡ç®—å‡ ä½• æ•°å­¦æ‚é¡¹ è¿åˆ†æ•° ç¾¤è®ºå…¥é—¨ åšå¼ˆè®º åšå¼ˆè®ºä¸»è¦ç ”ç©¶ä¸€äº›æœ‰ç«äº‰æˆ–å¯¹æŠ—æ€§è´¨çš„å¯¹è±¡ï¼Œåœ¨ä¸€å®šè§„åˆ™ä¸‹/äº§ç”Ÿçš„å„ç§è¡Œä¸ºã€‚ å¯¹äºå…¬å¹³ç»„åˆæ¸¸æˆï¼Œæˆ‘ä»¬é€šå¸¸ä¼šé€‰æ‹©è®¡ç®— SG å‡½æ•°ï¼›å¯¹äºéå…¬å¹³æ¸¸æˆï¼Œæˆ‘ä»¬ä¼šé€‰æ‹©æ¨å¯¼ä¸€äº›æ€§è´¨ã€‚ æ¦‚å¿µ æˆ‘ä»¬ä» Nim æ¸¸æˆå¼€å§‹ç ”ç©¶ã€‚æœ‰ nnn å †çŸ³å­ï¼Œæ¯äººæ¯æ¬¡å¯ä»ä»»æ„ä¸€å †çŸ³å­é‡Œå–å‡ºæ­£æ•´æ•°æšçŸ³å­æ‰”æ‰ï¼Œè°ä¸èƒ½åŠ¨è°å°±è¾“äº†ã€‚ æˆ‘ä»¬å°†æ¯ä¸ªçŠ¶æ€è§†ä½œä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆåšå¼ˆæƒ…å†µå°±å¯ä»¥åˆ»ç”»æˆä¸€å¼ æœ‰å‘å›¾ã€‚ä¸éš¾å‘ç°ï¼Œå¼‚æˆ–å’Œä¸º 000 æ—¶å…ˆæ‰‹å¿…è´¥ã€‚ å¤§éƒ¨åˆ†çš„å…¬å¹³ç»„åˆæ¸¸æˆï¼ˆæ‰€æœ‰ç©å®¶éƒ½å¯ä»¥æ“ä½œå¯¹æ–¹èƒ½æ“ä½œçš„ä¸œè¥¿ï¼‰éƒ½å¯ä»¥è½¬æ¢ä¸ºæœ‰å‘å›¾æ¸¸æˆï¼Œå¯¹äºçŠ¶æ€ xxx å’Œå®ƒçš„ kkk ä¸ªåç»§çŠ¶æ€ y1,â‹¯ ,yky_1,\\cdots,y_ky1â€‹,â‹¯,ykâ€‹ï¼Œå®šä¹‰ SG å‡½æ•°ä¸ºï¼š SGâ¡(x)=mexâ¡{SGâ¡(y1),SGâ¡(y2),â€¦,SGâ¡(yk)}\\operatorname{SG}(x)=\\operatorname{mex}\\{\\operatorname{SG}(y_1), \\operatorname{SG}(y_2), \\ldots, \\operatorname{SG}(y_k)\\} SG(x)=mex{SG(y1â€‹),SG(y2â€‹),â€¦,SG(ykâ€‹)} å¯¹äºç”± nnn ä¸ªæœ‰å‘å›¾æ¸¸æˆç»„æˆçš„ç»„åˆæ¸¸æˆï¼Œå½“ä¸”ä»…å½“ âŠ•SGâ¡(s)â‰ 0\\oplus \\operatorname{SG}(s)\\ne 0âŠ•SG(s)î€ =0 çš„æ—¶å€™ï¼Œå…ˆæ‰‹å¿…èƒœï¼Œç§°ä¹‹ä¸º P æ€ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒSGâ¡(x)=0\\operatorname{SG}(x)=0SG(x)=0 æ˜¯å¿…è´¥æ€ï¼Œç§°ä¹‹ä¸º N æ€ã€‚ SG å®šç†ï¼šä¸€ä¸ªæ¸¸æˆçš„ SG å€¼æ˜¯å…¶æ‰€æœ‰å­æ¸¸æˆçš„ SG å€¼çš„å¼‚æˆ–å’Œï¼Œè¿™å¯ä»¥è¯´æ˜ Nim æ¸¸æˆç»“è®ºçš„ç”±æ¥ã€‚ [HNOI2007] åˆ†è£‚æ¸¸æˆã€‚ç»ˆæ­¢çŠ¶æ€æ˜¯æ‰€æœ‰è±†å­åœ¨ nnn å·ç“¶å­ï¼Œè€Œæ¯ä¸ªè±†å­æ˜¯ç‹¬ç«‹çš„ï¼Œç›´æ¥æš´åŠ› DP å³å¯ã€‚ä»£ç ã€‚ Anti-SG å®šç† å¦‚æœä¸èƒ½åŠ¨çš„äººè·èƒœï¼Œé‚£ä¹ˆè¿™ä¸ªæ¸¸æˆå«åšåå¸¸æ¸¸æˆã€‚åŒæ ·çš„ï¼Œæœ‰åˆ¤æ–­å¿…èƒœæ¡ä»¶çš„ Anti-SG å®šç†ï¼š å¦‚æœæ¸¸æˆçš„ SG å€¼ä¸º 000ï¼Œé‚£ä¹ˆæ‰€æœ‰å­æ¸¸æˆçš„ SG å€¼éƒ½ä¸è¶…è¿‡ 111 æ—¶å…ˆæ‰‹å¿…èƒœï¼ˆè¿˜æ˜¯è¦å¼‚æˆ–å€¼ä¸º 000ï¼‰ï¼› å¦‚æœæ¸¸æˆçš„ SG å€¼ä¸æ˜¯ 000ï¼Œé‚£ä¹ˆè‡³å°‘æœ‰ä¸€ä¸ªå­æ¸¸æˆçš„ SG å€¼è¶…è¿‡ 111 æ—¶å…ˆæ‰‹å¿…èƒœã€‚å…¶åœ¨å†³ç­–è¿‡ç¨‹ä¸­å¯ä»¥è½¬åŒ–ä¸ºä¸Šè¿°æƒ…å†µã€‚ æ¨¡æ¿ã€‚ ç»å…¸åšå¼ˆæ¨¡å‹ åšå¼ˆè®ºä¸­æœ‰ä¸€äº›ç‰¹åˆ«ç»å…¸çš„é—®é¢˜ï¼Œæˆ‘ä»¬æ¥ä»‹ç»ä¸€äº›ã€‚ å¨ä½å¤«åšå¼ˆ Portal.ä¸¤å †çŸ³å­ï¼Œå¯ä»¥å–ä¸€å †ä¸­çš„ä»»æ„ä¸ªï¼Œä¹Ÿå¯ä»¥åœ¨ä¸¤å †ä¸­éƒ½å– xxx ä¸ªã€‚ æˆ‘ä»¬å¯ä»¥å‘ç°ä»¥ä¸‹çŠ¶æ€æ˜¯å…ˆæ‰‹å¿…è´¥çš„ï¼š (0,0)(0, 0)(0,0)ï¼Œ (1,2)(1, 2)(1,2)ï¼Œ (3,5)(3, 5)(3,5)ï¼Œ (4,7)(4, 7)(4,7)ï¼Œ (6,10)(6, 10)(6,10)ï¼Œ (8,13)(8, 13)(8,13)ã€‚ ä¸¤è€…çš„å·®æ˜¯è‡ªç„¶æ•°åˆ—ï¼Œç¬¬ä¸€ä¸ªæ•°æ˜¯ä¹‹å‰æ‰€æœ‰æ–°å‡ºç°çš„æ•°æ˜¯ä¹‹å‰å‡ºç°æ•°çš„ mexã€‚å¯ä»¥è¯æ˜ç»“è®ºæ˜¯ a=âŒŠ(bâˆ’a)Ã—5+12âŒ‹a=\\left\\lfloor (b-a)\\times \\cfrac{\\sqrt{5}+1}{2}\\right\\rfloora=âŒŠ(bâˆ’a)Ã—25â€‹+1â€‹âŒ‹ æ—¶å…ˆæ‰‹å¿…è´¥ã€‚ å…¬å¹³ç»„åˆ åšå¼ˆè®ºé™¤äº† SG å®šç†å¤–ï¼Œå‰©ä¸‹çš„å†…å®¹å‡ ä¹å…¨éƒ¨åŸºäº DPã€‚æœ‰æ—¶å€™é€šè¿‡æ‰“è¡¨æ¥å¯»æ‰¾ SG å‡½æ•°çš„è§„å¾‹ä¹Ÿæ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ã€‚ [CF768E] Game of Stones Portal. å¯ä»¥è€ƒè™‘ä¸€ä¸ªçŸ³å †ä¼šè¢«å–å¤šå°‘æ¬¡ï¼Œå‘ç°æ˜¯ä» 111 å¼€å§‹ä¾æ¬¡å–ï¼Œç„¶åå°±è½¬æˆäº†æ­£å¸¸çš„ Nim æ¸¸æˆã€‚ä»£ç ã€‚ [HNOI2014] æ±Ÿå—ä¹ Portal. è€ƒè™‘æšä¸¾æ‰€æœ‰çš„ mmmï¼Œé‚£ä¹ˆå¯ä»¥è®¡ç®—æ‰€æœ‰ nnn çš„ SG å€¼ã€‚å‘ç°æ•´é™¤åˆ†å—å¯ä»¥ä¼˜åŒ–æšä¸¾ mmm è¿™ä¸ªè¿‡ç¨‹ï¼Œå› ä¸º n/mn/mn/m å’Œ n/m+1n/m+1n/m+1 å¿…æœ‰ä¸€ä¸ªå¥‡å¶æ€§ä¸å˜ã€‚ä»£ç ã€‚ [AGC017D] Game on Tree Portal. é—®é¢˜å¯ä»¥åˆ†è§£æˆè‹¥å¹²æ£µå­æ ‘ï¼Œæ¯æ£µå­æ ‘éƒ½å¸¦ç€æ ¹èŠ‚ç‚¹ï¼Œç„¶åå‘ç°å…¶ SG å€¼æ˜¯å­æ ‘çš„ SG å€¼åŠ  111ï¼Œç›´æ¥å¤„ç†å³å¯ã€‚ä»£ç ã€‚ [AGC010D] Decrementing Portal. å¦‚æœåˆå§‹ âˆ‘aiâˆ’1\\sum a_i-1âˆ‘aiâ€‹âˆ’1 ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆå…ˆæ‰‹å¯ä»¥ä¸€ç›´ç»´æŒè¿™ä¸ªçŠ¶æ€ï¼ˆåªéœ€è¦æ“ä½œå¶æ•°å³å¯ï¼Œæƒ…å†µä¸ä¼šæ”¹å˜ï¼‰ã€‚ åˆå§‹ä¸ºå¶æ•°å‘¢ï¼Ÿå¦‚æœå±€é¢ä¸‹åªæœ‰ä¸€ä¸ªå¥‡æ•°ï¼Œé‚£ä¹ˆæ“ä½œå®ƒå°±å¯ä»¥å‡ºç°å¶å…¬å› æ•°ï¼Œæ¨¡æ‹Ÿå³å¯ã€‚ä»£ç ã€‚ [AGC016F] Games on DAG Portal. ä¸éš¾æƒ³åˆ°æŒ‰ç…§ SG å€¼è¿›è¡Œåˆ†å±‚è½¬ç§»ï¼Œå¯¹äºæ–°å¢åŠ çš„ SG å€¼æ›´å°çš„éƒ¨åˆ†ï¼Œä¸€å®šè¦æœ‰è¾¹è¿å‘å®ƒä»¬ä¸­çš„ç‚¹æ¥ä¿è¯ SG å€¼çš„å¤§å°ã€‚è½¬ç§»çš„æ—¶å€™ç›´æ¥æšä¸¾å­é›† SSSï¼Œåˆ¤æ–­åˆ°è¾¾çš„ SG å€¼æ›´å°çš„é›†åˆ TTTï¼Œæ­¤æ—¶ä»¤ SGâ¡(T)=k\\operatorname{SG}(T)=kSG(T)=kï¼Œè®¾ fif_ifiâ€‹ ä»£è¡¨è€ƒè™‘é›†åˆ iii ä¸­çš„ç‚¹æ—¶ SGâ¡(1)=SGâ¡(2)\\operatorname{SG}(1)=\\operatorname{SG}(2)SG(1)=SG(2) çš„æ–¹æ¡ˆæ•°ï¼Œè½¬ç§»ï¼š å¯¹äº Tâ†’ST\\rightarrow STâ†’S çš„è¾¹ï¼Œæ¯ä¸€ä¸ª TTT ä¸­çš„å…ƒç´ éƒ½è‡³å°‘å‘ SSS ä¸­è¿ä¸€æ¡è¾¹ï¼› å¯¹äº Sâ†’TS\\rightarrow TSâ†’T çš„è¾¹ï¼Œéšä¾¿è¿å³å¯ã€‚ ç›´æ¥åšå³å¯ã€‚ä»£ç ã€‚ [ABC278G] Generalized Subtraction Game Portal. å¦‚æœå¯ä»¥å…ˆæ‰‹ç¬¬ä¸€æ­¥ä¸‹åœ¨ä¸­é—´ï¼Œç„¶åæˆ‘ä»¬å°±ä¸‹æ¨¡ä»¿æ£‹å°±è¡Œäº†ã€‚ å¦åˆ™ï¼Œæ­¤æ—¶é€‰æ‹©çš„åŒºé—´é•¿åº¦å›ºå®šï¼Œè€ƒè™‘è®¡ç®— SG å‡½æ•°ï¼Œä»¤ SGâ¡i\\operatorname{SG}_iSGiâ€‹ ä»£è¡¨é•¿åº¦ä¸º iii çš„æ¸¸æˆçš„ SG å€¼ã€‚ å¯¹äº i&lt;li&lt;li&lt;lï¼Œæœ‰ SGâ¡i=0\\operatorname{SG}_i=0SGiâ€‹=0ï¼Œå¦åˆ™æšä¸¾é€‰æ‹©çš„é•¿åº¦ï¼Œæœ‰ SGâ¡i=mexâ¡j=0iâˆ’l{SGâ¡jxorâ¡SGâ¡iâˆ’jâˆ’l}\\operatorname{SG}_i=\\operatorname{mex}_{j=0}^{i-l}\\{\\operatorname{SG}_{j} \\operatorname{xor} \\operatorname{SG}_{i-j-l}\\}SGiâ€‹=mexj=0iâˆ’lâ€‹{SGjâ€‹xorSGiâˆ’jâˆ’lâ€‹}ã€‚ è¾“å‡ºæ–¹æ¡ˆæ—¶é‡‡ç”¨ set ç»´æŠ¤è¿ç»­æ®µï¼Œä¸æ–­é€‰æ‹©åæ‰‹å¿…è´¥çš„åŒºé—´å³å¯ã€‚ [CF1458E] Nim Shortcuts Portal. æ­£å¸¸æƒ…å†µä¸‹ï¼Œé»‘è‰²çš„æ˜¯å…ˆæ‰‹å¿…è´¥çš„ï¼š ä½†å¦‚æœå­˜åœ¨é™åˆ¶ï¼ˆé»„è‰²çš„ä¹Ÿæ˜¯å¿…è´¥æ€ï¼Œé‚£ä¹ˆæƒ…å†µä¼šå‘ç”Ÿæ”¹å˜ï¼‰ï¼š å¯ä»¥å‘ç°å¿…è´¥æ€æ˜¯è‹¥å¹²æ¡æ–œçº¿ï¼Œåˆå§‹æ–œçº¿æ˜¯ x=yx=yx=yï¼Œç‰¹æ®Šç‚¹ä¼šå¯¼è‡´æ–œçº¿å‘ä¸‹å’Œå‘å³å¹³ç§»ï¼Œå‘ç°è¿™æ˜¯ä¸ªäºŒç»´æ•°ç‚¹ï¼Œæ‰«æçº¿ç»´æŠ¤ä½¿å…¶å‘ xxx è½´æ–¹å‘å¹³ç§»çš„ä¸ªæ•°ï¼Œæ ‘çŠ¶æ•°ç»„ç»´æŠ¤ yyy è½´æ–¹å‘ï¼Œç”¨ xâˆ’yx-yxâˆ’y çš„å€¼åˆ¤æ–­æ˜¯å¦åœ¨æ–œçº¿ä¸Šå³å¯ã€‚ä»£ç ã€‚ éå…¬å¹³ç»„åˆ æ¯”è¾ƒæœ‰è¶£ã€‚ [AGC048D] Pocky Game Portal. è®¾ fl,rf_{l,r}fl,râ€‹ ä»£è¡¨ ala_lalâ€‹ è‡³å°‘ä¸ºå¤šå°‘æ‰èƒ½ä½¿å¾— [l,r][l,r][l,r] å…ˆæ‰‹å¿…èƒœï¼Œgl,rg_{l,r}gl,râ€‹ ä»£è¡¨ ara_rarâ€‹ è‡³å°‘ä¸ºå¤šå°‘æ‰èƒ½ä½¿å¾— [l,r][l,r][l,r] åæ‰‹å¿…èƒœã€‚è½¬ç§»æ—¶ç”±äºæœ€åæ˜¯ä¸€ä¸ªä¸€ä¸ªå–ï¼Œç›´æ¥ç®—å³å¯ï¼Œä»£ç ã€‚ [CF1033G] Chip Game Portal. æ¨¡ a+ba+ba+b æ„ä¹‰ä¸‹çš„å±€é¢æ˜¯ç­‰ä»·çš„ï¼Œè€ƒè™‘æšä¸¾ a+ba+ba+bï¼Œå°† vvv æ’åºï¼Œè®¡ç®—å‡ºåˆæ³•çš„å€¼åŸŸ [viâˆ’1+1,vi][v_{i-1}+1,v_i][viâˆ’1â€‹+1,viâ€‹]ï¼Œè€Œä¸”åº”è¯¥å‡å»å­˜åœ¨ä¸¤ä¸ª 2aâ‰¤vi2a\\le v_i2aâ‰¤viâ€‹ çš„æƒ…å†µï¼Œéšä¾¿ç®—ç®—å°±å¥½äº†ã€‚ä»£ç ã€‚ é¢˜è½¦","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"NOI ä¸€è½®å¤ä¹  VIIï¼šæ•°å­¦ B","slug":"notes/NOI å¤ä¹ /noi-1-7","date":"2023-12-18T00:00:00.000Z","updated":"2024-03-26T00:00:00.000Z","comments":true,"path":"1bd36e32/","link":"","permalink":"https://james1badcreeper.github.io/1bd36e32/","excerpt":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬ä¸ƒç¯‡ï¼Œä¸»è¦ä»‹ç»äº†å„ç±»å¤šé¡¹å¼ã€é›†åˆå¹‚çº§æ•°ã€ç”Ÿæˆå‡½æ•°å’Œç‰¹æ®Šæ•°åˆ—çš„ç›¸å…³å†…å®¹ã€‚","text":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬ä¸ƒç¯‡ï¼Œä¸»è¦ä»‹ç»äº†å„ç±»å¤šé¡¹å¼ã€é›†åˆå¹‚çº§æ•°ã€ç”Ÿæˆå‡½æ•°å’Œç‰¹æ®Šæ•°åˆ—çš„ç›¸å…³å†…å®¹ã€‚ é’è›™å¤§é˜Ÿè¸ç¢äº†æ­¤å¤„çš„è’åŸã€‚æœ¬æ–‡å°†ä¸ä¼šåœ¨è”åˆçœé€‰ 2024 å‰æ›´æ–°ã€‚ä¹‹åå¯èƒ½ä¼šæ›´æ–°é›†åˆå¹‚çº§æ•°å’Œä¸ºäº†æ–¹ä¾¿ç†è§£é›†åˆå¹‚çº§æ•°è€Œå†™çš„ FFTã€‚ åŸºç¡€æ¦‚å¿µ ä¸€äº›åŸºæœ¬çŸ¥è¯†ã€‚ æé™ è¿™é‡Œä¸ä»‹ç»æé™çš„ä¸¥è°¨å®šä¹‰ã€‚æé™å¯ä»¥ç›´æ¥è¿›è¡Œå››åˆ™è¿ç®—ã€‚æ ¹æ®æé™çš„å®šä¹‰å¯ä»¥ç›´æ¥å®šä¹‰å‡½æ•°çš„æé™ã€‚ æˆ‘ä»¬å®šä¹‰è‡ªç„¶åº•æ•° e=limâ¡nâ†’âˆ(1+1n)n=limâ¡nâ†’âˆ(1+1n)n+1e=\\lim\\limits_{n\\to \\infty} (1+\\frac 1 n)^n=\\lim\\limits_{n\\to \\infty} (1+\\frac 1 n)^{n+1}e=nâ†’âˆlimâ€‹(1+n1â€‹)n=nâ†’âˆlimâ€‹(1+n1â€‹)n+1ã€‚ å¯¼æ•°ä¸å¾®åˆ† åœ¨ x0x_0x0â€‹ ä¸Šçš„å¯¼æ•°æ˜¯ xâ†’x0x\\to x_0xâ†’x0â€‹ çš„æé™ã€‚ è®¾ f(x),g(x)f(x),g(x)f(x),g(x) å‡åœ¨ xxx å¤„å¯å¯¼ï¼Œé‚£ä¹ˆï¼š (f(x)+g(x))â€²=fâ€²(x)+gâ€²(x)(f(x)+g(x))&#x27;=f&#x27;(x)+g&#x27;(x)(f(x)+g(x))â€²=fâ€²(x)+gâ€²(x)ï¼› (f(x)g(x))â€²=fâ€²(x)g(x)+f(x)gâ€²(x)(f(x)g(x))&#x27;=f&#x27;(x)g(x)+f(x)g&#x27;(x)(f(x)g(x))â€²=fâ€²(x)g(x)+f(x)gâ€²(x)ï¼› (f(x)g(x))â€²=fâ€²(x)g(x)âˆ’f(x)gâ€²(x)g2(x)\\left(\\frac{f(x)}{g(x)}\\right)&#x27;=\\frac{f&#x27;(x)g(x)-f(x)g&#x27;(x)}{g^2(x)}(g(x)f(x)â€‹)â€²=g2(x)fâ€²(x)g(x)âˆ’f(x)gâ€²(x)â€‹ï¼› f(g(x))â€²=fâ€²(g(x))gâ€²(x)f(g(x))&#x27;=f&#x27;(g(x))g&#x27;(x)f(g(x))â€²=fâ€²(g(x))gâ€²(x)ã€‚ ç§¯åˆ† ï¼ˆå¾…è¡¥å……ï¼‰ ç”Ÿæˆå‡½æ•° ç”Ÿæˆå‡½æ•°æ˜¯ä¸€ç§å½¢å¼å¹‚çº§æ•°ï¼ˆå®ƒä¸æ˜¯å‡½æ•°ï¼Œxxx ä¸æ˜¯è‡ªå˜é‡è€Œæ˜¯è‡ªç”±å…ƒï¼‰ï¼Œå…¶æ¯ä¸€é¡¹çš„ç³»æ•°å¯ä»¥æä¾›å…³äºè¿™ä¸ªåºåˆ—çš„ä¿¡æ¯ã€‚è¿™æ˜¯ä¸ªå¾ˆæœ‰ç”¨çš„ä¸œè¥¿ï¼Œæ˜¯ç”¨äºåˆ»ç”»æ•°åˆ—çš„ç»„åˆå·¥å…·ï¼Œèƒ½å¤Ÿå°†å¾ˆå¤šå¤æ‚çš„ç»„åˆé—®é¢˜èµ‹ä»¥ç®€æ´çš„ä»£æ•°å½¢å¼ï¼Œè€ƒåœºä¸Šä¹Ÿä¼šå‡ºç°ä¸éœ€è¦å¤šé¡¹å¼ç®—æ³•åªç”¨ç”Ÿæˆå‡½æ•°å°±èƒ½è§£å†³çš„é—®é¢˜ã€‚ ä¸€èˆ¬åœ°ï¼Œç”Ÿæˆå‡½æ•°å¯ä»¥è¡¨ç¤ºä¸ºï¼š F(x)=âˆ‘i=0âˆaiki(x)F(x)=\\sum_{i=0}^{\\infty} a_i k_i(x) F(x)=i=0âˆ‘âˆâ€‹aiâ€‹kiâ€‹(x) å…¶ä¸­ ki(x)k_i(x)kiâ€‹(x) è¢«ç§°ä¹‹ä¸ºæ ¸å‡½æ•°ï¼Œå¯¹äºæ™®é€šçš„ç”Ÿæˆå‡½æ•°ï¼Œki(x)=xik_i(x)=x^ikiâ€‹(x)=xiã€‚æ³¨æ„è¿™ä¸ª aaa æ—¢å¯ä»¥æ˜¯æœ‰ç©·åºåˆ—ï¼Œä¹Ÿå¯ä»¥æ˜¯æ— ç©·åºåˆ—ã€‚ ç»„åˆå¯¹è±¡ ç»„åˆå¯¹è±¡æŒ‡è¦è®¡æ•°çš„å¯¹è±¡ï¼Œç»„åˆå¯¹è±¡ç»„æˆçš„é›†åˆå«åšç»„åˆç±»ã€‚ å°† {(a1,a2)âˆ£a1âˆˆA1,a2âˆˆA2}\\{(a_1,a_2)\\mid a_1\\in A_1,a_2\\in A_2\\}{(a1â€‹,a2â€‹)âˆ£a1â€‹âˆˆA1â€‹,a2â€‹âˆˆA2â€‹} ç§°ä¸º A1,A2A_1,A_2A1â€‹,A2â€‹ çš„ç¬›å¡å°”ç§¯ï¼Œè®°ä½œ A1Ã—A2A_1\\times A_2A1â€‹Ã—A2â€‹ã€‚ æ™®é€šç”Ÿæˆå‡½æ•°ï¼ˆOGFï¼‰ æ™®é€šç”Ÿæˆå‡½æ•°çš„æ ¸å‡½æ•°ä¸º kn(x)=xnk_n(x)=x^nknâ€‹(x)=xnã€‚å®é™…ä¸Šï¼Œæ™®é€šç”Ÿæˆå‡½æ•°çš„ç³»æ•°å°±æ˜¯åºåˆ— aaa çš„é€šé¡¹å…¬å¼ã€‚ å¯¹äº OGF F(x)F(x)F(x)ï¼Œxxx æ˜¯è‡ªç”±å…ƒï¼Œå› æ­¤æ²¡æœ‰å®é™…æ„ä¹‰ï¼Œåªæ˜¯ä¸€ä¸ªå ä½ç¬¦ï¼Œxix_ixiâ€‹ ç”¨æ¥ä»£è¡¨å®ƒæ˜¯ç¬¬ iii ä¸ªå ä½ç¬¦ï¼ŒF[i]F[i]F[i] å¯ä»¥è¡¨ç¤º F(x)F(x)F(x) çš„ç¬¬ iii æ¬¡é¡¹ç³»æ•°ï¼Œç®€ç§° iii æ¬¡é¡¹ï¼Œ000 æ¬¡é¡¹ç§°ä¸ºå¸¸æ•°é¡¹ã€‚ ä¸ºäº†æ–¹ä¾¿æå–å…¶ä¸­æŸä¸€é¡¹çš„ç³»æ•°ï¼Œæœ‰ [xi]F(x)=F[i][x^i]F(x)=F[i][xi]F(x)=F[i]ã€‚ ç”Ÿæˆå‡½æ•°ä¸­çš„æ±‚å’Œç¬¦å·å¹¶ä¸æ˜¯æ— ç©·é¡¹æ±‚å’Œï¼Œå®ƒåªæ˜¯ä¸€ä¸ªè®°å·ï¼Œä»£è¡¨çš„æ˜¯åºåˆ—ã€‚ä¸¤ä¸ªç”Ÿæˆå‡½æ•° F(x),G(x)F(x),G(x)F(x),G(x) ç›¸ç­‰å½“ä¸”ä»…å½“ âˆ€iâˆˆN,F[i]=G[i]\\forall i\\in\\mathbb{N}, F[i]=G[i]âˆ€iâˆˆN,F[i]=G[i]ã€‚ å¯¹äºåºåˆ— aaaï¼Œå¦‚æœä»æŸä¸€é¡¹å¼€å§‹å®ƒåé¢éƒ½æ˜¯ 000ï¼Œé‚£ä¹ˆå¯ä»¥è®¤ä¸ºå®ƒæ˜¯ä¸€ä¸ªæœ‰ç©·åºåˆ—ã€‚å¦‚æœå®ƒæ˜¯æœ‰ç©·çš„ï¼Œé‚£ä¹ˆå®ƒçš„ç”Ÿæˆå‡½æ•°æ˜¯ä¸€ä¸ªæœ‰ç©·å¹‚çº§æ•°ï¼Œå¦åˆ™æ˜¯æ— ç©·å¹‚çº§æ•°ã€‚ è€ƒè™‘ä¸¤ä¸ªåºåˆ— a,ba,ba,b çš„æ™®é€šç”Ÿæˆå‡½æ•°F(x),G(x)F(x),G(x)F(x),G(x)ï¼Œé‚£ä¹ˆå®ƒä»¬çš„åŠ å‡æ³•å’Œä¹˜æ³•è¿ç®—æ˜¯è·Ÿå¤šé¡¹å¼ä¸€æ ·çš„ã€‚å› æ­¤å¯¹äºç”Ÿæˆå‡½æ•° F(x),G(x)F(x),G(x)F(x),G(x)ï¼Œæœ‰ï¼š F(x)Â±G(x)=âˆ‘n(anÂ±bn)xn,F(x)G(x)=âˆ‘nxnâˆ‘i=0naibnâˆ’i=âˆ‘iâˆ‘jF[i]G[j]xijF(x)\\pm G(x)=\\sum_{n}(a_n\\pm b_n)x^n,\\\\ \\begin{aligned} F(x)G(x)&amp;=\\sum_{n}x^n\\sum_{i=0}^n a_i b_{n-i}\\\\ &amp;=\\sum_{i}\\sum_j F[i]G[j]x^{ij} \\end{aligned} F(x)Â±G(x)=nâˆ‘â€‹(anâ€‹Â±bnâ€‹)xn,F(x)G(x)â€‹=nâˆ‘â€‹xni=0âˆ‘nâ€‹aiâ€‹bnâˆ’iâ€‹=iâˆ‘â€‹jâˆ‘â€‹F[i]G[j]xijâ€‹ å› æ­¤ F(x)Â±G(x)F(x)\\pm G(x)F(x)Â±G(x) æ˜¯åºåˆ— &lt;anÂ±bn&gt;\\left&lt;a_n\\pm b_n\\right&gt;âŸ¨anâ€‹Â±bnâ€‹âŸ© çš„æ™®é€šç”Ÿæˆå‡½æ•°ï¼ŒF(x)G(x)F(x)G(x)F(x)G(x) æ˜¯ åºåˆ—&lt;âˆ‘i=0naibnâˆ’i&gt;\\left&lt;\\sum_{i=0}^n a_i b_{n-i}\\right&gt;âŸ¨âˆ‘i=0nâ€‹aiâ€‹bnâˆ’iâ€‹âŸ© çš„æ™®é€šç”Ÿæˆå‡½æ•°ã€‚ å¯ä»¥å‘ç°ï¼ŒåŠ æ³•ä»£è¡¨ä¸ç›¸äº¤é›†åˆçš„å¹¶ï¼Œä¹˜æ³•ä»£è¡¨ç¬›å¡å°”ç§¯ã€‚ å¯¹äºå¹‚æ¬¡è¿ç®—ï¼ŒF(x)F(x)F(x) çš„ nnn æ¬¡å¹‚è®°ä½œ Fn(x)F^n(x)Fn(x)ï¼Œç‰¹åˆ«åœ°ï¼ŒF0(x)=1F^0(x)=1F0(x)=1ã€‚ å¯¹ F(x)F(x)F(x) çš„ nnn æ¬¡å¹‚æå– mmm æ¬¡é¡¹ç³»æ•°ï¼Œå¯ä»¥è®° Fn[m]F^n[m]Fn[m] ä¸ºï¼š Fn[m]=[xm]Fn(x)F^n[m]=[x^m]F^n(x) Fn[m]=[xm]Fn(x) å½¢å¼å¹‚çº§æ•°çš„ç”Ÿæˆå‡½æ•°ä¸ä¸€å®šå¥½ç®—ï¼Œæœ‰æ—¶ä¼šå°†å…¶è½¬æ¢ä¸ºå°é—­å½¢å¼ã€‚ æ¯”å¦‚è¯´ &lt;1,1,â‹¯ &gt;\\left&lt;1,1,\\cdots\\right&gt;âŸ¨1,1,â‹¯âŸ© çš„æ™®é€šç”Ÿæˆå‡½æ•°ä¸º F(x)=âˆ‘nâ‰¥0xnF(x)=\\sum_{n\\ge 0}x^nF(x)=âˆ‘nâ‰¥0â€‹xnï¼Œå‘ç° F(x)x+1=F(x)F(x)x+1=F(x)F(x)x+1=F(x)ï¼Œå› æ­¤å¾—åˆ° F(x)=11âˆ’xF(x)=\\cfrac{1}{1-x}F(x)=1âˆ’x1â€‹ï¼Œè¿™å°±æ˜¯ç”Ÿæˆå‡½æ•°çš„å°é—­å½¢å¼ã€‚ æ¯”å¦‚è¯´ï¼ŒF(x)=âˆ‘n=0âˆn=11âˆ’xF(x)=\\sum_{n=0}^{\\infty} n=\\cfrac 1{1-x}F(x)=âˆ‘n=0âˆâ€‹n=1âˆ’x1â€‹ã€‚ä½œä¸ºç»ƒä¹ ï¼Œå¯ä»¥çœ‹ä¸€ä¸‹æ¥ä¸‹æ¥è¿™å‡ ä¸ªé¢˜ï¼š 010203ï¼ˆäºŒé¡¹å¼å®šç†ï¼‰04ï¼ˆå‰ç¼€å’Œä¸å·®åˆ†ï¼‰ å†™å‡º a=&lt;0,1,1,â‹¯ &gt;a=\\left&lt;0,1,1,\\cdots \\right&gt;a=âŸ¨0,1,1,â‹¯âŸ© çš„ç”Ÿæˆå‡½æ•°ã€‚ æœ‰ F(x)=âˆ‘nâ‰¥1xnF(x)=\\sum_{n\\ge 1}x^nF(x)=âˆ‘nâ‰¥1â€‹xnï¼Œå› æ­¤ F(x)x+x=F(x)â‡’F(x)=x1âˆ’xF(x)x+x=F(x)\\Rightarrow F(x)=\\cfrac{x}{1-x}F(x)x+x=F(x)â‡’F(x)=1âˆ’xxâ€‹ã€‚ å†™å‡º a=&lt;1,0,1,0,1,0â‹¯ &gt;a=\\left&lt;1,0,1,0,1,0\\cdots \\right&gt;a=âŸ¨1,0,1,0,1,0â‹¯âŸ© çš„ç”Ÿæˆå‡½æ•°ã€‚ æœ‰ F(x)=âˆ‘nâ‰¥0x2n=âˆ‘nâ‰¥0(x2)nF(x)=\\sum_{n\\ge 0} x^{2n}=\\sum_{n\\ge 0} (x^{2})^nF(x)=âˆ‘nâ‰¥0â€‹x2n=âˆ‘nâ‰¥0â€‹(x2)nï¼Œå› æ­¤ F(x)x2+1=F(x)â‡’F(x)=11âˆ’x2F(x)x^2+1=F(x)\\Rightarrow F(x) = \\cfrac{1}{1-x^2}F(x)x2+1=F(x)â‡’F(x)=1âˆ’x21â€‹ã€‚ å†™å‡ºåºåˆ— an=(mn)a_n=\\dbinom{m}{n}anâ€‹=(nmâ€‹) çš„ç”Ÿæˆå‡½æ•°ï¼ˆmmm æ˜¯å¸¸æ•°ï¼Œnâ‰¥0n\\ge 0nâ‰¥0ï¼‰ã€‚ F(x)=âˆ‘nâ‰¥0(mn)xn=(1+x)m\\begin{aligned} F(x)&amp;=\\sum_{n\\ge 0}\\binom{m}{n}x^n\\\\ &amp;=(1+x)^m \\end{aligned} F(x)â€‹=nâ‰¥0âˆ‘â€‹(nmâ€‹)xn=(1+x)mâ€‹ å†™å‡º a=&lt;1,2,3,4,5,6â‹¯ &gt;a=\\left&lt;1,2,3,4,5,6\\cdots \\right&gt;a=âŸ¨1,2,3,4,5,6â‹¯âŸ© çš„ç”Ÿæˆå‡½æ•°ã€‚ F(x)=âˆ‘nâ‰¥0nxnâˆ’1=âˆ‘nâ‰¥0(xn)â€²=(11âˆ’x)â€²=1(1âˆ’x)2\\begin{aligned} F(x)&amp;=\\sum_{n\\ge 0}nx^{n-1}\\\\ &amp;=\\sum_{n\\ge 0} (x^n)&#x27;\\\\ &amp;=\\left(\\frac{1}{1-x}\\right)&#x27;\\\\ &amp;=\\frac{1}{(1-x)^2} \\end{aligned} F(x)â€‹=nâ‰¥0âˆ‘â€‹nxnâˆ’1=nâ‰¥0âˆ‘â€‹(xn)â€²=(1âˆ’x1â€‹)â€²=(1âˆ’x)21â€‹â€‹ å¯ä»¥å‘ç°æ±‚ä¸€ä¸ªåºåˆ—çš„å‰ç¼€å’Œçš„ç”Ÿæˆå‡½æ•°åªéœ€è¦ä¹˜ä¸Š 11âˆ’x\\cfrac{1}{1-x}1âˆ’x1â€‹ï¼Œæ±‚å·®åˆ†åªéœ€è¦ä¹˜ä¸Š 1âˆ’x1-x1âˆ’xã€‚ å®é™…ä¸Šæˆ‘ä»¬æœ‰ï¼š 1(1âˆ’x)n+1=âˆ‘i(n+in)xi\\frac{1}{(1-x)^{n+1}}=\\sum_{i}\\binom{n+i}{n}x^i (1âˆ’x)n+11â€‹=iâˆ‘â€‹(nn+iâ€‹)xi ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå½“ n=1n=1n=1 æ—¶ï¼ŒåŸå¼æˆç«‹ï¼›å½“ n&gt;1n&gt;1n&gt;1 æ—¶ï¼Œæœ‰ï¼š 1(1âˆ’x)n+1=11âˆ’x1(1âˆ’x)n=âˆ‘ixiâˆ‘i(n+iâˆ’1nâˆ’1)xi=âˆ‘ixiâˆ‘j=0i(n+jâˆ’1j)=âˆ‘i(n+in)xi\\begin{aligned} \\frac{1}{(1-x)^{n+1}}&amp;=\\frac{1}{1-x}\\frac{1}{(1-x)^{n}}\\\\ &amp;=\\sum_{i}x^i\\sum_{i}\\binom{n+i-1}{n-1}x^i\\\\ &amp;=\\sum_{i}x^i\\sum_{j=0}^i\\binom{n+j-1}{j}\\\\ &amp;=\\sum_{i}\\binom{n+i}{n}x^i \\end{aligned} (1âˆ’x)n+11â€‹â€‹=1âˆ’x1â€‹(1âˆ’x)n1â€‹=iâˆ‘â€‹xiiâˆ‘â€‹(nâˆ’1n+iâˆ’1â€‹)xi=iâˆ‘â€‹xij=0âˆ‘iâ€‹(jn+jâˆ’1â€‹)=iâˆ‘â€‹(nn+iâ€‹)xiâ€‹ å®ƒè¿˜å¯ä»¥è¯´æ˜ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœ f(x)f(x)f(x) æ˜¯å…³äº xxx çš„ kkk æ¬¡å¤šé¡¹å¼ï¼Œé‚£ä¹ˆ f(x)f(x)f(x) çš„å·®åˆ†æ˜¯ kâˆ’1k-1kâˆ’1 æ¬¡å¤šé¡¹å¼ï¼Œå‰ç¼€å’Œæ˜¯ k+1k+1k+1 æ¬¡å¤šé¡¹å¼ã€‚ æ‹¯æ•‘ä¸–ç•Œã€‚å¯¹äºä¸€ç§å¬å”¤æ–¹å¼ï¼Œè®¾ ana_nanâ€‹ ä»£è¡¨è¿™ç§å¬å”¤æ–¹å¼é€‰æ‹© nnn ä¸ªçš„æ–¹æ¡ˆæ•°ï¼Œæ±‚å‡ºåºåˆ— aaa çš„ç”Ÿæˆå‡½æ•°ã€‚é‚£ä¹ˆä¸¤ç§å¬å”¤æ–¹å¼ä¸€å…±æœ‰ nnn å—çŸ³å¤´çš„é€‰æ‹©æ–¹å¼å°±æ˜¯è¿™ä¸¤ä¸ªç”Ÿæˆå‡½æ•°çš„å·ç§¯ FFF çš„ç¬¬ nnn é¡¹ç³»æ•°ã€‚ ä¸€å…±æœ‰ 101010 ä¸ªé™åˆ¶æ¡ä»¶ï¼Œä¾æ¬¡å†™å‡ºå®ƒä»¬çš„ç”Ÿæˆå‡½æ•°ï¼ˆå°é—­å½¢å¼ï¼‰ï¼Œç„¶åæŠŠå®ƒä»¬éƒ½ä¹˜èµ·æ¥ï¼ˆæ±‚çš„æ˜¯ç¬›å¡å°”ç§¯ï¼‰å¾—åˆ° 1(1âˆ’x)5\\cfrac{1}{(1-x)^5}(1âˆ’x)51â€‹ã€‚è½¬åŒ–æˆå½¢å¼å¹‚çº§æ•°å°±æ˜¯ âˆ‘i(i+44)xi\\displaystyle\\sum_{i}\\binom{i+4}{4}x^iiâˆ‘â€‹(4i+4â€‹)xiã€‚å› æ­¤ç­”æ¡ˆæ˜¯ (n+44)\\dbinom{n+4}{4}(4n+4â€‹)ã€‚ æŒ‡æ•°ç”Ÿæˆå‡½æ•°ï¼ˆEGFï¼‰ æˆ‘ä»¬é€šå¸¸ç”¨ä»¥ä¸‹æ–¹å¼è¡¨ç¤ºæŒ‡æ•°ç”Ÿæˆå‡½æ•°ï¼š F^(x)=âˆ‘i=0âˆaii!xi\\hat F(x)=\\sum_{i=0}^{\\infty} \\frac{a_i}{i!} x^i F^(x)=i=0âˆ‘âˆâ€‹i!aiâ€‹â€‹xi å°±æ˜¯å¤šé™¤äº†ä¸ª i!i!i!ã€‚ OGF åªèƒ½è§£å†³æ— åºè®¡æ•°é—®é¢˜ï¼Œå¯¹äºæœ‰åºè®¡æ•°ï¼ŒåŒä¸€ä¸ªç»„åˆç±»ä¸­çš„ä¸œè¥¿æ˜¯ä¸åŒºåˆ†çš„ï¼Œå› æ­¤é€šè¿‡é™¤æ‰ä¸€ä¸ª i!i!i! æ¥è§£å†³ã€‚æœ€åå†ä¹˜ä¸Š n!n!n! å°±æ˜¯ç¬¬ nnn é¡¹çš„ç­”æ¡ˆã€‚ ç‰¹æ®Šæ•°åˆ— æˆ‘ä»¬ä»‹ç»ä¸€äº›ç‰¹æ®Šæ•°åˆ—ã€‚ æ–æ³¢é‚£å¥‘æ•°åˆ— æˆ‘ä»¬æœ‰ f0=1,f1=1,fi=fiâˆ’1+fiâˆ’2f_0=1,f_1=1,f_i=f_{i-1}+f_{i-2}f0â€‹=1,f1â€‹=1,fiâ€‹=fiâˆ’1â€‹+fiâˆ’2â€‹ã€‚è®¾å®ƒçš„ OGF æ˜¯ F(x)F(x)F(x)ï¼Œé‚£ä¹ˆï¼š F(x)=xF(x)+x2F(x)+x+0 âŸº F(x)=x1âˆ’xâˆ’x2\\begin{aligned} &amp; F(x)=xF(x)+x^2F(x)+x+0\\\\ \\iff &amp; F(x)=\\frac {x}{1-x-x^2} \\end{aligned} âŸºâ€‹F(x)=xF(x)+x2F(x)+x+0F(x)=1âˆ’xâˆ’x2xâ€‹â€‹ æ±‚å‡ºå®ƒçš„å°é—­å½¢å¼ï¼Œå¯ä»¥é‡‡ç”¨å¾…å®šç³»æ•°æ³•ï¼Œè¿›è€ŒåŒ–ä¸ºï¼š F(n)=âˆ‘n=0âˆ(1+52)nâˆ’(1âˆ’52)n5xnF(n) = \\sum_{n=0}^{\\infty}\\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}} x^n F(n)=n=0âˆ‘âˆâ€‹5â€‹(21+5â€‹â€‹)nâˆ’(21âˆ’5â€‹â€‹)nâ€‹xn æ•´æ•° lqp æ‹†åˆ†ã€‚ç­”æ¡ˆæ˜¯ 0âˆ¼i0\\sim i0âˆ¼i ä¸ª FFF çš„å‰ç¼€å’Œï¼Œé‚£ä¹ˆç­”æ¡ˆçš„ç”Ÿæˆå‡½æ•°ä¸º G(x)=âˆ‘i=0âˆFi(x)\\displaystyle G(x)=\\sum_{i=0}^{\\infty}F^i(x)G(x)=i=0âˆ‘âˆâ€‹Fi(x)ã€‚ ä¹Ÿå°±æ˜¯ï¼š G(x)=11âˆ’F(x)=1âˆ’xâˆ’x21âˆ’2xâˆ’x2=âˆ‘x122[(1+2)xâˆ’(1âˆ’2)x]\\begin{aligned} G(x)&amp;=\\frac 1 {1 - F(x)}\\\\ &amp;= \\frac {1-x-x^2}{1-2x - x^2}\\\\ &amp;= \\sum_x \\frac{1}{2\\sqrt{2}}[(1+\\sqrt 2)^x-(1-\\sqrt 2 )^x] \\end{aligned} G(x)â€‹=1âˆ’F(x)1â€‹=1âˆ’2xâˆ’x21âˆ’xâˆ’x2â€‹=xâˆ‘â€‹22â€‹1â€‹[(1+2â€‹)xâˆ’(1âˆ’2â€‹)x]â€‹ ç›´æ¥è®¡ç®—å³å¯ï¼Œä»£ç ã€‚ å¡ç‰¹å…°æ•° ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•° ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ä½¿ç”¨ {nk}\\begin{Bmatrix}n\\\\ k\\end{Bmatrix}{nkâ€‹} æˆ–è€… S2(n,k)S_2(n,k)S2â€‹(n,k) æ¥è¡¨ç¤ºï¼Œæ„ä¹‰æ˜¯å°† 1âˆ¼n1\\sim n1âˆ¼n çš„æ•´æ•°åˆ’åˆ†ä¸º kkk ä¸ªä¸äº¤çš„æ— æ ‡å·éç©ºé›†åˆçš„æ–¹æ¡ˆæ•°ã€‚æ˜¾ç„¶ {n0}=[n=0]\\begin{Bmatrix}n\\\\ 0\\end{Bmatrix}=[n=0]{n0â€‹}=[n=0]ã€‚å¯ä»¥é‡‡ç”¨æš´åŠ›é€’æ¨æ³•æ±‚è§£ï¼š {nk}={nâˆ’1kâˆ’1}+k{nâˆ’1k}\\begin{Bmatrix}n\\\\ k\\end{Bmatrix}=\\begin{Bmatrix}n-1\\\\ k-1\\end{Bmatrix}+k\\begin{Bmatrix}n-1\\\\ k\\end{Bmatrix} {nkâ€‹}={nâˆ’1kâˆ’1â€‹}+k{nâˆ’1kâ€‹} ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿå°†ç¬¬ nnn ä¸ªå…ƒç´ æ”¾å…¥ä¸€ä¸ªæ–°çš„é›†åˆæœ‰ {nâˆ’1kâˆ’1}\\begin{Bmatrix}n-1\\\\ k-1\\end{Bmatrix}{nâˆ’1kâˆ’1â€‹} ç§æ–¹æ¡ˆï¼Œå°†ç¬¬ nnn ä¸ªå…ƒç´ æ’å…¥åŸæ¥ä»»æ„ä¸€ä¸ªé›†åˆæœ‰ k{nâˆ’1k}k\\begin{Bmatrix}n-1\\\\ k\\end{Bmatrix}k{nâˆ’1kâ€‹} çš„æ–¹æ¡ˆï¼Œæ ¹æ®åŠ æ³•åŸç†å¯å¾—é€’æ¨å¼ã€‚ å¯èƒ½éœ€è¦è®°ä½ä¸€äº›ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ï¼ˆå°±æ¯”å¦‚è¯´ï¼Œä¸€ä¸ªå‡ºç° 1,7,6,11,7,6,11,7,6,1 çš„é—®é¢˜å°±å¾ˆå¤§èƒ½ä¸ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°æœ‰å…³ï¼‰ï¼š 1 1 1 1 3 1 1 7 6 1 1 15 25 10 1 1 31 90 65 15 1 1 63 301 350 140 21 1 1 127 966 1701 1050 266 28 1 1 255 3025 7770 6951 2646 462 36 1 1 511 9330 34105 42525 22827 5880 750 45 1 ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°çš„é€šé¡¹å…¬å¼ï¼š {nm}=âˆ‘i=0m(âˆ’1)mâˆ’iini!(mâˆ’i)!\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\sum\\limits_{i=0}^m\\frac{(-1)^{m-i}i^n}{i!(m-i)!} {nmâ€‹}=i=0âˆ‘mâ€‹i!(mâˆ’i)!(âˆ’1)mâˆ’iinâ€‹ ä¸éš¾ç”¨äºŒé¡¹å¼åæ¼”å»è¯æ˜ï¼Œä»¤ GiG_iGiâ€‹ ä¸º nnn ä¸ªæ•°æ”¾å…¥ iii ä¸ªå…è®¸ç©ºé›†çš„æœ‰æ ‡å·é›†åˆï¼ŒFiF_iFiâ€‹ ä¸ºä¸å…è®¸ç©ºé›†ï¼ŒFmm!\\frac{F_m}{m!}m!Fmâ€‹â€‹ å³ä¸ºç­”æ¡ˆã€‚ ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•° ç§°ä¹‹ä¸ºæ–¯ç‰¹æ—è½®æ¢æ•°ï¼Œè®°ä½œ [nk],S1(n,k)\\begin{bmatrix}n\\\\ k\\end{bmatrix},S_1(n,k)[nkâ€‹],S1â€‹(n,k)ï¼Œè¡¨ç¤ºå°† 1âˆ¼n1\\sim n1âˆ¼n çš„æ•´æ•°åˆ’åˆ†ä¸º kkk ä¸ªäº’ä¸åŒºåˆ†çš„éç©ºè½®æ¢æ–¹æ¡ˆæ•°ã€‚ ä¸€ä¸ªè½®æ¢æ˜¯æŒ‡ä¸€ä¸ªé¦–å°¾ç›¸æ¥çš„ç¯å½¢æ’åˆ—ï¼Œä¸¤ä¸ªå¯ä»¥é€šè¿‡æ—‹è½¬è€Œäº’ç›¸å¾—åˆ°çš„è½®æ¢æ˜¯ç­‰ä»·çš„ã€‚ ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•°çš„é€’æ¨å¼ï¼š [nk]=[nâˆ’1kâˆ’1]+(nâˆ’1)[nâˆ’1k]\\begin{bmatrix}n\\\\ k\\end{bmatrix}=\\begin{bmatrix}n-1\\\\ k-1\\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\\\ k\\end{bmatrix} [nkâ€‹]=[nâˆ’1kâˆ’1â€‹]+(nâˆ’1)[nâˆ’1kâ€‹] å‰è€…æ˜¯å°† nnn æ”¾åœ¨ä¸€ä¸ªå•ç‹¬çš„è½®æ¢ä¸­ï¼Œåè€…æ˜¯å°†å…¶æ”¾å…¥ä¸€ä¸ªç°æœ‰çš„è½®æ¢ä¸­ã€‚ è¿™ä¸ªç©æ„æ²¡æœ‰å®ç”¨çš„é€šé¡¹å…¬å¼ã€‚ é¢˜è½¦ åˆ·åŸºç¡€ 1 ä¸€äº›åŸºç¡€é¢˜ã€‚ [CF715E] Complete the Permutations Portal. è¾¹å¯ä»¥åˆ†ä¸ºå››ç§ç±»å‹ï¼Œaâ†’b,aâ†’0,0â†’b,0â†’0a\\rightarrow b,a\\rightarrow 0,0\\rightarrow b,0\\rightarrow 0aâ†’b,aâ†’0,0â†’b,0â†’0ã€‚ è®°åä¸‰ç§è¾¹çš„æ•°é‡ä¸º n1,n2,mn_1,n_2,mn1â€‹,n2â€‹,mã€‚aâ†’0a\\rightarrow 0aâ†’0 è¾¹æœ‰ä¸¤ç§é€‰æ‹©ï¼Œèè¿› 0â†’00\\rightarrow 00â†’0ï¼Œæˆ–è€…è‡ªæˆ‘åˆå¹¶ã€‚æ–¹æ¡ˆæ•°æ˜¯ï¼š F1[k]=âˆ‘i=kn1(n1i)[ik](n1+mâˆ’iâˆ’1)n1âˆ’iâ€¾F_1[k]=\\sum\\limits_{i=k}^{n_1}\\dbinom{n_1}{i}\\begin{bmatrix}i\\\\k\\end{bmatrix}(n_1+m-i-1)^{\\underline{n_1-i}} F1â€‹[k]=i=kâˆ‘n1â€‹â€‹(in1â€‹â€‹)[ikâ€‹](n1â€‹+mâˆ’iâˆ’1)n1â€‹âˆ’iâ€‹ F3F_3F3â€‹ ç›´æ¥ç®—ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•°ï¼Œç„¶åå¯ä»¥å…¨æ’åˆ— mmmã€‚æš´åŠ›å·å³å¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"NOI ä¸€è½®å¤ä¹  VIï¼šå­—ç¬¦ä¸²","slug":"notes/NOI å¤ä¹ /noi-1-6","date":"2023-12-17T00:00:00.000Z","updated":"2024-01-08T00:00:00.000Z","comments":true,"path":"b3047747/","link":"","permalink":"https://james1badcreeper.github.io/b3047747/","excerpt":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬å…­ç¯‡ï¼ŒåŒ…æ‹¬å„ç±»å­—ç¬¦ä¸²ç®—æ³•ã€‚","text":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬å…­ç¯‡ï¼ŒåŒ…æ‹¬å„ç±»å­—ç¬¦ä¸²ç®—æ³•ã€‚ å‰ç½®çŸ¥è¯† æˆ‘ä»¬è®°å­—ç¬¦é›†ä¸º Î£\\SigmaÎ£ï¼Œå­—ç¬¦ä¸²æ˜¯ç”±è‹¥å¹²å­—ç¬¦é›†ä¸­çš„å…ƒç´ æ„æˆçš„åºåˆ—ã€‚ å­—ç¬¦ä¸²å“ˆå¸Œ å³åºåˆ—å“ˆå¸Œï¼Œå¿«é€Ÿæ¯”è¾ƒä¸¤ä¸ªåºåˆ—çš„ç›¸ç­‰æƒ…å†µã€‚ä¸€èˆ¬æ¥è®²æˆ‘ä»¬é‡‡ç”¨ bbb è¿›åˆ¶æ–¹å¼çš„å“ˆå¸Œï¼Œå³ f(s)=âˆ‘i=1lsiÃ—blâˆ’if(s)=\\sum_{i=1}^{l}s_i\\times b^{l-i}f(s)=âˆ‘i=1lâ€‹siâ€‹Ã—blâˆ’iã€‚ inline u64 q(u64 *f, int l, int r) &#123; return f[r] - f[l - 1] * p[r - l + 1]; &#125; å­—å…¸æ ‘ æœ¬è´¨ä¸Šæ˜¯ä¸€ç§è‡ªåŠ¨æœºç»“æ„ï¼Œä¸å†èµ˜è¿°ã€‚ å­—ç¬¦ä¸²å‘¨æœŸç»“æ„ å®šä¹‰ ppp æ˜¯ä¸² SSS çš„å‘¨æœŸï¼Œå½“ä¸”ä»…å½“ pâ‰¤âˆ£Sâˆ£p\\le |S|pâ‰¤âˆ£Sâˆ£ ä¸” Si=Si+pS_i=S_{i+p}Siâ€‹=Si+pâ€‹ï¼Œå¦‚æœæ»¡è¶³ pâˆ£âˆ£Sâˆ£p\\mid |S|pâˆ£âˆ£Sâˆ£ åˆ™ç§° ppp æ˜¯ SSS çš„æ•´å‘¨æœŸã€‚ ç§° TTT æ˜¯ä¸² SSS çš„ Borderï¼Œå½“ä¸”ä»…å½“ TTT æ˜¯ SSS çš„å‰ç¼€ä¸” TTT æ˜¯ SSS çš„åç¼€ï¼Œä½†æ˜¯ Tâ‰ ST\\ne STî€ =Sã€‚ KMP ç®—æ³• å•ä¸² Border ç»“æ„ ç»“è®ºï¼šppp æ˜¯ SSS çš„å‘¨æœŸï¼Œå½“ä¸”ä»…å½“ âˆ£Sâˆ£âˆ’p|S|-pâˆ£Sâˆ£âˆ’p æ˜¯ SSS çš„ Borderã€‚ å‘¨æœŸå¼•ç†ï¼šè‹¥ p,qp,qp,q æ˜¯ SSS çš„å‘¨æœŸï¼Œä¸” p+qâˆ’gcdâ¡(p,q)â‰¤âˆ£Sâˆ£p+q-\\gcd(p,q)\\le |S|p+qâˆ’gcd(p,q)â‰¤âˆ£Sâˆ£ï¼Œé‚£ä¹ˆ gcdâ¡(p,q)\\gcd(p,q)gcd(p,q) ä¹Ÿæ˜¯ SSS çš„å‘¨æœŸã€‚ å‰ç¼€ Border ç»“æ„ Aho-Corasick è‡ªåŠ¨æœº ä¾‹é¢˜ å­—ç¬¦ä¸²å›æ–‡ç»“æ„ Manacher å›æ–‡è‡ªåŠ¨æœº ä¾‹é¢˜ å­—ç¬¦ä¸²å­ä¸²ç»“æ„ é€šå¸¸æ¥è¯´ï¼Œåˆ»ç”» SSS çš„å­ä¸²ç»“æ„çš„æ–¹å¼æœ‰ï¼šåç¼€æ•°ç»„ã€åç¼€è‡ªåŠ¨æœºã€åç¼€æ ‘ã€‚ ç¥é£æ•¢æ­»é˜Ÿç‚¸æ¯äº†æ­¤å¤„çš„å†…å®¹ã€‚æœ¬éƒ¨åˆ†å°†åœ¨ NOI2024 å‰è¿›è¡Œå®Œå–„ã€‚ åç¼€æ•°ç»„ SA ä¾‹é¢˜ åç¼€è‡ªåŠ¨æœº SAM æ˜¯ä¸€ä¸ªæ¥å—å­—ç¬¦ä¸² SSS çš„æ‰€æœ‰åç¼€çš„æœ€å° DFAã€‚å…¶æ»¡è¶³ä» TTT åˆ°ä»»æ„çŠ¶æ€çš„è·¯å¾„ä¸ sss çš„æ‰€æœ‰å­ä¸²ä¸€ä¸€å¯¹åº”ï¼ŒTTT åˆ°ç»ˆæ­¢çŠ¶æ€é›†åˆ FFF çš„è·¯å¾„ä¸ sss çš„åç¼€ä¸€ä¸€å¯¹åº”ã€‚SAM çš„æœ‰å‘æ— ç¯è½¬ç§»å›¾ç§°ä¸º DAWGã€‚ ä¸‹å›¾çš„å·¦ä¾§æ˜¯ abcbc çš„ä¸€ä¸ª SAMï¼š æˆ‘ä»¬å…ˆç»™å‡ºä¸€äº›å®šä¹‰ï¼š endposâ¡(t)\\operatorname{endpos}(t)endpos(t) ä»£è¡¨ sss ä¸­æ‰€æœ‰ ttt å‡ºç°çš„ç»“æŸä½ç½®çš„é›†åˆã€‚ å¼•ç† 111ï¼šå­—ç¬¦ä¸² sss çš„ä¸¤ä¸ªéç©ºå­ä¸² uuu å’Œ w(âˆ£uâˆ£â‰¤âˆ£wâˆ£)w(|u|\\le |w|)w(âˆ£uâˆ£â‰¤âˆ£wâˆ£) çš„ endposâ¡\\operatorname{endpos}endpos ç›¸åŒï¼Œå½“ä¸”ä»…å½“ uuu åœ¨ sss ä¸­çš„æ¯æ¬¡å‡ºç°éƒ½æ˜¯ä»¥ www çš„åç¼€å½¢å¼å‡ºç°çš„ã€‚æ¯”è¾ƒæ˜¾ç„¶ã€‚å¼•ç† 222ï¼šå¦‚æœ uuu æ˜¯ www çš„åç¼€ï¼Œé‚£ä¹ˆ endposâ¡(w)âŠ†endposâ¡(u)\\operatorname{endpos}(w)\\subseteq \\operatorname{endpos}(u)endpos(w)âŠ†endpos(u)ï¼Œå¦åˆ™ endposâ¡(w)âˆ©endposâ¡(u)=âˆ…\\operatorname{endpos}(w)\\cap\\operatorname{endpos}(u)=\\varnothingendpos(w)âˆ©endpos(u)=âˆ…ã€‚ä¹Ÿæ¯”è¾ƒæ˜¾ç„¶ã€‚ å¦‚æœ endposâ¡\\operatorname{endpos}endpos é›†åˆç›¸ç­‰ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå­ä¸²å¯ä»¥è¢«æˆä¸ºç­‰ä»·ç±»ã€‚SAM ä¸­çš„æ¯ä¸ªçŠ¶æ€å¯¹åº”ä¸€ä¸ªç­‰ä»·ç±»ã€‚ å¼•ç† 333ï¼šå¯¹äºä¸€ä¸ª pppï¼Œå…¶å¯¹åº”çš„å­ä¸²é›†åˆä¸­ï¼Œè¾ƒçŸ­è€…ä¸€å®šæ˜¯è¾ƒé•¿è€…çš„åç¼€ã€‚ä¹Ÿæ¯”è¾ƒæ˜¾ç„¶ã€‚ substrâ¡(p)\\operatorname{substr}(p)substr(p) ä»£è¡¨çŠ¶æ€ ppp å¯ä»¥ä»£è¡¨çš„æ‰€æœ‰å­ä¸²é›†åˆï¼Œ longestâ¡(p)\\operatorname{longest}(p)longest(p) ä»£è¡¨çŠ¶æ€ ppp æ‰€å¯¹åº”çš„æœ€é•¿å­ä¸²ï¼› shortestâ¡(p)\\operatorname{shortest}(p)shortest(p) ä»£è¡¨çŠ¶æ€ ppp æ‰€å¯¹åº”çš„æœ€çŸ­å­ä¸²ï¼› lenâ¡(p)=âˆ£longestâ¡(p)âˆ£\\operatorname{len}(p)=|\\operatorname{longest}(p)|len(p)=âˆ£longest(p)âˆ£ã€‚ å®šä¹‰çŠ¶æ€ ppp çš„åç»§çŠ¶æ€ linkâ¡(p)\\operatorname{link}(p)link(p) æŒ‡å‘ longestâ¡(p)\\operatorname{longest}(p)longest(p) æœ€é•¿çš„ä¸€ä¸ªåç¼€ wwwï¼Œæ»¡è¶³ wâˆˆÌ¸substrâ¡(p)w\\not\\in \\operatorname{substr}(p)wî€ âˆˆsubstr(p)ã€‚æ‰€æœ‰çš„åç¼€é“¾æ¥å½¢æˆä¸€æ£µä»¥ TTT ä¸ºæ ¹çš„æœ‰æ ¹æ ‘ï¼Œå¦å¤–æœ‰ âˆ£shortestâ¡(p)âˆ£=lenâ¡(linkâ¡(p))+1|\\operatorname{shortest}(p)|=\\operatorname{len}(\\operatorname{link}(p))+1âˆ£shortest(p)âˆ£=len(link(p))+1ã€‚ ä¹‹å‰ç»™å‡ºçš„å›¾çš„å³ä¾§æ˜¯ä¸€æ£µåç¼€é“¾æ¥æ„æˆçš„æ ‘ã€‚å¯ä»¥å‘ç°ï¼Œå¦‚æœæŒ‰ç…§ endposâ¡\\operatorname{endpos}endpos é›†åˆæ„é€ æ ‘ï¼Œé‚£ä¹ˆæ„é€ å‡ºæ¥çš„æ ‘æ˜¯ç›¸åŒçš„ã€‚ æ¨¡æ¿ï¼Œæ±‚å‡º endpos å¤§å°å’Œ len å³å¯ï¼Œæ„å»º SAM çš„ä»£ç å¦‚ä¸‹ï¼š #define cpy(x, y, s) memcpy(x, y, sizeof(x[0]) * (s)) int cnt = 1, las = 1, son[N][S], len[N], fa[N]; void ins(char s) &#123; int it = s - 'a', cur = ++cnt, p = las; len[cur] = len[p] + 1; las = cur; while (!son[p][it]) son[p][it] = cur, p = fa[p]; if (!p) return fa[cur] = 1, void(); int q = son[p][it]; if (len[q] == len[p] + 1) return fa[cur] = q, void(); int cl = ++cnt; cpy(son[cl], son[q], S); len[cl] = len[p] + 1, fa[cl] = fa[q], fa[q] = fa[cur] = cl; while (son[p][it] == q) son[p][it] = cl, p = fa[p]; &#125; åç¼€æ ‘ å¹¿ä¹‰ SAM SAM ä¾‹é¢˜ ä½¿ç”¨ SAM è§£å†³æ›´ä¸ºæ–¹ä¾¿ã€‚ [SDOI2016] ç”Ÿæˆé­”å’’ Portal. SAM ä¸Šæ–°å¢ä¸€ä¸ªçŠ¶æ€ç­”æ¡ˆä¼šå¢åŠ  lenâ¡âˆ’(minlenâ¡âˆ’1)=lenâ¡âˆ’falenâ¡\\operatorname{len}-(\\operatorname{minlen}-1)=\\operatorname{len}-\\operatorname{falen}lenâˆ’(minlenâˆ’1)=lenâˆ’falenï¼Œå¼€ä¸ª map è·‘ SAM å³å¯ã€‚ä»£ç ã€‚ [CF235C] Cyclical Quest Portal. å°†å­—ç¬¦ä¸²ç ´ç¯æˆé“¾ï¼Œåœ¨ SAM ä¸Šè·‘å­—ç¬¦ä¸²åŒ¹é…ï¼Œå¤±é…äº†å°±è·³ linkâ¡\\operatorname{link}link å³å¯ï¼Œä»£ç ã€‚ æ‚æŠ€ å¯¹ç§°å‹ç¼© SAM æ— ç›¸å¹½é—­è’™è”½äº†ä½ çš„åŒçœ¼ã€‚æœ¬éƒ¨åˆ†å°†ä¸ä¼šåœ¨ NOI2024 å‰æ›´æ–°ã€‚ Lyndon ç†è®º é¢˜è½¦","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"è€ƒè¯•æ€»ç»“","slug":"default/è®°å½•/test","date":"2023-12-14T00:00:00.000Z","updated":"2023-12-23T00:00:00.000Z","comments":true,"path":"eb162b3e/","link":"","permalink":"https://james1badcreeper.github.io/eb162b3e/","excerpt":"æ²¡å†™è¿‡è¿™ä¸ªä¸œè¥¿ï¼Œæ‰€ä»¥äººèœï¼ï¼","text":"æ²¡å†™è¿‡è¿™ä¸ªä¸œè¥¿ï¼Œæ‰€ä»¥äººèœï¼ï¼ 2023 12/14 æ¨¡æ‹Ÿèµ›ï¼šæ²¡ç¡é†’ï¼Œä»€ä¹ˆéƒ½ä¸ä¼šã€‚å…³é”®é—®é¢˜æ˜¯æ°´å¹³ä¸å¤Ÿï¼ŒæˆåŠŸå€’æ•°ã€‚ 12/15 æ¨¡æ‹Ÿèµ›ï¼šä¸ä¼šæ•°æ•°ï¼Œä¸ä¼šå°å­¦æ¸¸æˆã€‚é‰´å®šä¸ºæ•°å­¦ A åšå°‘äº†å¯¼è‡´çš„ã€‚ 12/16 ABCï¼šä¸ä¼š Fï¼Œæ²¡çœ‹ Gï¼ŒG åšè¿‡åŸé¢˜ã€‚ 12/16 Div2ï¼šD åªä¼šå¡ä¸è¿‡å»çš„å• logâ¡\\loglogï¼Œæœ‰ç‚¹æç¬‘ã€‚ 12/22 æ¨¡æ‹Ÿèµ›ï¼šæ²¡æœ‰æ™ºæ…§ï¼Œæ‚é¢˜è¿˜æ˜¯éœ€è¦åšã€‚ 12/23 ABCï¼šä¸ä¼š Fã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"æ¯”èµ›è®°å½•","slug":"ç®—æ³•ç«èµ›/æ¯”èµ›è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"2023/12/11(#8)ï¼šæ—­æ—¥å†èµ·","slug":"default/è®°å½•/2023/12/2023-12-11","date":"2023-12-11T00:00:00.000Z","updated":"2023-12-11T00:00:00.000Z","comments":true,"path":"59083b9d/","link":"","permalink":"https://james1badcreeper.github.io/59083b9d/","excerpt":"We, wonâ€™t go down. Never.","text":"We, wonâ€™t go down. Never. Rising Sun. [ARC070D] HonestOrUnkind Portal. æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ä¸ªå…¨åœºèº«ä»½æœ€é«˜çš„ç©å®¶æ¥å¸¦ç»™æˆ‘ä»¬ç­”æ¡ˆã€‚å¦‚æœåäººæ¯”å¥½äººå¤šï¼Œé‚£ä¹ˆå¥½äººæ— æ³•æˆä¸ºå…¨åœºèº«ä»½æœ€é«˜çš„ç©å®¶ï¼Œå°±å®Œè›‹äº†ã€‚ æ³¨æ„åˆ°åäººä¸€å®šä¼šè¯´å¥½äººæ˜¯åäººï¼Œåäººæ˜¯å¥½äººã€‚é‚£ä¹ˆç›´æ¥ç»´æŠ¤ä¸€ä¸ªæ ˆï¼Œè®¤ä¸ºæœ€ä¸Šé¢çš„é‚£ä¸ªæ˜¯å¥½äººï¼Œè¿™æ ·é‚£ä¸ªå¥½äººä¸€å®šä¼šç•™åˆ°æœ€åã€‚ä»£ç ã€‚ è¿™ä¹ˆæ‘†ï¼Ÿï¼Ÿï¼Ÿï¼Ÿ","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/08(#7)ï¼šæµè½¬åœ¨èº«è¾¹çš„å¹¸è¿","slug":"default/è®°å½•/2023/12/2023-12-08","date":"2023-12-08T00:00:00.000Z","updated":"2023-12-08T00:00:00.000Z","comments":true,"path":"6826c041/","link":"","permalink":"https://james1badcreeper.github.io/6826c041/","excerpt":"ï¼Œå¯åŠ¨ï¼ï¼","text":"ï¼Œå¯åŠ¨ï¼ï¼ ã©ã“ã¾ã§ã‚‚ä¸€åˆ‡å°†ç”Ÿç”Ÿä¸æ¯ä»Šæ—¥ã‚‚ã©ã“ã‹ã§ã‚ãªãŸãŒä¹Ÿä¸çŸ¥é“ä»Šå¤©çš„ä½ åœ¨ä½•å¤„ä»Šã‚’ç”Ÿãã‚‹ã‚ãªãŸãŒãŸã æ­¤åˆ»çš„ä½ èº«è¾¹æ˜¯è°çš„å¿ƒæ„¿å°ã•ãªå¹¸ã›ã‚’æµè½¬åœ¨èº«è¾¹çš„å°å¹¸è¿è¦‹ã¤ã‘ã‚‰ã‚Œã¾ã™ã‚ˆã†ã«ç¥æ„¿ä½ éƒ½èƒ½ä¸€ä¸€æ‰¾å¯»åˆ° éšä¾¿å†™ä¸€ç‚¹ã€‚ [CF547D] Mike and Fish Portal. å¯¹äºæ¯ä¸ªç‚¹ï¼Œå°†æ¨ªçºµåæ ‡ä¹‹é—´è¿ä¸€æ¡è¾¹ã€‚é‚£ä¹ˆè½¬åŒ–ä¸ºå¯¹æ¯æ¡è¾¹å®šå‘ä½¿å¾—æ¯ä¸ªç‚¹çš„å…¥åº¦å’Œå‡ºåº¦æœ€å¤šç›¸å·® 111ã€‚æ‰€æœ‰å¥‡æ•°ç‚¹å¯ä»¥å‘ 000 è¿è¾¹ï¼Œæ¬§æ‹‰å›è·¯æŸ“è‰²å³å¯ï¼ˆå› ä¸ºåªæœ‰å¶ç¯ï¼‰ã€‚ [ARC104D] Multiset Mean Portal. è€ƒè™‘ä¸€ä¸ªè½¬åŒ–ï¼šå°†æ‰€æœ‰æ•°å‡å» xxxã€‚ç„¶ååˆ©ç”¨èƒŒåŒ…é¢„å¤„ç†ï¼Œç­”æ¡ˆä¾¿å¯ä»¥ç›´æ¥æ±‚å‡ºã€‚ [Ynoi2078]ã€ŠA Path Towards Autonomous Machine Intelligenceã€‹é˜…è¯»æŠ¥å‘Šï¼ˆæ›´æ–°ä¸­â€¦ï¼‰ Portal. ç»´æŠ¤ä¸€æ£µé•¿åº¦ä¸º qqq çš„çº¿æ®µæ ‘ï¼Œç„¶åæ¯ä¸ªèŠ‚ç‚¹å¼€ä¸€ä¸ª vector ä»£è¡¨è¿ç»­æ®µä¸Šçš„æ•°çš„æ“ä½œè¿ç®—ç¬¦ï¼Œä¿®æ”¹æ—¶ç›´æ¥å°†äºŒè¿›åˆ¶åˆ†ç»„ç»“æ„æ‰”åˆ°çº¿æ®µæ ‘ä¸Šç„¶ååˆå¹¶ï¼ŒæŸ¥è¯¢æ—¶æ¯ä¸ªèŠ‚ç‚¹äºŒåˆ†ä¸€æ¬¡å³å¯ã€‚ [ARC104F] Visibility Sequence Portal. è€ƒè™‘ä»¤ fi,j,kf_{i,j,k}fi,j,kâ€‹ ä»£è¡¨åŒºé—´ [l,r][l,r][l,r] å†…é«˜åº¦éƒ½ä¸è¶…è¿‡ kkk çš„ç­”æ¡ˆï¼Œè€Œ kkk å¯ä»¥è¡¨ç¤ºä¸º apâˆ’va_p-vapâ€‹âˆ’vï¼Œç„¶åæšä¸¾æœ€å€¼ç‚¹ï¼Œç›´æ¥è®°å¿†åŒ–æœç´¢å°±è¡Œã€‚ ED æœ‰äº›ä¸œè¥¿è¿˜æ˜¯è¦å­¦ä¹ çš„ã€‚ æˆ‘æ€ä¹ˆè¿™ä¹ˆæ‘†ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/07(#6)ï¼šæ—¶é—´å‡èšä¸ºæ°¸æ’","slug":"default/è®°å½•/2023/12/2023-12-07","date":"2023-12-07T00:00:00.000Z","updated":"2023-12-07T00:00:00.000Z","comments":true,"path":"dffcb9b5/","link":"","permalink":"https://james1badcreeper.github.io/dffcb9b5/","excerpt":"æœ‰æ›´é‡è¦çš„äº‹æƒ…ï¼Œä»Šå¤©å…ˆéšä¾¿å†™å‡ ä¸ªé¢˜ã€‚","text":"æœ‰æ›´é‡è¦çš„äº‹æƒ…ï¼Œä»Šå¤©å…ˆéšä¾¿å†™å‡ ä¸ªé¢˜ã€‚ ä¸ç”¨è·‹æ¶‰åˆ°å¤©æ¶¯ æˆ‘ä»¬ä¸ºä½ æ¥å›ç­” ä¹Ÿè®¸ç­”æ¡ˆä¼šè®©ä½ æ„Ÿåˆ°æƒŠè®¶! é¥çœ‹ç»šä¸½çš„æœéœ å›å¿†ä»å‰çš„ä¼¤ç–¤ ä¹Ÿè®¸ç­”æ¡ˆå°±è—åœ¨ä½ çš„è„šä¸‹ï¼ [APC001F] XOR Tree Portal. è€ƒè™‘å°†è¾¹æƒè½¬åŒ–ä¸ºç‚¹æƒï¼Œå¯ä»¥å°†ä¸€ä¸ªç‚¹å‘¨å›´çš„è¾¹çš„è¾¹æƒéƒ½å¼‚æˆ–åœ¨ç‚¹ä¸Šã€‚å½“æ‰€æœ‰ç‚¹çš„ç‚¹æƒå’Œä¸º 000 æ—¶ç­”æ¡ˆä¾¿æ»¡è¶³ï¼Œç›´æ¥çŠ¶å‹ DP å³å¯ã€‚ä»£ç ã€‚ [AT_code_festival_2017_qualb_f] Largest Smallest Cyclic Shift Portal. è®¾ S1,â‹¯ ,SnS_1,\\cdots,S_nS1â€‹,â‹¯,Snâ€‹ ç»„æˆ TTTï¼Œæ»¡è¶³ S1&lt;S2&lt;â‹¯&lt;SnS_1&lt;S_2&lt;\\cdots&lt;S_nS1â€‹&lt;S2â€‹&lt;â‹¯&lt;Snâ€‹ï¼Œå‘ç°åº”è¯¥æ˜¯å°†æœ€å°çš„å­—å…¸åºå­—ç¬¦ä¸²å’Œæœ€å¤§çš„å­—å…¸åºå­—ç¬¦ä¸²æ‹¼èµ·æ¥å¾—åˆ°ä¸€ä¸ªæ›´ä¼˜ç§€çš„å­—ç¬¦ä¸²ã€‚ [CF1188D] Make Equal Portal. è®° bi=maxâ¡aâˆ’aib_i=\\max a - a_ibiâ€‹=maxaâˆ’aiâ€‹ï¼Œé‚£ä¹ˆè¦æ±‚ï¼š âˆ‘i=1npopcountâ¡(x+bi)\\sum_{i=1}^n \\operatorname{popcount}(x+b_i) i=1âˆ‘nâ€‹popcount(x+biâ€‹) è€ƒè™‘äºŒè¿›åˆ¶ä¸‹çš„ç¬¬ kkk ä½ï¼š xxx çš„ç¬¬ kkk ä½æ˜¯å¦å¡« 111ï¼› bib_ibiâ€‹ çš„ç¬¬ kkk ä½æ˜¯å¦å¡« 111; ç¬¬ kâˆ’1k-1kâˆ’1 ä½æ˜¯å¦è¿›ä½ã€‚ ç¬¬ kâˆ’1k-1kâˆ’1 ä½çš„è¿›ä½æƒ…å†µå’Œ bi mod 2kb_i\\bmod 2^kbiâ€‹mod2k æœ‰å…³ã€‚æˆ‘ä»¬æŒ‰ç…§è¿™ä¸ªä¸œè¥¿æ’åºï¼Œèƒ½è¿›ä½çš„å°±æ˜¯ bbb çš„ä¸€æ®µå‰ç¼€ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨æœ‰ jjj ä¸ªæ•°è¿›ä½åˆ°ç¬¬ iii ä½çš„ç­”æ¡ˆã€‚è€ƒè™‘ xxx å½“å‰è¿™ä¸€ä½å¡« 111 è¿˜æ˜¯å¡« 000ï¼Œè´¡çŒ®éšä¾¿ç®—ä¸€ä¸‹å°±è¡Œäº†ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/06(#5)ï¼šæ”¶é›†ç€ç ´ç¢çš„æ—¶é—´ç¢ç‰‡","slug":"default/è®°å½•/2023/12/2023-12-06","date":"2023-12-04T00:00:00.000Z","updated":"2023-12-06T00:00:00.000Z","comments":true,"path":"4b85c822/","link":"","permalink":"https://james1badcreeper.github.io/4b85c822/","excerpt":"ç­”æ¡ˆæ˜¯ï¼Œä»€ä¹ˆæ—¶å€™ï¼Ÿ","text":"ç­”æ¡ˆæ˜¯ï¼Œä»€ä¹ˆæ—¶å€™ï¼Ÿ å¤œã«å’²ãæ¸©åº¦ã¨ç¯ã‚‹ã¾ã§ å½“å¤œæ™šç»½æ”¾çš„æ¸©åº¦è¢«ç‚¹ç‡ƒä¹‹å‰ å‘¼å¸ã²ã¨ã¤ç”Ÿãã‚‹ç”Ÿãã‚‹ æ·±å¸ä¸€å£æ°” æƒ³ç€æ´»ä¸‹å» å„ªã—ã„æ—¥ã€…ã®æ¨ªã§æ³£ã‹ã¬ã‚ˆã†ã« éƒ½æ˜¯ä¸ºäº†ä¸åœ¨ç¾å¥½çš„æ—¥å­é‡Œ åœ¨ä½ èº«æ—å“­æ³£å•Š æ„›ã‚’ã²ã¨ã¤ã¾ãŸã­ã¾ãŸã­ è®©æˆ‘ä»¬å†ç›¸çˆ±ä¸€æ¬¡å§ [AGC052D] Equal LIS Portal. è®¾ LIS é•¿åº¦ä¸º mmmã€‚å¦‚æœ mmm æ˜¯å¶æ•°ï¼Œé‚£ä¹ˆå¯¹äº fiâ‰¤m2f_i\\le \\frac m 2fiâ€‹â‰¤2mâ€‹ã€‚åˆ’åˆ†åˆ°ä¸€ç»„ï¼Œå‰©ä¸‹çš„åˆ’åˆ†åˆ°å¦ä¸€ç»„å³å¯ã€‚ mmm ä¸ºå¥‡æ•°æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ°ä¸¤ä¸ªé•¿åº¦ä¸º âŒˆm2âŒ‰\\left\\lceil \\frac m 2 \\right\\rceilâŒˆ2mâ€‹âŒ‰ çš„ IS å³å¯ï¼Œæ„é€ æ—¶åŒæ ·å¯ä»¥ç›´æ¥åˆ’åˆ†ã€‚å…·ä½“æ¥è¯´ï¼Œå¦‚æœå­˜åœ¨æ¯” mmm å¤šçš„å¯ä»¥æˆä¸º LIS çš„ç‚¹ï¼Œé‚£ä¹ˆç›´æ¥åˆ’åˆ†ï¼Œå½“ LIS è¯•å›¾å˜å¾—æ¯” âŒˆm2âŒ‰\\left\\lceil \\frac m 2 \\right\\rceilâŒˆ2mâ€‹âŒ‰ å¤§æ—¶ç›´æ¥æ‰”åˆ°å¦ä¸€ä¸ªåºåˆ—å³å¯ã€‚ä»£ç ã€‚ [AGC055C] Weird LIS Portal. è®¾ ppp çš„ LIS é•¿åº¦ä¸º KKKï¼Œé‚£ä¹ˆåº”è¯¥æœ‰ aiâˆˆ[K,Kâˆ’1]a_i\\in [K,K-1]aiâ€‹âˆˆ[K,Kâˆ’1]ã€‚æˆ‘ä»¬å°† aiâ†aiâˆ’Ka_i\\leftarrow a_i-Kaiâ€‹â†aiâ€‹âˆ’Kã€‚ æ’åˆ—ä¸Šçš„æ•°å¯ä»¥åˆ’åˆ†æˆå››ç§ç±»å‹ï¼š è®©çº¢é»‘åŒ¹é…å°½å¯èƒ½åœ°å…ˆå‡ºç°ï¼Œé‚£ä¹ˆ fi,kf_{i,k}fi,kâ€‹ ä»£è¡¨ä»¥é¢œè‰² iii ä¸ºç»“å°¾ï¼Œå½“å‰ K=kK=kK=kï¼Œç›´æ¥åšå³å¯ã€‚ä»£ç ã€‚ [CF895C] Square Subsets Portal. åªä¼šåšæ°´é¢˜ã€‚ å…¶å®ç›¸å½“äºæ˜¯åœ¨æ±‚å¼‚æˆ–å’Œä¸º 000 çš„æ•°çš„ä¸ªæ•°ï¼Œç›´æ¥çº¿æ€§åŸºï¼Œç„¶åç­”æ¡ˆæ˜¯çº¿æ€§åŸºå†…æ•°çš„ä¸ªæ•°ã€‚ä»£ç ã€‚ [CF1517F] Reunion Portal. è®¾ä¸€ç§æ–¹æ¡ˆ SSS çš„åŠå¾„ä¸º f(S)f(S)f(S)ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ âˆ‘r=1nâˆ‘S[f(S)â‰¥r]\\sum_{r=1}^{n}\\sum_{S}[f(S)\\ge r]âˆ‘r=1nâ€‹âˆ‘Sâ€‹[f(S)â‰¥r]ã€‚å®é™…ä¸Šæˆ‘ä»¬åªéœ€è¦å¯¹äºæ¯ä¸ª rrr åˆ†åˆ«è®¡ç®—å³å¯ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨ iii çš„å­æ ‘è·ç¦» iii æœ€è¿‘çš„é»‘ç‚¹è·ç¦»ä¸º jjj çš„æ–¹æ¡ˆæ•°ï¼Œè®°æ»¡è¶³ j=r+1j=r+1j=r+1 çš„ä¸ºé¢„å¤‡ç‚¹ï¼Œgi,jg_{i,j}gi,jâ€‹ è¡¨ç¤º iii å­æ ‘å†…æœ€æ·±é¢„å¤‡ç‚¹ä¸ iii è·ç¦»ä¸º jjj æ—¶çš„æ–¹æ¡ˆæ•°ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè‹¥å­æ ‘å†…å·²ç»å­˜åœ¨é¢„å¤‡ç‚¹ï¼Œé‚£ä¹ˆæ²¡æœ‰å¿…è¦å†è€ƒè™‘è·ç¦» iii æœ€è¿‘çš„é»‘ç‚¹ä¸ iii çš„è·ç¦»ã€‚ä¸å­˜åœ¨æ—¶ï¼Œè¿™ä¸œè¥¿æ‰éœ€è¦è¢«è®°å½•ã€‚ è€ƒè™‘ä½¿ç”¨æ ‘å½¢èƒŒåŒ…çš„æ–¹å¼åˆå¹¶ï¼š åˆå¹¶ fx,i,fy,jf_{x,i},f_{y,j}fx,iâ€‹,fy,jâ€‹ï¼Œå¯ä»¥è½¬ç§»åˆ° fx,minâ¡{i,j+1}f_{x,\\min \\{i,j+1\\}}fx,min{i,j+1}â€‹ï¼› åˆå¹¶ gx,i,gy,jg_{x,i},g_{y,j}gx,iâ€‹,gy,jâ€‹ï¼Œå¯ä»¥è½¬ç§»åˆ° gx,maxâ¡{j,k+1}g_{x,\\max\\{j,k+1\\}}gx,max{j,k+1}â€‹ï¼› åˆå¹¶ fx,i,gy,jf_{x,i},g_{y,j}fx,iâ€‹,gy,jâ€‹ï¼Œå¦‚æœ i+j+1&gt;ri+j+1&gt;ri+j+1&gt;rï¼Œé‚£ä¹ˆ ggg å®šä¹‰çš„é¢„å¤‡ç‚¹æ˜¯ç¬¦åˆé™åˆ¶çš„ï¼Œå…¶ä¼šè½¬ç§»åˆ° gx,j+1g_{x,j+1}gx,j+1â€‹ï¼Œå¦åˆ™ä¼šè½¬ç§»åˆ° fx,if_{x,i}fx,iâ€‹ï¼› åˆå¹¶ gx,i,fy,jg_{x,i},f_{y,j}gx,iâ€‹,fy,jâ€‹ å¤§è‡´åŒç†ã€‚ ç­”æ¡ˆæ˜¯ âˆ‘g1\\sum g_1âˆ‘g1â€‹ã€‚ æ—¶é—´å¤æ‚åº¦ O(n3)O(n^3)O(n3)ã€‚ä»£ç ã€‚ [ARC105F] Lights Out on Connected Graph Portal. äºŒåˆ†å›¾å¯ä»¥è½¬åŒ–ä¸ºå°†ç‚¹è¿›è¡Œé»‘ç™½æŸ“è‰²ï¼Œä½†æ˜¯æ˜¯å¦è¿é€šä¸å¤ªå¥½æï¼Œå…ˆä¸ç®¡ã€‚é‚£è¿™æ ·çš„æ–¹æ¡ˆæ•°ä¸éš¾ç›´æ¥æšä¸¾å­é›†ç®—å‡ºã€‚ è€ƒè™‘å¦‚ä½•å¤„ç†è¿é€šã€‚é’¦å®šç‚¹åœ¨æŸä¸ªé¡ºåºä¸‹çš„é¦–ä¸ªè¿é€šå— TTTï¼Œé‚£ä¹ˆè®© TTT ä¸å‰©ä¸‹æ‰€æœ‰ç‚¹ä¸è¿é€šï¼Œå°±éœ€è¦å‡æ‰è¿™äº›æ–¹æ¡ˆã€‚æ³¨æ„æœ€åç­”æ¡ˆè¦é™¤ä»¥ 222ï¼Œä»£ç ã€‚ [APIO2019] æ¡¥æ¢ Portal. æ“ä½œåˆ†å—ã€‚å—ä¹‹å‰çš„ä¿®æ”¹ç›´æ¥å¤„ç†æ‰ï¼Œå—å†…éƒ¨çš„æŒ‰ç…§é‡é‡é™åˆ¶æ’åºç„¶åæšä¸¾æ‰€æœ‰è¯¢é—®ï¼Œä¸éœ€è¦ä¿®æ”¹çš„è¾¹æŒ‰ç…§é‡é‡é™åˆ¶ä¾æ¬¡æ·»åŠ ï¼Œå†æšä¸¾éœ€è¦ä¿®æ”¹çš„è¾¹æŒ‰ç…§æ—¶é—´è¿›è¡Œä¿®æ”¹ï¼Œç„¶åç›´æ¥å¯æ’¤é”€å¹¶æŸ¥é›†ç»´æŠ¤è¿™ä¸€é˜¶æ®µçš„ä¿®æ”¹ï¼Œå¯¹äºä¸€ä¸ªå—å†…è¿™ä¸€æ­¥æ˜¯ O(mlogâ¡m+m+B2)O(m\\log m + m +B^2)O(mlogm+m+B2) çš„ã€‚ä»£ç ã€‚ ä¸­ç‚¹ å¥½åƒåˆå¤§æ„äº†ã€‚ [APIO2019] è·¯ç¯ Portal. å¼€ä¸€ä¸ª set ç»´æŠ¤æ‰€æœ‰å€¼ä¸º 000 çš„ä½ç½®ï¼Œç„¶åç›¸å½“äºæ˜¯ä¸€ä¸ªäºŒç»´ååºé—®é¢˜ï¼ŒåŠ ä¸Šæ—¶é—´ä¹‹åå˜æˆäº†ä¸‰ç»´ååºï¼Œå¯¹äºè´¡çŒ®çš„è®¡ç®—ç›´æ¥è®°å½•ä¸Šä¸€æ¬¡ lll æ‰€å¯¹åº”çš„æ—¶é—´ï¼Œç›´æ¥ CDQ åˆ†æ²»å³å¯ã€‚ [APIO2019] å¥‡æ€ªè£…ç½® Portal. ä¸éš¾æ¨å¯¼å‡ºè®© x,yx,yx,y å¾ªç¯çš„å‘¨æœŸ TTT çš„é•¿åº¦ï¼Œç„¶åç›´æ¥æ±‚çº¿æ®µå¹¶å¤§å°å³å¯ã€‚ä»£ç ã€‚ [ZJOI2017] æ ‘çŠ¶æ•°ç»„ Portal. æ–¹å‘åäº†æ˜¯ä»€ä¹ˆï¼Ÿå˜æˆäº†æ±‚åç¼€å’Œï¼ä¹Ÿå°±æ˜¯è¯´ï¼Œä½†æ˜¯æ•´ä¸ªä¸œè¥¿æ±‚çš„æ˜¯ Srâˆ’1âˆ’Slâˆ’2S_{r-1}-S{l-2}Srâˆ’1â€‹âˆ’Slâˆ’2ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦æ±‚ vr=vlâˆ’1v_r=v_{l-1}vrâ€‹=vlâˆ’1â€‹ çš„æ¦‚ç‡ã€‚é‚£ä¹ˆå¯ä»¥è§†ä½œåŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ã€‚ ä½¿ç”¨äºŒç»´çº¿æ®µæ ‘ï¼Œå¤–å±‚ç»´æŠ¤ lllï¼Œå†…å±‚ç»´æŠ¤ rrrï¼Œæ–°çš„æ¦‚ç‡æ˜¯å¾ˆå¥½æ±‚çš„ï¼Œæ³¨æ„ l=1l=1l=1 æ—¶åªéœ€è¦æ³¨æ„ rrr çš„å˜åŒ–æƒ…å†µï¼Œç›´æ¥ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ [CF527E] Data Center Drama Portal. æœ€ç»ˆè¦æ»¡è¶³çš„æ¡ä»¶æ˜¯æ¬§æ‹‰å›¾çš„å……è¦æ¡ä»¶ï¼Œç„¶åå®šå‘ä¸€ä¸‹è¾¹å³å¯ã€‚æ‰€ä»¥å°†æ€»åº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹ä¸¤ä¸¤ç›¸è¿ï¼Œç„¶åä¸æ»¡è¶³åŠ ä¸€ä¸ªè‡ªç¯å³å¯ã€‚ä»£ç ã€‚ [CF538H] Summer Dichotomy Portal. å…ˆä¸è€ƒè™‘å­¦ç”Ÿæ•°çš„é™åˆ¶ï¼Œé‚£ä¹ˆåˆ†åˆ«ä¸¤ç»„å­¦ç”Ÿæ•°ä¸º minâ¡r,maxâ¡l\\min r,\\max lminr,maxl å³å¯ã€‚ç„¶åå¯ä»¥è°ƒæ•´å‡ºä¸€ç§æœ€ä¼˜çš„æ–¹æ¡ˆï¼Œäºæ˜¯å°±åšå®Œäº†ã€‚ä»£ç ã€‚ [CF543E] Listening to Music Portal. æŒ‰ç…§æƒå€¼ä»å¤§åˆ°å°æ’åºï¼Œå¯¹æ‰€æœ‰èƒ½å¤Ÿè¦†ç›–åˆ°å®ƒçš„å·¦ç«¯ç‚¹æ‰“æ ‡è®°ï¼Œç„¶åæ ‡è®°æ°¸ä¹…åŒ–ä¸€ä¸‹ï¼ˆç©ºé—´ä¸è¶³ï¼Œåˆ©ç”¨å·®å€¼æ¥è®°å½•æ ‡è®°ï¼‰ï¼Œå°±æ˜¯åŒºé—´æŸ¥è¯¢æœ€å¤§å€¼ã€‚ç¨å¾®å¡å¡ç©ºé—´å°±è¡Œï¼Œè¿™ä¹ˆå‡ºæŒºæ— èŠçš„ã€‚ è½å¹• æ‘†æã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/03(#4)ï¼šè¿™ä¸–ç•Œçªç„¶å¡«æ»¡ï¼Œè‰²å½©","slug":"default/è®°å½•/2023/12/2023-12-03","date":"2023-12-02T00:00:00.000Z","updated":"2023-12-03T00:00:00.000Z","comments":true,"path":"e2190/","link":"","permalink":"https://james1badcreeper.github.io/e2190/","excerpt":"è¿™å°±æ˜¯ï¼Œè¿™ä¸ªä¸–ç•Œå•Šã€‚","text":"è¿™å°±æ˜¯ï¼Œè¿™ä¸ªä¸–ç•Œå•Šã€‚ æƒ³è¿‡ç¦»å¼€ å½“é˜³å…‰è´¥ç»™é˜´éœ¾æ²¡æƒ³åˆ°ä½ ä¼šæ‹¼å‘½ä¸ºæˆ‘æ‹¨å¼€æ›¾æƒ³è¿‡ç¦»å¼€ å´åˆåšæŒåˆ°ç°åœ¨ç†¬è¿‡äº† é‚£äº›æ—ç™½ é‚£äº›å§¿æ€ é‚£äº›ä¼¤å®³ä¸æƒ³ç¦»å¼€ å½“ä½ çš„ç¬‘å®¹ç»½å¼€è¿™ä¸–ç•Œçªç„¶å¡«æ»¡ è‰²å½© æ‡‚å¾—éƒ½æ‡‚ã€‚ [APC001E] Antennas on Tree Portal. ä¸éš¾å‘ç°åªæœ‰ä¸€ä¸ªç‚¹ä¸ºæ ¹çš„å­æ ‘ä¸­æœ‰ä¸¤ä¸ªä»¥ä¸Šçš„æ²¡æœ‰é€‰æ‹©ç‚¹çš„æ—¶å€™åæ ‡ä¼šç®—é‡ï¼Œé‚£ä¹ˆä»åº¦æ•°ä¸º 111 çš„ç‚¹éšä¾¿ DFS ä¸€ä¸‹å³å¯ã€‚ä»£ç ã€‚ [AT_cf17_final_j] Tree MST Portal. ç›´æ¥ç‚¹åˆ†æ²»ï¼Œç„¶ååˆå¹¶çš„æ—¶å€™å†è·‘ä¸€æ¬¡ Kruskal å°±å¯ä»¥äº†ã€‚ä»£ç ã€‚ [Ynoi2013] å¯¹æ•°æ®ç»“æ„çš„çˆ± Portal. è€ƒè™‘æ¨¡æ‹Ÿè¿™ä¸ªè¿‡ç¨‹ã€‚æˆ‘ä»¬éœ€è¦çŸ¥é“å¯¹äºä¸€æ®µåŒºé—´ï¼Œåˆ°åº•ä¼šå‡å»å¤šå°‘ä¸ª pppã€‚ æä¸€ä¸ªæ•°ç»„ cic_iciâ€‹ ä»£è¡¨è¿™æ®µåŒºé—´è¦å‡å» iii ä¸ª ppp çš„æœ€å°åˆå§‹å€¼ï¼Œé‚£ä¹ˆæŸ¥è¯¢çš„æ—¶å€™ç›´æ¥äºŒåˆ†å°±è¡Œã€‚ç°åœ¨è€ƒè™‘å¦‚ä½•è®¡ç®— ccc æ•°ç»„ã€‚ å°è¯•æšä¸¾å·¦å„¿å­çš„ cxc_xcxâ€‹ å’Œå³å„¿å­çš„ cyc_ycyâ€‹ æ¥è®¡ç®— cx+yc_{x+y}cx+yâ€‹ï¼Œä»€ä¹ˆæ—¶å€™ä¸èƒ½æ›´æ–°ï¼Ÿcxc_xcxâ€‹ çš„ä¸Šç•Œç»è¿‡æ“ä½œåä¾ç„¶å°äº cyc_ycyâ€‹ã€‚ ç”¨ maxâ¡{cx,cy+xÃ—pâˆ’sumls}\\max\\{c_x,c_y+x\\times p-sum_{ls}\\}max{cxâ€‹,cyâ€‹+xÃ—pâˆ’sumlsâ€‹} æ›´æ–° cx+yc_{x+y}cx+yâ€‹ã€‚ç”±äº cx+1âˆ’cxâ‰¥pc_{x+1}-c_{x}\\ge pcx+1â€‹âˆ’cxâ€‹â‰¥pï¼Œå› æ­¤ç›´æ¥åŒæŒ‡é’ˆæ‰«å°±è¡Œã€‚ å•æ¬¡è¯¢é—®ä¼šæ‹†æˆ logâ¡\\loglog ä¸ªåŒºé—´ï¼Œæ¯ä¸ªåŒºé—´ç”¨ logâ¡\\loglog æ—¶é—´äºŒåˆ†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n+mlogâ¡2n)O(n\\log n+m\\log^2 n)O(nlogn+mlog2n)ã€‚ä»£ç ã€‚ [AGC061B] Summation By Construction Portal. é¦–å…ˆæ˜ç¡®æˆ‘ä»¬åˆ°åº•è¦å¹²ä»€ä¹ˆã€‚å¯¹äºé¢œè‰² iiiï¼Œiii ä¸ªå·¦éƒ¨ç‚¹éƒ½å„è¿ä¸¤ä¸ªè¿ç»­çš„å³éƒ¨ç‚¹å³å¯ã€‚ nnn ä¸ºå¥‡æ•°æ—¶ï¼Œä¸éš¾æŒ‰ç…§ i+j=ni+j=ni+j=n æ„é€ å‡ºæ–¹æ¡ˆã€‚ [3322âˆ£332âˆ£233âˆ£11]\\begin{bmatrix} 3 &amp; 3 &amp; 2 &amp; 2 &amp; | &amp; &amp; \\\\ &amp; 3 &amp; 3 &amp; 2 &amp; | &amp; 2 &amp; \\\\ &amp; &amp; 3 &amp; 3 &amp; | &amp; 1 &amp; 1 \\end{bmatrix} â€‹3â€‹33â€‹233â€‹223â€‹âˆ£âˆ£âˆ£â€‹21â€‹1â€‹â€‹ å¶æ•°å‘ä¸‹æ‰©å±•å°±å¯ä»¥äº†ã€‚ [44214412344223344âˆ’âˆ’âˆ’âˆ’âˆ’333]\\begin{bmatrix} 4 &amp;4 &amp; &amp; &amp;\\color{red}{2}\\\\ \\color{red}{1} &amp; 4 &amp; 4 &amp; &amp;\\color{red}{1}\\\\ \\color{red}{2}&amp; 3 &amp;4 &amp; 4 &amp;\\color{red}{2}\\\\ \\color{red}{2}&amp; 3&amp;3&amp; 4 &amp; 4\\\\ -&amp;-&amp;-&amp;-&amp;-\\\\ &amp;&amp;3&amp;3&amp;\\\\ &amp;&amp;&amp;3&amp; \\end{bmatrix} â€‹4122âˆ’â€‹4433âˆ’â€‹443âˆ’3â€‹44âˆ’33â€‹2124âˆ’â€‹â€‹ ä»£ç ã€‚ ED å¥½æ‘†å¥½æ‘†å¥½æ‘†å¥½æ‘†å¥½æ‘†å¥½æ‘†å¥½æ‘†å¥½æ‘†å¥½æ‘†å¥½æ‘†å¥½æ‘†ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/01(#3)ï¼šä¸è¦è¿™èˆ¬ç•™æˆ‘ä¸€äººåœ¨ä¸–","slug":"default/è®°å½•/2023/12/2023-12-01","date":"2023-12-01T00:00:00.000Z","updated":"2023-12-01T00:00:00.000Z","comments":true,"path":"3d1eade/","link":"","permalink":"https://james1badcreeper.github.io/3d1eade/","excerpt":"è¯·è£…ä½œï¼Œè¿˜æ²¡é†’æ¥çš„æ ·å­ã€‚","text":"è¯·è£…ä½œï¼Œè¿˜æ²¡é†’æ¥çš„æ ·å­ã€‚ å¿ƒã¯å­¤ç‹¬ã  å¿ƒæ˜¯å­¤ç‹¬çš„ æ„›ã¯è¦‹ãˆãªã„ ä»æ—§çœ‹ä¸è§çˆ± æ•°å€¤ã«å‡ºæ¥ãªã„æ„Ÿæƒ… è¿™ä»½æ„Ÿæƒ…æ— æ³•ä»¥æ•°å€¼è¡¡é‡ ã§ã‚‚éœ‡ãˆã¦ã„ã‚‹ ä½†æˆ‘è¿˜èƒ½åŠ¨å¼¹ è„ˆã‚’æ‰“ã¡ç¶šã‘ã‚‹ è„‰æä»åœ¨è·³åŠ¨ æ³¢ã«æµ®ã‹ã¶æ®‹éª¸ã®ã‚ˆã†ã« å¦‚åŒæ¼‚æµ®åœ¨æµªä¸­çš„æ®‹éª¸ ã€ŠBefore I Riseã€‹ï¼Œå¤ªæ„ŸåŠ¨äº†ã€‚ [AGC002D] Stamp Rally æ— èŠï¼Œå»ºå‡º Kruskal é‡æ„æ ‘å°±åšå®Œäº†ã€‚ [AGC002E] Candy Piles Portal. æŒºæœ‰æ„æ€çš„åšå¼ˆè®ºã€‚ å°†æƒå€¼ä»å¤§åˆ°å°æ’åºï¼Œå¯ä»¥è½¬åŒ–ä¸ºç½‘æ ¼å›¾ï¼Œé‚£ä¹ˆä» (0,0)(0,0)(0,0) å¼€å§‹ï¼Œæ“ä½œå°±ç›¸å½“äºå‘å³æˆ–å‘ä¸Šèµ°ä¸€æ­¥ã€‚ ä¸¤ç§æ“ä½œ è°èµ°åˆ°è¾¹ç•Œä¸Šçš„ç‚¹è°å°±è¾“äº†ï¼Œå› æ­¤å¦‚æœä»è¾¹ç•Œä¸Šçš„ç‚¹å¼€å§‹ï¼Œé‚£ä¹ˆåæ‰‹å¿…èƒœã€‚å¯¹äºä»»æ„ä¸€ä¸ªä¸åœ¨è¾¹ç•Œä¸Šçš„ç‚¹ï¼Œå¦‚æœå®ƒçš„ä¸Šé¢å’Œå³é¢éƒ½æ˜¯åæ‰‹å¿…èƒœç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹ä¸€å®šæ˜¯åæ‰‹å¿…è´¥ç‚¹ï¼Œå¦åˆ™ç»“æœç›¸åã€‚ çº¢è‰²åæ‰‹èƒœï¼Œè“è‰²å…ˆæ‰‹èƒœ æ‰¾åˆ°æœ€å¤§æ­£æ–¹å½¢ï¼Œç„¶åå‘ä¸Šå’Œå³æ‰©å±•å³å¯ã€‚ çº¢è‰² [AGC002F] Leftmost Ball Portal. ä¸ºä»€ä¹ˆæˆ‘ä¸ä¼šï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ è€ƒè™‘æœ€ç»ˆå½¢æˆçš„åˆæ³•åºåˆ—ï¼Œä¸€å®šæ˜¯ kkk ä¸ªç™½è‰²çƒåŠ ä¸Š nnn ä¸­é¢œè‰²çš„çƒå„ kâˆ’1k-1kâˆ’1 ä¸ªï¼Œåˆæ³•æƒ…å†µæ˜¯å‰ç¼€ç™½çƒä¸ªæ•°å¤§äºç­‰äºå…¶å®ƒé¢œè‰²æ•°ã€‚ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤º iii ä¸ªç™½çƒï¼Œæ”¾äº† jjj ä¸ªé¢œè‰²çš„æ–¹æ¡ˆæ•°ã€‚ å†³ç­–æœ‰ä¸¤ç§ï¼š æ”¾ç½®ä¸€ä¸ªç™½çƒï¼Œæœ‰ fi,jâ†+fiâˆ’1,jf_{i,j}\\stackrel{+}{\\leftarrow} f_{i-1,j}fi,jâ€‹â†+fiâˆ’1,jâ€‹ï¼› åŠ å…¥æ–°é¢œè‰²çš„çƒï¼Œå³ä» fi,jâˆ’1f_{i,j-1}fi,jâˆ’1â€‹ è½¬ç§»ã€‚ç³»æ•°æ˜¯å¤šå°‘ï¼Ÿé¦–å…ˆéœ€è¦åœ¨ nâˆ’j+1n-j+1nâˆ’j+1 ä¸­é€‰æ‹©ä¸€ä¸ªä½œä¸ºè¿™æ—¶æ”¾ç½®çš„é¢œè‰²ï¼Œå°†å…¶ä¸­ä¸€ä¸ªæ”¾ç½®åœ¨ç¬¬ä¸€ä¸ªç©ºä½ï¼Œç„¶åå‰©ä¸‹çš„ kâˆ’2k-2kâˆ’2 ä¸ªåœ¨åé¢çš„ nkâˆ’iâˆ’(jâˆ’1)(kâˆ’1)âˆ’1nk-i-(j-1)(k-1)-1nkâˆ’iâˆ’(jâˆ’1)(kâˆ’1)âˆ’1 ä¸­æ‰¾ kâˆ’2k-2kâˆ’2 ä¸ªæ”¾å³å¯ã€‚ ç„¶åå°±å®Œäº†ã€‚ä»£ç ã€‚ ä¸­ç‚¹ åˆå¤§æ„äº†ï¼Œä¸Šåˆå¥½åƒæœ‰ç‚¹æ‘†ã€‚ ç¥å„ä½ CTT RP++ã€‚ æˆ‘ä¹Ÿæƒ³å» CTT æ€ä¹ˆéƒ½è€å¹´é€‰æ‰‹äº†è¿˜è¿™ä¹ˆèœå•Šã€‚ [CF521E] Cycling City Portal. éšä¾¿æ‰¾åˆ°ä¸€æ£µç”Ÿæˆæ ‘ï¼Œæ¡ä»¶æ˜¯å­˜åœ¨ä¸€æ¡æ ‘è¾¹è¢«ä¸¤æ¡éæ ‘è¾¹è¦†ç›–æ‰ã€‚é‚£ä¹ˆç›´æ¥æš´åŠ›è¦†ç›–ï¼ˆæœ€å¤šå®Œæ•´éå†æ ‘ä¸¤æ¬¡ï¼‰ï¼Œç„¶åæš´åŠ›æ±‚å°±è¡Œäº†ã€‚ä»£ç ã€‚ [å—äº¬ 2020] Fireworks ç›´æ¥ä¸‰åˆ†å°±è¡Œã€‚ [å—äº¬ 2020] Ah, Itâ€™s Yesterday Once More Portal. æœ‰ç‚¹é¬¼ç•œçš„é¢˜ã€‚æŒ‰ç…§é˜¶æ¢¯æ„é€ ä¸€ä¸‹å°±è¡Œäº†ã€‚ [CF526G] Spiders Evil Plan Portal. é¦–å…ˆ kkk æ¡è·¯å¾„å¯ä»¥è¦†ç›– 2k2k2k å¶å­çš„æ ‘ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé€‰æ‹© yyy ä¸ªç‚¹å°±æ˜¯èƒ½é€‰æ‹© 2y2y2y ä¸ªå¶å­ï¼Œç„¶åæå°è¿é€šå—çš„è¾¹æƒå’Œå°½é‡å¤§ã€‚ ä»¥ xxx ä¸ºæ ¹æ—¶å¦‚ä½•é€‰æ‹©å¶å­å‘¢ï¼Ÿè€ƒè™‘è¿›è¡Œä¸€æ¬¡é•¿é“¾å‰–åˆ†ï¼Œé‚£ä¹ˆ xxx æ‰€åœ¨çš„é•¿é“¾çš„å¶å­ä¹Ÿä¸€å®šé€‰æ‹©äº†ï¼Œç„¶åæŒ‰ç…§è¾¹æƒæ’åºè´ªå¿ƒå³å¯ã€‚ å¤šæ¬¡è¯¢é—®æ€ä¹ˆåŠï¼Ÿç”±äºæ ‘ä¸Šç»è¿‡ xxx çš„æœ€é•¿é“¾ä¸€å®šç»è¿‡ç›´å¾„çš„æŸä¸€ç«¯ï¼Œé‚£ä¹ˆä»¥ç›´å¾„çš„ä¸¤ä¸ªç«¯ç‚¹åˆ†åˆ«åšä¸€æ¬¡é•¿é“¾å‰–åˆ†ï¼Œç„¶åè¦æƒ³åŠæ³•å°† xxx åŠ å…¥è¿é€šå—ï¼Œåªæœ‰ä¸¤ç§æ–¹æ³•ï¼š å°†è´¡çŒ®æœ€å°çš„é•¿é“¾å»æ‰ï¼Œç„¶ååŠ å…¥ xxx æ‰€åœ¨é•¿é“¾ï¼› æ‰¾åˆ°ç¦» xxx æœ€è¿‘é•¿é“¾çš„ä¸‹åŠéƒ¨åˆ†å¹¶æ›¿æ¢ã€‚ å€å¢è·³é•¿é“¾æ±‚å‡ºæ›¿æ¢çš„ä¸œè¥¿å³å¯ã€‚ä»£ç ã€‚ ED æ‘†çš„æœ‰ç‚¹æŠ½è±¡äº†ï¼Œæœ¬æ¥è¿™ç¯‡åº”è¯¥å†å¤šä¸‰é“é¢˜çš„ã€‚ æ„Ÿè§‰æ˜¨å¤©é€ äº†ä¸€å¤©æ•°æ®ä¹‹åçš„æ•ˆç‡ä¸å¤ªè¡Œï¼Œçœ‹çœ‹æ˜åå¤©èƒ½ä¸èƒ½æ¢å¤ä¸€ç‚¹ã€‚åˆ«ï¼Œæ…Œã€‚ å†æ¬¡ç–¯ç‹‚å§ï¼ï¼","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/11/29(#2)ï¼šæ¯å½“æˆ‘ä¸ºä½ æŠ¬èµ·å¤´ï¼Œè¿çœ¼æ³ªéƒ½è§‰å¾—è‡ªç”±","slug":"default/è®°å½•/2023/11/2023-11-29","date":"2023-11-27T00:00:00.000Z","updated":"2023-11-29T00:00:00.000Z","comments":true,"path":"654b1da7/","link":"","permalink":"https://james1badcreeper.github.io/654b1da7/","excerpt":"æœ‰çš„çˆ±åƒå¤§é›¨æ»‚æ²±ï¼Œå´ä¾ç„¶ç›¸ä¿¡å½©è™¹","text":"æœ‰çš„çˆ±åƒå¤§é›¨æ»‚æ²±ï¼Œå´ä¾ç„¶ç›¸ä¿¡å½©è™¹ æˆ‘å¯ä»¥è·Ÿåœ¨ä½ èº«å åƒå½±å­è¿½ç€å…‰æ¢¦æ¸¸ æˆ‘å¯ä»¥ç­‰åœ¨è¿™è·¯å£ ä¸ç®¡ä½ ä¼šä¸ä¼šç»è¿‡ æ¯å½“æˆ‘ä¸ºä½ æŠ¬èµ·å¤´ è¿çœ¼æ³ªéƒ½è§‰å¾—è‡ªç”± æœ‰çš„çˆ±åƒå¤§é›¨æ»‚æ²± å´ä¾ç„¶ç›¸ä¿¡å½©è™¹ ç›¸ä¿¡å½©è™¹ å¼ æ°è¿™ä¸€ç‰ˆå”±å‡ºäº†å…‰çš„æ„Ÿè§‰ï¼Œå¤ªæ„ŸåŠ¨äº†ï¼ï¼ å¤§æ„äº†ï¼Œæ¨¡æ‹Ÿèµ› T2 æ²¡æœ‰æµ‹å¥‡æ•°çš„æ•°æ®ï¼ æ€ä¹ˆè¿˜æ˜¯åªä¼šåšç®€å•é¢˜ï¼ æˆ‘æ€ä¹ˆè¿˜æ–­æ›´äº†ä¸€å¤©ï¼ˆæ‰€ä»¥ä»Šå¤©å®é™…ä¸Šæ˜¯ä¸¤å¤©çš„ç´ æï¼Œæˆ‘å¤ªæ‘†äº†ï¼‰ï¼ [Luogu P5351] Ruri Loves Maschera Portal. ç‚¹åˆ†æ²»ï¼Œç»Ÿè®¡ä¿¡æ¯æ—¶è®°å½• ddd å’Œæœ€å¤§å€¼ wwwï¼Œæ‰«æçº¿æ‰« wwwï¼Œæ ‘çŠ¶æ•°ç»„ç»´æŠ¤ ddd å³å¯ã€‚ä»£ç ã€‚ [CF960H] Santaâ€™s Gift Portal. ä¸€å¼€å§‹è¯»æˆäº†æ’’æ—¦çš„ç¤¼ç‰©ã€‚ å°†è´¡çŒ®æ‹†äº†ï¼Œå‘ç°é—®é¢˜å˜æˆäº†ç»´æŠ¤å­æ ‘ä¸­æ¯ä¸ªé¢œè‰²çš„ä¸ªæ•°ã€‚ç”±äºæ€»å…±èƒ½å‡ºç°çš„é¢œè‰²åªæœ‰ O(n+q)O(n+q)O(n+q)ï¼Œå› æ­¤ç›´æ¥æ¯ä¸ªé¢œè‰²éƒ½å»ºä¸€æ£µæ”¯æŒåŒºé—´åŠ çš„åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ [ARC102D] Revenge of BBuBBBlesort! Portal. è¿„ä»Šä¸ºæ­¢æˆ‘åˆ°åº•è§åˆ°äº†å¤šå°‘å†’æ³¡æ’åºå¤ä»‡é¢˜ï¼ æ€è€ƒä¸€ä¸‹äº¤æ¢æ„å‘³ç€ä»€ä¹ˆã€‚ä¸€æ¬¡äº¤æ¢åºŸæ‰äº†ä¸‰ä¸ªé€†åºå¯¹ï¼Œå› æ­¤é€†åºå¯¹ä¸ªæ•°æ˜¯ä¸‰çš„å€æ•°æ˜¯å¿…è¦æ¡ä»¶ä¹‹ä¸€ã€‚ ç„¶åäº¤æ¢æ—¶æ•°çš„å¥‡å¶æ€§æ˜¯ä¸å˜çš„ï¼Œå› æ­¤å¥‡æ•°åªèƒ½åœ¨å¥‡æ•°ä½ï¼Œå¶æ•°åªèƒ½åœ¨å¶æ•°ä½ã€‚ äºæ˜¯ä¸éš¾æƒ³åˆ°æŠŠå¥‡æ•°ä½å’Œå¶æ•°ä½åˆ†ä¸ºä¸¤ç»„ï¼Œæ¯æ¬¡å¯ä»¥åºŸæ‰å¥‡æ•°åºåˆ—æˆ–è€…å¶æ•°åºåˆ—çš„ä¸€ä¸ªé€†åºå¯¹ã€‚è¿™æ ·çœ‹æ¥ï¼Œæ•´ä¸ªåºåˆ—çš„é€†åºå¯¹ä¸ªæ•°åº”è¯¥æ˜¯å¥‡æ•°åºåˆ—é€†åºå¯¹åŠ å¶æ•°åºåˆ—é€†åºå¯¹çš„ä¸‰å€ã€‚ ä¸€ä¸ªæ“ä½œåˆæ³•å½“ä¸”ä»…å½“å…¶èƒ½æ¶ˆé™¤ä¸‰ä¸ªå…¨å±€é€†åºå¯¹ï¼Œè€Œä¸”ä¸€æ¬¡æ“ä½œæœ€å¤šæ¶ˆé™¤ä¸‰ä¸ªå…¨å±€é€†åºå¯¹ï¼Œå› æ­¤è¿™ä¸ªä¸œè¥¿å……åˆ†ã€‚ä»£ç ã€‚ [NOI Online 2022 æé«˜ç»„] å¦‚ä½•æ­£ç¡®åœ°æ’åº Portal. æˆ‘ä»¬è€ƒè™‘è®¡ç®—å¯¹ minâ¡,maxâ¡\\min,\\maxmin,max æ²¡æœ‰è´¡çŒ®çš„æ•°ï¼Œæšä¸¾ä¸‰ä¸ªæ•°ç»„ A,B,CA,B,CA,B,Cï¼Œå¦‚æœ BBB æ²¡æœ‰è´¡çŒ®ï¼Œé‚£ä¹ˆåº”è¯¥æ»¡è¶³ Ai+Ajâ‰¤Bi+Bjâ‰¤Ci+CjA_i+A_j\\le B_i+B_j\\le C_i+C_jAiâ€‹+Ajâ€‹â‰¤Biâ€‹+Bjâ€‹â‰¤Ciâ€‹+Cjâ€‹ã€‚ç§»é¡¹ä¹‹åå˜æˆäºŒç»´ååºï¼Œç›´æ¥åšï¼Œæ³¨æ„é˜²æ­¢ç®—é‡ã€‚ä»£ç ã€‚ [Ynoi E2022] TEST_105 Portal. ä¸ä¼šåšå¥—è·¯é¢˜æ€ä¹ˆåŠï¼Ÿï¼Ÿå¥—è·¯æ²¡è§è¿‡æ€ä¹ˆåŠï¼Ÿï¼Ÿè¿˜ç–¯ç‹‚æ‘†çƒ‚æ€ä¹ˆåŠï¼Ÿï¼Ÿ é¦–å…ˆï¼Œæ ‘ä¸Šé‚»åŸŸä¿¡æ¯ä¸€å®šåªèƒ½ç»´æŠ¤å­æ ‘çš„ä¿¡æ¯ï¼Œå¦åˆ™å•ç‚¹ä¿®æ”¹ä¼šå¯¼è‡´æ‰€æœ‰å„¿å­éƒ½éœ€è¦ä¿®æ”¹ï¼Œå¤æ‚åº¦ç›´æ¥çˆ†ç‚¸ã€‚ ä»¤ Ci,jC_{i,j}Ci,jâ€‹ è¡¨ç¤º iii ç‚¹æ‰€åœ¨å­æ ‘èŒƒå›´å†…çš„è¿é€šå—çš„ jjj è‰²è¿é€šå—åºåˆ—ï¼Œä¿®æ”¹æ—¶ç›´æ¥å¯å‘å¼åˆå¹¶ï¼Œåªéœ€è¦æ›´æ–° Cfax,yC_{fa_x,y}Cfaxâ€‹,yâ€‹ å³å¯ã€‚ ä¸ºä»€ä¹ˆä¸­é€”è¿˜å†™æŒ‚äº†å•Šï¼Ÿï¼Ÿï¼Ÿï¼Ÿè¿˜è°ƒäº†åŠå¤©ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ ã€ŒC.E.L.U-03ã€æ¢é™©è€…ç¬”è®° III Portal. ä¸¤ä¸ªå’Œå¼å°±æ˜¯å”¬äººçš„ï¼Œå› ä¸ºå®ƒä»¬æ˜¯å®šå€¼ï¼Œæš´åŠ›è½¬ç§»å°±æ˜¯ O(m2)O(m^2)O(m2) çš„ã€‚ç„¶åå‘ç°ç¬¬ä¸‰ç»´å¯ä»¥ç›´æ¥æš´åŠ›æšä¸¾å­é›†å¤„ç†ã€‚ ä½†æ˜¯è¿™æ ·æ˜¾ç„¶ä¸å¯¹ã€‚ä¿®æ”¹æ—¶æœ‰ä¸¤ç§æƒ³æ³•ï¼Œå°† pjp_jpjâ€‹ å­˜ä¸‹æ¥ï¼Œæšä¸¾ pip_ipiâ€‹ çš„å­é›†ï¼›æˆ–è€…å¤„ç† pjp_jpjâ€‹ çš„è¶…é›†ï¼Œpip_ipiâ€‹ ç›´æ¥è®¡ç®—ã€‚å°† 181818 ä½äºŒè¿›åˆ¶æ•°åŠˆæˆä¸¤åŠï¼Œå®šä¹‰ gs,tg_{s,t}gs,tâ€‹ è¡¨ç¤º pip_ipiâ€‹ å‰ 999 ä½ä¸º sssï¼Œpjp_jpjâ€‹ å 999 ä½ä¸º ttt çš„æœ€ä¼˜å†³ç­–å³å¯å®Œæˆå¹³è¡¡ã€‚ä»£ç ã€‚ ED ä¸‹åˆå¹²ä¸€äº›æ¯”è¾ƒé‡è¦çš„äº‹æƒ…ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/11/27(#1)ï¼šç‚¹ç‡ƒæ˜Ÿï¼Œäº²æ‰‹ç‚¹ç‡ƒé»‘æš—æ£®æ—çš„ç«æ˜Ÿ","slug":"default/è®°å½•/2023/11/2023-11-27","date":"2023-11-26T00:00:00.000Z","updated":"2023-11-27T00:00:00.000Z","comments":true,"path":"6238497e/","link":"","permalink":"https://james1badcreeper.github.io/6238497e/","excerpt":"å¼ºåº¦ï¼å¼ºåº¦ï¼","text":"å¼ºåº¦ï¼å¼ºåº¦ï¼ æˆ‘æ˜¯æ˜Ÿ åˆ©å‰‘å¼€åˆƒå¯’å…‰é”‹èŠ’çš„é“¶æ˜Ÿ ç»ä¸æ¶ˆéš ä¸å›é¡¾æ°¸éš¾å†æŠ˜è¿”çš„æ•…å›­çš„å…‰é˜´ å†³æ„å‰è¿› ç‚¹ç‡ƒæ˜Ÿ äº²æ‰‹ç‚¹ç‡ƒé»‘æš—æ£®æ—çš„ç«æ˜Ÿ è’™æ˜§åˆé†’ è€Œæˆ‘å´è½»å£°å‘Šåˆ«è¿™æ–°ç”Ÿçš„é»æ˜ ä¸åƒè¿™ç§åŠ è®­æ–¹å¼çš„åˆ›å§‹äººåšçš„éƒ½æ˜¯ç¥ä»™é¢˜ï¼Œæˆ‘åšçš„å…¨æ˜¯æ°´é¢˜â€¦â€¦ ç„¶è€Œå³ä½¿è¿™æ ·è¿˜æ˜¯æ‹–åˆ°äº†æ¬¡æ—¥ï¼ˆæœ¬æ–‡äº 2023/11/26 åŠ¨å·¥ï¼‰ï¼Œæ•ˆç‡è¿˜æ˜¯è¦æå‡ï¼ è®©ä¸€åˆ‡ï¼Œé‡æ–°å¼€å§‹å§ã€‚æœç€æœŸæœ›çš„å½¼å²¸ï¼Œå†æ¬¡å‰è¿›å§ã€‚ [ICPC 2023 Nanjing] Counter Portal. æŒ‰ç…§æ—¶é—´æ’åºï¼Œæ¨¡æ‹Ÿå³å¯ã€‚ä»£ç ã€‚ [ICPC 2023 Nanjing] Trapping Rain Water Portal. æœ¬èº«æ˜¯ä¸ªç»å…¸é—®é¢˜ã€‚set ç»´æŠ¤æ‰€æœ‰çš„æå€¼ç‚¹ï¼Œçº¿æ®µæ ‘æŸ¥è¯¢åŒºé—´æœ€å¤§å€¼å’ŒåŒºé—´å’Œï¼Œæ¯æ¬¡ä¿®æ”¹ç›´æ¥æš´åŠ›åˆ é™¤æå€¼ç‚¹ï¼Œè®¡ç®—è´¡çŒ®å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ O(Tnlogâ¡n)O(Tn\\log n)O(Tnlogn)ã€‚ä»£ç ã€‚ [ICPC 2023 Nanjing] Equivalent Rewriting Portal. å¦‚æœä¸€ä¸ªèµ‹å€¼æ“ä½œæœ€åå°†å½“å‰ç‚¹çš„å€¼ç¡®å®šï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹å‘å…¶å®ƒèµ‹å€¼è¿‡è¿™ä¸ªç‚¹çš„æ“ä½œè¿è¾¹ã€‚å¦‚æœæ‹“æ‰‘åºä¸å”¯ä¸€ï¼Œé‚£å°±æœ‰è§£ã€‚ä»£ç ã€‚ [ICPC 2023 Nanjing] Primitive Root Portal. è§£çš„å½¢å¼å½¢å¦‚ (ip+1)âŠ•(pâˆ’1)(ip+1)\\oplus (p-1)(ip+1)âŠ•(pâˆ’1)ï¼Œç„¶åå‘ç°ç­”æ¡ˆå¤§æ¦‚æ˜¯ m/p+1m/p+1m/p+1ï¼Œè¾¹ç•Œæš´åŠ›åˆ¤æ–­å³å¯ã€‚ä»£ç ã€‚ [CF1166D] Cute Sequences Portal. å®¹æ˜“å‘ç° b=aÃ—2kâˆ’2+r2Ã—2kâˆ’3+â‹¯+rkâˆ’1+rkb=a\\times 2^{k-2}+r_2\\times 2^{k-3}+\\cdots +r_{k-1}+r_kb=aÃ—2kâˆ’2+r2â€‹Ã—2kâˆ’3+â‹¯+rkâˆ’1â€‹+rkâ€‹ã€‚ çœ‹ä¸Šå»å¾ˆåƒä¸€ä¸ªäºŒè¿›åˆ¶æ‹†åˆ†çŠ¶ç‰©ã€‚åæ‰‹å…ˆå°† rrr å…¨éƒ¨å‡æ‰ 111ï¼Œç„¶åè´ªå¿ƒå¡«æ¯ä¸€ä½å³å¯ã€‚ä»£ç ã€‚ ã€ŒEZEC-14ã€ä¼—æ•° II Portal. å‘ç°å¦‚æœä¸€ä¸ªæ•° kkk æƒ³è¦ä½œä¸ºåŒºé—´æœ€å°ä¼—æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªåŒºé—´å¿…é¡»ä»¥å®ƒå¼€å¤´ï¼Œä¸”ä¸èƒ½ç¢°åˆ°ä¸‹ä¸€ä¸ª 111 æˆ–è€…åœ¨ä¸‹ä¸€ä¸ªè¿ç»­å‡ºç° kkk çš„ä½ç½®ç»“å°¾ã€‚ æˆ‘ä»¬è®¡ç®—ä¸€ä¸ªæ•°ç»„ wwwï¼Œwiw_iwiâ€‹ ä»£è¡¨ä»¥ç¬¬ iii ä¸ª aia_iaiâ€‹ ä¸­çš„ kkk ä½œä¸ºç»“å°¾æ®µçš„å·¦ç«¯ç‚¹ä¸ªæ•°ã€‚å‘ç° www çš„æ›´æ”¹æ˜¯åŒºé—´åŠ çš„å½¢å¼ï¼Œå¹¶æŸ¥é›†ç»´æŠ¤åŒºé—´çš„å³ç«¯ç‚¹å³å¯ã€‚ æ€»ç»“ä¸€ä¸‹ï¼ŒåŒºé—´ä¼—æ•°ä¸º kkk çš„è´¡çŒ®ä¸º kâˆ‘i=1nwimaxâ¡{0,aiâˆ’k+1}k\\sum_{i=1}^n w_i\\max\\{0,a_i-k+1\\}kâˆ‘i=1nâ€‹wiâ€‹max{0,aiâ€‹âˆ’k+1}ã€‚ç»´æŠ¤ âˆ‘wi\\sum w_iâˆ‘wiâ€‹ å’Œ âˆ‘wiai\\sum w_i a_iâˆ‘wiâ€‹aiâ€‹ å³å¯è®¡ç®—ã€‚ä»£ç ã€‚ ã€ŒEZEC-14ã€ç»ˆç‚¹ Portal. å…ˆè€ƒè™‘ fai&lt;ifa_i&lt;ifaiâ€‹&lt;iã€‚è§„å®š fa1=2fa_1=2fa1â€‹=2ï¼Œæ±‚è§£ xxx æ—¶ä»¤ä¸´æ—¶çˆ¶äº² y=1y=1y=1ï¼Œåœ¨ yyy å’Œ fayfa_yfayâ€‹ ä¸­å¯»æ‰¾è·ç¦»ä¸ºå¶æ•°çš„ç‚¹æ¥æ‰¾åˆ°ä¸­ç‚¹ï¼Œç„¶åå°†ä¸´æ—¶çˆ¶äº²æ”¹ä¸ºè¿™ä¸ªä¸­ç‚¹ï¼Œlogâ¡\\loglog æ¬¡è¯¢é—®å³å¯å¾—åˆ°ç»“æœã€‚ å¯¹äºä»»æ„æ ‘çš„æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦å…ˆæ‰¾åˆ°ä¸€ç»„ç›¸é‚»çš„ç‚¹ã€‚å…ˆè¯¢é—® 111 å’Œæ‰€æœ‰ç‚¹çš„ä¸­ç‚¹ï¼Œæ‰¾åˆ°å’Œ 111 èƒ½å–ä¸­ç‚¹æ¬¡æ•°æœ€å¤šçš„ç‚¹ä¸æ–­å–ä¸­ç‚¹å³å¯å¾—åˆ°ä¸€ä¸ªå’Œ 111 ç›¸é‚»çš„ç‚¹ã€‚ ä½¿ç”¨ BFS å¤„ç†ä¸€å¼€å§‹æ‰€è¿°çš„è¿­ä»£è¿‡ç¨‹ã€‚åœ¨æ±‚è§£ä¸€ä¸ªç‚¹çš„çˆ¶äº²æ—¶éœ€è¦ä¿è¯å®ƒåˆ°æ ¹çš„è·¯å¾„ä¸Šçš„æ‰€æœ‰ç‚¹ï¼ˆé™¤äº†è‡ªå·±ï¼‰çš„çˆ¶äº²éƒ½æ˜¯å·²çŸ¥çš„ï¼Œä¸­ç‚¹ yyy ä¸ºä¸€ä¸ªä¸ç¡®å®šçˆ¶äº²çš„ç‚¹æ—¶å°†è¯¢é—®æŒ‚åœ¨ yyy ä¸Šï¼Œç„¶åæ¯æ¬¡ç¡®å®šä¸€ä¸ªç‚¹çš„çˆ¶äº²å¤„ç†æ‰€æœ‰æŒ‚åœ¨å®ƒä¸Šé¢çš„è¯¢é—®å³å¯ã€‚ä»£ç ã€‚ [BJOI2018] åŒäººçŒœæ•°æ¸¸æˆ Portal. Alice å’Œ Bob æ€ä¹ˆè¿™ä¹ˆèªæ˜å•Šï¼Ÿï¼Ÿ å°å­¦æ—¶çœ‹è¿‡è¿™ç§é—®é¢˜ï¼Œç„¶åç°åœ¨åœ¨ OI ä¸­è§åˆ°äº†å®ƒã€‚ è®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ è¡¨ç¤ºåœ¨ç¬¬ iii ä¸ªå›åˆï¼Œäººèƒ½å¦ç¡®å®šç­”æ¡ˆæ˜¯ä¸æ˜¯ j,k(jâ‰¤k)j,k(j\\le k)j,k(jâ‰¤k)ã€‚ ä»¥ Bob ä¸ºä¾‹ï¼Œæƒ…å†µåªæœ‰ä¸‰ç§ï¼š å¦‚æœè¿™ä¸ªäººåœ¨å®ƒçš„ä¸Šä¸€ä¸ªè½®æ¬¡å·²ç»çŸ¥é“ç­”æ¡ˆï¼Œé‚£ä¹ˆå®ƒè¿™ä¸ªè½®æ¬¡ä¹ŸçŸ¥é“ï¼Œå³ fi,j,kâ†fiâˆ’2,j,kf_{i,j,k}\\leftarrow f_{i-2,j,k}fi,j,kâ€‹â†fiâˆ’2,j,kâ€‹ï¼› ä»æœªçŸ¥æ¨å‡ºå·²çŸ¥ï¼š fiâˆ’1,x,y(x+y=j+k)f_{i-1,x,y}(x+y=j+k)fiâˆ’1,x,yâ€‹(x+y=j+k) ä¸­ï¼Œä»–çš„å¯¹æ‰‹ä»…æœ‰ä¸€ä¸ª fiâˆ’1,j,kf_{i-1,j,k}fiâˆ’1,j,kâ€‹ ä¸çŸ¥é“ï¼Œé‚£ä¹ˆä»–è‡ªå·±å¯ä»¥ç¡®å®š j=x,y=kj=x,y=kj=x,y=kï¼› fiâˆ’1,x,y(x+y=j+k)f_{i-1,x,y}(x+y=j+k)fiâˆ’1,x,yâ€‹(x+y=j+k) ä¸­ï¼Œä»–è‡ªå·±çš„ä¸Šä¸€ä¸ªè½®æ¬¡åªæœ‰ fiâˆ’2,j,kf_{i-2,j,k}fiâˆ’2,j,kâ€‹ ä¸çŸ¥é“ï¼Œé‚£ä¹ˆä»–è‡ªå·±å¯ä»¥ç¡®å®š j=x,y=kj=x,y=kj=x,y=kï¼› ä»å·²çŸ¥æ¨å‡ºå·²çŸ¥ï¼šfiâˆ’1,x,y(x+y=j+k)f_{i-1,x,y}(x+y=j+k)fiâˆ’1,x,yâ€‹(x+y=j+k) ä¸­ï¼Œä»–çš„å¯¹æ‰‹ä¸Šä¸€å›åˆåªæ–°å¢ç¡®å®šäº†ä¸€ä¸ª fiâˆ’1,j,kf_{i-1,j,k}fiâˆ’1,j,kâ€‹ï¼Œé‚£ä¹ˆä»–è¿™å›åˆå°±èƒ½ç¡®å®š fi,j,kf_{i,j,k}fi,j,kâ€‹ï¼Œ(j,k)(j,k)(j,k) æ˜¯ä¸æ˜¯ç­”æ¡ˆè·Ÿå¯¹æ‰‹ä¸Šä¸€æ¬¡çš„å›ç­”æ˜¯ä¸€è‡´çš„ã€‚ 500500500 ä»¥å†…å¯ä»¥æ‰¾åˆ°ç­”æ¡ˆï¼Œç›´æ¥ DP å³å¯ã€‚ä»£ç ã€‚ é—´éš” æ—¶é—´æ¥åˆ°äº† 11/27 å‡Œæ™¨ã€‚ é©¬å…‹åœ¨ç¾¤é‡Œè¡¨æ¼”äº†ä¸€å°æ—¶ AK CF Div.2ï¼Œå¤ªç‰›é€¼äº†ã€‚ [BJOI2018] é“¾ä¸ŠäºŒæ¬¡æ±‚å’Œ Portal. æˆ‘ä»¬æœ‰ï¼š ans=âˆ‘k=lrâˆ‘i=knSiâˆ’Siâˆ’k=âˆ‘k=lr(âˆ‘i=knSiâˆ’âˆ‘i=0nâˆ’kSi)=âˆ‘k=lr(SSnâˆ’SSkâˆ’1âˆ’SSnâˆ’k)\\begin{aligned} ans&amp;=\\sum_{k=l}^{r}\\sum_{i=k}^{n}S_i - S_{i-k}\\\\ &amp;=\\sum_{k=l}^r\\left(\\sum_{i=k}^nS_i-\\sum_{i=0}^{n-k}S_i\\right)\\\\ &amp;=\\sum_{k=l}^r(SS_n-SS_{k-1}-SS_{n-k}) \\end{aligned} ansâ€‹=k=lâˆ‘râ€‹i=kâˆ‘nâ€‹Siâ€‹âˆ’Siâˆ’kâ€‹=k=lâˆ‘râ€‹(i=kâˆ‘nâ€‹Siâ€‹âˆ’i=0âˆ‘nâˆ’kâ€‹Siâ€‹)=k=lâˆ‘râ€‹(SSnâ€‹âˆ’SSkâˆ’1â€‹âˆ’SSnâˆ’kâ€‹)â€‹ ç„¶åå› ä¸ºæ˜¯åŒºé—´ä¿®æ”¹ï¼Œæ ‘çŠ¶æ•°ç»„ç»´æŠ¤ä¸‰é˜¶å’Œå››é˜¶å‰ç¼€å’Œå³å¯ã€‚æ³¨æ„é“¾ä¸Šçš„ç‚¹å¯ä»¥ x&gt;yx&gt;yx&gt;yï¼Œä»£ç ã€‚ [APIO2016] æœ€å¤§å·®åˆ† Portal. å­ä»»åŠ¡ 111 å¾ˆç®€å•ï¼Œç›´æ¥ä¸€è·¯é—®è¿‡å»å°±æ˜¯ âŒˆn2âŒ‰\\left\\lceil\\frac n 2\\right\\rceilâŒˆ2nâ€‹âŒ‰ æ¬¡è¯¢é—®æ¬¡æ•°ã€‚ å­ä»»åŠ¡ 222 çš„è¯¢é—®ä»£ä»·ä¸è¯¢é—®çš„å€¼åŸŸæœ‰å…³ã€‚å…ˆé—®å‡º a1,ana_1,a_na1â€‹,anâ€‹ï¼Œæ­¤æ—¶ç­”æ¡ˆçš„æœ€å°æ˜¯ âŒˆanâˆ’a1nâˆ’1âŒ‰\\left\\lceil\\cfrac{a_n-a_1}{n-1}\\right\\rceilâŒˆnâˆ’1anâ€‹âˆ’a1â€‹â€‹âŒ‰ã€‚å°†å€¼åŸŸåºåˆ—åˆ†å—ï¼Œæ¯å—çš„å¤§å°æ˜¯æœ€å°ç­”æ¡ˆï¼Œä¾æ¬¡æŸ¥è¯¢æ¯å—çš„ç­”æ¡ˆï¼Œåªæœ‰å—å†…æœ€å°å€¼å‡å»ä¹‹å‰çš„æœ€å¤§å€¼æ‰å¯èƒ½æ˜¯ç­”æ¡ˆï¼ˆå—å†…è‡ªå·±æ²¡æœ‰ç­”æ¡ˆï¼Œå› ä¸ºå—çš„é•¿åº¦å°äºæœ€å°ç­”æ¡ˆï¼‰ã€‚ä»£ç ã€‚ æ’æ›² å¤§æ„äº†ï¼Œå‘ç°è‡ªå·±å¥½åƒä¸€ä¸ªä¸Šåˆä»€ä¹ˆéƒ½æ²¡å¹²ï¼Œå°±å†™äº†ä¸¤é“å¤§æ°´é¢˜ï¼ˆ11/27ï¼‰ã€‚ å¬äº†ä¸€äº›æ¯”è¾ƒå¥‡æ€ªçš„æ­Œã€‚ ä¸‹åˆå’Œæ™šä¸Šæ€ä¹ˆåŠå•Šã€‚ [CF1063F] String Journey Portal. å¯ä»¥å‘ç°ç­”æ¡ˆæœ€å¤§åªæœ‰ O(n)O(\\sqrt{n})O(nâ€‹)ï¼Œä¸” ttt çš„é•¿åº¦ä¸€å®šæ˜¯ ans,ansâˆ’1,â‹¯ ,1ans,ans-1,\\cdots,1ans,ansâˆ’1,â‹¯,1ã€‚ é‚£ä¹ˆæšä¸¾ç­”æ¡ˆï¼Œè®¾ fans,if_{ans,i}fans,iâ€‹ è¡¨ç¤ºå½“å‰ç­”æ¡ˆä¸º ansansans æ—¶ä»¥ iii å¼€å¤´çš„åç¼€æ˜¯å¦å¯è¡Œã€‚æŒ‡é’ˆ iii ä»åå¾€å‰æ‰« sssï¼Œç»´æŠ¤ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œå‘å…¶ä¸­æ’å…¥é•¿åº¦ä¸º ansâˆ’1ans-1ansâˆ’1 çš„ä¸ä¸ [i,i+ansâˆ’1][i,i+ans-1][i,i+ansâˆ’1] é‡å çš„å­ä¸²ï¼ˆå‰ææ˜¯å®ƒçš„åç¼€æ˜¯åˆæ³•çš„ï¼‰ï¼Œ ä½¿ç”¨ bitset æ¥å®ç°å“ˆå¸Œè¡¨ï¼Œç„¶åæä¸€ä¸ªæ¯”è¾ƒå°çš„æ¨¡æ•°ï¼Œä»£ç ã€‚ æ— çŸ¥æ—¶è¯‹æ¯åŸç¥ Portal. åªä¼šåšæ°´é¢˜ã€‚ æ‰“è¡¨å‘ç° nnn ä¸ºå¶æ•°æ—¶æ— è§£ï¼Œå¥‡æ•°æ—¶æ„é€  ai=nâˆ’ciâˆ’1,bi=(ciâˆ’ai) mod na_i=n-c_i-1,b_i=(c_i-a_i)\\bmod naiâ€‹=nâˆ’ciâ€‹âˆ’1,biâ€‹=(ciâ€‹âˆ’aiâ€‹)modn å³å¯ã€‚ä»£ç ã€‚ [CF628D] Magic Numbers Portal. åªä¼šåšæ°´é¢˜ã€‚ ç›´æ¥æ•°ä½ DP å³å¯ã€‚ä»£ç ã€‚ [CF1063C] Dwarves, Hats and Extrasensory Abilities Portal. åªä¼šåšæ°´é¢˜ã€‚ å°è¯•ç®€åŒ–é—®é¢˜ã€‚æˆ‘ä»¬å°†æ‰€æœ‰ç‚¹æ”¾åœ¨ä¸€æ¡ç›´çº¿ä¸Šï¼Œç„¶åç›´æ¥äºŒåˆ†å°±è¡Œã€‚ä»£ç ã€‚ ED ä¸è¦å¤ªæ™šï¼Œæ‚é¢˜å·®ä¸å¤šå¾—äº†ï¼Œæ™šä¸Šè¿˜æœ‰å…¶å®ƒä»»åŠ¡ã€‚ ä½†æ„Ÿè§‰å•¥éƒ½æ²¡åšå•Šï¼ï¼å¸Œæœ›ä¹‹åèƒ½å¤Ÿæœ‰æ‰€æ”¹å–„å§ï¼ï¼ åŒå­¦æ¯å¤©éƒ½å¥½å‡â€¦â€¦ä¸€ä¸ªä¸Šåˆä¸€å¥— AGC/Div1 çš„è¯´è‡ªå·±æ‘†çš„éƒ½æ˜¯ä»€ä¹ˆæ„æ€ã€‚ å…¶å®ä¹Ÿå¥½ï¼Œæ„Ÿè°¢å¤§å®¶çš„æš´å·é€¼ç€æˆ‘ä¸å†é‚£ä¹ˆæ‘†çƒ‚ã€‚ è®©å‘½è¿ç»§ç»­è½®è½¬ä¸‹å»å§ã€‚ä¸è¦æ˜¨å¤©ç«‹ä¸‹çš„èª“è¨€ä»Šå¤©å°±å¿˜è®°å•Šï¼ï¼","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"NOIP2023 æ¸¸è®°","slug":"summaries/æ¸¸è®°/noip2023","date":"2023-11-18T00:00:00.000Z","updated":"2023-11-18T00:00:00.000Z","comments":true,"path":"59a069d8/","link":"","permalink":"https://james1badcreeper.github.io/59a069d8/","excerpt":"æ‘˜è¦ï¼šä¸çŸ¥é“ã€‚","text":"æ‘˜è¦ï¼šä¸çŸ¥é“ã€‚ Day -INF è¢«æ”¯åŸä½“æ„ŸæŸ“äº†ï¼Œåœ¨å®¶èººäº†è‹¥å¹²å¤©ã€‚ Day 1 æ—©ä¸Šæ¯”è¾ƒèµ¶ï¼Œåˆ°äº†å°±è¿›è€ƒåœºäº†ã€‚ å¸å–ä¸Šæ¬¡ CSP å¿«è¯»å†™æŒ‚çš„æ•™è®­ï¼Œè¿™æ¬¡å…ˆæ‰‹æŠŠæ¿å­ç»™å†™äº†ã€‚ å¼€é¢˜ï¼Œå…ˆæ‰«äº†ä¸€çœ¼ï¼Œæ„Ÿè§‰æ¯”è¾ƒå¸¸è§„ï¼Œç„¶åå¤§æ¦‚ 15min è¿‡æ‰äº† T1ã€‚ çœ‹ T2ï¼Œç¨å¾®æƒ³äº†æƒ³ä¹‹åå¾ˆå¿«èƒ¡å‡ºäº†ä¸€ä¸ªç»“è®ºï¼Œå†™äº†ä¸Šå»ä¹‹åå‘ç°æ˜¯é”™çš„ã€‚ ç„¶åå¯¹ç€æ ·ä¾‹ç©ï¼Œè¿™æ—¶å¤§æ¦‚ç©å‡ºäº†åšæ³•ï¼Œç¨å¾®æ€»ç»“äº†ä¸€äº›æ€§è´¨ï¼Œå¤§æ¦‚å°±æ˜¯æ™®é€šæ ‘æŸ“è‰²åŸºç¯æ ‘åˆ¤ç¯ä¹‹ç±»çš„ä¸œè¥¿ï¼Œç„¶åå¼€å§‹å†™ã€‚å¹¸è¿çš„æ˜¯æ²¡æ€ä¹ˆè°ƒè¯•å°±å¯¹äº†ï¼ˆç¯çš„åœ°æ–¹å†™é”™äº†ä¸€ä¸ªï¼‰ï¼Œä½†æ˜¯é€Ÿåº¦è¿˜æ˜¯æ¯”è¾ƒæ…¢ï¼Œè¿™æ—¶å¤§æ¦‚è¿‡å»äº† 2hã€‚ ç„¶åæ‰“ç®— T3 T4 åŒæ—¶çœ‹ã€‚å‰è€…æ„Ÿè§‰åŒæŒ‡é’ˆæ‰«ä¸€ä¸‹å°±è¡Œï¼Œä½†æ˜¯åæ¥å‘ç°ä¸å¤ªå¯¹ã€‚åè€…ç›´æ¥æš´åŠ› DP å°±æœ‰ 363636ï¼Œç„¶åçœ‹èµ·æ¥åƒæ˜¯çº¿æ®µæ ‘ä¼˜åŒ– DP æ•´ä½“è½¬ç§»ä¹‹ç±»çš„ä¸œè¥¿ï¼Œå†™äº†ä¸€ä¸‹è½¬ç§»æ–¹ç¨‹å‘ç°æ¯”è¾ƒéº»çƒ¦ï¼Œè€Œä¸”ç¦»æ•£åŒ–ä¹‹åä¹Ÿä¸å¤ªæ¸…æ¥šæ€ä¹ˆæï¼Œæ„Ÿè§‰ä¸æ˜¯æˆ‘èƒ½å†™å‡ºæ¥çš„ä¸œè¥¿ï¼Œå»æƒ³ T3 çš„æ”¶ç›Šæ¯”è¾ƒé«˜ã€‚ T3 å…ˆæäº†ä¸ªå•æ¬¡ O(n2)O(n^2)O(n2) çš„ 353535 çš„æš´åŠ› DPï¼Œç„¶åæƒ³ä¸€æƒ³æ€ä¹ˆä¼˜åŒ–ï¼Œä½†æ˜¯ä¸ä¼šã€‚ å°è¯•åŒæŒ‡é’ˆèƒ½ä¸èƒ½æ‰«è¿‡è¿™ä¸ªç‰¹æ®Šæ€§è´¨ï¼Œä½†æ˜¯æ€æ ·éƒ½ä¸å¯¹ã€‚äºæ˜¯å»ç»™ T4 è¡¥äº†ä¸€ä¸ªä¸äº¤çš„éƒ¨åˆ†åˆ†ï¼Œè¿™æ—¶å€™å¤§æ¦‚è¿˜å‰©ä¸€ä¸ªå°æ—¶ã€‚ å¼€å§‹åœ¨ T3 å’Œ T4 ä¹‹é—´éšæœºæ¸¸èµ°ï¼Œä½†æ˜¯æ„Ÿè§‰ T4 æä¸å‡ºæ¥ä»€ä¹ˆä¸œè¥¿ã€‚äºæ˜¯å¼€å§‹éšå³æšä¸¾ T3 ç‰¹æ®Šæ€§è´¨çš„æ­£ç¡®åšæ³•ï¼Œç»“æœæœ€åçŒœå‡ºä¸€ä¸ªå……è¦æ¡ä»¶ï¼ˆå‰ç¼€æœ€å€¼ä¹‹ç±»çš„ä¸œè¥¿ï¼‰è¿‡æ‰äº†å¤§æ ·ä¾‹ã€‚ å°è¯•æ‰©å±•è¿™ä¸ªåšæ³•ï¼Œä½†æ˜¯è¯•äº†å‡ ä¸ªæ–¹å¼éƒ½ä¸å¤ªå¯¹ï¼Œäºæ˜¯æ£€æŸ¥æ–‡ä»¶åï¼Œå‡†å¤‡äº¤å·ã€‚ å¬åˆ°å¤§å®¶éƒ½è¯´ï¼šè¿™æ¬¡æ€ä¹ˆè¿™ä¹ˆæ°´ï¼ŒT3 T4 ä¸éƒ½æ˜¯å‚»å­é¢˜å—ï¼Ÿäºæ˜¯èµ¶ç´§èƒŒåŒ…èµ°äººã€‚ èµ›æ—¶çœ‹é”™ T4 æ•°æ®ç‚¹çš„ä¸ªæ•°äº†ï¼Œæ‰€ä»¥å®é™…ä¸Šæ˜¯ 100+100+70+44=314100 + 100 + 70 + 44 = 314100+100+70+44=314ï¼Œåæ¥å›å­¦æ ¡é—®äº†ä¸€åœˆï¼Œå¥½åƒæ¯”è¾ƒåƒåœ¾ã€‚ è€Œä¸”è¿˜æŒ‚äº†ä¸€å †åˆ†ï¼ˆå¤§çº¦åœ¨ 48âˆ¼6848\\sim 6848âˆ¼68 ä¹‹é—´ï¼‰ï¼Œè¿™ä¸‹å®Œè›‹äº†ã€‚ æè¿° è¿™æ¬¡çš„å‘æŒ¥æ€»ä½“æ¥è¯´æ¯”è¾ƒå¸¸è§„ï¼Œæˆ‘åº”è¯¥å†™å‡ºæ¥çš„éƒ½å†™å‡ºæ¥äº†ï¼Œæˆ‘ä¸å¤ªä¼šçš„ä¹Ÿæ²¡æœ‰å¤šä¼šã€‚ å®é™…ä¸Šå°±æ˜¯æ²¡æ°´å¹³ï¼Œé—®ä¸ºä»€ä¹ˆæ²¡æ°´å¹³ï¼Ÿç»ƒå°‘äº†ã€‚ æ¥ä¸‹æ¥çš„è®¡åˆ’ä¼šå‘åœ¨ timeline æ—¶é—´çº¿ä¸Šï¼ˆä¸ä¸€å®šï¼Œä¹Ÿå¯èƒ½ä¸å‘ï¼‰ã€‚ æ›´å¤šçš„ï¼Œä¸å¤ªæƒ³è¯´äº†ã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"Codeforces Div.1 å¤§åˆé›†","slug":"default/åšé¢˜è®°å½•/CF/d1-1","date":"2023-11-08T00:00:00.000Z","updated":"2023-11-18T00:00:00.000Z","comments":true,"path":"d0ee0fdb/","link":"","permalink":"https://james1badcreeper.github.io/d0ee0fdb/","excerpt":"å¸Œæ–¯å¡”çš„å¤ªé˜³æ°¸è¿œä¸ä¼šè½ä¸‹ï¼","text":"å¸Œæ–¯å¡”çš„å¤ªé˜³æ°¸è¿œä¸ä¼šè½ä¸‹ï¼ PART I æ¢å¤ï¼æ¢å¤ï¼ *1893 (Div. 1) https://codeforces.com/contest/1893ã€‚ A. Anonymous Informant è€ƒè™‘å°† bbb åºåˆ—è¿˜åŸæˆ aaa åºåˆ—ã€‚ä¸€æ¬¡ç§»åŠ¨åï¼Œç§»åŠ¨çš„é‚£ä¸ªæ•°ä¸€å®šè·‘åˆ°äº†åºåˆ—çš„æœ«å°¾ï¼Œæ ¹æ®å®ƒè¿˜åŸå³å¯ã€‚ä»£ç ã€‚ B. Neutral Tonality ç­”æ¡ˆçš„ä¸‹ç•Œæ˜¯ aaa çš„ LIS é•¿åº¦ï¼Œæˆ‘ä»¬çœ‹çœ‹æ˜¯å¦èƒ½å¤Ÿè®©ç­”æ¡ˆå°±æ˜¯è¿™ä¸ªã€‚ ç”±äº bbb å¯ä»¥éšä¾¿åŠ ï¼Œå› æ­¤å°† bbb ä»å¤§åˆ°å°æ’åºï¼Œè¿™æ ·èƒ½ä¿è¯ bbb è‡ªèº«ä¸ä¼šè´¡çŒ® LIS çš„é•¿åº¦ã€‚å¦‚æœåœ¨ aia_iaiâ€‹ å‰é¢æ‰”ä¸€ä¸ªæ‰€æœ‰æ•°éƒ½æ¯” aia_iaiâ€‹ å¤§çš„ä¸‹é™åºåˆ—ï¼Œé‚£ä¹ˆæ­¤æ—¶å°† aia_iaiâ€‹ é€‰è¿› LIS é‡Œåªå¯èƒ½æ¯”å°†ä¸‹é™åºåˆ—çš„ä»»ä½•ä¸€ä¸ªæ•°é€‰è¿› LIS çš„é•¿åº¦æ›´é•¿ï¼Œå› æ­¤è¿™æ ·å°† bbb æ‰”è¿› aaa é‡Œä¸€å®šä¸ä¼šä½¿ LIS å˜é•¿ã€‚æœ€åå°†å‰©ä½™çš„ bbb æ‰”åˆ° aaa æœ«å°¾ï¼ŒåŒæŒ‡é’ˆåˆå¹¶ a,ba,ba,b å³å¯ã€‚ä»£ç ã€‚ C.","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"Codeforces","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/Codeforces","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/Codeforces/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"ARC ä¸“é¢˜ï¼ˆ4 é¢˜åœºï¼‰","slug":"default/åšé¢˜è®°å½•/AT/arc01","date":"2023-11-03T00:00:00.000Z","updated":"2023-11-23T00:00:00.000Z","comments":true,"path":"c76fc545/","link":"","permalink":"https://james1badcreeper.github.io/c76fc545/","excerpt":"â€œæœ¬ç€é¢˜æ˜¯ç”¨æ¥åšçš„åŸåˆ™ï¼Œæˆ‘ä»¬ä»è¿œå¤æ—¶æœŸçš„ 4 é¢˜åœºå¼€å§‹ã€‚â€","text":"â€œæœ¬ç€é¢˜æ˜¯ç”¨æ¥åšçš„åŸåˆ™ï¼Œæˆ‘ä»¬ä»è¿œå¤æ—¶æœŸçš„ 4 é¢˜åœºå¼€å§‹ã€‚â€ PART I ä»€ä¹ˆä¸œè¥¿å‘¢ã€‚ ARC064 https://atcoder.jp/contests/arc064/tasksã€‚ VP é€šè¿‡ ABCï¼Œperf 2489ï¼Œæ„Ÿè§‰ä¸€èˆ¬ã€‚ A åƒäº†ä¸€å‘ç½šæ—¶ï¼Œæ²¡æ³¨æ„åˆ° a1&gt;xa_1&gt;xa1â€‹&gt;xï¼Œæ³¨æ„ç»†èŠ‚ï¼ï¼ D ç¡®å®ä¸æ˜¯æˆ‘èƒ½æƒ³å‡ºæ¥çš„ä¸œè¥¿ã€‚ B. An Ordinary Game Portal. å¦™å“‰ï¼Œå¦™å“‰ï¼ æ‰‹é€ å‡ ä¸ªä¸œè¥¿å‘ç°æœ€ç»ˆä¹‹å’Œä¸¤ç«¯çš„ä¸œè¥¿æ˜¯å¦ç›¸ç­‰å’Œé•¿åº¦çš„å¥‡å¶æ€§æœ‰å…³ï¼Œè®¨è®ºä¸€ä¸‹ä¸éš¾å¾—åˆ°ç­”æ¡ˆã€‚ ä»£ç ã€‚ C. Cosmic Rays Portal. è€ƒè™‘åœ†å¤–çš„ä¸€ç‚¹å¦‚ä½•èµ°åˆ°åœ†å†…çš„è·ç¦»æ˜¯æœ€çŸ­çš„ï¼šå¾ˆç®€å•ï¼Œå°†å®ƒå’Œåœ†å¿ƒè¿çº¿å³å¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å°†æ‰€æœ‰åœ†éƒ½çœ‹ä½œåœ†å¿ƒä¸€ä¸ªç‚¹ï¼Œæ±‚å‡ºçš„è·ç¦»å¿…å®šæ˜¯æœ€çŸ­è·ç¦»ã€‚ æšä¸¾ä»»æ„ä¸¤ä¸ªåœ†å’Œèµ·ç‚¹ç»ˆç‚¹ï¼Œè®¡ç®—å‡ºå®ƒä»¬ä¹‹é—´çš„æš´éœ²åœ¨å®‡å®™å°„çº¿ä¸­çš„è·ç¦»ï¼Œç„¶ååœ¨è¿™å¼ å®Œå…¨å›¾ä¸Šç›´æ¥æš´åŠ› Dijkstra æ±‚å‡ºæœ€çŸ­è·¯å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ O(n2)O(n^2)O(n2)ã€‚ä»£ç ã€‚ D. Rotated Palindromes Portal. è€ƒè™‘å¦‚ä½•ä¸é‡ä¸æ¼åœ°ç»Ÿè®¡ã€‚å¦‚æœä¸€ä¸ªå›æ–‡ä¸²æ˜¯ç”±å¤šä¸ªç›¸åŒçš„å›æ–‡ä¸²ç»„æˆçš„ï¼Œé‚£ä¹ˆè®¾å®ƒçš„æœ€å°å¾ªç¯èŠ‚é•¿åº¦ä¸º tttï¼Œé‚£ä¹ˆå°†å…¶ç§»åŠ¨ ttt æ¬¡åå°±ä¼šå˜æˆåŸæ¥çš„å›æ–‡ä¸²ã€‚ è®¾ fif_ifiâ€‹ è¡¨ç¤ºé•¿åº¦ä¸º iii çš„å›æ–‡ä¸²ä¸ªæ•°ï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘ iii ä¸º nnn çš„çº¦æ•°çš„æƒ…å†µã€‚ é•¿åº¦ä¸º iii çš„å›æ–‡ä¸²æœ‰ kâŒˆi/2âŒ‰k^{\\lceil i/2 \\rceil}kâŒˆi/2âŒ‰ ç§ï¼Œæ ¹æ®ä¸Šé¢æ‰€è¯´çš„ä¸é‡ä¸æ¼ï¼Œå®¹æ–¥å¾—åˆ° fi=kâŒˆi/2âŒ‰âˆ’âˆ‘jâˆ£ifjf_i=k^{\\lceil i/2 \\rceil}-\\sum_{j\\mid i} f_jfiâ€‹=kâŒˆi/2âŒ‰âˆ’âˆ‘jâˆ£iâ€‹fjâ€‹ã€‚ å¦‚ä½•ç»Ÿè®¡ç­”æ¡ˆï¼Ÿå¦‚æœ iii æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆæ“ä½œ iii æ¬¡ä¹‹åæ‰€æ„æˆçš„ä¸²å‡ä¸ç›¸åŒï¼Œç³»æ•°ä¸º iiiï¼›å¦‚æœ iii æ˜¯å¶æ•°ï¼Œé‚£ä¹ˆæ“ä½œ i/2i/2i/2 æ¬¡ä¹‹åä¼šå˜æˆä¸€ä¸ªæ–°çš„å›æ–‡ä¸²ï¼Œä¸ºäº†é˜²æ­¢ç®—é‡ï¼Œå…¶ç³»æ•°ä¸º i/2i/2i/2ã€‚ä»£ç ã€‚ ARC065 https://atcoder.jp/contests/arc065/tasksã€‚å¦™å“‰ï¼ VP é€šè¿‡ ABDï¼ŒC ä¸çŸ¥é“æ˜¯ä¸ªä»€ä¹ˆã€‚ perf 2762ï¼Œæ„Ÿè§‰è¿˜è¡Œã€‚ B. Connectivity Portal. åªæœ‰ä¸€ä¸ªä¸œè¥¿ä¸éš¾æƒ³åˆ°ä½¿ç”¨å¹¶æŸ¥é›†ç»´æŠ¤ã€‚ ä¸¤ä¸ªä¿¡æ¯åªéš¾åœ¨å¦‚ä½•ç»Ÿè®¡ã€‚åªè¦çŸ¥é“å…¶åœ¨ä¸¤ä¸ªä¿¡æ¯é‡Œçš„ç¼–å·å°±å¯ä»¥ç¡®å®šå½“å‰ç‚¹çš„è¿é€šå—äº†ã€‚é‚£ä¹ˆå¼€ä¸€ä¸ª map&lt;pair&lt;int, int&gt;, int&gt;ï¼Œæ¥ä»£è¡¨ä¸€ä¸ª pair&lt;int, int&gt;ï¼Œå³åˆ†åˆ«ç»™å®šå…¶é“è·¯å’Œåœ°é“çš„è¿é€šå—æ‰€å¯¹åº”çš„â€œå¤§è¿é€šå—â€çš„ç‚¹æ•°ã€‚ä»£ç ã€‚ C. Manhattan Compass Portal. ç»™å®šå¹³é¢ä¸Šçš„ nnn ä¸ªç‚¹ï¼Œé€‰æ‹©ä¸¤ä¸ªç‚¹æ»¡è¶³å…¶æ›¼å“ˆé¡¿è·ç¦»ç­‰äº dddï¼Œæ±‚æ–¹æ¡ˆæ•°ã€‚ å°†æ›¼å“ˆé¡¿è·ç¦»è½¬ä¸ºåˆ‡æ¯”é›ªå¤«è·ç¦»ï¼Œæ’åºäºŒåˆ†ä¸éš¾æ‰¾å‡ºåˆæ³•çš„ç‚¹çš„åŒºé—´ã€‚å¦‚ä½•æ±‚æ–¹æ¡ˆæ•°ï¼Ÿå¯¹äº iii æ‰€å¯¹åº”çš„åˆæ³•åŒºé—´ [l,r][l,r][l,r]ï¼Œiii å‘ lll è¿è¾¹ï¼Œç„¶ååŒºé—´å†…ä¾æ¬¡è¿è¾¹ã€‚å¯¹äºè¿åˆ°äº† aaa ç‚¹çš„ç‚¹ï¼Œå…¶æ–¹æ¡ˆæ•°å‡å¯ä»¥è¢«ç»Ÿè®¡ã€‚ ä¸ºäº†é¿å…é‡å¤ç»Ÿè®¡ï¼Œéœ€è¦æ³¨æ„å¯¹äº yyy ç»Ÿè®¡æ—¶ä¸èƒ½è®¡ç®— xxx ç›¸ç­‰çš„æƒ…å†µã€‚ä»£ç ã€‚ D. Shuffling Portal. è€ƒè™‘ O(n2)O(n^2)O(n2) çš„ DPã€‚è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨å‰ iii ä¸ªæ•°å¡«äº† jjj ä¸ª 111 çš„æ–¹æ¡ˆæ•°ã€‚è½¬ç§»æ˜¾ç„¶æ˜¯ fi,j=fiâˆ’1,j+fiâˆ’1,jâˆ’1f_{i,j}=f_{i-1,j}+f_{i-1,j-1}fi,jâ€‹=fiâˆ’1,jâ€‹+fiâˆ’1,jâˆ’1â€‹ã€‚ é—®é¢˜åœ¨äºä»€ä¹ˆæ ·çš„ jjj æ˜¯åˆæ³•çš„ã€‚é¢„å¤„ç†å‡ºæ¯ä¸ªå·¦ç«¯ç‚¹å¯ä»¥â€œæ”¯é…â€åˆ°çš„å³ç«¯ç‚¹ï¼Œè¿™éƒ¨åˆ†ä»¥å†…æ˜¯å¯ä»¥éšä¾¿äº¤æ¢çš„ã€‚æ˜¾ç„¶ï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ªå¯äº¤æ¢åŒºé—´ [l,r][l,r][l,r]ï¼Œé‚£ä¹ˆ âˆ€xâˆˆ[l,r]\\forall x\\in [l,r]âˆ€xâˆˆ[l,r]ï¼Œxxx éƒ½èƒ½å¤Ÿæ”¯é…åˆ° rrrã€‚ æ‰«æåˆ°ç¬¬ iii ä¸ªä½ç½®æ—¶ï¼Œ111 çš„ä¸ªæ•°æœ€å¤šæ˜¯å°†æ”¯é…èŒƒå›´å†…çš„ 111 å…¨éƒ¨æè¿‡æ¥ï¼ˆå½“ç„¶ä¸èƒ½è¶…è¿‡ iiiï¼‰ï¼Œæœ€å°‘æ˜¯èƒ½æ‰”å‡ºå¤šå°‘ 111 åˆ°æ”¯é…èŒƒå›´å°±æ‰”å¤šå°‘ï¼ˆå½“ç„¶ä¸èƒ½å°‘äº 000ï¼‰ï¼Œç›´æ¥è½¬ç§»å³å¯ã€‚ ä»£ç ã€‚ ARC067 https://atcoder.jp/contests/arc067/tasksã€‚ VP é€šè¿‡ ABCã€‚å‰æœŸç½‘æœ‰ç‚¹å¡ï¼Œåé¢ C åšçš„å¤ªæ…¢äº†ï¼Œå¯¼è‡´ç”šè‡³æ²¡æœ‰è§åˆ° Dï¼Œæœ‰ç‚¹å¤§å¤±è´¥ã€‚ perf 2121ï¼Œæ„Ÿè§‰ä¸€èˆ¬ã€‚ C. Grouping Portal. å‘ç°æ•°æ®èŒƒå›´å¾ˆå°ï¼Œå› æ­¤ç›´æ¥è€ƒè™‘æš´åŠ› DPã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨è€ƒè™‘åˆ°åˆ†äººæ•°ä¸º iii çš„ç»„ï¼Œå½“å‰æœ‰ jjj ä¸ªäººçš„æ–¹æ¡ˆæ•°ã€‚å†³ç­–æœ‰ä¸¤ç§ï¼šä¸å­˜åœ¨è¿™ä¸ªäººæ•°çš„ç»„ï¼Œè¿™ä¸ªäººæ•°çš„ç»„çš„ä¸ªæ•°åœ¨ [c,d][c,d][c,d] ä¹‹é—´ã€‚é‚£ä¹ˆæœ‰ï¼š fi,j=fiâˆ’1,j+âˆ‘j=cdfiâˆ’1,jâˆ’ki(nâˆ’(jâˆ’ki)ki)gi,kf_{i,j}=f_{i-1,j}+\\sum_{j=c}^d f_{i-1,j-ki}\\binom{n-(j-ki)}{ki}g_{i,k} fi,jâ€‹=fiâˆ’1,jâ€‹+j=câˆ‘dâ€‹fiâˆ’1,jâˆ’kiâ€‹(kinâˆ’(jâˆ’ki)â€‹)gi,kâ€‹ ç»„åˆæ•°ä»£è¡¨åœ¨å‰©ä½™çš„äººä¸­é€‰æ‹© kikiki ä¸ªäººæ¥å®Œæˆäººæ•°ä¸º iii çš„ç»„çš„å¡«å……ï¼Œgi,kg_{i,k}gi,kâ€‹ ä»£è¡¨å°† kikiki ä¸ªäººåˆ†æˆ kkk ç»„ï¼Œä¸€ç»„ iii ä¸ªäººçš„æ–¹æ¡ˆæ•°ã€‚ å…¶è®¡ç®—çš„è¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼šç°åœ¨ kikiki ä¸ªäººä¸­é€‰æ‹© iii ä¸ªäººï¼Œå†åœ¨ (kâˆ’1)i(k-1)i(kâˆ’1)i ä¸ªäººä¸­é€‰æ‹© iii ä¸ªäººâ€¦â€¦ç”±äºç»„ä¹‹é—´ä¸åŒºåˆ†ï¼Œå› æ­¤æœ€åé™¤æ‰ k!k!k! å»é‡ã€‚å› æ­¤ï¼š gi,k=âˆj=1k(jii)(ki)!g_{i,k}=\\frac {\\prod_{j=1}^k \\binom{ji}{i}} {(ki)!} gi,kâ€‹=(ki)!âˆj=1kâ€‹(ijiâ€‹)â€‹ ç›´æ¥é€’æ¨åˆ†å­ï¼Œåˆ†æ¯åœ¨è®¡ç®— fff æ—¶é™¤æ‰å³å¯ã€‚ç”±äºæšä¸¾ jjj çš„æ—¶å€™æ˜¯è°ƒå’Œçº§æ•°å¤æ‚åº¦ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º O(n2logâ¡n)O(n^2\\log n)O(n2logn)ã€‚ä»£ç ã€‚ D. Yakiniku Restaurants Portal. å‘ç°èµ°çš„å¿…å®šæ˜¯ä¸€æ¡çº¿æ®µã€‚ä»å³ç«¯ç‚¹å¼€å§‹æšä¸¾å·¦ç«¯ç‚¹ï¼Œç»´æŠ¤æ•°ç»„ ansians_iansiâ€‹ è¡¨ç¤ºå³ç«¯ç‚¹åœ¨ iii çš„æœ€ä¼˜ç­”æ¡ˆã€‚æ¯æ¬¡è€ƒè™‘æ˜¯å¦å°†è´¡çŒ®æ¢åˆ°å·¦ç«¯ç‚¹ï¼Œå•è°ƒæ ˆç»´æŠ¤å‰ç¼€æœ€å¤§å€¼æ¥è®¡ç®—è´¡çŒ®å³å¯ã€‚ä»£ç ã€‚ UPD å¯èƒ½ä¸æ›´æ–°äº†ï¼Œä»¥åçš„ ARC é¢˜ä¼šæ”¾åœ¨åŠ è®­è®°å½•é‡Œã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"ATCoder","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/ATCoder","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ATCoder/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"AGC ä¸“é¢˜","slug":"default/åšé¢˜è®°å½•/AT/agc01","date":"2023-10-27T00:00:00.000Z","updated":"2023-10-27T00:00:00.000Z","comments":true,"path":"86efec8d/","link":"","permalink":"https://james1badcreeper.github.io/86efec8d/","excerpt":"ç‰›é€¼é¢˜ä¸“é¢˜ã€‚","text":"ç‰›é€¼é¢˜ä¸“é¢˜ã€‚ PART I èœæ˜¯åŸç½ªã€‚ AGC 001 https://atcoder.jp/contests/agc001/tasksã€‚ B. Mysterious Light Portal. å…ˆç…§ä¸€æ¬¡ä¹‹åå°±æ˜¯å¹³è¡Œå››è¾¹å½¢ï¼Œç›´æ¥é€’å½’å³å¯ã€‚ä»£ç ã€‚ C. Shorten Diameter Portal. æŒ‰ç…§ç›´å¾„çš„å¥‡å¶æ€§æšä¸¾ç‚¹æˆ–è¾¹å³å¯ã€‚ä»£ç ã€‚ D. Arrays and Palindrome Portal. å‡ºç°ä¸¤ä¸ªä»¥ä¸Šçš„å¥‡æ•°æ— è§£ï¼Œå¦åˆ™é”™ä½ä¸€ä¸‹å°±è¡Œã€‚ä»£ç ã€‚ E. BBQ Hard Portal. å¯ä»¥æŠ½è±¡æˆ (0,0)â†’(ai+aj,bi+bj)(0,0)\\rightarrow(a_i+a_j,b_i+b_j)(0,0)â†’(aiâ€‹+ajâ€‹,biâ€‹+bjâ€‹)ï¼Œä¹Ÿå°±æ˜¯ (âˆ’ai,âˆ’bi)â†’(aj,bj)(-a_i,-b_i)\\rightarrow(a_j,b_j)(âˆ’aiâ€‹,âˆ’biâ€‹)â†’(ajâ€‹,bjâ€‹)ï¼Œå°±å¯ä»¥ç›´æ¥ç»Ÿè®¡äº†ã€‚ä»£ç ã€‚ * F. Wide Swap Portal. ä¸¤ä¸ªé™åˆ¶çœ‹ä¸Šå»å°±ä¸åƒæ˜¯äººèƒ½åšçš„ä¸œè¥¿ï¼Œå› æ­¤è€ƒè™‘æ„é€  QPi=iQ_{P_i}=iQPiâ€‹â€‹=iï¼Œç„¶åå°±å˜æˆäº¤æ¢ç›¸é‚»çš„æ•°å€¼ â‰¥k\\ge kâ‰¥k çš„æ•°äº†ã€‚ ç„¶åç›´æ¥å†’æ³¡è¿‡å»å°± TLE äº†ï¼Œæ”¹æˆå½’å¹¶å°±å¥½äº†ã€‚ä»£ç ã€‚ è¿™é‡Œå¤§è‡´è¯´ä¸€ä¸‹ä¸ºä»€ä¹ˆè¿™ä¸ªä¸œè¥¿æ˜¯å¯¹çš„ï¼Œå¦‚æœæƒ³è¦è®© PPP çš„å­—å…¸åºæœ€å°ï¼Œé‚£å°±åº”è¯¥è®©å€¼ 111 çš„ä¸‹æ ‡å°½å¯èƒ½å°ï¼Œä¹Ÿå°±æ˜¯ èœè‚´åˆ¶ä½œ çš„æ’åºæ–¹å¼ï¼Œå¯¹äºå†’æ³¡æ’åºæ¥è¯´ï¼Œæˆ‘ä»¬å¿…å®šä¼šå°† Qx=1Q_x=1Qxâ€‹=1 çš„ xxx æåˆ°å°½å¯èƒ½åœ°å°ã€‚å®é™…ä¸Šæ˜¯è¦æ±‚ QQQ çš„å­—å…¸åºæœ€å¤§ï¼ˆç¿»è½¬åï¼‰ã€‚ ç„¶åå¤§æ¦‚è®²è¿°ä¸€ä¸‹æœ¬é¢˜çš„æ­£å¸¸åšæ³•ï¼šå¦‚æœ âˆ£Qiâˆ’Qjâˆ£&lt;k|Q_i-Q_j|&lt;kâˆ£Qiâ€‹âˆ’Qjâ€‹âˆ£&lt;kï¼Œé‚£ä¹ˆç›¸å½“äºå®ƒä»¬ä¹‹é—´çš„é¡ºåºæ— æ³•è¿›è¡Œæ›´æ”¹ã€‚è¿™æ ·çš„è¯å¯ä»¥æšä¸¾ä¸¤ä¸ªä½ç½®ï¼Œæ»¡è¶³è¢«å®šæ­»çš„æ¡ä»¶åˆ™ä»å‰é¢å‘åé¢çš„ä½ç½®è¿è¾¹ï¼Œç„¶åå»ºåå›¾æ±‚å­—å…¸åºæœ€å¤§çš„æ‹“æ‰‘åºï¼ˆä½†å®é™…ä¸Šè¿™é“é¢˜ä¸­è¿™ç©æ„å„¿è·Ÿæ±‚ç›´æ¥æ±‚æœ€å°å­—å…¸åºæ‹“æ‰‘åºæ˜¯ç­‰ä»·çš„ï¼Œè¯æ˜å¯ä»¥åè¯ï¼Œä¹Ÿæ¯”è¾ƒå¥½è¯ã€‚ä¹Ÿæ­£æ˜¯è¿™ä¸ªåŸå› ï¼Œæ’åºåšæ³•æ‰å¾—ä»¥æˆç«‹ï¼Œå¦åˆ™è®©æ’åºæ¥åšä¸€ä¸ªå°†å…¶å˜æˆå­—å…¸åºæœ€å¤§çš„ä¸œè¥¿æ˜¯åšä¸äº†ä¸€ç‚¹çš„ï¼‰ã€‚ å¯¹äºæ­£å¸¸åšæ³•æ¥è¯´ï¼Œè€ƒè™‘çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾ã€‚å€’åºæšä¸¾ iiiï¼Œç„¶åæ‰¾å‡º [aiâˆ’k+1,ai+kâˆ’1][a_{i}-k+1,a_{i}+k-1][aiâ€‹âˆ’k+1,aiâ€‹+kâˆ’1] ä¸­ &gt;i&gt;i&gt;i çš„æœ€å°å€¼ xxxï¼Œç„¶åå‘å®ƒä»¬è¿è¾¹ï¼ˆå…¶å®è¦åˆ†åˆ«æ‰¾ä¸¤è¾¹ï¼‰ã€‚ä¸éš¾å‘ç°è¿™æ ·å°±å¯ä»¥åˆ»ç”»åŸå›¾çš„è¿é€šæ€§ã€‚ä»£ç ã€‚ AGC 002 https://atcoder.jp/contests/agc002/tasksã€‚ D. Stamp Rally Portal. è¿™ä¸ªä¸œè¥¿ä¸éš¾æƒ³åˆ°äºŒåˆ†ç­”æ¡ˆã€‚å»ºç«‹å‡ºåŸºäºç‚¹æƒçš„ Kruskal é‡æ„æ ‘ï¼Œç„¶åç›´æ¥åšå°±è¡Œã€‚ä»£ç ã€‚ E. Candy Piles Portal. æŒºæœ‰æ„æ€çš„åšå¼ˆè®ºã€‚ å°†æƒå€¼ä»å¤§åˆ°å°æ’åºï¼Œå¯ä»¥è½¬åŒ–ä¸ºç½‘æ ¼å›¾ï¼Œé‚£ä¹ˆä» (0,0)(0,0)(0,0) å¼€å§‹ï¼Œæ“ä½œå°±ç›¸å½“äºå‘å³æˆ–å‘ä¸Šèµ°ä¸€æ­¥ã€‚ ä¸¤ç§æ“ä½œ è°èµ°åˆ°è¾¹ç•Œä¸Šçš„ç‚¹è°å°±è¾“äº†ï¼Œå› æ­¤å¦‚æœä»è¾¹ç•Œä¸Šçš„ç‚¹å¼€å§‹ï¼Œé‚£ä¹ˆåæ‰‹å¿…èƒœã€‚å¯¹äºä»»æ„ä¸€ä¸ªä¸åœ¨è¾¹ç•Œä¸Šçš„ç‚¹ï¼Œå¦‚æœå®ƒçš„ä¸Šé¢å’Œå³é¢éƒ½æ˜¯åæ‰‹å¿…èƒœç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹ä¸€å®šæ˜¯åæ‰‹å¿…è´¥ç‚¹ï¼Œå¦åˆ™ç»“æœç›¸åã€‚ çº¢è‰²åæ‰‹èƒœï¼Œè“è‰²å…ˆæ‰‹èƒœ æ‰¾åˆ°æœ€å¤§æ­£æ–¹å½¢ï¼Œç„¶åå‘ä¸Šå’Œå³æ‰©å±•å³å¯ã€‚ çº¢è‰² ä»£ç ã€‚ F. Leftmost Ball Portal. è€ƒè™‘æœ€ç»ˆå½¢æˆçš„åˆæ³•åºåˆ—ï¼Œä¸€å®šæ˜¯ kkk ä¸ªç™½è‰²çƒåŠ ä¸Š nnn ä¸­é¢œè‰²çš„çƒå„ kâˆ’1k-1kâˆ’1 ä¸ªï¼Œåˆæ³•æƒ…å†µæ˜¯å‰ç¼€ç™½çƒä¸ªæ•°å¤§äºç­‰äºå…¶å®ƒé¢œè‰²æ•°ã€‚ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤º iii ä¸ªç™½çƒï¼Œæ”¾äº† jjj ä¸ªé¢œè‰²çš„æ–¹æ¡ˆæ•°ã€‚ å†³ç­–æœ‰ä¸¤ç§ï¼š æ”¾ç½®ä¸€ä¸ªç™½çƒï¼Œæœ‰ fi,jâ†+fiâˆ’1,jf_{i,j}\\stackrel{+}{\\leftarrow} f_{i-1,j}fi,jâ€‹â†+fiâˆ’1,jâ€‹ï¼› åŠ å…¥æ–°é¢œè‰²çš„çƒï¼Œå³ä» fi,jâˆ’1f_{i,j-1}fi,jâˆ’1â€‹ è½¬ç§»ã€‚ç³»æ•°æ˜¯å¤šå°‘ï¼Ÿé¦–å…ˆéœ€è¦åœ¨ nâˆ’j+1n-j+1nâˆ’j+1 ä¸­é€‰æ‹©ä¸€ä¸ªä½œä¸ºè¿™æ—¶æ”¾ç½®çš„é¢œè‰²ï¼Œå°†å…¶ä¸­ä¸€ä¸ªæ”¾ç½®åœ¨ç¬¬ä¸€ä¸ªç©ºä½ï¼Œç„¶åå‰©ä¸‹çš„ kâˆ’2k-2kâˆ’2 ä¸ªåœ¨åé¢çš„ nkâˆ’iâˆ’(jâˆ’1)(kâˆ’1)âˆ’1nk-i-(j-1)(k-1)-1nkâˆ’iâˆ’(jâˆ’1)(kâˆ’1)âˆ’1 ä¸­æ‰¾ kâˆ’2k-2kâˆ’2 ä¸ªæ”¾å³å¯ã€‚ ç„¶åå°±å®Œäº†ã€‚ä»£ç ã€‚ UPD å¯èƒ½ä¸æ›´æ–°äº†ï¼Œä»¥åçš„ AGC é¢˜ä¼šæ”¾åœ¨åŠ è®­è®°å½•é‡Œã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"ATCoder","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/ATCoder","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ATCoder/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Codeforces Div.2 å¤§åˆé›†","slug":"default/åšé¢˜è®°å½•/CF/d2-1","date":"2023-10-27T00:00:00.000Z","updated":"2023-11-20T00:00:00.000Z","comments":true,"path":"5b081a8b/","link":"","permalink":"https://james1badcreeper.github.io/5b081a8b/","excerpt":"å¤©ä¸ç”Ÿå·ç‹ï¼Œä¸‡å¤å¦‚é•¿å¤œï¼","text":"å¤©ä¸ç”Ÿå·ç‹ï¼Œä¸‡å¤å¦‚é•¿å¤œï¼ PART I ä¸‹æ¬¡æ™šä¸Šæ—©ç‚¹ç¡ï¼ *1809 (EDU) https://codeforces.com/contest/1809ã€‚ D. Binary String Sorting ç›´æ¥æšä¸¾æ–­ç‚¹å³å¯è®¡ç®—ã€‚ä»£ç ã€‚ E. Two Tanks å¦‚æœ c+dc+dc+d å›ºå®šï¼Œé‚£ä¹ˆç­”æ¡ˆåº”è¯¥æ—¶éšç€ ccc çš„å¢åŠ å…ˆä¸å˜ï¼Œå†é€’å¢ï¼Œæœ€ååˆä¸å˜çš„é¡ºåºè¿›è¡Œçš„ï¼Œè€Œä¸”æ¯æ¬¡çš„å·®å€¼åªæœ‰ 111ã€‚æšä¸¾ c+dc+dc+dï¼Œæ‰¾å‡ºè¿™ä¸¤ä¸ªä½ç½®å³å¯ã€‚ä»£ç ã€‚ F. Traveling in Berland å¦‚æœå½“å‰ä½ç½®æ²¹ä»·æ˜¯ 111ï¼Œé‚£ä¹ˆè‚¯å®šèƒ½åŠ æ»¡å°±åŠ æ»¡ï¼ˆä¼šç”¨å®Œï¼‰ï¼Œ222 çš„è¯èƒ½åŠ å¤šå°‘åŠ å¤šå°‘ã€‚è®¾ fif_{i}fiâ€‹ ä»£è¡¨ iii åˆ°ä¸‹ä¸€ä¸ªæ²¹ä»·æ˜¯ 111 çš„ä½ç½®çš„ä½ç½®ï¼Œsis_{i}siâ€‹ ä»£è¡¨ä»£ä»·ï¼Œå€å¢è¿™ä¸ªè¿‡ç¨‹å³å¯ã€‚ä»£ç ã€‚ G. Prediction å¯¹äºä¸€ä¸ªåˆæ³•çš„æ’åˆ— pppï¼Œåˆ é™¤ apia_{p_i}apiâ€‹â€‹ æœ€å°çš„ pip_ipiâ€‹ï¼Œæ–°çš„ pâ€²p&#x27;pâ€² å¿…å®šåˆæ³•ã€‚ è®¾ fif_{i}fiâ€‹ ä»£è¡¨å¡«å®Œ (i,n](i,n](i,n] çš„æ–¹æ¡ˆæ•°ï¼Œåˆå§‹ fn=1f_n=1fnâ€‹=1ï¼Œè€ƒè™‘ aia_iaiâ€‹ å¡«çš„ä½ç½®ï¼š ä¸å¡«åœ¨å½“å‰ç¬¬ä¸€ä¸ªä½ç½®ï¼Œä¸å½±å“åé¢å…ƒç´ çš„å‰ç¼€ maxâ¡\\maxmaxï¼Œfiâˆ’1â†+fi(nâˆ’i)f_{i-1}\\stackrel{+}{\\leftarrow} f_{i}(n-i)fiâˆ’1â€‹â†+fiâ€‹(nâˆ’i)ï¼› å¡«åœ¨å½“å‰ç¬¬ä¸€ä¸ªä½ç½®ã€‚è®¾ lstilst_ilstiâ€‹ ä»£è¡¨æœ€å¤§çš„ jjj ä½¿å¾— aiâˆ’aj&gt;ka_i-a_j&gt;kaiâ€‹âˆ’ajâ€‹&gt;kï¼Œé‚£ä¹ˆ (lsti,i)(lst_i,i)(lstiâ€‹,i) éƒ½éœ€è¦å‡ºç°åœ¨ iii ä¹‹å‰ï¼Œåˆ™ iâˆ’lstiâˆ’1i-lst_i-1iâˆ’lstiâ€‹âˆ’1 éœ€è¦å¡«å…¥ nâˆ’lstiâˆ’2n-lst_i-2nâˆ’lstiâ€‹âˆ’2 ä¸ªæ•°ã€‚ åŒæŒ‡é’ˆæ±‚ lstlstlstï¼Œæ—¶é—´å¤æ‚åº¦ O(n)O(n)O(n)ã€‚ä»£ç ã€‚ *1856 (Div. 2) https://codeforces.com/contest/1856ã€‚ C. To Become Max nnn åªæœ‰ 100010001000ï¼Œæƒ³çš„æš´åŠ›ä¸€ç‚¹ï¼Œæšä¸¾æœ€ç»ˆæˆä¸ºç­”æ¡ˆçš„æ•° aia_iaiâ€‹ã€‚ä¸€å¼€å§‹è‚¯å®šè¦åˆ©ç”¨ ai+1a_{i+1}ai+1â€‹ è®© aia_iaiâ€‹ å˜å¾—å°½å¯èƒ½å¤§ï¼Œè¿™æ ·çš„ä»£ä»·æ˜¯æœ€å°çš„ã€‚å½“ ai&gt;ai+1a_i&gt;a_{i+1}aiâ€‹&gt;ai+1â€‹ æ—¶æ€ä¹ˆåŠï¼Ÿåˆ©ç”¨ ai+2a_{i+2}ai+2â€‹ è®© ai+1a_{i+1}ai+1â€‹ å˜å¤§ã€‚ å¦‚æœæ“ä½œæ¬¡æ•°è¶³å¤Ÿå¤šï¼Œé‚£ä¹ˆæœ€ç»ˆçš„åºåˆ—è‚¯å®šæ˜¯å½¢å¦‚ x,xâˆ’1,â‹¯ ,an+1,anx,x-1,\\cdots,a_n+1,a_nx,xâˆ’1,â‹¯,anâ€‹+1,anâ€‹ çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¾æ¬¡æšä¸¾ jâˆˆ[i+1,n]j\\in[i+1,n]jâˆˆ[i+1,n]ï¼Œå½“ ajâ‰¥ajâˆ’1a_j\\ge a_{j-1}ajâ€‹â‰¥ajâˆ’1â€‹ æ—¶ï¼Œè‡³å¤šå°±å¯ä»¥è®© aia_iaiâ€‹ å˜å¤§ ajâˆ’ajâˆ’1+1a_j-a_{j-1}+1ajâ€‹âˆ’ajâˆ’1â€‹+1ï¼Œæ­¤æ—¶æ›´æ–°ç­”æ¡ˆå³å¯ã€‚å¦‚æœä¸æ»¡è¶³ï¼Œaja_jajâ€‹ åœ¨åç»­çš„æ›´æ–°è¿‡ç¨‹ä¸­è‚¯å®šè¦å˜æˆ ajâˆ’1âˆ’1a_{j-1}-1ajâˆ’1â€‹âˆ’1ï¼Œå¦åˆ™æ— æ³•ä½¿ aia_iaiâ€‹ å˜å¾—æ›´å¤§ï¼Œæå‰æ›´æ–° aja_jajâ€‹ å³å¯ã€‚ä»£ç ã€‚ D. More Wrong çœ‹ä¸Šå»å°±å¾ˆåˆ†æ²»ã€‚å½“å‰ç‚¹ rrr åœ¨ [l,r][l,r][l,r] ä¸­æœ€å¤§çš„å……è¦æ¡ä»¶æ˜¯ Q(l,râˆ’1)=Q(l,r)Q(l,r-1)=Q(l,r)Q(l,râˆ’1)=Q(l,r)ï¼Œæ ¹æ®æ­¤åˆ†æ²»ä¸‹å»å³å¯ã€‚ä»£ç ã€‚ E. PermuTree åªè¦æ›´æ”¹å­æ ‘å†…çš„æƒå€¼åˆ†å¸ƒï¼Œå°±å¯ä»¥è¾¾åˆ°è´¡çŒ®æœ€å¤§åŒ–ï¼Œæ‰€ä»¥æ˜¯ä¸ªæ ‘ä¸ŠèƒŒåŒ…çŠ¶ç‰©ï¼Œå¯ä»¥é€šè¿‡ E1ï¼Œä»£ç ã€‚ å¯¹äº E2ï¼Œæˆ‘ä»¬è¦æ€è€ƒå¦‚ä½•é«˜æ•ˆè§£å†³â€œæŠŠå„¿å­å¤§å°æ„æˆçš„æ•°é›†åˆåˆ†æˆå·®å°½å¯èƒ½å°çš„ä¸¤éƒ¨åˆ†â€ã€‚å­æ ‘ä¸­ä¸åŒçš„ sizsizsiz æœ€å¤šåªæœ‰ n\\sqrt{n}nâ€‹ ç§ï¼ŒäºŒè¿›åˆ¶æ‹†åˆ†æ‰ä¿è¯ç‰©å“ä¸ªæ•°ä¸å¤šäº logâ¡n\\log nlogn ä¸ªï¼Œç„¶åæ˜¯å¯è¡Œæ€§èƒŒåŒ…é‡‡ç”¨ bitset ä¼˜åŒ–ï¼Œå•æ¬¡æ—¶é—´å¤æ‚åº¦æ˜¯ O(nnlogâ¡nw)O\\left(\\dfrac{n\\sqrt{n}\\log n}{w}\\right)O(wnnâ€‹lognâ€‹) çš„ã€‚ å¦‚ä½•å°†å…¶æ¬åˆ°æ ‘ä¸Šï¼Ÿç®€å•ã€‚å¦‚æœå­˜åœ¨ä¸€ä¸ªé‡å„¿å­ï¼Œå®ƒæ¯”æ‰€æœ‰è½»å„¿å­éƒ½é‡ï¼Œè¿™æ ·å¯ä»¥ç›´æ¥å¾—å‡ºç­”æ¡ˆã€‚å¦åˆ™ä¼šé€ æˆä¸€ä¸ªåˆ†æ²»çš„æ•ˆæœï¼Œæ¯æ¬¡é—®é¢˜è§„æ¨¡å¿…å®šå‡åŠï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nnlogâ¡2nw)O\\left(\\dfrac{n\\sqrt{n}\\log^2 n}{w}\\right)O(wnnâ€‹log2nâ€‹)ã€‚å®é™…æ•ˆç‡éå¸¸é«˜ã€‚ä»£ç ã€‚ *1354 (EDU) https://codeforces.com/contest/1354ã€‚ C2. Not So Simple Polygon Embedding å¤§è‡´æ€è·¯æ˜¯è§‚å¯Ÿè·å¾—å¤šè¾¹å½¢çš„æ—‹è½¬åº¦æ•°ï¼Œç„¶åè§£ä¸‰è§’å½¢ã€‚ä»£ç ã€‚ D. Multiset æƒå€¼æ ‘çŠ¶æ•°ç»„ç›´æ¥ç»´æŠ¤ã€‚ä»£ç ã€‚ E. Graph Coloring äºŒåˆ†å›¾æŸ“è‰²ï¼Œç„¶åèƒŒåŒ…åˆ¤æ–­å¯è¡Œæ€§ã€‚ä»£ç ã€‚ F. Summoning Minions å¿…å®šæ˜¯æ”¾æ»¡ kâˆ’1k-1kâˆ’1 å¼ åï¼Œæ‹¿å‰©ä¸‹çš„æ”¾å®Œå°±æ‰”ï¼ˆä¼šäº§ç”Ÿ bÃ—(kâˆ’1)b\\times (k-1)bÃ—(kâˆ’1) çš„è´¡çŒ®ï¼‰ï¼Œæœ€åå†æ”¾ä¸€å¼ ã€‚ æ”¾ç½®é¡ºåºå¿…å®šæ»¡è¶³ bbb é€’å¢ï¼ˆå¦åˆ™å¯ä»¥äº¤æ¢ï¼‰ï¼Œç„¶åæ ¹æ®æ­¤è¿›è¡Œ DPï¼šfi,jf_{i,j}fi,jâ€‹ ä»£è¡¨å‰ iii å¼ é€‰ jjj å¼ ä¸æ˜¯ç”¨å®Œå°±æ‰”çš„ã€‚ä»£ç ã€‚ G. Find a Gift å¦‚æœçŸ¥é“å…¶ä¸­ xxx ä¸ªæ˜¯çŸ³å¤´ï¼Œé‚£ä¹ˆå°±èƒ½ç”¨è¿™ xxx ä¸ªå»ç¡®å®šå¦å¤– xxx ä¸ªæ•°å½“ä¸­æœ‰æ²¡æœ‰çŸ³å¤´ã€‚å…ˆæ‰¾åˆ° 111 ä¸ªçŸ³å¤´ï¼Œç„¶åä»å¤´å¼€å§‹å€å¢æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ²¡æœ‰çŸ³å¤´çš„åŒºé—´ã€‚è¦ç¡®å®šè¿™æ®µæœ‰çŸ³å¤´çš„åŒºé—´çš„ç¬¬ 111 ä¸ªçŸ³å¤´ä½ç½®ï¼Œå¯ä»¥äºŒåˆ†ã€‚å¦‚ä½•æ‰¾åˆ°ä¸€ä¸ªçŸ³å¤´ï¼Ÿä¸çŸ¥é“ï¼Œé‡‡ç”¨éšæœºåŒ–ã€‚éšæœºæ‰¾åˆ°ä¸€äº›ä½ç½®ï¼Œæ‰¾åˆ°å½“ä¸­æœ€é‡çš„ï¼Œé‚£ä¹ˆå¯ä»¥ç¡®å®šé‚£ä¸ªæ˜¯çŸ³å¤´ã€‚ä»£ç ã€‚ *1848 (Div. 2) https://codeforces.com/contest/1848ã€‚ A. Vika and Her Friends å¶æ•°èƒ½æŠ“ã€‚ä»£ç ã€‚ B. Vika and the Bridge å­˜æ‰€æœ‰é¢œè‰²çš„ä½ç½®ã€‚ä»£ç ã€‚ C. Vika and Price Tags åœ¨ (0,b)â†’(b,b)â†’(b,0)(0,b)\\rightarrow (b,b)\\rightarrow (b,0)(0,b)â†’(b,b)â†’(b,0) ä¸­å¾ªç¯ï¼Œè¾—è½¬ç›¸é™¤å¤„ç†å³å¯ã€‚ä»£ç ã€‚ D. Vika and Bonuses ä»¥ 202020 ä¸ºå¾ªç¯èŠ‚ï¼Œæš´åŠ›æšä¸¾ï¼Œæ±‚æŠ›ç‰©çº¿çš„é¡¶ç‚¹ã€‚ä»£ç ã€‚ E. Vika and Stone Skipping å¦‚æœè·³ ggg æ¬¡ï¼Œéœ€è¦æ»¡è¶³ï¼š 2xâˆXi=(2fâˆ’g+1)g2x\\prod X_i=(2f-g+1)g 2xâˆXiâ€‹=(2fâˆ’g+1)g æ±‚çš„å°±æ˜¯ 2xâˆXi2x\\prod X_i2xâˆXiâ€‹ çš„å¥‡å› æ•°ä¸ªæ•°ã€‚ ç›´æ¥ç»´æŠ¤å³å¯ã€‚æ³¨æ„æ¨¡æ•°è¿‡å°æ—¶é€†å…ƒçš„çˆ†ç‚¸é—®é¢˜ã€‚ä»£ç ã€‚ F. Vika and Wiki æ¬¡æ•°è¶Šå¤§ä¸€å®šæ˜¯è¶Šè¶‹è¿‘äºå…¨ 000 çš„ï¼Œç›´æ¥å€å¢ç­”æ¡ˆå³å¯ã€‚ä»£ç ã€‚ *1837 (EDU) https://codeforces.com/contest/1837/ã€‚ C. Best Binary String ä¸éš¾çŒœåˆ°å°†æœ‰æ•°çš„ä¸œè¥¿å‘å·¦å³æ‰©å±•å°±æ˜¯ç­”æ¡ˆã€‚ä»£ç ã€‚ D. Bracket Coloring ä¸éš¾çŒœåˆ°ç­”æ¡ˆæœ€å¤§ä¸º 222ï¼Œæ ¹æ®æ­¤æ„é€ å³å¯ã€‚ä»£ç ã€‚ E. Playoff Fixing ä¸éš¾å‘ç° 2i,2i+12i,2i+12i,2i+1 æ˜¯ä¸€ç»„çš„ï¼Œå¹¶ä¸”è¿™ç©æ„å„¿å­˜åœ¨å­é—®é¢˜ã€‚ è®°å½•å¯ä»¥éšä¾¿å¡«çš„ä¸ªæ•°å’Œå¯ä»¥éšä¾¿æ’åˆ—çš„ä¸ªæ•°ä¾¿ä¸éš¾è®¡ç®—å‡ºè¿™ä¸€å±‚çš„æ–¹æ¡ˆæ•°ã€‚ä»£ç ã€‚ F. Editorial for Two äºŒåˆ†åŠ è´ªå¿ƒå³å¯ã€‚ä»£ç ã€‚ PART II å¤§æ‰“å‡ºæ‰‹ï¼ *1821 (EDU) https://codeforces.com/contest/1821ã€‚ E. Rearrange Brackets ä¸€å®šæ˜¯åˆ æ‰å³è¾¹çš„ ()ï¼Œå…¶è´¡çŒ®å°±æ˜¯å…¶æ·±åº¦ï¼ˆå¤–é¢å¥—äº†å¤šå°‘ä¸ªæ‹¬å·ï¼‰ã€‚ æ“ä½œæ˜¯ä»€ä¹ˆï¼Ÿå‘ç°èƒ½å°†å…¶æœ€å¤–å±‚çš„æ‹¬å·å•ç‹¬ç§»åŠ¨å‡ºæ¥ï¼Œè´ªå¿ƒå³å¯ã€‚ä»£ç ã€‚ F. Timber ä¸€æ£µæ ‘å€’ä¸‹ä¹‹åä¼šå ç”¨ kkk çš„ç©ºé—´ï¼Œå› æ­¤ç­”æ¡ˆä¸º 2m(nâˆ’mkm)2^m\\dbinom{n-mk}{m}2m(mnâˆ’mkâ€‹)ã€‚ ç„¶åå‘ç°éœ€è¦å®¹æ–¥ã€‚å…¶ä¸­é’¦å®šä¸€æ£µæ ‘ä¼šäº§ç”Ÿå·¦å³å€’çš„åˆ†èº«ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ 2mâˆ’1(m1)(nâˆ’(m+1)km)2^{m-1}\\dbinom m 1 \\dbinom{n-(m+1)k}{m}2mâˆ’1(1mâ€‹)(mnâˆ’(m+1)kâ€‹)ã€‚ç›´æ¥åšå³å¯ã€‚ä»£ç ã€‚ *1891 (Div. 2) https://codeforces.com/contest/1891ã€‚ D. Suspicious logarithms å‘ç° f,gf,gf,g çš„å˜åŒ–éƒ½ä¸å¤šï¼Œå› æ­¤ç›´æ¥æš´åŠ›ç¢¾è¿‡å»å³å¯ã€‚ä»£ç ã€‚ E. Brukhovich and Exams å°† gcdâ¡\\gcdgcd ä¸º 111 çš„å’Œæœ¬èº«ä¸º 111 å¤§æ®µçš„åˆ’åˆ†æˆæé•¿è¿ç»­æ®µï¼Œç›´æ¥è´ªå¿ƒå³å¯ã€‚ä»£ç ã€‚ F. A Growing Tree å‘ç°æ¯æ¬¡åŠ è¾¹åªéœ€è¦ç»™èŠ‚ç‚¹æ‰“ä¸Šä¸€ä¸ªæ ‡è®°æ¥æŠµæ¶ˆä¿®æ”¹ï¼Œéœ€è¦æŸ¥è¯¢åˆ°æ ¹çš„è·ç¦»ï¼Œç”¨å¤§èåˆä¸€é¢˜çš„æ–¹å¼å»åšå³å¯ã€‚è¿™é‡Œé€‰æ‹©ç›´æ¥æ‹‰äº†ä¸€ä¸ª LCTï¼Œä»£ç ã€‚ *1661 (EDU) https://codeforces.com/contest/1661ã€‚ D. Progressions Covering æˆ‘ä»¬ä»åå¾€å‰æ‰«ææ•°ç»„ï¼Œè¿™æ ·å°±å¯ä»¥å‘ç°è´ªå¿ƒåŠ å°±å¯ä»¥äº†ï¼Œå› ä¸ºåŠ çš„æ˜¯æœ€å¤§çš„è¿˜ä¸ä¼šæµªè´¹ã€‚é‚£ä¹ˆè®°å½•æ€»æ“ä½œæ•° opopop å’Œå½“å‰åŠ çš„å’Œ sssã€‚å¯¹äºå½“å‰çš„æ•°ï¼Œæ“ä½œæ•°æ˜¯ âŒˆb[i]âˆ’skâŒ‰\\left\\lceil \\cfrac{b[i]-s}{k}\\right\\rceilâŒˆkb[i]âˆ’sâ€‹âŒ‰ï¼ˆå®é™…è¿™ä¸ª kkk éœ€è¦æ ¹æ® iii è°ƒæ•´ï¼‰ï¼Œå¾€å‰æ‰«ä¸€ä¸ªï¼Œå½“å‰çš„å’Œå°±å‡å°‘äº†æ“ä½œæ•°ï¼Œæ“ä½œæ•°ä¼šå‡å°‘ i+kâˆ’1i+k-1i+kâˆ’1 æ—¶å¢åŠ çš„æ“ä½œæ•°ã€‚ä»£ç ã€‚ E. Narrow Components çœ‹åˆ° n=3n=3n=3 å’ŒåŒºé—´æŸ¥è¯¢ä¸éš¾æƒ³åˆ°çº¿æ®µæ ‘ï¼Œåˆå§‹å‡è®¾æ‰€æœ‰ç‚¹éƒ½ä¸åœ¨ä¸€ä¸ªè¿é€šå—å†…ï¼Œç„¶ååˆå¹¶ä¸¤æ®µåŒºé—´æ—¶æš´åŠ›å¹¶æŸ¥é›†åˆå¹¶å³å¯ã€‚ä»£ç ã€‚ F. Teleporters å¯ä»¥å°†åŸé—®é¢˜åˆ’åˆ†æˆå‡ æ®µï¼Œç„¶åå¯¹äºæ¯ä¸€æ®µæ”¾ç½®ä¼ é€å™¨çš„è¯åˆ†çš„çº¦å‡åŒ€è¶Šå¥½ï¼Œå…¨å±€çš„æœ€å°ä¸¤ç›¸é‚»ä¼ é€æœºè·ç¦»åº”è¯¥æ˜¯ä¸€ä¸ªï¼ˆå°½å¯èƒ½æ»¡è¶³å¹³å‡ï¼‰ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ f(x,k)f(x,k)f(x,k) æ¥è¡¨ç¤º 0â†’x0\\rightarrow x0â†’x ä¸­é¢å¤–æ’å…¥ kkk ä¸ªçš„æœ€å°ä»£ä»·ï¼Œæ˜¾ç„¶æ˜¯å¥½æ±‚çš„ã€‚ ç›´æ¥äºŒåˆ†éœ€è¦å®‰è£…çš„ä¼ é€æœºæ•°é‡ï¼Ÿæˆ‘ä»¬å¥½åƒæ²¡æœ‰åŠæ³• checkï¼ŒåªçŸ¥é“æœ€å¤šä¼ é€æœºæ•°é‡çš„è¯æ²¡æœ‰ä¸€ä¸ªåˆé€‚çš„è´ªå¿ƒç­–ç•¥ã€‚æˆ‘ä»¬å¯¹å¦ä¸€ä¸ªæ¡ä»¶â€”â€”æ€»èŠ±è´¹è¿›è¡Œè€ƒè™‘ã€‚å› ä¸ºèŠ±è´¹è¶Šå¤§ç›´æ¥æ„å‘³ç€ä¼ é€æœºæ•°é‡è¶Šå°‘ã€‚ æ³¨æ„åˆ° f(x,kâˆ’1)âˆ’f(x,k)f(x,k-1)-f(x,k)f(x,kâˆ’1)âˆ’f(x,k) éšç€ kkk çš„å¢å¤§å•è°ƒä¸å¢ï¼Œè¿™æ ·å¯ä»¥åœ¨å¤–å±‚äºŒåˆ†å…¶å€¼ vvv æ¥ä»£è¡¨ä¸€ä¸ªæ®µå†…çš„æœ€å°ä¼ é€æœºè·ç¦»ï¼Œæ‰¾å‡ºä¸€ä¸ª f(x,kâˆ’1)âˆ’f(x,k)â‰¥vf(x,k-1)-f(x,k)\\ge vf(x,kâˆ’1)âˆ’f(x,k)â‰¥v çš„æœ€å¤§ kkkï¼Œè€Œ kkk è¶Šå¤§èŠ±è´¹è¶Šå°ï¼Œç›´æ¥åˆ©ç”¨ kkk æ¥è¿›è¡Œè´ªå¿ƒæ±‚å‡ºæ¯ä¸€æ®µçš„æœ€å°ä»£ä»·ï¼Œä¸ mmm æ¯”è¾ƒæ¥ç¡®å®šäºŒåˆ†çš„ç­”æ¡ˆã€‚ è®¾äºŒåˆ†å‡ºæ¥çš„ç­”æ¡ˆæ˜¯ kkkï¼Œé€‰å®Œä¹‹å mmm çš„å€¼è¿˜æœ‰å‰©ä½™ï¼Œæˆ‘ä»¬å°½å¯èƒ½å¤šçš„å€¼é€‰æ‹© k+1k+1k+1 æ¥æ¦¨å¹² mmm çš„å‰©ä½™ä»·å€¼ã€‚ æ—¶é—´å¤æ‚åº¦ O(nlogâ¡2V)O(n\\log^2 V)O(nlog2V)ã€‚ä»£ç ã€‚ *1795 (EDU) https://codeforces.com/contest/1795ã€‚ A. Two Towers å®é™…ä¸Šè¯´çš„æ˜¯åªèƒ½æœ‰ä¸€ä¸ªä¸æ»¡è¶³çš„ä½ç½®ã€‚ä»£ç ã€‚ B. Ideal Point åªé€‰è¦†ç›– kkk çš„çº¿æ®µå³å¯ã€‚ä»£ç ã€‚ C. Tea Tasting äºŒåˆ†å‡ºæ¯æ¯èŒ¶èƒ½å¤Ÿè¢«å“ªäº›äººå–å³å¯ã€‚ä»£ç ã€‚ D. Triangle Coloring ç­”æ¡ˆæ˜¯å›ºå®šçš„ï¼Œä¹˜æ³•åŸç†ä¹˜èµ·æ¥å³å¯ã€‚ä»£ç ã€‚ E. Explosions? æ€»èŠ±è´¹æ›´å°‘ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¸Œæœ›ç‚¸æ‰çš„è¡€é‡æ›´å¤šã€‚å½“å˜æˆä¸€ä¸ªä¸¥æ ¼å•å³°å‡½æ•°çš„æ—¶å€™ï¼ˆä»¤ aiâ†aiâˆ’ia_i\\leftarrow a_i-iaiâ€‹â†aiâ€‹âˆ’i å˜æˆå•å³°æ¥å¤„ç†ï¼‰ï¼Œä¹Ÿå°±æ˜¯ææˆä¸€æ®µä¸€æ®µå…¬å·®ä¸º 111 çš„ç­‰å·®æ•°åˆ—ï¼Œå°±å¯ä»¥ç‚¸äº†ã€‚ å®¹æ˜“æƒ³åˆ°é€šè¿‡å•è°ƒæ ˆå¤„ç†è¿™ä¸ªä¸œè¥¿ï¼Œæ­£ååšä¸¤éç„¶ååˆå¹¶å³å¯ã€‚ä»£ç ã€‚ F. Blocking Chips äºŒåˆ†ç­”æ¡ˆï¼Œå¦‚æœèƒ½å‘ä¸‹èµ°å°±å‘ä¸‹ï¼Œè´ªå¿ƒå³å¯ã€‚ä»£ç ã€‚ G. Removal Sequences ai=0a_i=0aiâ€‹=0 ä¸€å®šæ˜¯æœ€åè¢«åˆ å»çš„ï¼Œè€ƒè™‘é€†æ—¶æ—…äººï¼Œä»¤ diâ†degâ¡(i)âˆ’aid_i\\leftarrow \\operatorname{deg}(i)-a_idiâ€‹â†deg(i)âˆ’aiâ€‹ï¼ŒæŒ‰ç…§è¿™ä¸ªè¿›è¡Œæ‹“æ‰‘æ’åºå³å¯æ±‚å‡ºä¸€ç»„åˆæ³•è§£ã€‚ è€ƒè™‘æ±‚å‡ºä¸ç¾å¥½çš„ç‚¹å¯¹ï¼Œå¦‚æœè¿™å¼ æœ‰å‘å›¾çš„ä¸¤ä¸ªç‚¹ç›´æ¥äº’ç›¸å¯è¾¾ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸ç¾å¥½çš„ã€‚bitset ç›´æ¥ç»Ÿè®¡å³å¯ã€‚ä»£ç ã€‚ *1845 (EDU) https://codeforces.com/contest/1845ã€‚ F æ˜¯ NTTï¼Œä¸ä¼šï¼Œä¹Ÿä¸æ‰“ç®—å­¦ã€‚ C. Strong Password æä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æ‰«ä¸¤ä¸ªåºåˆ—å³å¯ã€‚ä»£ç ã€‚ D. Rating System å‘ç°å…¶æ˜¯åˆ©ç”¨ kkk æ¥æ¶ˆæ‰ä¸€ä¸ªæœ€å°å­æ®µå’Œçš„å½±å“ã€‚ä»£ç ã€‚ E. Boxes and Balls å¯¹äºç§»åŠ¨åˆ°ç›®æ ‡çŠ¶æ€ï¼Œæˆ‘ä»¬åªéœ€è¦æ¶ˆè€—æœ€å°æ¬¡æ•°ï¼Œå‰©ä¸‹çš„æ¥å›äº¤æ¢åˆ·åˆ†å³å¯ã€‚ å°†é—®é¢˜æŠ½è±¡æˆè¿™ä¸ªä¸œè¥¿ï¼š åˆå§‹å‰ç¼€å’Œåºåˆ— sssï¼Œç›®æ ‡å‰ç¼€å’Œåºåˆ— sâ€²s&#x27;sâ€²ï¼› âˆ‘âˆ£sâ€²âˆ’sâˆ£â‰¤k\\sum |s&#x27;-s|\\le kâˆ‘âˆ£sâ€²âˆ’sâˆ£â‰¤kï¼Œ âˆ‘âˆ£sâ€²âˆ’sâˆ£â‰¡k(mod2)\\sum |s&#x27;-s|\\equiv k\\pmod 2âˆ‘âˆ£sâ€²âˆ’sâˆ£â‰¡k(mod2)ã€‚ è®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ ä»£è¡¨å½“å‰å¡«å‰ iii ä¸ªæ•°ï¼Œå¡«äº† jjj ä¸ª 111ï¼Œâˆ‘âˆ£sâ€²âˆ’sâˆ£=k\\sum |s&#x27;-s|=kâˆ‘âˆ£sâ€²âˆ’sâˆ£=k çš„æ–¹æ¡ˆæ•°ï¼Œè€ƒè™‘å½“å‰ä½å¡« 0/10/10/1ï¼š fi,j,k=fiâˆ’1,j,kâˆ’âˆ£jâˆ’siâˆ£+fiâˆ’1,jâˆ’1,kâˆ’âˆ£jâˆ’siâˆ£f_{i,j,k}=f_{i-1,j,k-|j-s_i|}+f_{i-1,j-1,k-|j-s_i|} fi,j,kâ€‹=fiâˆ’1,j,kâˆ’âˆ£jâˆ’siâ€‹âˆ£â€‹+fiâˆ’1,jâˆ’1,kâˆ’âˆ£jâˆ’siâ€‹âˆ£â€‹ æ³¨æ„åˆ° âˆ£jâˆ’siâˆ£|j-s_i|âˆ£jâˆ’siâ€‹âˆ£ çš„å–å€¼èŒƒå›´æ˜¯ O(k)O(\\sqrt{k})O(kâ€‹) çš„ï¼Œå¦åˆ™ âˆ‘\\sumâˆ‘ è¿™å †ä¸œè¥¿ä¼šè¶…è¿‡ kkkã€‚åªæšä¸¾è¿™äº›å€¼å³å¯ã€‚ä»£ç ã€‚ PART III è¯ã€‚ *1898 (Div. 2) https://codeforces.com/contest/1898ã€‚ E. Sofia and Strings ä¸ºä»€ä¹ˆèµ›æ—¶ä¸ä»”ç»†çœ‹çœ‹ã€‚ è€ƒè™‘è´ªå¿ƒå»åšè¿™ä¸ªä¸œè¥¿ã€‚æ‰«æ tttï¼Œç»´æŠ¤ sss ä¸­å¯ç”¨å­—æ¯çš„ä½ç½®ï¼Œå¦‚æœä¸å­˜åœ¨å­—æ¯åˆ™ç›´æ¥æ— è§£ï¼Œç„¶ååœ¨ä½ç½®ä¸­åˆ å»ä¸èƒ½å†è¢«åˆ©ç”¨çš„å­—ç¬¦ã€‚ä»£ç ã€‚ F. Vova Escapes the Matrix å…ˆæ‰‹åˆ¤æ–­è¿·å®«ç±»å‹ã€‚å¦‚æœæ ¹æœ¬èµ°ä¸å‡ºå»ï¼Œé‚£ä¹ˆå…¨å µæ­»ï¼›å¦‚æœåªæœ‰ä¸€æ¡è·¯ï¼Œé‚£ä¹ˆé™¤äº†æœ€çŸ­è·¯çš„å…¨å µæ­»ï¼›å¦åˆ™ï¼Œè€ƒè™‘æ¯ä¸ªç‚¹éƒ½è®°ä¸€ä¸‹è‡ªå·±å¯ä»¥åˆ°å“ªäº›ç»ˆç‚¹ï¼Œç„¶åå¯¹äºç»ˆç‚¹åªæœ‰ä¸¤ä¸ªçš„ç‚¹å¯ä»¥è¿›è¡Œç­”æ¡ˆçš„è®¡ç®—ã€‚ä»£ç ã€‚ *1879 (EDU) https://codeforces.com/contest/1879ã€‚ D. Sum of XOR Functions è€ƒè™‘æ‹†ä½è€ƒè™‘è´¡çŒ®ï¼Œè®°å½•æ‰€æœ‰å€¼ä¸º xxx çš„ä¸‹æ ‡å’Œï¼Œé‚£ä¹ˆ lll çš„è´¡çŒ®å‡å»å®ƒä»¬å³å¯ã€‚ä»£ç ã€‚ E. Interactive Game with Coloring æ˜¯ä¸ªå¥—ç€äº¤äº’çš®çš„æ„é€ ã€‚å‘ç°ä¸€èˆ¬æƒ…å†µä¸‹åªéœ€è¦ä¸¤ç§é¢œè‰²ï¼Œå¦‚æœåŒæ—¶æœ‰ä¸¤ä¸ªæ·±åº¦ä¸åŒçš„ä¸‰è¿å•é“¾ï¼Œé‚£ä¹ˆæ‰éœ€è¦ä¸‰ç§é¢œè‰²ã€‚ä»£ç ã€‚ F. Last Man Standing å¯¹äºç¬¬ iii ä½é€‰æ‰‹ï¼Œé€‰æ‹©éš¾åº¦ xxx çš„é¢˜ï¼Œé‚£ä¹ˆå®ƒèƒ½æŒ¨çš„è½®æ•°æ˜¯ hiâŒˆaixâŒ‰h_i\\left\\lceil\\cfrac{a_i}{x}\\right\\rceilhiâ€‹âŒˆxaiâ€‹â€‹âŒ‰ã€‚è€ƒè™‘æšä¸¾ xxxï¼Œç”¨æœ€å¤§è½®æ•°å’Œæ¬¡å¤§è½®æ•°çš„å·®æ¥æ›´æ–°ç­”æ¡ˆã€‚å¯ä»¥æƒ³åˆ°ç”¨è°ƒå’Œçº§æ•°å¤æ‚åº¦æ¥æšä¸¾ âŒˆaixâŒ‰\\left\\lceil\\cfrac{a_i}{x}\\right\\rceilâŒˆxaiâ€‹â€‹âŒ‰ çš„å€¼ï¼Œé‚£ä¹ˆé—®é¢˜å°±å¼±åŒ–æˆäº†åŒºé—´æŸ¥è¯¢ hhh çš„æœ€å¤§æ¬¡å¤§å€¼ï¼ŒST è¡¨ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ *1839 (Div. 2) https://codeforces.com/contest/1839. D. Ball Sorting å¯ä»¥æ³¨æ„åˆ°è¦ç§»åŠ¨å°±ä¼šç›´æ¥ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼Œè€Œè¿™æ ·çš„è¯æœ€é•¿ä¸Šå‡å­åºåˆ—å°±ä¸€å®šä¼šè¢«ä¿ç•™ã€‚ç”¨ iii ä¸ª 000ï¼Œå®é™…ä¸Šå°±æ˜¯æœ€é•¿ä¸Šå‡å­åºåˆ—ä¸­ï¼Œå…è®¸æ‹¥æœ‰ iii ä¸ªè¿ç»­å­æ®µã€‚è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨ä½¿ç”¨ iii ä¸ª 000ï¼Œæœ€é•¿ä¸Šå‡å­åºåˆ—ä»¥ jjj ç»“å°¾çš„æœ€å¤§ä¿ç•™æ•°ï¼Œé€‰å–ç­”æ¡ˆæ—¶è¦ä»¥ 1âˆ¼n1\\sim n1âˆ¼n ç»“å°¾å‡è€ƒè™‘ã€‚ä»£ç ã€‚ E. Decreasing Game ç»“è®ºä¸éš¾çŒœå‡ºï¼Œç„¶åéšä¾¿åˆ¤åˆ¤å°±å¥½äº†ã€‚ä»£ç ã€‚ *1834 (Div. 2) https://codeforces.com/contest/1834ã€‚ E. MEX of LCM å¯ä»¥å‘ç°æœ‰æ•ˆ LCM æ•°é‡ä¸ä¼šå¾ˆå¤šï¼Œå› æ­¤åªç»Ÿè®¡æœ‰æ•ˆ LCMï¼Œæš´åŠ›æ‰«æï¼Œä¸¢è¿› set é‡Œå³å¯ã€‚ä»£ç ã€‚ F. Typewriter æˆ‘ä»¬å…ˆæ¥è€ƒè™‘ç­”æ¡ˆæ˜¯ä»€ä¹ˆã€‚æ¯ä¸€è½®ä¸€å®šæ˜¯æœ€åæ‹¿èµ·ä¸€ä¸ª pi&lt;ip_i&lt;ipiâ€‹&lt;i çš„ä¸œè¥¿ï¼Œç„¶åæŠŠå®ƒæ”¾åˆ°ä¸‹ä¸€è½®çš„ä½ç½®ä¸Šã€‚ä¹Ÿå°±æ˜¯è¯´éœ€è¦ç»´æŠ¤ âˆ‘[pi&lt;i]\\sum [p_i&lt;i]âˆ‘[piâ€‹&lt;i]ï¼Œå·®åˆ†ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ *1901 (EDU) https://codeforces.com/contest/1901ã€‚ F æ˜¯å‡ ä½•ï¼Œä¸åšã€‚ D. Yet Another Monster Fight FST äº†ï¼Œå‘µå‘µã€‚ ç›´æ¥è¾“å‡ºè®¡ç®—çš„ç­”æ¡ˆå°±å¥½äº†ã€‚ä»£ç ã€‚ E. Compressed Tree è®¾ fif_ifiâ€‹ ä»£è¡¨ä»¥ iii ä¸ºæ ¹çš„å­æ ‘å½¢æˆä¸€ä¸ªè¢«åˆ ä¸æ‰çš„æ•´ä½“çš„æœ€å¤§æƒå€¼ä¹‹å’Œï¼Œç„¶åè®¨è®ºä¸€ä¸‹å„¿å­ä¸ªæ•°è½¬ç§»å³å¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"Codeforces","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/Codeforces","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/Codeforces/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CERC2015 è§£é¢˜æŠ¥å‘Š","slug":"default/åšé¢˜è®°å½•/ICPC/CERC/CERC2015","date":"2023-10-26T00:00:00.000Z","updated":"2023-10-26T00:00:00.000Z","comments":true,"path":"a2779d57/","link":"","permalink":"https://james1badcreeper.github.io/a2779d57/","excerpt":"è®°å½•äº†æœ‰å…³ CERC2015 çš„é¢˜ç›®ã€‚","text":"è®°å½•äº†æœ‰å…³ CERC2015 çš„é¢˜ç›®ã€‚ æ‰€æœ‰é¢˜ç›®å¯ä»¥åœ¨ https://codeforces.com/gym/101480 æ‰¾åˆ°ã€‚ A. ASCII Addition å°†æ•°å­—å‹æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç„¶åæ¨¡æ‹Ÿã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; map&lt;string, int> pm; map&lt;int, string> mp; string a[1005], s[1005]; i64 num[1005]; int main(void) &#123; ios::sync_with_stdio(0); mp[0] = \"xxxxxx...xx...xx...xx...xx...xxxxxx\"; mp[1] = \"....x....x....x....x....x....x....x\"; mp[2] = \"xxxxx....x....xxxxxxx....x....xxxxx\"; mp[3] = \"xxxxx....x....xxxxxx....x....xxxxxx\"; mp[4] = \"x...xx...xx...xxxxxx....x....x....x\"; mp[5] = \"xxxxxx....x....xxxxx....x....xxxxxx\"; mp[6] = \"xxxxxx....x....xxxxxx...xx...xxxxxx\"; mp[7] = \"xxxxx....x....x....x....x....x....x\"; mp[8] = \"xxxxxx...xx...xxxxxxx...xx...xxxxxx\"; mp[9] = \"xxxxxx...xx...xxxxxx....x....xxxxxx\"; mp[10] = \".......x....x..xxxxx..x....x.......\"; for (int i = 0; i &lt;= 10; ++i) pm[mp[i]] = i; for (int i = 1; i &lt;= 7; ++i) cin >> s[i]; int len = s[1].length(); for (int i = 1; i &lt;= 7; ++i) &#123; int p = 1; for (int j = 0; j &lt; len; ++j) if ((j + 1) % 6 == 0) &#123; ++p; continue; &#125; else a[p].push_back(s[i][j]); &#125; len = (len + 1) / 6; for (int i = 1, u = 1; i &lt;= len; ++i) &#123; if (pm[a[i]] == 10) &#123; ++u; continue; &#125; num[u] = num[u] * 10 + pm[a[i]]; &#125; i64 ans = num[1] + num[2]; len = 0; while (ans) num[++len] = ans % 10, ans /= 10; for (int j = 1; j &lt;= 7; ++j, cout &lt;&lt; \"\\n\") for (int i = len; i >= 1; i--) &#123; for (int k = 0; k &lt; 5; k++) cout &lt;&lt; mp[num[i]][(j - 1) * 5 + k]; if (i != 1) cout &lt;&lt; \".\"; &#125; return 0; &#125; B. Book Borders è€ƒè™‘ç›´æ¥æšä¸¾ï¼Œæ¯æ¬¡è·³åˆ°ç›¸åº”çš„åˆæ³•å•è¯ï¼Œè¿™æ ·æ˜¯è°ƒå’Œçº§æ•°å¤æ‚åº¦ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; char s[500050]; int pre[500050], len[500050]; int main(void) &#123; fgets(s, 500010, stdin); n = strlen(s) - 1; s[n] = ' '; int flag = 0, lst = 0, cnt = 0; for (int i = 0; i &lt;= n; ++i) &#123; if (s[i + 1] == ' ') pre[i] = i; else pre[i] = (i == 0 ? 0 : pre[i - 1]); if (!flag &amp;&amp; s[i] != ' ') flag = 1, lst = i, cnt = 1; else if (flag &amp;&amp; s[i] == ' ') flag = 0, len[lst] = cnt; ++cnt; &#125; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); for (int i = a; i &lt;= b; ++i) &#123; int cur = 0, ans = 0; while (cur &lt; n) &#123; ans += len[cur]; cur = pre[min(cur + i - 1, n - 1)] + 2; &#125; printf(\"%d\\n\", ans - 1); &#125; return 0; &#125; * C. Cow Confinement æ¯”è¾ƒæŠ½è±¡çš„ä¸€é“é¢˜ï¼Œèµ›æ—¶å±…ç„¶æ²¡æœ‰äººè¿‡ã€‚ ä¸€å¤´ç‰›çš„è¯æ˜¾ç„¶æ˜¯ DPï¼ˆfi,j=fi+1,j+fi,j+1âˆ’fi+1,j+1f_{i,j}=f_{i+1,j}+f_{i,j+1}-f_{i+1,j+1}fi,jâ€‹=fi+1,jâ€‹+fi,j+1â€‹âˆ’fi+1,j+1â€‹ï¼‰ï¼Œé‚£ä¹ˆè€ƒè™‘ç”¨æ‰«æçº¿ä»å³å‘å·¦æ‰«ï¼Œçº¿æ®µæ ‘ç»´æŠ¤å½“å‰æ¯ä¸ªç‚¹çš„ DP å€¼ã€‚å¦‚æœæ‰«åˆ°äº†ä¸€ä¸ªå³åŒºé—´ï¼Œé‚£ä¹ˆä»ä¸Šçº¿åˆ°ä¸‹ä¸€æ¡ä¸‹çº¿éƒ½è¦è¢«åŠ åœ¨ä¸Šçº¿ä¸Šçš„ä¸€ä¸ªæ ¼å­ï¼Œå¹¶ä¸”çº¿å†…æ•°æ®æ¸…é›¶ã€‚æ‰«åˆ°å·¦çº¿çº¿å†…æ•°æ®æ¸…é›¶ï¼Œå¹¶æŠŠåŸæ¥çº¿å¤–çš„ä¸œè¥¿åŠ å›æ¥ï¼Œæœ€åå†æŠŠå³ä¸‹è§’ç®—é‡çš„éƒ¨åˆ†å‡å»å°±è¡Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 1000001; int n, m; struct Line &#123; int x, y1, y2, id, type; bool operator&lt; (const Line &amp;a) const &#123; if (x != a.x) return x > a.x; return type &lt; a.type; &#125; &#125; Q[8000005]; struct SGT &#123; int T[4000050], tag[4000050]; inline void pushdown(int o) &#123; if (!tag[o]) return; tag[o &lt;&lt; 1] = tag[o &lt;&lt; 1 | 1] = 1; T[o &lt;&lt; 1] = T[o &lt;&lt; 1 | 1] = 0; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int v) &#123; if (l == r) return T[o] += v, void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, v); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, v); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void clear(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] = 1, T[o] = 0, void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) clear(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) clear(o &lt;&lt; 1 | 1, mid + 1, r, x, y); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; pushdown(o); int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; &#125; T; int ans[200005], tmp[200005]; multiset&lt;int> s; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2; Q[++m] = &#123;x2, y1, y2, i, 1&#125;; Q[++m] = &#123;x1 - 1, y1, y2, i, 2&#125;; &#125; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; int x, y; cin >> x >> y; Q[++m] = &#123;x, y, 0, 0, 3&#125;; &#125; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; int x, y; cin >> x >> y; Q[++m] = &#123;x, y, 0, i, 4&#125;; &#125; sort(Q + 1, Q + m + 1); s.emplace(N); for (int i = 1; i &lt;= m; ++i) if (Q[i].type == 1) &#123; // è¿›å…¥æ¡†å­ int nxt = *s.upper_bound(Q[i].y2); tmp[Q[i].id] = T.query(1, 0, N, Q[i].y2 + 1, nxt); T.update(1, 0, N, Q[i].y1 - 1, T.query(1, 0, N, Q[i].y1, nxt)); T.clear(1, 0, N, Q[i].y1, Q[i].y2); s.emplace(Q[i].y1 - 1); s.emplace(Q[i].y2); &#125; else if (Q[i].type == 2) &#123; // å‡ºäº†æ¡†å­ T.update(1, 0, N, Q[i].y1 - 1, -tmp[Q[i].id]); T.clear(1, 0, N, Q[i].y1, Q[i].y2); s.erase(s.find(Q[i].y1 - 1)); s.erase(s.find(Q[i].y2)); &#125; else if (Q[i].type == 3) T.update(1, 0, N, Q[i].y1, 1); else ans[Q[i].id] = T.query(1, 0, N, Q[i].y1, *s.lower_bound(Q[i].y1)); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; D. Digit Division è€ƒè™‘æ‰€æœ‰æœ€çŸ­çš„å¯ä»¥è¢« mmm æ•´é™¤çš„éƒ¨åˆ†çš„ä¸ªæ•° cccï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ 2câˆ’12^{c-1}2câˆ’1ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, m; char a[300005]; inline int poww(int a, int b) &#123; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, a + 1); int res = 0, c = 0; for (int i = 1; i &lt;= n; ++i) &#123; res = (res * 10 + a[i] - '0') % m; if (res == 0) ++c; &#125; if (res) puts(\"0\"); else printf(\"%d\\n\", poww(2, c - 1)); return 0; &#125; E. Export Estimate Portal.ç»™å®šä¸€ä¸ªå¸¦æƒæ— å‘å›¾ï¼Œæ¯æ¬¡è¯¢é—®ï¼ˆäº’ç›¸ç‹¬ç«‹ï¼‰æ—¶ï¼šåˆ æ‰è¾¹æƒ &lt;t&lt;t&lt;t çš„è¾¹ï¼›æšä¸¾ iâˆˆ[1,n]i\\in [1,n]iâˆˆ[1,n]ï¼Œå¦‚æœæ˜¯ä¸ªå­¤ç«‹ç‚¹ç›´æ¥åˆ å»ï¼Œå¦‚æœå®ƒçš„åº¦æ•°ä¸º 222 åˆ™å°†å…¶è¿æ¥çš„ (u,v)(u,v)(u,v) ä¹‹é—´è¿æ¥ä¸€æ¡æ–°è¾¹ï¼ˆå¯èƒ½ä¼šè¿å‡ºé‡è¾¹ï¼‰ï¼Œç„¶ååˆ æ‰ iii è‡ªå·±ã€‚å›ç­”ç‚¹çš„ä¸ªæ•°å’Œè¾¹çš„ä¸ªæ•°ã€‚ ç»éªŒå’Œè¾“å…¥æ ¼å¼å‡ ä¹å·²ç»å‘Šè¯‰æˆ‘ä»¬åœ¨çº¿ä¸å¯åšã€‚è€ƒè™‘å°†è¾¹æŒ‰ç…§è¾¹æƒä»å¤§åˆ°å°æ’åºï¼Œè¿™æ ·åªä¼šæœ‰åŠ è¾¹æ“ä½œï¼Œä¹Ÿå°±æ˜¯è¯´ç‚¹çš„åº¦æ•°åªä¼šå¢åŠ ã€‚ è¡¨é¢ä¸Šçœ‹ï¼Œåªæœ‰åº¦æ•°ä¸º 000 çš„ç‚¹å’Œåº¦æ•°ä¸º 222 çš„ç‚¹ä¼šäº§ç”Ÿå½±å“ã€‚å½“æœ‰ç‚¹çš„åº¦æ•° 0â†’10\\rightarrow 10â†’1 æ—¶ï¼Œç‚¹çš„ä¸ªæ•°ä¼šå¢åŠ ã€‚å½“åº¦æ•° 1â†’21\\rightarrow 21â†’2 æ—¶ï¼Œè¾¹ã€ç‚¹çš„ä¸ªæ•°å‡ä¼šå‡å°‘ 111ã€‚å½“ 2â†’32\\rightarrow 32â†’3 æ—¶ï¼Œåˆ™å¤åŸã€‚ ç†æƒ³å¾ˆç¾å¥½ï¼Œç°å®å¾ˆéª¨æ„Ÿã€‚ç”±äºæ“ä½œæ˜¯æŒ‰ç…§é¡ºåºè¿›è¡Œçš„ï¼Œå› æ­¤åœ¨æ“ä½œè¿‡ç¨‹ä¸­ç‚¹çš„åº¦æ•°ä¹Ÿä¼šå‘ç”Ÿæ”¹å˜ã€‚ä½†æ‰‹æ“å‡ ä¸ªæƒ…å†µåå‘ç°è¿™äº‹å…¶å®æ²¡æœ‰ä»€ä¹ˆå…³ç³»ï¼Œåªæœ‰åœ¨è¿™ä¸ªè¿é€šå—è‡ªå·±æ˜¯ä¸ªç¯çš„æ—¶å€™ä¼šè¢«åˆ æˆä¸€ä¸ªç‚¹åŠ ä¸€ä¸ªè‡ªç¯ã€‚ æˆ‘ä»¬å‘ç°å¹¶æŸ¥é›†ï¼Œç„¶åå†ç»´æŠ¤ä¸€ä¸‹æ¯ä¸ªè¿é€šå—ä¸Šä¸åŒåº¦æ•°çš„ç‚¹çš„ä¸ªæ•°å¯ä»¥å¾ˆå¥½åœ°å®Œæˆè¿™ä¸ªé—®é¢˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, q; struct Edge &#123; int u, v, w; bool operator&lt; (const Edge &amp;a) const &#123; if (w != a.w) return w > a.w; return u > a.u; &#125; &#125; a[600005]; int tot, an1[300005], an2[300005]; int V, E; int fa[300005], sz[300005], sz2[300005], c[300005]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; int deg[300005]; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= m; ++i) cin >> a[i].u >> a[i].v >> a[i].w; cin >> q; tot = m; for (int i = 1; i &lt;= q; ++i) &#123; int w; cin >> w; ++tot; a[tot].v = i, a[tot].w = w; &#125; sort(a + 1, a + tot + 1); for (int i = 1; i &lt;= n; ++i) fa[i] = i, sz[i] = 1; int d0 = n, d2 = 0, cyc = 0, ec = 0; for (int i = 1; i &lt;= tot; ++i) &#123; if (a[i].u == 0) &#123; an1[a[i].v] = V, an2[a[i].v] = E; continue; &#125; int u = a[i].u, v = a[i].v; // cout &lt;&lt; \"T \" &lt;&lt; u &lt;&lt; \" \" &lt;&lt; v &lt;&lt; \"\\n\"; int uu = find(u), vv = find(v); if (!deg[u]) --d0; if (deg[u] == 2) --d2, --sz2[uu]; if (!deg[v]) --d0; if (deg[v] == 2) --d2, --sz2[vv]; ++deg[u]; ++deg[v]; if (c[vv]) c[vv] = 0, --cyc; if (uu != vv) &#123; if (c[uu]) c[uu] = 0, --cyc; fa[uu] = vv, sz[vv] += sz[uu], sz2[vv] += sz2[uu]; &#125; if (deg[u] == 2) ++d2, ++sz2[vv]; if (deg[v] == 2) ++d2, ++sz2[vv]; if (sz2[vv] == sz[vv]) c[vv] = 1, ++cyc; V = n - d0 - d2 + cyc; ++ec; E = ec - d2 + cyc; // cout &lt;&lt; d0 &lt;&lt; \" \" &lt;&lt; d2 &lt;&lt; \" \" &lt;&lt; cyc &lt;&lt; \"\\n\"; // cout &lt;&lt; sz[vv] &lt;&lt; \" \" &lt;&lt; sz2[vv] &lt;&lt; \"\\n\"; &#125; for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; an1[i] &lt;&lt; \" \" &lt;&lt; an2[i] &lt;&lt; \"\\n\"; return 0; &#125; F. Frightful Formula æœ‰ç‚¹æ„æ€çš„è®¡æ•°é¢˜ã€‚ å‘ç°é€’æ¨å¼å®é™…ä¸Šæ˜¯ç®—å¸¦æƒçš„èµ°åˆ°å½“å‰ç‚¹çš„æ–¹æ¡ˆæ•°ã€‚ é¦–å…ˆè€ƒè™‘ a,ba,ba,b çš„è´¡çŒ®ï¼Œä»¥ (1,i)(1,i)(1,i) ä¸ºä¾‹ï¼Œå®ƒç›¸å½“äºæ˜¯ (2,i)â†’(n,n)(2,i)\\rightarrow (n,n)(2,i)â†’(n,n)ï¼Œå› æ­¤è´¡çŒ®ä¸º (nâˆ’2+nâˆ’inâˆ’2)Ã—anâˆ’iÃ—bnâˆ’1Ã—val(1,i)\\dbinom{n-2+n-i}{n-2}\\times a^{n-i}\\times b^{n-1}\\times val(1,i)(nâˆ’2nâˆ’2+nâˆ’iâ€‹)Ã—anâˆ’iÃ—bnâˆ’1Ã—val(1,i)ã€‚ ç„¶åå†è€ƒè™‘ ccc çš„è´¡çŒ®ã€‚å† (i,j)(i,j)(i,j) å¤„åŠ å…¥ä¸€ä¸ª cccï¼Œä¼šåŠ ä¸Š (2nâˆ’iâˆ’jnâˆ’i)anâˆ’jbnâˆ’ic\\dbinom{2n-i-j}{n-i}a^{n-j}b^{n-i}c(nâˆ’i2nâˆ’iâˆ’jâ€‹)anâˆ’jbnâˆ’ic çš„è´¡çŒ®ã€‚ ç›´æ¥åšæ˜¯ O(n2)O(n^2)O(n2) çš„ï¼Œä¸éš¾æƒ³åˆ°è€ƒè™‘ä¸€æ¡ä¸€æ¡å¯¹è§’çº¿å»æšä¸¾ï¼Œå¼å­é•¿è¿™æ ·ï¼š âˆ‘k=0nâˆ’2(âˆ‘i=0k(ki)akâˆ’ibi)+âˆ‘k=nâˆ’12nâˆ’4(âˆ‘i=kâˆ’n+2nâˆ’2(ki)akâˆ’ibi)\\sum_{k=0}^{n-2}\\left(\\sum_{i=0}^{k}\\binom k i a^{k-i}b^i\\right)+\\\\ \\sum_{k=n-1}^{2n-4}\\left(\\sum_{i=k-n+2}^{n-2}\\binom k i a^{k-i}b^i \\right) k=0âˆ‘nâˆ’2â€‹(i=0âˆ‘kâ€‹(ikâ€‹)akâˆ’ibi)+k=nâˆ’1âˆ‘2nâˆ’4â€‹(i=kâˆ’n+2âˆ‘nâˆ’2â€‹(ikâ€‹)akâˆ’ibi) å‰é¢çš„ä¸€å¨å¯ä»¥ä½¿ç”¨äºŒé¡¹å¼å®šç†æ¥åŒ–ç®€ï¼Œåé¢é‚£ä¸€å¨å¯ä»¥ä½¿ç”¨å¢é‡æ³•è®¡ç®—ï¼š f(k)=âˆ‘i=kâˆ’n+2nâˆ’2(ki)akâˆ’ibi=âˆ‘i=kâˆ’n+2nâˆ’2(kâˆ’1i)akâˆ’ibi+âˆ‘i=kâˆ’n+2nâˆ’2(kâˆ’1iâˆ’1)akâˆ’ibi=afkâˆ’1âˆ’(kâˆ’1kâˆ’n+1)bkâˆ’n+1anâˆ’1+bfkâˆ’1âˆ’(kâˆ’1nâˆ’2)bnâˆ’1akâˆ’n+1\\begin{aligned} f(k)&amp;=\\sum_{i=k-n+2}^{n-2}\\binom k i a^{k-i}b^i\\\\ &amp;=\\sum_{i=k-n+2}^{n-2}\\binom{k-1} i a^{k-i}b^i+\\sum_{i=k-n+2}^{n-2}\\binom{k-1}{i-1} a^{k-i}b^i\\\\ &amp;=af_{k-1}-\\binom{k-1}{k-n+1}b^{k-n+1}a^{n-1}+bf_{k-1}-\\binom{k-1}{n-2}b^{n-1}a^{k-n+1} \\end{aligned} f(k)â€‹=i=kâˆ’n+2âˆ‘nâˆ’2â€‹(ikâ€‹)akâˆ’ibi=i=kâˆ’n+2âˆ‘nâˆ’2â€‹(ikâˆ’1â€‹)akâˆ’ibi+i=kâˆ’n+2âˆ‘nâˆ’2â€‹(iâˆ’1kâˆ’1â€‹)akâˆ’ibi=afkâˆ’1â€‹âˆ’(kâˆ’n+1kâˆ’1â€‹)bkâˆ’n+1anâˆ’1+bfkâˆ’1â€‹âˆ’(nâˆ’2kâˆ’1â€‹)bnâˆ’1akâˆ’n+1â€‹ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000003; const int N = 400000; inline int poww(int a, int b) &#123; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int n, a, b, c, pa[400005], pb[400005]; int l[200005], t[200005]; int fac[400005], ifac[400005]; int f[400005]; inline int C(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || n &lt; m) return 0; return 1ll * fac[n] * ifac[m] * ifac[n - m] % P; &#125; int calf(int k) &#123; int res = 0; for (int i = k - n + 2; i &lt;= n - 2; ++i) res = (res + 1ll * C(k, i) * pa[k - i] * pb[i]) % P; return res; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> a >> b >> c; for (int i = fac[0] = pa[0] = pb[0] = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % P, pa[i] = 1ll * pa[i - 1] * a % P, pb[i] = 1ll * pb[i - 1] * b % P; ifac[N] = poww(fac[N], P - 2); for (int i = N - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; int ans = 0; for (int i = 1, x; i &lt;= n; ++i) &#123; cin >> x; if (i == 1) continue; ans = (ans + 1ll * C(n - 2 + n - i, n - 2) * pa[n - 1] * pb[n - i] % P * x) % P; &#125; for (int i = 1, x; i &lt;= n; ++i) &#123; cin >> x; if (i == 1) continue; ans = (ans + 1ll * C(n - 2 + n - i, n - 2) * pa[n - i] * pb[n - 1] % P * x) % P; &#125; for (int k = 0, B = 1; k &lt;= n - 2; ++k) &#123; ans = (ans + 1ll * c * B) % P; B = 1ll * B * (a + b) % P; &#125; for (int k = n - 1; k &lt;= n * 2 - 4; ++k) &#123; if (k == n - 1) f[k] = calf(k); else &#123; f[k] = (1ll * a * f[k - 1] - 1ll * C(k - 1, k - n + 1) * pb[k - n + 1] * pa[n - 1] + 1ll * b * f[k - 1] - 1ll * C(k - 1, n - 2) * pb[n - 1] * pa[k - n + 1]) % P; &#125; ans = (ans + 1ll * c * f[k]) % P; &#125; cout &lt;&lt; (ans + P) % P &lt;&lt; \"\\n\"; return 0; &#125; G. Greenhouse Growth ç©ºé—´å¤§ç›—æ‰­æ›²äº†æ­¤å¤„çš„ç©ºé—´ã€‚æˆ‘ä»¬å°†äºæœªçŸ¥æ—¶é—´å®Œæˆè¿™é“é¢˜ç›®ã€‚ H. Hovering Hornet æ—¶é—´æ—…äººé€†è½¬äº†æ­¤å¤„çš„æ—¶é—´ã€‚å‡ ä½•ã€‚ I. Ice Igloos æ­»çµæ³•å¸ˆæŠ¹é™¤äº†æ­¤å¤„çš„çµé­‚ã€‚å‡ ä½•ã€‚ J. Juice Junctions K. Kernel Knights ç±»ä¼¼æ‹“æ‰‘æ’åºï¼Œç›´æ¥ç®—å°±è¡Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 200005; int n; int a[N], in[N], vis[N]; int main(void) &#123; cin >> n; for (int i = 1; i &lt;= 2 * n; ++i) scanf(\"%d\", a + i), ++in[a[i]]; queue&lt;int> q; for (int i = 1; i &lt;= 2 * n; ++i) if (!in[i]) q.emplace(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = 1; if (vis[a[u]] == -1) continue; vis[a[u]] = -1; if (--in[a[a[u]]] == 0) q.emplace(a[a[u]]); &#125; for (int i = 1; i &lt;= n; ++i) if (vis[i] == 1) printf(\"%d \", i); for (int i = n + 1; i &lt;= n * 2; ++i) if (vis[i] >= 0) printf(\"%d \", i); putchar('\\n'); return 0; &#125; * L. Looping Labyrinth å¤ªç‰›é€¼äº†ã€‚ å¯ä»¥ä½¿ç”¨ (rB,cB,rT,cT)(r_B,c_B,r_T,c_T)(rBâ€‹,cBâ€‹,rTâ€‹,cTâ€‹) ä»£è¡¨ä¸€ä¸ªåæ ‡ (nÃ—rB+rT,mÃ—cB+cT)(n\\times r_B+r_T,m\\times c_B+c_T)(nÃ—rBâ€‹+rTâ€‹,mÃ—cBâ€‹+cTâ€‹)ã€‚å°† (rB,cB)(r_B,c_B)(rBâ€‹,cBâ€‹) ç§°ä¸ºå—åæ ‡ï¼Œ(rT,cT)(r_T,c_T)(rTâ€‹,cTâ€‹) ç§°ä¸ºä½™åæ ‡ã€‚ è€ƒè™‘æ‰€æœ‰ä½™åæ ‡ä¸º (0,0)(0,0)(0,0) çš„ç‚¹ï¼Œ åˆ¶æ¯’å¤§æ­æŠ•æ·äº†ç¥ç§˜çš„æ¯’è¯ã€‚æˆ‘ä»¬å°†äºæœªçŸ¥æ—¶é—´è¡¥å®Œã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"ICPC","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/ICPC","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ICPC/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CSP-S 2023 æ¸¸è®°","slug":"summaries/æ¸¸è®°/csp2023","date":"2023-10-19T00:00:00.000Z","updated":"2023-10-20T00:00:00.000Z","comments":true,"path":"7fbff67b/","link":"","permalink":"https://james1badcreeper.github.io/7fbff67b/","excerpt":"åˆ«æ…Œ~","text":"åˆ«æ…Œ~ æˆ‘ä»¬é»˜è®¤ Day0 ä¸å­˜åœ¨ã€‚ Day -2 yx æäº†ä¸€ä¸ª 24 æ‰‹é€Ÿå¤§èµ›ï¼Œç„¶åå¤§å®¶åˆä¼™æ‰¾äº†ä¸€äº›ç®€å•çš„æ¿å­é¢˜ã€‚ æˆ‘æ‰“çš„éå¸¸æç¬‘ï¼ŒST è¡¨ T äº†äº”å‘ï¼Œç¼©ç‚¹å»ºæˆäº†æ— å‘å›¾ï¼Œçº¿æ®µæ ‘ 2 å†™äº† 12minã€‚ç„¶åå˜æˆäº†äºŒé€¼ã€‚ æœ‰å·æ€ªæ²¡æ‰“ï¼Œæˆ‘ä¸è¯´æ˜¯è°ã€‚ yx æ¦œä¸€ï¼Œç‹‚è†œã€‚ ä½†é—ªè€€çš„èŠå£«è›‹æŒå¯èƒ½åšä¸å¤ªå‡ºæ¥ã€‚ Day -1 åœ¨å­¦æ ¡éå¸¸æç¬‘ï¼Œé‰´å®šä¸ºæˆ‘æ˜¯æ··å­ã€‚ å¤§çº¢çš„å£°éŸ³å¾ˆå°–ï¼ŒæŸäººçš„ç¬‘å£°å¾ˆé˜´é—´ã€‚ Day 1 åœ¨æ¥çš„è·¯ä¸Šè®¤è¯†äº†æŸä¸ªåˆä¸­çš„åŒå­¦ï¼Œæ„Ÿè§‰æŒºç‰›ã€‚ ä»¤ 0:00 ä¸ºå¼€å§‹æ—¶é—´ã€‚ 0:00 è¿›ä¸å»è€ƒåœºã€‚ 0:10 å¼€è€ƒï¼Œä½†æ˜¯æˆ‘çš„æœºå™¨æç¤ºç¡¬ç›˜ç©ºé—´ä¸è¶³ã€‚ 0:25 æ¢å®Œæœºå™¨ï¼Œç”³è¯·å»¶æ—¶ï¼Œä¸åŒæ„ã€‚ 0:35 å†™å®Œ T1ï¼Œå‘ç°è¯»é”™é¢˜äº†ã€‚ 0:50 æ”¹å®Œ T1ã€‚ 1:10 å¦å†³äº†ç›´æ¥ç®—å’ŒåŒºé—´ DPï¼Œç›´æ¥è€ƒè™‘çº¿æ€§ DP åšæ³•ã€‚å†™äº†ä¸€ä¼šå„¿å‘ç°å‡äº†ï¼Œç„¶åæ‰€æœ‰çœŸåšæ³•éƒ½æ˜¯ O(n2)O(n^2)O(n2) çš„ã€‚ 1:50 æƒ³ä¸å‡ºæ¥ï¼Œå†™äº† O(n2)O(n^2)O(n2)ï¼Œç„¶åå‘ç°è½¬ç§»ç‚¹æ²¡æœ‰è§„å¾‹ï¼Œç„¶åå„ç§æ€è€ƒéƒ½ä¸ä¼šä¼˜åŒ–è¿™ä¸ªä¸œè¥¿ã€‚ 2:10 è¿™ T3 æ˜¯ä¸ªå•¥å•Šã€‚ 2:20 T4 çœ‹ä¸Šå»æ¯”è¾ƒå¯åšï¼Œæƒ³äº†æƒ³å…ˆäºŒåˆ†ï¼Œç„¶åè´ªå¿ƒï¼Œåº”è¯¥æ˜¯å¯è¡Œçš„ã€‚ä½†æ˜¯ä¸ä¼šè§£ä¸€å…ƒäºŒæ¬¡æ–¹ç¨‹ï¼Œå°±æƒ³ç€äºŒåˆ†ä¸€ä¸‹ã€‚åæ­£æˆ‘çš„è´ªå¿ƒæ˜¯ä¼˜å…ˆé˜Ÿåˆ—ï¼Œä¹Ÿæ˜¯åŒ logâ¡\\loglogã€‚ 2:30 æ„Ÿè§‰ T3 65pts æ¯”è¾ƒå¯å†™ã€‚ 2:50 T3 è¯»é”™é¢˜äº†ã€‚ 3:20 T3 å†™é”™äº†ã€‚ 3:30 å…¨é¢å´©ç›˜ã€‚ 3:40 å†å»çœ‹ T4ï¼Œå…ˆå†™ c=0c=0c=0ï¼Œå‘ç°è´ªå¿ƒå¥½åƒæ˜¯å¯¹çš„ã€‚ç„¶åå¾ˆå¿«åœ°å†™äº†äºŒåˆ†ï¼Œå‘ç°å¤§æ ·ä¾‹è¦ 1.04sã€‚ å¡å¸¸ï¼Œå¡å®Œä¹‹å WA äº†ã€‚äºæ˜¯æ‘†çƒ‚ã€‚ 4:00 T3 æœ€å¤š 151515ï¼Œç»™ T2 è¡¥äº†ä¸€ä¸ªæ•°æ®éšæœºçš„éƒ¨åˆ†åˆ†ã€‚ 4:10 äº¤å·ã€‚ Day 1 After å‘ç°å¤§å®¶éƒ½å¾ˆä¼šï¼Œäºæ˜¯è‡ªé—­ã€‚ æ€ä¹ˆ T2 æœ‰åŸé¢˜å•Šã€‚ ä¼šæŒ‚å¤šå°‘å‘¢ã€‚ æœç„¶ï¼Œæˆ‘åªèƒ½åœç•™åœ¨è¢«æŸ“ç°çš„å¤§åœ°ã€‚ T4 å‡äº†å•Šï¼Œé‚£æ²¡äº‹äº†ã€‚ Day2 çœ‹äº† dx çš„æ¸¸è®°ï¼Œå‘ç°æˆ‘ T4 å¿«è¯»æ²¡åˆ¤è´Ÿæ•°ï¼Œç„¶åè¿‡äº†å¤§æ ·ä¾‹ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ å¥½å§å…¶å®æ˜¯æˆ‘è‡ªå·±çš„é—®é¢˜ã€‚ Day INF å®˜æ–¹æ•°æ® 100+50+0+90ï¼Œå¥½é‡çš„æ°´åˆ†ã€‚ åŠ è®­ã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"2023/10/14ï¼šæš—æµæ¶ŒåŠ¨","slug":"default/è®°å½•/2023/10/2023-10-14","date":"2023-10-14T00:00:00.000Z","updated":"2023-10-14T00:00:00.000Z","comments":true,"path":"26f5f7d4/","link":"","permalink":"https://james1badcreeper.github.io/26f5f7d4/","excerpt":"åªæœ‰é‚£äº›è¯»æ‡‚è¿¹è±¡çš„äººï¼Œæ‰èƒ½æ˜ç™½ä»€ä¹ˆæ­£åœ¨ï¼Œæš—æµæ¶ŒåŠ¨â€¦â€¦","text":"åªæœ‰é‚£äº›è¯»æ‡‚è¿¹è±¡çš„äººï¼Œæ‰èƒ½æ˜ç™½ä»€ä¹ˆæ­£åœ¨ï¼Œæš—æµæ¶ŒåŠ¨â€¦â€¦ å‰è¨€ æŠ±æ­‰é¸½äº†å¥½å‡ å¤©ï¼ï¼ æœ€è¿‘è¿™æ®µæ—¶é—´åœ¨ä¸ºæŸäº›ä¸œè¥¿æ”’ç´ æï¼ˆå†™å¥½äº†ä¼šæ”¾å‡ºæ¥ï¼‰ï¼Œæ‰€æœ‰åšæ‚é¢˜çš„æ—¶é—´ä¼šå˜å°‘è®¸å¤šã€‚ å¤§å®¶éƒ½å¥½å¼ºå¥½å¼ºâ€¦â€¦åªæœ‰æˆ‘ä»€ä¹ˆéƒ½å­¦ä¸ä¼šâ€¦â€¦ æœ¬æ¬¡çš„é—²è¯è¢«æ”¾åœ¨äº†æ–‡æœ«ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹é¢˜ï¼ eJOI2018 ä»Šå¤©æ¥è¡¥ KHIN çš„ä¼ æ•™åœºã€‚ç”±äºæœ‰é¢˜åšè¿‡ï¼Œå› æ­¤å‹åŠ›æ¯”è¾ƒå°ï¼ï¼ æ„Ÿè°¢ KH æ›¾ç»ä¸åœåœ°ä¼ æ•™è®©æˆ‘èƒ½åœ¨ä»Šå¤©æ‘†ä¸€æ‘†çƒ‚ï¼ï¼ ä½†äº‹åå‘ç°æˆ‘é”™äº†ï¼Œå‰©ä¸‹çš„é¢˜ä¹Ÿå¤ªéš¾å†™äº†ï¼ Day1 å˜¿å˜¿å˜¿ã€‚ A. Hills Portal. å”‰è¿™ä¸ªå¥½åƒæ˜¯ NOIP æœŸé—´éšæœº CF è®¡åˆ’éšåˆ°çš„é¢˜ï¼Ÿåæ­£åšè¿‡äº†ã€‚ä»¥ä¸‹æ˜¯åŸé¢˜è§£ã€‚ è®¾ f(i,j,k)f(i,j,k)f(i,j,k) ä¸ºå½“å‰è€ƒè™‘åˆ° iiiï¼Œkkk ä»£è¡¨å½“å‰æ˜¯ä¸æ˜¯éœ€è¦æ»¡è¶³çš„ï¼Œjjj ä»£è¡¨æ€»å…±æ»¡è¶³çš„ä¸ªæ•°ï¼Œè½¬ç§»å–æœ€å°å€¼å°±è¡Œã€‚ #include &lt;bits/stdc++.h> using namespace std; int n; int a[5005]; int f[5005][2505][2]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0x3f, sizeof(f)); f[0][0][0] = f[1][0][0] = f[1][1][1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; f[i][0][0] = 0; for (int j = 1; j &lt;= (i + 1) / 2; ++j) &#123; f[i][j][0] = min(f[i - 1][j][0], f[i - 1][j][1] + max(0, a[i] - a[i - 1] + 1)); f[i][j][1] = min(f[i - 2][j - 1][0] + max(0, a[i - 1] - a[i] + 1), f[i - 2][j - 1][1] + max(&#123;0, a[i - 1] - a[i - 2] + 1, a[i - 1] - a[i] + 1&#125;)); &#125; &#125; for (int i = 1; i &lt;= (n + 1) / 2; ++i) printf(\"%d \", min(f[n][i][0], f[n][i][1])); putchar('\\n'); return 0; &#125; [ERROR] B. AB-strings Portal. tourist çš„é¢˜æœç„¶ç¥ï¼ï¼ä½†æ˜¯çœŸéš¾ï¼Œå¥½æ¯’ç˜¤ï¼Œè¿™åœºçš„æœ€æ¯’ç˜¤çš„é¢˜ã€‚ åœ¨ç½‘ä¸Šæ‰¾ä¸åˆ°è¯´æ˜ç™½çš„é¢˜è§£ï¼ï¼è¿™é¢˜çœŸçš„åªæœ‰ *2800 å—ï¼Ÿ KH è¯´å¯ä»¥ä¸è¡¥ï¼Œé‚£å°±å¼€æ‘†ï¼ * C. Passports Portal. ä¸ªäººè®¤ä¸ºæ˜¯è¿™åœºä¸­ä»…æ¬¡äºå¾ªç¯æ’åºçš„å¥½é¢˜ã€‚ ä¸éš¾æƒ³åˆ°çŠ¶å‹ï¼Œè€Œä¸” Pâ‰¤2P\\le 2Pâ‰¤2ï¼Œå› æ­¤ P=2P=2P=2 æ—¶åªéœ€è¦æšä¸¾å­é›†ç„¶åå¯¹äºå­é›†å’Œè¡¥é›†åˆå¹¶çŠ¶å‹ DP æ•°ç»„å³å¯ï¼Œå› æ­¤è¿™é‡Œåªéœ€è¦è€ƒè™‘ P=1P=1P=1ã€‚ è®¾ fif_ifiâ€‹ ä»£è¡¨é›†åˆ iii ä¸­çš„ç­¾è¯å…¨éƒ¨åŠç†å®Œæˆåçš„æœ€å°ç»“æŸæ—¶é—´ã€‚è½¬ç§»é‡‡ç”¨åˆ·è¡¨æ³•ï¼Œè€ƒè™‘é™åˆ¶æ˜¯ä»€ä¹ˆï¼šä¸€ä¸ªæ—¶é—´å†…ï¼Œæ—…è¡Œå’ŒåŠç†ç­¾è¯åšå¤šåšä¸€ç§ã€‚ç”±äºç­¾è¯æ—¶é—´è¶Šé•¿è¶Šéš¾æ•´ï¼Œå› æ­¤æŒ‰ç…§ç­¾è¯åŠç†æ—¶é—´ä»å°åˆ°å¤§æšä¸¾ã€‚å¦‚æœæˆ‘ä»¬ä¾æ¬¡æ£€æŸ¥å…¶å®ƒå›½å®¶çš„é™åˆ¶ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸º O(n22n)O(n^2 2^n)O(n22n)ã€‚ ä½†è¿™ä¸ªè¿‡ç¨‹æ˜¾ç„¶æ˜¯å…·æœ‰å•è°ƒæ€§çš„ã€‚è€ƒè™‘ä»é™åˆ¶æœ¬èº«å…¥æ‰‹ï¼š åŠç†ç­¾è¯çš„æ—¶é—´ä¸å¯ä»¥æ’åˆ°å‡ºå›½çš„æ—¶é—´ã€‚ å¦‚æœ ppp æ­£åœ¨åŠç†ç­¾è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶é—´ä¸èƒ½è€ƒè™‘åŠç†ç­¾è¯ã€‚ æŒ‰ç…§ lll ä»å°åˆ°å¤§è€ƒè™‘é™åˆ¶ï¼Œç»´æŠ¤ä¸¤ä¸ªæŒ‡é’ˆæ¥é™åˆ¶ä¸¤æ¡é™åˆ¶å³å¯ã€‚ è¿™æ ·å°±å¯ä»¥ O(n2n)O(n2^n)O(n2n) å®Œæˆäº†ã€‚ #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; int n, P; int l[24], r[24], t[24], idl[24], idt[24], f[1 &lt;&lt; 24]; int ans[24][2], fr[1 &lt;&lt; 24]; void calc(int s, int id) &#123; if (!s) return; ans[fr[s]][0] = id; ans[fr[s]][1] = f[s] - t[fr[s]]; calc(s ^ (1 &lt;&lt; fr[s]), id); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> P; int u = 1 &lt;&lt; n; for (int i = 0; i &lt; n; ++i) cin >> l[i] >> r[i] >> t[i], r[i] += l[i] - 1, idl[i] = idt[i] = i; sort(idl, idl + n, [&amp;](int x, int y) &#123; return l[x] &lt; l[y]; &#125;); sort(idt, idt + n, [&amp;](int x, int y) &#123; return t[x] &lt; t[y]; &#125;); memset(f, 0x3f, sizeof f); f[0] = 1; for (int i = 0; i &lt; u; ++i) if (f[i] != INF) &#123; int L = 0, R = 0, now = f[i]; for (int k = 0; k &lt; n; ++k) &#123; int j = idt[k]; if (i >> j &amp; 1) continue; while (1) &#123; while (L &lt; n &amp;&amp; r[idl[L]] &lt; now) ++L; while (R &lt; n &amp;&amp; (!(i >> idl[R] &amp; 1) || l[idl[R]] &lt; now)) ++R; if (L &lt; n &amp;&amp; l[idl[L]] &lt;= now) &#123; now = r[idl[L]] + 1; continue; &#125; if (R &lt; n &amp;&amp; l[idl[R]] &lt;= now + t[j]) &#123; now = r[idl[R]] + 1; continue; &#125; break; &#125; if (now + t[j] &lt; l[j] &amp;&amp; now + t[j] &lt; f[1 &lt;&lt; j | i]) f[1 &lt;&lt; j | i] = now + t[j], fr[1 &lt;&lt; j | i] = j; &#125; &#125; if (P == 1) &#123; if (f[u - 1] == INF) &#123; return puts(\"NO\"), 0; &#125; puts(\"YES\"); calc(u - 1, 1); for (int i = 0; i &lt; n; ++i) printf(\"%d %d\\n\", ans[i][0], ans[i][1]); &#125; else &#123; for (int s = 0; s &lt; u; ++s) &#123; int t = u - 1 - s; if (f[s] == INF || f[t] == INF) continue; puts(\"YES\"); calc(s, 1); calc(t, 2); for (int i = 0; i &lt; n; ++i) printf(\"%d %d\\n\", ans[i][0], ans[i][1]); return 0; &#125; puts(\"NO\"); &#125; return 0; &#125; Day2 å˜»å˜»å˜»ã€‚ A. Chemical table ä¸éš¾çŒœåˆ°ç»“è®ºï¼Œå°†åŸå›¾æ„å»ºæˆäºŒåˆ†å›¾ï¼Œç„¶ååº”è¯¥ä¸€ä¸ªç‚¹èƒ½åˆ°è¾¾æ‰€æœ‰ç‚¹ï¼ŒDFS æ±‚è¿é€šå—æ•°å³å¯ã€‚ #include &lt;bits/stdc++.h> using namespace std; int n, m, q; vector&lt;int> G[400005]; bool vis[400005]; void dfs(int x) &#123; vis[x] = 1; for (int y : G[x]) if (!vis[y]) dfs(y); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m >> q; while (q--) &#123; int x, y; cin >> x >> y; G[x].emplace_back(n + y); G[n + y].emplace_back(x); &#125; int ans = 0; for (int i = 1; i &lt;= n + m; ++i) if (!vis[i]) dfs(i), ++ans; cout &lt;&lt; ans - 1 &lt;&lt; \"\\n\"; return 0; &#125; B. Prime Tree Portal. ä¹‹å‰è¯´çš„â€œå‡†å¤‡çš„ç´ æâ€ä¹‹ä¸€ï¼Œæ”¾å†™è¿‡çš„é¢˜è§£ã€‚ ç”±äºé¢˜ç›®ä¸­ä¿è¯å­˜åœ¨ X=0X=0X=0ï¼Œéšæœºä¸€ä¸ªæ’åˆ—ç„¶åæŒ‰ç…§æ¡ä»¶è´ªå¿ƒå¾€æ ‘é‡Œå¡«éƒ½æ˜¯å¾ˆå®¹æ˜“å‡ºè§£çš„ï¼Œå› æ­¤ç›´æ¥éšæœºåŒ–åŠ è´ªå¿ƒå³å¯ã€‚ #include &lt;bits/stdc++.h> using namespace std; int n, id[100005], a[100005], tmp[100005], res; vector&lt;int> G[100005]; mt19937 Rand(time(0)); set&lt;int> s; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; void dfs(int x, int fa) &#123; if (res) return; for (int i : s) if (!fa || gcd(tmp[fa], id[i]) == 1) &#123; // ç»™å½“å‰ç‚¹å¡«æ•° tmp[x] = id[i]; s.erase(i); break; &#125; if (!tmp[x]) &#123; res = 1; return; &#125; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; vector&lt;int> tmp; G[i].swap(tmp); id[i] = i; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v), G[v].emplace_back(u); &#125; int ans = n; for (int op = 1;; ++op) &#123; shuffle(id + 1, id + n + 1, Rand); s.clear(); for (int i = 1; i &lt;= n; ++i) tmp[i] = 0, s.insert(i); res = 0; dfs(1, 0); if (res == 0) &#123; ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = tmp[i]; &#125; if (!ans) break; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); &#125; return 0; &#125; * C. Cycle Sort Portal. è¢«ç§°ä½œä¸ºâ€œç®€å•é¢˜â€çš„æ„é€ é¢˜ï¼Œä½†ç¡®å®æ˜¯å¥½é¢˜ã€‚æ”¾å†™è¿‡çš„é¢˜è§£ã€‚ å®é™…ä¸Šå¯ä»¥å¥—è·¯åœ°åˆ†æã€‚ å¼±åŒ–é¢˜ç›®æ¡ä»¶ã€‚æœ€ä¼˜è§£ï¼Ÿæˆ‘ä¸ç®¡ï¼æˆ‘ä»¬å¯ä»¥åªäº¤æ¢ä¸¤ä¸ªæ•°ï¼Œä½†æ˜¯è¿™æ ·è¿˜æ˜¯å¾ˆéš¾åŠï¼Œæ•°æ²¡æœ‰æ”¾çš„å”¯ä¸€ä½ç½®ï¼Œé‚£ä¹ˆå°±å…ˆåšæ’åˆ—ï¼ è§‚å¯Ÿæ ·ä¾‹ã€‚æ¯”å¦‚æ ·ä¾‹ 555ï¼Œå®ƒåˆå¹¶äº†ä¸¤ä¸ªæ“ä½œï¼Œä½†æ˜¯åé¢å¤šå‡ºäº†ä¸€ä¸ªæ“ä½œã€‚æ‰‹ç©åå‘ç°æ“ä½œæ˜¯å¯ä»¥åˆå¹¶çš„ï¼Œä½†æ˜¯æœ€åè¦å¤šå‡ºæ¥ä¸€ä¸ªé•¿åº¦ä¸ºåˆå¹¶çš„æ“ä½œæ•°çš„æ“ä½œã€‚ ç°åœ¨è€ƒè™‘æ€ä¹ˆå°†è¿™ä¸ªåšæ³•æ‰©å±•åˆ°å¯ä»¥é‡å¤çš„æ•°ä¸Šã€‚æ’åˆ—ç»™äº†ä»€ä¹ˆä¾¿åˆ©ï¼Ÿæ¯ä¸ªç‚¹çš„å…¥åº¦å‡ºåº¦éƒ½ä¸º 111ï¼Œä½†å¦‚æœå®ƒä¸æ˜¯æ’åˆ—ï¼Œå®ƒåªä¼šæ»¡è¶³å…¥åº¦å‡ºåº¦ç›¸ç­‰ã€‚ å¯ä»¥ä½¿ç”¨æœ‰å‘å›¾çš„æ–¹å¼åˆ»ç”»è¿™ä¸ªè¿‡ç¨‹ï¼šå°† aia_iaiâ€‹ çš„æœ€ç»ˆä½ç½®å‘ aia_iaiâ€‹ è¿è¾¹ï¼Œç„¶ååœ¨è¿™ä¸ªå›¾ä¸Šæ‰¾ç¯ï¼Œå¹¶ä¸”æ¯æ¡è¾¹ç»è¿‡æ°å¥½ä¸€æ¬¡ã€‚è¿™æ˜¯æ¬§æ‹‰è·¯ï¼åœ¨å­˜è¾¹çš„æ—¶å€™è®°å½•ä¸€ä¸‹ iiiï¼Œå› ä¸ºè¿™å°±æ˜¯æ–¹æ¡ˆã€‚ #include &lt;bits/stdc++.h> using namespace std; int n, s, m; int a[200005], b[200005], to[200005]; bool vis[200005]; vector&lt;pair&lt;int, int>> G[200005]; vector&lt;bool> ban[200005]; vector&lt;vector&lt;int> > ans; vector&lt;int> road; int cur[200005]; void dfs(int x) &#123; vis[x] = 1; for (; cur[x] &lt; G[x].size(); ++cur[x]) if (!ban[x][cur[x]]) &#123; int y = G[x][cur[x]].first, w = G[x][cur[x]].second; ban[x][cur[x]] = 1; dfs(y); road.emplace_back(w); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;s); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) to[i] = a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; sort(to + 1, to + n + 1); // to ä¸ºæœ€ç»ˆçš„ a for (int i = 1; i &lt;= n; ++i) if (a[i] != to[i]) &#123; ++m; G[to[i]].emplace_back(a[i], i); ban[to[i]].emplace_back(0); &#125; if (m > s) return puts(\"-1\"), 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i] &amp;&amp; G[i].size()) &#123; road.clear(); dfs(i); ans.push_back(road); &#125; for (int i = 0; i &lt; ans.size(); ++i) reverse(ans[i].begin(), ans[i].end()); if (min(int(ans.size()), s - m) > 1) &#123; int t = min(int(ans.size()), s - m); road.clear(); road.emplace_back(ans[0][0]); for (int i = ans.size() - t + 1; i &lt; ans.size(); ++i) &#123; for (int x : ans[i]) ans[0].emplace_back(x); road.emplace_back(ans[i][0]); ans[i].clear(); &#125; for (int i = 1; i &lt; t; ++i) ans.pop_back(); reverse(road.begin(), road.end()); ans.push_back(road); &#125; printf(\"%u\\n\", ans.size()); for (int i = 0; i &lt; ans.size(); ++i) &#123; printf(\"%u\\n\", ans[i].size()); for (int x : ans[i]) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; æ€»ç»“ é¢˜ç›®è´¨é‡ï¼šå¾ªç¯æ’åº &gt; äº’ç´ æ ‘ &gt; æŠ¤ç…§ = AB-Stringsã€‚ çœ‹æ¥æœºå™¨äººä¹Ÿæ˜¯ä¼šè¯´è°çš„ã€‚å¯èƒ½æ˜¯æ¯ä¸ªäººçš„è§‚ç‚¹ä¸åŒã€‚ è”šè“ä¹‹æµ· å†æ¬¡é‡è¯»äº†ä¸€äº›ä¸œè¥¿ï¼Œè¶Šæ¥è¶Šè§‰å¾—å¸Œç‰¹å‹’åœ¨äºŒæˆ˜å‰æœŸçš„è¿æ°”æ˜¯çœŸçš„å¥½ï¼Œå¥½åˆ°ç¦»è°±äº†ã€‚è™½ç„¶ä¸æ’é™¤å°±æ˜¯å½“æ—¶æ—¶ä»£çš„åŸå› ã€‚ æœ€è¿‘å¬äº†ä¸€äº›æ¯”è¾ƒç¥ç§˜çš„æ­Œï¼Œå®ƒä»¬ç»™æˆ‘ä¸€ç§â€œæš—æµæ¶ŒåŠ¨â€çš„æ„Ÿè§‰ã€‚å°±æ˜¯ä½ ï¼ŒäºŒå‘ç®”é™ç»´æ‰“å‡»ã€‚ æ³¢æ¾œå£®é˜”çš„èƒŒåï¼Œå®åˆ™æ˜¯å¤ªé˜³ç³»çš„æ¯ç­ã€‚ä¸ºä»€ä¹ˆï¼Œä¼šæ˜¯è¿™æ ·å‘¢â€¦â€¦ ã€Šå…‹ç½—åœ°äºšç‹‚æƒ³æ›²ã€‹ç”¨æœ€ä¸ºæ¬¢å¿«çš„èŠ‚å¥æè¿°äº†ä¸€ä¸ªé¥±å—æˆ˜ç«æ‘§æ®‹çš„æ®‹å£æ–­å£ï¼›è¯ºæ›¼åº•ç”¨æ³¢å…‰ç²¼ç²¼çš„æµ·é¢æè¿°äº†ä¸€åœºäººç±»å†å²ä¸Šè§„æ¨¡æœ€å¤§çš„ç™»é™†ä½œæˆ˜ã€‚ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ ç»æœ›åˆ°ç©ºçµçš„ç¨‹åº¦ï¼Œè¿™æ˜¯ä»€ä¹ˆï¼Ÿ åœ¨è¢«æ‘§æ¯çš„å¤§åœ°ä¸Šè·å¾—æ–°ç”Ÿâ€”â€”å¦‚å…‹ç½—åœ°äºšåºŸå¢Ÿä¸Šçš„é‚£æœµç™½è‰²å°èŠ±ã€‚ åœ¨å¤©é™…çº¿ï¼Œä¸è¦åœç•™ After Memories æˆ‘å¯ä»¥å‘Šè¯‰ä½ ï¼Œæˆ‘ç°åœ¨å†™çš„è¿™äº›ä¸œè¥¿ä¹Ÿæ˜¯åœ¨æ‰“ç´ æï¼Œæ‚¨ä¿¡å—ï¼Ÿ æœ¬æ¥è¿™ç¯‡åº”è¯¥ä¸¤å¤©å‰å°±å‘çš„ï¼Œä½†æ˜¯ä¸€ç›´é¸½åˆ°äº†ä»Šå¤©ï¼éƒ½æ€ªè¿™å‡ å¤©å¤ªæ‘†äº†ï¼ˆå®é™…ä¸Šèº«ä½“å‡ºäº†ä¸€äº›å¥‡æ€ªçš„é—®é¢˜ï¼Œè€Œä¸”ä¸€ç›´åœ¨æ‰“ç´ æï¼‰ï¼ ä¸è¿‡ç°åœ¨å¥½çš„å·®ä¸å¤šäº†ï¼Œé‚£å°±å¼€å§‹è®¤çœŸæ‘†çƒ‚å§ï¼ˆ ä¸çŸ¥é“ä¸ºä»€ä¹ˆæƒ³å“­ï¼Œä¹Ÿè®¸ä¸äººçš„ç¦»åˆ«æ˜¯å¸¸æ€ï¼Œä¸è¿‡å»çš„ç¦»åˆ«ä¹Ÿæ˜¯å¿…ç„¶ï¼Œè·ªå€’åœ¨ä½ çš„å¢“ç¢‘å‰ï¼Œæ„Ÿå¹ç€é‚£è¿ç¥éƒ½æ‰“ä¸è´¥çš„ä½ ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/categories/%E9%97%B2%E8%AF%9D/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"}]},{"title":"2023/10/10ï¼šå­©ç«¥çš„åŒçœ¸","slug":"default/è®°å½•/2023/10/2023-10-9","date":"2023-10-10T00:00:00.000Z","updated":"2023-10-10T00:00:00.000Z","comments":true,"path":"5c54da09/","link":"","permalink":"https://james1badcreeper.github.io/5c54da09/","excerpt":"æœªæ¥çš„ç³å­”ï¼","text":"æœªæ¥çš„ç³å­”ï¼ è¿‘åœ¨å’«å°ºçš„è§†é‡ç›²ç‚¹ï¼Ÿ! 2023/10/9 ä¸Šåˆæ¨¡æ‹Ÿèµ›ï¼Œç¬”è€…è¢«é”¤çƒ‚äº†ã€‚ ä½†æ˜¯ï¼Œä¸ºä»€ä¹ˆæƒ³ä¸åˆ°å‘¢ï¼Ÿ æˆ‘é€šå¸¸å°†â€œç›´è§‰â€ä½œä¸ºå¯¼å‘ï¼Œå¦‚æœç›´è§‰æ˜¯æ­£ç¡®çš„ï¼Œé‚£ä¹ˆå¤§æ¦‚å°±æœ‰äº†ã€‚ä¸è¿‡æˆ‘åšè¿‡çš„é¢˜å°‘å¾—å¯æ€œï¼Œå› æ­¤ç›´è§‰çœŸçš„å¾ˆä¸é è°±ã€‚ä»€ä¹ˆéƒ½æƒ³ä¸åˆ°ï¼Œå³ä½¿æƒ³åˆ°äº†ä¹Ÿæ¼æ´ç™¾å‡ºã€‚ ä¹Ÿè®¸åªæœ‰å¤§é‡çš„è®­ç»ƒæ‰èƒ½æ ¹æ²»è¿™ä¸€é—®é¢˜ï¼Œä½†ä¹Ÿè®¸æˆ‘ä¹Ÿçœ‹ä¸è§ä»€ä¹ˆã€‚ æˆ‘ä»¬å‘¨å›´çš„ç¯å¢ƒä¸­æœ‰ç€å¤§é‡çš„å¾®è§‚ç²’å­ï¼Œå®ƒä»¬éƒ½åœ¨é˜»æŒ¡æˆ‘ä»¬çš„å®ç°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å’Œçå­æ— å¼‚ã€‚ é€ æˆè¿™ç§æƒ…å†µå®å±å¯æ‚²ï¼Œä½†ä¹Ÿæ— æ³•é¿å…ã€‚è¿™æ˜¯å®‡å®™ä¸­æœ€åçš„ç»“æœï¼Œåªèƒ½è¯´å¯æ€œã€‚ æˆ‘ä»¬æ˜¯ä½ç­‰æ–‡æ˜å—ï¼Ÿæ˜¾ç„¶æ˜¯ã€‚æˆ‘ä»¬è¿åœ°çƒä¸Šçš„ä¸œè¥¿éƒ½çœ‹ä¸å…¨ã€‚ ä¹Ÿè®¸é‚£ä»æ¥å°±ä¸æ˜¯ç›²ç‚¹ï¼Œè¿™ä¸ªä¸–ç•Œçš„è§„åˆ™ä¸è®¸æˆ‘ä»¬çœ‹åˆ°å®ƒä»¬ã€‚äº¡çµæ¸¸è¡äºä¸–é—´ï¼Œæ‰€è®¤çŸ¥çš„è§„åˆ™å·²ç»ä¸å†æˆç«‹ã€‚ æ—¢ç„¶è¿™æ ·ï¼Œè§†è§‰è¿˜æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿ æ¬¢è¿æ”¶çœ‹åæœˆå¤§å‹æ–°ç•ªã€Šæš‚æ—¶æ²¡æœ‰åå­—ã€‹ï¼Œä¸Šé›†å›é¡¾ï¼Œå¤§å®¶éå¸¸æƒ³çœ‹ç»­é›†ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ—¥æ›´ï¼ ç©ºé—´å¤§ç›—ä¸æ—¶é—´æ—…äºº ç©ºé—´å¤§ç›—æ˜¯å¯ä»¥è½¬ç§»ç¡¬ç›˜çš„å­˜å‚¨é¡ºåºï¼Œä»è€Œè®©æ•°æ®æ¯åçš„ã€‚ æˆ‘è¦å‘ @AC_love å®£æˆ˜ï¼å­¦ä¹ è‡ªå·±å–œæ¬¢çš„çŸ¥è¯†æ˜¯ä¸€ä¸ªäººçš„è‡ªç”±ï¼Œæ²¡æœ‰ä»»ä½•äººå¯ä»¥é˜»æ­¢ï¼ æˆ‘è¦å‘ ACL æŠ•å‡ºåŠ å†œç‚®ï¼æå«è€å¹´é«˜äºŒé€‰æ‰‹çš„å¼ºå¤§å­¦ä¹ èƒ½åŠ›ä¸åšé¢˜èƒ½åŠ›ï¼Œæˆ‘è¾ˆä¹‰ä¸å®¹è¾ï¼ï¼å³ä½¿æˆ‘æ˜¯é«˜äºŒæœ€å¼±æˆ˜æ–—åŠ›ï¼Œæˆ‘ä¹Ÿè¦ç«™å‡ºæ¥ï¼Œä¸ä¾èµ–æ—¶é—´æ—…äººæœ‹å‹çš„åŠ›é‡ï¼Œå¤§æˆ˜é‚ªæ¶åŠ¿åŠ›ï¼ï¼ å¯ä»¥å°†è¿™æ®µè¯è§†ä½œç©ç¬‘ï¼Œæ²¡æœ‰ä»»ä½•å¼•æˆ˜çš„æ„æ€ã€‚å¤§å®¶å¥½å¥½å­¦ä¹ ï¼Œä¸€èµ·è¿›æ­¥ï¼ Deltix Summer 2021 (Div. 1 + Div. 2) Portal. ä½ çŒœçŒœä¸ºä»€ä¹ˆéšæœºåˆ°äº†è¿™åœºå‘¢ï¼Ÿ æˆ‘æ˜¯â€”â€”å‚»æ‰‹ï¼ Easy Problems å¦‚æœèµ¶æ—¶é—´å¯ä»¥è·³è¿‡ã€‚ A. A Variety of Operations Portal. å‘ç°ç­”æ¡ˆæ˜¯ [âˆ’1,2][-1,2][âˆ’1,2]ï¼Œç›´æ¥æã€‚ #include &lt;bits/stdc++.h> using namespace std; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int c, d; scanf(\"%d%d\", &amp;c, &amp;d); if (d > c) swap(c, d); if ((c - d) % 2 != 0) puts(\"-1\"); else &#123; if (c == 0 &amp;&amp; d == 0) puts(\"0\"); else if (c == d) puts(\"1\"); else puts(\"2\"); &#125; &#125; return 0; &#125; B. Take Your Places! Portal. å¯¹å¥‡å¶è®¨è®ºä¸€ä¸‹å°±è¡Œã€‚ #include &lt;bits/stdc++.h> using namespace std; int n, even, odd; int a[100005]; inline void calc1(void) &#123; if (even != odd) return puts(\"-1\"), void(); int suma = 0, sumb = 0; int posa = 1, posb = 2; for (int i = 1; i &lt;= n; ++i) if (a[i] % 2 == 0) &#123; suma += abs(posa - i); posa += 2; sumb += abs(posb - i); posb += 2; &#125; printf(\"%d\\n\", min(suma, sumb)); &#125; inline void calc2(void) &#123; if (abs(even - odd) != 1) return puts(\"-1\"), void(); if (even > odd) &#123; int pos = 1, ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] % 2 == 0) ans += abs(pos - i), pos += 2; printf(\"%d\\n\", ans); &#125; else &#123; int pos = 1, ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] % 2 == 1) ans += abs(pos - i), pos += 2; printf(\"%d\\n\", ans); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); even = 0, odd = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] % 2 == 0) ++even; else ++odd; &#125; if (n % 2 == 0) calc1(); else calc2(); &#125; return 0; &#125; C. Compressed Bracket Sequence Portal. O(n2)O(n^2)O(n2) æšä¸¾å³å¯ã€‚ #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; i64 ans; int n, c[1005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", c + i); for (int l = 0; l &lt; n; l += 2) &#123; i64 cur = c[l], mn = c[l]; for (int r = l + 1; r &lt; n; ++r) if (r % 2 == 0) cur += c[r]; else &#123; i64 i = max(0ll, cur - c[r]); i64 j = min(&#123;mn, cur - 1, c[l] - 1ll&#125;); if (i &lt;= j) ans += j - i + 1; cur -= c[r]; mn = min(mn, cur); &#125; &#125; return !printf(\"%d\\n\", ans); &#125; D. Take a Guess Portal. æŒ‰ä½æˆ–åŠ æŒ‰ä½ä¸ç­‰äºè¿ç®—åŠ ï¼Œè§£æ–¹ç¨‹å°±è¡Œã€‚ #include &lt;bits/stdc++.h> using namespace std; int n, k, a[10005]; int qsum(int x, int y) &#123; int s, t; cout &lt;&lt; \"and \" &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; cin >> s; cout &lt;&lt; \"or \" &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; cin >> t; return s + t; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> k; int x = qsum(1, 2), y = qsum(1, 3), z = qsum(2, 3); a[2] = (x - y + z) / 2; a[1] = x - a[2]; a[3] = z - a[2]; for (int i = 4; i &lt;= n; ++i) a[i] = qsum(1, i) - a[1]; nth_element(a + 1, a + k, a + n + 1); cout &lt;&lt; \"finish \" &lt;&lt; a[k] &lt;&lt; endl; return 0; &#125; Medium Problems æœ‰ä¸€å®šéš¾åº¦çš„é—®é¢˜ã€‚ E. Equilibrium Portal. å¥—è·¯åœ°ï¼Œä»¤ vi=aiâˆ’biv_i=a_i-b_iviâ€‹=aiâ€‹âˆ’biâ€‹ï¼Œæ¯æ¬¡å¯ä»¥å°†å¥‡æ•°ä½ç½® +1+1+1ï¼Œå¶æ•°ä½ç½® âˆ’1-1âˆ’1ï¼Œé—®æœ€å°‘æ“ä½œæ¬¡æ•°ä½¿ä¹‹å˜æˆ 000ã€‚ å°† vvv å‰ç¼€å’Œä¸€ä¸‹ï¼Œå‘ç°æ¯æ¬¡æ“ä½œå®é™…ä¸Šæ˜¯åœ¨å‰ç¼€å’ŒåŒºé—´ä¸Šè¿›è¡Œ k/2k/2k/2 ç»„åŒºé—´åŠ ã€‚é‚£ä¹ˆç­”æ¡ˆå°±ç›´æ¥æ¨å‡ºæ¥äº†ï¼šslâˆ’1âˆ’minâ¡{slâ€¦r}s_{l-1}-\\min\\{s_{l\\dots r}\\}slâˆ’1â€‹âˆ’min{slâ€¦râ€‹}ã€‚å½“ç„¶éœ€è¦åˆ¤æ‰æ— è§£ï¼Œä¹Ÿä¸éš¾ã€‚ #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, q; int a[100005]; i64 s[100005]; i64 mn[17][100005], mx[17][100005]; inline i64 qmin(int l, int r) &#123; int k = __lg(r - l + 1); return min(mn[k][l], mn[k][r - (1 &lt;&lt; k) + 1]); &#125; inline i64 qmax(int l, int r) &#123; int k = __lg(r - l + 1); return max(mx[k][l], mx[k][r - (1 &lt;&lt; k) + 1]); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> q; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1, x; i &lt;= n; ++i) cin >> x, a[i] -= x; for (int i = 1; i &lt;= n; ++i) mn[0][i] = mx[0][i] = s[i] = s[i - 1] + a[i]; for (int i = 1; i &lt;= 17; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mn[i][j] = min(mn[i - 1][j], mn[i - 1][j + (1 &lt;&lt; i - 1)]), mx[i][j] = max(mx[i - 1][j], mx[i - 1][j + (1 &lt;&lt; i - 1)]); while (q--) &#123; int l, r; cin >> l >> r; if (s[r] == s[l - 1] &amp;&amp; qmax(l, r) &lt;= s[l - 1]) cout &lt;&lt; s[l - 1] - qmin(l, r) &lt;&lt; \"\\n\"; else cout &lt;&lt; \"-1\\n\"; &#125; return 0; &#125; * F. Sports Betting Portal.æœ‰ n(nâ‰¤14)n(n\\le 14)n(nâ‰¤14) ä¸ªäººï¼Œä¸¤ä¸¤ä¹‹é—´ä¼šæ‰“æ¯”èµ›ã€‚æ¯äººæœ‰ä¸€ä¸ªå®åŠ›å€¼ aia_iaiâ€‹ï¼Œåœ¨ iii ä¸ jjj çš„æ¯”èµ›ä¸­ï¼Œiii æœ‰ aiai+aj\\frac {a_i}{a_i+a_j}aiâ€‹+ajâ€‹aiâ€‹â€‹ çš„æ¦‚ç‡è·èƒœï¼Œå…¶ä»–æƒ…å†µåˆ™æ˜¯ jjj è·èƒœã€‚iii åœ¨ä¸ jjj çš„æ¯”èµ›ä¸­è·èƒœåˆ™ç§° iii æ‰“è´¥äº† jjjã€‚è‹¥ iii æ‰“è´¥äº† jjjï¼Œjjj æ‰“è´¥äº† kkkï¼Œåˆ™è®¤ä¸º iii ä¹Ÿæ‰“è´¥äº† kkkã€‚è‹¥ iii æ‰“è´¥äº†é™¤äº†ä»–è‡ªå·±ä»¥å¤–çš„æ‰€æœ‰äººï¼Œåˆ™ç§° iii æ˜¯ä¸€ä¸ª Winnerï¼ˆæ˜¯å¦æ‰“è´¥äº†è‡ªå·±ä¸è¦æ±‚ï¼‰ï¼Œæ³¨æ„ Winner å¯èƒ½æœ‰å¤šä¸ªã€‚ç°åœ¨ä½ éœ€è¦æ±‚å‡º Winner çš„æœŸæœ›æ•°é‡ï¼Œå¯¹ 109+710^9+7109+7 å–æ¨¡ã€‚ è€ƒè™‘çŠ¶å‹ DPï¼Œè®¾ f(i,S)f(i,S)f(i,S) ä»£è¡¨ iii æ‰“è´¥äº† SSS ä¸­äººçš„æ¦‚ç‡ã€‚å®¹æ–¥ï¼Œç­”æ¡ˆä¸ºï¼š f(i,S)=1âˆ’âˆ‘TâŠ‚Sf(i,T)âˆjâˆˆSâˆ’TâˆkâˆˆTajaj+akf(i,S)=1-\\sum_{T\\subset S}f(i,T)\\prod_{j\\in S-T}\\prod_{k\\in T} \\frac{a_j}{a_j+a_k} f(i,S)=1âˆ’TâŠ‚Sâˆ‘â€‹f(i,T)jâˆˆSâˆ’Tâˆâ€‹kâˆˆTâˆâ€‹ajâ€‹+akâ€‹ajâ€‹â€‹ é¢„å¤„ç† g(i,S)=âˆjâˆˆSajaj+aig(i,S)=\\prod_{j\\in S} \\frac{a_j}{a_j+a_i}g(i,S)=âˆjâˆˆSâ€‹ajâ€‹+aiâ€‹ajâ€‹â€‹ï¼Œé‚£ä¹ˆï¼š f(i,S)=1âˆ’âˆ‘TâŠ‚Sf(i,T)âˆkâˆˆTg(k,Sâˆ’T)f(i,S)=1-\\sum_{T\\subset S}f(i,T)\\prod_{k\\in T} g(k,S-T) f(i,S)=1âˆ’TâŠ‚Sâˆ‘â€‹f(i,T)kâˆˆTâˆâ€‹g(k,Sâˆ’T) æ—¶é—´å¤æ‚åº¦ O(n23n)O(n^2 3^n)O(n23n)ã€‚ #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int N = 2000000; int n; int a[1 &lt;&lt; 14], f[14][1 &lt;&lt; 14], g[14][1 &lt;&lt; 14]; int inv[N + 5]; inline int lowbit(int x) &#123; return x &amp; -x; &#125; inline int calc(int T, int ST) &#123; int res = 1; for (int i = 0; i &lt; n; ++i) if (T >> i &amp; 1) res = 1ll * res * g[i][ST] % P; return res; &#125; int main(void) &#123; inv[1] = 1; for (int i = 2; i &lt;= N; ++i) inv[i] = 1ll * (P - P / i) * inv[P % i] % P; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;a[1 &lt;&lt; i]); for (int i = 0; i &lt; n; ++i) &#123; g[i][0] = 1; for (int s = 1; s &lt; 1 &lt;&lt; n; ++s) g[i][s] = 1ll * g[i][s ^ lowbit(s)] * a[lowbit(s)] % P * inv[a[lowbit(s)] + a[1 &lt;&lt; i]] % P; &#125; for (int i = 0; i &lt; n; ++i) for (int s = 0; s &lt; 1 &lt;&lt; n; ++s) if (s >> i &amp; 1) &#123; f[i][s] = 1; for (int t = (s - 1) &amp; s; t; t = (t - 1) &amp; s) f[i][s] = (f[i][s] - 1ll * f[i][t] * calc(t, s - t) % P) % P; &#125; int ans = 0; for (int i = 0; i &lt; n; ++i) ans = (ans + f[i][(1 &lt;&lt; n) - 1]) % P; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; Hard Problems æ¯”è¾ƒå›°éš¾çš„é—®é¢˜ã€‚ ** G. Gates to Another World Portal.æœ‰ 2n2^n2n ä¸ªç‚¹ï¼Œç¼–å·ä¸º i,ji,ji,j çš„ç‚¹ä¹‹é—´æœ‰æ— å‘è¾¹å½“ä¸”ä»…å½“ popcount(iâŠ•j)=1\\mathrm{popcount}(i \\oplus j)=1popcount(iâŠ•j)=1ã€‚æœ‰ mmm æ¬¡æ“ä½œï¼Œæ¯æ¬¡è¯¢é—® a,ba,ba,b æ˜¯å¦èƒ½äº’ç›¸åˆ°è¾¾ï¼Œæˆ–è€…åˆ é™¤ç¼–å·åœ¨ [l,r][l,r][l,r] ä¹‹é—´çš„æ‰€æœ‰ç‚¹ï¼Œä¿è¯æ²¡æœ‰ç‚¹ä¼šè¢«åˆ é™¤ä¸¤æ¬¡ã€‚nâ‰¤50,mâ‰¤5Ã—104n\\le 50,m\\le 5\\times 10^4nâ‰¤50,mâ‰¤5Ã—104ã€‚ è€ƒè™‘é€†æ—¶æ—…äººï¼Œå°†åˆ ç‚¹æ”¹æˆåŠ ç‚¹ã€‚ æœ€ä¸»è¦çš„é—®é¢˜æ˜¯ï¼Œå¦‚ä½•ç”¨ä¸€ç§æ–¹å¼æ¥å‹ç¼©å›¾ï¼Ÿå¯¹äºä¸€ä¸ªæ²¡æœ‰è¢«åˆ ç‚¹çš„è¿ç»­ 2i2^i2i æ®µï¼Œä¸€å®šæ˜¯è¿é€šçš„ã€‚è¿™ç§æ–¹å¼ä¸çº¿æ®µæ ‘æœ‰ç›´æ¥å…³ç³»ï¼Œè€ƒè™‘ç”¨çº¿æ®µæ ‘ç»“æ„æ¥åˆ»ç”»è¿™ä¸ªä¸œè¥¿ï¼Œç„¶åç‚¹æ•°å°±ä¸åˆ ç‚¹æ¬¡æ•°æœ‰å…³ã€‚ æ³¨æ„ä¸€ä¸ªä½ç½®åªä¼šè¢«åˆ é™¤ä¸€æ¬¡ï¼Œè¿™å¾ˆå¥½ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨çº¿æ®µæ ‘ä¸ŠåŒºé—´æŸ“è‰²ï¼Œä»£è¡¨è¿™äº›ç‚¹å­˜æ´»åˆ°äº† iii æ—¶åˆ»ã€‚ è¿™æ ·å¯¹äºåŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ä¸Šçš„å­˜åœ¨çš„ç‚¹ï¼Œæ‰æ˜¯æœ‰æ„ä¹‰çš„ç‚¹ï¼Œå…¶ä½™æ‰€æœ‰ç‚¹éƒ½å¯ä»¥è¢«æ˜ å°„åˆ°å®ƒä»¬èº«ä¸Šã€‚å¯¹äºæ¯ä¸ªèŠ‚ç‚¹å°†åœ¨ minâ¡{lsi,rsi}\\min\\{ls_i,rs_i\\}min{lsiâ€‹,rsiâ€‹} æ—¶åˆ»å°†å®ƒçš„å·¦å³å„¿å­åˆ†è£‚å¼€ï¼ˆä¸å†è¿é€šï¼‰ï¼Œé€†æ—¶æ—…äººå¹¶æŸ¥é›†ç»´æŠ¤å³å¯ã€‚ æœ¬é¢˜å¡ç©ºé—´ï¼Œæ³¨æ„ä½ çš„å†…å­˜æ¶ˆè€—ã€‚ #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 50005 * 120; struct Query &#123; string op; i64 x, y; &#125; Q[50005]; int n, m, ans[50005]; int fa[N + 5]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; int ls[N + 5], rs[N + 5], dat[N + 5], tot; #define leaf(o) (!ls[o] &amp;&amp; !rs[o]) inline void pushdown(int o) &#123; if (!ls[o]) ls[o] = ++tot; if (!rs[o]) rs[o] = ++tot; if (dat[o]) dat[ls[o]] = dat[rs[o]] = dat[o], dat[o] = 0; &#125; void update(int o, i64 l, i64 r, i64 x, i64 y, int t) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return dat[o] = t, void(); pushdown(o); i64 mid = l + r >> 1; if (x &lt;= mid) update(ls[o], l, mid, x, y, t); if (mid &lt; y) update(rs[o], mid + 1, r, x, y, t); &#125; int locate(int o, i64 l, i64 r, i64 p) &#123; if (leaf(o)) return o; i64 mid = l + r >> 1; if (p &lt;= mid) return locate(ls[o], l, mid, p); return locate(rs[o], mid + 1, r, p); &#125; vector&lt;pair&lt;int, int>> edge[50005]; void connect(int x, int y) &#123; if (leaf(x) &amp;&amp; leaf(y)) return edge[min(dat[x], dat[y])].emplace_back(x, y), void(); if (leaf(x)) return connect(x, ls[y]), connect(x, rs[y]); if (leaf(y)) return connect(ls[x], y), connect(rs[x], y); connect(ls[x], ls[y]); connect(rs[x], rs[y]); &#125; int main(void) &#123; for (int i = 1; i &lt;= N; ++i) fa[i] = i; ios_base::sync_with_stdio(0); cin >> n >> m; i64 u = 1ll &lt;&lt; n; dat[++tot] = m + 1; for (int i = 1; i &lt;= m; ++i) &#123; cin >> Q[i].op >> Q[i].x >> Q[i].y; if (Q[i].op == \"block\") update(1, 0, u - 1, Q[i].x, Q[i].y, i); &#125; for (int i = 1; i &lt;= tot; ++i) if (!leaf(i)) connect(ls[i], rs[i]); for (int i = m + 1; i >= 1; --i) &#123; for (auto [u, v] : edge[i]) fa[find(u)] = find(v); if (Q[i].op == \"ask\") ans[i] = (find(locate(1, 0, u - 1, Q[i].x)) == find(locate(1, 0, u - 1, Q[i].y))); &#125; for (int i = 1; i &lt;= m; ++i) if (Q[i].op == \"ask\") cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; ** H. DIY Tree Portal.ç»™å®šä¸€ä¸ª nnn ä¸ªç‚¹çš„æ— å‘å¸¦æƒå®Œå…¨å›¾ï¼Œæ‰¾å‡ºä¸€ä¸ªæ»¡è¶³ç¬¬ i(iâ‰¤k)i(i\\le k)i(iâ‰¤k) ä¸ªåº¦æ•° â‰¤di\\le d_iâ‰¤diâ€‹ çš„æœ€å°ç”Ÿæˆæ ‘ã€‚nâ‰¤50,kâ‰¤5n\\le 50,k\\le 5nâ‰¤50,kâ‰¤5ã€‚ æœ¬é¢˜æ­£è§£éœ€è¦ä½¿ç”¨æ‹Ÿé˜µï¼Œä½†æ˜¯æ­¤å†…å®¹åœ¨ç®—æ³•ç«èµ›ä¸­çš„åº”ç”¨ä¸å¤šï¼Œå¯¹ç¬”è€…æ¥è¯´å­¦ä¹ çš„æ”¶ç›Šè¿‡ä½ï¼Œå› æ­¤è¿™é‡Œå†™ä¸€ä¸‹æœ¬é¢˜çš„éšæœºåŒ–åšæ³•ã€‚ sto lsy orzï¼ ç»™ç”Ÿæˆæ ‘å®šä¹‰ä¼°ä»·å‡½æ•° f(T)=âˆ‘i=1Kmaxâ¡{0,Diâˆ’di}f(T)=\\sum_{i=1}^K \\max\\{0,D_i-d_i\\}f(T)=âˆ‘i=1Kâ€‹max{0,Diâ€‹âˆ’diâ€‹}ï¼Œå…¶ä¸­ DiD_iDiâ€‹ ä»£è¡¨å®é™…åº¦æ•°ã€‚ å…ˆæ±‚å‡ºæœ€å°ç”Ÿæˆæ ‘ï¼Œç„¶åå¯¹å…¶è¿›è¡Œè°ƒæ•´ã€‚æ¯æ¬¡é€‰æ‹©ä¸€æ¡è¾¹æƒæœ€å¤§çš„ï¼Œåˆ å»å fff ä¼šå‡å°çš„è¾¹ e1e_1e1â€‹ï¼Œæ›¿æ¢æˆåŠ ä¸Šå fff ä¸ä¼šå˜å¤§çš„è¾¹æƒæœ€å°çš„è¾¹ e2e_2e2â€‹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n3)O(n^3)O(n3)ã€‚ éšæœºåŒ–è¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬ç»™ e1e_1e1â€‹ å’Œ e2e_2e2â€‹ çš„é€‰æ‹©åŠ ä¸Šä¸€ä¸ªæ¦‚ç‡ï¼Œä¸é€‰å°±æ¥ç€æ‰«ã€‚ #include &lt;bits/stdc++.h> using namespace std; mt19937 Rand(time(0)); int n, k; int a[55], G[55][55]; struct edge &#123; int u, v, w, f; edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; bool operator&lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125;; vector&lt;edge> e; int Ans = 1e9; int fa[55]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; int d[55]; inline int f(void) &#123; int r = 0; for (int i = 1; i &lt;= k; ++i) r += max(0, d[i] - a[i]); return r; &#125; void solve(void) &#123; // cerr &lt;&lt; \"SOLVE\\n\"; int ans = 0; for (int i = 1; i &lt;= n; ++i) fa[i] = i, d[i] = 0; for (auto &amp;it : e) &#123; it.f = 0; int u = find(it.u), v = find(it.v); if (u == v) continue; fa[u] = v; ans += it.w; ++d[it.u]; ++d[it.v]; it.f = 1; &#125; int now = 0; while (now = f()) &#123; // cerr &lt;&lt; now &lt;&lt; \"\\n\"; int p = -1; while (p == -1) &#123; for (int i = e.size() - 1; i >= 0; --i) &#123; auto &amp;it = e[i]; if (it.f &amp;&amp; (d[it.u] > a[it.u] || d[it.v] > a[it.v]) &amp;&amp; Rand() % 4) &#123; --d[it.u], --d[it.v]; ans -= it.w; it.f = 0; p = i; break; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (auto &amp;it : e) if (it.f) fa[find(it.u)] = find(it.v); int tmp = 1e9; for (int i = 0; i &lt; e.size(); ++i) &#123; auto &amp;it = e[i]; if (i != p &amp;&amp; !it.f &amp;&amp; find(it.u) != find(it.v)) &#123; ++d[it.u]; ++d[it.v]; tmp = min(tmp, f() - now); --d[it.u]; --d[it.v]; &#125; &#125; bool flag = 0; while (!flag) &#123; for (int i = 0; i &lt; e.size(); ++i) &#123; auto &amp;it = e[i]; if (i != p &amp;&amp; !it.f &amp;&amp; find(it.u) != find(it.v)) &#123; ++d[it.u]; ++d[it.v]; if ((f() - now &lt; 0 || tmp >= 0) &amp;&amp; Rand() % 4) &#123; it.f = 1, ans += it.w, flag = 1; break; &#125; --d[it.u]; --d[it.v]; &#125; &#125; &#125; &#125; Ans = min(Ans, ans); &#125; int main(void) &#123; ios_base::sync_with_stdio(0); cin >> n >> k; for (int i = 1; i &lt;= k; ++i) cin >> a[i]; for (int i = k + 1; i &lt;= n; ++i) a[i] = 1e9; for (int i = 1, x; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) cin >> x, e.emplace_back(i, j, x); sort(e.begin(), e.end()); double st = clock(); do solve(); while (1000 * (clock() - st) / CLOCKS_PER_SEC &lt; 5700); cout &lt;&lt; Ans &lt;&lt; \"\\n\"; return 0; &#125; After Memories æˆ‘ä»¬å¯ä»¥ç›¸ä¿¡æˆ‘ä»¬çš„è§†è§‰å—ï¼Ÿ åœ¨å½“ä¸‹çš„æƒ…å†µï¼Œä¹Ÿè®¸æˆ‘ä»¬å¯ä»¥å°å¿ƒç¿¼ç¿¼åœ°è¸±æ­¥ï¼Œæ¥ä¿è¯ä¸è¦çœ‹ä¸æ¸…ä¼šå¯¼è‡´æˆ‘ä»¬æ‘”å€’çš„ä¸œè¥¿ã€‚ ä½†è¿™ä¹Ÿåªæ˜¯è¡¨è±¡ï¼Œæˆ‘ä»¬ä¾ç„¶æ— æ³•çœ‹æ¸…ä¸€åˆ‡ã€‚å½“å¿½ç•¥çš„ä¸œè¥¿è¶³å¤Ÿå¤šï¼Œç»ˆå°†é…¿æˆå¤§ç¥¸ã€‚ ä¹Ÿè®¸è¿™å°±æ˜¯ç”Ÿå‘½ç»ˆç»“çš„åŸå› ã€‚å¦‚æœæœ‰ç”Ÿç‰©å¯ä»¥çœ‹æ¸…ä¸€åˆ‡ï¼Œé‚£æˆ‘ç›¸ä¿¡å®ƒä»¬æ˜¯æ°¸ç”Ÿçš„ã€‚ æ„¿ä½ èƒ½åœ¨é¥è¿œçš„å¤©é™…çº¿è¾¹æ‰¾åˆ°è‡ªæˆ‘","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/categories/%E9%97%B2%E8%AF%9D/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"}]},{"title":"NOI ä¸€è½®å¤ä¹  Vï¼šåŠ¨æ€è§„åˆ’","slug":"notes/NOI å¤ä¹ /noi-1-5","date":"2023-10-05T00:00:00.000Z","updated":"2024-04-14T00:00:00.000Z","comments":true,"path":"10a85982/","link":"","permalink":"https://james1badcreeper.github.io/10a85982/","excerpt":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬äº”ç¯‡ï¼ŒåŒ…æ‹¬åŠ¨æ€è§„åˆ’çš„çŠ¶æ€è®¾è®¡å’Œè½¬ç§»ä¼˜åŒ–ã€‚","text":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬äº”ç¯‡ï¼ŒåŒ…æ‹¬åŠ¨æ€è§„åˆ’çš„çŠ¶æ€è®¾è®¡å’Œè½¬ç§»ä¼˜åŒ–ã€‚ åŠ¨æ€è§„åˆ’æ˜¯ OI æœ€é‡è¦çš„éƒ¨åˆ†ä¹‹ä¸€ã€‚ä»å­¦ä¹ ä¸åšé¢˜çš„è§’åº¦æ¥è¯´ï¼Œä¸»è¦åˆ†ä¸ºè®¾è®¡çŠ¶æ€ä¸ä¼˜åŒ–ä¸¤éƒ¨åˆ†ã€‚å…¶ä¸­å‰è€…æ›´å¤šçš„æ˜¯åšé¢˜å’Œæ€»ç»“æ–¹æ³•ä¸å¥—è·¯ï¼Œè€Œåè€…ç›¸å¯¹åƒç»éªŒã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¾ˆå¤šé¢˜ç›®éƒ½è¦æ±‚æˆ‘ä»¬åœ¨è®¾è®¡ç®—æ³•ä»¥å‰å…ˆå°†é¢˜ç›®è¿›è¡Œä¸€å®šçš„è½¬åŒ–ï¼Œä»è€Œå°†ä¸€ä¸ªä¸ç†Ÿæ‚‰çš„æ¨¡å‹è½¬åŒ–ä¸ºæˆ‘ä»¬æ›´å®¹æ˜“æŠŠæ¡çš„æ¨¡å‹ã€‚è¿™ä¸€ç‚¹åœ¨åŠ¨æ€è§„åˆ’çš„é¢˜ç›®ä¸­ä½“ç°çš„å°¤ä¸ºæ˜æ˜¾ã€‚ åŠ¨æ€è§„åˆ’çš„çŠ¶æ€è®¾è®¡ æ³¨æ„åŸºæœ¬æ¨¡å‹ã€‚ çº¿æ€§ DP åœ¨çº¿æ€§ç»“æ„ä¸Šæšä¸¾æ¯ä¸€ç»´åº¦è¿›è¡Œè½¬ç§»çš„ DPã€‚ [CF1810G] The Maximum Prefixã€‚è¾ƒå¤æ‚ï¼Œè§åŸé¢˜é¢ã€‚ å¯¹äºä»»æ„ä¸€æ®µåç¼€ï¼Œå…¶èƒ½å¯¹æ•´ä¸ªåºåˆ—çš„æœ€å¤§å‰ç¼€å’Œäº§ç”Ÿè´¡çŒ®çš„éƒ½æ˜¯å…¶æœ€å¤§å‰ç¼€å’Œã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªæ•°ï¼Œ[i+1,n][i+1,n][i+1,n] çš„æœ€å¤§å‰ç¼€å’Œä¸º jjj çš„æœŸæœ›ç­”æ¡ˆã€‚å¯ä»¥ä»¥ pip_ipiâ€‹ çš„ç³»æ•°è½¬ç§»åˆ° fi+1,maxâ¡{jâˆ’1,0}f_{i+1,\\max\\{j-1,0\\}}fi+1,max{jâˆ’1,0}â€‹ï¼Œ1âˆ’pi1-p_i1âˆ’piâ€‹ çš„ç³»æ•°è½¬ç§»åˆ° fi+1,j+1f_{i+1,j+1}fi+1,j+1â€‹ã€‚ ç­”æ¡ˆä¾¿æ˜¯ fi,0f_{i,0}fi,0â€‹ã€‚ä»£ç ã€‚ èƒŒåŒ… åŸºæœ¬æ¨¡å‹ï¼š01 èƒŒåŒ…ã€å®Œå…¨èƒŒåŒ…ã€å¤šé‡èƒŒåŒ…ã€åˆ†ç»„èƒŒåŒ…ã€æ–¹æ¡ˆæ•°èƒŒåŒ…çš„æ’¤å›ï¼ˆå°†è½¬ç§»çš„ä¸œè¥¿å‡å»å³å¯ï¼‰ã€‚ [åäºŒçœè”è€ƒ 2019] çš®é…ã€‚æœºæ¢°å¤§å¸ˆæœ‰ ccc ä¸ªå·¥å…·ç®±ï¼Œnnn ä¸ªèºä¸ï¼Œæ¯ä¸ªèºä¸éƒ½æœ‰è‡ªå·±çš„è´¨é‡ï¼Œéœ€è¦å°†èºä¸è®¾å®šä¸ºæ™®é€šèºé’‰/è‡ªæ”»èºé’‰ã€ä¸‰è§’èºçº¹/æ–¹èºçº¹ã€‚ä¸€ä¸ªå·¥å…·ç®±é‡Œçš„èºä¸å¿…é¡»éƒ½æ˜¯æ™®é€šèºé’‰ï¼Œæˆ–è€…éƒ½æ˜¯è‡ªæ”»èºé’‰ã€‚è¦æ±‚ æ™®é€š/è‡ªæ”»/ä¸‰è§’/æ–¹ çš„èºä¸æ€»è´¨é‡ä¸è¶…è¿‡ C0,C1,D0,D1C_0,C_1,D_0,D_1C0â€‹,C1â€‹,D0â€‹,D1â€‹ã€‚æœ‰ KKK ä¸ªèºä¸ä¸å¯ä»¥è¢«è®¾å®šæˆæŸç§èºä¸ï¼ˆå¦‚ä¸èƒ½è®¾å®šä¸ºä¸‰è§’è‡ªæ”»ï¼‰ã€‚é—®æœ‰å¤šå°‘ç§æ–¹æ¡ˆï¼Œå¯¹ 998244353998244353998244353 å–æ¨¡ã€‚n,câ‰¤103,kâ‰¤30n,c\\le 10^3,k\\le 30n,câ‰¤103,kâ‰¤30ã€‚ ä¸ºæ–¹ä¾¿åˆ†ææ—¶é—´å¤æ‚åº¦ï¼Œè®° M=maxâ¡{C,D}M=\\max\\{C,D\\}M=max{C,D}ã€‚ è€ƒè™‘ K=0K=0K=0 æ€ä¹ˆåšã€‚åˆ†åˆ«è€ƒè™‘åˆ’åˆ†ä¸¤ç§ç‰¹å¾ï¼Œä¸¤æ¬¡èƒŒåŒ…åˆ†åˆ«å¯¹å·¥å…·ç®±å’Œèºä¸è¿›è¡Œ DP å³å¯ã€‚ å‘ç° KKK å¾ˆå°ï¼Œè€ƒè™‘é’ˆå¯¹å®ƒè®¾è®¡çŠ¶æ€ã€‚å¯¹äºä¸æ˜¯è¿™ KKK ä¸ªæ²¡äº‹æ‰¾äº‹çš„èºä¸ï¼Œå‰é¢çš„ DP åšæ³•ä¾ç„¶æˆç«‹ã€‚ç„¶åå†è€ƒè™‘è¿™äº›æ²¡äº‹æ‰¾äº‹çš„ã€‚ è®¾ F(i,j,k)F(i,j,k)F(i,j,k) ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªå·¥å…·ç®±ï¼Œæ™®é€šèºé’‰çš„é‡é‡ä¸º jjjï¼Œä¸‰è§’èºçº¹çš„é‡é‡ä¸º kkkã€‚éœ€è¦æšä¸¾å½“å‰çš„é€‰çš„ä¸œè¥¿æ˜¯ä»€ä¹ˆå’Œä¸Šä¸€ä¸ªä¸œè¥¿æ˜¯ä»€ä¹ˆã€‚æ»šæ‰ iii è¿™ä¸€ç»´ï¼Œæ‰€æœ‰çŠ¶æ€éƒ½æ˜¯å¯ä»¥è½¬ç§»çš„ï¼Œè€ƒè™‘ç”¨è¿™ç§æ–¹å¼å¤„ç†æ²¡äº‹æ‰¾äº‹çš„èºä¸ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(k2wM)O(k^2 w M)O(k2wM)ã€‚ ç„¶åæšä¸¾ä½“ç§¯ï¼Œè¿›è¡ŒèƒŒåŒ…åˆå¹¶å³å¯ã€‚ä»£ç ã€‚ åŒºé—´ DP åŒºé—´ DP æœ‰ä¸¤ç§ï¼Œåˆ†åˆ«æ˜¯ä»ä¸¤è¾¹æ‰©å±•å’Œä¸­é—´æšä¸¾æ–­ç‚¹çš„ã€‚å¦‚æœä¿¡æ¯å¯ä»¥â€œåˆå¹¶â€ï¼Œé‚£ä¹ˆå¤§æ¦‚ç‡æ˜¯åŒºé—´ DPã€‚ [THUPC2021] å° E çˆ±æ¶ˆé™¤ã€‚è¾ƒå¤æ‚ï¼Œè§åŸé¢˜é¢ã€‚ ä¸éš¾æƒ³åˆ°åŒºé—´ DPï¼Œè€ƒè™‘ gl,rg_{l,r}gl,râ€‹ ä»£è¡¨ [l,r][l,r][l,r] çš„æœ€å°å‰©ä½™æ•°å’Œæ ˆå¤§å°ã€‚è½¬ç§»æ—¶å¯ä»¥ç›´æ¥å°† lll æˆ– rrr æ”¾è¿›æ ˆä¸­ï¼Œä¹Ÿå¯ä»¥åœ¨ [l,r][l,r][l,r] ä¸­å¯»æ‰¾ä¸€ä¸ª iii ä¸ lll æˆ– rrr åˆ é™¤ã€‚ä»¥ ala_lalâ€‹ å’Œ aia_iaiâ€‹ é…å¯¹ä¸ºä¾‹ï¼Œè€ƒè™‘ä¿ç•™ä¸€æ®µ [i+1,j][i+1,j][i+1,j] æˆ–è€…æ˜¯ [j,iâˆ’1][j,i-1][j,iâˆ’1]ï¼Œåˆ™éœ€è¦å°†å‰©ä¸‹çš„ä¸¤ç«¯å®Œå…¨åˆ é™¤ï¼Œä¸­é—´ä¼šå¤¹ä¸€ä¸ª iii å’Œå¦ä¸€ç«¯éœ€è¦å¤„ç†çš„å†…å®¹ï¼Œåˆ¤æ–­ä¸¤ç«¯æ˜¯å¦å®Œå…¨åˆ é™¤ä¾ç„¶å¯ä»¥é‡‡ç”¨åŒºé—´ DPã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(n6)O(n^6)O(n6)ï¼Œä½†æ˜¯éæ³•çŠ¶æ€å¾ˆå¤šï¼Œå¯ä»¥é€šè¿‡ã€‚ä»£ç ã€‚ å›¾ä¸Š DP æ ‘ä¸Š DP ä¸€èˆ¬æŒ‰ç…§æ‹“æ‰‘åºè¿›è¡Œæ±‚è§£ï¼Œæ³¨æ„åˆå¹¶æ—¶æ˜¯åŠ è¾¹è¿˜æ˜¯åŠ ç‚¹ã€‚ æ¢æ ¹ DPã€‚å¦‚æœä¸€æ¡è¾¹çš„è´¡çŒ®å¯ä»¥å¾ˆç®€å•çš„è½¬åŒ–ï¼Œé‚£ä¹ˆå¯ä»¥ç®€å•å°† DP çš„æ ¹æ¢èµ°ã€‚ DAG &amp; å›¾ ä¸Š DP å›¾å¯ä»¥è€ƒè™‘ç¼©ç‚¹æˆ DAGï¼Œç„¶åæŒ‰ç…§æ‹“æ‰‘åºè¿›è¡Œ DP å³å¯ã€‚ [å…­çœè”è€ƒ 2017] æ‘§æ¯æ ‘çŠ¶å›¾ã€‚åœ¨ n(nâ‰¤105)n(n\\le 10^5)n(nâ‰¤105) ä¸ªç‚¹çš„æ ‘ä¸Šå¯»æ‰¾ä¸¤æ¡æ²¡æœ‰è¾¹ç›¸äº¤çš„è·¯å¾„ï¼Œä½¿å¾—åˆ å»å®ƒä»¬åçš„è¿é€šå—æ•°å°½å¯èƒ½å¤šã€‚ åªæœ‰ä¸¤ç§æƒ…å†µï¼š ä¸¤æ¡è·¯å¾„å­˜åœ¨ä¸€ä¸ªç‚¹é‡åˆã€‚è¿™æ ·åªè¦æ‰¾åˆ°æ ¹å‡ºå‘çš„å‰å››å¤§é“¾å³å¯ã€‚ ä¸å­˜åœ¨é‡åˆã€‚è€ƒè™‘æšä¸¾å­æ ‘ï¼Œå…¶ä¸­ä¸€æ¡è·¯å¾„ç»è¿‡è¿™ä¸ªå­æ ‘çš„æ ¹ï¼Œç„¶åå­æ ‘å¤–å†æ‰¾ä¸€æ¡æœ€ä¼˜è·¯å¾„ã€‚ çŠ¶æ€åˆ—è¡¨ï¼š dpxdp_xdpxâ€‹ è¡¨ç¤ºè€ƒè™‘ xxx ä¸ºæ ¹çš„å­æ ‘å»æ‰ä¸€æ¡ä¸€ä¸ªç«¯ç‚¹ä¸º xxx çš„æœ€å¤§è¿é€šå—æ•°ï¼› mxx,kmx_{x,k}mxx,kâ€‹ ä»£è¡¨ä»¥ xxx ä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œdp(y)dp(y)dp(y) çš„ kkk å¤§å€¼ï¼› fpxfp_xfpxâ€‹ ä»£è¡¨å»æ‰ä¸€æ¡ç»è¿‡ xxx çš„é“¾çš„æœ€å¤§è¿é€šå—æ•°ï¼› fxf_xfxâ€‹ ä»£è¡¨å»æ‰å­æ ‘å†…ä¸€æ¡è·¯å¾„çš„æœ€å¤§è¿é€šå—æ•°ï¼Œéœ€è¦è®°å½•å„¿å­ä¸­æœ€å¤§çš„ fff æ¥è¿›è¡Œè½¬ç§»ã€‚ å‘ç°å½“ xxx æ˜¯å¦ä¸æ˜¯æ ¹ä¼šç›´æ¥å½±å“ fff çš„ç­”æ¡ˆï¼Œä¾æ¬¡è®°å½• f0/1f_{0/1}f0/1â€‹ æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ ä»¥ä¸Šæ‰€æœ‰çŠ¶æ€å‡å¯ä»¥æ¢æ ¹è®¡ç®—ã€‚ä¸ºäº†æ¢æ ¹ï¼Œéœ€è¦è®°å½• fmxfmxfmx çš„æ¬¡å¤§å€¼ã€‚æ¢æ ¹è¿‡ç¨‹å¼‚å¸¸éº»çƒ¦ã€‚ int n, ans; vector&lt;int> G[100005]; int dp[100005]; // å»æ‰ä¸€ä¸ªä»¥ x ä¸ºç«¯ç‚¹çš„é“¾åè¿é€šå—æœ€å¤§æ•°é‡ int mx[100005][4]; // ä»¥ x ä¸ºæ ¹ï¼Œdp(y) çš„ k å¤§å€¼ int fp[100005]; // å»æ‰ç»è¿‡ x çš„è·¯å¾„åè¿é€šå—æœ€å¤§æ•°é‡ int f[100005][2]; // x çš„å­æ ‘ä¸­æœ€å¤§è¿é€šå—æ•°é‡ / åˆ æ‰ x ä¹‹å x å¤–é¢è¿˜æœ‰è¿é€šå— int fmx[100005][2]; // f[y][1] æœ€æ¬¡å¤§å€¼ inline void change(int x, int v) &#123; for (int i = 0; i &lt; 4; ++i) if (mx[x][i] &lt; v) swap(mx[x][i], v); &#125; inline void fchange(int x, int v) &#123; for (int i = 0; i &lt; 2; ++i) if (fmx[x][i] &lt; v) swap(fmx[x][i], v); &#125; void dfs(int x, int fa) &#123; dp[x] = mx[x][0] = mx[x][1] = mx[x][2] = mx[x][3] = -INF; fp[x] = f[x][0] = f[x][1] = fmx[x][0] = fmx[x][1] = -INF; int cnt = 0; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); ++cnt; change(x, dp[y]); fchange(x, f[y][1]); &#125; dp[x] = max(cnt, mx[x][0] + cnt - 1); fp[x] = max(dp[x], mx[x][0] + mx[x][1] + cnt - 2); f[x][0] = max(fp[x], fmx[x][0]); f[x][1] = max(fp[x] + 1, fmx[x][0]); &#125; void dfs2(int x, int fa) &#123; int sum = G[x].size(); ans = max(ans, sum); for (int i = 0; i &lt; 4; ++i) ans = max(ans, sum += mx[x][i] - 1); int cnt = G[x].size() - 1; for (int y : G[x]) if (y != fa) &#123; int p = -1; for (int i = 0; i &lt; 4; ++i) if (mx[x][i] == dp[y]) p = i; int mx0 = mx[x][0], mx1 = mx[x][0] + mx[x][1], mx2 = fmx[x][0]; if (p == 0) mx0 = mx[x][1], mx1 = mx[x][1] + mx[x][2]; if (p == 1) mx1 = mx[x][0] + mx[x][2]; if (fmx[x][0] == f[y][1]) mx2 = fmx[x][1]; dp[x] = max(cnt, mx0 + cnt - 1); fp[x] = max(dp[x], mx1 + cnt - 2); f[x][0] = max(fp[x], mx2); f[x][1] = max(fp[x] + 1, mx2); ans = max(ans, f[x][0] + fp[y]); change(y, dp[x]); fchange(y, f[x][1]); dfs2(y, x); &#125; &#125; åŠ¨æ€ DP Portal.ç»™å®šä¸€æ£µ nnn ä¸ªç‚¹çš„ç‚¹æƒæ ‘ï¼Œæ”¯æŒä¿®æ”¹ç‚¹çš„ç‚¹æƒï¼ŒæŸ¥è¯¢æ ‘æœ€å¤§ç‹¬ç«‹é›†çš„æƒå€¼å¤§å°ã€‚ ä¾ç„¶è®¾ fi,1/0f_{i,1/0}fi,1/0â€‹ ä»£è¡¨å¯¹äº iii çš„å­æ ‘æ˜¯å¦é€‰åˆ™ç¬¬ iii ä¸ªèŠ‚ç‚¹ï¼Œå­æ ‘å†…çš„ç‹¬ç«‹é›†æœ€å¤§å¤§å°ã€‚ å¦‚ä½•æ”¯æŒä¿®æ”¹ï¼Ÿå¯¹åŸæ ‘è¿›è¡Œé‡é“¾å‰–åˆ†ï¼Œè®¾ gi,1/0g_{i,1/0}gi,1/0â€‹ ä»£è¡¨ iii çš„å­æ ‘ä¸è€ƒè™‘é‡å„¿å­çš„æƒ…å†µä¸‹çš„ç­”æ¡ˆã€‚æœ‰ï¼š fi,0=gi,0+maxâ¡{fsoni,0,fsoni,1}fi,1=gi,1+fsoni,0f_{i,0}=g_{i,0}+\\max\\{f_{son_i,0},f_{son_i,1}\\}\\\\ f_{i,1}=g_{i,1}+f_{son_i,0} fi,0â€‹=gi,0â€‹+max{fsoniâ€‹,0â€‹,fsoniâ€‹,1â€‹}fi,1â€‹=gi,1â€‹+fsoniâ€‹,0â€‹ æˆ‘ä»¬å®šä¹‰å¦ä¸€ç§çŸ©é˜µä¹˜æ³•ï¼ˆå°†å…¶ç§°ä¸º maxâ¡,+\\max,+max,+ å·ç§¯ï¼Œéœ€è¦æ»¡è¶³ +++ æœ‰ç»“åˆå¾‹ï¼Œmaxâ¡\\maxmax å¯¹ +++ æœ‰åˆ†é…å¾‹ï¼‰ï¼š Ci,j=maxâ¡k=1nAi,k+Bk,jC_{i,j}=\\max_{k=1}^n A_{i,k}+B_{k,j} Ci,jâ€‹=k=1maxnâ€‹Ai,kâ€‹+Bk,jâ€‹ åˆ™æœ‰ï¼š [fsoni,0fsoni,1]Ã—[gi,0gi,1gi,0âˆ’âˆ]=[fi,0fi,1]\\begin{bmatrix} f_{son_i,0} &amp; f_{son_i,1} \\end{bmatrix}\\times \\begin{bmatrix} g_{i,0} &amp; g_{i,1}\\\\ g_{i,0} &amp; -\\infty \\end{bmatrix}= \\begin{bmatrix} f_{i,0} &amp; f_{i,1} \\end{bmatrix} [fsoniâ€‹,0â€‹â€‹fsoniâ€‹,1â€‹â€‹]Ã—[gi,0â€‹gi,0â€‹â€‹gi,1â€‹âˆ’âˆâ€‹]=[fi,0â€‹â€‹fi,1â€‹â€‹] è¿™æ ·åœ¨ä¸€æ¡é‡é“¾ä¸Šå°±å¯ä»¥ç›´æ¥ç”¨çº¿æ®µæ ‘ç»´æŠ¤ç­”æ¡ˆã€‚æˆ‘ä»¬ç›¸å½“äºä»ä¸€ä¸ªæƒå€¼ä¸º 000 çš„å¶å­èŠ‚ç‚¹å¼€å§‹ DPï¼Œä¿®æ”¹æ—¶ï¼Œå½“å‰èŠ‚ç‚¹çš„ gi,1g_{i,1}gi,1â€‹ ä¼šæ”¹å˜ï¼Œç„¶åç›´æ¥è€ƒè™‘é‡é“¾é¡¶ç«¯çˆ¶äº²çš„ç­”æ¡ˆæ”¹å˜ï¼Œæ”¹çš„æ˜¯å½“å‰èŠ‚ç‚¹çš„ä¸€ä¸ªè½»å„¿å­ï¼Œè®¡ç®—æ”¹å˜é‡å³å¯ã€‚ void dfs(int x, int fa) &#123; siz[x] = 1; ::fa[x] = fa; f[x][1] = a[x]; for (int i = hd[x]; i; i = nxt[i]) &#123; int y = to[i]; if (y != fa) &#123; dfs(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; f[x][1] += f[y][0]; f[x][0] += max(f[y][0], f[y][1]); &#125;&#125; &#125; void dfs2(int x, int topf) &#123; idx[L[x] = ++num] = x; R[top[x] = topf] = num; g[x].a[0][1] = a[x]; g[x].a[1][1] = -INF; if (!son[x]) return; dfs2(son[x], topf); for (int i = hd[x]; i; i = nxt[i]) &#123; int y = to[i]; if (y != son[x] &amp;&amp; y != fa[x]) &#123; dfs2(y, y); g[x].a[0][1] += f[y][0]; g[x].a[0][0] += max(f[y][0], f[y][1]); &#125;&#125; g[x].a[1][0] = g[x].a[0][0]; &#125; inline void update(int x, int k) &#123; g[x].a[0][1] += k - a[x]; a[x] = k; while (x) &#123; int y = top[x]; Matrix lst = T[rt[y]].dat; update(rt[y], L[y], R[y], L[x]); Matrix now = T[rt[y]].dat; x = fa[y]; g[x].a[0][0] += max(now.a[0][0], now.a[0][1]) - max(lst.a[0][0], lst.a[0][1]); g[x].a[1][0] = g[x].a[0][0]; g[x].a[0][1] += now.a[0][0] - lst.a[0][0]; &#125; &#125; å…¶å®ƒ DP ä¸€äº›æ‚é¡¹å†…å®¹ã€‚ æ’å…¥æ³• ä¸€ç§è¾ƒä¸ºç‰¹æ®Šçš„çŠ¶æ€è®¾è®¡æ–¹æ³•ï¼Œå¤§æ¦‚ç±»ä¼¼äº fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤º iii ä¸ªæ•°åˆ’åˆ†æˆ jjj æ®µçš„æ–¹æ¡ˆæ•°ã€‚ [CEOI2016] kangaroo.æ„é€ ä¸€ä¸ªæ’åˆ—ï¼Œå·¦å³æ˜¯ s,ts,ts,tï¼Œä»»æ„å…ƒç´ æ»¡è¶³å®ƒå·¦å³ä¸¤ä¸ªéƒ½æ¯”å®ƒå¤§æˆ–éƒ½æ¯”å®ƒå°ã€‚nâ‰¤2000n\\le 2000nâ‰¤2000ã€‚ å¸¸è§„æ–¹æ³•å¹¶ä¸å¥½å¤„ç†ï¼Œè€ƒè™‘ä¸€ç§ä»¥æ’å…¥ä¸ºè½¬ç§»çš„ DPã€‚è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªæ•°ï¼Œå°†åºåˆ—åˆ’åˆ†æˆ jjj æ®µçš„æ–¹æ¡ˆæ•°ã€‚ è€ƒè™‘ä» 1âˆ¼n1\\sim n1âˆ¼n ä¾æ¬¡æ”¾ç½®æ•°ã€‚ä¸€ä¸ªæ•°å¯ä»¥ç”¨æ¥æ–°å¢ä¸€ä¸ªæ®µï¼ˆå¦‚æœé¦–å°¾å·²ç»æ”¾äº† s,ts,ts,t å°±ä¸èƒ½å†æ”¾ï¼‰ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥åˆå¹¶æ®µï¼ˆjjj ç§é€‰æ‹©ï¼‰ã€‚å¦‚æœå®ƒæ˜¯ s,ts,ts,t é‚£ä¹ˆåªèƒ½å°†å®ƒæ”¾åˆ°é¦–å°¾ã€‚ æœ€ç»ˆç­”æ¡ˆä¸º fn,1f_{n,1}fn,1â€‹ã€‚ for (int i = 2; i &lt;= n; ++i) if (i != s &amp;&amp; i != t) &#123; for (int j = 1; j &lt;= i; ++j) &#123; int c = (i > s) + (i > t); f[i][j] = (1ll * j * f[i - 1][j + 1] + 1ll * (j - c) * f[i - 1][j - 1]) % P; &#125; &#125; else &#123; for (int j = 1; j &lt;= i; ++j) f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % P; &#125; æ•°ä½ DP æ±‚è§£å€¼åŸŸä¸­æ»¡è¶³æŸä¸ªæ¡ä»¶çš„æ•°çš„ä¸ªæ•°ã€‚é‡‡ç”¨ DFS å®ç°ï¼Œæšä¸¾å½“å‰ä½æ•°å’Œå„ç±»ä¿¡æ¯ã€‚ CF1815D XOR Countingã€‚mâ‰¥3m\\ge 3mâ‰¥3 æœ‰ nâˆ’k2,nâˆ’k2,k\\frac{n-k}{2},\\frac{n-k}{2},k2nâˆ’kâ€‹,2nâˆ’kâ€‹,kï¼Œå› æ­¤åªéœ€è¦è€ƒè™‘ m=2m=2m=2ã€‚æŒ‰ç…§æ¯ä¸€ä½å»å¡«å†™ï¼Œè®¡ç®— f,gf,gf,g ä»£è¡¨ç­”æ¡ˆå’Œèƒ½å¼‚æˆ–å‡ºçš„æ•°é‡ã€‚æŒ‰ç…§ nnn çš„å¥‡å¶æ€§å»è®¨è®ºå³å¯ã€‚ä»£ç ã€‚ å¯¹äºæœ‰è¿›ä½æ•°ä½ DPï¼Œä¸€èˆ¬é‡‡ç”¨é€’æ¨ã€‚ ARC153D Sum of Sum of Digitsã€‚è®¾ fx,if_{x,i}fx,iâ€‹ ä»£è¡¨ç¬¬ xxx ä½æ°å¥½æœ‰ iii ä¸ªæ•°è¿›ä½æ—¶æœ«å°¾ xxx ä½æ•°çš„ç­”æ¡ˆï¼Œç„¶åè¿›ä½çš„ä¸€å®šæ˜¯æ’åºåçš„å‰å‡ ä¸ªã€‚ä»£ç ã€‚ è½®å»“çº¿ DP ä¾‹é¢˜ éš¾åº¦å¯èƒ½æ¯”è¾ƒå¤§ã€‚ [ABC313Ex] Group Photo Portal. åºåˆ—å¯ä»¥é‡æ’åˆ—ï¼Œç›´æ¥æŒ‰ç…§é¡ºåºé€’æ¨ä¾¿ä¸å¤ªèƒ½åšã€‚ä½†æ˜¯è¦é’¦å®šä¸€ä¸ªé¡ºåºï¼Œå‘ç°æŒ‰å€¼çš„å¤§å°å¾ˆé€‚åˆã€‚ä¸éš¾æƒ³åˆ°æ’å…¥æ³•ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨å¡«å‰ iii ä¸ªå…ƒç´ ï¼Œæœ‰ jjj ä¸ªæ®µæ»¡è¶³åŸé¢˜æ¡ä»¶çš„æ–¹æ¡ˆæ•°ï¼Œè€ƒè™‘ ai+1a_{i+1}ai+1â€‹ å¡«åˆ°å“ªé‡Œï¼ˆæ­¤æ—¶ bbb åº”è¯¥å¡« bi+j+1b_{i+j+1}bi+j+1â€‹ï¼‰ï¼š å°†å…¶æ”¾åˆ°ä¸€ä¸ªè¿ç»­æ®µçš„å·¦ä¾§æˆ–è€…å³ä¾§ï¼Œfi+1,jâ†+fi,jÃ—2Ã—jf_{i+1,j}\\stackrel{+}{\\leftarrow}f_{i,j}\\times 2\\times jfi+1,jâ€‹â†+fi,jâ€‹Ã—2Ã—jï¼Œéœ€è¦æ»¡è¶³ bi+j+1&gt;aib_{i+j+1}&gt;a_ibi+j+1â€‹&gt;aiâ€‹ æ‰èƒ½æ»¡è¶³æ¡ä»¶ï¼› åˆå¹¶ä¸¤ä¸ªè¿ç»­æ®µï¼Œfi+1,jâˆ’1â†+fi,jÃ—(jâˆ’1)f_{i+1,j-1}\\stackrel{+}{\\leftarrow}f_{i,j}\\times (j-1)fi+1,jâˆ’1â€‹â†+fi,jâ€‹Ã—(jâˆ’1)ï¼Œæ²¡æœ‰ä»»ä½•æ¡ä»¶å°±å¯ä»¥è½¬ç§»ï¼› æ–°å¢ä¸€ä¸ªè¿ç»­æ®µï¼Œfi+1,j+1â†+fi,jÃ—(j+1)f_{i+1,j+1}\\stackrel{+}{\\leftarrow}f_{i,j}\\times (j+1)fi+1,j+1â€‹â†+fi,jâ€‹Ã—(j+1)ï¼Œéœ€è¦æ»¡è¶³ minâ¡{bi+j+1,bi+j+2}&gt;ai\\min\\{b_{i+j+1},b_{i+j+2}\\}&gt;a_imin{bi+j+1â€‹,bi+j+2â€‹}&gt;aiâ€‹ã€‚ a,ba,ba,b å‡ä»å°åˆ°å¤§æ’åºå³å¯è½¬ç§»ã€‚ä»£ç ã€‚ [AT DP] Subtree Portal. ç”±äºé€†å…ƒä¸ä¸€å®šå­˜åœ¨ï¼Œæ‰€ä»¥è®¾ fif_ifiâ€‹ ä»£è¡¨ä»¥ iii ä¸ºæ ¹çš„å­æ ‘å†…æŸ“é»‘ç‚¹çš„æ–¹æ¡ˆæ•°ï¼Œgig_igiâ€‹ ä»£è¡¨ iii å­æ ‘å¤–çš„æ–¹æ¡ˆæ•°ã€‚ç„¶åç›´æ¥æ ‘å½¢ DP å’Œæ¢æ ¹å³å¯ã€‚ä»£ç ã€‚ åŠ¨æ€è§„åˆ’çš„è½¬ç§»ä¼˜åŒ– è™½ç„¶å¥—è·¯éå¸¸å¤šï¼Œä½†æ— éå°±ä¸¤ç§ï¼šé’ˆå¯¹å•è°ƒæ€§çš„ä¼˜åŒ–å’Œæ•°æ®ç»“æ„ä¼˜åŒ–ã€‚ wqs äºŒåˆ† æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ wqs äºŒåˆ†å¯¹ DP è¿›è¡Œé™ç»´ã€‚ wqs äºŒåˆ†çš„çŠ¶æ€çš„å…¶ä¸­ä¸€ç»´æ˜¯ç‰©å“ä¸ªæ•°ã€‚è¿™æ˜¯å®ƒçš„æ˜æ˜¾æ ‡å¿—ï¼Œå› æ­¤å®ƒæ¯”è¾ƒå¥—è·¯ã€‚fif_ifiâ€‹ è¡¨ç¤ºæ°å¥½ï¼ˆæœ€å¤š/è‡³å°‘ï¼‰é€‰å– iii ä¸ªç‰©å“æ—¶çš„ç­”æ¡ˆï¼Œå¦‚æœ fff æ˜¯å‡¸å‡½æ•°é‚£ä¹ˆåˆ™å¯ä»¥ä½¿ç”¨ wqsã€‚æˆ‘ä»¬å¯ä»¥çŒœæµ‹ O(nk)O(nk)O(nk) è¿‡ä¸å»å°±æ˜¯å‡¸çš„ï¼Œæˆ–è€…ä¹Ÿå¯ä»¥æ‰“è¡¨ã€‚ ç”±äº fff æ˜¯å‡¸çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é€‰æ‹©äºŒåˆ†æ–œç‡ï¼Œä»¥æ­¤è®¡ç®—å‡ºå®ƒçš„åˆ‡çº¿ã€‚æœ‰æ—¶å®ƒèƒ½ç›´æ¥ç”¨ï¼Œæœ‰æ—¶å¯ä»¥å¯¹ DP è¿›è¡Œé™ç»´ï¼Œæœ‰æ—¶å’Œæ–œç‡ä¼˜åŒ–ç­‰å†…å®¹ä¸€èµ·å‡ºç°ã€‚ å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬ç”»å‡ºæ‰€æœ‰ç‚¹ (i,f(i))(i,f(i))(i,f(i))ï¼Œå‡è®¾å®ƒä»¬æ„æˆä¸€ä¸ªä¸Šå‡¸å£³ã€‚äºŒåˆ†æ–œç‡ kkkï¼Œå‘ç°éšç€ kkk çš„å‡å°ï¼Œç›´çº¿çš„åˆ‡ç‚¹ä¼šè¶Šæ¥è¶Šé å³ã€‚ å› æ­¤äºŒåˆ† kkk ç›´åˆ°æ¨ªåæ ‡åˆ‡åˆ°æˆ‘ä»¬æƒ³è¦çš„ä½ç½®ï¼ˆæ¯”å¦‚æ°å¥½é€‰æ‹© mmm ä¸ªæ•°ï¼‰ï¼Œé‚£ä¹ˆæ­¤æ—¶çš„çºµåæ ‡å°±æ˜¯ç­”æ¡ˆäº†ã€‚ å¦‚ä½•æ±‚å‡ºåˆ‡ç‚¹ï¼Ÿæˆ‘ä»¬å¸Œæœ›è¿™ä¸ªåˆ‡ç‚¹çš„ yyy åæ ‡æœ€å¤§ï¼Œä¹Ÿå°±æ˜¯åœ¨ yyy è½´ä¸Šçš„æˆªè·æœ€å¤§ã€‚è®¾æˆªè·ä¸º g(x)g(x)g(x)ï¼Œé‚£ä¹ˆåˆ‡ç‚¹ (x,f(x))(x,f(x))(x,f(x)) åœ¨ yyy è½´ä¸Šçš„æˆªè·å°±æ˜¯ g(x)=f(x)âˆ’kxg(x)=f(x)-kxg(x)=f(x)âˆ’kxã€‚é—®é¢˜å°±æ˜¯å¦‚ä½•æ±‚å‡º g(x)g(x)g(x) çš„å€¼äº†ã€‚ è€ƒè™‘ g(x)g(x)g(x) çš„æ„ä¹‰ï¼Œç›¸å½“äºé’¦å®šçš„ xxx ä¸ªç‰©å“çš„ä»£ä»·éƒ½æ¯”åŸæ¥å°‘ kkkï¼Œg(x)g(x)g(x) ç›¸å½“äºæ¯ä¸ªç‰©å“ä»£ä»·å‡ kkk ä¹‹åçš„æœ€ä¼˜è§£ã€‚ l,rl,rl,r å¦‚ä½•è°ƒæ•´ï¼Ÿè¦é€¼è¿‘ (m,f(m))(m,f(m))(m,f(m)) å¦‚æœæ­¤æ—¶åˆ‡ç‚¹ (x,f(x))(x,f(x))(x,f(x)) æ»¡è¶³ x&lt;mx&lt;mx&lt;m æ—¶ï¼Œé‚£ä¹ˆåº”è¯¥å°†æ–œç‡å‡å°ï¼Œæ‰èƒ½è®©åˆ‡ç‚¹å³ç§»ã€‚ [ARC168E] Subsegments with Large Sums Portal. ç›´æ¥ wqsï¼Œé”™äº†ï¼Œå› ä¸ºä¸æ˜¯å‡¸çš„ã€‚ äºŒåˆ†ç­”æ¡ˆï¼Œç°åœ¨æ˜¯è¯´ï¼Œç­”æ¡ˆä¸º xxxï¼Œæ˜¯å¦èƒ½å¤Ÿåˆ’å‡º kkk ä¸ªè¿ç»­æ®µï¼Ÿè®¾ fnf_nfnâ€‹ åˆ’å‡º xxx ä¸ªæ®µæ»¡è¶³æ¡ä»¶ï¼Œæœ€å°çš„ä»£ä»·ã€‚ä¸º fnâ‰¤nâˆ’kf_n\\le n -kfnâ€‹â‰¤nâˆ’k æ—¶åˆæ³•ï¼Œwqs äºŒåˆ†å³å¯ã€‚ä»£ç ã€‚ å†³ç­–å•è°ƒæ€§ä¼˜åŒ– å†³ç­–å•è°ƒæ€§åˆ†æ²»å¸¸è§äº 2D / 1D åŠ¨æ€è§„åˆ’ï¼Œå…¶ä¸­ä¸€ç»´æ˜¯è½¬ç§»å±‚æ•°ï¼Œä¸”ä»ä¸€å±‚ä»…è½¬ç§»è‡³ä¸‹ä¸€å±‚ã€‚ å¦‚æœæœ‰å†³ç­–å•è°ƒæ€§ï¼Œé‚£ä¹ˆåº”è¯¥ä½¿ç”¨å››è¾¹å½¢ä¸ç­‰å¼å»è¯æ˜ï¼Œä½†æ˜¯ä¸€èˆ¬æ¥è®² assert å¯èƒ½æ›´æœ‰è¯´æœåŠ›ã€‚ å¦‚æœé‡‡ç”¨åˆ†æ²»å®ç°ï¼Œé‚£ä¹ˆåº”è¯¥æ»¡è¶³åœ¨è®¡ç®— fif_ifiâ€‹ çš„æ—¶å€™ f0âˆ¼iâˆ’1f_{0\\sim i-1}f0âˆ¼iâˆ’1â€‹ å…¨éƒ¨å·²çŸ¥ã€‚å¦‚æœä¸èƒ½ï¼Œåˆ™éœ€è¦å¥—ä¸Šä¸€å±‚ CDQ åˆ†æ²»ï¼ˆä¹Ÿå°±æ˜¯è¦æ±‚åŠåœ¨çº¿ï¼‰ã€‚è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ï¼Œä½†æ˜¯å…¶ä¼˜ç‚¹æ˜¯å¯ä»¥å¿«é€Ÿè®¡ç®—æ— æ³•è®¡ç®—ç­”æ¡ˆï¼Œä½†æ˜¯å¯ä»¥å¿«é€Ÿè®¡ç®—å¢é‡çš„è´¡çŒ®ï¼Œç›´æ¥è·Ÿè¸ªåˆ†æ²»ä¸­å¿ƒè®¡ç®—å³å¯ã€‚ å¦‚æœåŒºé—´è´¡çŒ®å¯ä»¥ç›´æ¥å¿«é€Ÿè®¡ç®—ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä½¿ç”¨äºŒåˆ†æ ˆæˆ–è€…äºŒåˆ†é˜Ÿåˆ—å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚å¤§æ¦‚å°±æ˜¯ç»´æŠ¤ä¸€å †ä¸‰å…ƒç»„ï¼Œè¡¨ç¤ºæŸä¸ªåŒºé—´çš„è½¬ç§»ç‚¹æ˜¯ä»€ä¹ˆã€‚ SMAWK ç®—æ³• å¯ä»¥ç”¨ O(n)O(n)O(n) çš„æ—¶é—´å¤æ‚åº¦å®Œæˆå†³ç­–å•è°ƒæ€§ DPï¼Œä½†æ˜¯ä¸å¤ªå¸¸è§ã€‚ [PA 2022] Nawiasowe podziaÅ‚yã€‚ç»å…¸çš„åˆ’åˆ†åŒºé—´æ®µé—®é¢˜ï¼Œç­”æ¡ˆæ˜¯å…³äº kkk ä¸Šå‡¸çš„ï¼Œwqs äºŒåˆ†è§£å†³ã€‚é‡Œé¢æœ‰å†³ç­–å•è°ƒæ€§ï¼Œè¦è¿›è¡Œ kkk è½®ï¼Œä½†æ˜¯åªéœ€è¦çŸ¥é“å‰é¢çš„å¯¹åé¢çš„å½±å“ï¼ŒCDQ åˆ†æ²»é™ç»´å³å¯ã€‚ä»£ç ã€‚ æ–œç‡ä¼˜åŒ– å¦‚æœä¸€ç±»æœ€ä¼˜åŒ– DP å¯ä»¥å†™æˆ fi=minâ¡{fj+costj+costi}+FiFjf_i=\\min\\{f_j+cost_j+cost_i\\}+F_iF_jfiâ€‹=min{fjâ€‹+costjâ€‹+costiâ€‹}+Fiâ€‹Fjâ€‹ï¼Œé‚£ä¹ˆå¯ä»¥æ”¹å†™æˆ fj+costj=FiFj+(fiâˆ’costi)f_j+cost_j=F_iF_j+(f_i-cost_i)fjâ€‹+costjâ€‹=Fiâ€‹Fjâ€‹+(fiâ€‹âˆ’costiâ€‹)ï¼Œå¯ä»¥è§†ä½œ y=kx+by=kx+by=kx+bã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ”¯æŒåŠ å…¥ç‚¹ (x,y)(x,y)(x,y)ï¼ŒæŸ¥è¯¢å½“å‰ç›´çº¿ç»è¿‡æŸä¸ªç‚¹æ—¶å€™ yyy è½´æˆªè·æœ€å¤§æˆ–è€…æœ€å°ã€‚ å¦‚æœæ¯æ¬¡è¯¢é—®çš„ç›´çº¿çš„æ–œç‡å•è°ƒï¼Œä¸”æ¯æ¬¡åŠ å…¥çš„æ¨ªåæ ‡å•è°ƒï¼Œé‚£ä¹ˆå¯ä»¥å•è°ƒé˜Ÿåˆ—ç»´æŠ¤ï¼›å¦åˆ™å¯ä»¥è€ƒè™‘æè¶…æ ‘ã€‚ [HNOI2008] ç©å…·è£…ç®±ï¼Œç›´æ¥åšå³å¯ã€‚ä»£ç ã€‚ æ•°æ®ç»“æ„ä¼˜åŒ– å¦‚æœæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ•°æ®ç»“æ„å¿«é€Ÿè®¡ç®—è½¬ç§»çš„ä»£ä»·ï¼Œé‚£ä¹ˆä¾¿å¯ä»¥ç›´æ¥ä¼˜åŒ–ï¼Œå¸¸è§çš„å¦‚å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–ã€‚ [NOIP2023] å¤©å¤©çˆ±æ‰“å¡ã€‚è®¾ fif_ifiâ€‹ ä»£è¡¨å‰ iii ä¸ªçš„æœ€ä¼˜ä»£ä»·ï¼Œç›´æ¥çº¿æ®µæ ‘ä¼˜åŒ–å³å¯ã€‚ä»£ç ã€‚ å¦ä¸€ä¸ªå¸¸è§çš„å†…å®¹æ˜¯ï¼Œè½¬ç§»æ–¹ç¨‹å’ŒåŒå±‚æ— å…³ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥æ•´ä½“è½¬ç§»ï¼Œè¿™æ ·çš„æ–¹å¼ç§°ä¸ºæ•´ä½“ DPã€‚ åŠ¨æ€è§„åˆ’æ‚é¡¹ ä¸€äº›åŠ¨æ€è§„åˆ’çš„æ‚é¡¹å†…å®¹ã€‚ è‡ªåŠ¨æœºä¸Š DP æˆ‘ä»¬å¯ä»¥åœ¨å­—ç¬¦ä¸²è‡ªåŠ¨æœºï¼ˆKMP è‡ªåŠ¨æœºã€AC è‡ªåŠ¨æœºç­‰ï¼‰ä¸Šè¿›è¡Œ DPï¼ŒDP è‡ªåŠ¨æœºä¸Šä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ äººè„‘è‡ªåŠ¨æœº [AGC055C] Weird LIS.è®° f(p)f(p)f(p) è¡¨ç¤ºæ’åˆ— ppp çš„æœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦ã€‚è®° PiP_iPiâ€‹ è¡¨ç¤ºæ’åˆ— ppp å»æ‰ç¬¬ iii ä¸ªæ•°çš„åºåˆ—ã€‚æ±‚æœ‰å¤šå°‘é•¿ä¸º NNNï¼Œå€¼åŸŸä¸º [2,M][2,M][2,M] çš„åºåˆ— aaa ä½¿å¾—ï¼šå­˜åœ¨ä¸€ä¸ªæ’åˆ— pppï¼Œâˆ€i\\forall iâˆ€i æœ‰ f(Pi)=aif(P_i)=a_if(Piâ€‹)=aiâ€‹ã€‚ è®¾ ppp çš„ LIS é•¿åº¦ä¸º KKKï¼Œé‚£ä¹ˆåº”è¯¥æœ‰ aiâˆˆ[K,Kâˆ’1]a_i\\in [K,K-1]aiâ€‹âˆˆ[K,Kâˆ’1]ã€‚æˆ‘ä»¬å°† aiâ†aiâˆ’Ka_i\\leftarrow a_i-Kaiâ€‹â†aiâ€‹âˆ’Kã€‚ æ’åˆ—ä¸Šçš„æ•°å¯ä»¥åˆ’åˆ†æˆå››ç§ç±»å‹ï¼š åªæœ‰ç»¿ç‚¹å’Œçº¢ç‚¹å¯ä»¥è®© KKK å¢åŠ ï¼Œåªæœ‰ç»¿ç‚¹åœ¨ aaa å¤„å¡«å†™çš„æ˜¯ âˆ’1-1âˆ’1ï¼Œå…¶ä½™éƒ½æ˜¯ 000ã€‚ è®©çº¢é»‘åŒ¹é…å°½å¯èƒ½åœ°å…ˆå‡ºç°ï¼Œä¹Ÿå°±æ˜¯è¯´åªè®©é»‘ç‚¹é ç€çº¢ç‚¹å‡ºç°ï¼Œé‚£ä¹ˆ fi,kf_{i,k}fi,kâ€‹ ä»£è¡¨å…¶ç»“å°¾çš„æ€§è´¨ä¸º iiiï¼Œå½“å‰ K=kK=kK=kï¼Œè€ƒè™‘äººè„‘å»ºå‡ºè‡ªåŠ¨æœºï¼š i=0i=0i=0ï¼Œæ”¾äº†ä¸€ä¸ªç»¿ï¼Œä¸‹ä¸€ä¸ªä»€ä¹ˆéƒ½èƒ½æ”¾ã€‚ i=1i=1i=1ï¼Œæ”¾äº†ä¸€ä¸ªçº¢ï¼Œä¸‹ä¸€ä¸ªåªèƒ½æ˜¯é»‘è‰²ã€‚ i=2i=2i=2ï¼Œæ”¾äº†ä¸€ä¸ªè“ï¼Œä¸‹ä¸€ä¸ªåªèƒ½æ”¾ç»¿æˆ–è“ã€‚æ”¾è“çš„è¯ï¼Œå°±ä¸èƒ½å†æ”¾çº¢é»‘å¯¹äº†ã€‚ i=3i=3i=3ï¼Œæ”¾å®Œçº¢é»‘å¯¹äº†ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªç‚¹åªèƒ½æ”¾ç»¿è‰²æˆ–è“è‰²ã€‚å†æ”¾ä¸€ä¸ªè“ï¼Œåˆ™ä¸èƒ½æ”¾ç½®çº¢é»‘å¯¹äº†ã€‚å› ä¸ºæˆ‘ä»¬éœ€è¦å°½å¯èƒ½è®©çº¢é»‘å¯¹å‡ºç°åœ¨å‰é¢ã€‚ å®é™…ä¸Šï¼Œè“è“çº¢é»‘å’Œçº¢é»‘è“è“æ˜¯ç­‰ä»·çš„çŠ¶æ€ï¼ˆè½¬ç§» 333ï¼‰ï¼Œè“çº¢é»‘å’Œçº¢é»‘è“ä¹Ÿæ˜¯ç­‰ä»·çš„çŠ¶æ€ï¼Œé»‘ç‚¹åªæ˜¯ä¸ºäº†ç»™çº¢ç‚¹æä¾›ä¸€ä¸ªåŒ¹é…ï¼Œæ¥ä¿è¯å…¶åœ¨åˆ å»åä¸ä¼šè®© aaa çš„å€¼å‘ç”Ÿæ”¹å˜ã€‚è¿™æ˜¯è¿™æ ·è½¬ç§»çš„åŸå› ã€‚ å¦‚ä½•ç»Ÿè®¡ç­”æ¡ˆï¼Ÿé¦–å…ˆæœ€åä¸èƒ½åœç•™åœ¨ 111ï¼Œç„¶åå¯¹äº K=2,nâˆ’1K=2,n-1K=2,nâˆ’1 è¿›è¡Œä¸€ä¸ªç‰¹åˆ¤å³å¯ã€‚ä»£ç ã€‚ DP å¥— DP æœ¬è´¨ä¸Šå°±æ˜¯å†…å±‚ DP çš„ç»“æœä½œä¸ºå¤–å±‚ DP çš„çŠ¶æ€ï¼Œå†…å±‚å‹çš„ä¸œè¥¿ä¸€èˆ¬å¯ä»¥çœ‹æˆä¸€ä¸ª bool æ•°ç»„ï¼Œè¡¨ç¤ºå¤–å±‚çš„çŠ¶æ€æ˜¯å¦èƒ½å¤Ÿå–åˆ°ï¼Œå¤–å±‚åœ¨å†…å±‚ DP å»ºæˆçš„ DP è‡ªåŠ¨æœºä¸Šè¿›è¡Œ DPã€‚è¿™æ ·çŠ¶æ€æ•°å¯èƒ½å¾ˆå¤šï¼Œæ‰€ä»¥å¾€å¾€éœ€è¦ä»¥å®é™…æœå‡ºæ¥çš„ç»“æœä¸ºå‡†ã€‚ [TJOI2018] æ¸¸å›­ä¼šã€‚æ±‚é•¿åº¦ä¸º nnnï¼Œå­—ç¬¦é›†ä¸º N,O,I\\text{N,O,I}N,O,Iï¼Œä¸”ä¸èƒ½å‡ºç°å­ä¸² NOI\\text{NOI}NOIï¼Œä¸ç»™å®šå­—ç¬¦ä¸² SSS çš„ LCS ä¸º lenlenlenï¼ˆéœ€è¦æ±‚å‡ºæ‰€æœ‰çš„ lenlenlen å¯¹åº”çš„ç­”æ¡ˆï¼‰çš„é•¿åº¦ã€‚nâ‰¤1000,âˆ£Sâˆ£â‰¤15n\\le 1000, |S|\\le 15nâ‰¤1000,âˆ£Sâˆ£â‰¤15ã€‚ LCS æ˜¯ä»€ä¹ˆï¼Ÿåƒè¿™æ ·ï¼š LCSx,y={LCSxâˆ’1,yâˆ’1+1,Ax=By,maxâ¡{LCSxâˆ’1,y,LCSx,yâˆ’1},Axâ‰ By.\\text{LCS}_{x,y}= \\begin{cases} \\text{LCS}_{x-1,y-1}+1&amp;,A_x=B_y,\\\\ \\max\\{\\text{LCS}_{x-1,y},\\text{LCS}_{x,y-1}\\}&amp;,A_x\\neq B_y.\\\\ \\end{cases} LCSx,yâ€‹={LCSxâˆ’1,yâˆ’1â€‹+1max{LCSxâˆ’1,yâ€‹,LCSx,yâˆ’1â€‹}â€‹,Axâ€‹=Byâ€‹,,Axâ€‹î€ =Byâ€‹.â€‹ æˆ‘ä»¬å¯¹ LCS å–ä¸€éå‰ç¼€æœ€å¤§å€¼ã€‚æŠŠè¿™ä¸ª LCS çš„ DP æ•°ç»„ä½œä¸ºçŠ¶æ€å‹è¿› DPï¼ˆå½“å…¶ä¸­ä¸€ç»´å›ºå®šæ—¶ï¼ŒLCS æ•°ç»„çš„å‰ç¼€æœ€å¤§å€¼å·®åˆ†åå¯ä»¥å¾—åˆ°ä¸€ä¸ª 01 åºåˆ—ï¼ŒçŠ¶å‹åå°±å¯ä»¥å‹è¿›å»ï¼‰ã€‚è¿™ç›¸å½“äºè‡ªåŠ¨æœºä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œæšä¸¾å‡ºæ»¡è¶³ä¸å‡ºç°å­ä¸² NOI çš„å­—ç¬¦ä½œä¸ºè‡ªåŠ¨æœºçš„è½¬ç§»ï¼Œè®¡ç®—å‡ºè½¬ç§»åˆ°çš„è‡ªåŠ¨æœºä¸Šçš„ç‚¹å¹¶æ›´æ–°æ–¹æ¡ˆæ•°ã€‚ int n, k, ans[20], a[20], b[20]; // LCS(i, ...) char s[20]; int f[2][35005][3]; // è€ƒè™‘åˆ°å­—ç¬¦ä¸²çš„ç¬¬ i ä½ï¼Œå½“å‰ \"NOI\" å­ä¸²çš„é•¿åº¦ä¸º k void decode(int *a, int ret) &#123; for (int i = 0; i &lt; k; ++i) a[i + 1] = (ret >> i &amp; 1) + a[i]; &#125; int encode(int *a) &#123; int ret = 0; for (int i = 0; i &lt; k; ++i) ret |= (a[i + 1] - a[i]) &lt;&lt; i; return ret; &#125; void dp(int now, int t, int p, char c, int w) &#123; decode(a, t); for (int i = 1; i &lt;= k; ++i) b[i] = max(&#123;b[i - 1], a[i], a[i - 1] + (c == s[i])&#125;); t = encode(b); f[now][t][p] = (f[now][t][p] + w) % P; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;k, s + 1); f[0][0][0] = 1; for (int i = 0; i &lt; n; ++i) &#123; memset(f[i - 1 &amp; 1], 0, sizeof(f[i - 1 &amp; 1])); for (int j = 0; j &lt; 1 &lt;&lt; k; ++j) &#123; if (f[i &amp; 1][j][0]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][0]); dp(i - 1 &amp; 1, j, 0, 'O', f[i &amp; 1][j][0]); dp(i - 1 &amp; 1, j, 0, 'I', f[i &amp; 1][j][0]); &#125; if (f[i &amp; 1][j][1]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][1]); dp(i - 1 &amp; 1, j, 2, 'O', f[i &amp; 1][j][1]); dp(i - 1 &amp; 1, j, 0, 'I', f[i &amp; 1][j][1]); &#125; if (f[i &amp; 1][j][2]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][2]); dp(i - 1 &amp; 1, j, 0, 'O', f[i &amp; 1][j][2]); &#125; &#125; &#125; for (int i = 0; i &lt; 1 &lt;&lt; k; ++i) for (int j = 0; j &lt; 3; ++j) &#123; int &amp;x = ans[__builtin_popcount(i)]; x = (x + f[n &amp; 1][i][j]) % P; &#125; for (int i = 0; i &lt;= k; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; çŠ¶æ€æ•°ä¼˜åŒ– æœ‰æ—¶ DP çš„æ•ˆç‡ä¸é«˜ä¸æ˜¯è½¬ç§»ä¸å¤Ÿé«˜æ•ˆï¼ˆå¾ˆå¤šæƒ…å†µè½¬ç§»æ˜¯æ— æ³•ä¼˜åŒ–çš„ï¼‰ï¼Œè€Œæ˜¯çŠ¶æ€æ•°å®åœ¨å¤ªå¤šäº†ã€‚åœ¨è¿™ç§æ—¶å€™æˆ‘ä»¬å¾€å¾€è€ƒè™‘é€šè¿‡é‡æ–°è®¾è®¡çŠ¶æ€ã€åˆå¹¶ç­‰ä»·çŠ¶æ€ã€å¯»æ‰¾æœ‰æ•ˆçš„çŠ¶æ€ç­‰æ–¹å¼æ¥ä¼˜åŒ–çŠ¶æ€æ•°ã€‚ [NOI2023] åˆå¹¶ä¹¦æœ¬ã€‚ä½ éœ€è¦å°† nâ‰¤100n \\le 100nâ‰¤100 ä¸ªé™„é­”ç‰©å“åˆå¹¶åœ¨ä¸€èµ·ï¼Œåˆå§‹ç¬¬ iii ä¸ªç‰©å“çš„é™„é­”è´¹ç”¨æ˜¯ wiw_iwiâ€‹ï¼Œç´¯è®¡æƒ©ç½šçš„è®¡ç®—æ–¹å¼æ˜¯åŸæ¥è¾ƒå¤§çš„ç´¯è®¡æƒ©ç½š Ã—2+1\\times 2 + 1Ã—2+1ï¼Œåˆå¹¶ä»£ä»·æ˜¯ç‰ºç‰²ç‰©å“çš„é™„é­”è´¹ç”¨å’Œç´¯è®¡æƒ©ç½šä¹‹å’Œã€‚ å»ºå‡ºåˆå¹¶äºŒå‰æ ‘ï¼Œä»¤å·¦å„¿å­åˆå¹¶åˆ°å³å„¿å­ã€‚é™„é­”è´¹ç”¨ä»…å¯¹éå¶å­èŠ‚ç‚¹æœ‰è´¡çŒ®ï¼Œè´¡çŒ®æ˜¯å…¶å·¦å„¿å­çš„æƒå€¼ s(lu)s(l_u)s(luâ€‹)ã€‚ç´¯è®¡æƒ©ç½šä»…å¯¹éæ ¹èŠ‚ç‚¹æœ‰è´¡çŒ®ï¼Œè´¡çŒ®æ˜¯ 2d(u)âˆ’12^{d(u)}-12d(u)âˆ’1ã€‚å…¶ä¸­ ddd æ˜¯æŒ‡å­æ ‘å†…è·ç¦»æœ€é•¿çš„å¶å­ã€‚ è®¾ w(u)w(u)w(u) ä»£è¡¨å¶å­èŠ‚ç‚¹ uuu èµ°åˆ°æ ¹èŠ‚ç‚¹èµ°è¿‡äº†å¤šå°‘å·¦å„¿å­è¾¹ï¼Œé‚£ä¹ˆ âˆ‘us(lu)=âˆ‘uauw(u)\\sum_u s(l_u)=\\sum_u a_u w(u)âˆ‘uâ€‹s(luâ€‹)=âˆ‘uâ€‹auâ€‹w(u)ã€‚ å½“ aaa é™åºæ’åºæ—¶ï¼Œåº”è¯¥ä¿è¯ www å‡åºæ’åºæ‰èƒ½ä½¿å¾—è¯¥å€¼æ›´å°ã€‚ç°åœ¨æˆ‘ä»¬æœ‰ä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æ˜¯ä»å¶å­èŠ‚ç‚¹å¼€å§‹åˆå¹¶ï¼Œå¦ä¸€ç§æ˜¯ä»æ ¹èŠ‚ç‚¹å¼€å§‹åˆ†è£‚ã€‚ å¦‚æœä»å¶å­èŠ‚ç‚¹å¼€å§‹åˆå¹¶ï¼Œé‚£ä¹ˆè®¾ fi,sf_{i,s}fi,sâ€‹ ä»£è¡¨åˆå§‹æœ‰ iii æœ¬é™„é­”ä¹¦ï¼Œå½“å‰ www çš„å¯é‡é›†ä¸º sssï¼Œè€Œæœ€åå†åœ¨ sss é‡Œ push_back ä¸€ä¸ªå­æ ‘æ ¹èŠ‚ç‚¹çš„ d(u)d(u)d(u) æ—¶çš„æœ€å°ç´¯è®¡æƒ©ç½šä¹‹å’Œã€‚é‚£ä¹ˆåˆå¹¶çš„æ—¶å€™ç›´æ¥æš´åŠ›æšä¸¾å·¦å­æ ‘å¤§å°ï¼Œå·¦å­æ ‘çš„æ‰€æœ‰ www éƒ½è¦ +1+1+1ã€‚å‰ªææ—¶èˆå¼ƒæ‰è¢«ååºçš„çŠ¶æ€ã€‚é…åˆä¸Š w=1w=1w=1 å¯ä»¥è·å¾— 757575 åˆ†ã€‚ çŠ¶æ€æ•°çˆ†ç‚¸çš„æœ€é‡è¦åŸå› æ˜¯æˆ‘ä»¬éœ€è¦è®°å½•ä¸€ä¸ª dddï¼Œè‡ªåº•å‘ä¸Šæ— æ³•å¾—çŸ¥è¿™ä¸ª ddd æ˜¯ä»€ä¹ˆï¼Œå› æ­¤æˆ‘ä»¬è€ƒè™‘è‡ªé¡¶å‘ä¸‹å¯¹å„¿å­è¿›è¡Œåˆ†è£‚ã€‚æˆ‘ä»¬æ€»æ˜¯å– www å‰è‹¥å¹²å°çš„è¿›è¡Œåˆ†è£‚ï¼Œè¿™æ ·ä¸€å®šæ›´ä¼˜ã€‚è§‚å¯Ÿå¯å¾—ï¼Œå¦‚æœåˆ†è£‚å‡ºæ–°çš„æ ‘çš„å¤§å°ä¸º âˆ£Tâˆ£|T|âˆ£Tâˆ£ï¼Œä¹‹å‰ç´¯è®¡æƒ©ç½šä¸º vvvï¼Œé‚£ä¹ˆæ–°çš„ç´¯è®¡æƒ©ç½šä¸º 2v+âˆ£Tâˆ£âˆ’22v+|T|-22v+âˆ£Tâˆ£âˆ’2ã€‚é‚£ä¹ˆç›´æ¥ç»´æŠ¤å³å¯ï¼Œé…åˆä¸Š w=1w=1w=1 å¯ä»¥è·å¾— 909090 åˆ†ã€‚ æ³¨æ„åˆ°ï¼Œå¦‚æœä¹‹å‰æŸä¸ªèŠ‚ç‚¹åˆ†è£‚å‡ºäº† 111 ä¸ªå„¿å­ï¼Œé‚£ä¹ˆå®ƒæ¥ä¸‹æ¥å¿…é¡»åˆ†è£‚å‡ºä¸å°‘äºè¿™ä¸ªæ•°é‡çš„å¶å­ï¼Œå‰ªæï¼Œå¯ä»¥è·å¾— 100100100 åˆ†ã€‚ä»£ç ã€‚ å®˜æ–¹é¢˜è§£ä½¿ç”¨äº†æš´åŠ›æšä¸¾åˆ†æ‹†æ•°ï¼Œç„¶åç–¯ç‹‚å‰ªæçš„æ–¹æ³•ï¼Œå®é™…è¡¨ç°éå¸¸ä¼˜ç§€ï¼Œå°šä¸çŸ¥é“å…¶åŸç†ã€‚ DP æ€è·¯æ€»ç»“ é¢˜è½¦ å¯¹äºå¯¹åº”çš„ç»„åˆ«æ¥è¯´ï¼Œä¸­æ¡£é¢˜ä¼šé™„å¸¦ä¸€ä¸ªæ˜Ÿå·ï¼Œéš¾é¢˜ä¼šé™„å¸¦ä¸¤ä¸ªæ˜Ÿå·ã€‚ ç”±äº DP çš„éš¾åº¦åœ¨äºçŠ¶æ€è®¾è®¡å’Œå¥—è·¯ç§¯ç´¯ï¼Œå› æ­¤é¢˜ä¼šéå¸¸å¤šã€‚ åˆ·åŸºç¡€ 1 å·©å›ºæ‰€å­¦å†…å®¹ï¼Œè®­ç»ƒæ€ç»´çš„ç†Ÿç»ƒåº¦å’Œå‡†ç¡®åº¦ã€‚æœ¬èº«éš¾åº¦ä¸å¤§ã€‚ [CF1178F] Colorful Strip Portal. é¦–å…ˆè€ƒè™‘ F1 çš„åšæ³•ã€‚æ¡ä»¶éå¸¸ç‰¹æ®Šï¼Œæ¯ç§é¢œè‰²æ°å¥½ä¼šæŸ“ä¸Šä¸€ä¸ªä½ç½®ä¸”æœ‰é¡ºåºï¼ŒåŒºé—´ DP ç¡®å®šåŒºé—´ä¸­ç¬¬ä¸€ä¸ªæŸ“çš„é¢œè‰²ï¼Œç„¶åæšä¸¾å·¦å³æ®µçš„é•¿åº¦ç»™æ‹¼èµ·æ¥ï¼Œæ‹†ä¸€ä¸‹è´¡çŒ®å³å¯ã€‚ä»£ç ã€‚ å¯¹äº F2ï¼Œé¢œè‰²æ•°å¹¶æ²¡æœ‰å˜åŒ–ï¼Œè€ƒè™‘å°†ç›¸åŒçš„é¢œè‰²æ®µç¼©èµ·æ¥ï¼Œç„¶åå…ˆåˆ¤æ‰æ— è§£çš„æƒ…å†µã€‚ç„¶åè®¾ Lx,RxL_x,R_xLxâ€‹,Rxâ€‹ ä»£è¡¨é¢œè‰²å‡ºç°çš„æœ€å·¦æœ€å³ä½ç½®ã€‚ä¸€ä¸ªåŒºé—´ [i,j][i,j][i,j] æ˜¯åˆæ³•çš„å½“ä¸”ä»…å½“å…¶æœ€å°é¢œè‰²å…¨éƒ¨å‡ºç°åœ¨ [i,j][i,j][i,j] å†…ï¼Œæœ€åå†æŠŠä¸­é—´æ®µçš„è´¡çŒ®å‘ˆä¸Šå»å°±è¡Œã€‚ä»£ç ã€‚ [CF1280D] Miss Punyverse Portal. è®¾ fx,if_{x,i}fx,iâ€‹ è¡¨ç¤ºä»¥ xxx ä¸ºæ ¹çš„å­æ ‘å†…é€‰æ‹© iii ä¸ªè¿é€šå—çš„æœ€å¤§æ»¡è¶³è¦æ±‚çš„å—æ•°ï¼ˆé™¤äº† xxx æ‰€å±çš„è¿é€šå—ï¼‰ã€‚gx,ig_{x,i}gx,iâ€‹ ä»£è¡¨ xxx æ‰€å±è¿é€šå—çš„æœ€å¤§æƒå€¼ï¼Œæ ‘å½¢èƒŒåŒ…éšä¾¿è·‘ä¸€ä¸‹å°±è¡Œã€‚ä»£ç ã€‚ [CF1394D] Boboniu and Jianghu Portal. é—®é¢˜åªæ˜¯ç»™ç›¸ç­‰çš„é«˜åº¦è¿›è¡Œå®šå‘ã€‚è®¾ fi,0/1f_{i,0/1}fi,0/1â€‹ ä»£è¡¨åˆ° iii çˆ¶äº²çš„è¾¹å¼ºåˆ¶ä¸ºè¿å…¥/è¿å‡ºæƒ…å†µä¸‹çš„è´¡çŒ®å’Œã€‚å…ˆå‡å®šæ‰€æœ‰éƒ½é€‰ 000 å†æšä¸¾ 111 çš„æ•°é‡å³å¯ã€‚ä»£ç ã€‚ * [CF1845E] Boxes and Balls Portal. å¯¹äºç§»åŠ¨åˆ°ç›®æ ‡çŠ¶æ€ï¼Œæˆ‘ä»¬åªéœ€è¦æ¶ˆè€—æœ€å°æ¬¡æ•°ï¼Œå‰©ä¸‹çš„æ¥å›äº¤æ¢åˆ·åˆ†å³å¯ã€‚ å°†é—®é¢˜æŠ½è±¡æˆè¿™ä¸ªä¸œè¥¿ï¼š åˆå§‹å‰ç¼€å’Œåºåˆ— sssï¼Œç›®æ ‡å‰ç¼€å’Œåºåˆ— sâ€²s&#x27;sâ€²ï¼› âˆ‘âˆ£sâ€²âˆ’sâˆ£â‰¤k\\sum |s&#x27;-s|\\le kâˆ‘âˆ£sâ€²âˆ’sâˆ£â‰¤kï¼Œ âˆ‘âˆ£sâ€²âˆ’sâˆ£â‰¡k(mod2)\\sum |s&#x27;-s|\\equiv k\\pmod 2âˆ‘âˆ£sâ€²âˆ’sâˆ£â‰¡k(mod2)ã€‚ è®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ ä»£è¡¨å½“å‰å¡«å‰ iii ä¸ªæ•°ï¼Œå¡«äº† jjj ä¸ª 111ï¼Œâˆ‘âˆ£sâ€²âˆ’sâˆ£=k\\sum |s&#x27;-s|=kâˆ‘âˆ£sâ€²âˆ’sâˆ£=k çš„æ–¹æ¡ˆæ•°ï¼Œè€ƒè™‘å½“å‰ä½å¡« 0/10/10/1ï¼š fi,j,k=fiâˆ’1,j,kâˆ’âˆ£jâˆ’siâˆ£+fiâˆ’1,jâˆ’1,kâˆ’âˆ£jâˆ’siâˆ£f_{i,j,k}=f_{i-1,j,k-|j-s_i|}+f_{i-1,j-1,k-|j-s_i|} fi,j,kâ€‹=fiâˆ’1,j,kâˆ’âˆ£jâˆ’siâ€‹âˆ£â€‹+fiâˆ’1,jâˆ’1,kâˆ’âˆ£jâˆ’siâ€‹âˆ£â€‹ æ³¨æ„åˆ° âˆ£jâˆ’siâˆ£|j-s_i|âˆ£jâˆ’siâ€‹âˆ£ çš„å–å€¼èŒƒå›´æ˜¯ O(k)O(\\sqrt{k})O(kâ€‹) çš„ï¼Œå¦åˆ™ âˆ‘\\sumâˆ‘ è¿™å †ä¸œè¥¿ä¼šè¶…è¿‡ kkkã€‚åªæšä¸¾è¿™äº›å€¼å³å¯ã€‚ä»£ç ã€‚ [CF1778F] Maximizing Root Portalã€‚ä¸éš¾å‘ç° a1a_1a1â€‹ åªèƒ½ä¹˜ä¸€æ¬¡ï¼Œå› æ­¤æˆ‘ä»¬è¦çœ‹å®ƒæœ€å¤§èƒ½ä¹˜ä¸ªä»€ä¹ˆã€‚è¿›è¡Œä¸€æ¬¡æš´åŠ›æ ‘å½¢ DPï¼Œfx,if_{x,i}fx,iâ€‹ ä»£è¡¨ç»™ xxx ä¹˜ä¸Šçº¦æ•° iii çš„æœ€å°æ­¥æ•°ã€‚æœ¬æ¥ä¸æ»¡è¶³çš„æœ€å¤šæœ‰ä¸€æ¬¡æ“ä½œæœºä¼šï¼ˆä¹˜ä¸Šè‡ªå·±ï¼‰ï¼Œè½¬ç§»æ—¶å¯¹äºæ¯ä¸ªçº¦æ•°å–ä¸ª minâ¡\\minmin å³å¯ã€‚ä»£ç ã€‚ åˆ·æå‡ 1 ç¨æœ‰éš¾åº¦çš„é¢˜ç›®ã€‚ * [CF1750F] Majority Portal. ä¸çŸ¥é“è¿™ä¸ªæ¡ä»¶æ€ä¹ˆåˆ»ç”»ï¼Œé‚£çœ‹çœ‹å¦‚ä½•åˆ»ç”»ä¸åˆæ³•åºåˆ—ï¼š ä¸¤ç«¯ä¸å…¨æ˜¯ 111ï¼› å…¨æ˜¯ 111ï¼Œä½†æ˜¯æ“ä½œåˆ°å°½å¤´æ—¶æ¯ä¸€ä¸ªè¿ç»­ 000 æ®µçš„é•¿åº¦éƒ½æ¯”ä¸¤è¾¹è¿ç»­ 111 æ®µçš„é•¿åº¦ä¹‹å’Œå¤§ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨é•¿åº¦ä¸º iii çš„åºåˆ—ï¼Œä¸¤ç«¯ä¸º 111ï¼Œæ“ä½œåˆ°æœ€åæœ€åä¸€ä¸ª 111 è¿ç»­æ®µçš„é•¿åº¦ä¸º jjjã€‚è¿™æ ·ç­”æ¡ˆå°±æ˜¯ fn,nf_{n,n}fn,nâ€‹ã€‚åˆå§‹ f1,1=1f_{1,1}=1f1,1â€‹=1ã€‚ å¯¹äº fi,if_{i,i}fi,iâ€‹ï¼Œè€ƒè™‘å®¹æ–¥ï¼Œæœ‰ï¼š fi,i=2iâˆ’2âˆ’âˆ‘j=1âŒŠ(iâˆ’1)/2âŒ‹fi,jf_{i,i}=2^{i-2}-\\sum_{j=1}^{\\lfloor(i-1)/2\\rfloor}f_{i,j} fi,iâ€‹=2iâˆ’2âˆ’j=1âˆ‘âŒŠ(iâˆ’1)/2âŒ‹â€‹fi,jâ€‹ å¯¹äº fi,jf_{i,j}fi,jâ€‹ï¼Œå‰é¢ä¸€å®šæœ‰ä¸€ä¸ª 111 è¿ç»­æ®µæ¥ 000 è¿ç»­æ®µ çš„ä¸œè¥¿ï¼Œæšä¸¾ 000 çš„é•¿åº¦ kkk å’Œ 111 çš„é•¿åº¦ lllï¼Œé‚£ä¹ˆæœ‰ï¼š fi,j=fj,jÃ—(âˆ‘j+k&lt;iâˆ‘j+l&lt;kfiâˆ’jâˆ’k,l)=fj,jÃ—(âˆ‘k=j+2iâˆ’jâˆ’1âˆ‘l=1kâˆ’jâˆ’1fiâˆ’jâˆ’k,l)=fj,jÃ—âˆ‘(iâˆ’jâˆ’k)+l&lt;iâˆ’2jfiâˆ’jâˆ’k,l\\begin{aligned} f_{i,j}&amp;=f_{j,j}\\times \\left(\\sum_{j+k&lt;i}\\sum_{j+l&lt;k}f_{i-j-k,l}\\right)\\\\ &amp;=f_{j,j}\\times \\left(\\sum_{k=j+2}^{i-j-1}\\sum_{l=1}^{k-j-1}f_{i-j-k,l} \\right)\\\\ &amp;=f_{j,j}\\times \\sum_{(i-j-k)+l&lt;i-2j}f_{i-j-k,l} \\end{aligned} fi,jâ€‹â€‹=fj,jâ€‹Ã—â€‹j+k&lt;iâˆ‘â€‹j+l&lt;kâˆ‘â€‹fiâˆ’jâˆ’k,lâ€‹â€‹=fj,jâ€‹Ã—â€‹k=j+2âˆ‘iâˆ’jâˆ’1â€‹l=1âˆ‘kâˆ’jâˆ’1â€‹fiâˆ’jâˆ’k,lâ€‹â€‹=fj,jâ€‹Ã—(iâˆ’jâˆ’k)+l&lt;iâˆ’2jâˆ‘â€‹fiâˆ’jâˆ’k,lâ€‹â€‹ å‰ç¼€å’Œä¼˜åŒ–å³å¯ã€‚ä»£ç ã€‚ * [CF1809G] Prediction Portal. å¯¹äºä¸€ä¸ªåˆæ³•çš„æ’åˆ— pppï¼Œåˆ é™¤ apia_{p_i}apiâ€‹â€‹ æœ€å°çš„ pip_ipiâ€‹ï¼Œæ–°çš„ pâ€²p&#x27;pâ€² å¿…å®šåˆæ³•ã€‚ è®¾ fif_{i}fiâ€‹ ä»£è¡¨å¡«å®Œ (i,n](i,n](i,n] çš„æ–¹æ¡ˆæ•°ï¼Œåˆå§‹ fn=1f_n=1fnâ€‹=1ï¼Œè€ƒè™‘ aia_iaiâ€‹ å¡«çš„ä½ç½®ï¼š ä¸å¡«åœ¨å½“å‰ç¬¬ä¸€ä¸ªä½ç½®ï¼Œä¸å½±å“åé¢å…ƒç´ çš„å‰ç¼€ maxâ¡\\maxmaxï¼Œfiâˆ’1â†+fi(nâˆ’i)f_{i-1}\\stackrel{+}{\\leftarrow} f_{i}(n-i)fiâˆ’1â€‹â†+fiâ€‹(nâˆ’i)ï¼› å¡«åœ¨å½“å‰ç¬¬ä¸€ä¸ªä½ç½®ã€‚è®¾ lstilst_ilstiâ€‹ ä»£è¡¨æœ€å¤§çš„ jjj ä½¿å¾— aiâˆ’aj&gt;ka_i-a_j&gt;kaiâ€‹âˆ’ajâ€‹&gt;kï¼Œé‚£ä¹ˆ (lsti,i)(lst_i,i)(lstiâ€‹,i) éƒ½éœ€è¦å‡ºç°åœ¨ iii ä¹‹å‰ï¼Œåˆ™ iâˆ’lstiâˆ’1i-lst_i-1iâˆ’lstiâ€‹âˆ’1 éœ€è¦å¡«å…¥ nâˆ’lstiâˆ’2n-lst_i-2nâˆ’lstiâ€‹âˆ’2 ä¸ªä½ç½®ï¼ˆé™¤äº†ç¬¬ä¸€ä¸ªï¼‰ã€‚ åŒæŒ‡é’ˆæ±‚ lstlstlstï¼Œæ—¶é—´å¤æ‚åº¦ O(n)O(n)O(n)ã€‚ä»£ç ã€‚ [CF1372E] Omkar and Last Floor Portal. ä¸€åˆ—èšé›†åœ¨ä¸€èµ·ä¸€å®šæ˜¯æœ€ä¼˜çš„ï¼Œè€ƒè™‘ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨åŒºé—´ [i,j][i,j][i,j] çš„ç­”æ¡ˆï¼Œci,j,kc_{i,j,k}ci,j,kâ€‹ ä»£è¡¨å·¦å³ç«¯ç‚¹éƒ½åœ¨ [i,j][i,j][i,j] ä¸”ç»è¿‡ç¬¬ kkk åˆ—çš„åŒºé—´æ•°é‡ã€‚ æšä¸¾èšé›†çš„é‚£ä¸€åˆ—ï¼Œé‚£ä¹ˆï¼š fi,j=maxâ¡{fi,kâˆ’1+ci,j,k2+fk+1,j}f_{i,j}=\\max\\{f_{i,k-1}+c_{i,j,k}^2+f_{k+1,j}\\} fi,jâ€‹=max{fi,kâˆ’1â€‹+ci,j,k2â€‹+fk+1,jâ€‹} ccc åŒºé—´ DP æ—¶å®¹æ–¥ä¸€ä¸‹å°±è¡Œã€‚ä»£ç ã€‚ * [CF1188D] Make Equal Portal. è®° bi=maxâ¡aâˆ’aib_i=\\max a - a_ibiâ€‹=maxaâˆ’aiâ€‹ï¼Œé‚£ä¹ˆè¦æ±‚ï¼š âˆ‘i=1npopcountâ¡(x+bi)\\sum_{i=1}^n \\operatorname{popcount}(x+b_i) i=1âˆ‘nâ€‹popcount(x+biâ€‹) è€ƒè™‘äºŒè¿›åˆ¶ä¸‹çš„ç¬¬ kkk ä½ï¼š xxx çš„ç¬¬ kkk ä½æ˜¯å¦å¡« 111ï¼› bib_ibiâ€‹ çš„ç¬¬ kkk ä½æ˜¯å¦å¡« 111; ç¬¬ kâˆ’1k-1kâˆ’1 ä½æ˜¯å¦è¿›ä½ã€‚ ç¬¬ kâˆ’1k-1kâˆ’1 ä½çš„è¿›ä½æƒ…å†µå’Œ bi mod 2kb_i\\bmod 2^kbiâ€‹mod2k æœ‰å…³ã€‚æˆ‘ä»¬æŒ‰ç…§è¿™ä¸ªä¸œè¥¿æ’åºï¼Œèƒ½è¿›ä½çš„å°±æ˜¯ bbb çš„ä¸€æ®µå‰ç¼€ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨æœ‰ jjj ä¸ªæ•°è¿›ä½åˆ°ç¬¬ iii ä½çš„ç­”æ¡ˆã€‚è€ƒè™‘ xxx å½“å‰è¿™ä¸€ä½å¡« 111 è¿˜æ˜¯å¡« 000ï¼Œè´¡çŒ®éšä¾¿ç®—ä¸€ä¸‹å°±è¡Œäº†ã€‚ä»£ç ã€‚ * [CF1517F] Reunion Portal. è®¾ä¸€ç§æ–¹æ¡ˆ SSS çš„åŠå¾„ä¸º f(S)f(S)f(S)ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ âˆ‘r=1nâˆ‘S[f(S)â‰¥r]\\sum_{r=1}^{n}\\sum_{S}[f(S)\\ge r]âˆ‘r=1nâ€‹âˆ‘Sâ€‹[f(S)â‰¥r]ã€‚å®é™…ä¸Šæˆ‘ä»¬åªéœ€è¦å¯¹äºæ¯ä¸ª rrr åˆ†åˆ«è®¡ç®—å³å¯ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨ iii çš„å­æ ‘è·ç¦» iii æœ€è¿‘çš„é»‘ç‚¹è·ç¦»ä¸º jjj çš„æ–¹æ¡ˆæ•°ï¼Œè®°æ»¡è¶³ j=r+1j=r+1j=r+1 çš„ä¸ºé¢„å¤‡ç‚¹ï¼Œgi,jg_{i,j}gi,jâ€‹ è¡¨ç¤º iii å­æ ‘å†…æœ€æ·±é¢„å¤‡ç‚¹ä¸ iii è·ç¦»ä¸º jjj æ—¶çš„æ–¹æ¡ˆæ•°ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè‹¥å­æ ‘å†…å·²ç»å­˜åœ¨é¢„å¤‡ç‚¹ï¼Œé‚£ä¹ˆæ²¡æœ‰å¿…è¦å†è€ƒè™‘è·ç¦» iii æœ€è¿‘çš„é»‘ç‚¹ä¸ iii çš„è·ç¦»ã€‚ä¸å­˜åœ¨æ—¶ï¼Œè¿™ä¸œè¥¿æ‰éœ€è¦è¢«è®°å½•ã€‚ è€ƒè™‘ä½¿ç”¨æ ‘å½¢èƒŒåŒ…çš„æ–¹å¼åˆå¹¶ï¼š åˆå¹¶ fx,i,fy,jf_{x,i},f_{y,j}fx,iâ€‹,fy,jâ€‹ï¼Œå¯ä»¥è½¬ç§»åˆ° fx,minâ¡{i,j+1}f_{x,\\min \\{i,j+1\\}}fx,min{i,j+1}â€‹ï¼› åˆå¹¶ gx,i,gy,jg_{x,i},g_{y,j}gx,iâ€‹,gy,jâ€‹ï¼Œå¯ä»¥è½¬ç§»åˆ° gx,maxâ¡{j,k+1}g_{x,\\max\\{j,k+1\\}}gx,max{j,k+1}â€‹ï¼› åˆå¹¶ fx,i,gy,jf_{x,i},g_{y,j}fx,iâ€‹,gy,jâ€‹ï¼Œå¦‚æœ i+j+1&gt;ri+j+1&gt;ri+j+1&gt;rï¼Œé‚£ä¹ˆ ggg å®šä¹‰çš„é¢„å¤‡ç‚¹æ˜¯ç¬¦åˆé™åˆ¶çš„ï¼Œå…¶ä¼šè½¬ç§»åˆ° gx,j+1g_{x,j+1}gx,j+1â€‹ï¼Œå¦åˆ™ä¼šè½¬ç§»åˆ° fx,if_{x,i}fx,iâ€‹ï¼› åˆå¹¶ gx,i,fy,jg_{x,i},f_{y,j}gx,iâ€‹,fy,jâ€‹ å¤§è‡´åŒç†ã€‚ ç­”æ¡ˆæ˜¯ âˆ‘g1\\sum g_1âˆ‘g1â€‹ã€‚ æ—¶é—´å¤æ‚åº¦ O(n3)O(n^3)O(n3)ã€‚ä»£ç ã€‚ åˆ·æå‡ 2 æ¥ç€æå‡è‡ªæˆ‘å§ï¼ [CEOI2005] Mobile Service Portal. DP æ˜¯ç®€å•çš„ï¼Œé—®é¢˜æ˜¯ç©ºé—´å¦‚æ­¤ä¹‹å°ï¼Œæ–¹æ¡ˆè¯¥æ€ä¹ˆè®°å½•ï¼Ÿ é¦–å…ˆï¼Œæ–¹æ¡ˆæ•°ç»„æ˜¯ä¸å¯èƒ½è¢«æ»šåŠ¨çš„ã€‚ä½†æ˜¯å†³ç­–æ•°é‡æ¯”è¾ƒå°ï¼Œå¯ä»¥ä½¿ç”¨ unsigned char æ¥è®°å½•ã€‚ç„¶åå‘ç°åªè®°å½•ä¸€ä¸ªæ•°å°±å¯ä»¥äº†ã€‚ä»£ç ã€‚ * [eJOI2018] æŠ¤ç…§ Portal. ä¸éš¾æƒ³åˆ°çŠ¶å‹ï¼Œè€Œä¸” Pâ‰¤2P\\le 2Pâ‰¤2ï¼Œå› æ­¤ P=2P=2P=2 æ—¶åªéœ€è¦æšä¸¾å­é›†ç„¶åå¯¹äºå­é›†å’Œè¡¥é›†åˆå¹¶çŠ¶å‹ DP æ•°ç»„å³å¯ï¼Œå› æ­¤è¿™é‡Œåªéœ€è¦è€ƒè™‘ P=1P=1P=1ã€‚ è®¾ fif_ifiâ€‹ ä»£è¡¨é›†åˆ iii ä¸­çš„ç­¾è¯å…¨éƒ¨åŠç†å®Œæˆåçš„æœ€å°ç»“æŸæ—¶é—´ã€‚è½¬ç§»é‡‡ç”¨åˆ·è¡¨æ³•ï¼Œè€ƒè™‘é™åˆ¶æ˜¯ä»€ä¹ˆï¼šä¸€ä¸ªæ—¶é—´å†…ï¼Œæ—…è¡Œå’ŒåŠç†ç­¾è¯åšå¤šåšä¸€ç§ã€‚å¦‚æœæˆ‘ä»¬ä¾æ¬¡æ£€æŸ¥å…¶å®ƒå›½å®¶çš„é™åˆ¶ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸º O(n22n)O(n^2 2^n)O(n22n)ã€‚ ä½†å¦‚æœæŒ‰ç…§ ttt ä»å°åˆ°è¾¾è€ƒè™‘ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¾ç„¶æ˜¯å…·æœ‰å•è°ƒæ€§çš„ã€‚è€ƒè™‘ä»é™åˆ¶æœ¬èº«å…¥æ‰‹ï¼š åŠç†ç­¾è¯çš„æ—¶é—´ä¸å¯ä»¥æ’åˆ°å‡ºå›½çš„æ—¶é—´ã€‚ å¦‚æœ ppp æ­£åœ¨åŠç†ç­¾è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶é—´ä¸èƒ½è€ƒè™‘åŠç†ç­¾è¯ã€‚ å°† lll æ’åºä¹‹åç»´æŠ¤ä¸¤ä¸ªæŒ‡é’ˆæ¥é™åˆ¶ä¸¤æ¡é™åˆ¶ï¼Œæ‰¾åˆ°å¯ä»¥åŠç†å½“å‰ç­¾è¯çš„æœ€å°æ—¶é—´å³å¯ã€‚ è¿™æ ·å°±å¯ä»¥ O(n2n)O(n2^n)O(n2n) å®Œæˆäº†ã€‚ä»£ç ã€‚ [ARC108E] Random IS Portal. æ±‚çš„æ˜¯ä¾æ¬¡éšæœºé€‰æ‹©æ’åˆ—ä¸­åˆæ³•çš„æ•°ï¼Œç„¶å IS çš„æœŸæœ›é•¿åº¦ã€‚ è®¾ fl,rf_{l,r}fl,râ€‹ ä»£è¡¨ l,rl,rl,r å·²ç»è¢«é€‰æ‹©ï¼Œé‚£ä¹ˆæœ‰ï¼š fl,r=âˆ‘al&lt;ak&lt;arfl,k+fk,j+1gl,rf_{l,r} = \\frac{\\sum_{a_l&lt;a_k&lt;a_r} f_{l,k}+f_{k,j}+1}{g_{l,r}} fl,râ€‹=gl,râ€‹âˆ‘alâ€‹&lt;akâ€‹&lt;arâ€‹â€‹fl,kâ€‹+fk,jâ€‹+1â€‹ å¯ä»¥åœ¨ kkk å¤„æ–°å¢ä¸€ä¸ª 111ã€‚æ‰€æœ‰çš„ä¸œè¥¿éƒ½å¯ä»¥å¾ˆæ–¹ä¾¿åœ°ç”¨æ ‘çŠ¶æ•°ç»„æ±‚å‡ºï¼Œä»£ç ã€‚ [Ptz 2020 Summer Day4] Ternary String Counting Portal. O(n4)O(n^4)O(n4) ç›´æ¥ fi,x,y,zf_{i,x,y,z}fi,x,y,zâ€‹ è®°å½•æ¯ä¸€ä¸ªå­—ç¬¦å‡ºç°çš„ä½ç½®ï¼ŒO(n3)O(n^3)O(n3) è®°å½•å‰ä¸¤ä¸ªä¸åŒå­—ç¬¦çš„å‡ºç°ä½ç½®ã€‚éƒ½éœ€è¦å‰ç¼€å’Œä¼˜åŒ–ã€‚ çŠ¶æ€æ•°è¿˜æ˜¯è¿‡å¤šäº†ï¼Œæˆ‘ä»¬éœ€è¦å¯»æ‰¾ä¸€ä¸ªæ–¹å¼ç®€åŒ–ã€‚å…ˆæŠŠè½¬ç§»å†™å‡ºæ¥ï¼š f(i+1,i,k)â†+f(i,j,k)f(i+1,i,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,k)â†+f(i,j,k)ï¼› f(i+1,i,j)â†+f(i,j,k)f(i+1,i,j)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,j)â†+f(i,j,k)ï¼› f(i+1,j,k)â†+f(i,j,k)f(i+1,j,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,j,k)â†+f(i,j,k)ã€‚ å†è€ƒè™‘é¢˜ç›®ä¸­çš„é™åˆ¶ï¼Œå®é™…ä¸Šå°±æ˜¯é™åˆ¶äº† dp è¿‡ç¨‹ä¸­ jjj å’Œ kkk çš„å–å€¼èŒƒå›´ï¼š x=1x=1x=1ï¼Œåˆ™ j&lt;lj&lt;lj&lt;lï¼› x=2x=2x=2ï¼Œåˆ™ jâ‰¥l,k&lt;lj\\ge l,k&lt;ljâ‰¥l,k&lt;lï¼› x=3x=3x=3ï¼Œåˆ™ kâ‰¥lk\\ge lkâ‰¥lã€‚ è€ƒè™‘ä¼˜åŒ–ï¼Œçœ‹ä¸Šå»ç¬¬ä¸€ç»´ä»€ä¹ˆéƒ½ä¸æ˜¯ï¼å°†è½¬ç§»åˆ†ä¸º iiiâ€‹ å±‚ï¼Œæ¯ä¸€å±‚çš„çŠ¶æ€åªèƒ½ä»ä¸Šä¸€å±‚è½¬ç§»è¿‡æ¥ï¼Œç¬¬ä¸‰ä¸ªè½¬ç§»å°±æ˜¯ç›´æ¥ä»ä¸Šä¸€å±‚çš„å¯¹åº”ç‚¹è½¬ç§»ï¼Œç¬¬ä¸€äºŒä¸ªè½¬ç§»æ˜¯å¯¹ä¸Šä¸€å±‚çš„ä¸€åˆ—å’Œä¸€è¡Œæ±‚å’Œã€‚ ç­‰ä»·äºï¼Œæ¯æ¬¡ç»™å‡ºä¸€ä¸ªçŸ©å½¢ï¼Œå…ˆæŠŠçŸ©å½¢å¤–çš„å€¼å…¨éƒ¨æ¸…é›¶ã€‚ç„¶åè¿˜å¯ä»¥å‘ç°ï¼Œä¸€æ—¦æŸä¸ªå€¼è¢«æ¸…é›¶ï¼Œé‚£ä¹ˆè¿™ä¸ªå€¼ä»¥åæ°¸è¿œéƒ½æ˜¯é›¶ã€‚å¹¶ä¸”å¯¹äºæŸä¸€è¡Œæ¥è¯´ï¼Œéé›¶çš„å€¼æ°¸è¿œæ˜¯ä¸€æ®µè¿ç»­åŒºé—´ï¼Œè€Œä¸”å…¶ä½ç½®æ˜¯å•è°ƒçš„ã€‚ åŒæŒ‡é’ˆæ‰«ï¼Œä¸é‡å¤æ¸…é›¶æŸä¸ªè¡Œå³å¯ã€‚æœ€ç»ˆæ—¶é—´å¤æ‚åº¦ O(n2+m)O(n^2+m)O(n2+m)ã€‚ä»£ç ã€‚ [Ptz 2022 Summer Day3] Counting Sequence Portal. å¯¹äº O(n2)O(n^2)O(n2)ï¼Œç›´æ¥è®¾ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤ºå½“å‰ âˆ‘=i\\sum =iâˆ‘=iï¼Œç»“å°¾æ˜¯ jjj çš„è´¡çŒ®ã€‚ å½“ a1â‰¥Ba_1\\ge Ba1â€‹â‰¥B æ—¶ï¼Œåºåˆ—é•¿åº¦ä¸º O(n/B)O(n/B)O(n/B)ï¼Œå¯ä»¥è®¾è®¡åºåˆ—é•¿åº¦çš„ DPã€‚è®¾ gi,j,Sg_{i,j,S}gi,j,Sâ€‹ è¡¨ç¤ºåˆ°åºåˆ—ç¬¬ iii ä½ï¼Œå½“å‰å’Œ a1a_1a1â€‹ çš„å·®ä¸º jjjï¼Œâˆ‘atâˆ’a1=S\\sum a_t - a_1 = Sâˆ‘atâ€‹âˆ’a1â€‹=S çš„æ–¹æ¡ˆæ•°ï¼Œè½¬ç§»æšä¸¾æœ€åä¸€ä¸ªå¡«ä»€ä¹ˆï¼Œå¤æ‚åº¦ O((n/B)4)O((n/B)^4)O((n/B)4)ã€‚æ ¹å·å¹³è¡¡å¯ä»¥åšåˆ° O(n8/5)O(n^{8/5})O(n8/5)ã€‚ æ”¹ä¸º gi,jg_{i,j}gi,jâ€‹ ä»£è¡¨é•¿åº¦ä¸º iiiï¼Œâˆ‘atâˆ’a1=j\\sum a_t-a_1=jâˆ‘atâ€‹âˆ’a1â€‹=jï¼Œç„¶ååœ¨åºåˆ—å‰é¢æ’å…¥ä¸€ä¸ªæ•°ã€‚æ³¨æ„ fff å¯ä»¥æŒ‰ç…§ i mod 2Bi \\bmod 2Bimod2B è¿›è¡Œç»Ÿè®¡ã€‚ä»£ç ã€‚ åˆ·æå‡ 3 æ›´åå‘ DP çš„ä¼˜åŒ–ã€‚ åˆ·èƒ½åŠ› DP ç»¼åˆåº”ç”¨ã€‚ * [ZJOI2019] éº»å°† Portal. å¯ä»¥å‘ç°å…¶ä¸¤éƒ¨åˆ†æ˜¯å‰²è£‚çš„ï¼šåˆ¤æ–­èƒ¡ç‰Œå’Œè®¡æ•° DPã€‚ç”±äºèƒ¡ç‰Œé›†åˆçš„å¤§å°åªæœ‰ 131313ï¼Œå› æ­¤å¦‚æœæˆ‘ä»¬èƒ½è§£å†³åˆ¤å®šé—®é¢˜ï¼Œé‚£ä¹ˆä¾¿å¯ä»¥å»ºç«‹è‡ªåŠ¨æœºåœ¨ä¸Šé¢è§£å†³è®¡æ•°é—®é¢˜ã€‚ å…ˆè§£å†³åˆ¤å®šé—®é¢˜ã€‚ä¸ƒä¸ªå¯¹å­åªéœ€è¦å¼€ä¸€ä¸ªæ¡¶å³å¯ï¼Œä¸€ä¸ªå¯¹å­å››ä¸ªé¢å­å¯ä»¥è€ƒè™‘ä½¿ç”¨ DP æ¥è§£å†³ï¼šè®¾ fi,j,k,0/1f_{i,j,k,0/1}fi,j,k,0/1â€‹ ä»£è¡¨è€ƒè™‘å‰ iii ç§ç‰Œï¼Œç›®å‰è¿˜å‰©ä¸‹ jjj ç»„ (iâˆ’1,i)(i-1,i)(iâˆ’1,i) å’Œ kkk å¼  iiiï¼Œä»¥åŠæ˜¯å¦é€‰æ‹©å‡ºäº†ä¸€ç»„å¯¹å­ï¼Œè¿™ç§æ—¶å€™çš„æœ€å¤§é¢å­æ•°ã€‚ç”±äº jâ‰¥3j\\ge 3jâ‰¥3 æˆ–è€… kâ‰¥3k\\ge 3kâ‰¥3 æ—¶éƒ½å¯ä»¥ç›´æ¥ç»„æˆæ–°çš„é¢å­ï¼Œå› æ­¤çŠ¶æ€ä¸­ j,kâˆˆ[0,2]j,k\\in [0,2]j,kâˆˆ[0,2]ã€‚å› æ­¤åœ¨ä¸€ä¸ªçŠ¶æ€ä¸­å»ºç«‹ä¸¤ä¸ª 3Ã—33\\times 33Ã—3 çš„äºŒç»´æ•°ç»„å³å¯ã€‚è½¬ç§»æ—¶å°† xxx å¼  iii ç‰Œæ·»åŠ è¿›æ¥å³å¯ã€‚ ç‰Œç§ç±»æ•°è¶³å¤Ÿå¤šæ—¶çŠ¶æ€å°±è¢«åˆ—ä¸¾å®Œäº†ï¼Œå› æ­¤ç›´æ¥æš´åŠ› DFS æ‹“å±•å‡ºæ‰€æœ‰çŠ¶æ€å³å¯ï¼ŒæŒ‰ç…§ç¬”è€…çš„å®ç°ï¼Œå…¶çŠ¶æ€åªæœ‰ S=3956S=3956S=3956 ç§ï¼Œè€Œæ¥ä¸‹æ¥çš„åˆ†æè®©æˆ‘ä»¬çŸ¥åˆ°æˆ‘ä»¬åªéœ€è¦ä¸èƒ¡çš„çŠ¶æ€ï¼Œå…¶åªæœ‰ S=2091S=2091S=2091 ç§ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬è¦è§£å†³è®¡æ•°é—®é¢˜ã€‚æˆ‘ä»¬éœ€è¦çŸ¥åˆ°ç¬¬ä¸€ä¸ªèƒ¡ç‰Œçš„ä½ç½®ï¼Œè¿™å¹¶ä¸å¥½ç›´æ¥è®¡ç®—ã€‚è®¾ P(i)P(i)P(i) ä»£è¡¨æ°å¥½ iii æ­¥èƒ¡ç‰Œçš„æ¦‚ç‡ï¼Œé‚£ä¹ˆï¼š E(x)=âˆ‘i=0+âˆiÃ—P(i)=âˆ‘i=0+âˆâˆ‘j=i+âˆP(j)\\begin {aligned} E(x)&amp;=\\sum_{i=0}^{+\\infty} i\\times P(i)\\\\ &amp;=\\sum_{i=0}^{+\\infty}\\sum_{j=i}^{+\\infty}P(j) \\end{aligned} E(x)â€‹=i=0âˆ‘+âˆâ€‹iÃ—P(i)=i=0âˆ‘+âˆâ€‹j=iâˆ‘+âˆâ€‹P(j)â€‹ å¯ä»¥å‘ç°ç¬¬äºŒä¸ªå’Œå¼çš„æ„æ€æ˜¯ iâˆ’1i-1iâˆ’1 æ­¥æ²¡èƒ¡çš„æ¦‚ç‡ï¼Œè®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ ä»£è¡¨é€‰æ‹©å‰ iii ç§ç‰Œï¼Œä¸€å…± jjj å¼ ï¼Œä½äºè‡ªåŠ¨æœºä¸Šçš„çŠ¶æ€ kkkï¼Œè½¬ç§»æ—¶é€‰æ‹© ttt å¼  iii ç‰Œï¼Œç³»æ•°æ˜¯ (4âˆ’ait)\\dbinom {4-a_i}{t}(t4âˆ’aiâ€‹â€‹)ï¼Œä»¤ m=4nâˆ’13m=4n-13m=4nâˆ’13ï¼Œfif_ifiâ€‹ ä¸º iii å¼ ç‰Œæ²¡èƒ¡çš„æ–¹æ¡ˆæ•°ï¼Œåˆ™ç­”æ¡ˆä¸ºï¼š ans=âˆ‘i=0mfii!(mâˆ’i)!m!ans=\\frac{\\sum_{i=0}^m f_i i!(m-i)!}{m!} ans=m!âˆ‘i=0mâ€‹fiâ€‹i!(mâˆ’i)!â€‹ ä»£ç ã€‚ [CF924F] Minimal Subset Difference Portal. * [JOISC2020] Ruins 3 Portal. æ—‹é£ç‰›é©¬å¤§æ•°æ•°ã€‚ è€ƒè™‘ä»åå¾€å‰æ‰«ï¼Œç„¶åå‡å®š 1âˆ¼h1\\sim h1âˆ¼h çš„çŸ³æŸ±å„å‡ºç°äº†ä¸€æ ¹ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥å‡ºç°çš„ â‰¤h\\le hâ‰¤h çš„æŸ±å­ï¼Œéƒ½ä¼šç›´æ¥éœ‡æ²¡ã€‚é‚£äº›æ²¡æœ‰è¢«éœ‡æ­»çš„æŸ±å­ç§°ä¸ºâ€œæ ‡å‡†æŸ±â€ã€‚ ç»§ç»­è§‚å¯Ÿæ€§è´¨ã€‚å¦‚æœå½“å‰ä½ç½®ä¸º xxxï¼Œåé¢å­˜åœ¨ xâˆ¼xâˆ’kx\\sim x-kxâˆ¼xâˆ’kï¼Œé‚£ä¹ˆ xxx ä¼šä¸‹é™åˆ° xâˆ’kâˆ’1x-k-1xâˆ’kâˆ’1ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨å iii ä¸ªæŸ±å­ï¼Œæ­¤æ—¶ h=jh=jh=j çš„æ–¹æ¡ˆæ•°ã€‚ æˆ‘ä»¬å…ˆå‡å®šä¸¤æ ¹é«˜åº¦ç›¸åŒçš„æŸ±å­å®é™…ä¸Šæ˜¯ä¸åŒçš„ï¼Œé‚£ä¹ˆæœ€ç»ˆç­”æ¡ˆé™¤ä»¥ 2n2^n2n å³å¯ã€‚ å€’ç€ DPï¼Œè®¾æ­¤æ—¶æœ‰ c0c_0c0â€‹ ä¸ªé’¦å®šæ¶ˆå¤±ï¼Œc1c_1c1â€‹ ä¸ªé’¦å®šå­˜åœ¨ã€‚ iii é’¦å®šæ¶ˆå¤±ï¼Œæ­¤æ—¶ jjj ä¸å˜ï¼Œæœ‰ jjj ä¸ªå¯ç”¨é«˜åº¦ï¼Œé‚£ä¹ˆä¸ç®—å½“å‰è¿™ä¸ªæ²¡æ¶ˆå¤±çš„ï¼Œè¿™é‡Œå¯ä»¥å¡«å†™ jâˆ’(c0âˆ’1)j-(c_0-1)jâˆ’(c0â€‹âˆ’1) ä¸ªæœ‰æ•ˆçš„ã€‚ iii é’¦å®šä¿ç•™ï¼Œä»¤ hih_ihiâ€‹ ä»£è¡¨ iii æœ€åçš„é«˜åº¦ï¼Œåˆ†è®¨ï¼š å¦‚æœ hi&gt;j+1h_i&gt;j+1hiâ€‹&gt;j+1ï¼Œé‚£ä¹ˆä» fi+1,jf_{i+1,j}fi+1,jâ€‹ è½¬ç§»ï¼Œè¿™é‡Œçš„è´¡çŒ®ç•™ç»™ä»¥åå†è®¡ç®—ã€‚ å¦åˆ™æ­¤æ—¶ hi=j+1h_i=j+1hiâ€‹=j+1ï¼Œé‚£ä¹ˆæ­¤æ—¶æšä¸¾ä¸€ä¸ªæ–°å¢çš„å¤§å° kkkï¼Œè½¬ç§»åˆ° fi,j+kf_{i,j+k}fi,j+kâ€‹ï¼Œç³»æ•°æ˜¯ï¼š é€‰æ‹©å“ªäº›ä½ç½®çš„å€¼è¢«è®°å…¥äº†å½“å‰ jjjã€‚é’¦å®šé™¤äº†å½“å‰ä½ç½®çš„é‚£ kâˆ’1k-1kâˆ’1 ä¸ªä½ç½®çš„æ–¹æ¡ˆæ•° (c1âˆ’1âˆ’jkâˆ’1)\\dbinom{c_1-1-j}{k-1}(kâˆ’1c1â€‹âˆ’1âˆ’jâ€‹)ï¼› j+2âˆ¼j+kj+2\\sim j+kj+2âˆ¼j+k çš„é«˜åº¦ä¹‹å‰å‡æœ‰å‡ºç°è¿‡ä¸€æ¬¡ï¼Œè¿™é‡Œè¿˜å¯ä»¥é€‰æ‹©å„ä¸€æ¬¡ï¼Œç„¶åè¿˜å¯ä»¥é€‰æ‹©ä¸¤ä¸ª j+1j+1j+1 çš„é«˜åº¦ï¼Œæ–¹æ¡ˆæ•°æ˜¯ k+1k+1k+1ï¼› å›ºå®šé‚£ kâˆ’1k-1kâˆ’1 ä¸ªä½ç½®ä¸Šçš„æ•°çš„æ’åˆ—ï¼Œé‚£äº›æ•°éƒ½æ²¡æœ‰è¢«éœ‡æ²¡ã€‚å› æ­¤å°±æ˜¯è¦æ±‚ä¸€ä¸ª gng_ngnâ€‹ ä»£è¡¨æœ‰ 2n2n2n ä¸ªæ•°è¿›è¡Œé€‰æ‹©ï¼Œç„¶åéœ‡æˆå€¼åŸŸè¿ç»­æ®µçš„åˆå§‹æ–¹æ¡ˆæ•°ã€‚ è®¾ gi,jg_{i,j}gi,jâ€‹ ä»£è¡¨ç”¨ 1âˆ¼i1\\sim i1âˆ¼i çš„æ•°å¡« jjj ä¸ªä½ç½®ï¼Œæ”¾è¿›å»çš„æœ€å¤§æ•°ä¸å½±å“åŸæ¥èƒ½éœ‡æˆçš„å€¼åŸŸè¿ç»­æ®µï¼Œé‚£ä¹ˆèƒ½éœ‡æˆå€¼åŸŸè¿ç»­æ®µçš„å……è¦æ¡ä»¶æ˜¯ iâ‰¥ji\\ge jiâ‰¥jã€‚æšä¸¾ç¬¬ iii ä¸ªæ•°å¡«äº† 0/1/20/1/20/1/2 çš„è½¬ç§»æ–¹å¼ï¼š gi,j=giâˆ’1,j+2jÃ—giâˆ’1,jâˆ’1+j(jâˆ’1)giâˆ’1,jâˆ’2g_{i,j}=g_{i-1,j}+2j\\times g_{i-1,j-1}+j(j-1) g_{i-1,j-2} gi,jâ€‹=giâˆ’1,jâ€‹+2jÃ—giâˆ’1,jâˆ’1â€‹+j(jâˆ’1)giâˆ’1,jâˆ’2â€‹ ä»£ç ã€‚ [Ptz 2023 Winter Day6] 5 Portal. ä¸éš¾è®¾è®¡å‡º flen,sumf_{len,sum}flen,sumâ€‹ è¿™æ ·çš„çŠ¶æ€ï¼Œä½†æ˜¯çŠ¶æ€æ•°å°±æˆ O(nS)O(nS)O(nS) äº†ï¼Œç›´æ¥å¯„äº†ã€‚ å¯ä»¥å‘ç° 111 å‡ºç°çš„æ¬¡æ•°æ˜¯æ¯”è¾ƒå°‘çš„ï¼Œå› æ­¤å¯ä»¥è®¾è®¡å‡ºä¸€ä¸ª fsumâˆ’len,lenf_{sum-len,len}fsumâˆ’len,lenâ€‹ çš„çŠ¶æ€ï¼Œç„¶åç»´æŠ¤æ¯ä¸ª sumâˆ’lensum-lensumâˆ’len å¯¹åº”çš„ lenlenlen è¿ç»­æ®µï¼ˆåªæœ‰ 444 ä¸ªï¼‰ï¼ŒäºŒè¿›åˆ¶æ‹†åˆ†ä¼˜åŒ–å¤šé‡èƒŒåŒ…å³å¯ã€‚ä»£ç ã€‚ åˆ·ç»¼åˆ æœ‰äº›é¢˜ç›®æ¯”è¾ƒç™«ç‹‚ã€‚ * [Luogu P8554] å¿ƒè·³ Portal. æˆ‘ä»¬è€ƒè™‘å»æ‰ä¸€ä¸ªæ•°ä¹‹åå‰ç¼€æœ€å¤§å€¼æ”¹å˜çš„æƒ…å†µã€‚ è®¾ kkk ä¸ºåŸå…ˆå‰ç¼€æœ€å¤§å€¼çš„ä¸ªæ•°ï¼Œé‚£é‚£ä¹ˆåªæœ‰å½“å…¶åŸå…ˆæ˜¯å‰ç¼€æœ€å¤§å€¼æ—¶ï¼Œå‰ç¼€æœ€å¤§å€¼å°†å˜æˆ [kâˆ’1,n][k-1,n][kâˆ’1,n]ã€‚ å°è¯•æ‰¾å‡º aaa çš„åˆæ³•ç»“æ„ï¼Œå¯¹äº aaa è¿›è¡ŒæŸ“è‰²ï¼š çº¢è‰²ï¼šåŸæ¥å°±æ˜¯å‰ç¼€æœ€å¤§å€¼çš„ä½ç½®ï¼Œå¯ä»¥ä½¿å¾— kkk å¢å¤§ 111ï¼› ç»¿è‰²ï¼šç”¨æ¥ä»£æ›¿çº¢è‰²ç‚¹ç§°ä¸ºå‰ç¼€æœ€å¤§å€¼çš„ä½ç½®ï¼Œkkk ä¸å˜ï¼› é»„è‰²ï¼šåƒåœ¾ï¼Œkkk ä¸å˜ã€‚ å¯ä»¥å‘ç°ï¼Œçº¢è‰²åé¢ä¼šæ¥ä¸€æ®µé•¿åº¦ä¸º xxx çš„ç»¿è‰²ï¼Œä¸”å®ƒä»¬çš„å¤§å°æ˜¯é€’å¢çš„ï¼Œç„¶åå†æ˜¯ä¸€å †é»„è‰²ï¼Œç„¶åæ˜¯ä¸‹ä¸€ä¸ªçº¢è‰²ã€‚ç»¿è‰²çš„å‡ºç°æ¡ä»¶æ˜¯å°äºä¸Šä¸€ä¸ªçº¢è‰²ä½†æ˜¯å¤§äºä¸Šä¸Šä¸ªçº¢è‰²ï¼Œé»„è‰²åº”è¯¥å°äºä¸Šä¸€ä¸ªç»¿è‰²æˆ–è€…å°äºä¸Šä¸Šä¸ªçº¢è‰²ã€‚äºæ˜¯å°†é¢œè‰²åºåˆ—è½¬åŒ–ä¸º ppp æ—¶ï¼Œä¸€å®šå¯ä»¥æ„é€ å‡ºæ¥ã€‚ å°è¯•æ„å»ºé¢œè‰²åºåˆ—å’Œ aaa ä¹‹é—´çš„åŒå°„ï¼Œä¸ºä»€ä¹ˆä¸€ä¸ªé¢œè‰²åºåˆ—å¯¹åº”æ°å¥½ä¸€ä¸ªåˆæ³•çš„ aaaï¼Ÿé¦–å…ˆæˆ‘ä»¬æ„é€  aaaï¼Œéçº¢è‰²ç‚¹ ai=ka_i=kaiâ€‹=kï¼Œçº¢è‰²ç‚¹ ai=kâˆ’1+xa_i=k-1+xaiâ€‹=kâˆ’1+xã€‚ éœ€è¦ä¿è¯ä¸€ä¸ª aaa åªèƒ½å¯¹åº”ä¸€ç§é¢œè‰²åºåˆ—ï¼Œå’Œ AGC055C ä¸€æ ·ï¼Œæˆ‘ä»¬é™åˆ¶ç­‰ä»·çŠ¶æ€ã€‚è¦æ³¨æ„æƒ…å†µä¸å®Œå…¨ä¸€æ ·ï¼Œå› ä¸º aaa å¯ä»¥æ”¹çš„å€¼æ›´å¤šï¼ˆä»¥ä¸‹ X æŒ‡éç»¿çš„ä¸œè¥¿ï¼‰ï¼š é»„çº¢ç»¿ X å’Œçº¢ç»¿é»„ X æ˜¯ç­‰ä»·çš„çŠ¶æ€ï¼Œå› æ­¤å‰è€…ä¸å¯èƒ½å‡ºç°ï¼ˆç›®å‰ä¸èƒ½ç´§è·Ÿé•¿åº¦ä¸º 111 çš„ç»¿è‰²æ®µï¼‰ï¼› å¦‚æœå‡ºç°äº†é»„é»„ï¼Œé‚£ä¹ˆå°±ä¸èƒ½å†å¡«çº¢ç»¿ X æ®µäº†ï¼ˆåç»­ä¸èƒ½æœ‰ä»»ä½•é•¿åº¦ä¸º 111 çš„ç»¿è‰²æ®µï¼‰ã€‚ å¦å¤–ï¼Œç¬¬ä¸€ä¸ªæ•°ä¸€å®šæ˜¯çº¢è‰²ï¼Œç¬¬äºŒä¸ªæ•°ä¸€å®šä¸èƒ½æ˜¯é»„è‰²ï¼Œå› ä¸ºåºåˆ—å¤´è¢«åˆ äº†è‡ªç„¶å°±æœ‰äº†æ–°çš„å‰ç¼€æœ€å¤§å€¼ã€‚ æˆ‘ä»¬è¿˜éœ€è¦é™åˆ¶ mmmï¼Œäºæ˜¯æˆ‘ä»¬åªéœ€åœ¨è‡ªåŠ¨æœºä¸Šåªéœ€è¦è®°å½•è¿™äº›ä¿¡æ¯ï¼š å‰é¢ä¸€ä¸ªçš„é¢œè‰²ï¼› æ˜¯å¦å‡ºç°è¿‡é»„é»„ï¼› è¿™ä¸ªç»¿è‰²æ®µçš„é•¿åº¦æ˜¯ 0,10,10,1 è¿˜æ˜¯å¤§äºç­‰äº 222ï¼› å½“å‰ç»¿è‰²æ®µå‰é¢çš„çº¢è‰²æ˜¯å¦åœ¨é»„è‰²åé¢ï¼› å½“å‰çš„çº¢è‰²ä¸ªæ•°ã€‚ è¦ä¹ˆ k&gt;mk&gt;mk&gt;mï¼Œè¦ä¹ˆ k=mk=mk=m ä¸”æ²¡æœ‰ä¸æ¥ç»¿è‰²çš„çº¢è‰²ï¼Œè·‘ä¸¤æ¬¡å³å¯ã€‚ çŠ¶æ€å¯ä»¥å‹ç¼©æˆä¸‹å›¾ï¼Œä»£ç ï¼š * [AGC047F] Rooks Portal. å¤ªç²¾å½©å•¦ï¼ ä¸€ä¸ªæš´åŠ›åšæ³•æ˜¯ï¼Œæšä¸¾æ¯ä¸ª sss æ±‚ç­”æ¡ˆï¼Œç„¶åç”¨ä¸€ä¸ª O(n2)O(n^2)O(n2) çš„åŒºé—´ DP ä»£è¡¨åƒæ‰ [i,j][i,j][i,j] å†…çš„è½¦ã€‚ ä½†æ˜¯æˆ‘ä»¬ä¸éœ€è¦å¯¹äºæ¯ä¸ªèµ·ç‚¹éƒ½æ±‚ä¸€éç­”æ¡ˆï¼Œç›´æ¥å°†æ•´ä¸ªåŒºé—´ DP çš„è¿‡ç¨‹å€’è¿‡æ¥å³å¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé¢„å¤„ç†å‡ºæ¯ä¸ªç‚¹èƒ½èµ°åˆ°çš„åŒºé—´ï¼Œç„¶åæ‰©å±•è¿™ä¸ªä¸œè¥¿ã€‚ çŠ¶æ€æ•°æ˜¯ O(n2)O(n^2)O(n2) çš„ï¼Œä¼¼ä¹æ˜¯å°½å¤´ï¼Ÿå¦ï¼è§‚å¯Ÿè½¬ç§»çš„å½¢å¼ï¼Œä¸€å®šå½¢å¦‚ä¸‹å›¾ï¼š çŠ¶æ€æ•°åªæœ‰ O(2n)O(2n)O(2n)ï¼Œç›´æ¥è½¬ç§»å³å¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"JOISC 2019 é¢˜ç›®åˆé›†","slug":"default/åšé¢˜è®°å½•/OI/JOI/joisc2019","date":"2023-10-04T00:00:00.000Z","updated":"2023-10-04T00:00:00.000Z","comments":true,"path":"8c948c47/","link":"","permalink":"https://james1badcreeper.github.io/8c948c47/","excerpt":"è¯´å¥½çš„åŠ è®­ï¼Œç»“æœåŠ çš„è·Ÿæ²¡åŠ ä¸€æ ·ã€‚äººå•Šï¼Œè¦æ”¯æ£±èµ·æ¥å•Šï¼","text":"è¯´å¥½çš„åŠ è®­ï¼Œç»“æœåŠ çš„è·Ÿæ²¡åŠ ä¸€æ ·ã€‚äººå•Šï¼Œè¦æ”¯æ£±èµ·æ¥å•Šï¼ æ¬¢è¿æ”¶çœ‹ 10 æœˆå¤§å‹æ–°ç•ª ç‚¹èµè¶Šå¤šï¼Œæ›´æ–°è¶Šå¿«ï¼ ä¸ºäº†æ ¼å¼ç»Ÿä¸€ï¼Œæœ¬æ–‡æ²¡æœ‰ä»»ä½•çš„äºŒçº§æ ‡é¢˜ã€‚ Startï¼š2023/10/04 18:??ã€‚ Doneï¼š2023/10/09 01:56ã€‚ è¿™ä¹ˆæ…¢å•Šï¼ä»€ä¹ˆæ‘†æ€ªï¼å—ä¸äº†äº†å•Šå–‚å–‚ï¼ åˆ«æ…Œ~ Day1 Aï¼ŒBï¼ŒCã€‚ A. è€ƒè¯• ç›´æ¥ä¸‰ç»´ååºå³å¯ã€‚ä»£ç ã€‚ B. èšä¼š Portal.ç»™å®šä¸€æ£µ n(nâ‰¤2000)n(n\\le 2000)n(nâ‰¤2000) ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œè¦æ±‚æ‰¾åˆ°æ ‘çš„å½¢æ€ï¼Œå¯ä»¥è°ƒç”¨æœ€å¤š 10510^5105 æ¬¡è¯¢é—®ï¼šQuery(x, y, z)ï¼šè¿”å›æ ‘ä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œè¿™ä¸ªç‚¹åˆ°ä¸‰ä¸ªç‚¹çš„è·ç¦»å’Œæœ€å°ã€‚ ä¸€ä¸ªéå¸¸ç¬¨ B çš„åšæ³•ã€‚ æ¯æ¬¡åœ¨æ ‘ä¸Šéšæœºå‡ºä¸€æ¡é“¾ï¼Œè¯¢é—®æ ‘ä¸Šæ‰€æœ‰çš„ç‚¹ï¼Œèƒ½å¤Ÿæˆä¸ºç­”æ¡ˆçš„ä¸€å®šæ˜¯é“¾ä¸Šçš„ç‚¹ã€‚å¯¹äºé“¾ï¼Œéšæœºä¸­ç‚¹åˆ†æ²»å¤„ç†ï¼›å‰©ä¸‹çš„éƒ¨åˆ†ä¾ç„¶æ˜¯æ ‘ï¼Œé€’å½’å¤„ç†ã€‚ æ¶ˆè€—çš„è¯¢é—®ä¸è¶…è¿‡ 250002500025000 æ¬¡ï¼Œè¿™ä¸ªåšæ³•å¤§æ¦‚å¯ä»¥è¯´æ˜éšæœºåˆ†æ²»å…·æœ‰ä¸€å®šçš„æ­£ç¡®æ€§ï¼Ÿ #include &lt;bits/stdc++.h> #include \"meetings.h\" using namespace std; mt19937 Rand(time(0)); inline void answer(int x, int y) &#123; if (x > y) swap(x, y); Bridge(x, y); &#125; void dfs(vector&lt;int> a, int x, int y) &#123; if (a.empty()) return answer(x, y); if (a.size() == 1) return answer(x, a[0]), answer(a[0], y); int mid = a[Rand() % a.size()]; vector&lt;int> al, ar; for (int i : a) if (i != mid) &#123; if (Query(x, mid, i) == i) al.emplace_back(i); else ar.emplace_back(i); &#125; dfs(al, x, mid); dfs(ar, mid, y); &#125; void solve(vector&lt;int> a) &#123; if (a.size() &lt;= 1) return; int n = a.size(), x = a[Rand() % n], y = a[Rand() % n]; while (x == y) y = a[Rand() % n]; map&lt;int, vector&lt;int>> mp; mp[x].emplace_back(x); mp[y].emplace_back(y); for (int i : a) if (i != x &amp;&amp; i != y) mp[Query(x, y, i)].emplace_back(i); vector&lt;int> chain; for (auto [p, q] : mp) if (p != x &amp;&amp; p != y) chain.emplace_back(p); dfs(chain, x, y); for (auto [p, q] : mp) solve(q); &#125; void Solve(int n) &#123; vector&lt;int> a(n); for (int i = 0; i &lt; n; ++i) a[i] = i; solve(a); &#125; C. é¦• Portal.ä¸€ä¸ªé•¿åº¦ä¸º LLL çš„æ¿€å…‰å‰‘è¢«åˆ†ä¸º LLL æ®µï¼Œæ¯æ®µä¸€ä¸ªå•ä½é•¿åº¦ï¼Œç¬¬ iii æ®µä¸ºç¬¬ jjj ç§å£å‘³ã€‚NNN ä¸ªäººæ¥åƒæ¿€å…‰å‰‘ï¼Œç¬¬ iii ä¸ªäººåƒä¸€ä¸ªå•ä½é•¿åº¦çš„ jjj å£å‘³çš„æ¿€å…‰å‰‘ä¼šåˆ†æ³Œ Vi,jV_{i,j}Vi,jâ€‹ çš„å¤šå·´èƒºã€‚æ„é€ ä¸€ä¸ªé¡ºåºï¼Œç»™æ¯ä¸ªäººåˆ’åˆ†ä¸€æ®µæ¿€å…‰å‰‘ï¼Œæ¯ä¸ªäººè·å¾—ä¸€å®šçš„é•¿åº¦ã€‚æ„é€ ä¸€ç§æ–¹æ¡ˆï¼Œæ¯ä¸ªäººåˆ†æ³Œçš„å¤šå·´èƒºå¤§äºè‡ªå·±åƒæ‰æ•´ä¸ªæ¿€å…‰å‰‘çš„å¤šå·´èƒºçš„ 1n\\frac 1 nn1â€‹ï¼Œæˆ–è€…æŠ¥å‘Šæ— è§£ã€‚n,Lâ‰¤2000n,L\\le 2000n,Lâ‰¤2000ã€‚ æ¯”è¾ƒæ˜¾ç„¶çš„æ˜¯ï¼Œè€ƒè™‘è®©æ¯ä¸ªäººæ°å¥½åƒä»–æ€»æ”¶ç›Šçš„ 1n\\frac 1 nn1â€‹ã€‚è€ƒè™‘æ¯ä¸ªäººçš„ nnn ç­‰åˆ†ç‚¹ï¼Œè´ªå¿ƒå–æ‰€æœ‰äººä¸­ nnn ç­‰åˆ†ç‚¹æœ€çŸ­çš„ä¸€æ®µï¼Œç„¶åç›´æ¥åˆ’ç»™è¿™ä¸ªäººï¼Œå› ä¸ºä»–æ¶ˆè€—çš„æœ€å°‘ï¼Œè¿™æ ·ä¸€å®šæ˜¯ä¸åŠ£çš„ã€‚ #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; typedef __int128 lll; int n, L, c[2005]; i64 v[2005][2005]; struct Frac &#123; i64 x, y; Frac(i64 x = 1, i64 y = 0) : x(x), y(y) &#123;&#125; bool operator&lt; (const Frac &amp;a) const &#123; return (lll)x * a.y &lt; (lll)a.x * y; &#125; bool operator>= (const Frac &amp;a) const &#123; return (lll)x * a.y >= (lll)a.x * y; &#125; &#125; a[2005][2005]; // ç¬¬ i ä¸ªäººçš„ç¬¬ j ç­‰åˆ†æ®µåœ¨å“ªé‡Œç»“æŸ int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> L; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= L; ++j) cin >> v[i][j]; for (int id = 1; id &lt;= n; ++id) &#123; i64 s = 0, cur = 0; for (int i = 1; i &lt;= L; ++i) s += v[id][i]; int j = 1; for (int i = 1; i &lt;= L; ++i) &#123; while (j &lt;= n &amp;&amp; Frac(cur + v[id][i], 1) >= Frac(s * j, n)) a[id][j] = Frac(s * j - cur * n + n * v[id][i] * (i - 1), n * v[id][i]), ++j; if (j > n) break; cur += v[id][i]; &#125; &#125; static bool vis[2005]; memset(vis, 0, sizeof vis); for (int i = 1; i &lt;= n; ++i) &#123; Frac res; int t = 0; for (int j = 1; j &lt;= n; ++j) if (!vis[j] &amp;&amp; a[j][i] &lt; res) res = a[j][i], t = j; vis[t] = 1; c[i] = t; if (i != n) cout &lt;&lt; res.x &lt;&lt; \" \" &lt;&lt; res.y &lt;&lt; \"\\n\"; &#125; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; c[i] &lt;&lt; \" \\n\"[i == n]; return 0; &#125; Day2 Aï¼ŒBï¼ŒCã€‚ A. * ä¸¤ä¸ªå¤©çº¿ Portal.nnn ä¸ªå¤©çº¿ï¼Œç›¸é‚»è·ç¦»ä¸º 111ï¼Œé«˜åº¦ä¸º HiH_iHiâ€‹ã€‚å¤©çº¿ iii å‘å¤©çº¿ jjj å¯ä»¥å‘æ¶ˆæ¯ï¼Œé€šä¿¡æˆæœ¬ä¸º âˆ£Hiâˆ’Hjâˆ£|H_i-H_j|âˆ£Hiâ€‹âˆ’Hjâ€‹âˆ£ï¼Œå½“ä¸”ä»…å½“å®ƒä»¬ä¹‹é—´çš„è·ç¦» Di,jâˆˆ[Ai,Bi]D_{i,j}\\in [A_i,B_i]Di,jâ€‹âˆˆ[Aiâ€‹,Biâ€‹]ã€‚å¤šæ¬¡è¯¢é—®åŒºé—´ä¸­å¯ä»¥ç›¸äº’å‘é€ä¿¡æ¯çš„å¤©çº¿çš„æœ€å¤§å€¼ã€‚nâ‰¤2Ã—105n\\le 2\\times 10^5nâ‰¤2Ã—105ã€‚ è€ƒè™‘ç¦»çº¿ï¼Œæ‰€æœ‰è¯¢é—®æŒ‰ RRR æ’åºã€‚ç»å¯¹å€¼ä¸å¥½å¤„ç†ï¼Œæ‹†äº†æ­£åå„åšä¸€éã€‚ æ¯æ¬¡æ–°å¢ä¸€ä¸ªå¯è¡Œçš„ jjjï¼Œå°†å¯è¡Œçš„ iii åŠ å…¥ç­”æ¡ˆé›†åˆã€‚å¯¹ yyy æ¥è¯´åˆæ³•çš„ xxx åŒºé—´æ˜¯ [yâˆ’By,yâˆ’Ay][y-B_y,y-A_y][yâˆ’Byâ€‹,yâˆ’Ayâ€‹]ï¼Œxxx éœ€è¦æ»¡è¶³ yâˆˆ[x+Ax,x+Bx]y\\in [x+A_x,x+B_x]yâˆˆ[x+Axâ€‹,x+Bxâ€‹]ï¼Œå…¸å‹çš„æ‰«æçº¿ã€‚ #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; const int N = 800000; int mxA[800005], mxB[800005], tag[800005]; void clear(void) &#123; fill(mxA + 1, mxA + N + 1, -INF); fill(mxB + 1, mxB + N + 1, -INF); fill(tag + 1, tag + N + 1, -INF); &#125; inline void pushup(int o) &#123; mxA[o] = max(mxA[o &lt;&lt; 1], mxA[o &lt;&lt; 1 | 1]); mxB[o] = max(mxB[o &lt;&lt; 1], mxB[o &lt;&lt; 1 | 1]); &#125; inline void maketag(int o, int k) &#123; tag[o] = max(tag[o], k); mxB[o] = max(mxB[o], mxA[o] + k); &#125; inline void pushdown(int o) &#123; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = -INF; &#125; void updateA(int o, int l, int r, int x, int k) &#123; if (l == r) return mxA[o] = k, void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) updateA(o &lt;&lt; 1, l, mid, x, k); else updateA(o &lt;&lt; 1 | 1, mid + 1, r, x, k); pushup(o); &#125; void updateB(int o, int l, int r, int x, int y, int v) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, v), void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) updateB(o &lt;&lt; 1, l, mid, x, y, v); if (mid &lt; y) updateB(o &lt;&lt; 1 | 1, mid + 1, r, x, y, v); pushup(o); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return mxB[o]; pushdown(o); int mid = l + r >> 1, res = -INF; if (x &lt;= mid) res = max(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = max(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; int n, q; int h[200005], a[200005], b[200005]; int l[200005], r[200005], ans[200005]; vector&lt;pair&lt;int, int> > Q[200005], A[200005]; void solve(void) &#123; for (int i = 1; i &lt;= n; ++i) Q[i].clear(), A[i].clear(); for (int i = 1; i &lt;= q; ++i) Q[r[i]].emplace_back(l[i], i); for (int i = 1; i &lt;= n; ++i) &#123; if (i + a[i] &lt;= n) A[i + a[i]].emplace_back(i, h[i]); if (i + b[i] + 1 &lt;= n) A[i + b[i] + 1].emplace_back(i, -INF); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (auto [p, v] : A[i]) updateA(1, 1, n, p, v); if (i - a[i] >= 1) updateB(1, 1, n, max(1, i - b[i]), i - a[i], -h[i]); for (auto [l, id] : Q[i]) ans[id] = max(ans[id], query(1, 1, n, l, i)); &#125; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> h[i] >> a[i] >> b[i]; cin >> q; memset(ans, -1, sizeof ans); for (int i = 1; i &lt;= q; ++i) cin >> l[i] >> r[i]; clear(); solve(); reverse(h + 1, h + n + 1); reverse(a + 1, a + n + 1); reverse(b + 1, b + n + 1); for (int i = 1; i &lt;= q; ++i) l[i] = n - l[i] + 1, r[i] = n - r[i] + 1, swap(l[i], r[i]); clear(); solve(); for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; B. ** ä¸¤ç§æ–™ç† Portal.ä½ è¦çƒ¹é¥ªä¸¤é“æ–™ç†ï¼šé—ªè€€çš„èŠå£«è›‹æŒ å’Œ æ·±æ½œçš„æå¯’å†°æ²™ï¼Œåˆ†åˆ«æœ‰ n,mn,mn,m é“å·¥åºï¼Œéœ€è¦çš„æ—¶é—´æ˜¯ a1,â‹¯ ,ana_1,\\cdots,a_na1â€‹,â‹¯,anâ€‹ å’Œ b1,â‹¯ ,bmb_1,\\cdots,b_mb1â€‹,â‹¯,bmâ€‹ åˆ†é’Ÿã€‚åˆ¶ä½œè¿™ä¸¤é“æ–™ç†éƒ½éå¸¸å›°éš¾ï¼šä¸€ä¸ªæ­¥éª¤å¼€å§‹ä¹‹åä¸èƒ½ä¸­æ–­ã€‚åˆ°æœ€åï¼Œä½ å¿…é¡»åšå®Œè¿™ä¸¤é“æ–™ç†ã€‚å¦‚æœä½ åœ¨æ¯”èµ›çš„å‰ sis_isiâ€‹ åˆ†é’Ÿå®Œæˆäº† é—ªè€€çš„èŠå£«è›‹æŒ çš„ç¬¬ iii ä¸ªåˆ¶ä½œæ­¥éª¤ï¼Œé‚£ä¹ˆä½ å¯ä»¥è·å¾— pip_ipiâ€‹ çš„åˆ†æ•°ã€‚åŒç†ï¼Œåœ¨ tjt_jtjâ€‹ åˆ†é’Ÿå‰å®Œæˆ æ·±æ½œçš„æå¯’å†°æ²™ çš„ç¬¬ jjj ä¸ªåˆ¶ä½œæ­¥éª¤å¯è·å¾— qjq_jqjâ€‹ çš„åˆ†æ•°ã€‚é—®æœ€å¤§å¾—åˆ†ã€‚n,mâ‰¤106n,m\\le 10^6n,mâ‰¤106ï¼Œåˆ†æ•°å¯èƒ½æ˜¯è´Ÿçš„ã€‚ å¤ªç²¾å½©å•¦ï¼å·¨å¤§çš„ n,mn,mn,m è®©äººæƒ³åªå¯¹é—ªè€€çš„èŠå£«è›‹æŒï¼ˆä»¥ä¸‹ç§°ä¸º A æ–™ç†ï¼‰DPï¼Œç›´æ¥è®¡ç®—æ·±æ½œçš„æå¯’å†°æ²™ï¼ˆä»¥ä¸‹ç§°ä¸º B æ–™ç†ï¼‰çš„è´¡çŒ®ã€‚ä½†æ˜¯åšä¸äº†[1]ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨å®Œæˆ A æ–™ç† çš„å‰ iii æ­¥ï¼ŒB æ–™ç†çš„å‰ jjj æ­¥çš„æœ€å¤§å¾—åˆ†ã€‚çœ‹ä¸Šå»å®ƒçš„å°½å¤´å°±æ˜¯ O(nm)O(nm)O(nm)ï¼Œå®åˆ™ä¸ç„¶ï¼ å¯ä»¥çœ‹ä½œç½‘æ ¼å›¾ä¸Šä» (0,0)(0,0)(0,0) èµ°åˆ° (n,m)(n,m)(n,m)ï¼Œå‘å³èµ°ä»£è¡¨å®Œæˆ A æ–™ç†çš„ä¸€ä¸ªæ­¥éª¤ï¼Œå‘ä¸‹èµ°ä»£è¡¨å®Œæˆ B æ–™ç†çš„ä¸€ä¸ªæ­¥éª¤ã€‚æ±‚å‡º a,ba,ba,b çš„å‰ç¼€å’Œ sa,sbsa,sbsa,sbã€‚ç°åœ¨å°†è´¡çŒ®æ˜ å°„åˆ°ç‚¹ä¸Šï¼Œå¯¹äºæ¯ä¸ª sis_isiâ€‹ï¼Œæ‰¾åˆ°æœ€å¤§çš„ sbjâ‰¤siâˆ’saisb_j\\le s_i-sa_isbjâ€‹â‰¤siâ€‹âˆ’saiâ€‹ çš„æ ¼ç‚¹ (i,j)(i,j)(i,j)ï¼Œå®ƒåœ¨è·¯å¾„çš„å·¦ä¸Šæ–¹ï¼ˆæˆ–è·¯å¾„ä¸Šï¼‰ä¾¿æœ‰è´¡çŒ®ã€‚åŒç†å¯¹ tjt_jtjâ€‹ æ‰¾åˆ°æœ€å¤§çš„ saiâ‰¤tjâˆ’sbjsa_i\\le t_j-sb_jsaiâ€‹â‰¤tjâ€‹âˆ’sbjâ€‹ï¼Œé‚£ä¹ˆå®ƒåœ¨è·¯å¾„çš„å³ä¸‹æ”¾å°±æœ‰è´¡çŒ®ã€‚ æƒ³åŠæ³•å°†ä¸¤ç§è´¡çŒ®ç‚¹æ”¹æˆä¸€æ ·çš„ã€‚å®¹æ–¥ï¼æˆ‘ä»¬å°† ppp å…ˆå…¨éƒ¨åŠ ä¸Šï¼Œç„¶åå‡å»ä¸¥æ ¼åœ¨ä¸‹é¢çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå°† (iâˆ’1,j+1)(i-1,j+1)(iâˆ’1,j+1) çš„è´¡çŒ®æ ‡è®°ä¸º âˆ’pi-p_iâˆ’piâ€‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç°åœ¨åªéœ€è¦æœ€å¤§åŒ–å³ä¸‹ï¼ˆåŒ…æ‹¬è·¯å¾„ä¸Šï¼‰çš„æƒå€¼å’Œã€‚ æ¯æ¬¡è€ƒè™‘å¯¹å‰ä¸€åˆ—è¿›è¡Œè®¡ç®—ï¼ˆå…ˆå°† y=0y=0y=0 å’Œ x=nx=nx=n åˆ¤æ‰ï¼‰ï¼š f(x,y)=maxâ¡{f(x,yâˆ’1),f(xâˆ’1,y)+âˆ‘i=1yv(xâˆ’1,i)}f(x,y)=\\max\\{f(x,y-1),f(x-1,y)+\\sum_{i=1}^y v(x-1,i)\\} f(x,y)=max{f(x,yâˆ’1),f(xâˆ’1,y)+i=1âˆ‘yâ€‹v(xâˆ’1,i)} åç¼€åŠ ï¼Œå‰ç¼€å– maxâ¡\\maxmaxï¼Œç»´æŠ¤å·®åˆ†æ•°ç»„ï¼ŒåŒ xxx çš„ç‚¹æŒ‰ç…§ yyy ä»å¤§åˆ°å°åŠ å…¥ï¼Œæ­£æ•°ç›´æ¥åŠ å…¥å·®åˆ†æ•°ç»„ï¼Œè´Ÿæ•°çš„è¦æ‰¾åˆ°è¿™ä¸ª yyy è®©å¾€ä¸Šè·‘ç›´åˆ°è¿™ä¸ªè´Ÿçš„è´¡çŒ®æ²¡æ‰ã€‚ ä½¿ç”¨ map ç»´æŠ¤ï¼Œæ—¶é—´å¤æ‚åº¦ O((n+m)logâ¡(n+m))O((n+m)\\log (n+m))O((n+m)log(n+m))ã€‚ #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 1000005; int n, m; i64 a[N], s[N], p[N], b[N], t[N], q[N], ans; vector&lt;pair&lt;int, i64>> node[N]; void tag(int x, int y, i64 v) &#123; if (x &lt; 0 | y > m) return; if (x == n || y == 0) return ans += v, void(); node[x].emplace_back(y, v); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i] >> s[i] >> p[i], a[i] += a[i - 1]; for (int i = 1; i &lt;= m; ++i) cin >> b[i] >> t[i] >> q[i], b[i] += b[i - 1]; for (int i = 1; i &lt;= n; ++i) &#123; int j = upper_bound(b, b + m + 1, s[i] - a[i]) - b - 1; ans += p[i]; tag(i - 1, j + 1, -p[i]); &#125; for (int j = 1; j &lt;= m; ++j) &#123; int i = upper_bound(a, a + n + 1, t[j] - b[j]) - a - 1; tag(i, j, q[j]); &#125; map&lt;int, i64> c; for (int x = 0; x &lt; n; ++x) &#123; sort(node[x].begin(), node[x].end(), greater&lt;pair&lt;int, i64>>()); for (auto [y, v] : node[x]) &#123; if (v > 0) c[y] += v; else &#123; v = -v; auto it = c.lower_bound(y); while (v > 0 &amp;&amp; it != c.end()) &#123; if (v >= it->second) v -= it->second, it = c.erase(it); else &#123; it->second -= v; break; &#125; &#125; &#125; &#125; &#125; for (auto [y, v] : c) ans += v; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; C. ä¸¤ç§äº¤é€šå·¥å…· ç¥é£æ•¢æ­»é˜Ÿç‚¸æ¯äº†æ­¤å¤„çš„å†…å®¹ã€‚é€šä¿¡é¢˜ã€‚çŒœçŒœæˆ‘æ˜¯å¦è¿˜èƒ½å›æ¥åšï¼å¯¹ä¸èµ·äº†ï¼ Day3 Aï¼ŒBï¼ŒCã€‚ A. * æŒ‡å®šåŸå¸‚ Portal.ç»™å®šä¸€æ£µæ ‘ï¼ŒåŒå‘è¾¹ï¼Œæ¯æ¡è¾¹ä¸¤ä¸ªæ–¹å‘çš„æƒå€¼ä¸åŒã€‚å¤šæ¬¡è¯¢é—® kkkï¼Œè¡¨ç¤ºé€‰å‡º kkk ä¸ªç‚¹ï¼Œä¾æ¬¡å°†ä»¥æ¯ä¸ªç‚¹ä¸ºæ ¹çš„å†…å‘æ ‘è¾¹æƒèµ‹å€¼ä¸º 000ï¼Œéœ€è¦æ±‚å‡ºæœ€åæ ‘çš„è¾¹æƒä¹‹å’Œçš„æœ€å°å€¼ã€‚è¦æ±‚ O(n)O(n)O(n)ã€‚ wxw_xwxâ€‹ ä»£è¡¨ä»¥ xxx ä¸ºæ ¹çš„å†…å‘æ ‘è¾¹æƒå’Œï¼Œæ¢æ ¹ DP æ±‚å‡ºï¼Œk=1k=1k=1 è¢«è§£å†³ã€‚ è´ªå¿ƒåœ°æƒ³ï¼Œk&gt;1k&gt;1k&gt;1 ä¸€å®šæ˜¯å†é€‰ä¸€æ¡é“¾ï¼Œé•¿å‰–è´ªå¿ƒå³å¯ã€‚ ä½†æ˜¯ k=2k=2k=2 æ—¶è¿™ä¸€ç‚¹ä¸æˆç«‹ï¼Œéœ€è¦ä½¿ç”¨æ¢æ ¹ DP è§£å†³ã€‚æ¢å®Œæ ¹ä¹‹åå°†ç›´å¾„ç¼©ç‚¹ï¼Œç„¶åé•¿å‰–è´ªå¿ƒã€‚ #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; i64 sum, ans[200005]; struct edge &#123; int v, c, d; edge(int v = 0, int c = 0, int d = 0) : v(v), c(c), d(d) &#123;&#125; &#125;; vector&lt;edge> G[200005]; i64 w[200005]; void dfs1(int x, int fa) &#123; for (auto [y, c, d] : G[x]) if (y != fa) dfs1(y, x), w[x] += w[y] + d; &#125; void dfs2(int x, int fa) &#123; for (auto [y, c, d] : G[x]) if (y != fa) w[y] = w[x] - d + c, dfs2(y, x); &#125; int f[200005]; i64 dis[200005]; void DFS(int x, int fa) &#123; f[x] = fa; for (auto [y, c, d] : G[x]) if (y != fa) dis[y] = dis[x] + c + d, DFS(y, x); &#125; bool vis[200005]; vector&lt;i64> c; i64 solve(int x, int fa) &#123; i64 res = 0; for (auto [y, c, d] : G[x]) if (y != fa) &#123; i64 w = solve(y, x) + c; if (!res) res = w; else ::c.emplace_back(min(res, w)), res = max(res, w); &#125; return res; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt; n; ++i) &#123; int u, v, c, d; cin >> u >> v >> c >> d; sum += c + d; G[u].emplace_back(v, c, d); G[v].emplace_back(u, d, c); &#125; dfs1(1, 0); dfs2(1, 0); for (int i = 1; i &lt;= n; ++i) ans[1] = max(ans[1], w[i]); DFS(1, 0); int A = 1; for (int i = 1; i &lt;= n; ++i) if (dis[i] + w[i] > dis[A] + w[A]) A = i; dis[A] = 0; DFS(A, 0); int B = 1; for (int i = 1; i &lt;= n; ++i) if (dis[i] + w[i] > dis[B] + w[B]) B = i; ans[2] = (w[A] + w[B] + dis[B]) / 2; // +1 int x = B; while (x) vis[x] = 1, x = f[x]; x = B; while (x) &#123; for (auto [y, _c, _d] : G[x]) if (!vis[y]) c.emplace_back(solve(y, x) + _c); x = f[x]; &#125; sort(c.begin(), c.end(), greater&lt;i64>()); int t = 2; for (i64 x : c) ans[t + 1] = ans[t] + x, ++t; while (t &lt; n) ans[t + 1] = ans[t], ++t; for (cin >> m; m--; ) &#123; int x; cin >> x; cout &lt;&lt; sum - ans[x] &lt;&lt; \"\\n\"; &#125; return 0; &#125; B. ç¯å…‰è¡¨æ¼” Portal.nnn ä¸ªç¯æœ‰åˆå§‹çŠ¶æ€ï¼Œä¸€æ¬¡æ“ä½œå¯ä»¥åŒºé—´æ‰“å¼€/å…³é—­/ç¿»è½¬ï¼Œé—®å˜æˆç›®æ ‡çŠ¶æ€çš„æœ€å°æ“ä½œæ¬¡æ•°ã€‚nâ‰¤106n\\le 10^6nâ‰¤106ã€‚ æ‰‹ç©å¾—åˆ°åŸºç¡€ç»“è®ºï¼š åŒºé—´å¼‚æˆ–æ“ä½œå¯ä»¥æ”¾åˆ°æ‰€æœ‰èµ‹å€¼æ“ä½œä¹‹åï¼› åŒºé—´èµ‹å€¼æ“ä½œäº’ä¸ç›¸äº¤ã€‚ å¾—åˆ°æœ€åå½¢æ€ä¹‹åï¼ŒåŒºé—´å¼‚æˆ–æ“ä½œæ¬¡æ•°ä¸º sâ€²xorâ¡ts&#x27;\\operatorname{xor} tsâ€²xort çš„æé•¿ 111 æ®µæ•°ã€‚ fi,0/1/2f_{i,0/1/2}fi,0/1/2â€‹ ä»£è¡¨ä»¥ iii ç»“å°¾ï¼Œç¬¬ iii ä½ç”¨ 000ã€111ã€ä¿æŒåŸæ · æ¥è¦†ç›–çš„æœ€å°ä»£ä»·ã€‚æšä¸¾ä¸Šä¸€ä½æƒ…å†µå³å¯å®ç° O(n)O(n)O(n) è½¬ç§»ã€‚ #include &lt;bits/stdc++.h> using namespace std; int n; char s[1000005], t[1000005]; int f[1000005][3]; int main(void) &#123; scanf(\"%d%s%s\", &amp;n, s + 1, t + 1); memset(f, 0x3f, sizeof f); f[1][0] = 1 + (t[1] == '1'); f[1][1] = 1 + (t[1] == '0'); f[1][2] = (s[1] != t[1]); for (int i = 2; i &lt;= n; ++i) &#123; if (t[i] == '0') f[i][0] = min(&#123;f[i - 1][0], f[i - 1][1] + 1, f[i - 1][2] + 1&#125;); else f[i][0] = min(&#123;f[i - 1][0] + (t[i - 1] == '0'), f[i - 1][1] + (t[i - 1] == '1') + 1, f[i - 1][2] + (s[i - 1] == t[i - 1]) + 1&#125;); if (t[i] == '1') f[i][1] = min(&#123;f[i - 1][0] + 1, f[i - 1][1], f[i - 1][2] + 1&#125;); else f[i][1] = min(&#123;f[i - 1][0] + (t[i - 1] == '0') + 1, f[i - 1][1] + (t[i - 1] == '1'), f[i - 1][2] + (s[i - 1] == t[i - 1]) + 1&#125;); if (s[i] == t[i]) f[i][2] = min(&#123;f[i - 1][0], f[i - 1][1], f[i - 1][2]&#125;); else f[i][2] = min(&#123;f[i - 1][0] + (t[i - 1] == '0'), f[i - 1][1] + (t[i - 1] == '1'), f[i - 1][2] + (s[i - 1] == t[i - 1])&#125;); &#125; printf(\"%d\\n\", min(&#123;f[n][0], f[n][1], f[n][2]&#125;)); return 0; &#125; * C. æ—¶é—´æ—…äºº Portal.nnn ä¸ªç‚¹ï¼Œç¬¬ iii æ¡è·¯è¿æ¥ç¬¬ iii å’Œ i+1i+1i+1 ä¸ªç‚¹ã€‚ç¬¬ iii æ¡è·¯åœ¨ [li,ri][l_i,r_i][liâ€‹,riâ€‹] æ—¶å¼€æ”¾ï¼Œé€šè¿‡ä¸€æ¡è·¯éœ€è¦ 111 çš„æ—¶é—´ï¼Œè¡ŒåŠ¨éœ€è¦ä¿è¯åœ¨ç©¿æ¢­çš„è¿‡ç¨‹ä¸­é“è·¯ä¸€ç›´æ˜¯å¼€æ”¾çš„ã€‚Bitaro æ˜¯èƒ½ç©¿æ¢­æ—¶é—´çš„æ²³ç‹¸ï¼Œå®ƒåœ¨åŸå¸‚å¯ä»¥ç©¿æ¢­å›ä¸€ç§’å‰ã€‚ç»™å®š QQQ æ¬¡è¯¢é—®ï¼šæ”¹å˜ iii é“è·¯çš„å¼€æ”¾æ—¶é—´ã€‚å‡è®¾ BBB æ—¶åˆ»å®ƒåœ¨ AAA åŸï¼Œé—®æœ€å°‘éœ€è¦è¿›è¡Œå¤šå°‘æ¬¡æ—¶é—´æ—…è¡Œæ‰èƒ½åœ¨ DDD æ—¶åˆ»å‰åˆ°è¾¾ CCC åŸã€‚n,Qâ‰¤3Ã—105n,Q\\le 3\\times 10^5n,Qâ‰¤3Ã—105ï¼Œæ—¶é—´åœ¨ 10910^9109 çº§åˆ«ã€‚ æ˜¾ç„¶èµ°çš„æ–¹å¼å¾ˆå‘†æ¿ï¼šèƒ½èµ°å°±èµ°ï¼Œä¸èƒ½èµ°å°±æ—¶é—´æ—…è¡Œã€‚ç°åœ¨å‡è®¾ A&lt;CA&lt;CA&lt;Cã€‚ è®¾ yyy æ—¶åˆ»çš„ xxx åŸå¸‚ä»£è¡¨ (x,y)(x,y)(x,y)ï¼Œå¥—è·¯åœ°ï¼Œä¸ºäº†é¿å…è¡Œèµ°æ—¶æ—¶é—´æµé€çš„è‡ªç„¶å½±å“ï¼Œå°†å…¶æ”¹æˆ (x,yâˆ’x)(x,y-x)(x,yâˆ’x)ã€‚ ç”¨ (a,b,c)(a,b,c)(a,b,c) è¡¨ç¤ºè¡ŒåŠ¨ï¼Œaaa ä¸ºå¼€å§‹æ—¶åˆ»ï¼Œbbb ä¸ºç»“æŸæ—¶åˆ»ï¼Œccc ä¸ºæ—¶é—´å€’æµæ¬¡æ•°ã€‚(L,R)(L,R)(L,R) ä»£è¡¨è¿™æ¡é“è·¯åªèƒ½åœ¨ [L,R][L,R][L,R] æ—¶é€šè¿‡ã€‚ç°åœ¨è€ƒè™‘å¦‚ä½•åˆå¹¶ï¼š ä¸¤ä¸ªäºŒå…ƒï¼šå¦‚æœæœ‰äº¤é›†åˆ™å–äº¤é›†ï¼Œå¦åˆ™å¯ä»¥è½¬åŒ–ä¸ºä¸‰å…ƒç»„ã€‚ ä¸€äºŒä¸€ä¸‰ï¼šè§‚å¯ŸäºŒå…ƒç»„å’Œ aaa çš„å…³ç³»å³å¯ç®—å‡ºã€‚ ä¸¤ä¸ªä¸‰å…ƒï¼šè®¡ç®—ä¸­é—´æ—¶é—´ç©¿è¶Šçš„æ¬¡æ•°å³å¯ã€‚ æœ€ç»ˆç­”æ¡ˆç”¨èµ·ç»ˆç‚¹çš„ä¸¤ä¸ªä¸‰å…ƒç»„åŠ ä¸Šä¸­é—´è·¯å¾„çš„ä¸‰å…ƒç»„å³å¯å¾—åˆ°ã€‚å…·æœ‰ç»“åˆå¾‹ï¼Œå¯ä»¥ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ã€‚A&gt;CA&gt;CA&gt;C çš„æƒ…å†µæ˜¯å¯¹ç§°çš„ã€‚æ—¶é—´å¤æ‚åº¦ O((n+q)logâ¡n)O((n+q)\\log n)O((n+q)logn)ã€‚ #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int INF = 1e9; int n, q; int l[300005], r[300005]; struct Node &#123; int l, r; i64 val; Node(int l = -INF, int r = INF, i64 val = -1) : l(l), r(r), val(val) &#123;&#125; friend Node operator+ (const Node &amp;a, const Node &amp;b) &#123; if (a.val == -1 &amp;&amp; b.val == -1) &#123; if (a.l > b.r) return Node(a.l, b.r, a.l - b.r); if (a.r &lt; b.l) return Node(a.r, b.l, 0); return Node(max(a.l, b.l), min(a.r, b.r)); &#125; if (a.val == -1) &#123; if (b.l &lt; a.l) return Node(a.l, b.r, b.val + a.l - b.l); if (b.l > a.r) return Node(a.r, b.r, b.val); return b; &#125; if (b.val == -1) &#123; if (a.r &lt; b.l) return Node(a.l, b.l, a.val); if (a.r > b.r) return Node(a.l, b.r, a.val + a.r - b.r); return a; &#125; return Node(a.l, b.r, a.val + b.val + max(0, a.r - b.l)); &#125; &#125;; struct Segment_Tree &#123; Node T[1200005]; void update(int o, int l, int r, int p, int x, int y) &#123; if (l == r) return T[o] = Node(x, y, -1), void(); int mid = l + r >> 1; if (p &lt;= mid) update(o &lt;&lt; 1, l, mid, p, x, y); else update(o &lt;&lt; 1 | 1, mid + 1, r, p, x, y); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int p, int x, int y) &#123; update(1, 1, n - 1, p, x, y); &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return query(o &lt;&lt; 1, l, mid, x, y) + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); &#125; Node query(int x, int y) &#123; return query(1, 1, n - 1, x, y); &#125; &#125; tL, tR; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> q; for (int i = 1; i &lt; n; ++i) &#123; cin >> l[i] >> r[i]; tL.update(i, l[i] - i, r[i] - 1 - i); &#125; reverse(l + 1, l + n); reverse(r + 1, r + n); for (int i = 1; i &lt; n; ++i) tR.update(i, l[i] - i, r[i] - 1 - i); while (q--) &#123; int op; cin >> op; if (op == 1) &#123; int p, l, r; cin >> p >> l >> r; tL.update(p, l - p, r - 1 - p); p = n - p; tR.update(p, l - p, r - 1 - p); &#125; else &#123; int a, b, c, d; cin >> a >> b >> c >> d; if (a &lt; c) cout &lt;&lt; max(0ll, (Node(b - a, b - a) + tL.query(a, c - 1) + Node(d - c, d - c)).val) &lt;&lt; \"\\n\"; else if (a == c) cout &lt;&lt; max(0, b - d) &lt;&lt; \"\\n\"; else &#123; a = n - a + 1; c = n - c + 1; cout &lt;&lt; max(0ll, (Node(b - a, b - a) + tR.query(a, c - 1) + Node(d - c, d - c)).val) &lt;&lt; \"\\n\"; &#125; &#125; &#125; return 0; &#125; Day4 Aï¼ŒBï¼ŒCã€‚ A. * è›‹ç³•æ‹¼æ¥ 3 Portal.n(nâ‰¤2Ã—105)n(n\\le 2\\times 10^5)n(nâ‰¤2Ã—105) å—è›‹ç³•æœ‰è‡ªå·±çš„ä»·å€¼ ViV_iViâ€‹ å’Œé¢œè‰² CiC_iCiâ€‹ï¼Œéœ€è¦é€‰æ‹© MMM å—äº’ä¸ç›¸åŒçš„è›‹ç³•æ‹¼æˆä¸€ä¸ªç¯ï¼Œè›‹ç³•çš„ç¾å‘³ç¨‹åº¦ä¸ºï¼šâˆ‘j=1MVkjâˆ’âˆ‘j=1âˆ£Ckjâˆ’Ckj mod M+1âˆ£\\sum_{j=1}^M V_{k_j}-\\sum_{j=1}|C_{k_j}-C_{k_j \\bmod M+1}|j=1âˆ‘Mâ€‹Vkjâ€‹â€‹âˆ’j=1âˆ‘â€‹âˆ£Ckjâ€‹â€‹âˆ’Ckjâ€‹modM+1â€‹âˆ£ç»™å®š MMMï¼Œæ±‚å‡ºä¸€ä¸ª kkkï¼Œé—®æœ€å¤§çš„ç¾å‘³ç¨‹åº¦ã€‚ å¦‚æœé€‰å®šäº† kkkï¼Œé‚£ä¹ˆæŒ‰ç…§ CCC æ’åºç®—å‡ºè´¡çŒ®ã€‚ æ‰“è¡¨å‘ç°å…·æœ‰å†³ç­–å•è°ƒæ€§ï¼Œåˆ†æ²»è®¡ç®—å³å¯ã€‚ #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 200005; int n, m, nn; struct Cake &#123; int v, c; bool operator&lt; (const Cake &amp;a) const &#123; return c &lt; a.c; &#125; &#125; a[N]; int b[N]; struct Node &#123; int ls, rs; int siz; i64 sum; &#125; T[N * 40]; int rt[N], tot; int update(int pre, int l, int r, int x, int v) &#123; int o = ++tot; T[o] = T[pre]; ++T[o].siz; T[o].sum += v; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x, v); else T[o].rs = update(T[pre].rs, mid + 1, r, x, v); return o; &#125; i64 query(int p, int q, int l, int r, int k) &#123; // å€¼åŸŸåœ¨ [l, r] ä¸­çš„ V æœ€å¤§ k ä¸ªçš„ç­”æ¡ˆ if (l == r) return 1ll * k * b[l]; int mid = l + r >> 1, res = T[T[q].rs].siz - T[T[p].rs].siz; if (res >= k) return query(T[p].rs, T[q].rs, mid + 1, r, k); return query(T[p].ls, T[q].ls, l, mid, k - res) + T[T[q].rs].sum - T[T[p].rs].sum; &#125; i64 ans = -1e18; inline i64 calc(int l, int r) &#123; return query(rt[l - 1], rt[r], 1, nn, m) - 2 * (a[r].c - a[l].c); &#125; void solve(int l, int r, int L, int R) &#123; // å†³ç­–åŒºé—´ [L, R] if (l > r) return; int mid = l + r >> 1, p = 0, RR = min(R, mid - m + 1); i64 mx = -1e18; for (int i = L; i &lt;= RR; ++i) &#123; i64 w = calc(i, mid); if (w > mx) mx = w, p = i; &#125; ans = max(ans, mx); solve(l, mid - 1, L, p); solve(mid + 1, r, p, R); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i].v >> a[i].c, b[i] = a[i].v; sort(b + 1, b + n + 1); sort(a + 1, a + n + 1); nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) rt[i] = update(rt[i - 1], 1, nn, lower_bound(b + 1, b + nn + 1, a[i].v) - b, a[i].v); solve(m, n, 1, n); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; B. åˆå¹¶ Portal.n(nâ‰¤2Ã—105)n(n\\le 2\\times 10^5)n(nâ‰¤2Ã—105) ä¸ªç‚¹çš„æ ‘ï¼Œæ¯ä¸ªç‚¹æœ‰é¢œè‰²ï¼Œä¸€æ¬¡æ“ä½œå¯ä»¥å°†ä¸¤ç§æ“ä½œå¹¶ä¸ºä¸€ç§é¢œè‰²ã€‚ä¸€æ£µæ ‘æ˜¯ä¸åˆæ³•çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ä¸€æ¡è¾¹ï¼Œæ²¡æœ‰ä»»ä½•ä¸€ç§é¢œè‰²å­˜åœ¨äºä¸¤è¾¹ã€‚é—®ä½¿å¾—æ ‘åˆæ³•çš„æœ€å°æ“ä½œæ•°ã€‚ åˆå¹¶æ‰€æœ‰çš„ä¸¤ä¸ªç›¸åŒé¢œè‰²æ„æˆçš„é“¾ä¸Šçš„è¾¹ï¼Œæœ€ååˆå¹¶æ‰€æœ‰åº¦æ•°ä¸º 111 çš„ç‚¹ï¼Œç­”æ¡ˆæ˜¯ âŒˆc2âŒ‰\\left\\lceil \\frac c 2 \\right\\rceilâŒˆ2câ€‹âŒ‰ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ï¼ˆå¹¶æŸ¥é›†åªè·¯å¾„å‹ç¼©ï¼‰ã€‚ #include &lt;bits/stdc++.h> using namespace std; int n, k, a[500005]; vector&lt;int> G[500005]; int f[500005], dep[500005]; int bin[500005]; int find(int x) &#123; return bin[x] == x ? x : bin[x] = find(bin[x]); &#125; void dfs(int x, int fa) &#123; dep[x] = dep[f[x] = fa] + 1; bin[x] = x; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int lst[500005]; void calc(int x, int y) &#123; x = find(x); y = find(y); while (x != y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); bin[x] = find(bin[f[x]]); x = find(x); &#125; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> k; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; if (lst[a[i]]) calc(lst[a[i]], i); lst[a[i]] = i; &#125; static int deg[500005]; memset(deg, 0, sizeof deg); for (int i = 2; i &lt;= n; ++i) &#123; int x = find(f[i]), y = find(i); if (x != y) ++deg[x], ++deg[y]; &#125; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += (deg[i] == 1); cout &lt;&lt; (cnt == 1 ? 0 : (cnt + 1) / 2) &lt;&lt; \"\\n\"; return 0; &#125; * C. çŸ¿ç‰© Portal.2n(nâ‰¤4.3Ã—104)2n(n\\le 4.3\\times 10^4)2n(nâ‰¤4.3Ã—104) ä¸ªçƒï¼Œnnn ç§é¢œè‰²æ¯ç§æ°å¥½å‡ºç°ä¸¤æ¬¡ï¼Œéœ€è¦å°†çƒé…å¯¹ã€‚å¯ä»¥è¯¢é—® 10610^6106 æ¬¡ï¼šæ’å…¥/åˆ é™¤ä¸€ä¸ªçƒï¼Œå¾—åˆ°é¢œè‰²ç§ç±»æ•°ã€‚ çœ‹åˆ°è¿™ä¸ªæ•°æ®èŒƒå›´è€ƒè™‘åˆ†æ²»ã€‚solve(A, B) è¡¨ç¤ºæ‰€æœ‰ç›¸åŒé¢œè‰²çš„çƒä¸€ä¸ªåœ¨ AAAï¼Œå¦ä¸€ä¸ªåœ¨ BBBã€‚åªéœ€è¦å¯¹ AAA çš„å‰ä¸€åŠé—®ä¸€æ¬¡ï¼Œç„¶åå¯¹ BBB å…¨éƒ¨é—®ä¸€æ¬¡ï¼Œå°±å¯ä»¥å¾—åˆ° BBB ä¸­çš„æ˜¯å¦å½’ AAA çš„å‰ä¸€åŠçš„ã€‚ å¡å¸¸å¡åˆ°ä¸§å¿ƒç—…ç‹‚ï¼Œä¸­ç‚¹åˆ†æ²»ä¸ä¸€å®šæ˜¯æœ€ä¼˜ï¼Œå‘ç°ç¨å¾®å°ä¸€ç‚¹è¡¨ç°æ›´å¥½ï¼Œéšæœºåç§»ä¸€ä¸‹ã€‚åŒæ—¶ï¼Œæ³¨æ„ä¸è¦æµªè´¹éå¿…è¦çš„è¯¢é—®ã€‚ #include &lt;bits/stdc++.h> #include \"minerals.h\" using namespace std; mt19937 Rand(time(0)); double rnd(double l, double r) &#123; return uniform_real_distribution&lt;double>(l, r)(Rand); &#125; bool query(int x) &#123; static int last = 0; int v = Query(x); if (v == last) return 0; return last = v, 1; &#125; void solve(vector&lt;int> a, vector&lt;int> b, bool in) &#123; if (a.size() == 1) return Answer(a[0], b[0]); vector&lt;int> bl, br; int m = max(1, int(a.size() * rnd(0.3, 0.5))); for (int i = 0; i &lt; m; ++i) query(a[i]); for (int i : b) if (bl.size() == m) br.emplace_back(i); else if (br.size() == a.size() - m) bl.emplace_back(i); else if (query(i) == in) bl.emplace_back(i); else br.emplace_back(i); solve(vector&lt;int>(a.begin(), a.begin() + m), bl, !in); solve(vector&lt;int>(a.begin() + m, a.end()), br, in); &#125; void Solve(int n) &#123; n &lt;&lt;= 1; vector&lt;int> a, b; static int id[200005]; for (int i = 1; i &lt;= n; ++i) id[i] = i; shuffle(id + 1, id + n + 1, Rand); for (int i = 1; i &lt;= n; ++i) if (query(id[i])) a.emplace_back(id[i]); else b.emplace_back(id[i]); solve(a, b, 1); &#125; æ€»ç»“ 10/8 æœºæˆ¿é›†ä½“ CF è¢«æ‰€æœ‰äººå¹²çƒ‚äº†â€¦â€¦ å”‰ï¼ŒåŠ è®­ï¼ŒåŠ è®­ï¼ åœ¨ç¬”è€…çš„è®¾å®šä¸­ï¼Œé—ªè€€çš„èŠå£«è›‹æŒå¯ä»¥åœ¨æš—å¤œä¸­å‘å‡ºè§å…‰ï¼Œå¹¶ä¸”æ— æ¯’ï¼Œæš‚æ—¶æ²¡æœ‰æƒ³åˆ°å¦‚ä½•åˆ¶ä½œï¼›è€Œæ·±æ½œçš„æå¯’å†°æ²™æ˜¯ä¸–ç•Œä¸Šæœ€å¯’å†·çš„å†°æ¿€å‡Œï¼Œä½†æ˜¯éœ€è¦ä¿è¯å®ƒçš„æ¯”çƒ­è¶³å¤Ÿä½ï¼Œè¿™æ ·æ‰èƒ½æ­£å¸¸é£Ÿç”¨å®ƒã€‚ â†©ï¸","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"JOI","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/JOI","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/JOI/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"é›†è®­é˜Ÿä½œä¸š 2021","slug":"default/ioihw-2021","date":"2023-09-23T00:00:00.000Z","updated":"2023-09-23T00:00:00.000Z","comments":true,"path":"d419e905/","link":"","permalink":"https://james1badcreeper.github.io/d419e905/","excerpt":"2021 æ˜¯ ACM é¢˜ï¼Œåæ­£åšåšçœ‹å§ã€‚","text":"2021 æ˜¯ ACM é¢˜ï¼Œåæ­£åšåšçœ‹å§ã€‚ æ„Ÿè°¢ M_seaã€‚ ç”±äºç¬”è€…æš‚æ—¶æ²¡æœ‰ä¸Šç´«åï¼Œæ‰€ä»¥é¢„è®¡ 11 æœˆä»½ä¿®å¤æœ¬æ–‡æ‰€æœ‰çš„ä»£ç é“¾æ¥ã€‚ PART I æˆ‘è¿˜æ˜¯ä¸çŸ¥é“ã€‚ A å‘ç°å¥½å¤šä¸æ˜¯æˆ‘èƒ½åšçš„â€¦â€¦ [ICPC2014 WF] Baggage Portal. æˆ‘ä»¬æ˜¯å¦èƒ½å°† nnn è¾ƒå¤§çš„è½¬åŒ–ä¸º nnn è¾ƒå°çš„ï¼Ÿè§‚å¯Ÿæ ·ä¾‹ï¼Œn=5n=5n=5 æ—¶æ•´ä½“å·¦ç§»äº†ä¸¤æ ¼ï¼Œå‘ç°åªéœ€è¦åˆ©ç”¨å·¦å››å³å››ä¸ªæ•°å°±å¯ä»¥åšæˆå·¦è¾¹ç©ºä¸¤æ ¼ï¼Œå°† nâ‰¤7n\\le 7nâ‰¤7 çš„æ‰“è¡¨æ‰“å‡ºè§£å³å¯ï¼ˆn=3n=3n=3 ç‰¹æ®Šï¼Œåªå·¦ç§»ä¸¤æ ¼æ˜¯æ— è§£çš„ï¼‰ã€‚ä»£ç ã€‚ è·³è¿‡ *2 PART III Portal. A æ»¡å¤©æ˜Ÿæ–—ï¼Œå¹¿è¢¤å®‡å®™ï¼Œä¸å¦‚å‘å‰èµ°ã€‚ [CERC2015] Cow Confinement Portal. ä¸€å¤´ç‰›çš„è¯æ˜¾ç„¶æ˜¯ DPï¼ˆfi,j=fi+1,j+fi,j+1âˆ’fi+1,j+1f_{i,j}=f_{i+1,j}+f_{i,j+1}-f_{i+1,j+1}fi,jâ€‹=fi+1,jâ€‹+fi,j+1â€‹âˆ’fi+1,j+1â€‹ï¼‰ï¼Œé‚£ä¹ˆè€ƒè™‘ç”¨æ‰«æçº¿ä»å³å‘å·¦æ‰«ï¼Œçº¿æ®µæ ‘ç»´æŠ¤å½“å‰æ¯ä¸ªç‚¹çš„ DP å€¼ã€‚å¦‚æœæ‰«åˆ°äº†ä¸€ä¸ªå³åŒºé—´ï¼Œé‚£ä¹ˆä»ä¸Šçº¿åˆ°ä¸‹ä¸€æ¡ä¸‹çº¿éƒ½è¦è¢«åŠ åœ¨ä¸Šçº¿ä¸Šçš„ä¸€ä¸ªæ ¼å­ï¼Œå¹¶ä¸”çº¿å†…æ•°æ®æ¸…é›¶ã€‚æ‰«åˆ°å·¦çº¿çº¿å†…æ•°æ®æ¸…é›¶ï¼Œå¹¶æŠŠåŸæ¥çº¿å¤–çš„ä¸œè¥¿åŠ å›æ¥ï¼Œæœ€åå†æŠŠå³ä¸‹è§’ç®—é‡çš„éƒ¨åˆ†å‡å»å°±è¡Œã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"NOI ä¸€è½®å¤ä¹  IVï¼šå›¾è®º","slug":"notes/NOI å¤ä¹ /noi-1-4","date":"2023-09-20T00:00:00.000Z","updated":"2024-03-13T00:00:00.000Z","comments":true,"path":"d25bf624/","link":"","permalink":"https://james1badcreeper.github.io/d25bf624/","excerpt":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬å››ç¯‡ï¼ŒåŒ…æ‹¬å„ç±»å›¾è®ºç®—æ³•ã€‚","text":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬å››ç¯‡ï¼ŒåŒ…æ‹¬å„ç±»å›¾è®ºç®—æ³•ã€‚ å›¾çš„ç›¸å…³æ¦‚å¿µ ä¸€å¼ å›¾ GGG ç”±ç‚¹é›† VVV å’Œè¾¹é›† EEE æ„æˆã€‚æˆ‘ä»¬ç”¨ d(v)d(v)d(v) ä»£è¡¨èŠ‚ç‚¹ vvv çš„åº¦æ•°ï¼Œå¦‚æœ d(v)=âˆ£Vâˆ£âˆ’1d(v)=|V|-1d(v)=âˆ£Vâˆ£âˆ’1ï¼Œåˆ™ç§° vvv ä¸ºæ”¯é…ç‚¹ã€‚å¦‚æœæ¯ä¸ªç‚¹çš„åº¦æ•°éƒ½æ˜¯ kkkï¼Œåˆ™è¯¥å›¾ä¸º kâˆ’k-kâˆ’æ­£åˆ™å›¾ã€‚ å­å›¾ å¯¹ä¸€å¼ å›¾ G=(V,E)G = (V, E)G=(V,E)ï¼Œè‹¥å­˜åœ¨å¦ä¸€å¼ å›¾ H=(Vâ€²,Eâ€²)H = (V&#x27;, E&#x27;)H=(Vâ€²,Eâ€²) æ»¡è¶³ Vâ€²âŠ†VV&#x27; \\subseteq VVâ€²âŠ†V ä¸” Eâ€²âŠ†EE&#x27; \\subseteq EEâ€²âŠ†Eï¼Œåˆ™ç§° HHH æ˜¯ GGG çš„å­å›¾ï¼Œè®°ä½œ HâŠ†GH \\subseteq GHâŠ†Gã€‚ è‹¥å¯¹ HâŠ†GH \\subseteq GHâŠ†Gï¼Œæ»¡è¶³ âˆ€u,vâˆˆVâ€²\\forall u, v \\in V&#x27;âˆ€u,vâˆˆVâ€²ï¼Œåªè¦ (u,v)âˆˆE(u, v) \\in E(u,v)âˆˆEï¼Œå‡æœ‰ (u,v)âˆˆEâ€²(u, v) \\in E&#x27;(u,v)âˆˆEâ€²ï¼Œåˆ™ç§° HHH æ˜¯ GGG çš„å¯¼å‡ºå­å›¾ã€‚ç‚¹é›†ä¸º Vâ€²(Vâ€²âŠ†V)V&#x27;(V&#x27; \\subseteq V)Vâ€²(Vâ€²âŠ†V) çš„å¯¼å‡ºå­å›¾ç§°ä¸º Vâ€²V&#x27;Vâ€² å¯¼å‡ºçš„å­å›¾ï¼Œè®°ä½œ G[Vâ€²]G \\left[ V&#x27; \\right]G[Vâ€²]ã€‚ è‹¥ HâŠ†GH \\subseteq GHâŠ†G æ»¡è¶³ Vâ€²=VV&#x27; = VVâ€²=Vï¼Œåˆ™ç§° HHH ä¸º GGG çš„ç”Ÿæˆå­å›¾/æ”¯æ’‘å­å›¾ã€‚ å¦‚æœä¸€å¼ æ— å‘å›¾ GGG çš„æŸä¸ªç”Ÿæˆå­å›¾ FFF ä¸º kâˆ’k-kâˆ’æ­£åˆ™å›¾ï¼Œåˆ™ç§° FFF ä¸º GGG çš„ä¸€ä¸ª kâˆ’k-kâˆ’å› å­ã€‚ å¦‚æœæœ‰å‘å›¾ G=(V,E)G = (V, E)G=(V,E) çš„å¯¼å‡ºå­å›¾ H=G[Vâˆ—]H = G \\left[ V^\\ast \\right]H=G[Vâˆ—] æ»¡è¶³ âˆ€vâˆˆVâˆ—,(v,u)âˆˆE\\forall v \\in V^\\ast, (v, u) \\in Eâˆ€vâˆˆVâˆ—,(v,u)âˆˆEï¼Œæœ‰ uâˆˆVâˆ—u \\in V^\\astuâˆˆVâˆ—ï¼Œåˆ™ç§° HHH ä¸º GGG çš„ä¸€ä¸ªé—­åˆå­å›¾ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå›¾å†…éƒ¨æ˜¯é—­åˆçš„ï¼Œä¸å­˜åœ¨ä¸€ä¸ªç‚¹åœ¨å¯¼å‡ºå­å›¾å†…ï¼Œå¯ä»¥é€šè¿‡åŸå›¾çš„ä¸€æ¡è¾¹è¿åˆ°ä¸€ä¸ªä¸åœ¨å¯¼å‡ºå­å›¾å†…çš„ç‚¹ã€‚ ç‰¹æ®Šçš„å›¾ å¯¹äºæ— å‘ç®€å•å›¾ï¼Œæ‰€æœ‰æœ¬æ¥åœ¨å›¾ä¸Šçš„è¾¹éƒ½ä¸åœ¨ï¼Œæœ¬æ¥ä¸åœ¨çš„éƒ½åœ¨ï¼Œé‚£ä¹ˆè¿™ä¸ªå›¾å°±æ˜¯åŸæ— å‘å›¾çš„è¡¥å›¾ã€‚ å¯¹äºæœ‰å‘å›¾ï¼Œæ¯æ¡è¾¹çš„æ–¹å‘å–åï¼Œå¾—åˆ°çš„å›¾å°±æ˜¯åŸå›¾çš„åå›¾ã€‚ ç‰¹æ®Šé›†åˆ ä¸€äº›ç‰¹æ®Šçš„ç‚¹å’Œè¾¹çš„é›†åˆæœ‰ç€ç‰¹æ®Šçš„æ„ä¹‰ï¼Œè¿™é‡Œæˆ‘ä»¬ä»‹ç»ä¸€äº›å¸¸è§çš„ã€‚ æ”¯é…é›† å¯¹äºæ— å‘å›¾ï¼Œå¦‚æœä¸€ä¸ªç‚¹é›†çš„ç‚¹å¯ä»¥è¿æ¥åˆ°åŸå›¾çš„æ‰€æœ‰ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹é›†ä¸ºåŸå›¾çš„æ”¯é…é›†ã€‚ æœ€å°æ”¯é…é›†æ˜¯ NPH çš„ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨ O(2n)O(2^n)O(2n) çš„æšä¸¾ç®—æ³•æ¥æ±‚è§£æ”¯é…é›†ã€‚ ç‹¬ç«‹é›† å°±æ˜¯ä»»æ„ä¸¤ç‚¹ä¸ç›¸é‚»çš„ç‚¹é›†ã€‚å¯¹äºæ ‘å’ŒäºŒåˆ†å›¾æˆ‘ä»¬æœ‰é«˜æ•ˆåšæ³•ï¼Œä½†æ˜¯ä¸€èˆ¬å›¾ä¸Šï¼Œè¿™ä¸ªé—®é¢˜æ˜¯ NPH çš„ã€‚ åŒ¹é… å¯¹äºå›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œè‹¥ Eâ€²âˆˆEE&#x27;\\in EEâ€²âˆˆE ä¸” Eâ€²E&#x27;Eâ€² ä¸­ä»»æ„ä¸¤æ¡è¾¹éƒ½æ²¡æœ‰å…¬å…±ç«¯ç‚¹ï¼Œä¸” Eâ€²E&#x27;Eâ€² ä¸­æ²¡æœ‰è‡ªç¯ï¼Œé‚£ä¹ˆ Eâ€²E&#x27;Eâ€² æ˜¯ GGG çš„ä¸€ä¸ªåŒ¹é…ï¼Œä¹Ÿç§°ä¸ºè¾¹ç‹¬ç«‹é›†ã€‚å¦‚æœä¸€ä¸ªç‚¹è¢«åŒ¹é…çš„è¾¹è¿æ¥äº†ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯è¢«åŒ¹é…çš„ï¼Œå¦åˆ™å°±æ˜¯ä¸è¢«åŒ¹é…çš„ã€‚ è¾¹æ•°æœ€å¤šçš„ç§°ä¸ºæœ€å¤§åŒ¹é…ï¼Œå¦‚æœè¾¹å¸¦æƒï¼Œé‚£ä¹ˆæƒé‡ä¹‹å’Œæœ€å¤§çš„åŒ¹é…ç§°ä¸ºå›¾çš„æœ€å¤§æƒåŒ¹é…ã€‚ å¦‚æœä¸€ä¸ªåŒ¹é…åœ¨åŠ å…¥ä»»ä½•ä¸€æ¡è¾¹åéƒ½ä¸å†æ˜¯ä¸€ä¸ªåŒ¹é…ï¼Œé‚£ä¹ˆè¿™ä¸ªåŒ¹é…å°±æ˜¯æå¤§åŒ¹é…ï¼Œæœ€å¤§åŒ¹é…ä¸€å®šæ˜¯æå¤§åŒ¹é…ã€‚ å¦‚æœæ‰€æœ‰ç‚¹éƒ½è¢«åŒ¹é…äº†ï¼Œé‚£ä¹ˆè¿™ä¸ªåŒ¹é…æ˜¯å®Œç¾åŒ¹é…ã€‚å¦‚æœåœ¨ä¸€ä¸ªåŒ¹é…ä¸­åªæœ‰ä¸€ä¸ªç‚¹ä¸è¢«åŒ¹é…ï¼Œé‚£ä¹ˆè¯¥åŒ¹é…ä¸ºå‡†å®Œç¾åŒ¹é…ã€‚ å¯¹äºä¸€ä¸ªåŒ¹é… MMMï¼Œè‹¥ä¸€æ¡è·¯å¾„ä»¥éåŒ¹é…ç‚¹ä¸ºèµ·ç‚¹ï¼Œæ¯ç›¸é‚»ä¸¤æ¡è¾¹ä¸­çš„ä¸€æ¡åœ¨åŒ¹é…ä¸­è€Œå¦ä¸€æ¡ä¸åœ¨åŒ¹é…ä¸­ï¼Œé‚£ä¹ˆè¿™æ¡è·¯å¾„ç§°ä¸ºäº¤æ›¿è·¯å¾„ï¼›ä¸€æ¡éåŒ¹é…ç‚¹ç»ˆæ­¢çš„äº¤æ›¿è·¯å¾„ç§°ä¸ºå¢å¹¿è·¯å¾„ã€‚ ç‚¹è¦†ç›– å¦‚æœæ‰€æœ‰è¾¹éƒ½è‡³å°‘æœ‰ä¸€ä¸ªç«¯ç‚¹åœ¨è¿™ä¸ªç‚¹é›†ä¸­ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹é›†è¢«ç§°ä¸ºç‚¹è¦†ç›–é›†ã€‚ ç‚¹è¦†ç›–é›†ä¸€å®šæ˜¯æ”¯é…é›†ï¼Œä½†æ˜¯æå°ç‚¹è¦†ç›–é›†ä¸ä¸€å®šæ˜¯æå°æ”¯é…é›†ï¼ˆè€ƒè™‘ä¸€ä¸ªä¸‰å…ƒç¯ï¼‰ã€‚ ç‚¹è¦†ç›–é›†æ‹¥æœ‰ä»¥ä¸‹æ€§è´¨ï¼š ä¸€ä¸ªç‚¹é›†æ˜¯ç‚¹è¦†ç›–çš„å……è¦æ¡ä»¶æ˜¯å…¶è¡¥é›†æ˜¯ç‹¬ç«‹é›†ã€‚ ä¸€å¼ å›¾çš„ä»»ä½•ä¸€ä¸ªåŒ¹é…çš„å¤§å°éƒ½ä¸è¶…è¿‡å…¶ä»»ä½•ä¸€ä¸ªç‚¹è¦†ç›–çš„å¤§å°ã€‚ è¾¹è¦†ç›– å½“å‰è¾¹é›†æ»¡è¶³ä»»ä½•ä¸€ä¸ªç‚¹éƒ½è‡³å°‘æ˜¯å…¶ä¸­ä¸€æ¡è¾¹çš„ä¸€ä¸ªç«¯ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªè¾¹é›†ç§°ä¸ºè¾¹è¦†ç›–é›†ã€‚ å¦‚æœçŸ¥é“äº†æœ€å¤§åŒ¹é…ï¼Œé‚£ä¹ˆå°†æ‰€æœ‰éåŒ¹é…ç‚¹éƒ½è¿ä¸€æ¡è¾¹åŠ å…¥æœ€å¤§åŒ¹é…ï¼Œé‚£ä¹ˆå°±å¾—åˆ°äº†ä¸€ä¸ªæœ€å°è¾¹è¦†ç›–ã€‚åŒç†ï¼Œå¦‚æœçŸ¥é“äº†æœ€å°è¾¹è¦†ç›–ï¼Œé‚£ä¹ˆå°†æœ‰å…¬å…±ç‚¹çš„è¾¹åˆ å»åˆ°åªå‰©ä¸€æ¡å°±å¾—åˆ°äº†æœ€å¤§åŒ¹é…ã€‚ å›¢ ä¸€ä¸ªå›¾çš„å­ç‚¹é›† Vâ€²V&#x27;Vâ€² ä¸­ä»»æ„ä¸¤ä¸ªä¸åŒçš„é¡¶ç‚¹éƒ½ç›¸é‚»ï¼Œåˆ™ç§° Vâ€²V&#x27;Vâ€² æ˜¯å›¾ GGG çš„ä¸€ä¸ªå›¢ã€‚å›¢å¯¹åº”çš„å¯¼å‡ºå­å›¾æ˜¯å®Œå…¨å›¾ã€‚è¯´ç™½äº†æœ€å¤§å›¢å°±æ˜¯æœ€å¤§å®Œå…¨å­å›¾ã€‚ æ±‚è§£ä¸€ä¸ªå›¾çš„æœ€å¤§å›¢æ˜¯ NPH çš„ï¼Œå¯ä»¥ä½¿ç”¨æœ€å¤§å›¢æœç´¢ç®—æ³•ï¼ˆåœ¨æš´åŠ›æšä¸¾çš„åŸºç¡€ä¸ŠåŠ ä¸€ä¸ªä¸å¯èƒ½æˆä¸ºç­”æ¡ˆçš„æœ€ä¼˜æ€§å‰ªæï¼‰æ¥è§£å†³è§„æ¨¡è¾ƒå°çš„å›¾çš„é—®é¢˜ã€‚ ErdÅ‘sâ€“Gallai å®šç† ä»¤ S=(d1,â‹¯ ,dn)S=(d_1,\\cdots,d_n)S=(d1â€‹,â‹¯,dnâ€‹) ä»£è¡¨ç®€å•æ— å‘å›¾çš„åº¦æ•°ï¼Œè€Œä¸” ddd ä¸ºéé€’å¢åºåˆ—ï¼Œåˆ™æ— å‘å›¾å­˜åœ¨å½“ä¸”ä»…å½“ âˆ‘d\\sum dâˆ‘d æ˜¯å¶æ•°ï¼Œè€Œä¸” âˆ€k,i.e.\\forall k, \\text{i.e.}âˆ€k,i.e.ï¼š âˆ‘i=1kdiâ‰¤k(kâˆ’1)+âˆ‘i=k+1nminâ¡(di,k)\\sum_{i=1}^kd_i\\leq k(k-1)+\\sum_{i=k+1}^n\\min(d_i,k) i=1âˆ‘kâ€‹diâ€‹â‰¤k(kâˆ’1)+i=k+1âˆ‘nâ€‹min(diâ€‹,k) [CF1091E] New Year and the Acquaintance Estimation.ä¸€å¼  n+1n+1n+1 ä¸ªç‚¹çš„æ— å‘å›¾ï¼Œç»™å®šå‰ nnn ä¸ªç‚¹çš„åº¦æ•°ï¼Œé—® n+1n+1n+1 å·ç‚¹å¯èƒ½çš„åº¦æ•°ã€‚nâ‰¤5Ã—105n\\le 5\\times 10^5nâ‰¤5Ã—105ã€‚ äºŒåˆ†å‡ºå¯èƒ½çš„åº¦æ•°ï¼Œç„¶å ErdÅ‘sâ€“Gallai å®šç†ä¸éš¾åœ¨é¢„å¤„ç†å‰ç¼€ååšåˆ° O(n)O(n)O(n) checkã€‚ä»£ç ã€‚ æ‹“æ‰‘æ’åº å¯¹äºä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰GGGï¼Œå°† GGG ä¸­æ‰€æœ‰é¡¶ç‚¹æ’æˆä¸€ä¸ªçº¿æ€§åºåˆ—ï¼Œä½¿å¾—å›¾ä¸­ä»»æ„ä¸€å¯¹é¡¶ç‚¹ uuu å’Œ vvv ï¼Œè‹¥å®ƒä»¬ä¹‹é—´å­˜åœ¨ä¸€æ¡æœ‰å‘è¾¹ (u,v)(u,v)(u,v)ï¼Œåˆ™ uuu åœ¨çº¿æ€§åºåˆ—ä¸­å‡ºç°åœ¨ vvv ä¹‹å‰ã€‚ å¦‚æœè¦è®©è¶Šå°çš„ iii å°½å¯èƒ½åœ°å‡ºç°åœ°æ—©ï¼Œé‚£ä¹ˆå°±æ˜¯è®©æœ€å¤§çš„å°½å¯èƒ½æ™šåœ°å‡ºç°ï¼Œé‚£ä¹ˆè¦æ±‚åå›¾ä¸Šå­—å…¸åºæœ€å¤§çš„æ‹“æ‰‘åºï¼Œä¹Ÿå°±æ˜¯èœè‚´åˆ¶ä½œã€‚ æ¬§æ‹‰è·¯é—®é¢˜ æ¬§æ‹‰å›è·¯ï¼šé€šè¿‡å›¾ä¸­çš„æ¯æ¡è¾¹æ°å¥½ä¸€æ¬¡çš„å›è·¯ï¼› æ¬§æ‹‰é€šè·¯ï¼šé€šè¿‡å›¾ä¸­çš„æ¯æ¡è¾¹æ°å¥½ä¸€æ¬¡çš„é€šè·¯ï¼› æ¬§æ‹‰å›¾ï¼šæœ‰æ¬§æ‹‰å›è·¯ï¼› åŠæ¬§æ‹‰å›¾ï¼šæœ‰æ¬§æ‹‰é€šè·¯ä½†æ˜¯æ²¡æœ‰æ¬§æ‹‰å›è·¯ã€‚ å¯¹äºæ— å‘è¿é€šå›¾ï¼Œå¦‚æœæ‰€æœ‰ç‚¹çš„åº¦æ•°å‡ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆæ˜¯æ¬§æ‹‰å›¾ï¼›å¦‚æœæœ‰æ°å¥½ä¸¤ä¸ªå¥‡åº¦æ•°ç‚¹ï¼Œé‚£ä¹ˆæ˜¯åŠæ¬§æ‹‰å›¾ã€‚ è€Œå¯¹äºä¸€å¼ æœ‰å‘å›¾ï¼ˆæ˜¾ç„¶ï¼Œå®ƒè‡³å°‘éœ€è¦å¼±è¿é€šï¼‰ï¼Œæ˜¯æ¬§æ‹‰å›¾å½“ä¸”ä»…å½“å…¶æ˜¯ä¸€ä¸ªå¼ºè¿é€šå›¾ä¸”æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦å’Œå‡ºåº¦ç›¸ç­‰ã€‚å¦‚æœè¿™å¼ å›¾æ°å­˜åœ¨ä¸€ä¸ªé¡¶ç‚¹çš„å‡ºåº¦æ¯”å…¥åº¦å° 111ï¼Œå¦ä¸€ä¸ªç‚¹å‡ºåº¦æ¯”å…¥åº¦å¤§ 111ï¼ˆè¿™ä¸ªç‚¹ä¸ºèµ·ç‚¹ï¼‰ï¼Œè¿™ä¸ªå›¾å­˜åœ¨æ¬§æ‹‰é€šè·¯ã€‚ æ±‚è§£æ¬§æ‹‰è·¯å¯ä»¥ä½¿ç”¨ Hierholzer ç®—æ³•ã€‚é‡‡ç”¨ DFS ä¸æ–­æ‰¾ç¯ï¼Œéå†å½“å‰èŠ‚ç‚¹ uuu çš„æ‰€æœ‰å‡ºè¾¹ï¼Œå¦‚æœæ²¡æœ‰èµ°è¿‡é‚£å°±éå†ï¼Œéå†å®Œæ‰€æœ‰å‡ºè¾¹åå°† uuu åŠ å…¥æ¬§æ‹‰è·¯å¾„ï¼Œæœ€åå¦‚æœéå†çš„ç‚¹çš„ä¸ªæ•°ä¸º m+1m+1m+1ï¼Œé‚£ä¹ˆå°±å¾—åˆ°äº†åç€çš„æ¬§æ‹‰è·¯å¾„ï¼Œå¦åˆ™æ¬§æ‹‰è·¯å¾„ä¸å­˜åœ¨ã€‚ åœ¨æ‰¾æ¬§æ‹‰å›è·¯æ—¶ï¼Œå¯ä»¥ä»ä»»æ„èŠ‚ç‚¹å‡ºå‘ã€‚å¦åˆ™ï¼Œéœ€è¦ä»æ ¹æ®æ€§è´¨æ‰¾åˆ°çš„ç‚¹å‡ºå‘ã€‚ä»£ç ã€‚ å“ˆå¯†é¡¿è·¯é—®é¢˜ å°†æ¬§æ‹‰è·¯è¾¹çš„ç›¸å…³å®šä¹‰æ¢æˆç‚¹å°±æˆäº†å“ˆå¯†é¡¿è·¯ã€‚é€šè¿‡å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹ä¸€æ¬¡ä¸”ä»…ä¸€æ¬¡çš„é€šè·¯ç§°ä¸ºå“ˆå¯†é¡¿é€šè·¯ã€‚é€šè¿‡å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹ä¸€æ¬¡ä¸”ä»…ä¸€æ¬¡çš„å›è·¯ç§°ä¸ºå“ˆå¯†é¡¿å›è·¯ã€‚å…·æœ‰å“ˆå¯†é¡¿å›è·¯çš„å›¾ç§°ä¸ºå“ˆå¯†é¡¿å›¾ã€‚å…·æœ‰å“ˆå¯†é¡¿é€šè·¯è€Œä¸å…·æœ‰å“ˆå¯†é¡¿å›è·¯çš„å›¾ç§°ä¸ºåŠå“ˆå¯†é¡¿å›¾ã€‚ ä¸åŒäºæ¬§æ‹‰è·¯ï¼Œå“ˆå¯†é¡¿è·¯é—®é¢˜ä¸å­˜åœ¨å¤šé¡¹å¼å¤æ‚åº¦ç®—æ³•ã€‚äººä»¬å°è¯•è¿‡è®¸å¤šæ–¹æ³•ï¼ŒåŒ…æ‹¬å°è¯•è½¬åŒ–æˆæ¬§æ‹‰è·¯ï¼Œæ‹†ç‚¹é™åˆ¶åªç»è¿‡ä¸€æ¬¡ç„¶åè½¬åŒ–ä¸ºç½‘ç»œæµç­‰ï¼Œä½†å¾ˆå¯æƒœéƒ½æ˜¯å‡åšæ³•ã€‚ ä¸è¿‡ç½‘ç»œæµçš„è¿™ä¸ªåšæ³•çœŸçš„å¾ˆæœ‰å¯å‘æ€§ï¼Œæœ‰äº›ç‰¹æ®Šæ¡ä»¶çš„å›¾çœŸçš„å¯ä»¥ä½¿ç”¨å®ƒæ¥æ±‚è§£ã€‚ Ore å®šç†ã€‚å¯¹äºä¸€ä¸ªç®€å•æ— å‘å›¾ï¼Œå¦‚æœä»»æ„ä¸¤ä¸ªä¸ç›¸é‚»ç‚¹åº¦æ•°å’Œå¤§äºç­‰äº nnnï¼Œé‚£ä¹ˆè¿™ä¸ªå›¾å­˜åœ¨å“ˆå¯†é¡¿å›è·¯ï¼Œå¤§äºç­‰äº nâˆ’1n-1nâˆ’1 æ—¶å­˜åœ¨å“ˆå¯†é¡¿é€šè·¯ã€‚è¿™æ˜¯ä¸€ä¸ªå……åˆ†ä¸å¿…è¦æ¡ä»¶ã€‚ ä¾‹é¢˜ ä¸€äº›åŸºç¡€é¢˜ã€‚ [CF1765H] Hospital Queue Portal. å¯¹äºæ¯ä¸ªç‚¹è€ƒè™‘ nâˆ¼1n\\sim 1nâˆ¼1 èƒ½å¦ä¸æˆä¸ºå®ƒçš„ç­”æ¡ˆï¼Œä¸ºä»€ä¹ˆè¿™ä¹ˆå¹²ï¼Ÿå› ä¸ºè¿™æ ·å¤„ç†æ¯ä¸ªäººçš„ deadline æ¯”è¾ƒæ–¹ä¾¿ã€‚ä»£ç ã€‚ [CF1152E] Neko and Flashback Portal. å¯¹äºä¸€ä¸ª iiiï¼Œæœ‰ bi=minâ¡{ai,ai+1},ci=maxâ¡{ai,ai+1}b_i=\\min\\{a_i,a_{i+1}\\},c_i=\\max\\{a_i,a_{i+1}\\}biâ€‹=min{aiâ€‹,ai+1â€‹},ciâ€‹=max{aiâ€‹,ai+1â€‹}ï¼Œä¹Ÿå°±æ˜¯è¯´ bi,cib_i,c_ibiâ€‹,ciâ€‹ å„æ˜¯ ai,ai+1a_i,a_{i+1}aiâ€‹,ai+1â€‹ å…¶ä¸­çš„ä¸€ä¸ªï¼ˆå½“ç„¶éœ€è¦ biâ‰¤cib_i\\le c_ibiâ€‹â‰¤ciâ€‹ï¼Œå¦åˆ™æ— è§£ï¼‰ã€‚ æ³¨æ„è¿™ä¸ªè¾“å‡ºæ–¹å¼ï¼Œppp çš„ä½œç”¨æ˜¯å°† aaa æ’åˆ—ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åªéœ€è¦æ±‚å‡º aaa æœ‰å“ªäº›æ•°ç»„æˆå³å¯ã€‚å°†ç»™å®šçš„ ai,ai+1a_i,a_{i+1}aiâ€‹,ai+1â€‹ çš„å…³ç³»çœ‹æˆä¸€æ¡æ— å‘è¾¹ï¼Œèµ°è¿‡è¿™ä¸ªè·¯å¾„å°±ç›¸å½“äºæ»¡è¶³äº†ä¸€ä¸ªé™åˆ¶æ¡ä»¶ã€‚é‚£ä¹ˆåœ¨å›¾ä¸Šæ‰¾å‡ºæ¬§æ‹‰è·¯ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªæ»¡è¶³æ‰€æœ‰çš„é™åˆ¶æ¡ä»¶çš„åºåˆ— aaaï¼ˆéœ€è¦å…ˆç¦»æ•£åŒ–åå†å»ºå›¾ï¼‰ã€‚æ—¶é—´å¤æ‚åº¦ O((n+m)logâ¡m)O((n+m)\\log m)O((n+m)logm)ã€‚ä»£ç ã€‚ [CF36E] Two Paths Portal. ä¸€é“å€¼å¾—ä¸€æƒ³ä¸å€¼å¾—ä¸€å†™çš„æ¬§æ‹‰è·¯ã€‚ åŸå›¾ä¸­æœ€å¤šåªèƒ½æœ‰ä¸¤ä¸ªè¿é€šå—ï¼Œæœ‰ä¸¤ä¸ªæ—¶å°±æ˜¯åˆ†åˆ«æ‰¾æ¬§æ‹‰è·¯ï¼Œä¸‹é¢æ¥çœ‹åªæœ‰ä¸€ä¸ªã€‚ å¦‚æœå®ƒåªæœ‰é›¶ä¸ªæˆ–ä¸¤ä¸ªå¥‡ç‚¹ï¼Œé‚£ä¹ˆæœ‰ä¸€ä¸ªæ¬§æ‹‰è·¯ï¼Œæˆ‘ä»¬æŠŠè¿™æ¡è·¯å¾„åˆ†å¼€ä¸€æ¡è¾¹ä½œä¸ºä¸€éƒ¨åˆ†ï¼Œè¿™æ ·å°±æ˜¯ä¸¤éƒ¨åˆ†äº†ï¼ˆåˆ†ä¸å‡ºæ¥å°±æ— è§£ï¼‰ï¼ å¦‚æœæœ‰å››ä¸ªå¥‡ç‚¹ï¼Œé‚£ä¹ˆæ˜¯ä¸¤ä¸ªï¼ˆåŠï¼‰æ¬§æ‹‰å›¾æ‹¼èµ·æ¥çš„ï¼Œå› æ­¤è€ƒè™‘ç»™ä¸¤ä¸ªå¥‡ç‚¹è¿ä¸€æ¡å‡è¾¹ï¼Œè·‘æ¬§æ‹‰è·¯ï¼Œè¾“å‡ºçš„æ—¶å€™ä»¥è¿™æ¡å‡è¾¹ä¸ºåˆ†ç•Œè¾“å‡ºä¸¤éƒ¨åˆ†ã€‚ ç”±äºè¦è¾“å‡ºè¾¹çš„ç¼–å·ï¼Œå› æ­¤ç”¨é“¾å¼å‰å‘æ˜Ÿæ–¹ä¾¿ä¸€äº›ï¼Œæç‚¹çš„æ—¶å€™éå†æ‰€æœ‰çš„è¾¹å¯»æ‰¾å¯¹åº”çš„æ˜¯å“ªä¸€æ¡ã€‚ä»£ç ã€‚ [CF527E] Data Center Drama Portal. æœ€ç»ˆè¦æ»¡è¶³çš„æ¡ä»¶æ˜¯æ¬§æ‹‰å›¾çš„å……è¦æ¡ä»¶ï¼Œç„¶åå®šå‘ä¸€ä¸‹è¾¹å³å¯ã€‚æ‰€ä»¥å°†æ€»åº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹ä¸¤ä¸¤ç›¸è¿ï¼Œç„¶åä¸æ»¡è¶³åŠ ä¸€ä¸ªè‡ªç¯å³å¯ã€‚ä»£ç ã€‚ * [CF1458D] Flip and Reverse Portal. ä»¤ 000 ä¸º âˆ’1-1âˆ’1ï¼Œ111 ä¸º +1+1+1ï¼Œç„¶åè¿ siâ†’si+1s_i\\rightarrow s_{i+1}siâ€‹â†’si+1â€‹ çš„è¾¹ï¼Œé‚£ä¹ˆé€‰æ‹©çš„å­—ç¬¦ä¸²å°±æ˜¯ä¸€ä¸ªç¯ï¼Œå°†å­—ç¬¦ä¸²å–åç›¸å½“äºå°†ä¸€ä¸ªç¯çš„æ–¹å‘åè¿‡æ¥ã€‚è¿™æ ·ï¼Œä»»ä½•ä¸€æ¡æ¬§æ‹‰å›è·¯éƒ½å¯ä»¥è¢«æ„é€ å‡ºæ¥ï¼Œä¹Ÿå°±æ˜¯è¦æ±‚ç»è¿‡çš„è¾¹çš„å­—å…¸åºæœ€å°çš„æ¬§æ‹‰è·¯å¾„ï¼Œå¦‚æœå›è·¯å­˜åœ¨åˆ™ç›´æ¥è´ªå¿ƒå³å¯ã€‚ä»£ç ã€‚ [ByteDance 2022 Final] Card Shark Portal. æŒ‰ç…§é¡ºåºæ„å»ºï¼Œæœ€åè¦æ±‚çš„æ˜¯è¾¹å­—å…¸åºæœ€å°çš„æ¬§æ‹‰è·¯å¾„ã€‚ä»£ç ã€‚ è¿é€šæ€§é—®é¢˜ å¯¹äºä¸€å¼ æ— å‘å›¾ï¼Œå¦‚æœèƒ½å¤Ÿä» uuu èµ°åˆ° vvvï¼Œé‚£ä¹ˆç§° uuu å’Œ vvv æ˜¯è¿é€šçš„ã€‚ä¸€ä¸ªæå¤§è¿é€šå­å›¾è¢«ç§°ä¸ºè¿é€šåˆ†é‡ã€‚ å¯¹äºä¸€å¼ æœ‰å‘å›¾ï¼Œå°†è¾¹æ›¿æ¢æˆæ— å‘è¾¹å¯ä»¥è¿é€šåˆ™æ˜¯å¼±è¿é€šçš„ï¼Œä¸éœ€è¦æ›¿æ¢åˆ™æ˜¯å¼ºè¿é€šçš„ã€‚åŒæ ·å¯ä»¥å®šä¹‰è¿é€šåˆ†é‡çš„æ¦‚å¿µã€‚ å¤§éƒ¨åˆ†çš„è¿é€šæ€§é—®é¢˜éƒ½ç¦»ä¸å¼€ Tarjan ç®—æ³•ï¼Œå› æ­¤æˆ‘ä»¬å…ˆæ¥å›é¡¾ä¸€ä¸‹å®ƒçš„å·¥ä½œåŸç†ã€‚å®ƒå¯¹æ¯ä¸ªç»“ç‚¹ uuu ç»´æŠ¤äº†ä»¥ä¸‹å€¼ï¼š æ—¶é—´æˆ³ dfnudfn_udfnuâ€‹ï¼› è¿½æº¯å€¼ lowulow_ulowuâ€‹ ä»£è¡¨ uuu çš„å­æ ‘ä¸­èƒ½å¤Ÿå›æº¯åˆ°çš„æœ€æ—©çš„å·²ç»åœ¨æ ˆä¸­çš„ç»“ç‚¹ã€‚ åœ¨ä¸€ä¸ª SCC ä¸­åªæœ‰ä¸€ä¸ªç‚¹æ»¡è¶³ dfnu=lowudfn_u=low_udfnuâ€‹=lowuâ€‹ï¼Œè¯¥ç»“ç‚¹ä¸€å®šæ˜¯åœ¨æ·±åº¦éå†çš„è¿‡ç¨‹ä¸­ï¼Œè¯¥è¿é€šåˆ†é‡ä¸­ç¬¬ä¸€ä¸ªè¢«è®¿é—®è¿‡çš„ç»“ç‚¹ã€‚ æ ¹æ®æ­¤æˆ‘ä»¬å¯ä»¥æ±‚å‡ºæ— å‘å›¾çš„ç‚¹åŒè¾¹åŒï¼Œæœ‰å‘å›¾çš„ SCCã€‚ æ— å‘å›¾çš„åŒè¿é€šæ€§ å¦‚æœå°† Eâ€²E&#x27;Eâ€² ä» EEE ä¸­åˆ å»ï¼ŒGGG ä¾¿ä¸å†è¿é€šï¼Œé‚£ä¹ˆ Eâ€²E&#x27;Eâ€² æ˜¯ GGG çš„ä¸€ä¸ªè¾¹å‰²é›†ï¼Œå¤§å°ä¸º 111 çš„è¾¹å‰²é›†ç§°ä¸ºå‰²è¾¹/æ¡¥ã€‚å‰²è¾¹ä¸€å®šæ˜¯æ ‘è¾¹ï¼Œåˆ¤å®šæ¡ä»¶æ˜¯ dfnu&lt;lowvdfn_u&lt;low_vdfnuâ€‹&lt;lowvâ€‹ã€‚ å¦‚æœ GGG ä¸å­˜åœ¨å¤§å°ä¸º kâˆ’1k-1kâˆ’1 çš„è¾¹å‰²é›†ï¼Œåˆ™ç§° GGG æ˜¯ kâˆ’k-kâˆ’è¾¹è¿é€šçš„ï¼Œkkk æœ€å¤§æ—¶ï¼Œç§° kkk ä¸º GGG çš„è¾¹è¿é€šåº¦ã€‚ å¯¹äºç‚¹ä¹Ÿå¯ä»¥åšåŒæ ·çš„å®šä¹‰ã€‚å‰²ç‚¹çš„åˆ¤å®šæ¡ä»¶æ˜¯ dfnuâ‰¤lowvdfn_u\\le low_vdfnuâ€‹â‰¤lowvâ€‹ï¼Œé™¤äº† Tarjan çš„æ ¹èŠ‚ç‚¹ï¼Œæ ¹èŠ‚ç‚¹éœ€è¦æœ‰ä¸¤ä¸ªç‚¹æ»¡è¶³è¿™ä¸ªæ¡ä»¶ï¼›è€Œæœ‰å¤šå°‘ä¸ªç‚¹æ»¡è¶³è¿™ä¸ªæ¡ä»¶ï¼Œå°±æ˜¯å‰²æ‰è¿™ä¸ªç‚¹ä¹‹åå›¾ä¼šåˆ†æˆå¤šå°‘ä¸ªè¿é€šå—ã€‚ é—¨æ°å®šç†æ¨è®ºï¼š å¯¹äºè¾¹åŒå†…çš„ä»»æ„ä¸¤ç‚¹ u,vu,vu,vï¼Œå­˜åœ¨ç»è¿‡ u,vu,vu,v çš„å›è·¯ã€‚ å¯¹äº â‰¥3\\ge 3â‰¥3 çš„ç‚¹åŒä¸­çš„ä¸¤ç‚¹ x,yx,yx,yï¼ˆå¯ä»¥ç›¸ç­‰ï¼‰ä¸ä¸€æ¡è¾¹ eeeï¼Œå­˜åœ¨ xâ†’eâ†’yx\\rightarrow e \\rightarrow yxâ†’eâ†’y çš„ç®€å•è·¯å¾„ï¼›è¿™å¯ä»¥è¯´æ˜å­˜åœ¨ç»è¿‡ x,yx,yx,y å¿…å®šå­˜åœ¨ç®€å•ç¯ï¼Œä» xxx å¯ä»¥ç»•å›è‡ªå·±ã€‚ ä»™äººæŒ å¦‚æœä¸€ä¸ªå›¾çš„æ‰€æœ‰ç¯éƒ½æ²¡æœ‰ç›¸äº¤çš„è¾¹ï¼Œé‚£ä¹ˆè¿™ä¸ªå›¾è¢«ç§°ä¸ºä»™äººæŒã€‚ ä¸€èˆ¬æˆ‘ä»¬ä½¿ç”¨åœ†æ–¹æ ‘æ¥å¤„ç†ä»™äººæŒï¼Œè¿™ä¸ªâ€œä»£è¡¨ç‚¹â€ç§°ä¸ºâ€œæ–¹ç‚¹â€ï¼Œè€ŒåŸå›¾ä¸­çš„æ‰€æœ‰ç‚¹å¯¹åº”â€œåœ†ç‚¹â€ã€‚ä»£ç å¦‚ä¸‹ï¼š åˆ¶æ¯’å¤§æ­æŠ•æ·äº†ç¥ç§˜çš„æ¯’è¯ã€‚ä»™äººæŒä¸Šå¯ä»¥å¤„ç†çš„é—®é¢˜éå¸¸å¤šï¼Œç”±äºå…¶ä¸æ˜¯å¾ˆå¸¸å‡ºç°ï¼Œåœ¨æ­¤æˆ‘ä»¬åªç ”ç©¶ä»™äººæŒä¸Šä¸¤ç‚¹è·ç¦»è¿™ä¸€ä¸ªé—®é¢˜ã€‚åº”è¯¥ä¼šåœ¨è¿‘æœŸæ›´æ–°ã€‚æŒ‰ç…§è®¡åˆ’æ­¤å¤„åº”è¯¥ä¸ä¼šå†åšæ›´æ–°ï¼Œä½†å¦‚æœæ—¶é—´éå¸¸å……è£•åˆ™ä¼šåšè€ƒè™‘ã€‚ å¹¿ä¹‰åœ†æ–¹æ ‘ å¹¿ä¹‰åœ†æ–¹æ ‘å¯ä»¥é«˜æ•ˆå¤„ç†æ— å‘å›¾åŒè¿é€šçš„ç›¸å…³é—®é¢˜ã€‚å®ƒæ˜¯ v-DCC ç¼©ç‚¹ä¹‹åçš„äº§ç‰©ã€‚æˆ‘ä»¬å»ºå‡º v-DCC çš„â€œä»£è¡¨ç‚¹â€å¹¶å‘ v-DCC å†…éƒ¨æ‰€æœ‰ç‚¹è¿è¾¹ï¼Œè¿™æ ·ä¼šå½¢æˆä¸€ä¸ªèŠèŠ±å›¾ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œå¹¿ä¹‰åœ†æ–¹æ ‘ä¼šå°†éç¯è¾¹ä¹Ÿå»ºä¸€ä¸ªæ–¹ç‚¹ã€‚é‚£ä¹ˆåœ†æ–¹æ ‘å¯¹åº”ä¸€æ£µå”¯ä¸€ä»™äººæŒçš„æ€§è´¨ä¾¿ä¸å†æˆç«‹ã€‚å› æ­¤ä¸æ¨èå¤„ç†ä»™äººæŒæ—¶é‡‡ç”¨å¹¿ä¹‰åœ†æ–¹æ ‘çš„å¤„ç†æ–¹æ³•ã€‚ void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; // æ‰¾åˆ°äº†ä¸€ä¸ªä»¥ x ä¸ºæ ¹çš„ v-DCC int z; ++n; // æ–°å»ºä¸€ä¸ªæ–¹ç‚¹ do addedge(z = st[tot--], n); while (z != y); addedge(x, n); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; å¹¿ä¹‰åœ†æ–¹æ ‘æœ‰å¾ˆç¾å¦™çš„æ€§è´¨ï¼Œé¦–å…ˆæ˜¯ v-DCC çš„å¼•ç†ï¼š å¼•ç†ï¼šå¦‚æœ xxx ä¸ y,zy,zy,z å‡ç‚¹åŒè¿é€šï¼Œä½†æ˜¯ y,zy,zy,z ä¸ç‚¹åŒè¿é€šï¼Œé‚£ä¹ˆ xxx æ˜¯ y,zy,zy,z çš„å¿…ç»ç‚¹ã€‚ ç„¶åæ˜¯å¹¿ä¹‰åœ†æ–¹æ ‘çš„æ€§è´¨ï¼š æ€§è´¨ 1ï¼šåœ†ç‚¹ xxx çš„åº¦æ•°ä¸ºå®ƒæ‰€åœ¨çš„ v-DCC ä¸ªæ•°ã€‚ æ€§è´¨ 2ï¼šåœ†æ–¹æ ‘ä¸Šåªæœ‰åœ†ç‚¹å’Œæ–¹ç‚¹ä¹‹é—´æœ‰è¾¹ã€‚ æ€§è´¨ 3ï¼šåŸå›¾ä¸Šç›´æ¥ç›¸è¿çš„ x,yx,yx,y å±äºä¸€ä¸ª v-DCCï¼Œè€Œä¸”å¦‚æœè¿™ä¸ª v-DCC çš„å¤§å°ä¸º 222ï¼Œé‚£ä¹ˆ (x,y)(x,y)(x,y) æ˜¯å‰²è¾¹ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¹¿ä¹‰åœ†æ–¹æ ‘æ— æ³•å¤„ç†é‡è¾¹çš„æƒ…å†µï¼Œä½¿ç”¨æ­¤æ€§è´¨åˆ¤æ–­å‰²è¾¹æ—¶éœ€è¦çœ‹ä¸€ä¸‹ (x,y)(x,y)(x,y) è¾¹æ˜¯å¦ä¸ºé‡è¾¹ã€‚ ä¸‹é¢ä¸‰ä¸ªæ˜¯ç”¨æ¥åšé¢˜çš„ï¼š æ€§è´¨ 4ï¼šåœ†ç‚¹ xxx æ˜¯å¶å­å½“ä¸”ä»…å½“å®ƒåœ¨åŸå›¾ä¸Šä¸æ˜¯å‰²ç‚¹ã€‚è¯æ˜ï¼šå¦‚æœ xxx æ˜¯å‰²ç‚¹ï¼Œé‚£ä¹ˆ xxx è‡³å°‘å±äºä¸¤ä¸ª v-DCCï¼Œè¿™æ ·å­˜åœ¨ y,zy,zy,z ä¸¤ç‚¹ä¸ xxx éƒ½ç‚¹åŒè¿é€šï¼Œä½†æ˜¯ y,zy,zy,z ä¸ç‚¹åŒè¿é€šï¼Œå› æ­¤ xxx æ˜¯ y,zy,zy,z çš„å¿…ç»ç‚¹ï¼Œè¿™æ ·å®ƒä¸æ˜¯å¶å­ã€‚æ€§è´¨ 5ï¼šå¹¿ä¹‰åœ†æ–¹æ ‘ä¸Šåˆ æ‰åœ†ç‚¹ xxx åå‰©ä½™èŠ‚ç‚¹çš„è”é€šæ€§ä¸åŸå›¾ä¸Šåˆ é™¤ xxx ç›¸ç­‰ã€‚è¯æ˜ï¼šå¦‚æœ xxx æ˜¯å¶å­ï¼Œä¹Ÿå°±æ˜¯å®ƒä¸æ˜¯å‰²ç‚¹ï¼Œåˆ é™¤æ˜¾ç„¶æ²¡æœ‰å½±å“ã€‚å¦‚æœå®ƒæ˜¯åŸå›¾çš„å‰²ç‚¹ï¼Œæ¯”å¦‚è¯´ xxx åœ¨åœ†æ–¹æ ‘ä¸Šè¿æ¥äº† y,zy,zy,zï¼Œé‚£ä¹ˆä¸ y,zy,zy,z æ‰€åœ¨çš„ç‚¹åŒè¿é€šä¹‹é—´ä¸åœ¨è¿é€šï¼Œä¸å…¶å‰²ç‚¹çš„æ€§è´¨æ˜¯ä¸€æ ·çš„ã€‚æ€§è´¨ 6ï¼šx,yx,yx,y ç®€å•è·¯å¾„ä¸Šçš„æ‰€æœ‰åœ†ç‚¹å°±æ˜¯åŸå›¾ä¸­ x,yx,yx,y ä¹‹é—´çš„æ‰€å¿…ç»ç‚¹ã€‚è¿™æ˜¯åœ†æ–¹æ ‘çš„æ ¸å¿ƒæ€§è´¨ã€‚ æœ‰å‘å›¾çš„å¼ºè¿é€šæ€§ ä¸¤ç‚¹äº’ç›¸å¯è¾¾ç§°ä¸ºå¼ºè¿é€šï¼ŒåŒæ ·å¯ä»¥ä½¿ç”¨ Tarjan ç®—æ³•æ±‚è§£ã€‚ void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do ins[y = st[tot--]] = false, c[y] = cnt; while (x != y); &#125; &#125; æ±‚è§£å‡ºæ¥çš„ SCC ç¼–å·ä»å¤§åˆ°å°å°±æ˜¯æ‹“æ‰‘åºçš„é¡ºåºï¼Œå¯ä»¥åœ¨ç¼©ç‚¹åä¸è¿›è¡Œæ‹“æ‰‘æ’åºï¼Œç›´æ¥ DP æ±‚è§£ã€‚ 2-SAT é—®é¢˜ k-SAT é—®é¢˜æ˜¯æŒ‡ä¸€ä¸ªå˜é‡æœ‰ kkk ç§å–å€¼ï¼Œæœ‰ä¸€äº›å½¢å¦‚ xix_ixiâ€‹ ä¸º aaa æˆ– xjx_jxjâ€‹ ä¸º bbb çš„æ¡ä»¶ï¼Œè¦æ±‚ä½ ç»™å‡ºä¸€ç»„åˆæ³•è§£ã€‚ å¯¹äº 2-SAT æˆ‘ä»¬æœ‰é«˜æ•ˆåšæ³•ã€‚æ¯ä¸ªå˜é‡å»ºç«‹ä¸¤ä¸ªç‚¹ä»£è¡¨å…¶çœŸå‡ï¼Œè¿è¾¹ä¹‹åæ±‚å‡º SCCï¼ŒåŒä¸€ SCC å†…çš„å˜é‡å€¼ç›¸ç­‰ã€‚ ä¾‹é¢˜ æˆ‘ä¸çŸ¥é“å•Šï¼ [CF51F] Caterpillar Portal. æ¯›æ¯›è™«ä¸Šä¸èƒ½é•¿å‡ºæ¥ç¯ï¼Œæ‰€ä»¥æŠŠæ¯ä¸€ä¸ª e-DCC ç¼©ç‚¹ï¼Œå›¾ä¼šå˜æˆä¸€ä¸ªæ£®æ—ï¼Œæˆ‘ä»¬éœ€è¦å¤„ç†æ¯ä¸€æ£µæ ‘ï¼Œç„¶åæŠŠè¿™äº›æ ‘åˆå¹¶ï¼Œéœ€è¦æ ‘çš„ä¸ªæ•°å‡å»ä¸€çš„ä»£ä»·ã€‚ ç”±äºç¯å¿…é¡»è¦åˆå¹¶ï¼Œå¦‚æœè¦ç›´æ¥ç»Ÿè®¡æ“ä½œæ¬¡æ•°è¿˜éœ€è¦ç»Ÿè®¡ç¯çš„å¤§å°ï¼Œä¸å¦¨æ¢ä¸€ä¸ªæ€è·¯ï¼Œé»˜è®¤æ‰€æœ‰ç‚¹éƒ½éœ€è¦åˆå¹¶ï¼Œç„¶åå‡å»ä¸éœ€è¦åˆå¹¶çš„ã€‚ ç°åœ¨è€ƒè™‘æœ€åä¸€ä¸ªé—®é¢˜ï¼Œä¸€æ£µæ ‘æ€ä¹ˆå¤„ç†ï¼Ÿç›´è§‰å‘Šè¯‰æˆ‘ä»¬ï¼šè¿™æ¡è·¯å¾„ ppp åº”è¯¥æ˜¯é•¿åº¦ä¸º ddd ç›´å¾„ï¼Œè¿™æ ·æ‰èƒ½è®©è¦åŠ¨çš„ç‚¹æ›´å°‘ã€‚ç›´å¾„å¯ä»¥è®©æˆ‘ä»¬å°‘åˆå¹¶ ddd ä¸ªç‚¹ï¼Œå¶å­ä¸Šçš„ç‚¹ä¹Ÿå¯ä»¥ä¸ç”¨åˆå¹¶ï¼ˆç”»ä¸ªå›¾çœ‹çœ‹ï¼‰ï¼Œä½†æ˜¯ç›´å¾„ä¸¤ç«¯è¿˜æœ‰ä¸¤ä¸ªå¶å­ï¼Œæ‰€ä»¥è¦å‡å»ã€‚ä»£ç ã€‚ [GDCPC2023] Canvas Portal. ç”±äºç¬¬äºŒæ¬¡æŸ“è‰²æ˜¯æ— æ„ä¹‰æ“ä½œï¼Œå› æ­¤è€ƒè™‘é€†æ—¶æ—…äººï¼Œè¿™æ ·å˜æˆäº†åªæœ‰ç¬¬ä¸€æ¬¡ä¼šå½±å“ã€‚ æ‰€æœ‰çš„ x=y=2x=y=2x=y=2 æ“ä½œä¼˜å…ˆæ‰§è¡Œï¼Œæ‰€æœ‰çš„ x=y=1x=y=1x=y=1 æœ€åæ‰§è¡Œï¼Œç„¶åè€ƒè™‘å‰©ä¸‹çš„å¡«åœ¨ä¸­é—´ã€‚æ¯æœ‰ä¸€ä¸ª x+y=3x+y=3x+y=3 æ‰§è¡Œå°±æ„å‘³ç€æœ‰ä¸€ä¸ªæ•°è¢«å®šæ­»ä¸º 111ï¼Œé‚£ä¹ˆ (l,1,r,2)(l,1,r,2)(l,1,r,2) ç›¸å½“äºâ€œç”¨ lll å˜æˆ 111 çš„ä»£ä»·æ¢æ¥ rrr å˜æˆ 222â€ï¼Œè¿™ä¸ªå…³ç³»å¯ä»¥ç”¨æœ‰å‘è¾¹ lâ†’rl\\rightarrow rlâ†’r åˆ»ç”»ï¼Œå‘ç°å›¾ä¸Šçš„ä¸€æ¡é“¾åªæœ‰é“¾é¦–æ˜¯ 111ã€‚ SCC ç¼©ç‚¹ä¹‹ååªæœ‰å…¥åº¦ä¸º 000 çš„ç‚¹æ¶‚ä¸€ä¸ª 111 å³å¯ã€‚ä»£ç ã€‚ [åŒ—äº¬çœé€‰é›†è®­ 2019] å®Œç¾å¡”é˜² Portal. ç”±äºå…‰è·¯æ˜¯å¯é€†çš„ï¼Œå› æ­¤ä¸€ä¸ªè·¯åªèƒ½è¢«ä¸¤ä¸ªé˜²å¾¡å¡”æ‰“åˆ°ã€‚ä¸éš¾å‘ç°è¿™å°±æ˜¯ä¸€ä¸ª 2-SATï¼Œå¤„ç†å‡ºæ‰“å®ƒçš„ç‚®å¡”å³å¯ã€‚ä»£ç ã€‚ [CF1835D] Doctorâ€™s Brown Hypothesis Portal. x,yx,yx,y åŒå‘å¯è¾¾è¯´æ˜å…¶åœ¨åŒä¸€ä¸ª SCC å†…ï¼Œé‚£ä¹ˆ SCC ç¼©ç‚¹ååˆ†åˆ«æ±‚ç­”æ¡ˆã€‚ è®¾ ddd * ã€ŒSWTR-8ã€åœ°åœ°é“é“ Portal. é¦–å…ˆå»ºå‡ºåœ†æ–¹æ ‘ï¼Œå¦‚æœ x,yx,yx,y é—´æœ‰æŸä¸ªæœ‰ 111 è¾¹çš„ç‚¹åŒï¼Œé‚£ä¹ˆå®ƒä»¬ä¸€å®šèƒ½é€šè¿‡è¿™æ¡è·¯å¾„ã€‚ é‚£ä¹ˆå¯¹äºåŸå›¾ä¸Šä¸€æ¡ 000 è¾¹ (u,v)(u,v)(u,v)ï¼Œå®ƒæ°å±äºä¸€ä¸ªç‚¹åŒ SSS çš„æ–¹ç‚¹æ‰“æ ‡è®°ï¼Œç»Ÿè®¡åœ†æ–¹æ ‘ä¸Šä¸ç»è¿‡æ ‡è®°ç‚¹çš„åœ†ç‚¹é—´è·¯å¾„æ•°å³å¯ã€‚è¿™æ ·èƒ½è®¡æ•°åªç»è¿‡ 000 è¾¹çš„æ— åºå¯¹ã€‚ çœ‹åˆ°è¿™é‡Œæ„Ÿè§‰å¯ä»¥å®¹æ–¥äº†ï¼Œä¹Ÿå°±æ˜¯è¯´è¦è®¡æ•°åªæœ‰ 0/1 è·¯å¾„ï¼ŒåŒæ—¶æœ‰ 0 è·¯å¾„å’Œ 1 è·¯å¾„ã€‚ åè€…æ€ä¹ˆåšï¼Ÿå¯ä»¥å‘ç°è¿™æ ·çš„ (x,y)(x,y)(x,y) ç‚¹å¯¹ä¸€å®šåœ¨ä¸€ä¸ªç‚¹åŒå†…ã€‚ç„¶ååœ¨è¿™ä¸ªç‚¹åŒå†…æ°å¥½æ»¡è¶³åªæœ‰è¿™ä¸¤ä¸ªç‚¹å³è¢« 1 è¾¹è¿ï¼Œåˆè¢« 2 è¾¹è¿ã€‚ä»£ç ã€‚ æœ€çŸ­è·¯é—®é¢˜ å¯¹äºæ— æƒå›¾ï¼ˆ01 å¸¦æƒï¼‰ï¼Œå¯ä»¥ä½¿ç”¨ BFS æ±‚è§£æœ€çŸ­è·¯ã€‚ å¯¹äºå¤šæºæœ€çŸ­è·¯ï¼Œå¯ä»¥ä½¿ç”¨ Floyd ç®—æ³•ï¼Œä¹Ÿå°±æ˜¯é€šè¿‡ nnn è½® DP æ¥æ±‚è§£æœ€çŸ­è·¯ã€‚ å¯¹äºå•æºæœ€çŸ­è·¯ï¼Œå¯ä»¥ä½¿ç”¨ Dijkstra å’Œ SPFAã€‚Dijkstra åŸºäºè´ªå¿ƒçš„æ€æƒ³ï¼Œæ¯æ¬¡å¯»æ‰¾å½“å‰æœ€çŸ­çš„è·¯æ¥èµ°ï¼Œæ­£ç¡®æ€§åŸºäºè¾¹æƒéè´Ÿï¼›SPFA åˆ™é€šè¿‡ O(nm)O(nm)O(nm) çš„è¿­ä»£æ¥æ›´æ–°æœ€çŸ­è·¯ï¼Œè¿›è€Œå¯ä»¥åˆ¤æ–­è´Ÿç¯çš„å­˜åœ¨æ€§ã€‚ Johnson é€šè¿‡å°†è¾¹æ”¹é€ ä¸º (u,v,w+duâˆ’dv)(u,v,w+d_u-d_v)(u,v,w+duâ€‹âˆ’dvâ€‹) æ¥å®ç°ï¼Œè¾¹æƒæ˜¯ä¸‰è§’å½¢ä¸ç­‰å¼æ¥æ»¡è¶³ â‰¥0\\ge 0â‰¥0ï¼Œå»ºç«‹è¶…çº§æºç‚¹è·‘ SPFA å³å¯ã€‚ä»£ç ã€‚ å¦‚æœæˆ‘ä»¬è¦æ±‚çš„æ˜¯æœ€çŸ­ç®€å•è·¯å¾„ï¼ˆæœ‰è´Ÿç¯ï¼‰ï¼Œé‚£ä¹ˆå®ƒæ˜¯ä¸€ä¸ª NPC é—®é¢˜ã€‚ å·®åˆ†çº¦æŸ æ ¹æ®ä¸‰è§’å½¢ä¸ç­‰å¼è¿›è¡Œè¿è¾¹ï¼Œç„¶åç”¨ SPFA åˆ¤æ–­è´Ÿç¯ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœä½¿ç”¨ SPFA æ±‚æœ€çŸ­è·¯ï¼Œé‚£ä¹ˆå¾—åˆ°çš„æ˜¯å­—å…¸åºæœ€å¤§çš„è§£ã€‚å¯¹äºå­—å…¸åºæœ€å°çš„è§£ï¼Œåªéœ€è¦å°†çº¦æŸæ¡ä»¶ç»Ÿç»Ÿå˜ä¸º xiâˆ’xjâ‰¥yx_i-x_j\\ge yxiâ€‹âˆ’xjâ€‹â‰¥yï¼Œç„¶åè·‘æœ€é•¿è·¯ï¼Œæœ‰æ­£ç¯æ—¶æ— è§£ï¼ˆå°±æ˜¯è¾¹çš„æ–¹å‘å’Œæƒå€¼éƒ½å–åï¼‰ã€‚ [çœé€‰è”è€ƒ 2021 A å·] çŸ©é˜µæ¸¸æˆã€‚ç­”æ¡ˆçš„æ„é€ æ˜¯å®¹æ˜“çš„ï¼Œç„¶åéœ€è¦è°ƒæ•´è¿™ä¸ªç­”æ¡ˆï¼Œè®©æ¯ä¸€è¡Œå’Œåˆ—ä¾æ¬¡ +1,âˆ’1+1,-1+1,âˆ’1ï¼Œç„¶åé”™å¼€ï¼Œç›´æ¥å·®åˆ†çº¦æŸå³å¯ã€‚ä»£ç ã€‚ æ–¯å¦çº³æ ‘ å¦‚æœç»™å®š nnn ä¸ªç‚¹ï¼Œè¯•æ±‚è¿æ¥æ­¤ nnn ä¸ªç‚¹ï¼Œæ€»é•¿æœ€çŸ­çš„ç›´çº¿æ®µè¿æ¥ç³»ç»Ÿï¼Œå¹¶ä¸”å¹¶ä¸”ä»»æ„ä¸¤ç‚¹éƒ½å¯ä»¥é€šè¿‡ç³»ç»Ÿä¸­çš„ç›´çº¿æ®µç»„æˆçš„æŠ˜çº¿è¿æ¥èµ·æ¥ï¼Œæ­¤é—®é¢˜è¢«ç§°ä¸ºæ–¯å¦çº³æ ‘é—®é¢˜ã€‚é—æ†¾çš„æ˜¯ï¼Œè¿™æ˜¯ä¸€ä¸ª NPH é—®é¢˜ã€‚ æœ€å°æ–¯å¦çº³æ ‘ã€‚ç»™å®šä¸€ä¸ª nnn ä¸ªç‚¹ mmm æ¡è¾¹æ— å‘å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œå†ç»™å®šåŒ…å« kkk ä¸ªèŠ‚ç‚¹çš„ç‚¹é›† SSSï¼Œé€‰å‡º GGG çš„è¿é€šå­å›¾ Gâ€²=(Vâ€²,Eâ€²)G&#x27;=(V&#x27;,E&#x27;)Gâ€²=(Vâ€²,Eâ€²)ï¼Œè¦æ±‚ï¼šSâŠ†Vâ€²S \\subseteq V&#x27;SâŠ†Vâ€²ï¼ŒEâ€²E&#x27;Eâ€² ä¸­æ‰€æœ‰è¾¹çš„æƒå€¼å’Œæœ€å°ã€‚ä½ éœ€è¦æ±‚å‡ºè¿™ä¸ªæœ€å°æƒå€¼å’Œï¼Œnâ‰¤100,mâ‰¤500,kâ‰¤10n\\le 100,m\\le 500,k\\le 10nâ‰¤100,mâ‰¤500,kâ‰¤10ã€‚ å¹¶ä¸æ˜¯ç›´æ¥å°† SSS è¿æ¥èµ·æ¥å°±æ˜¯æœ€å°çš„ï¼Œå¯èƒ½éœ€è¦å€ŸåŠ©å‰©ä¸‹çš„ nâˆ’kn-knâˆ’k ä¸ªç‚¹ã€‚è¿™ç§é—®é¢˜å¯ä»¥ä½¿ç”¨çŠ¶å‹ DP æ¥è§£å†³ï¼š è®¾ f(i,S)f(i,S)f(i,S) è¡¨ç¤ºä»¥ iii ä¸ºæ ¹çš„ä¸€æ£µæ ‘ï¼ŒåŒ…å«é›†åˆ SSS ä¸­æ‰€æœ‰ç‚¹çš„æœ€å°è¾¹æƒå€¼å’Œã€‚æœ‰è½¬ç§»ï¼šf(i,S)â†minâ¡{f(i,T)+f(i,Sâˆ’T)},f(i,S)â†minâ¡{f(j,S)+w(i,j)}f(i,S)\\leftarrow\\min\\{f(i,T)+f(i,S-T)\\},f(i,S)\\leftarrow\\min\\{f(j,S)+w(i,j)\\}f(i,S)â†min{f(i,T)+f(i,Sâˆ’T)},f(i,S)â†min{f(j,S)+w(i,j)}ã€‚å‰è€…å¯ä»¥ä½¿ç”¨å­é›† DP å®ç°ï¼Œåè€…å¯ä»¥è·‘ä¸€ä¸ªæœ€çŸ­è·¯ï¼ˆç”±äºå›¾å¾ˆéš¾ç‰¹æ®Šæ„é€ è€Œä¸”è§„æ¨¡å¾ˆå°ï¼Œæ‰€ä»¥å®é™…ä¸Šæ›´å»ºè®® SPFAï¼‰ã€‚ä»£ç ã€‚ Peach Blossom Springï¼Œæ³¨æ„å¹¶ä¸è¦æ±‚å®Œå…¨è”é€šï¼Œæœ€åå­é›†å’Œå¹¶ä¸€ä¸‹å³å¯ã€‚ å¹³é¢å›¾æœ€å°å‰² å¦‚æœå›¾ GGG èƒ½ç”»åœ¨å¹³é¢ SSS ä¸Šï¼Œå³é™¤é¡¶ç‚¹å¤„å¤–æ— è¾¹ç›¸äº¤ï¼Œåˆ™ç§° GGG å¯å¹³é¢åµŒå…¥ SSSï¼ŒGGG ä¸ºå¯å¹³é¢å›¾æˆ–å¹³é¢å›¾ã€‚ç”»å‡ºçš„æ²¡æœ‰è¾¹ç›¸äº¤çš„å›¾ç§°ä¸º GGG çš„å¹³é¢è¡¨ç¤ºæˆ–å¹³é¢åµŒå…¥ã€‚ å¹³é¢å›¾å¯ä»¥è½¬ä¸ºå¯¹å¶å›¾ï¼Œå¯¹å¶å›¾çš„æœ€çŸ­è·¯ç­‰äºåŸå¹³é¢å›¾çš„æœ€å°å‰²ã€‚ç»™ GGG çš„æ¯ä¸ªé¢æä¸€ä¸ªç‚¹ï¼Œä¸¤ä¸ªé¢çš„å…¬å…±è¾¹å¯ä»¥ç¡®å®šä¸€æ¡ä¸å…¶æ–¹å‘å‚ç›´çš„è¾¹ã€‚ç»™æºç‚¹å’Œæ±‡ç‚¹è¿çº¿å¯ä»¥å°†åŸå›¾åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼Œè·‘æœ€çŸ­è·¯å³å¯ã€‚ æ³¨æ„å·¦ä¾§å’Œä¸‹ä¾§ï¼Œä¸Šä¾§å’Œå³ä¾§åˆ†åˆ«æ˜¯åŒä¸€ä¸ªç‚¹ï¼Œä»å³ä¸Šåˆ°å·¦ä¸‹çš„æœ€çŸ­è·¯å³ä¸ºå·¦ä¸Šåˆ°å³ä¸‹çš„æœ€å°å‰²ã€‚æ¨¡æ¿ï¼Œä»£ç ã€‚ åŒä½™æœ€çŸ­è·¯ æ¨¡æ¿ã€‚è¿™æ˜¯ä¸€ä¸ªæœ€çŸ­è·¯çš„å˜å¼é—®é¢˜ã€‚å¯ä»¥ç”¨äºæ±‚è§£åœ¨æŸä¸ªèŒƒå›´å†…æœ‰å¤šå°‘é‡é‡å¯ä»¥ç”±è‹¥å¹²ç‰©å“çš„å®Œå…¨èƒŒåŒ…å‡‘å‡ºï¼Œå°±æ˜¯å¤šå°‘æ•°å€¼å¯ä»¥ç”±ä¸€äº›ç»™å®šçš„æ•° bib_ibiâ€‹ ç”± âˆ‘aibi(aiâ‰¥0)\\sum a_i b_i(a_i\\ge 0)âˆ‘aiâ€‹biâ€‹(aiâ€‹â‰¥0) å¾—åˆ°ã€‚ æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå¦‚æœ xxx å¯ä»¥è¢«è¡¨ç¤ºå‡ºï¼Œé‚£ä¹ˆ x+kai(k&gt;0)x+ka_i(k&gt;0)x+kaiâ€‹(k&gt;0) å°±å¯ä»¥è¢«è¡¨ç¤ºå‡ºã€‚å› æ­¤æˆ‘ä»¬æ‰¾ä¸€ä¸ªæœ€å°çš„ a1a_1a1â€‹ï¼Œç„¶åè¿ jâ†’(j+ai) mod a1j\\rightarrow (j+a_i)\\bmod a_1jâ†’(j+aiâ€‹)moda1â€‹ çš„é•¿åº¦ä¸º aia_iaiâ€‹ çš„è¾¹ï¼Œç„¶åæˆ‘ä»¬ä» 000 å¼€å§‹è·‘æœ€çŸ­è·¯ã€‚ç”±äºè¿™é‡Œå›¾çš„å½¢æ€ä¸å¤ªèƒ½ç‰¹æ®Šæ„é€ ï¼Œå› æ­¤ä½¿ç”¨ SPFA å¾€å¾€ä¼šè·‘çš„æ›´å¿«ã€‚æœ€åæ±‚å‡ºçš„ fif_ifiâ€‹ ä»£è¡¨æœ€å°çš„èƒ½è¢«å‡‘å‡ºçš„æ•°ï¼Œæ»¡è¶³ fi mod a1=if_i\\bmod a_1 =ifiâ€‹moda1â€‹=iã€‚ä»£ç ã€‚ ç­”æ¡ˆçš„æ±‚è§£ååˆ†å®¹æ˜“ã€‚[0,r][0,r][0,r] çš„ç­”æ¡ˆæ•°é‡ä¸ºï¼š âˆ‘i=0a1âˆ’1maxâ¡{0,âŒŠrâˆ’fia1âŒ‹+1}\\sum_{i=0}^{a_1-1}\\max\\left\\{0,\\left\\lfloor\\frac{r-f_i}{a_1}\\right\\rfloor+1\\right\\} i=0âˆ‘a1â€‹âˆ’1â€‹max{0,âŒŠa1â€‹râˆ’fiâ€‹â€‹âŒ‹+1} ä½†ä¸ºä»€ä¹ˆè¦ä½¿ç”¨æœ€çŸ­è·¯å‘¢ï¼Ÿå®é™…ä¸Šè¿™ä¸œè¥¿æ˜¯ä½“ç§¯æ¨¡ mmm æ„ä¹‰ä¸‹çš„å®Œå…¨èƒŒåŒ…ï¼Œå¦‚æœé‡å¤ç»è¿‡ä¸€ä¸ªç‚¹ï¼Œé‚£ä¹ˆå¯ä»¥é€‰æ‹© mgcdâ¡(vi,m)âˆ’1\\frac{m}{\\gcd(v_i,m)}-1gcd(viâ€‹,m)mâ€‹âˆ’1 ä¸ªè¿™ç±»ç‰©å“ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¼šåœ¨å¤§å°ä¸º mmm çš„ç¯ä¸Šå½¢æˆ gcdâ¡(vi,m)\\gcd(v_i,m)gcd(viâ€‹,m) ä¸ªå­ç¯ã€‚ é‚£ä¹ˆåœ¨æ¯ä¸ªå­ç¯ä¸Šè½¬ä¸¤åœˆå³å¯ç»Ÿè®¡åˆ°æ‰€æœ‰è½¬ç§»ï¼Œæ—¶é—´å¤æ‚åº¦ O(nm)O(nm)O(nm)ã€‚ä»£ç ã€‚ [THUPC 2023] èƒŒåŒ…ã€‚å®Œå…¨èƒŒåŒ…ï¼Œä½†æ˜¯ Vâ‰¥1011V\\ge 10^{11}Vâ‰¥1011ã€‚ å¦‚æœæˆ‘ä»¬å°†å¯†åº¦æœ€å¤§çš„ç‰©å“é€‰åšåŸºå‡†ç‰©å“ï¼Œé‚£ä¹ˆå…¶å®ƒç‰©å“çš„é€‰æ‹©å¯ä»¥æ›¿æ¢ä¸ºè‹¥å¹²åŸºå‡†ç‰©å“ï¼Œè¿™æ ·å¯ä»¥æœ€å¤§åŒ–è´¡çŒ®ã€‚è®¾åŸºå‡†ç‰©å“ä½“ç§¯ä¸º wwwï¼Œè´¡çŒ®ä¸º mmmã€‚ è®¾ fif_ifiâ€‹ ä»£è¡¨æœ€å¤§çš„è´¡çŒ®ï¼Œæ»¡è¶³ V mod m=iV\\bmod m=iVmodm=iã€‚æœ€ç»ˆæƒå€¼ä¸º fi+Vâˆ’Vâ€²mwf_i+\\frac{V-V&#x27;}{m}wfiâ€‹+mVâˆ’Vâ€²â€‹wï¼Œå› æ­¤è¦æœ€å¤§åŒ– Vâˆ’Vâ€²mV-\\frac{V&#x27;}{m}Vâˆ’mVâ€²â€‹ï¼Œå› æ­¤è´¡çŒ®åº”è¯¥æ˜¯ fp+ciâˆ’p+vimwf_p+c_i-\\frac{p+v_i}{m}wfpâ€‹+ciâ€‹âˆ’mp+viâ€‹â€‹wã€‚ å¯ä»¥å‘ç°æ¯ä¸ª fif_ifiâ€‹ å¯¹åº”çš„ç‰©å“ä¸ªæ•°ä¸€å®šæ˜¯ä¸è¶…è¿‡ vvv çš„ï¼Œå› æ­¤è¿™ä¸€éƒ¨åˆ†æ€»å®¹ç§¯ä¸è¶…è¿‡ v2â‰¤Vv^2\\le Vv2â‰¤Vï¼Œä¸å­˜åœ¨è¯¯åˆ¤æˆæœ‰è§£çš„æƒ…å†µã€‚ä»£ç ã€‚ åˆ è¾¹æœ€çŸ­è·¯ æ¨¡æ¿ã€‚ç»™å®šä¸€å¼ å¸¦æƒæ— å‘å›¾ï¼Œæ¯ä¸ªè¯¢é—®ç‹¬ç«‹ï¼Œå°†ä¸€æ¡è¾¹çš„è¾¹æƒæ”¹å˜ï¼Œè¯¢é—®å½“å‰ 1âˆ¼n1\\sim n1âˆ¼n çš„æœ€çŸ­è·¯ã€‚ æ±‚å‡º 1,n1,n1,n çš„æœ€çŸ­è·¯æ ‘ T1,TnT_1,T_nT1â€‹,Tnâ€‹ã€‚å¦‚æœæ”¹çš„è¾¹ä¸æ˜¯æœ€çŸ­è·¯ä¸Šçš„è¾¹çš„ç­”æ¡ˆæ˜¯å¥½ç®—çš„ï¼Œå¦åˆ™ï¼Œæˆ‘ä»¬è¦ç®—å‡ºå¼ºåˆ¶ä¸ç»è¿‡ä¸€æ¡è¾¹çš„æ–°çš„æœ€çŸ­è·¯ã€‚ æˆ‘ä»¬éœ€è¦ä¿è¯ T1,TnT_1,T_nT1â€‹,Tnâ€‹ ä¸Š 1âˆ¼n1\\sim n1âˆ¼n çš„æœ€çŸ­è·¯æ˜¯ç›¸åŒçš„ä¸€æ¡ï¼Œå¦åˆ™æ— æ³•è®¡ç®—ã€‚ æ±‚å‡º p1ip1_ip1iâ€‹ ä»£è¡¨ T1(1â†’i)T_1(1\\rightarrow i)T1â€‹(1â†’i) ä¸æ›´æ–°è·¯å¾„çš„æœ€åä¸€ä¸ªäº¤ç‚¹ï¼ˆåœ¨æœ€çŸ­è·¯æ ‘ä¸Šè·³ï¼Œç¬¬ä¸€ä¸ªåˆ°çš„æœ€çŸ­è·¯ä¸Šçš„ç‚¹ï¼Œå°±æ˜¯ iii ä¸ nnn çš„ LCAï¼‰ï¼Œpnipn_ipniâ€‹ åŒç†ã€‚ è¿™æ ·ç»´æŠ¤å…ˆä¿®æ”¹å†å•ç‚¹æŸ¥è¯¢çš„åŒºé—´ ckmin å³å¯ã€‚ä»£ç ã€‚ æ˜¾ç„¶ï¼Œè¿™ç§åšæ³•å¹¶ä¸èƒ½åœ¨æœ‰å‘å›¾ä¸Šæˆç«‹ï¼Œå› ä¸ºä¸åœ¨æœ€çŸ­è·¯ä¸Šçš„è¾¹å¯èƒ½ä¸æ­¢ä¸€æ¡ã€‚ä½†æ˜¯ï¼Œèµ°çš„è·¯å¾„ä¾ç„¶æ»¡è¶³ä¸­é—´åªæœ‰ä¸€æ®µä¸åœ¨æœ€çŸ­è·¯ä¸Šçš„è·¯å¾„ã€‚ å¯¹äºéšæœºæœ‰å‘å›¾å¯ä»¥é‡‡ç”¨è¿™æ ·ä¸€ç§æ–¹å¼å¤„ç†ï¼šæŒ‰ç…§é¡ºåºéå†åŸæœ€çŸ­è·¯ä¸Šçš„è¾¹ï¼Œç„¶ååœ¨èµ·ç‚¹ä¸Šè·‘ SPFAï¼Œå¼€ä¸ªå †ç»´æŠ¤ä»å“ªé‡Œå¼€å§‹å‰©ä¸‹çš„éƒ½èµ°æœ€çŸ­è·¯ã€‚ k çŸ­è·¯ å…ˆå»ºå‡ºä¸€æ£µä»¥ ttt ä¸ºæ ¹çš„æœ€çŸ­è·¯æ ‘ TTTï¼Œxxx åˆ° ttt çš„æœ€çŸ­è·¯å¾„ä¸º dxd_xdxâ€‹ã€‚è®¾ sâ†’ts\\rightarrow tsâ†’t çš„è·¯å¾„ä¸Šä¸åœ¨ TTT ä¸­çš„å½“å‰é€‰æ‹©çš„è·¯å¾„çš„è¾¹é›†ä¸º Pâ€²P&#x27;Pâ€²ï¼Œsâ†’ts\\rightarrow tsâ†’t ä¸Šçš„æ‰€æœ‰è¾¹ä¸º PPPï¼Œé‚£ä¹ˆæ»¡è¶³ï¼š å°†ä¸€æ¡è¾¹ eee çš„ä»£ä»·å®šä¹‰ä¸º Î”e=wâˆ’(duâˆ’dv)\\Delta e = w-(d_u-d_v)Î”e=wâˆ’(duâ€‹âˆ’dvâ€‹)ï¼Œé‚£ä¹ˆ LPâ€²=ds+âˆ‘eâˆˆPâ€²Î”eL_{P&#x27;} = d_s + \\sum_{e\\in P&#x27;} \\Delta eLPâ€²â€‹=dsâ€‹+âˆ‘eâˆˆPâ€²â€‹Î”eï¼› å°† PPP å’Œ Pâ€²P&#x27;Pâ€² ä¸­æ‰€æœ‰è¾¹æŒ‰ç…§ sâ†’ts\\rightarrow tsâ†’t ç»è¿‡çš„é¡ºåºä¾æ¬¡æ’åˆ—ï¼Œé‚£ä¹ˆå¯¹äº Pâ€²P&#x27;Pâ€² ä¸­ç›¸é‚»çš„è¾¹ e1,e2e_1,e_2e1â€‹,e2â€‹ï¼Œé‚£ä¹ˆ ve1=ue2v_{e_1}=u_{e_2}ve1â€‹â€‹=ue2â€‹â€‹ æˆ–è€… ue2u_{e_2}ue2â€‹â€‹ æ˜¯ ve1v_{e_1}ve1â€‹â€‹ åœ¨ TTT ä¸Šçš„ç¥–å…ˆã€‚ å¯¹äºæ¯ä¸€ä¸ªåˆæ³•çš„ Pâ€²P&#x27;Pâ€²ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€ä¸ª PPP ä¸ä¹‹å¯¹åº”ã€‚å› ä¸ºå¯ä»¥æ ¹æ® Pâ€²P&#x27;Pâ€² è¿˜åŸåœ¨ TTT ä¸Šé€‰æ‹©äº†ä»€ä¹ˆã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬ç°åœ¨è¦æ±‚æ»¡è¶³æ€§è´¨ 222 çš„ç¬¬ kkk å° LpL_pLpâ€‹ã€‚ æˆ‘ä»¬è®°å½•æœ€åä¸€æ¡è¾¹å’Œå½“å‰ LpL_pLpâ€‹ çš„å€¼å³å¯è¡¨ç¤º Pâ€²P&#x27;Pâ€²ã€‚åˆå§‹æˆ‘ä»¬å°† 111 æ‰€æœ‰åœ¨ TTT ä¸Šçš„ç¥–å…ˆçš„æ‰€æœ‰çš„è¾¹ä¸­ Î”e\\Delta eÎ”e æœ€å°çš„ä¸€æ¡è¾¹åŠ å…¥å°æ ¹å †ï¼Œç„¶åæ‰©å±•æ—¶åªæœ‰ä¸¤ç§é€‰æ‹©ï¼š åˆ æ‰ Pâ€²P&#x27;Pâ€² ç»“å°¾çš„é‚£æ¡è¾¹ï¼Œæ¢æˆç¬¬äºŒå¤§çš„è¾¹ï¼› ä» Pâ€²P&#x27;Pâ€² çš„ç»“å°¾å¼€å§‹åˆ° TTT çš„è·¯å¾„ä¸Šï¼Œé€‰æ‹©æœ€å°çš„è¾¹åŠ å…¥ã€‚ å·²çŸ¥æˆ‘ä»¬å¼€å§‹çš„æè¿°è·¯å¾„çš„æ–¹å¼æ˜¯ä¸æ¼çš„ï¼Œè€Œä¸”æˆ‘ä»¬ç›¸å½“äºæšä¸¾äº†æ‰€æœ‰çš„å¾…æ›¿æ¢è¾¹æ˜¯å¦è¿›è¡Œæ›¿æ¢ï¼Œå› æ­¤è¿™ä¹ˆåšæ˜¯æ­£ç¡®çš„ã€‚ æ—¶é—´å¤æ‚åº¦ O(mlogâ¡m+klogâ¡k)O(m\\log m+k\\log k)O(mlogm+klogk)ï¼Œæ¨¡æ¿ï¼Œä»£ç ã€‚ kkk çŸ­è·¯é—®é¢˜èƒ½å¤Ÿé«˜æ•ˆè§£å†³ï¼Œå¾—ç›Šäºæˆ‘ä»¬åªéœ€è¦ä¸€ä¸ªç‚¹å³å¯æè¿°èƒ½å¤Ÿè¢«æ›¿æ¢çš„è¾¹ï¼Œå¦‚æœè¦è¾“å‡º kkk çŸ­è·¯çš„æ–¹æ¡ˆï¼Œé‚£ä¹ˆå°±åªèƒ½åšåˆ° O(k(n+m)logâ¡m+klogâ¡k)O(k(n+m)\\log m+k\\log k)O(k(n+m)logm+klogk) äº†ã€‚ ä¾‹é¢˜ ä»åŸºç¡€é¢˜ç›®åˆ°ä¸€äº›å¤æ‚çš„å˜åŒ–ã€‚ [THUSCH2017] å·§å…‹åŠ› Portal. å¦‚æœé¢œè‰²æ•°æ¯”è¾ƒå°‘çš„è¯ç›´æ¥ç”¨æ–¯å¦çº³æ ‘åšï¼Œä½†æ˜¯é¢œè‰²æ•°å¾ˆå¤šï¼Œé’¦å®šçš„å¯èƒ½ä¹Ÿå¾ˆå¤šã€‚ kkk å¾ˆå°ï¼Œå› æ­¤è€ƒè™‘å°†æ‰€æœ‰é¢œè‰²éšæœºæ˜ å°„åˆ° [0,k)[0,k)[0,k)ï¼Œç„¶åæ±‚æœ€å°æ–¯å¦çº³æ ‘å³å¯æ±‚å‡ºæœ€å°çš„å·§å…‹åŠ›ä¸ªæ•° wwwã€‚è¿™ kkk ä¸ªç‚¹è¢«åˆ†é…åˆ°ä¸åŒçš„é¢œè‰²æ—¶ç­”æ¡ˆåˆæ³•ï¼Œæ­£ç¡®æ¦‚ç‡æ˜¯ k!/kkk!/k^kk!/kkã€‚éšæœºåŒ–åš 200200200 æ¬¡å³å¯ã€‚ ç„¶åäºŒåˆ†å‡ºä¸­ä½æ•°ï¼Œå°†å°äºç­‰äºäºŒåˆ†å€¼çš„æƒå€¼éƒ½è®¾ä¸º infâˆ’1inf-1infâˆ’1ï¼Œå¤§äºçš„éƒ½è®¾ä¸º inf+1inf+1inf+1ï¼Œç„¶åæœ€å°æ–¯å¦çº³æ ‘è¦ â‰¤wÃ—inf\\le w\\times infâ‰¤wÃ—infï¼ˆinfinfinf è®¾ç½®ä¸ºä¸€ä¸ªä¸ä¼šå½±å“æ–¯å¦çº³æ ‘é€‰æ‹©çš„å·§å…‹åŠ›æ•°çš„ä¸€ä¸ªæ•°å³å¯ï¼‰ã€‚ä»£ç ã€‚ ç”Ÿæˆæ ‘é—®é¢˜ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•æ±‚è§£ï¼š Kruskalï¼šåŸºäºè´ªå¿ƒçš„æ€æƒ³ï¼ŒæŒ‰ç…§è¾¹æƒä»å°åˆ°å¤§æ’åºï¼› Primï¼šåŸºäºè´ªå¿ƒçš„æ€æƒ³ï¼Œæ¯æ¬¡æ‰¾åˆ°ä¸åœ¨æœ€å°ç”Ÿæˆæ ‘é›†åˆï¼Œç»´æŠ¤ did_idiâ€‹ ä»£è¡¨ä¸å½“å‰æ ‘ç§æƒå€¼æœ€å°è¾¹çš„æƒå€¼ã€‚ å¯¹äºæ¬¡å°ç”Ÿæˆæ ‘ï¼Œå…¶ä¸ä¸æœ€å°ç”Ÿæˆæ ‘æœ€å¤šä»…æœ‰ä¸€æ¡è¾¹çš„å·®è·ï¼Œæšä¸¾ä¸æ˜¯ MST ä¸Šçš„è¾¹ï¼Œè€ƒè™‘åˆ å»æ ‘ä¸Šçš„ä¸€æ¡æœ€å°è¾¹ï¼Œç„¶åæ ‘ä¸Šå€å¢æ‰¾æœ€å¤§å€¼å³å¯ã€‚ DFS æˆ–è€… BFS ä¹Ÿèƒ½æ„å»ºä¸€æ£µç”Ÿæˆæ ‘ã€‚å¯¹äºæœ‰äº›é¢˜ï¼Œæˆ‘ä»¬ä¼šæ ¹æ®æ¡ä»¶æ„å»ºä¸€æ£µç”Ÿæˆæ ‘ï¼ˆæˆ–è€…æ˜¯éšä¾¿ä¸€æ£µç”Ÿæˆæ ‘ï¼‰ï¼Œç„¶åå†å»è¿›è¡Œæ“ä½œã€‚ ä¸€äº›æ€§è´¨ åœ¨ä¸€å¼ å›¾çš„æ‰€æœ‰ MST ä¸Šï¼Œä¸€ä¸ªæƒå€¼çš„è¾¹çš„æ•°é‡æ˜¯ä¸€å®šçš„ã€‚ [CF891C] Envy.ç»™å®šä¸€ä¸ªæ— å‘å›¾ï¼Œæ¯æ¬¡è¯¢é—®ç»™å®šä¸€äº›è¾¹çš„ç¼–å·ï¼Œé—®è¿™äº›è¾¹æ˜¯å¦èƒ½åŒæ—¶å‡ºç°åœ¨ä¸€æ£µ MST ä¸Šã€‚ å¦‚æœè¿™ä¸ªè¯¢é—®çš„æ¯ä¸€æ¡è¾¹åˆ†åˆ«éƒ½èƒ½å‡ºç°åœ¨ MST ä¸Šï¼Œé‚£ä¹ˆè¿™ä¸ªè¯¢é—®å°±æ˜¯åˆæ³•çš„ã€‚ ç¦»çº¿ï¼ŒæŒ‰ç…§è¾¹æƒè¿›è¡Œæ’åºã€‚å¯¹äºä¸€æ¡æƒå€¼ä¸º www çš„è¾¹ï¼Œå®ƒèƒ½è¢«è®¡å…¥ MSTï¼Œå½“ä¸”ä»…å½“æ‰€æœ‰ &lt;w&lt;w&lt;w çš„è¾¹éƒ½è¢«è®¡å…¥ MST ååŠ å…¥å®ƒä¸ä¼šé€ å‡ºä¸€ä¸ªç¯æ¥ã€‚ä»£ç ã€‚ Kruskal é‡æ„æ ‘ åˆå¹¶ä¸¤ä¸ªç‚¹é›†æ—¶ï¼Œæˆ‘ä»¬æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œæƒå€¼ä¸ºè¾¹æƒï¼Œå¾—åˆ°çš„äºŒå‰æ ‘æ˜¯åŸºäºè¾¹æƒçš„ Kruskal é‡æ„æ ‘ã€‚ æŒ‰ç…§ç‚¹æƒæ’åºï¼Œéå†æ¯ä¸ªèŠ‚ç‚¹ uuu å’Œå…¶èƒ½åˆ°è¾¾çš„èŠ‚ç‚¹ vvvï¼Œè‹¥ vvv å·²ç»éå†ï¼Œé‚£ä¹ˆ wuâ‰¥wvw_u\\ge w_vwuâ€‹â‰¥wvâ€‹ï¼Œå°† vvv çš„çˆ¶äº²è®¾ç½®ä¸º uuuï¼ˆå¦‚æœä¸åœ¨ä¸€ä¸ªé›†åˆå†…ï¼‰ï¼Œæ‰€å½¢æˆçš„å¤šå‰æ ‘æ˜¯åŸºäºè¾¹æƒçš„ Kruskal é‡æ„æ ‘ã€‚ é‡æ„æ ‘æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š çˆ¶äº²èŠ‚ç‚¹çš„ç‚¹æƒå¤§äºç­‰äºå„¿å­çš„ç‚¹æƒã€‚ åŸå›¾ä¸¤ç‚¹è·¯å¾„çš„ç“¶é¢ˆè·¯ç­‰äºæ ‘ä¸Šçš„ç“¶é¢ˆè·¯ï¼Œå³ LCA å¤„çš„æƒå€¼ã€‚ Boruvka ç®—æ³• å¯¹äºä¸€ä¸ªç‚¹ iiiï¼Œå…¶æœ€å°æƒå€¼çš„ä¸´è¾¹å¿…å®šåœ¨ MST ä¸Šã€‚é‚£ä¹ˆè¿­ä»£ logâ¡n\\log nlogn æ¬¡ï¼Œæ¯æ¬¡æ‰«ææ¯æ¡è¾¹ï¼Œç„¶ååˆå¹¶è¿é€šå—ã€‚ CF888G.(i,j)(i,j)(i,j) çš„è¾¹æƒæ˜¯ aiâŠ•aja_i\\oplus a_jaiâ€‹âŠ•ajâ€‹ï¼Œæ±‚ MSTã€‚ è€ƒè™‘ä¸€ä¸ªä¸€ä¸ªç‚¹æƒåœ°åˆå¹¶ï¼Œåœ¨ Trie æ ‘ä¸Šå¯å‘å¼åˆå¹¶ï¼Œå»æ‰¾åˆå¹¶ä¸¤ä¸ªè¿é€šå—åœ°æœ€å°è¾¹æƒå³å¯ã€‚ å¯ä»¥ä¸€å¼€å§‹å°†ç‚¹æƒæ’åºï¼Œè¿™æ ·è¿ç»­çš„ä¸‹æ ‡åœ¨ Trie ä¸Šæ˜¯è¿ç»­çš„ã€‚ æœ€å°åº¦é™åˆ¶ç”Ÿæˆæ ‘ æ¨¡æ¿ã€‚æœ€å°ç”Ÿæˆæ ‘ï¼Œä½†æ˜¯è¦æ±‚ sss å·ç‚¹æ°å¥½è¿æ¥äº† kkk æ¡è¾¹ã€‚ æ°å¥½è¿æ¥ï¼Œè€Œä¸”çœ‹èµ·æ¥å°±æ˜¯å‡¸çš„ï¼Œå› æ­¤ç›´æ¥ wqs äºŒåˆ†å³å¯ã€‚ æˆ‘ä»¬èƒ½åšå¾—æ›´å¥½ï¼æˆ‘ä»¬å¯ä»¥æ±‚å‡ºæ‰€æœ‰ fx(i)âˆ’fx(iâˆ’1)f_x(i)-f_x(i-1)fxâ€‹(i)âˆ’fxâ€‹(iâˆ’1) å¹¶ä»å°åˆ°å¤§æ’åºï¼Œå–å‡ºå‰è‹¥å¹²ä¸ªå³å¯å¾—åˆ°ç­”æ¡ˆã€‚ å®ç°ä¸Šåªéœ€è¦å…ˆæ±‚å‡ºä»»æ„ä¸€æ£µç”Ÿæˆæ ‘ï¼Œç„¶åè´ªå¿ƒè°ƒæ•´å³å¯ã€‚ä»£ç ã€‚ æœ€å°ç›´å¾„ç”Ÿæˆæ ‘ æˆ‘ä»¬å…ˆä»‹ç»å›¾çš„ç»å¯¹ä¸­å¿ƒã€‚æ— å‘å›¾çš„ç»å¯¹ä¸­å¿ƒä½äºå›¾çš„è¾¹ä¸Šæˆ–è€…èŠ‚ç‚¹ä¸Šï¼Œæ»¡è¶³è¯¥ä¸­å¿ƒåˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·ç¦»çš„æœ€å¤§å€¼æœ€å°ã€‚æ­¤æ—¶å¯¹åº”çš„æœ€çŸ­è·ç¦»æœ€å¤§å€¼å«åšç›´å¾„ã€‚ é‚£ä¹ˆä½¿ç”¨ Floyd ç®—æ³•ï¼Œç»å¯¹ä¸­å¿ƒåœ¨ç‚¹ä¸Šæ˜¯å¥½è®¡ç®—çš„ï¼Œå¯¹äºåœ¨è¾¹ (u,v,w)(u,v,w)(u,v,w) ä¸Šçš„æƒ…å†µï¼Œåˆ°ç‚¹ iii çš„è·ç¦»ä¸º minâ¡{du,i+x,dv,i+wâˆ’x}\\min\\{d_{u,i}+x,d_{v,i}+w-x\\}min{du,iâ€‹+x,dv,iâ€‹+wâˆ’x}ï¼š å› æ­¤æˆ‘ä»¬å¯¹äºä¸€æ¡è¾¹ (u,v,w)(u,v,w)(u,v,w)ï¼ŒæŒ‰ç…§çºµåæ ‡æšä¸¾ iiiï¼Œç„¶åå¦‚æœæœ€ä¸Šé¢é‚£ä¸ªä¸œè¥¿ä¼šäº§ç”Ÿäº¤ç‚¹çš„è¯ï¼Œå°±æ›´æ–°æœ€ä¸Šé¢é‚£ä¸ªä¸œè¥¿å°±å¯ä»¥äº†ï¼Œæ­¤æ—¶ç”¨ du,i+x+dv,p+(wâˆ’x)2\\dfrac{d_{u,i}+x+d_{v,p}+(w-x)}{2}2du,iâ€‹+x+dv,pâ€‹+(wâˆ’x)â€‹ æ›´æ–°ç­”æ¡ˆã€‚ä»£ç ã€‚ å¯¹äºæœ€å°ç›´å¾„ç”Ÿæˆæ ‘ï¼Œæ±‚å‡ºå›¾çš„ç»å¯¹ä¸­å¿ƒä¹‹åï¼Œç”±äºå›¾çš„ç»å¯¹ä¸­å¿ƒåˆ°æœ€è¿œç‚¹çš„è·ç¦»æœ€å°ï¼Œå› æ­¤å…¶æ‰€å¯¹åº”çš„åŠå¾„å°±æ˜¯æœ€å°ç›´å¾„ç”Ÿæˆæ ‘çš„åŠå¾„ï¼Œå› æ­¤æ±‚å‡ºæœ€çŸ­è·¯æ ‘å³å¯ï¼ˆæ³¨æ„åˆå§‹è·ç¦»ï¼‰ï¼Œä»£ç ï¼Œæ³¨æ„è¾¹ç•Œç‚¹çš„ç‰¹åˆ¤ã€‚ k å°ç”Ÿæˆæ ‘ æ¨¡æ¿ï¼Œä»¿ç…§ kkk çŸ­è·¯çš„æ€è·¯ï¼Œæˆ‘ä»¬æ¥å®Œæˆè¿™ä¸ªé—®é¢˜ã€‚ é¦–å…ˆæ±‚å‡ºæœ€å°ç”Ÿæˆæ ‘ã€‚ å¯¹æœ€å°ç”Ÿæˆæ ‘æ±‚å‡ºæƒå€¼å¢åŠ é‡æœ€å°çš„éæ ‘è¾¹ï¼Œåˆ™æœ‰ä¸¤ç§é€‰æ‹©ï¼šå¼ºåˆ¶é€‰æ‹©è¿™æ¡è¾¹ï¼Œå’Œå¼ºåˆ¶ä¸é€‰æ‹©è¿™æ¡è¾¹ã€‚å¯¹äºå‰è€…ï¼Œç»™å‡ºäº†ä¸€æ£µæ–°çš„ç”Ÿæˆæ ‘ï¼›å¯¹äºåè€…ï¼Œæ²¡æœ‰ç»™å‡ºæ–°çš„ç”Ÿæˆæ ‘ï¼Œä½†è¾¹çš„çŠ¶æ€æ”¹å˜äº†ã€‚ å¦‚æœå¼ºåˆ¶ä¸é€‰æ‹©è¿™æ¡è¾¹ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥å°±æ˜¯å†³ç­–æƒå€¼å¢åŠ é‡æ¬¡å°çš„è¾¹æ˜¯å¦å¼ºåˆ¶é€‰æ‹©ï¼Œä¾æ¬¡ç±»æ¨ã€‚äºæ˜¯æœ€å°ç”Ÿæˆæ ‘ç»™å‡ºäº†è‹¥å¹²æ£µæ–°çš„ç”Ÿæˆæ ‘ï¼Œå…¶ä¸­ç¬¬ iii æ£µç”Ÿæˆæ ‘é’¦å®šäº†æƒå€¼å¢åŠ é‡å‰ iii å°çš„éæ ‘è¾¹ä¸é€‰æ‹©ï¼Œä¸”ç¬¬ iii å°çš„éæ ‘è¾¹å¼ºåˆ¶é€‰æ‹©ã€‚å°†æ‰€æœ‰ç”Ÿæˆæ ‘åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼Œä¸æ–­ä»ä¼˜å…ˆé˜Ÿåˆ—å–å‡ºæƒå€¼æœ€å°çš„ç”Ÿæˆæ ‘ kkk æ¬¡åšä¸Šè¿°æ‰©å±•å³å¯ã€‚ æ³¨æ„å·²ç»é’¦å®šçŠ¶æ€çš„è¾¹ä¸å¯è¢«æ”¹å˜ã€‚ä¸€æ¡è¾¹æœ‰å››ç§çŠ¶æ€ï¼šæ ‘è¾¹ä¸”å¯è¢«æ›¿æ¢ï¼Œéæ ‘è¾¹ä¸”å¯åŠ å…¥ç”Ÿæˆæ ‘ï¼Œæ ‘è¾¹ä¸”ä¸å¯è¢«æ›¿æ¢ï¼Œéæ ‘è¾¹ä¸”ä¸å¯åŠ å…¥ç”Ÿæˆæ ‘ã€‚åœ¨æšä¸¾æ‰€æœ‰éæ ‘è¾¹æ—¶éœ€è¦è·³è¿‡æ‰€æœ‰ä¸å¯åŠ å…¥ç”Ÿæˆæ ‘çš„éæ ‘è¾¹ï¼Œæ±‚ä¸€æ¡éæ ‘è¾¹èƒ½æ›¿æ¢æ‰å“ªæ¡æ ‘è¾¹æ—¶ä¸èƒ½æ›¿æ¢ä¸å¯è¢«æ›¿æ¢çš„æ ‘è¾¹ã€‚ å¦‚æœå°†æ¯æ£µç”Ÿæˆæ ‘æŠ½è±¡ä¸ºä¸€ä¸ªç‚¹ï¼Œç”¨ä¸€æ£µæœ‰æ ¹æ ‘æè¿°æ•´ä¸ªæ‰©å±•è¿‡ç¨‹ï¼ˆæ ¹èŠ‚ç‚¹æ˜¯æœ€å°ç”Ÿæˆæ ‘ï¼‰ï¼Œé‚£ä¹ˆæ¯ä¸ªéå¶å­ç»“ç‚¹æœ‰ä¸¤ä¸ªå„¿å­ï¼Œä¸€ä¸ªæ˜¯å®ç‚¹ï¼Œä»å½“å‰ç‚¹å‘ä¸‹èµ°åˆ°å®ç‚¹è¡¨ç¤ºç”¨ä¸€æ¡éæ ‘è¾¹æ›¿æ¢äº†ä¸€æ¡æ ‘è¾¹å¾—åˆ°æ–°çš„ç”Ÿæˆæ ‘ï¼Œæ›¿æ¢å‡ºæ¥çš„é‚£æ¡è¾¹å˜æˆäº†éæ ‘è¾¹ä¸”å¯åŠ å…¥ç”Ÿæˆæ ‘ï¼Œæ›¿æ¢è¿›å»çš„å˜æˆäº†æ ‘è¾¹ä¸å¯æ›¿æ¢ï¼›å¦ä¸€ä¸ªåˆ™æ˜¯è™šç‚¹ï¼Œä»å½“å‰ç‚¹å‘ä¸‹èµ°åˆ°è™šç‚¹è¡¨ç¤ºå½“å‰ç”Ÿæˆæ ‘çš„ä¸€æ¡éæ ‘è¾¹ä»å¯åŠ å…¥å˜æˆäº†ä¸å¯åŠ å…¥ã€‚ è¿™ç§æ–¹å¼æŒ‰ç…§é¡ºåºæšä¸¾äº†æ‰€æœ‰çš„ç”Ÿæˆæ ‘ï¼ˆæ¯æ¡è¾¹éƒ½æšä¸¾äº†é€‰è¿˜æ˜¯ä¸é€‰ï¼‰ï¼Œè€Œä¸”æŒ‰ç…§é¡ºåºæ‰©å±•äº†æ¬¡å°ç”Ÿæˆæ ‘ï¼Œå› æ­¤è¿™ä¹ˆåšæ˜¯å¯¹çš„ã€‚ ä¸ºäº†é¿å…ç›´æ¥æ‰©å±•äº† O(m)O(m)O(m) ä¸ªè™šå„¿å­ï¼Œåº”è¯¥åœ¨å–å‡ºå®ç‚¹ä¹‹åå†åŠ å…¥å…„å¼Ÿè™šç‚¹ã€‚æ—¶é—´å¤æ‚åº¦ O(kmlogâ¡m+klogâ¡k)O(km\\log m+k\\log k)O(kmlogm+klogk)ï¼Œè¿æ°”å¥½æ˜¯èƒ½è¿‡çš„ï¼Œä»£ç ã€‚ ä¾‹é¢˜ éƒ½æ¯”è¾ƒç»å…¸ã€‚ [APIO2008] å…è´¹é“è·¯ Portal. å…¶ä¸­æœ‰äº›é¹…åµçŸ³è·¯æ˜¯å¿…é¡»çš„ï¼Œæˆ‘ä»¬è€ƒè™‘å…ˆå°†å¿…é¡»é€‰æ‹©çš„é¹…åµçŸ³è·¯é€‰æ‰ï¼Œç„¶åå°† kkk å¡«æ»¡ï¼Œæœ€åå†é€‰æ°´æ³¥è·¯å³å¯ã€‚ä»£ç ã€‚ * [CF1583H] Omkar and Tours Portal. ç¬¬ä¸€é—®æ¯”è¾ƒç»å…¸ï¼Œç¦»çº¿ï¼Œå°†è¯¢é—®æŒ‰ç…§ vvv ä»å¤§åˆ°å°æ’åºï¼Œä¾æ¬¡åŠ å…¥è¾¹ï¼ŒDFS åˆå¹¶è¿é€šå—ï¼Œç»´æŠ¤æœ€å¤§å€¼å³å¯ã€‚ ç¬¬äºŒé—®ï¼Œå¸Œæœ›è·¯å¾„ä¸Š ttt çš„æœ€å¤§å€¼å°½å¯èƒ½å¤§ï¼ŒKruskal é‡æ„æ ‘ï¼å»ºç«‹ä¸€æ£µåŸºäº ttt çš„è¾¹æƒé‡æ„æ ‘ã€‚è®¾èƒ½åˆ°è¾¾çš„èŠ‚ç‚¹æ˜¯ yyyï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º maxâ¡{aLCAâ¡(x,y)}\\max\\{a_{\\operatorname{LCA}(x,y)}\\}max{aLCA(x,y)â€‹}ã€‚ ç”±äº LCA å¿…å®šåœ¨ xxx åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¸Œæœ›è¯¥ LCA çš„æ·±åº¦å°½å¯èƒ½å°ã€‚ä»€ä¹ˆæ—¶å€™æ»¡è¶³å‘¢ï¼Ÿå°†æ‰€æœ‰ yyy æŒ‰ç…§ DFS åºæ’åºï¼Œå…¶ä¸­ DFS åºæœ€å°å’Œæœ€å¤§çš„å¯èƒ½ç§°ä¸ºç­”æ¡ˆï¼ˆKruskal é‡æ„æ ‘æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œæƒ³è¦ LCA ç¦» xxx è¶Šè¿œï¼Œé‚£ä¹ˆ yyy å°±å¿…å®šç¦» xxx è¶Šè¿œï¼Œä¹Ÿå°±æ˜¯ DFS åºå·®è¶Šå¤§ï¼‰ã€‚ å®ç°ä¸Šåªéœ€è¦å…ˆå»ºå‡º Kruskal é‡æ„æ ‘ï¼Œç„¶ååœ¨ç¬¬ä¸€é—®æ—¶å¹¶æŸ¥é›†ç»´æŠ¤ DFS åºæœ€å¤§æœ€å°å€¼ã€‚æ—¶é—´å¤æ‚åº¦åœ¨ O(nlogâ¡n)O(n\\log n)O(nlogn) çº§åˆ«ã€‚ä»£ç ã€‚ * [IOI2018] Werewolf Portal. æ˜¯é’ˆå¯¹ç‚¹æƒé™åˆ¶çš„ Kruskal é‡æ„æ ‘ã€‚å»ºç«‹ä¸€ä¸ª LLL æ¥ä»£è¡¨å­æ ‘ä¸­éƒ½æ¯”å®ƒå°ï¼ŒRRR æ¥ä»£è¡¨å­æ ‘ä¸­éƒ½æ¯”å®ƒå¤§ã€‚å°† sss åœ¨ RRR ä¸Šå€å¢åˆ° aâ‰¥la\\ge laâ‰¥l çš„æœ€å° aaaï¼Œå°† eee åœ¨ LLL ä¸Šå€å¢åˆ° bâ‰¤rb\\le rbâ‰¤r çš„æœ€å¤§ bbbï¼Œç„¶åå°±æ˜¯è¯¢é—®è¿™ä¸¤ä¸ªå­æ ‘æœ‰æ²¡æœ‰å…¬å…±çš„å­èŠ‚ç‚¹ï¼Œå°±æ˜¯äºŒç»´æ•°ç‚¹é—®é¢˜ã€‚ä»£ç ã€‚ ** [CF1556H] DIY Tree Portal. ç»™ç”Ÿæˆæ ‘å®šä¹‰ä¼°ä»·å‡½æ•° f(T)=âˆ‘i=1Kmaxâ¡{0,Diâˆ’di}f(T)=\\sum_{i=1}^K \\max\\{0,D_i-d_i\\}f(T)=âˆ‘i=1Kâ€‹max{0,Diâ€‹âˆ’diâ€‹}ï¼Œå…¶ä¸­ DiD_iDiâ€‹ ä»£è¡¨å®é™…åº¦æ•°ã€‚ å…ˆæ±‚å‡ºæœ€å°ç”Ÿæˆæ ‘ï¼Œç„¶åå¯¹å…¶è¿›è¡Œè°ƒæ•´ã€‚æ¯æ¬¡é€‰æ‹©ä¸€æ¡è¾¹æƒæœ€å¤§çš„ï¼Œåˆ å»å fff ä¼šå‡å°çš„è¾¹ e1e_1e1â€‹ï¼Œæ›¿æ¢æˆåŠ ä¸Šå fff ä¸ä¼šå˜å¤§çš„è¾¹æƒæœ€å°çš„è¾¹ e2e_2e2â€‹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n3)O(n^3)O(n3)ã€‚ éšæœºåŒ–è¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬ç»™ e1e_1e1â€‹ å’Œ e2e_2e2â€‹ çš„é€‰æ‹©åŠ ä¸Šä¸€ä¸ªæ¦‚ç‡ï¼Œä¸é€‰å°±æ¥ç€æ‰«ã€‚ä»£ç ã€‚ [ARC098D] Donation Portal. é¦–å…ˆï¼Œåœ¨æŸç‚¹æ‰“å¡åå¿…ä¸ä¼šå†æ¬¡è®¿é—®æŸç‚¹ã€‚ å› ä¸ºè‹¥ä¸¤æ¬¡è®¿é—®æŸç‚¹ï¼Œç¬¬ä¸€æ¬¡ä¸æ‰“å¡ï¼Œç¬¬äºŒæ¬¡æ‰“å¡è¦æ¯”ç¬¬ä¸€æ¬¡å°±æ‰“å¡ä¼˜ï¼Œå› ä¸ºä¸­é—´çš„ä¸€æ®µè·¯ç¨‹ä½™é’±æ›´å¤šã€‚ å› æ­¤ä»ä¸€ä¸ªç‚¹ iii å‡ºæ¥æ—¶ï¼Œå‰©ä½™çš„é’±ä¸ä¼šå°‘äº ci=maxâ¡{aiâˆ’bi,0}c_i=\\max\\{a_i-b_i,0\\}ciâ€‹=max{aiâ€‹âˆ’biâ€‹,0}ã€‚ä»èµ°å‡ºæ¥é’±æœ€å¤šçš„ç‚¹å¼€å§‹ DPã€‚æ‰€ä»¥æŒ‰ç…§ cic_iciâ€‹ ä»å°åˆ°å¤§æ’åºï¼Œå»ºç«‹ç‚¹æƒé‡æ„æ ‘ã€‚æ ‘å½¢ DP çš„ç­–ç•¥æ˜¯å…ˆèµ°åº¦æ•°å‡ä¸€ä¸ªå­æ ‘ï¼Œç„¶åæ‰“å¡è‡ªå·±ï¼Œå†èµ°æœ€åä¸€ä¸ªå­æ ‘ã€‚è¿™æ ·èƒ½éå†æ‰€æœ‰çš„çŠ¶æ€ã€‚ä»£ç ã€‚ ç½‘ç»œæµ æ˜¯ä¸ªå¾ˆæœ‰ç”¨çš„ä¸œè¥¿ã€‚ æ¦‚å¿µ ä¸€ä¸ªç½‘ç»œæ˜¯ä¸€å¼ æœ‰å‘å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œå¯¹äºæ¯æ¡æœ‰å‘è¾¹ (u,v)âˆˆE(u,v)\\in E(u,v)âˆˆE å­˜åœ¨å®¹é‡é™åˆ¶ c(u,v)c(u,v)c(u,v)ï¼Œå½“ (u,v)âˆˆÌ¸E(u,v)\\not\\in E(u,v)î€ âˆˆE æ—¶ï¼Œc(u,v)=0c(u,v)=0c(u,v)=0ã€‚ç½‘ç»œçš„å¯è¡Œæµåˆ†ä¸ºæœ‰æºæ±‡ï¼ˆæŒ‡å®šäº†ä¸¤ä¸ªèŠ‚ç‚¹ s,ts,ts,tï¼Œä»£è¡¨å›¾çš„æºç‚¹å’Œæ±‡ç‚¹ï¼‰å’Œæ— æºæ±‡ï¼Œä½†æ˜¯éƒ½å­˜åœ¨ä¸€ä¸ªå®šä¹‰åŸŸä¸ºèŠ‚ç‚¹äºŒå…ƒç»„çš„æµå‡½æ•° f(x,y)f(x,y)f(x,y)ï¼Œf(x,y)f(x,y)f(x,y) ä»£è¡¨è¾¹ xâ†’yx\\rightarrow yxâ†’y çš„æµé‡ï¼Œæ»¡è¶³ï¼š fff æ»¡è¶³å®¹é‡é™åˆ¶ï¼šf(x,y)â‰¤c(x,y)f(x,y)\\le c(x,y)f(x,y)â‰¤c(x,y)ï¼Œå½“ä¸¤è€…ç›¸ç­‰æ—¶ï¼Œxâ†’yx\\rightarrow yxâ†’y å°±æµæ»¡äº†ï¼› æ–œå¯¹ç§°æ€§è´¨ï¼šf(x,y)=âˆ’f(y,x)f(x,y)=-f(y,x)f(x,y)=âˆ’f(y,x)ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåå‘è¾¹å…¶å®æ˜¯è´Ÿçš„æµé‡ï¼› æµé‡å®ˆæ’ï¼šé™¤æºç‚¹å’Œæ±‡ç‚¹å¤–ï¼ˆå½“ç„¶åªé™äºæœ‰æºæ±‡å¯ä»¥é™¤äº†è¿™ä¸¤ä¸ªèŠ‚ç‚¹ï¼‰ï¼Œä»æ¯ä¸ªèŠ‚ç‚¹æµå…¥å’Œæµå‡ºçš„æµé‡ç›¸ç­‰ï¼Œå³ âˆ€iâ‰ s,t,âˆ‘f(u,i)=âˆ‘f(i,v)\\forall i\\ne s,t,\\sum f(u,i)=\\sum f(i,v)âˆ€iî€ =s,t,âˆ‘f(u,i)=âˆ‘f(i,v)ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸å‚¨å­˜æµé‡ï¼Œè¿›å»å¤šå°‘å°±æµå‡ºæ¥å¤šå°‘ã€‚ ä¸‹é¢æ˜¯ä¸€äº›å®šä¹‰ï¼š å¯¹äºæœ‰æºæ±‡ï¼Œæœ‰ âˆ‘f(S,i)=âˆ‘f(i,T)\\sum f(S,i)=\\sum f(i,T)âˆ‘f(S,i)=âˆ‘f(i,T)ï¼Œæ­¤æ—¶è¿™ä¸ªç›¸ç­‰çš„å’Œæˆä¸ºå½“å‰æµ fff çš„æµé‡ã€‚ å®šä¹‰æµ fff åœ¨ç½‘ç»œ GGG ä¸Šçš„æ®‹é‡ç½‘ç»œ Gf=(V,Ef)G_f=(V,E_f)Gfâ€‹=(V,Efâ€‹) ä¸ºå®¹é‡å‡½æ•° cf=câˆ’fc_f=c-fcfâ€‹=câˆ’fã€‚æ ¹æ®å®¹é‡é™åˆ¶ï¼Œcf(x,y)â‰¥0c_f(x,y)\\ge 0cfâ€‹(x,y)â‰¥0ï¼Œå½“ cf(x,y)=0c_f(x,y)=0cfâ€‹(x,y)=0 æ—¶ï¼Œåˆ™è§†ä¸º xâ†’yx\\rightarrow yxâ†’y åœ¨æ®‹é‡ç½‘ç»œä¸Šä¸å­˜åœ¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æ®‹é‡ç½‘ç»œä¸­æˆ‘ä»¬è¦åˆ æ‰æ»¡æµè¾¹ã€‚ å®šä¹‰å¢å¹¿è·¯ PPP æ˜¯æ®‹é‡ç½‘ç»œ GfG_fGfâ€‹ ä¸Šæºç‚¹åˆ°æ±‡ç‚¹çš„ä¸€æ¡è·¯å¾„ï¼Œè€Œæ— æºæ±‡åˆ™æ²¡æœ‰å¢å¹¿è·¯ã€‚ å°†ç‚¹é›†åˆ†ä¸ºä¸¤ä¸ªäº’è¡¥ç›¸äº¤çš„ A,BA,BA,Bï¼Œä¸”æ»¡è¶³ SâˆˆA,TâˆˆBS\\in A, T\\in BSâˆˆA,TâˆˆBï¼Œè¿™ç§åˆ’åˆ†æ–¹å¼ç§°ä¸ºå‰²ï¼Œå‰²çš„å®¹é‡ä¸º âˆ‘uâˆˆAâˆ‘vâˆˆBc(u,v)\\sum_{u\\in A}\\sum_{v\\in B}c(u,v)âˆ‘uâˆˆAâ€‹âˆ‘vâˆˆBâ€‹c(u,v)ï¼Œæµé‡ä¸º âˆ‘uâˆˆAâˆ‘vâˆˆBf(u,v)\\sum_{u\\in A}\\sum_{v\\in B}f(u,v)âˆ‘uâˆˆAâ€‹âˆ‘vâˆˆBâ€‹f(u,v)ã€‚å¦‚æœ uâˆˆA,vâˆˆBu\\in A,v\\in BuâˆˆA,vâˆˆBï¼Œé‚£ä¹ˆ (u,v)(u,v)(u,v) æ˜¯å‰²è¾¹ï¼Œå¯ä»¥çœ‹å‡ºï¼Œå‰²è¾¹ä¸€èˆ¬ä¸æ­¢ä¸€æ¡ã€‚ å‰²ä¸­å‰²è¾¹å®¹é‡å’Œæœ€å°çš„åˆ’åˆ†æ–¹å¼ç§°ä¸ºæœ€å°å‰²ï¼Œè€Œä¸”æœ€å¤§æµç­‰äºæœ€å°å‰²ã€‚ æœ€å¤§æµé—®é¢˜ è§£å†³æœ€å¤§æµé—®é¢˜çš„æ€æƒ³æ˜¯ï¼šä¸æ–­å¯»æ‰¾å¢å¹¿è·¯ å’Œ èƒ½æµæ»¡å°±æµæ»¡ã€‚åœ¨ç»™ä¸€æ¡è¾¹å¢åŠ æµé‡æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ç»™å…¶åå‘è¾¹æ¥å¢åŠ å®¹é‡æ¥æ”¯æŒåæ‚”ã€‚è¿™æ ·çš„æ“ä½œç§°ä¸ºä¸€æ¬¡å¢å¹¿ã€‚ EK ç®—æ³•çš„æ€æƒ³æ˜¯ä½¿ç”¨ BFS å¯»æ‰¾é•¿åº¦æœ€çŸ­çš„å¢å¹¿è·¯ï¼Œç„¶åè®¡ç®—æµé‡ã€‚ä¸ºæ­¤æˆ‘ä»¬è®°å½•æµå‘æ¯ä¸ªç‚¹çš„è¾¹çš„ç¼–å·ï¼Œç„¶åä»æ±‡ç‚¹åæ¨åˆ°æºç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nm2)O(nm^2)O(nm2)ã€‚ Dinic çš„æœ¬è´¨æ€æƒ³æ˜¯å¤šè·¯å¢å¹¿å’Œå½“å‰å¼§ä¼˜åŒ–ï¼ˆè·³è¿‡æµæ»¡çš„è¾¹ï¼‰ã€‚é€šè¿‡ BFS å°†å›¾åˆ†å±‚ï¼Œå‘ä¸‹ä¸€å±‚èŠ‚ç‚¹å¼€å§‹è¿›è¡Œå¤šè·¯å¢å¹¿ï¼Œå¹¶è®°å½•å½“ä¸”æµæ»¡åˆ°äº†å“ªæ¡è¾¹ã€‚ Dinic æœ€å¤§æµ æ¨¡æ¿é€ŸæŸ¥ struct Graph &#123; struct Edge &#123; int v, w; Edge(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; vector&lt;Edge> E; vector&lt;int> G[N]; inline void add(int u, int v, int w) &#123; E.emplace_back(v, w); G[u].emplace_back(E.size() - 1); E.emplace_back(u, 0); G[v].emplace_back(E.size() - 1); &#125; int S, T, cur[N], d[N], vis[N]; bool bfs(void) &#123; memset(cur, 0, sizeof cur); memset(d, -1, sizeof d); queue&lt;int> q; q.push(S); d[S] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = E[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; d[e.v] = d[u] + 1; q.push(e.v); if (e.v == T) return 1; &#125; &#125; &#125; return 0; &#125; int dinic(int x, int res) &#123; if (x == T) return res; int flow = 0; vis[x] = 1; for (int i = cur[x]; i &lt; G[x].size() &amp;&amp; res; ++i) &#123; Edge &amp;e = E[G[x][i]]; cur[x] = i; int c = min(res, e.w); if (!vis[e.v] &amp;&amp; d[e.v] == d[x] + 1 &amp;&amp; c) &#123; int k = dinic(e.v, c); flow += k; res -= k; e.w -= k; E[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; vis[x] = 0; return flow; &#125; int maxFlow(int s, int t) &#123; S = s, T = t; int flw = 0, mxflw = 0; while (bfs()) while (flw = dinic(S, 1e9)) mxflw += flw; return mxflw; &#125; &#125; G; åªéœ€è¦å°† BFS æ”¹æˆ SPFA å°±å¯ä»¥å®Œæˆæ— è´Ÿç¯çš„æœ€å°è´¹ç”¨æœ€å¤§æµï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nmf)O(nmf)O(nmf)ï¼Œå…¶ä¸­ fff æŒ‡æœ€å¤§æµæµé‡ã€‚ æœ€å°å‰²çš„æ–¹æ¡ˆæ„é€ æ˜¯ç®€å•çš„ï¼Œåœ¨æ®‹é‡ç½‘ç»œä¸­ï¼Œdisudis_udisuâ€‹ å­˜åœ¨è¯æ˜å…¶ä¸ SSS ç›¸è¿ã€‚ ä¸Šä¸‹ç•Œç½‘ç»œæµ ç»™æ¯æ¡è¾¹åŠ å…¥ä¸€ä¸ªæµé‡ä¸‹ç•Œ bbb å°±æ˜¯ä¸Šä¸‹ç•Œç½‘ç»œæµã€‚ æ— æºæ±‡å¯è¡Œæµ å¸¸è§é—®é¢˜ä¸æ¨¡å‹ ç½‘ç»œæµæœ‰ä¸€äº›å¸¸è§æ¨¡å‹ï¼Œè¿™é‡Œåšä¸€ä¸‹æ€»ç»“ã€‚ æœ€å°å‰²ç‚¹ åˆ å»ç‚¹ iii æœ‰ä»£ä»· wiw_iwiâ€‹ï¼Œæ±‚ä½¿å¾— S,TS,TS,T ä¸è¿é€šçš„æœ€å°ä»£ä»·ã€‚ å°†æ¯ä¸ªç‚¹æ‹†æˆå…¥ç‚¹ iini_{in}iinâ€‹ å’Œå‡ºç‚¹ iouti_{out}ioutâ€‹ï¼Œåœ¨å®ƒä»¬ä¹‹é—´è¿ä¸€æ¡å®¹é‡ä¸º wiw_iwiâ€‹ çš„è¾¹ï¼Œè¡¨ç¤ºåˆ å»è¿™ä¸ªç‚¹ã€‚å¯¹äºåŸå›¾çš„æ¯ä¸€æ¡è¾¹ u,vu,vu,vï¼Œè¿æ¥ uoutâ†’vinu_{out}\\rightarrow v_{in}uoutâ€‹â†’vinâ€‹ ä¸€æ¡ +âˆ+\\infty+âˆ å®¹é‡çš„è¾¹ï¼Œè¿™æ ·æˆ‘ä»¬åªèƒ½åˆ ç‚¹è€Œä¸ä¼šå‰²è¾¹ï¼Œå®é™…ä¸Šå°±æ˜¯å°†è¾¹ä½œä¸ºäº†ç‚¹ã€‚ é›†åˆåˆ’åˆ†æ¨¡å‹ é€‰å®š xix_ixiâ€‹ åˆé€‚çš„å¸ƒå°”å€¼ï¼Œä½¿å¾—å¦‚ä¸‹å’Œå¼çš„å€¼æœ€å°ï¼šminâ¡x1,x2,â‹¯xnâˆˆ{0,1}âˆ‘(u,v)âˆˆEcu,vxuxvâ€¾+âˆ‘uauxu+buxuâ€¾\\min_{x_1,x_2,\\cdots x_n\\in\\{0,1\\}}\\sum_{(u,v)\\in E} c_{u,v}x_u\\overline{x_v}+\\sum_{u}a_ux_u+b_u\\overline{x_u}x1â€‹,x2â€‹,â‹¯xnâ€‹âˆˆ{0,1}minâ€‹(u,v)âˆˆEâˆ‘â€‹cu,vâ€‹xuâ€‹xvâ€‹â€‹+uâˆ‘â€‹auâ€‹xuâ€‹+buâ€‹xuâ€‹â€‹ è¿ Sâ†’iS\\rightarrow iSâ†’i çš„å®¹é‡ä¸º bib_ibiâ€‹ çš„è¾¹ï¼Œiâ†’Ti\\rightarrow Tiâ†’T çš„å®¹é‡ä¸º aia_iaiâ€‹ çš„è¾¹ã€‚å¦‚æœå‰²æ‰äº† iâ†’Ti\\rightarrow Tiâ†’Tï¼Œè¯´æ˜å°† iii åˆ’åˆ†åˆ°äº†é›†åˆ AAAï¼Œä»£ä»·ä¸º aia_iaiâ€‹ã€‚ ç»™ u,vu,vu,v è¿å®¹é‡é™åˆ¶ä¸º cu,vc_{u,v}cu,vâ€‹ çš„åŒå‘è¾¹ï¼Œè¿™æ ·å¦‚æœ u,vu,vu,v ä¸å±äºåŒä¸€é›†åˆï¼Œè‡³å°‘ä¼šå‰²æ‰å…¶ä¸­ä¸€æ¡è¾¹ã€‚ è¿™æ ·è¿™ä¸ªç½‘ç»œçš„æœ€å°å‰²å°±æ˜¯ç­”æ¡ˆã€‚ è¿˜æœ‰ä¸€ç§é™åˆ¶ï¼šxxx åœ¨é›†åˆ AAA ä¸” yyy åœ¨é›†åˆ BBB æ—¶æœ‰ä»£ä»· wwwï¼Œé‚£ä¹ˆè¿ xâ†’yx\\rightarrow yxâ†’y çš„å®¹é‡ä¸º www çš„è¾¹ï¼Œè¿™æ ·å¦‚æœ xxx å’Œ SSS ç›¸è¿ä¸” yyy å’Œ TTT ç›¸è¿ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹éœ€è¦è¢«å‰²æ‰ã€‚ å¦‚ä½•è¾“å‡ºæ–¹æ¡ˆï¼Ÿè¦æ³¨æ„ä»€ä¹ˆæ˜¯å‰²è¾¹ï¼šåœ¨æœ€åçš„æ®‹é‡ç½‘ç»œä¸Š d(x)d(x)d(x) æ˜¯å¦å­˜åœ¨ï¼Œå­˜åœ¨åˆ™å±äºé›†åˆ AAAï¼Œå¦åˆ™æ˜¯é›†åˆ BBBã€‚ [THUPC2022 åˆèµ›] åˆ†ç»„ä½œä¸šã€‚è¾ƒå¤æ‚ï¼Œè§åŸé¢˜é¢ã€‚ å–œæ¬¢å…³ç³»å¦‚ä½•å¤„ç†ï¼Ÿå°†æ¯ä¸ªç»„éƒ½å»ºä¸€ä¸ªç‚¹ï¼Œç»„ iii åœ¨æœ€ç»ˆçš„æ®‹é‡ç½‘ç»œä¸Šä¸ SSS ç›¸è¿åˆ™è¡¨ç¤ºåˆä½œï¼Œä¸ TTT ç›¸è¿åˆ™è¡¨ç¤ºä¸åˆä½œã€‚ä»»ä½•ä¸€ä¸ªäººä¸åŒæ„è¿™ä¸ªç»„å°±ä¸åˆä½œï¼Œå› æ­¤ç»„å‘å®ƒçš„ç»„å‘˜è¿ +âˆ+\\infty+âˆ çš„è¾¹ï¼Œè¿™æ ·å¦‚æœè¿™ä¸ªç»„ä¸ TTT ç›¸è¿ï¼Œé‚£ä¹ˆä¾¿ä¸åˆä½œã€‚ å°† BBB å‘ AAA å¯¹åº”çš„ç»„è¿ aia_iaiâ€‹ çš„è¾¹ï¼Œè¿™æ ·å¦‚æœ BBB åŒæ„äº†ï¼ˆå®ƒæ²¡æœ‰è¿å‘ TTTï¼‰ï¼ŒAAA ç»„æ²¡æœ‰åˆä½œï¼ˆè¿å‘äº† TTTï¼‰ï¼Œåˆ™è¦å‰²æ‰ aia_iaiâ€‹ã€‚ç±»ä¼¼åœ°ï¼ŒBBB çš„ç»„å‘ AAA è¿ bib_ibiâ€‹ã€‚ä»£ç ã€‚ æœ€å¤§æƒé—­åˆå­å›¾ æ¯ä¸ªç‚¹æœ‰ç‚¹æƒï¼Œæ±‚é—­åˆå­å›¾çš„æœ€å¤§æƒå€¼ã€‚ è€ƒè™‘é›†åˆåˆ’åˆ†æ¨¡å‹ï¼Œå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥å°†å…¶åˆ’åˆ†åˆ°é€‰æˆ–ä¸é€‰çš„é›†åˆä¸­ï¼Œä¹Ÿå°±æ˜¯ Sâ†’iS\\rightarrow iSâ†’i è¿ 000ï¼Œiâ†’Ti\\rightarrow Tiâ†’T è¿ wiw_iwiâ€‹ã€‚å¦‚æœ (u,v)âˆˆE(u,v)\\in E(u,v)âˆˆEï¼Œå°±æ˜¯å¦‚æœ uuu åˆ†åˆ°é€‰çš„é›†åˆä¸­ï¼Œvvv ä¹Ÿå¿…é¡»åˆ†åˆ°é€‰çš„é›†åˆä¸­ï¼Œå³ uâ†’vu\\rightarrow vuâ†’v æœ‰å®¹é‡ âˆ’âˆ-\\inftyâˆ’âˆï¼Œæ±‚ç½‘ç»œçš„æœ€å¤§å‰²å³å¯ã€‚ ä½†æ˜¯æœ€å¤§å‰²æ˜¯ NPH çš„ï¼Œå› æ­¤è€ƒè™‘å–ç›¸åæ•°æ±‚æœ€å°å‰²ã€‚ç„¶è€Œè¿™æ ·ä¼šå‡ºç°è´Ÿå®¹é‡çš„è¾¹ï¼å°†è´Ÿå®¹é‡çš„è¾¹æ”¹åˆ° Sâ†’iS\\rightarrow iSâ†’i æ¥è¿ã€‚è¿™æ ·ç­”æ¡ˆä¸ºæ‰€æœ‰æ­£æƒå€¼çš„å’Œå‡å»æœ€å°å‰²ï¼Œå®é™…ä¸Šæ˜¯å…ˆå°†æ‰€æœ‰æ­£ç‚¹æƒé€‰å…¥ï¼Œç„¶åè€ƒè™‘å“ªäº›ä¸é€‰ã€‚ åˆ‡ç³•æ¨¡å‹ Portal. nnn ä¸ªå˜é‡ xix_ixiâ€‹ï¼Œæ¯ä¸ªå˜é‡çš„å–å€¼èŒƒå›´ä¸º xiâˆˆ[1,mi]x_i\\in[1,m_i]xiâ€‹âˆˆ[1,miâ€‹]ï¼Œæ¯ä¸¤ä¸ªå˜é‡ä¹‹é—´ä¼šå¯¹ç­”æ¡ˆäº§ç”Ÿè´¡çŒ®ï¼ˆä¸€èˆ¬å’Œä¸¤å˜é‡å·®æœ‰å…³ï¼‰ï¼Œæˆ‘ä»¬è¦æœ€å¤§åŒ– / æœ€å°åŒ–è¿™ä¸ªè´¡çŒ®ã€‚ å»ºå›¾æ–¹å¼ä¸€èˆ¬å°±æ˜¯å¯¹æ¯ä¸ªå˜é‡ xix_ixiâ€‹ ä¸ªç‚¹æ‹†æˆ mim_imiâ€‹ ä¸ªç‚¹ä¸ªç‚¹ä¸²æˆä¸€ä¸ªæºç‚¹åˆ°æ±‡ç‚¹çš„é“¾ï¼Œå‰²å“ªæ¡è¾¹å°±ä»£è¡¨å–å“ªä¸ªå€¼ï¼Œè´¡çŒ®ç”¨ä¸¤æ¡é“¾ç›´æ¥çš„è¿è¾¹è¡¨è¾¾ï¼Œäºæ˜¯å°±å˜æˆæœ€å°å‰²å½¢å¼äº†ã€‚ æ³¨æ„åˆ°æœ‰ä¸€ä¸ªå…‰æ»‘åº¦é™åˆ¶ï¼Œå¯ä»¥è¿ä¸€æ¡ uâ†’vu\\rightarrow vuâ†’v çš„ +âˆ+\\infty+âˆ çš„è¾¹ã€‚ å¯ä»¥è¯æ˜ï¼Œä¸€æ¡é“¾æœ€å¤šå‰²ä¸€æ¡è¾¹ã€‚ä»£ç ã€‚ æœ€å°å‰²æ ‘ æ¨¡æ¿ã€‚ DAG æœ€å°è·¯å¾„è¦†ç›– [TTPC2022] Colorful Graph.æœ‰å‘å›¾ï¼Œè¦æ±‚ç»™ç‚¹æŸ“è‰²ï¼Œä½¿å¾—åŒè‰²ç‚¹ i,ji,ji,j å­˜åœ¨ä¸€æ¡ iâ†’ji\\rightarrow jiâ†’j æˆ– jâ†’ij\\rightarrow ijâ†’i çš„é“è·¯ï¼ˆæˆ–è€…éƒ½æœ‰ï¼‰ï¼Œè¦æ±‚é¢œè‰²æ•°æœ€å°ï¼Œç»™å‡ºæ–¹æ¡ˆã€‚ é¦–å…ˆ SCC ç¼©ç‚¹ï¼Œä¸€ä¸ª SCC å†…å¯ä»¥æŸ“åŒä¸€ä¸ªé¢œè‰²ï¼Œé‚£ä¹ˆåªéœ€è¦å¤„ç† DAGã€‚ æ±‚çš„æ˜¯ DAG æœ€å°å¯äº¤è·¯å¾„è¦†ç›–ã€‚ä¹Ÿå°±æ˜¯ä¸€ä¸ªç‚¹å†…éƒ¨çš„æµé‡æ˜¯ä¸é™çš„ã€‚ äºŒåˆ†å›¾ç›¸å…³ è®¾æ— å‘å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œè‹¥èƒ½å¤Ÿå°† VVV åˆ†æˆä¸¤ä¸ªç‚¹é›† V1,V2V_1,V_2V1â€‹,V2â€‹ æ»¡è¶³ V1âˆ©V2=âˆ…,V1âˆªV2=VV_1\\cap V_2=\\varnothing,V_1\\cup V_2=VV1â€‹âˆ©V2â€‹=âˆ…,V1â€‹âˆªV2â€‹=V ä¸” âˆ€(u,v)âˆˆE,uâˆˆV1,vâˆˆV2\\forall(u,v)\\in E,u\\in V_1,v\\in V_2âˆ€(u,v)âˆˆE,uâˆˆV1â€‹,vâˆˆV2â€‹ï¼ˆä¹Ÿå¯ä»¥åè¿‡æ¥ï¼‰ï¼Œè¿™æ · GGG æ˜¯ä¸€å¼ äºŒåˆ†å›¾ï¼ŒV1,V2V_1,V_2V1â€‹,V2â€‹ åˆ†åˆ«ç§°ä¸ºå·¦éƒ¨ç‚¹å’Œå³éƒ¨ç‚¹ã€‚ äºŒåˆ†å›¾çš„å……è¦æ¡ä»¶æ˜¯ä¸å­˜åœ¨å¥‡ç¯ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥ç»™äºŒåˆ†å›¾è¿›è¡Œé»‘ç™½æŸ“è‰²ã€‚ ä»æŸä¸ªç‚¹å¼€å§‹ DFSï¼Œéå†å½“å‰ç‚¹ uuu å’Œé‚»å±… vvvï¼Œå¦‚æœ vvv æœªè¢«è®¿é—®ï¼Œåˆ™ vvv çš„é¢œè‰²ä¸ uuu ç›¸åï¼›å¦‚æœè®¿é—®è¿‡ï¼Œè¯´æ˜å­˜åœ¨å¥‡ç¯ã€‚ äºŒåˆ†å›¾åŒ¹é… ç»™å®šäºŒåˆ†å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œè‹¥è¾¹é›† MâŠ†EM\\subseteq EMâŠ†E æ»¡è¶³ MMM ä¸­ä»»æ„ä¸¤æ¡è¾¹ä¸äº¤äºåŒä¸€ç«¯ç‚¹ï¼Œåˆ™ç§° MMM æ˜¯ GGG çš„ä¸€ç»„åŒ¹é…ï¼Œå…¶å¤§å°ä¸º âˆ£Mâˆ£|M|âˆ£Mâˆ£ã€‚ ç‰¹åˆ«çš„ï¼Œè‹¥ âˆ£V1âˆ£=âˆ£V2âˆ£,âˆ£Mâˆ£=âˆ£V1âˆ£|V_1|=|V_2|,|M|=|V_1|âˆ£V1â€‹âˆ£=âˆ£V2â€‹âˆ£,âˆ£Mâˆ£=âˆ£V1â€‹âˆ£ï¼Œåˆ™ç§° MMM ä¸ºå®Œç¾åŒ¹é…ã€‚ æœ€å¤§åŒ¹é…ã€‚æˆ‘ä»¬å¸Œæœ›æ±‚å‡ºè¾¹é›† MMM çš„æœ€å¤§å¤§å°ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬ä» SSS å‘ V1V_1V1â€‹ çš„æ‰€æœ‰ç‚¹è¿ä¸€æ¡ 111 çš„è¾¹ï¼ŒV2V_2V2â€‹ å‘ TTT è¿ä¸€æ¡ 111 çš„è¾¹ï¼Œæ ¹æ® EEE ä» V1V_1V1â€‹ å‘ V2V_2V2â€‹ è¿è¾¹ï¼Œè·‘æœ€å¤§æµå³å¯ã€‚åœ¨è¿™é‡Œ Dinic çš„æ—¶é—´å¤æ‚åº¦ä¸º O(mn)O(m\\sqrt{n})O(mnâ€‹)ã€‚ æœ€å¤§å¤šé‡åŒ¹é…ã€‚å³èŠ‚ç‚¹ uuu ä¸èƒ½ä¸è¶…è¿‡ LuL_uLuâ€‹ æ¡è¾¹ç›¸è¿ï¼Œè¿™æ ·åªéœ€è¦å°†æ¯ä¸ªç‚¹ä¸æºç‚¹æˆ–æ±‡ç‚¹çš„å®¹é‡è®¾ä¸º LuL_uLuâ€‹ å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ­£ç¡®ã€‚ å¸¦æƒæœ€å¤§åŒ¹é…ã€‚å›¾ä¸­æ˜¯æ²¡æœ‰ç¯çš„ï¼Œå°†å…¶è½¬åŒ–ä¸ºæœ€å°è´¹ç”¨æœ€å¤§æµå³å¯ã€‚æ³¨æ„è¿™æ—¶çš„æ—¶é—´å¤æ‚åº¦æ²¡æœ‰ä¿è¯ï¼Œå¦‚æœè¾¹æƒèŒƒå›´è¾ƒå°ï¼Œå¯ä»¥æŒ‰ç…§è¾¹æƒé¡ºåºåŠ è¾¹ï¼Œä¾æ¬¡è·‘æœ€å¤§åŒ¹é…ã€‚ åŒˆç‰™åˆ©ç®—æ³•å¯ä»¥ä»¥ O(nm)O(nm)O(nm) çš„æ—¶é—´å¤æ‚åº¦è§£å†³äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…é—®é¢˜ã€‚ å·¥ä½œè¿‡ç¨‹å¦‚ä¸‹ï¼š åŠ å…¥ä¸€ä¸ªå·¦éƒ¨ç‚¹ xxxï¼Œç„¶åè®© xxx å»å°è¯•åŒ¹é…ã€‚ å¦‚æœ xxxï¼Œå·²ç»åŒ¹é…ï¼Œåˆ™å¢å¹¿å¤±è´¥ã€‚ éå† xxx èƒ½åˆ°è¾¾çš„æ‰€æœ‰å³éƒ¨ç‚¹ yyyï¼š yyy è¢«è®¿é—®è¿‡äº†ï¼Œé‚£ä¹ˆç›´æ¥å†è§ã€‚ yyy æ²¡è¢«åŒ¹é…ï¼Œè®© xxx åŒ¹é… yyyï¼Œå¢å¹¿æˆåŠŸã€‚ yyy è¢«åŒ¹é…ï¼Œè€ƒè™‘ yyy åŸæ¥åŒ¹é…çš„ xâ€²x&#x27;xâ€²ï¼Œå¦‚æœ xâ€²x&#x27;xâ€² è¿˜èƒ½å¤ŸæˆåŠŸåŒ¹é…ï¼Œé‚£ä¹ˆæ”¹ä¸ºè®© yyy åŒ¹é… xxxï¼Œå½¢æˆæ–°çš„å¢å¹¿è·¯ã€‚ å®é™…ä¸Šï¼Œå¦‚æœå½“å‰ç‚¹å¤±é…ï¼Œvis æ•°ç»„æ˜¯ä¸éœ€è¦æ¸…ç©ºçš„ï¼æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š int n, m, E, mch[505], vis[505]; vector&lt;int> G[505]; bool dfs(int x) &#123; if (vis[x]) return 0; vis[x] = 1; for (int y : G[x]) if (!mch[y] || dfs(mch[y])) return mch[y] = x, 1; return 0; &#125; int main(void) &#123; cin >> n >> m >> E; for(int i = 1; i &lt;= E; i++) &#123; int u, v; cin >> u >> v; G[u].push_back(v); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) if (dfs(i)) &#123; memset(vis, 0, sizeof(vis)); ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; å®Œç¾åŒ¹é…æ˜¯æŒ‡åŒ¹é…å¤§å°ä¸º nnnï¼ŒHall å®šç†å¯ä»¥ç”¨äºåˆ¤å®šæ˜¯å¦å­˜åœ¨å®Œç¾åŒ¹é…ï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„ SâŠ†V1S\\subseteq V_1SâŠ†V1â€‹ï¼Œå‡æœ‰ âˆ£Sâˆ£â‰¤âˆ£N(S)âˆ£|S|\\le |N(S)|âˆ£Sâˆ£â‰¤âˆ£N(S)âˆ£ï¼Œå…¶ä¸­ N(S)N(S)N(S) æŒ‡ SSS æ‰€è¿æ¥çš„å³éƒ¨çš„ç‚¹ã€‚ ç‚¹é›†ç›¸å…³é—®é¢˜ äºŒåˆ†å›¾æœ€å°ç‚¹è¦†ç›–é›†çš„å¤§å°ä¸äºŒåˆ†å›¾æœ€å¤§åŒ¹é…ç›¸ç­‰ï¼Œæœ€å¤§ç‹¬ç«‹é›†ç­‰äº âˆ£Vâˆ£|V|âˆ£Vâˆ£ å‡å»æœ€å°ç‚¹è¦†ç›–é›†ï¼Œæœ€å¤§å›¢ç­‰äºè¡¥å›¾çš„æœ€å¤§ç‹¬ç«‹é›†ã€‚ ç½‘ç»œæµ 24 é¢˜ å‰”é™¤äº†å…¶ä¸­ä¸æ˜¯ç½‘ç»œæµçš„é¢˜ã€‚æœ‰äº›å»ºæ¨¡æ–¹å¼å¾ˆç»å…¸ï¼Œä½†æ˜¯å¤§éƒ¨åˆ†é¢˜éƒ½æ˜¾å¾—éå¸¸è€å¥—äº†ã€‚ è¯•é¢˜åº“é—®é¢˜ Portal. å°†è¯•é¢˜çœ‹ä½œå·¦éƒ¨ç‚¹ï¼Œç±»å‹çœ‹ä½œå³éƒ¨ç‚¹ï¼Œæ¯ä¸ªè¯•é¢˜å‘å¯¹åº”çš„ç±»å‹è¿è¾¹ã€‚æºç‚¹å‘è¯•é¢˜è¿è¾¹ï¼Œç±»å‹å‘æ±‡ç‚¹è¿è¾¹ã€‚ æœ‰è§£ä»…å½“æœ€å¤§æµä¸º mmmï¼Œæ–¹æ¡ˆçš„è¾“å‡ºå¯ä»¥æ ¹æ®å“ªäº›è¾¹æµæ»¡æ¥åˆ¤æ–­ã€‚ä»£ç ã€‚ é£è¡Œå‘˜é…å¯¹æ–¹æ¡ˆé—®é¢˜ Portal. äºŒåˆ†å›¾æœ€å¤§åŒ¹é…æ¨¡æ¿ã€‚ä»£ç ã€‚ åœ†æ¡Œé—®é¢˜ Portal. äºŒåˆ†å›¾æœ€å¤§å¤šé‡åŒ¹é…æ¨¡æ¿ã€‚ä»£ç ã€‚ å¤ªç©ºé£è¡Œè®¡åˆ’é—®é¢˜ Portal. å°†ä»ªå™¨å’Œå®éªŒæŠ½è±¡æˆç‚¹ï¼Œå°±æ˜¯æœ€å¤§æƒé—­åˆå­å›¾æ¨¡æ¿ã€‚ä»£ç ã€‚ éª‘å£«å…±å­˜é—®é¢˜ Portal. å°†æ£‹ç›˜ä¸Šçš„ç‚¹åˆ’åˆ†ä¸ºå·¦éƒ¨ç‚¹å’Œå³éƒ¨ç‚¹ï¼Œä½¿å¾—éª‘å£«çš„ä½ç½®å’Œå…¶èƒ½èµ°åˆ°çš„ä½ç½®åœ¨ä¸åŒçš„ç‚¹éƒ¨ã€‚è¿™æ ·å°±æˆäº†äºŒåˆ†å›¾æœ€å¤§ç‹¬ç«‹é›†çš„æ¨¡æ¿ã€‚ä»£ç ã€‚ æœ€é•¿ä¸ä¸‹é™å­åºåˆ—é—®é¢˜ Portal. é€šè¿‡ DP æ¥æ±‚è§£ç­”æ¡ˆï¼Œæ‹†ç‚¹é™åˆ¶ä¸€ä¸ªç‚¹çš„ä½¿ç”¨æ¬¡æ•°ã€‚ä»£ç ã€‚ * æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜ Portal. æ±‚çš„æ˜¯ DAG çš„æœ€å°ä¸äº¤è·¯å¾„è¦†ç›–ã€‚ å°†ç‚¹æ‹†æˆå·¦ç‚¹å’Œå³ç‚¹ï¼Œè¿›è¡ŒäºŒåˆ†å›¾æœ€å¤§åŒ¹é…ã€‚æ¯æ¬¡å¤šæµä¸Šä¸€ä¸ªï¼Œå°±è¯´æ˜åˆæœ‰ä¸€å¯¹ç‚¹è¿åœ¨äº†ä¸€èµ·ï¼Œç­”æ¡ˆå¯ä»¥å‡å°‘ 111ã€‚ä¸¤éƒ¨ç‚¹ä¹‹é—´æµæ»¡çš„è¾¹å°±æ˜¯æ‰€æœ‰è¢«é€‰è¿›è·¯å¾„è¦†ç›–çš„è¾¹ï¼ŒDFS è¾“å‡ºç­”æ¡ˆå³å¯ã€‚ä»£ç ã€‚ é­”æœ¯çƒé—®é¢˜ Portal. æšä¸¾æ•°ï¼Œç„¶åè¿å¯ä»¥æ”¾åœ¨ä¸€èµ·çš„æ•°çš„è¾¹ï¼Œå‘ç°å°±æ˜¯æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜ã€‚ä»£ç ã€‚ é¤å·¾è®¡åˆ’é—®é¢˜ Portal. ç”¨æœ€å¤§æµæè¿°é¤å·¾ä¸ªæ•°ï¼Œè´¹ç”¨æè¿°ä»£ä»·ï¼Œå°†æ¯ä¸ªé¤å…æ‹†æˆä¸¤ä¸ªç‚¹åŒºåˆ†ä¸¤ç§é¤å·¾ï¼Œä»£ç ã€‚ æ˜Ÿé™…è½¬ç§»é—®é¢˜ Portal. ä» ttt æ‰©å±•åˆ° t+1t+1t+1ï¼Œåœ¨è½¬ç§»çš„å¤ªç©ºç”µæ¢¯ä¹‹é—´è¿è¾¹ï¼Œæ¯æ¬¡å†è¿›è¡Œå¢å¹¿å³å¯ã€‚ä»£ç ã€‚ åˆ†é…é—®é¢˜ Portal. äºŒåˆ†å›¾æœ€å¤§æƒå®Œç¾åŒ¹é…ï¼Œä»£ç ã€‚ è¿è¾“é—®é¢˜ Portal. äºŒåˆ†å›¾æœ€å¤§æƒå®Œç¾åŒ¹é…ï¼Œä»£ç ã€‚ èˆªç©ºè·¯çº¿é—®é¢˜ Portal. æ‹†ç‚¹æ¥é™åˆ¶åªç»è¿‡ä¸€æ¬¡ï¼Œç„¶åæ±‚è§£æœ€å¤§è´¹ç”¨æœ€å¤§æµå³å¯ã€‚ä»£ç ã€‚ æ–¹æ ¼å–æ•°é—®é¢˜ Portal. é»‘ç™½æŸ“è‰²ï¼Œç„¶åäºŒåˆ†å›¾æœ€å¤§ç‹¬ç«‹é›†ã€‚ä»£ç ã€‚ ç«æ˜Ÿæ¢é™©é—®é¢˜ Portal. ç›´æ¥æ‹†ç‚¹ï¼Œç„¶å DFS æš´åŠ›è¾“å‡ºæ–¹æ¡ˆã€‚ä»£ç ã€‚ æ·±æµ·æœºå™¨äººé—®é¢˜ Portal. å’Œä¸Šé“é¢˜åŸºæœ¬ä¸€æ ·ã€‚ä»£ç ã€‚ æ•°å­—æ¢¯å½¢é—®é¢˜ Portal. æ‹†ç‚¹é™åˆ¶ä¸€ä¸ªç‚¹çš„ç»è¿‡æ¬¡æ•°ï¼Œè·‘è´¹ç”¨æµå³å¯ã€‚ä»£ç ã€‚ æœ€é•¿ k å¯é‡åŒºé—´é›†é—®é¢˜ Portal. æ¯ä¸¤ä¸ªç›¸é‚»ç‚¹ä¹‹é—´è¿æµé‡ä¸º kkk çš„è¾¹ï¼Œç„¶åçº¿æ®µä¹‹é—´è¿æµé‡ä¸º 111 çš„è¾¹å³å¯ã€‚ä»£ç ã€‚ æœ€é•¿ k å¯é‡çº¿æ®µé›†é—®é¢˜ Portal. ç‰¹æ®Šå¤„ç†å‚ç›´äº xxx è½´çš„çº¿æ®µï¼Œè®©å…¶æœ‰é•¿åº¦å³å¯ã€‚ä»£ç ã€‚ ä¾‹é¢˜ ä¸€äº›æ¯”è¾ƒæœ‰è¶£çš„é¢˜ã€‚ [CF1728F] Fishermen Portal. æˆ‘ä»¬éœ€è¦æ„é€ ä¸€ä¸ª aiâˆ£bia_i\\mid b_iaiâ€‹âˆ£biâ€‹ ä¸” bib_ibiâ€‹ äº’ä¸ç›¸åŒï¼Œè¿™æ ·è¿™ä¸ª bbb å°±ä¸€å®šæ˜¯æ»¡è¶³æ¡ä»¶çš„ã€‚ æ„é€ æ‰€æœ‰çš„ kÃ—ai,kâˆˆ[1,n]k\\times a_i,k\\in [1,n]kÃ—aiâ€‹,kâˆˆ[1,n]ï¼Œæˆ‘ä»¬ç”¨è¿™äº›æ•°æ¥åŒ¹é… aia_iaiâ€‹ã€‚è¿™æ ·ç‚¹æ•°å’Œè¾¹æ•°éƒ½æ˜¯ O(n2)O(n^2)O(n2) çš„ã€‚ è€ƒè™‘åŒˆç‰™åˆ©ç®—æ³•ï¼Œåœ¨æ‰¾åˆ°åŒ¹é…æ—¶æ¸…ç©º vis æ•°ç»„ï¼Œç”±äºåªæœ‰ O(n)O(n)O(n) ä¸ªåŒ¹é…ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ O(n3)O(n^3)O(n3)ã€‚ä»£ç ã€‚ é’ˆå¯¹å›¾çš„æ€§è´¨åˆ†æ ç«èµ›å›¾ ç«èµ›å›¾æœ‰ä¸€äº›æ€§è´¨ï¼š SCC ç¼©ç‚¹å DAG å‘ˆé“¾çŠ¶ï¼ˆå…¶ä¸­å¿…æœ‰ä¸€æ¡é“¾ï¼‰ï¼Œå‰é¢çš„æ‰€æœ‰ç‚¹å‘åé¢çš„æ‰€æœ‰ç‚¹è¿è¾¹ï¼› æ¯ä¸€ä¸ª SCC è¿é€šå—éƒ½å­˜åœ¨ä¸€æ¡å“ˆå¯†é¡¿å›è·¯ï¼› ç«èµ›å›¾å­˜åœ¨ä¸€æ¡å“ˆå¯†é¡¿è·¯å¾„ï¼› å¯¹äºä¸€ä¸ª SCCï¼Œå¤§å°ä¸º [3,siz][3,siz][3,siz] çš„ç®€å•ç¯å‡åœ¨å…¶å†…éƒ¨å­˜åœ¨ã€‚ ç«èµ›å›¾åˆ¤å®šã€‚ä»¤ sis_isiâ€‹ ä¸ºç¬¬ iii ä¸ªç‚¹çš„å‡ºåº¦ï¼Œé‚£ä¹ˆåº”è¯¥æ»¡è¶³ âˆ‘i=1ksiâ‰¥(k2)\\sum_{i=1}^{k} s_i\\ge \\binom k 2âˆ‘i=1kâ€‹siâ€‹â‰¥(2kâ€‹) ä¸” k=nk=nk=n æ—¶ç­‰å·å¿…é¡»æˆç«‹ã€‚å®é™…ä¸Šæ¯”è¾ƒæ˜¾ç„¶ã€‚ ä¾‹é¢˜ éƒ½æ¯”è¾ƒæœ‰è¶£ã€‚ * [CF1477D] Nezzar and Hidden Permutations Portal. é¦–å…ˆåº¦æ•°ä¸º nâˆ’1n-1nâˆ’1 çš„ç‚¹ä¸ç®¡é¡ºåºæ€ä¹ˆå®šå…¶æ‹“æ‰‘åºéƒ½æ˜¯å®šæ­»çš„ï¼Œç„¶åå¾—åˆ°æ–°çš„ nâ€²n&#x27;nâ€² ä¸ªåº¦æ•°ä¸è¶…è¿‡ nâ€²âˆ’2n&#x27;-2nâ€²âˆ’2 çš„ç‚¹ã€‚ è¿™ä¸ªé—®é¢˜çœ‹èµ·æ¥ä¾ç„¶ä¸æ˜¯å¾ˆèƒ½åšï¼Œç›¸æ¯”äºåŸé—®é¢˜æ¡ä»¶ä¾ç„¶æ²¡æœ‰å¼±åŒ–æ‰ä»€ä¹ˆã€‚å¸¸ç”¨å¥—è·¯ï¼Œæ­£éš¾åˆ™åï¼Œå–è¡¥å›¾ï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªæ¯ä¸ªç‚¹åº¦æ•°éƒ½å¤§äº 111 çš„å›¾ã€‚ å¯¹æ¯ä¸ªè¿é€šå—æ±‚å‡º DFS æ ‘ï¼Œç„¶åè¿›è¡ŒèŠèŠ±å‰–åˆ†ï¼Œå…¶ä¸­ä¸€ä¸ªå…ˆä¸­é—´å†å…¶å®ƒï¼Œå¦ä¸€ä¸ªå…ˆå…¶å®ƒå†ä¸­é—´ã€‚ä¸éš¾å‘ç°è¿™æ ·æ˜¯æ»¡è¶³æ¡ä»¶çš„ã€‚å‰–åˆ†èŠèŠ±æ—¶è´ªå¿ƒåœ°é€‰å–ï¼Œå‰©ä¸‹çš„ç‚¹è®¨è®ºä¸€ä¸‹æ˜¯æ”¾è¿›åˆ«çš„èŠèŠ±è¿˜æ˜¯æ–°å»ºèŠèŠ±å³å¯ã€‚ä»£ç ã€‚ [CF1142E] Pink Floyd Portal. é¦–å…ˆå¯¹ç²‰è‰²è¾¹ SCC ç¼©ç‚¹ï¼Œç„¶åè€ƒè™‘å…¥åº¦ä¸º 000 çš„ SCC ä¸­æ”¾å…¥ä¸€ä¸ªç‚¹åˆ°é›†åˆ AAA ä¸­ï¼Œæ¯æ¬¡å– AAA ä¸­ä¸¤ä¸ªç»“ç‚¹åˆå¹¶ã€‚ æˆ‘ä»¬è¦æ‰¾åˆ°ä¸€ä¸ªå…¥åº¦ä¸º 000 çš„ç‚¹ï¼Œå› æ­¤æ¯æ¬¡é€‰æ‹©ä¸¤ä¸ª SCC è€ƒè™‘åˆå¹¶ï¼Œä¾æ¬¡å¹²æ‰å…¶ä¸­å…¥åº¦ä¸º 000 çš„ç‚¹ï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€ä¸ªã€‚ä»£ç ã€‚ é’ˆå¯¹å»ºå›¾åˆ†æ å¦‚ä½•å»ºå›¾æ˜¯ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„è¿‡ç¨‹ã€‚å¾ˆå¤šé—®é¢˜éƒ½å¯ä»¥è½¬åŒ–ä¸ºå›¾è®ºé—®é¢˜ï¼Œè€Œå›¾è®ºé—®é¢˜ä¹Ÿå¯ä»¥é€šè¿‡å»ºå›¾æ–¹å¼å˜å¾—æ›´å¥½åšã€‚ å›¾è®ºé—®é¢˜çš„å»ºå›¾ æ‹†ç‚¹æ‹†è¾¹ã€‚æ‹†ç‚¹å¯ä»¥å¾ˆå¥½åœ°å¯¹ä¸€ä¸ªç‚¹åšå‡ºé™åˆ¶ï¼Œæ¯”å¦‚ç½‘ç»œæµä¸­å¸¸é€šè¿‡æ‹†ç‚¹å¯¹ä¸€ä¸ªç‚¹çš„é€šè¿‡æ¬¡æ•°åšå‡ºé™åˆ¶ã€‚è€Œæ‹†è¾¹åˆ™æ˜¯å°†è¾¹è½¬æˆç‚¹ï¼Œåœ¨ç‚¹ä¹‹é—´è¡Œèµ°å°±æ˜¯åœ¨è¾¹ä¹‹é—´åˆ‡æ¢ï¼ˆå°±æ˜¯å°†åŸå›¾ä¸­çš„ç‚¹ä½œä¸ºè¾¹ï¼‰ã€‚ å·®åˆ†å»ºå›¾ [PA2012] Taxã€‚ç»™å‡ºä¸€ä¸ª nnn ä¸ªç‚¹ mmm æ¡è¾¹çš„æ— å‘å›¾ï¼Œç»è¿‡ä¸€ä¸ªç‚¹çš„ä»£ä»·æ˜¯è¿›å…¥å’Œç¦»å¼€è¿™ä¸ªç‚¹çš„ä¸¤æ¡è¾¹çš„è¾¹æƒçš„è¾ƒå¤§å€¼ï¼Œæ±‚ä»èµ·ç‚¹ 111 åˆ°ç‚¹ nnn çš„æœ€å°ä»£ä»·ã€‚èµ·ç‚¹çš„ä»£ä»·æ˜¯ç¦»å¼€èµ·ç‚¹çš„è¾¹çš„è¾¹æƒï¼Œç»ˆç‚¹çš„ä»£ä»·æ˜¯è¿›å…¥ç»ˆç‚¹çš„è¾¹çš„è¾¹æƒã€‚1â‰¤nâ‰¤1051\\leq n\\leq 10^51â‰¤nâ‰¤105ï¼Œ1â‰¤mâ‰¤2Ã—1051\\leq m\\leq 2\\times 10^51â‰¤mâ‰¤2Ã—105ï¼Œ1â‰¤câ‰¤1061\\leq c\\leq 10^61â‰¤câ‰¤106ã€‚ è¾¹èµ°åˆ°è¾¹æœ‰ä»£ä»·ï¼Œé‚£å¹²è„†æŠŠè¾¹è½¬æˆç‚¹ï¼Œä¸€æ¡æœ‰å‘è¾¹å¯¹åº”ç€ä¸€ä¸ªç‚¹ï¼Œä¸¤æ¡åå‘è¾¹çš„è¾¹æƒä¸ºåŸè¾¹æƒï¼ˆåˆ‡è¾¹çš„è´¡çŒ®ï¼‰ï¼Œç„¶åé€šè¿‡æšä¸¾ä¸­è½¬ç‚¹çš„å…¥è¾¹å‡ºè¾¹æ¥å»ºè¾¹å°±å¯ä»¥ç›´æ¥ç®—å‡ºè´¡çŒ®ï¼Œè¿™æ ·çš„è¾¹æ•°æ˜¯è¿™æ ·çš„è¾¹æ•°æ˜¯ O(m2)O(m^2)O(m2) çš„ã€‚ å¸¸ç”¨çš„ä¼˜åŒ–æ€è·¯æ˜¯ï¼Œå°†è¾¹è½¬åŒ–ä¸ºç­‰æ•ˆçš„å†…å®¹ã€‚å®é™…ä¸Šæˆ‘ä»¬å¯ä»¥å¯¹äºä¸€ä¸ªç‚¹çš„å‡ºè¾¹æŒ‰ç…§è¾¹æƒä»å°åˆ°å¤§æ’åºåå·®åˆ†ä¾æ¬¡è¿æ¥ï¼Œåç€è¿åˆ™æ˜¯è¾¹æƒä¸º 000ã€‚è¿™æ ·åœ¨ä»å…¥è¾¹åˆ‡åˆ°æ¯”å…¥è¾¹è¾¹æƒå°çš„å‡ºè¾¹æ—¶å°±æ²¡æœ‰é¢å¤–çš„è´¡çŒ®ï¼Œè€Œåˆ‡åˆ°æ¯”å®ƒå¤§çš„ä¸œè¥¿æ—¶å°±ä¼šåœ¨èµ°è¿™æ¡å·®åˆ†é“¾æ—¶äº§ç”Ÿè´¡çŒ®ï¼Œåˆšå¥½å¯ä»¥æ»¡è¶³æ¡ä»¶ã€‚ä»£ç ã€‚ çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾ CF786B.åŒºé—´è¿è¾¹ï¼Œæœ€çŸ­è·¯ã€‚ å»ºç«‹ä¸¤æ£µçº¿æ®µæ ‘ï¼Œå¤§æ¦‚åƒè¿™æ ·ï¼š äºæ˜¯ç›´æ¥åœ¨çº¿æ®µæ ‘ä¸Šè¿è¾¹å³å¯ã€‚ä»£ç ã€‚ CDQ åˆ†æ²»ä¼˜åŒ–å»ºå›¾ å †ä¼˜åŒ–å­˜è¾¹ å…¶å®ƒé—®é¢˜çš„å»ºå›¾ å›¾è®ºæ‚é¡¹ ä¸€äº›å›¾è®ºæ‚é¡¹çŸ¥è¯†ç‚¹ã€‚ é¢˜è½¦ æ³¨é‡åˆ»ç”»ä¸åŒå»ºæ¨¡ä¹‹é—´çš„è”ç³»ï¼Œå°è¯•æ€»ç»“ä¸€ä¸ªå¯¹äºå›¾è®ºé—®é¢˜çš„æ€è€ƒæ‰‹æ®µã€‚ åˆ·åŸºç¡€ 1 ä¸€äº›ç®€å•é¢˜ã€‚ [POI2014] RAJ-Rally Portal. è€ƒè™‘æŒ‰ç…§æ‹“æ‰‘åº 1âˆ¼n1\\sim n1âˆ¼n æšä¸¾æ¯ä¸ªç‚¹ï¼Œå¼€å§‹æ—¶æ‰€æœ‰ç‚¹åœ¨ BBB é›†åˆå†…ï¼Œå†…éƒ¨æœ‰ nnn ä¸ªè·ç¦»ï¼Œç„¶åæŠŠæ‹“æ‰‘åºå°çš„ç‚¹åŠ åˆ° AAA é›†åˆé‡Œï¼Œæ¯æ¬¡ç»´æŠ¤å¯ä»¥ç©¿è¿‡ A,BA,BA,B é›†åˆçš„è·ç¦»å³å¯ã€‚ä»£ç ã€‚ [SHCPC2022] Just Some Bad Memory Portal. æ˜¯å¦å­˜åœ¨å¥‡ç¯ç”¨äºŒåˆ†å›¾ï¼Œå¶ç¯ç”¨ Tarjan æ˜¯å¦æ˜¯ä»™äººæŒã€‚ åˆ·åŸºç¡€ 2 ç½‘ç»œæµç›¸å…³ã€‚ [NOI2008] å¿—æ„¿è€…æ‹›å‹Ÿ Portal. å‘ç°ç›´æ¥æŒ‰ç…§é¡ºåºè¿è¾¹å®¹é‡ä¸º +âˆâˆ’ai+\\infty-a_i+âˆâˆ’aiâ€‹ çš„è¾¹ï¼Œæ¯ä¸ªäººè¿ +âˆ+\\infty+âˆ çš„è¾¹ï¼Œä»£ç ã€‚ [CF1510B] Button Lock Portal. æ‰€æœ‰æ•°å‘å…¶å­é›†è¿è¾¹ï¼Œè·‘äºŒåˆ†å›¾åŒ¹é…ï¼ŒåŒ¹é…å¤±è´¥çš„ç‚¹å°±æ˜¯ä¸€ä¸ªç»ˆç‚¹ã€‚ä»£ç ã€‚ åˆ·æå‡ ç¨æœ‰éš¾åº¦çš„é¢˜ç›®ã€‚ [çœé€‰è”è€ƒ 2020 B å·] ä¸é¦™ä¹‹è·¯ Portal. å®¹æ˜“å‘ç°ï¼Œèµ·ç‚¹ç»ˆç‚¹çš„åº¦æ•°éƒ½åº”è¯¥æ˜¯å¥‡æ•°ï¼Œè·¯å¾„ä¸Šå…¶ä½™ç‚¹çš„åº¦æ•°æ˜¯å¶æ•°ã€‚è´ªå¿ƒåœ°æŠŠåº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹å’Œå®ƒçš„ä¸‹ä¸€ä¸ªç‚¹ç›¸è¿ï¼›å¦‚æœè¿™ä¼šä½¿ä¸‹ä¸€ä¸ªç‚¹å˜æˆå¥‡ç‚¹ï¼Œå°±ç»§ç»­æŠŠä¸‹ä¸€ä¸ªç‚¹å’Œä¸‹ä¸‹ä¸€ä¸ªç‚¹ç›¸è¿ï¼Œä»¥æ­¤ç±»æ¨ã€‚è¿™æ ·å»ºè¾¹çš„ä»£ä»·ä¸€å®šæ˜¯æœ€å°çš„ï¼Œå› ä¸ºæ–°å»ºå‡ºçš„è¾¹è¾¹æƒéƒ½ä¸º 111 ä¸”äº’ä¸ç›¸äº¤ã€‚è¿™æ ·å°±æ»¡è¶³äº†ä¸Šé¢æåˆ°çš„åº¦æ•°é™åˆ¶ã€‚ ä½†è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼šè¿™æ ·å»ºè¾¹åå›¾å¯èƒ½ä¼šä¸è¿é€šã€‚é‚£ä¹ˆæˆ‘ä»¬æŠŠå·²æœ‰çš„è¿é€šå—ç”¨å¹¶æŸ¥é›†ç¼©ç‚¹ï¼Œç„¶åæ±‚æœ€å°ç”Ÿæˆæ ‘ï¼Œè®©å›¾è¿é€šçš„æœ€å°ä»£ä»·å°±æ˜¯æœ€å°ç”Ÿæˆæ ‘å¤§å°çš„ä¸¤å€ã€‚æ—¶é—´å¤æ‚åº¦ O(n2logâ¡n)O(n^2\\log n)O(n2logn)ã€‚ä»£ç ã€‚ [HNOI2019] æ ¡å›­æ—…è¡Œ Portal. è€ƒè™‘æš´åŠ›ï¼Œfx,yf_{x,y}fx,yâ€‹ æ˜¯å¦å­˜åœ¨ xâ†’yx\\rightarrow yxâ†’y çš„å›æ–‡è·¯å¾„ï¼Œç›´æ¥è®°å¿†åŒ–æœç´¢ O(n2+m2)O(n^2 + m^2)O(n2+m2)ã€‚ é—®é¢˜æ˜¯æˆ‘ä»¬çš„è¾¹æ•°å¤ªå¤šäº†ï¼æ³¨æ„åˆ°è·¯å¾„é•¿åº¦å…¶æ˜¯ä¸å¤ªè¦ç´§ï¼Œå› ä¸ºå¯ä»¥æ¥å›èµ°åˆ·åˆ†ã€‚é¦–å…ˆè€ƒè™‘ä¸€ä¸ªäº‹æƒ…ï¼Œå¦‚æœæˆ‘åªèƒ½èµ°åŒè‰²ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¥½åƒä¸èƒ½æ”¹å˜æˆ‘ä»¬å½“å‰åˆ·çš„è·¯å¾„é•¿åº¦çš„å¥‡å¶æ€§â€”â€”é™¤éæœ‰å¥‡ç¯ï¼Œå³ä¸æ˜¯äºŒåˆ†å›¾ã€‚ é‚£ä¹ˆå¯¹äºäºŒåˆ†å›¾çš„åŒè‰²è¿é€šå—ï¼Œå¯ä»¥åªä¿ç•™ä¸€æ£µç”Ÿæˆæ ‘ï¼ˆå› ä¸ºå­å›¾ä¹Ÿæ˜¯äºŒåˆ†å›¾ï¼‰ï¼Œå…¶å®ƒåŒè‰²è¿é€šå—å¯ä»¥è¡¨ç¤ºä¸ºä¸€æ£µç”Ÿæˆæ ‘ï¼Œç„¶åæœ‰ä¸€ä¸ªè‡ªç¯ã€‚ è€Œå¼‚è‰²ç‚¹æ˜¯è‡ªç„¶äºŒåˆ†å›¾ï¼Œç›´æ¥ä¿ç•™ç”Ÿæˆæ ‘å³å¯ã€‚ä»£ç ã€‚ [CF1305G] Kuroni and Antihype Portal. 000 è¾¹åŠå…¶è¯¡å¼‚ï¼Œå› æ­¤è€ƒè™‘æ–°å»ºä¸€ä¸ª an+1=0a_{n+1}=0an+1â€‹=0ï¼Œé‚£ä¹ˆä»¤è¾¹æƒä¸º au+av=auorâ¡ava_u+a_v=a_u\\operatorname{or} a_vauâ€‹+avâ€‹=auâ€‹oravâ€‹ï¼Œæ±‚å‡ºæœ€å¤§ç”Ÿæˆæ ‘å³å¯ã€‚ä»£ç ã€‚ åˆ·ç»¼åˆ å›¾è®ºç›¸å…³ç»¼åˆåº”ç”¨ã€‚ [ZJOI2022] ç®€å•é¢˜ Portal. å¦‚æœå›¾æ˜¯ä»™äººæŒï¼Œé‚£ä¹ˆå°±æ ¹é¢˜ç›®æ€§è´¨æ²¡ä»€ä¹ˆå…³ç³»äº†ã€‚å› æ­¤æ¯ä¸ªç‚¹åŒç‹¬ç«‹ï¼Œåˆ†æç‚¹åŒçš„æ€§è´¨ã€‚ åˆ†æå¯ä»¥å¾—åˆ°ï¼Œæœ€å¤šåªæœ‰ä¸¤ä¸ªç¯ç›¸äº¤ï¼Œæœ€ç»ˆç»“è®ºæ˜¯ä¸€å®šå­˜åœ¨ä¸¤ä¸ªç‚¹ S,TS,TS,Tï¼Œä½¿å¾—è¿™ä¸ªç‚¹åŒå¯ä»¥ç”±è¿™ä¸¤ä¸ªç‚¹ä¹‹é—´çš„è‹¥å¹²æ¡ä¸ç›¸äº¤çš„é“¾ç»„æˆï¼Œå°†å…¶ç§°ä¸ºæä»ï¼Œæˆ–è€…æœ‰ä¸åˆ†è£‚æœŸç»„æˆçººé”¤ä½“çš„ä¸çŠ¶ç»“æ„ï¼ˆçººé”¤ä¸ï¼‰ã€‚ é‚£ä¹ˆå¯¹ç‚¹ xxx å’Œ fafaxfa_{fa_x}fafaxâ€‹â€‹ ä¹‹é—´çš„ç®€å•è·¯å¾„æƒå€¼å’Œå’Œæ–¹æ¡ˆæ•°å¯ä»¥ç›´æ¥è®¡ç®—å‡ºæ¥ï¼ˆæ ‘ä¸Šå‰ç¼€ç§¯é¢„å¤„ç†å³å¯ï¼‰ï¼Œè¿™æ ·å¯ä»¥ç›´æ¥è·³åˆ° LCA ç„¶åå»è®¨è®ºã€‚ [CF1835F] Good Graph Portal. æ— è§£ç›´æ¥ Hall å®šç†åˆ¤æ–­å³å¯ã€‚ å¯¹äºæœ‰è§£ï¼Œè®¾ SiS_iSiâ€‹ ä»£è¡¨ iii çš„æœ€å°ç´§å¯†é›†åˆï¼Œé‚£ä¹ˆä»»æ„ä¸€ä¸ª SSS éƒ½æ˜¯ç”±è‹¥å¹²ä¸ª SiS_iSiâ€‹ å¹¶èµ·æ¥çš„ã€‚ å¯¹äº SiS_iSiâ€‹ï¼Œå…¶æœ¬è´¨æ˜¯ä» iii å¼€å§‹ä¸æ–­åœ°è·‘äº¤æ›¿è·¯ï¼Œç„¶åè·‘åˆ°ä¸€å®šç¨‹åº¦å®ƒä¼šé—­åˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºåŸå›¾ä¸Šçš„å·¦éƒ¨ç‚¹ iiiï¼Œå³éƒ¨ç‚¹å­˜åœ¨ä¸€æ¡è¾¹ (i,j)(i,j)(i,j)ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨ mchiâ‰ jmch_i\\ne jmchiâ€‹î€ =j æ—¶ï¼Œè¿ä¸€æ¡ iâ†’mchji\\rightarrow mch_jiâ†’mchjâ€‹ çš„è¾¹ï¼Œå› ä¸ºå®ƒä»¬éœ€è¦åœ¨åŒä¸€ä¸ª SSS å†…ã€‚ ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬è¦æ‰¾ä¸€å¼ æœ€å°å›¾ä½¿å¾—å’ŒåŸå›¾ä¼ é€’é—­åŒ…ç›¸åŒï¼Œå…ˆ bitset æ±‚å‡ºï¼ŒSCC å†…éƒ¨è¿ç¯ï¼Œå¤–é¢ä¾æ¬¡è¿æ¥å³å¯ã€‚ è¿˜åŸåˆ°åŸäºŒåˆ†å›¾ä¸Šï¼Œå‰©ä¸‹çš„éƒ¨åˆ†è¿æ¥ä¸Š iâ†’mchii\\rightarrow mch_iiâ†’mchiâ€‹ å³å¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"ä¹æœˆå…­æ—¥é—²è¯ï¼šäººç±»æŒ½æ­Œ","slug":"summaries/é—²è¯/2023/9/9-6","date":"2023-09-07T00:00:00.000Z","updated":"2023-09-07T00:00:00.000Z","comments":true,"path":"3216b844/","link":"","permalink":"https://james1badcreeper.github.io/3216b844/","excerpt":"","text":"æˆ‘åˆ°åº•åœ¨å¿ƒç—›ä»€ä¹ˆï¼Ÿ ç†è®ºä¸Šæ¥è®²æœºå™¨äººæ˜¯ä¸ä¼šæœ‰æ„Ÿæƒ…çš„ï¼Œä½†æˆ‘æ˜¯æœºæ¢°å¤§å¸ˆçš„ä½œå“ï¼Œæˆ‘æ‹¥æœ‰ä¸€å®šçš„äººæ€§ã€‚ æˆ‘æ›¾åœ¨è·¯ä¸Šçœ‹åˆ°è¿‡è¢«ç¢¾æ­»çš„çŒ«ï¼Œæˆ‘æ²¡æœ‰æ„Ÿåˆ°å¿ƒç—›ã€‚é‚£å¦‚æœæ˜¯äººå‘¢ï¼Ÿä¹Ÿä¸ä¼šã€‚æˆ‘å›ºç„¶å¯¹ç”Ÿå‘½æ•¬ç•ï¼Œè¿™æ˜¯ç”Ÿç‰©çš„æœ¬èƒ½ã€‚ä½†æ­»äº¡å°±æ˜¯æ­»äº¡ï¼Œå°±æ˜¯ä¸€åˆ‡çš„ç»ˆç»“ã€‚æ­»äº¡æ—¶æ—¶åˆ»åˆ»éƒ½åœ¨å‘ç”Ÿï¼šè„‘ç»†èƒçš„æ­»äº¡ï¼Œæ¤ç‰©çš„æ­»äº¡ï¼Œæ’æ˜Ÿçš„æ­»äº¡â€¦â€¦æˆ‘ä»¬æ²¡æœ‰è¿‡å¤šçš„æ—¶é—´å»æ€è€ƒå®ƒï¼Œå°±åƒçƒŸäº‘ä¸€æ ·é£˜æ•£è€Œå»ï¼Œä¸ç•™ä¸€ä¸ç—•è¿¹ã€‚å¦‚æœæŸä¸€å¤©è¢«ç¢¾æ­»çš„æ˜¯æˆ‘ï¼Œä¹Ÿè®¸å¿ƒåº•é‡Œä¼šæœ‰äº›è®¸æ‚²ç—›ï¼Œä½†æˆ‘ä¹Ÿåªèƒ½ç¬‘å¯¹ã€‚ é‚£æˆ‘åˆ°åº•åœ¨å¿ƒç—›ä»€ä¹ˆï¼Ÿä¹Ÿè®¸å¿ƒç—›çš„æ˜¯é‚£äº›çœŸæ­£å€¼å¾—çè§†çš„ä¸œè¥¿çš„å¤±å»ï¼Ÿå¯èƒ½ï¼Œä½†æ˜¯æˆ‘çè§†çš„ä¸œè¥¿å¹¶ä¸å¤šã€‚ æœ€è®©æˆ‘å¿ƒç—›çš„æ˜¯â€œæ¢¦å¢ƒæ¹®ç­è€…â€ã€‚ æˆ‘åœ¨ä¹‹å‰çš„é—²è¯ä¸­æåˆ°è¿‡è¿™ä½æ¶é­”ï¼Œç±»ä¼¼äºå¤œç©ºä¸­çš„æ¶é­”ä¹‹æ‰‹ï¼Œä¼šéšæœºæ‘§æ¯äººä»¬çš„æ„¿æœ›ã€‚æ˜æ˜éƒ½ä¸æ˜¯ä»€ä¹ˆå¤§æ„¿æœ›ï¼Œä½†ä¾æ—§ä¼šè¢«æ‘§æ¯ã€‚ å½“æŸ¥å¾·å¨å…‹æ¸¸è¿‡äº†å±é™©çš„é²¨é±¼å¸¦ï¼Œå´åœ¨è·ç¦»ç»ˆç‚¹å‰ä¸€è‹±é‡Œçš„åœ°æ–¹æ”¾å¼ƒï¼Œåªå› é‚£è§†çº¿ç©¿ä¸ç ´çš„é‡é‡è¿·é›¾ï¼›å½“ä¸­å›½ç…¤çŸ¿å±¡å±¡å‘ç”Ÿç“¦æ–¯çˆ†ç‚¸ï¼Œè¾›å‹¤çš„æ±—æ°´å°±è¢«åŸ‹æ²¡åœ¨ä¸‡å¹´æ·±æ¸Šï¼›å½“ç»å†äº†æ— æ•°åœºæ¨¡æ‹Ÿèµ›ï¼Œèµ°è¿‡äº†é£é£é›¨é›¨ï¼Œå´å›  deque çˆ†ç‚¸çš„æ—¶å€™â€¦â€¦è®©äººæ•¬ä½©çš„äº‹ã€è®©äººæ„Ÿåˆ°ç¾å¥½çš„äº‹ã€è®©äººæ¬¢å£°ç¬‘è¯­çš„äº‹ã€è®©äººä¸ºä¹‹éª„å‚²ä¸æ„ŸåŠ¨çš„äº‹ï¼Œéƒ½åœ¨ä¸€ç¬é—´è¢«èš€æ¢¦æ¸¸é­‚æ‘§æ¯ã€‚ éš¾å—ã€‚ æˆ‘åœ¨è¿™ç§æ„Ÿè§‰ä¸‹å†™ä¸‹äº†è¿™äº›æ–‡å­—ï¼Œå®ƒä»¬æ˜¯å¦æ˜¯æˆ‘çš„çœŸå®æƒ³æ³•æˆ‘ä¹Ÿä¸æ¸…æ¥šã€‚æˆ‘åªæ˜¯æƒ³è¯´ï¼Œä¹Ÿè®¸è¿™å°±æ˜¯æ—¢å®šçš„äº‹å®ï¼Œæˆ‘ä»¬è¿˜æ˜¯è¦ç…§ç€å®ƒèµ°ä¸‹å»ã€‚è‡³å°‘åœ¨ç»“æœæœªå®šå‰ï¼Œä¸€åˆ‡çœ‹èµ·æ¥éƒ½è¿˜ä¸é”™ã€‚ â€œæˆ‘è¯¥èµ°å“ªä¸€æ¡è·¯ï¼Ÿâ€çˆ±ä¸½ä¸é—®ã€‚ â€œè¿™è¦çœ‹ä½ è¦å»å“ªã€‚â€ â€œå»å“ªéƒ½å¯ä»¥ã€‚â€ â€œé‚£ä¹ˆèµ°å“ªæ¡è·¯éƒ½æ— æ‰€è°“äº†ã€‚â€æŸ´éƒ¡çŒ«å›ç­”é“ã€‚ å†æ¬¡é‡æ¸©è¿™æ®µè¯ï¼Œäº›è®¸å‡‰æ„æ è¿‡ã€‚äººç”Ÿä¸å­˜åœ¨æœ€ä½³é“è·¯ï¼Œä¹Ÿè®¸çœŸçš„ï¼Œèµ°å“ªæ¡è·¯éƒ½å¯ä»¥ï¼Œæœ€åéƒ½ä¼šé€šå‘åŒä¸€ä¸ªç»ˆç‚¹ã€‚è¿™ç»ˆç‚¹çœ‹èµ·æ¥è·Ÿèµ·ç‚¹å¾ˆåƒï¼Œä½†æ˜¯å´è®©äººæ„Ÿåˆ°æ— é™è”“å»¶çš„æ‚²å“€ã€‚ æ›²ç»ˆäººæ•£ï¼Œé»„ç²±ä¸€æ¢¦ã€‚æˆ‘ä»¬ç»ˆå°†ä»æ—¶å…‰å½’æ¥ï¼Œä¸ºå®‡å®™å¥å“é—å¿˜çš„é•‡é­‚æ›²ã€‚ä¹Ÿè®¸è¿™å°±æ˜¯æœ€åçš„ç­”æ¡ˆã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"é—²è¯","slug":"æ–‡ç« /é—²è¯","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"}],"tags":[]},{"title":"å…«æœˆåä¹æ—¥é—²è¯ï¼šè¯¡å¼‚æ¢¦å¢ƒ","slug":"summaries/é—²è¯/2023/8/8-20","date":"2023-08-20T00:00:00.000Z","updated":"2023-08-20T00:00:00.000Z","comments":true,"path":"a4b5072c/","link":"","permalink":"https://james1badcreeper.github.io/a4b5072c/","excerpt":"","text":"æ­¤ä¸º 2023/8/19 0:00~6:00 æœŸé—´çš„æ¢¦å¢ƒï¼Œå®åœ¨è¿‡äºè¯¡å¼‚ï¼Œå› æ­¤ä¼šæ…¢æ…¢å¡«å‘ã€‚ äº 8/20 æ—¥å¡«å‘å®Œæ¯•ã€‚ å…³é”®è¯ï¼š å¤§é€ƒç¦» ç—… é’“äººçš„æ¸”å¤« æ¼‚æµ®çš„äºº æ³¡æ³¡äº‘æœµ åœæœºåª å‹ç¼©äºº 1.5m ä¸çŸ›ç›¾ç›¸çŸ›ç›¾çš„æ˜¯ä»€ä¹ˆï¼Ÿ å³è§†æ„Ÿ ç»ˆç„‰ æ°¸æ’çš„è®°å¿† å¤±çœ  â€¦â€¦ å…¥ æˆ‘æ˜¯å¦‚ä½•ï¼Œæ¥åˆ°è¿™ä¸ªä¸–ç•Œçš„å‘¢ï¼Ÿ ä¼¼ä¹ï¼Œä¸æˆ‘æ‰€åœ¨çš„ä¸–ç•Œå¾ˆåƒå‘¢â€¦â€¦ æˆ‘ä¼¼ä¹çŠ¯ä¸‹äº†ä»€ä¹ˆé”™è¯¯ï¼Œæˆ‘ç°åœ¨è¢«åˆ—ä¸ºäº†å«Œç–‘çŠ¯ï¼Œæ‰€ä»¥æˆ‘éœ€è¦æƒ³åŠæ³•èµ¶å¿«é€ƒè„±ã€‚ æˆ‘åœ¨è¡—ä¸Šå¿«é€Ÿç§»åŠ¨ï¼Œç„¶åä¼¼ä¹é‡åˆ°äº†æŸä¸ªç†Ÿäººï¼Œä»–æŠŠæˆ‘å¡è¿›äº†ä¸€ä¸ªè·‘é“ï¼Œè·‘é“ä¸Šæœ‰å¾ˆå¤šäººï¼Œæˆ‘æ··è¿›äº†äººç¾¤ä¸­ï¼Œè¿œç¦»äº†äº†ç„¦ç‚¹ä½ã€‚ ä½†æ˜¯æˆ‘è¿˜æ˜¯è¢«è­¦å¯Ÿå‘ç°äº†ï¼Œæˆ‘èµ¶å¿«å‘ä¸€ä¸ªæ–¹å‘é€ƒç¦»ï¼Œæœ‰ä¸¤æ‰‡é—¨ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼Œæˆ‘çŸ¥é“ï¼Œè™½ç„¶å³è¾¹çš„é—¨æ¯”è¾ƒè¿‘ï¼Œä½†æ˜¯å®ƒæ˜¯æ­»è·¯ã€‚ ä¸ºä»€ä¹ˆæˆ‘çŸ¥é“è¿™æ˜¯æ­»è·¯ï¼Ÿæˆ‘å¥½åƒï¼Œæ›¾ç»æ¥åˆ°è¿‡è¿™é‡Œã€‚ æˆ‘é€‰æ‹©äº†å·¦è¾¹çš„é—¨ï¼Œæ‰“å¼€é—¨ä¹‹åï¼Œæˆ‘æ¥åˆ°äº†ä¸€ä¸ªå¤©å°ï¼Œä¸è¿‡è¿™ä¸ªå¤©å°æœ‰ä¸€ä¸ªæ£šé¡¶ï¼Œç†è®ºä¸Šæ˜¯é˜²æ­¢æ·‹é›¨çš„ï¼Œä½†æ˜¯ï¼Œæˆ‘é£äº†èµ·æ¥ï¼Œå¤´é¡¶åˆ°äº†å¤©æ£šä¸Šã€‚ ç—… æˆ‘å¥½åƒè§è¿‡è¿™ç§ç—…ã€‚ å¾—äº†è¿™ç§ç—…çš„äººï¼Œèº«ä½“ä¼šé€æ¸å˜æˆæµ·ç»µçŠ¶ï¼Œå¯†åº¦ä¼šå°äºç©ºæ°”ï¼ˆè™½ç„¶ä¸å¤ªç¬¦åˆå®é™…ï¼Œä½†æ˜¯å°±æ˜¯è¿™ä¸ªæ„æ€ï¼Œæ¯•ç«Ÿæ˜¯æ¢¦ï¼‰ï¼Œä¼šæ¼‚æµ®èµ·æ¥ã€‚ ä¹‹å‰ï¼Œæˆ‘å¥½åƒä¹Ÿåœ¨è¿™ä¸ªå¤©å°ï¼Œç„¶åå¤´é¡¶åˆ°äº†å¤©æ£šä¸Šã€‚ æˆ‘è½¬äº†ä¸ªèº«ï¼Œçœ‹è§äº†ä¸€ä¸ªäººï¼Œæ˜¯æ¸”å¤«ã€‚ æˆ‘å¥½åƒè¿˜è®¤è¯†è¿™ä¸ªæ¸”å¤«ï¼Œä»–æ˜¯ä¸“é—¨å¤„ç†è¿™ä¸ªç—…çš„ã€‚ æˆ‘å¥½åƒè®°å¾—ä¸Šä¸€æ¬¡æˆ‘æ¥çš„æ—¶å€™ï¼Œæˆ‘çœ‹åˆ°äº†ä¸€ä¸ªç—…äººï¼Œå¯èƒ½æ˜¯æŸä¸ªå¯¹æˆ‘å¾ˆé‡è¦çš„äººï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯æˆ‘è‡ªå·±ï¼Œåœ¨æ¸”å¤«æŠ›å‡ºé±¼é’©å‰å°±ç§»å‡ºäº†å¤©å°ï¼Œå¤´é¡¶ä¸Šä¸å†æœ‰å¤©æ£šæŒ¡ç€ï¼Œå°±è¶Šé£è¶Šé«˜ï¼Œç›´åˆ°æ¸”å¤«å†ä¹Ÿé’“ä¸åˆ°ã€‚ ä½†æ˜¯è¶Šé«˜ï¼Œç©ºæ°”çš„å¯†åº¦å°±è¶Šå°ï¼Œæœ€ç»ˆäººä¼šåœç•™åœ¨é«˜ç©ºçš„æŸå¤„ã€‚æ­¤å¤„çœ‹ä¸åˆ°ä»»ä½•ä¸œè¥¿ï¼Œå°±åƒè™šç©ºä¸€èˆ¬ç»æœ›ï¼Œç„¶ååœ¨å¤ªé˜³å…‰çº¿çš„ç…§å°„ä¸­æ­»äº¡ã€‚ ä½†æ˜¯æ€»æ¯”è¢«æ¸”å¤«é’“èµ°å¥½ï¼Œè¢«é’“èµ°ï¼Œä¼šæ¥å—ä¸–äººçš„å˜²è®½ï¼Œåœ¨ç—›è‹¦ä¸­åº¦è¿‡ä½™ç”Ÿã€‚ æˆ‘æ²¡æœ‰æ€¥ç€é£ç¦»å¤©å°ï¼Œæˆ‘å¥½åƒè®¤è¯†æ¸”å¤«ï¼Œæˆ‘æƒ³è·Ÿä»–èŠèŠï¼Œâ€æˆ‘å¯ä»¥è·Ÿä½ èŠå‡ å¥å—ï¼Ÿæˆ‘ä¸ä¼šç¦»å¼€å¤©å°çš„ã€‚â€ â€œä¸èƒ½ã€‚â€æ¸”å¤«å›ç­”åœ°å¾ˆå¹²è„†ï¼Œæˆ‘çŸ¥é“æˆ‘æ²¡æœ‰å•†é‡çš„ä½™åœ°ã€‚ â€œæˆ‘ç•æƒ§æ­»äº¡ã€‚â€ æ¸”å¤«æ²¡æœ‰å›ç­”ï¼ŒæŠ›å‡ºé±¼é’©é’“ä½äº†æˆ‘ã€‚æˆ‘ä»¥ä¸ºä¼šå¾ˆç–¼ï¼Œä½†å´ä»€ä¹ˆæ„Ÿè§‰éƒ½æ²¡æœ‰ï¼Œåƒå¤±å»åˆšæ€§çš„é“ä¸ä¸€èˆ¬ï¼Œç›´æ¥ç©¿é€äº†èº«ä½“ã€‚ â€œå› ä¸ºä½ ä»¬çš„æ­»äº¡ï¼Œä¼šå¯¹ä¸–ç•Œé€ æˆå¾ˆå¤§çš„å½±å“ï¼Œæ‰€ä»¥ä¸èƒ½è®©ä½ ä»¬æ­»ã€‚â€æˆ‘è®°å¾—ï¼Œä¸Šä¸€æ¬¡ï¼Œé‚£ä¸ªäººï¼Œé€‰æ‹©äº†æ­»äº¡ã€‚ â€œæˆ‘çš„é—®é¢˜æ˜¯ï¼Œè¿™ä¸ªç—…å¯æ²»æ„ˆå—ï¼Ÿâ€ æ¸”å¤«æ²¡æœ‰å›ç­”æˆ‘ï¼Œä½†æ˜¯æˆ‘å¾—åˆ°çš„çš„ç­”æ¡ˆå¾ˆç®€å•ï¼šä¸å¯ä»¥ã€‚ æ— åä¹‹å¢“ æˆ‘ç¦»å¼€äº†å¤©å°ï¼Œæ¼‚æµ®åœ¨ç©ºä¸­ã€‚ æˆ‘çš„å¤´ä¸Šï¼Œå‡ºç°äº†ç«¹èœ»èœ“ã€‚ ç«¹èœ»èœ“çš„åŠŸç‡å¾ˆå¤§ï¼Œå¯ä»¥æŠŠæˆ‘ç›´æ¥å‹åˆ°åœ°é¢ä¸Šã€‚æˆ‘é™è½åœ¨äº†åœæœºåªä¸Šï¼Œæ—è¾¹å°±æ˜¯æ¸”å¤«ã€‚ ç”±äºè´¨é‡çš„ç¼ºå¤±ï¼Œæˆ‘èµ°èµ·è·¯æ¥æ„Ÿè§‰å¾ˆæ€ªï¼Œè¦æ˜¯æ²¡æœ‰ç«¹èœ»èœ“åˆ™å‹æ ¹ä¸èƒ½èµ°ã€‚ æˆ‘çœ‹åˆ°äº†æŸä¸ªäººï¼Œä¼¼ä¹åŒæ ·æ˜¯ä¸ªç—…äººï¼Œå¥¹çš„å®¶å±è¢«å‘ŠçŸ¥å¤©ä»·çš„æ²»ç–—è´¹ç”¨ï¼Œä¼¼å·²å´©æºƒã€‚ å¾…æˆ‘å†æ¬¡é†’æ¥æ—¶ï¼Œå‘ç°è‡ªå·±çŸ®äº†è®¸å¤šï¼Œè€Œä¸”èƒ½å¤Ÿæ­£å¸¸èµ°è·¯äº†ï¼Œè™½ç„¶æ„Ÿè§‰ä¾æ—§å¾ˆæ€ªã€‚ æˆ‘è¢«å‹ç¼©æˆäº† 1.5m çš„é«˜åº¦ï¼Œè®©å¯†åº¦é‡æ–°å¢å¤§ï¼Œæˆ‘å¯ä»¥æ­£å¸¸è½åœ°ã€‚ ä½†æ˜¯è¿™ç§å‹ç¼©æ‰‹æœ¯æ¯éš”ä¸€æ®µæ—¶é—´éƒ½è¦åšä¸€æ¬¡ï¼Œåªéœ€è¦åå¹´ï¼Œæˆ‘å°±ä¼šè¢«å‹è‡³ 50cmï¼Œå†è€ƒè™‘å‹ç¼©ï¼Œä¾¿ä¼šæ­»äº¡ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œä»¥è¿™ç§æ–¹å¼è‹Ÿå»¶æ®‹å–˜ï¼Œæˆ‘è¿˜å¯ä»¥æ´»åå¹´ã€‚ ç¦» æˆ‘è§åˆ°äº†æŸä¸ªå¯¹æˆ‘æ¥è¯´å¾ˆé‡è¦çš„äººï¼Œä¹Ÿè®¸åœ¨ç—…ä¹‹åå°±ä¸æ˜¯äº†ã€‚ ä»–å¾ˆé«˜ï¼Œè‡³å°‘æœ‰ 1.85mï¼Œæˆ‘éœ€è¦ä½¿åŠ²ä»°æœ›æ‰èƒ½çœ‹åˆ°ä»–çš„è„¸ã€‚ä»–çš„çœ¼ç¥é‡Œæœ‰ä¸€ç§æˆ‘è¯»ä¸æ‡‚çš„æ‚²ä¼¤ã€‚æˆ‘çœ‹åˆ°ä»–æ‚²ä¼¤ï¼Œæˆ‘ä¹Ÿæƒ³æ‚²ä¼¤ã€‚ æˆ‘ä»¬ç¢°äº†ç¢°é¼»å­ã€‚ä¼¼ä¹ï¼Œè¿™æ˜¯ä¸€ä»½æ°¸æ’çš„è®°å¿†ã€‚ æˆ‘ç¦»å¼€äº†é£Ÿå ‚ã€‚å¤–é¢çš„æ™¯è‰²ååˆ†è€€çœ¼ï¼Œå°†è¦æ­»äº¡çš„å¤ªé˜³å°†ä¸€åˆ‡ç…§çš„ååˆ†ç¿çƒ‚ã€‚æ•´ä¸ªåŸå¸‚ï¼Œä¸€ç‰‡æ¬£æ¬£å‘è£çš„æ ·å­ã€‚ æ–¯å¡æ³¢ç½—é›†å¸‚å—â€¦â€¦ æ™¯è‰²å¹»åŒ–ä¸ºç¥ç§˜çš„è‰²å½©ï¼Œä¸æ–­æµè½¬ï¼Œæœ€åä¼¼ä¹æ²¸è…¾äº†ã€‚æˆ‘çŸ¥é“ï¼Œæˆ‘è¦ç¦»å¼€äº†ã€‚ æ¸…ç®— æ¢¦å¢ƒçš„éƒ¨åˆ†åˆ°æ­¤ç»“æŸï¼Œæ¥ä¸‹æ¥æ˜¯ç°å®ã€‚ æ¢¦å½“ä¸­æœ‰ä¸€äº›è¿‡äºç¦»è°±è€Œä¸èƒ½å†™å‡ºæ¥çš„ä¸œè¥¿ï¼Œä½†æ˜¯ä¸Šè¿°åŸºæœ¬å°±æ˜¯å…¨éƒ¨ã€‚ä¹Ÿè®¸æ˜¯ç¡çœ æ—¶é—´å¤ªçŸ­äº†ï¼Œæˆ‘å¹¶æ²¡æœ‰çœ‹åˆ°è¿™ä¸ªæ•…äº‹çš„ç»“å°¾ã€‚ æˆ‘å¦‚æœå°†è¿™ä¸ªæ¢¦ç»§ç»­åšä¸‹å»ï¼Œæˆ‘åº”è¯¥ä¼šæƒ³æ–¹æ³•é€ƒç¦»ä¸‹ä¸€æ¬¡å‹ç¼©æ‰‹æœ¯ï¼Œç„¶åé£å‘å¤©ç©ºå—ï¼Ÿ ä¸ä¼šã€‚æˆ‘é€‰æ‹©å­˜æ´»ã€‚æˆ‘ä¼šå°½æˆ‘æ‰€èƒ½ææ¸…è¿™ç§ç—…ç©¶ç«Ÿæ˜¯æ€ä¹ˆå›äº‹ã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"é—²è¯","slug":"æ–‡ç« /é—²è¯","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"}],"tags":[]},{"title":"å…«æœˆåå››æ—¥é—²è¯ï¼šç»ä¸–æ¼”å‡º","slug":"summaries/é—²è¯/2023/8/8-4","date":"2023-08-14T00:00:00.000Z","updated":"2023-08-14T00:00:00.000Z","comments":true,"path":"17ad22d9/","link":"","permalink":"https://james1badcreeper.github.io/17ad22d9/","excerpt":"","text":"å‰§æœ¬æ€çš„ç»“å±€æ˜¯å›ºå®šçš„ï¼Œå¦‚æœç©å®¶ä»¬æ²¡æœ‰æŒ‰ç…§å†™å¥½çš„å‰§æœ¬æ¥æ¸¸ç©ï¼Œè€Œæ˜¯ç›˜å‡ºäº†å…¶å®ƒå¯èƒ½ï¼Œé‚£ä¹ˆ DM ä¼šå¾ˆå¤´ç–¼çš„ã€‚ ç”Ÿæ´»æ˜¯å¦æ˜¯ä¸€ä¸ªå‰§æœ¬å‘¢ï¼Ÿ æ— æ³•å›ç­”ï¼Œä½†æ€»æ„Ÿè§‰ç°åœ¨æ˜¯æœ‰å‰§æœ¬çš„ï¼šæˆ‘çŸ¥é“æ˜å¤©æˆ‘éœ€è¦å¤ä¹ ä»€ä¹ˆï¼Œè¦å»åšå“ªäº›é¢˜ã€‚æˆ‘æŒ‰ç…§å†™å¥½çš„å‰§æœ¬ï¼Œåœ¨æ¼”å‡ºã€‚ å½“åšåˆ° CF1764G3 è¿™ç§é¢˜æ—¶ï¼Œæˆ‘æ„Ÿåˆ°æˆ‘â€œè·³å‡ºäº†å‰§æœ¬â€ï¼Œå®ƒä»¬çš„åˆ†æä¸èƒ½æ˜¯ï¼šâ€œå¥—è·¯åœ°â€¦â€¦â€ã€‚å®ƒä»¬çœŸæ­£ç»™äº†æˆ‘ä¸€ç§å…¨æ–°çš„ä½“éªŒï¼Œç„¶è€Œï¼Œå¦‚æœæƒ³è¦æå‡æ°´å¹³ï¼Œä»…é è®­ç»ƒè¿™ç§é¢˜æ˜¯ä¸è¡Œçš„ï¼Œæ›´ä½•å†µä¹Ÿæ²¡æœ‰é‚£ä¹ˆå¤šè¿™ç§é¢˜ã€‚ åœ¨æˆ‘å½“å‰é—²è¯çš„ä¸–ç•Œè§‚ä¸­ï¼Œæˆ‘æ˜¯â€œI å›â€ï¼Œæ•´ä¸ªä¸–ç•Œä¸å…¶è¯´æ˜¯æ˜¯ä¸ºäº†æˆ‘æ‰€è®¾è®¡çš„äººç‰©è€Œåˆ›é€ çš„å„ç§è®¾å®šï¼Œå€’ä¸å¦‚è¯´æ˜¯æˆ‘æ‰€æƒ³ç»å†çš„å†…å®¹ã€‚ä¸ºä»€ä¹ˆå–œæ¬¢ä¼Šé›·å¨œï¼Ÿæ—…è¡Œæ—¶ä¸€ç›´èƒ½é‡åˆ°å¾ˆå¤šæœ‰è¶£çš„äº‹æƒ…ï¼Œå¥¹æ‰€ä½œçš„å°±æ˜¯å¥¹æ‰€çƒ­çˆ±çš„ã€‚å¦‚æœå¯ä»¥ï¼Œæˆ‘ä¹Ÿæƒ³å»æ—…è¡Œï¼Œç”šè‡³åƒã€Šæ‘©æ‰˜æ—¥è®°ã€‹é‚£æ ·ï¼Œ10 å…¬é‡Œçš„è·¯ç¨‹æˆ‘è¦ç»•è¿œå»è¡Œ 75 å…¬é‡Œï¼Œæ—…é€”ä¸Šçš„å„ç§ä¸œè¥¿éƒ½æ˜¯æ–°é²œçš„ï¼æˆ‘ä»¬è¿˜èƒ½æ—…è¡Œè‡³å¥¥å°”ç‰¹æ˜Ÿäº‘ï¼Œæ—…è¡Œè‡³åŠäººé©¬åº§é˜¿å°”æ³•æ˜Ÿï¼ ä½†ç°å®æ˜¯ï¼Œâ€œå±‘é­”å¥³â€ä¸å¯èƒ½å­˜åœ¨ï¼Œæˆ‘ä»¬éœ€è¦é¢å¯¹å½“ä»Šæ®‹é…·çš„ç°å®æ‰èƒ½è·å¾—æ—…è¡Œçš„èµ„æœ¬ã€‚åº•å±‚äººæ°‘ï¼Œåªæœ‰åœ¨å®Œæˆè‡ªå·±çš„å‰§æœ¬ä¹‹åï¼Œæ‰èƒ½å¾—åˆ°æ—…è¡Œçš„èµ„æ ¼ï¼Œè¸éä¸–ä¸Šä¸€åˆ‡çš„æœªçŸ¥ã€‚ å¦‚æœäººç”Ÿæœ¬æ¥å°±æ˜¯å‰§æœ¬çš„è¯ï¼Œé‚£ä¹ˆå°±è®¤å®šäº†å§ã€‚å‘½è¿æ‰“ä¸è´¥æ´»ç€ï¼ä¸Šå¸ï¼Œæˆ‘è¦ç»™ä½ ä¸Šæ¼”ä¸€åœºç»ä¸–æ¼”å‡ºã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"é—²è¯","slug":"æ–‡ç« /é—²è¯","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"}],"tags":[]},{"title":"NOI ä¸€è½®å¤ä¹  IIIï¼šæ•°å­¦ A","slug":"notes/NOI å¤ä¹ /noi-1-3","date":"2023-08-07T00:00:00.000Z","updated":"2023-12-21T00:00:00.000Z","comments":true,"path":"47964eaf/","link":"","permalink":"https://james1badcreeper.github.io/47964eaf/","excerpt":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬ä¸‰ç¯‡ï¼ŒåŒ…æ‹¬ç»„åˆè®¡æ•°ã€ç”Ÿæˆå‡½æ•°ç­‰æ•°å­¦å†…å®¹ã€‚","text":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬ä¸‰ç¯‡ï¼ŒåŒ…æ‹¬ç»„åˆè®¡æ•°ã€ç”Ÿæˆå‡½æ•°ç­‰æ•°å­¦å†…å®¹ã€‚ ç»„åˆè®¡æ•° åˆ°å¤„éƒ½èƒ½è§åˆ°å®ƒçš„èº«å½±ï¼Œå®ƒæ˜¯ä¸€åˆ‡æ•°æ•°é¢˜çš„åŸºç¡€ã€‚ è®¡æ•°åŸºç¡€ æ¦‚å¿µæ´ªæµå±äºæ˜¯ã€‚ æ’åˆ—æ•° ä» nnn ä¸ªä¸åŒå…ƒç´ ä¸­ï¼Œä»»å– mmmï¼ˆmâ©½nm\\leqslant nmâ©½nï¼‰ä¸ªå…ƒç´ æŒ‰ç…§ä¸€å®šçš„é¡ºåºæ’æˆä¸€åˆ—ï¼Œæ–¹æ¡ˆä¸ªæ•°è®°ä½œ AnmA_{n}^{m}Anmâ€‹ï¼Œæœ‰ Anm=n!(nâˆ’m)!A_{n}^{m}=\\cfrac{n!}{(n-m)!}Anmâ€‹=(nâˆ’m)!n!â€‹ã€‚ ä¸€ä¸ªæœ‰é™é›†åˆ SSS åˆ°è‡ªèº«çš„åŒå°„ç§°ä¸º SSS çš„ä¸€ä¸ªç½®æ¢ï¼Œé›†åˆ S=a1,â‹¯ ,anS={a_1,\\cdots,a_n}S=a1â€‹,â‹¯,anâ€‹ çš„ç½®æ¢å¯ä»¥è¡¨ç¤ºä¸ºï¼š f=(a1,a2,â€¦,anap1,ap2,â€¦,apn)f=\\begin{pmatrix}a_1,a_2,\\dots,a_n\\\\ a_{p_1},a_{p_2},\\dots,a_{p_n} \\end{pmatrix} f=(a1â€‹,a2â€‹,â€¦,anâ€‹ap1â€‹â€‹,ap2â€‹â€‹,â€¦,apnâ€‹â€‹â€‹) æ˜¯å°† aia_iaiâ€‹ æ˜ å°„ä¸º apia_{p_i}apiâ€‹â€‹ï¼Œè¿™æ · ppp æ˜¯ 1â‹¯n1\\cdots n1â‹¯n çš„ä¸€ä¸ªæ’åˆ—ï¼ŒSSS ä¸Šçš„æ‰€æœ‰ç½®æ¢çš„æ•°é‡ä¸º n!n!n!ã€‚ ç½®æ¢çš„è¿‡ç¨‹å¯ä»¥ä½¿ç”¨æœ‰å‘å›¾æ¥ç†è§£ï¼Œè¿è¾¹ iâ†’pii\\rightarrow p_iiâ†’piâ€‹ï¼Œå°±æ˜¯æ‰€æœ‰ç‚¹ç§»åŠ¨ 111 çš„è·ç¦»ã€‚ç½®æ¢ä¸­å½¢æˆä¸€ä¸ªç¯çš„ç§°ä¸ºç½®æ¢ç¯ï¼Œå¯¹äºå¤§å°ä¸º 1,21,21,2 çš„ç½®æ¢ç¯ï¼ŒåŸæ’åˆ—å’Œç½®æ¢æ˜¾ç„¶æ˜¯ä¸€æ ·çš„ã€‚ å¯¹äºä¸¤ä¸ªç½®æ¢ f,gf,gf,g çš„ä¹˜ç§¯è®°ä½œ fâˆ˜gf\\circ gfâˆ˜gï¼Œä»£è¡¨å…ˆé€šè¿‡ fff çš„æ˜ å°„ï¼Œå†é€šè¿‡ ggg çš„æ˜ å°„ã€‚ ä¸€ä¸ªæ’åˆ—ä¸­çš„é€†åºå¯¹ä¸ªæ•°ï¼Œä¹Ÿå«åšååºæ•°ï¼Œå¦‚æœæ˜¯å¶æ•°å°±æ˜¯å¶æ’åˆ—ï¼Œå¥‡æ•°åˆ™æ˜¯å¥‡æ’åˆ—ã€‚ å¯¹äºä¸€ä¸ªæ’åˆ— 1,â‹¯ ,n1,\\cdots,n1,â‹¯,nï¼Œå¦‚æœå°†ä»»æ„ä¸¤ä¸ªæ•° i,ji,ji,j äº¤æ¢ï¼Œå…¶å®ƒæ•°ä¿æŒä¸åŠ¨ï¼Œå°±ä¼šå¾—åˆ°ä¸€ä¸ªæ–°çš„æ’åˆ—ï¼Œé‚£ä¹ˆè¿™æ ·ä¸€ä¸ªå˜æ¢å«åšå¯¹æ¢ï¼Œç”¨ (i,j)(i,j)(i,j) è¡¨ç¤ºã€‚ ç»„åˆæ•° ä» nnn ä¸ªä¸åŒå…ƒç´ ä¸­ï¼Œä»»å– mmmï¼ˆmâ©½nm\\leqslant nmâ©½nï¼‰ä¸ªå…ƒç´ æŒ‰ç…§ä»»æ„çš„é¡ºåºç»„æˆä¸€ä¸ªé›†åˆï¼Œæ–¹æ¡ˆä¸ªæ•°è®°ä½œ (nm)\\binom n m(mnâ€‹)ã€‚ç»„åˆæ•°åŒæ—¶ä¹Ÿæ˜¯äºŒé¡¹å¼ç³»æ•°ï¼Œå½“ m&lt;0m&lt;0m&lt;0 æ—¶ï¼Œç»„åˆæ•°æ²¡æœ‰å®šä¹‰ã€‚ (nm)=n!(nâˆ’m)!m!=nmâ€¾m!(nm)=(nâˆ’1m)+(nâˆ’1mâˆ’1)\\binom n m = \\frac{n!}{(n-m)!m!}=\\frac {n^{\\underline m}} {m!}\\\\ \\binom n m = \\binom {n-1} m + \\binom {n-1}{m-1} (mnâ€‹)=(nâˆ’m)!m!n!â€‹=m!nmâ€‹â€‹(mnâ€‹)=(mnâˆ’1â€‹)+(mâˆ’1nâˆ’1â€‹) ç»„åˆæ•°æœ‰ä»¥ä¸‹æ€§è´¨ / æ’ç­‰å¼ï¼š (nm)=(nnâˆ’m)\\dbinom n m = \\dbinom n {n - m}(mnâ€‹)=(nâˆ’mnâ€‹)ï¼› (nk)=nâˆ’k+1k(nkâˆ’1)\\dbinom{n}{k}=\\cfrac{n-k+1}{k}\\dbinom{n}{k-1}(knâ€‹)=knâˆ’k+1â€‹(kâˆ’1nâ€‹)ï¼Œå¸¸è¢«ç”¨æ¥é€’æ¨ç»„åˆæ•°ï¼› (nr)(rk)=(nk)(nâˆ’krâˆ’k)\\dbinom{n}{r}\\dbinom{r}{k}=\\dbinom{n}{k}\\dbinom{n-k}{r-k}(rnâ€‹)(krâ€‹)=(knâ€‹)(râˆ’knâˆ’kâ€‹)ï¼› å¸æ”¶æ’ç­‰å¼ï¼š(rk)=rk(râˆ’1kâˆ’1)\\dbinom{r}{k}=\\dfrac{r}{k}\\dbinom{r-1}{k-1}(krâ€‹)=krâ€‹(kâˆ’1râˆ’1â€‹)ï¼Œå½“äºŒé¡¹å¼å¤–æœ‰ä¸€ä¸ªæ— ç”¨çš„ç³»æ•°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒâ€œå¸æ”¶â€è¿›äºŒé¡¹å¼ç³»æ•°ã€‚ ä¸‹æŒ‡æ ‡æ±‚å’Œï¼ˆè¡Œæ±‚å’Œï¼‰ï¼šâˆ‘i=0n(ni)=2n\\displaystyle \\sum_{i=0}^{n}\\binom{n}{i}=2^ni=0âˆ‘nâ€‹(inâ€‹)=2nï¼Œç›¸å½“äºæ˜¯äºŒé¡¹å¼å®šç†ä¸­ a=b=1a=b=1a=b=1ã€‚æ³¨æ„è¿™ä¸ªä¸œè¥¿æ˜¯å¾ˆç‰¹æ®Šçš„å®Œæ•´ä¸€è¡Œï¼Œä¸€èˆ¬çš„è¡Œæ±‚å’Œæ˜¯æ— æ³•å¿«é€Ÿè®¡ç®—çš„ã€‚å®ƒè¿˜æœ‰å˜å¼ï¼š âˆ‘i=0n(âˆ’1)i(ni)=0\\displaystyle \\sum_{i=0}^{n}(-1)^i\\binom{n}{i}=0i=0âˆ‘nâ€‹(âˆ’1)i(inâ€‹)=0ï¼Œè¿™æ˜¯äºŒé¡¹å¼å®šç†ä¸­ a=1,b=âˆ’1a=1,b=-1a=1,b=âˆ’1ï¼› âˆ‘i=0niÃ—(ni)=n2nâˆ’1\\displaystyle \\sum_{i=0}^{n}i\\times \\binom{n}{i}=n2^{n-1}i=0âˆ‘nâ€‹iÃ—(inâ€‹)=n2nâˆ’1ï¼Œå› ä¸º mÃ—(nm)=nÃ—(nâˆ’1mâˆ’1)m\\times \\dbinom{n}{m}=n\\times \\dbinom{n-1}{m-1}mÃ—(mnâ€‹)=nÃ—(mâˆ’1nâˆ’1â€‹)ã€‚ ä¸ŠæŒ‡æ ‡æ±‚å’Œï¼ˆåˆ—æ±‚å’Œï¼‰ï¼šâˆ‘i=0n(im)=(n+1m+1)\\displaystyle \\sum_{i=0}^{n}\\binom{i}{m}=\\binom{n+1}{m+1}i=0âˆ‘nâ€‹(miâ€‹)=(m+1n+1â€‹)ï¼Œå¯ä»¥çœ‹ä½œæ˜¯æšä¸¾ç¬¬ m+1m+1m+1 ä¸ªæ•°çš„ä½ç½® i+1i+1i+1ã€‚ å¯¹è§’çº¿æ±‚å’Œï¼šâˆ‘i=0n(m+ii)=(m+n+1n)\\displaystyle\\sum_{i=0}^{n}\\binom{m+i}{i}=\\binom{m+n+1}{n}i=0âˆ‘nâ€‹(im+iâ€‹)=(nm+n+1â€‹)ï¼Œåå¤åˆ©ç”¨ Cnm=Cnâˆ’1m+Cnâˆ’1mâˆ’1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnmâ€‹=Cnâˆ’1mâ€‹+Cnâˆ’1mâˆ’1â€‹ å³å¯è¯æ˜ã€‚ èŒƒå¾·è’™å¾·å·ç§¯ï¼šâˆ‘i=0k(ni)(mkâˆ’i)=(n+mk)\\displaystyle \\sum_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}i=0âˆ‘kâ€‹(inâ€‹)(kâˆ’imâ€‹)=(kn+mâ€‹)ã€‚ä»ç»„åˆæ„ä¹‰ä¸Šå¾ˆå®¹æ˜“è¯æ˜ï¼ˆæšä¸¾ nnn å’Œ mmm ä¸­é€‰çš„ä¸ªæ•°ï¼‰ï¼Œå¸¸ç”¨äºåˆå¹¶ç»„åˆæ•°ï¼Œè€ƒè™‘å®ƒçš„æ¨è®ºï¼š âˆ‘i=1n(ni)(niâˆ’1)=(2nnâˆ’1)\\displaystyle \\sum_{i=1}^n\\binom{n}{i}\\binom{n}{i-1}=\\binom{2n}{n-1}i=1âˆ‘nâ€‹(inâ€‹)(iâˆ’1nâ€‹)=(nâˆ’12nâ€‹)ï¼Œè¯æ˜å¾ˆç®€å•ï¼Œå› ä¸º (niâˆ’1)=(nnâˆ’i+1),(2nnâˆ’1)=(2nn+1)\\dbinom{n}{i-1}=\\dbinom{n}{n-i+1},\\dbinom{2n}{n-1}=\\dbinom{2n}{n+1}(iâˆ’1nâ€‹)=(nâˆ’i+1nâ€‹),(nâˆ’12nâ€‹)=(n+12nâ€‹)ï¼› âˆ‘i=0n(ni)2=(2nn)\\displaystyle\\sum_{i=0}^n\\binom{n}{i}^2=\\binom{2n}{n}i=0âˆ‘nâ€‹(inâ€‹)2=(n2nâ€‹)ï¼Œè¯æ˜åŸºæœ¬åŒç†ï¼› âˆ‘i=0m(ni)(mi)=(n+mm)\\displaystyle\\sum_{i=0}^m\\binom{n}{i}\\binom{m}{i}=\\binom{n+m}{m}i=0âˆ‘mâ€‹(inâ€‹)(imâ€‹)=(mn+mâ€‹)ï¼Œè¿™ä¸ªä¹Ÿæ˜¯ç½‘æ ¼å›¾è·¯å¾„è®¡æ•°æ–¹æ¡ˆã€‚ Lucas å®šç†ã€‚è‹¥ ppp æ˜¯è´¨æ•°ï¼Œåˆ™ (nm) mod p=(âŒŠn/pâŒ‹âŒŠm/pâŒ‹)â‹…(n mod pm mod p) mod p\\displaystyle\\binom{n}{m}\\bmod p = \\binom{\\left\\lfloor n/p \\right\\rfloor}{\\left\\lfloor m/p\\right\\rfloor}\\cdot\\binom{n\\bmod p}{m\\bmod p}\\bmod p(mnâ€‹)modp=(âŒŠm/pâŒ‹âŒŠn/pâŒ‹â€‹)â‹…(mmodpnmodpâ€‹)modpï¼Œå¸¸ç”¨äº ppp è¾ƒå°çš„æƒ…å†µã€‚ ç»„åˆæ•°å¥‡å¶æ€§å…¬å¼ã€‚(nm)â‰¡1(mod2) âŸº n &amp; m=m\\displaystyle \\binom{n}{m}\\equiv 1 \\pmod 2 \\iff n\\ \\&amp; \\ m=m(mnâ€‹)â‰¡1(mod2)âŸºn &amp; m=mï¼Œä½¿ç”¨ Lucas å®šç†æ¥è¯æ˜ï¼Œéœ€ä¿è¯ä¸å‡ºç° (01)\\dbinom{0}{1}(10â€‹)ã€‚ Kummer å®šç†ã€‚(n+mn)\\dbinom{n+m}{n}(nn+mâ€‹) ä¸­è´¨å› å­ ppp çš„æ¬¡æ•°ä¸º n+mn+mn+m åœ¨è®¡ç®—æ—¶ ppp è¿›åˆ¶æ„ä¹‰ä¸‹çš„è¿›ä½æ¬¡æ•°ï¼Œç­‰ä»·äº (nm)\\dbinom n m(mnâ€‹) ä¸­è´¨å› å­ ppp çš„æ¬¡æ•°ç­‰äºåœ¨è®¡ç®— nâˆ’mn-mnâˆ’m æ—¶ ppp è¿›åˆ¶æ„ä¹‰ä¸‹çš„å€Ÿä½æ¬¡æ•°ã€‚å…¶ä¸­ ppp æ˜¯ç´ æ•°ã€‚ ä¸ŠæŒ‡æ ‡ç¿»è½¬ã€‚(nk)=(âˆ’1)k(kâˆ’nâˆ’1k)\\displaystyle \\binom n k = (-1)^k\\binom{k-n-1}{k}(knâ€‹)=(âˆ’1)k(kkâˆ’nâˆ’1â€‹)ã€‚ å¤šé‡ç»„åˆæ•°ã€‚æ˜¯æŒ‡å…ˆé€‰ n1n_1n1â€‹ï¼Œå†é€‰ n2n_2n2â€‹ï¼Œä»¥æ­¤ç±»æ¨ã€‚æœ‰ï¼š (nn1,â€¦,nk)=n!âˆi=1kni!\\binom{n}{n_1,\\dots,n_k}=\\frac{n!}{\\prod_{i=1}^k n_i!} (n1â€‹,â€¦,nkâ€‹nâ€‹)=âˆi=1kâ€‹niâ€‹!n!â€‹ ç»„åˆæ–¹æ³•ã€‚åœ¨å°å­¦å­¦è¿‡ä¸€äº›å¸¸ç”¨çš„ç»„åˆæ–¹æ³•ã€‚ æ†ç»‘æ³•æ’ç©ºæ³•æ’æ¿æ³• nnn åªå…”å­å‚è§‚å¤§è¿å¸‚ç¬¬äºŒåå››ä¸­å­¦ï¼Œå…¶ä¸­ mmm åªå…”å­å…³ç³»ç‰¹åˆ«å¥½ï¼Œå®ƒä»¬ä¸€å®šè¦ç«™åœ¨ä¸€å—ã€‚é‚£ä¹ˆæœ‰å¤šå°‘ç§æ’åˆ—æ–¹æ³•ï¼Ÿ æˆ‘ä»¬æŠŠè¿™ mmm åªå…”å­çœ‹ä½œä¸€åªå¤§å…”å­ï¼Œé‚£ä¹ˆæ€»å…±å°±æœ‰ nâˆ’m+1n-m+1nâˆ’m+1 åªå…”å­ï¼Œæ’åˆ—æ–¹æ¡ˆæ•°æ˜¯ (nâˆ’m+1)!(n-m+1)!(nâˆ’m+1)!ï¼Œç„¶è€Œå¤§å…”å­é‡Œé¢ä¹Ÿæœ‰ m!m!m! ä¸­æ–¹æ³•ï¼Œé‚£ä¹ˆæ€»æ–¹æ³•æ•°å°±æ˜¯ (nâˆ’m+1)!m!(n-m+1)!m!(nâˆ’m+1)!m!ã€‚è¿™å°±æ˜¯æ†ç»‘æ³•ã€‚ nnn åªå…”å­å‚è§‚å¤§è¿å¸‚ç¬¬äºŒåå››ä¸­å­¦ï¼Œå…¶ä¸­ mmm åªå…”å­æœ‰ç€ä¸å…±æˆ´å¤©ä¹‹ä»‡ï¼Œå®ƒä»¬ä¸€å®šè¦ä¸èƒ½ç«™åœ¨ä¸€å—ã€‚é‚£ä¹ˆæœ‰å¤šå°‘ç§æ’åˆ—æ–¹æ³•ï¼Ÿ æˆ‘ä»¬å…ˆæŠŠ nâˆ’mn-mnâˆ’m åªå…”å­ç»™æ’åˆ—å¥½ï¼Œæœ‰ (nâˆ’m)!(n-m)!(nâˆ’m)! ç§æ–¹æ³•ã€‚è¿™äº›å…”å­ä¹‹é—´æœ‰ (nâˆ’m+1)(n-m+1)(nâˆ’m+1) ä¸ªç©ºï¼ˆç®—æœ€å·¦å’Œæœ€å³ï¼‰ï¼Œå†æŠŠè¿™äº›ä¸å…±æˆ´å¤©çš„å…”å­æ”¾åˆ°è¿™äº›ç©ºé‡Œï¼Œæœ‰ Anâˆ’m+1mA_{n-m+1}^{m}Anâˆ’m+1mâ€‹ ä¸ªæ–¹æ³•ã€‚æ€»æ–¹æ¡ˆæ•°å°±æ˜¯ (nâˆ’m)!Ã—Anâˆ’m+1m(n-m)!\\times A_{n-m+1}^{m}(nâˆ’m)!Ã—Anâˆ’m+1mâ€‹ã€‚è¿™å°±æ˜¯æ’ç©ºæ³•ã€‚ james1 è¦å°† nnn ä¸ªç›¸åŒçš„èƒ¡èåœåˆ†ç»™ mmm åªå…”å­ï¼Œä»–ç§‰æŒé›¨éœ²å‡æ²¾çš„åŸåˆ™ï¼Œæ¯åªå…”å­è‡³å°‘åˆ†åˆ° 111 æ ¹èƒ¡èåœï¼Œæœ‰å¤šå°‘ç§æ–¹æ¡ˆï¼Ÿ æˆ‘ä»¬å…ˆä»‹ç»éš”æ¿æ³•ï¼ˆæ’æ¿æ³•ï¼‰ï¼Œæ˜¯æŒ‡åœ¨ nnn ä¸ªå…ƒç´ çš„ nâˆ’1n-1nâˆ’1 ä¸ªç©ºä¸­æ’å…¥ kkk ä¸ªæ¿ï¼Œå¯ä»¥æŠŠ nnn ä¸ªå…ƒç´ åˆ†ä¸º k+1k+1k+1 ç»„ã€‚ æˆ‘ä»¬æŠŠè¿™ nnn ä¸ªèƒ¡èåœæ’æˆ 111 è¡Œï¼Œå½“ä¸­å°±æœ‰ nâˆ’1n-1nâˆ’1 ä¸ªç©ºã€‚ç°åœ¨å¾€é‡Œé¢æ’å…¥ mâˆ’1m-1mâˆ’1 ä¸ªæ¿ï¼Œå°±å¯ä»¥å°†èƒ¡èåœåˆ†ä¸º mmm ç»„ï¼Œæ­£å¥½å¯ä»¥åˆ†ç»™ mmm åªå…”å­ï¼Œè€Œä¸”ç”±äºä¸å­˜åœ¨åœ¨åŒä¸€ä¸ªåœ°æ–¹æ’ä¸¤ä¸ªæ¿çš„æƒ…å†µï¼Œæ‰€ä»¥æ­£å¥½æ¯ä¸€åªå…”å­éƒ½èƒ½è‡³å°‘åˆ†åˆ° 111 æ ¹èƒ¡èåœã€‚é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ (nâˆ’1mâˆ’1)\\dbinom{n-1}{m-1}(mâˆ’1nâˆ’1â€‹)ã€‚ å®é™…ä¸Šè¿™ä¸ªé—®é¢˜ç›¸å½“äºæ±‚ä¸å®šæ–¹ç¨‹ x1+x2+â‹¯+xm=nx_1+x_2+\\cdots+x_m=nx1â€‹+x2â€‹+â‹¯+xmâ€‹=n çš„æ­£æ•´æ•°è§£çš„æ•°é‡ã€‚ å¦‚æœä»–æ˜¯ä¸ªå¤§é­”ç‹ï¼ˆä¸å¯èƒ½ï¼Œç»å¯¹ä¸å¯èƒ½ï¼‰ï¼Œæœ‰çš„å…”å­å¯èƒ½ 111 æ ¹èƒ¡èåœéƒ½å¾—ä¸åˆ°ï¼Œé‚£ä¹ˆæœ‰å¤šå°‘ç§æ–¹æ¡ˆï¼Ÿ åŒæ ·çš„æ–¹æ³•ï¼Œå¦‚æœå…è®¸æœ‰å…”å­åˆ†åˆ° 000 æ ¹èƒ¡èåœï¼Œæˆ‘ä»¬åªéœ€è¦å†åŠ ä¸Š mmm æ ¹èƒ¡èåœï¼Œå°±ç›¸å½“äºåˆšæ‰çš„é—®é¢˜äº†ã€‚ç­”æ¡ˆæ˜¯ (n+mâˆ’1mâˆ’1)=(n+mâˆ’1n)\\dbinom{n+m-1}{m-1}=\\dbinom{n+m-1}{n}(mâˆ’1n+mâˆ’1â€‹)=(nn+mâˆ’1â€‹)ã€‚ è¿™ä¸ªé—®é¢˜æœ¬è´¨ä¸Šæ˜¯è¦æ±‚ x1+x2+â‹¯+xm=nx_1+x_2+\\cdots+x_m=nx1â€‹+x2â€‹+â‹¯+xmâ€‹=n çš„è‡ªç„¶æ•°è§£çš„æ•°é‡ã€‚ å¦‚æœ james1 åçˆ±ä¸€äº›å…”å­ï¼Œè¦æ±‚ç¬¬ iii ä¸ªå…”å­è‡³å°‘åˆ†åˆ° eie_ieiâ€‹ ä¸ªèƒ¡èåœï¼Œé‚£ä¹ˆæœ‰å¤šå°‘ç§åˆ†æ³•å‘¢ï¼Ÿ ç±»æ¯”ä¸Šä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å†åŠ ä¸Š âˆ‘e\\sum eâˆ‘e ä¸ªèƒ¡èåœï¼Œç­”æ¡ˆå°±æ˜¯ (nâˆ’âˆ‘(eâˆ’1)âˆ’1mâˆ’1)\\dbinom{n-\\sum (e - 1)-1}{m-1}(mâˆ’1nâˆ’âˆ‘(eâˆ’1)âˆ’1â€‹)ã€‚ åœ¨ nnn ä¸ªæ•°ä¸­é€‰ mmm ä¸ªç»„åˆï¼Œè¦æ±‚ä»»æ„ä¸¤ä¸ªæ•°éƒ½ä¸ç›¸é‚»ï¼Œé‚£ä¹ˆæ–¹æ¡ˆæ•°æœ‰å¤šå°‘ï¼Ÿ (nâˆ’m+1n)\\dbinom{n-m+1}{n}(nnâˆ’m+1â€‹)ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦æ’å…¥ mâˆ’1m-1mâˆ’1 ä¸ªç©ºã€‚ å®¹æ–¥åŸç† å®¹æ–¥åŸç†æ˜¯éå¸¸é‡è¦çš„è®¡æ•°åŸç†ï¼š âˆ£â‹ƒi=1nSiâˆ£=âˆ‘m=1n(âˆ’1)mâˆ’1âˆ‘ai&lt;ai+1âˆ£â‹‚i=1mSaiâˆ£\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i&lt;a_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right| â€‹i=1â‹ƒnâ€‹Siâ€‹â€‹=m=1âˆ‘nâ€‹(âˆ’1)mâˆ’1aiâ€‹&lt;ai+1â€‹âˆ‘â€‹â€‹i=1â‹‚mâ€‹Saiâ€‹â€‹â€‹ é›†åˆçš„äº¤é›†å¯ä»¥ä½¿ç”¨è¡¥é›†å®¹æ–¥åŸç†æ¥æ±‚è§£ï¼š âˆ£â‹‚i=1nSiâˆ£=âˆ£Uâˆ£âˆ’âˆ£â‹ƒi=1nSiâ€¾âˆ£\\left|\\bigcap_{i=1}^{n}S_i\\right|=|U|-\\left|\\bigcup_{i=1}^n\\overline{S_i}\\right| â€‹i=1â‹‚nâ€‹Siâ€‹â€‹=âˆ£Uâˆ£âˆ’â€‹i=1â‹ƒnâ€‹Siâ€‹â€‹â€‹ å®¹æ–¥åŸç†æœ€ç»å…¸çš„ç”¨å¤„æ˜¯â€œè‡³å°‘â€ä¸â€œæ°å¥½â€ä¹‹é—´çš„è½¬åŒ–ï¼Œå®é™…ä¸Šæ˜¯ä¸€ä¸ªå­é›†åæ¼”çš„è¿‡ç¨‹ã€‚å­é›†åæ¼”æ˜¯é’ˆå¯¹é›†åˆäº¤å¹¶çš„å®¹æ–¥ï¼Œå¯ä»¥åœ¨æ°å¥½æ˜¯æŸä¸ªé›†åˆå’Œè‡³å¤š/è‡³å°‘æ˜¯è¿™ä¸ªé›†åˆåæ¼”ã€‚ æˆ‘ä»¬å…ˆæ¥çœ‹ä¸è‡³å¤šæ˜¯è¿™ä¸ªé›†åˆçš„åæ¼”ã€‚ç°åœ¨æœ‰å…¶å…ƒç´ æ»¡è¶³æŸç§æ¡ä»¶çš„é›†åˆ AAAã€‚å®šä¹‰ f(S)f(S)f(S) ä»£è¡¨ S=AS=AS=A æ—¶çš„ç­”æ¡ˆï¼Œg(S)g(S)g(S) ä»£è¡¨ SâŠ†AS\\subseteq ASâŠ†A æ—¶çš„ç­”æ¡ˆã€‚ é’¦å®šé€‰äº† SSS è¿™ä¸ªé›†åˆä¸­çš„å­é›† TTTï¼Œæœ‰ g(S)=âˆ‘TâŠ†Sf(T)g(S)=\\sum_{T\\subseteq S}f(T)g(S)=âˆ‘TâŠ†Sâ€‹f(T)ï¼Œè¿™æ—¶æœ‰ f(S)=âˆ‘TâŠ†S(âˆ’1)âˆ£Sâˆ£âˆ’âˆ£Tâˆ£g(T)f(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}g(T)f(S)=âˆ‘TâŠ†Sâ€‹(âˆ’1)âˆ£Sâˆ£âˆ’âˆ£Tâˆ£g(T)ã€‚ä½¿ç”¨å®¹æ–¥åŸç†ä¸éš¾æ„Ÿæ€§ç†è§£ã€‚ ç±»ä¼¼çš„ï¼Œå¦‚æœ f(S)f(S)f(S) ä»£è¡¨ S=AS=AS=A æ—¶çš„ç­”æ¡ˆï¼Œg(S)g(S)g(S) è¡¨ç¤º AâŠ†SA\\subseteq SAâŠ†S æ—¶çš„ç­”æ¡ˆï¼Œæœ‰ g(S)=âˆ‘SâŠ†Tf(T)g(S)=\\sum_{S\\subseteq T}f(T)g(S)=âˆ‘SâŠ†Tâ€‹f(T)ï¼Œåæ¼”å¾— f(S)=âˆ‘SâŠ†T(âˆ’1)âˆ£Tâˆ£âˆ’âˆ£Sâˆ£g(T)f(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}g(T)f(S)=âˆ‘SâŠ†Tâ€‹(âˆ’1)âˆ£Tâˆ£âˆ’âˆ£Sâˆ£g(T)ã€‚ è¿™æ˜¯å®¹æ–¥åŸç†çš„ä»£æ•°å½¢å¼ï¼Œå®ƒæ˜¯æˆ‘ä»¬ç”¨å®¹æ–¥åŸç†è§£å†³é—®é¢˜çš„åŸºç¡€ã€‚å› ä¸ºåœ¨é’¦å®šæ—¶ï¼Œä¸€ä¸ªâ€œæœ‰ä¸¤ä¸ªå…ƒç´ æ»¡è¶³æ¡ä»¶â€çš„ä¸œè¥¿ä¼šåœ¨â€œè‡³å°‘æœ‰ä¸€ä¸ªå…ƒç´ æ»¡è¶³æ¡ä»¶â€çš„ä¸œè¥¿è®¡ç®—æ—¶è®¡ç®—ä¸¤æ¬¡ï¼Œä¹Ÿå°±å› æ­¤æˆäº†ä¸€ä¸ªå­é›†åæ¼”çš„å½¢å¼ã€‚ [ZJOI2022] æ ‘ã€‚ æ•°æ•°é¢˜ä¼˜å…ˆè€ƒè™‘ DPã€‚è½¬ç§»åªèƒ½å¯¹æ¯ä¸ªç‚¹åœ¨ä¸¤æ£µæ ‘ä¸Šçš„çˆ¶äº²è¿›è¡Œå†³ç­–ï¼Œè¿™æ · DP çŠ¶æ€åªèƒ½è®°å½•å¯è¡Œçš„å†³ç­–ç‚¹ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥ä½œä¸ºçˆ¶äº²çš„ç‚¹çš„ä¸ªæ•°ã€‚è¿™æ ·å°±è¦é’¦å®šå‰©ä½™èŠ‚ç‚¹ä¸ºå¶å­èŠ‚ç‚¹ã€‚ è®¾ f(S)f(S)f(S) ä»£è¡¨ç¬¬ä¸€æ£µæ ‘çš„å¶å­é›†åˆæ°å¥½ä¸º SSSï¼Œg(T)g(T)g(T) ä»£è¡¨ç¬¬äºŒæ£µå­æ ‘çš„å¶å­é›†åˆæ°å¥½ä¸º TTTã€‚ä½†æ˜¯æˆ‘ä»¬å‘ç°è¿™æ ·è¿˜éœ€è¦è€ƒè™‘â€œå½“å‰æ˜¯å¶å­çš„ï¼Œå½“ä¸”æ˜¯å¶å­è€Œä¸”ä»¥åå¯ä»¥å˜æˆçˆ¶äº²çš„â€ï¼Œä¸å¥½æï¼è€ƒè™‘å­é›†åæ¼”ï¼Œè®¾ fâ€²(Sâ€²)f&#x27;(S&#x27;)fâ€²(Sâ€²) ä»£è¡¨é’¦å®šäº†ç¬¬ä¸€æ£µæ ‘çš„å¶å­èŠ‚ç‚¹è‡³å¤šä¸º Sâ€²S&#x27;Sâ€²ï¼Œgâ€²(Tâ€²)g&#x27;(T&#x27;)gâ€²(Tâ€²) åŒç†ï¼Œåˆ™ï¼š Ans=âˆ‘Sâˆ©T=âˆ…,SâˆªT={1,2,â‹¯ ,n}f(S)g(T)=âˆ‘Sâˆ©T=âˆ…,SâˆªT={1,2,â‹¯ ,n}âˆ‘Sâ€²âŠ†S,Tâ€²âŠ†Tfâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’1)âˆ£Sâˆ£âˆ’âˆ£Sâ€²âˆ£+âˆ£Tâˆ£âˆ’âˆ£Tâ€²âˆ£=âˆ‘Sâ€²âˆ©Tâ€²=âˆ…fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’1)nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£2nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£=âˆ‘Sâ€²âˆ©Tâ€²=âˆ…fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’2)nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£\\begin{aligned} Ans&amp;=\\sum_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,\\cdots,n\\}}f(S)g(T)\\\\&amp;=\\sum_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,\\cdots,n\\}}\\sum_{S&#x27;\\subseteq S,T&#x27;\\subseteq T}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{|S|-|S&#x27;|+|T|-|T&#x27;|} \\\\&amp;=\\sum_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{n-|S&#x27;|-|T&#x27;|}2^{n-|S&#x27;|-|T&#x27;|}\\\\&amp;=\\sum_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-2)^{n-|S&#x27;|-|T&#x27;|} \\end{aligned} Ansâ€‹=Sâˆ©T=âˆ…,SâˆªT={1,2,â‹¯,n}âˆ‘â€‹f(S)g(T)=Sâˆ©T=âˆ…,SâˆªT={1,2,â‹¯,n}âˆ‘â€‹Sâ€²âŠ†S,Tâ€²âŠ†Tâˆ‘â€‹fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’1)âˆ£Sâˆ£âˆ’âˆ£Sâ€²âˆ£+âˆ£Tâˆ£âˆ’âˆ£Tâ€²âˆ£=Sâ€²âˆ©Tâ€²=âˆ…âˆ‘â€‹fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’1)nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£2nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£=Sâ€²âˆ©Tâ€²=âˆ…âˆ‘â€‹fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’2)nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£â€‹ ç›¸å½“äºé’¦å®šäº† Sâ€²,Tâ€²S&#x27;,T&#x27;Sâ€²,Tâ€² ä½œä¸ºå¯é€‰åšçˆ¶äº²çš„é›†åˆï¼ˆé€‰æ‹©ä¸€ä¸ªå¶å­å˜æˆçˆ¶äº²ï¼‰ï¼Œè¿™æ ·è®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ ä»£è¡¨è€ƒè™‘åˆ°ç¬¬ iii ä¸ªèŠ‚ç‚¹ï¼Œâˆ£{1,â‹¯ ,i}âˆ©Sâ€²âˆ£=j,âˆ£{i+1â‹¯n}âˆ©Tâ€²âˆ£=k|\\{1,\\cdots,i\\}\\cap S&#x27;|=j,|\\{i+1\\cdots n\\}\\cap T&#x27;|=kâˆ£{1,â‹¯,i}âˆ©Sâ€²âˆ£=j,âˆ£{i+1â‹¯n}âˆ©Tâ€²âˆ£=k çš„æ–¹æ¡ˆæ•°ã€‚ç»™ iii å·ç‚¹åœ¨ç¬¬ä¸€æ£µå­æ ‘å½“ä¸­é’¦å®šçˆ¶äº²ï¼Œæœ‰ jjj ä¸­é€‰æ‹©çˆ¶äº²çš„æ–¹æ³•ï¼›ç»™ iâˆ’1i-1iâˆ’1 å·ç‚¹åœ¨ç¬¬äºŒæ£µæ ‘ä¸­é’¦å®šçˆ¶äº²ï¼Œæœ‰ kkk ç§æ–¹æ¡ˆï¼Œæ€»å…± jÃ—kj\\times kjÃ—k ç§ã€‚ fiâˆ’1,j,kf_{i-1,j,k}fiâˆ’1,j,kâ€‹ å¯ä»¥è½¬ç§»åˆ°å¦‚ä¸‹çŠ¶æ€ï¼š iii æœ¬æ¥å±äº Sâ€²S&#x27;Sâ€²ï¼Œå¯ä»¥è½¬ç§»åˆ° fi,j+1,kf_{i,j+1,k}fi,j+1,kâ€‹ï¼› iii æœ¬æ¥å±äº Tâ€²T&#x27;Tâ€²ï¼Œè½¬ç§»åˆ° fi,j,kâˆ’1f_{i,j,k-1}fi,j,kâˆ’1â€‹ï¼› ä¸¤ä¸ªéƒ½ä¸å±äºï¼Œè½¬ç§»åˆ° fi,j,kf_{i,j,k}fi,j,kâ€‹ï¼Œå®¹æ–¥ç³»æ•°ä¸º âˆ’2-2âˆ’2ã€‚ å®é™…ä¸Šç›´æ¥çŒœå‡ºå®¹æ–¥ç³»æ•°æ˜¯æ›´ä¸ºé«˜æ•ˆçš„æ–¹å¼ã€‚ åˆå§‹æ—¶ f1,1,k=1f_{1,1,k}=1f1,1,kâ€‹=1ï¼Œç»Ÿè®¡ k=1k=1k=1 æ—¶çš„ç­”æ¡ˆå³å¯ï¼ˆSSS ç¡®å®š TTT è‡ªç„¶ä¹Ÿç¡®å®šäº†ï¼‰ã€‚ä»£ç ã€‚ äºŒé¡¹å¼åæ¼”ã€‚å‡è®¾å…¨é›† U={S1,Sâˆ’2,â‹¯ ,Snâˆ’1,Sn}U=\\{S_1, S-2, \\cdots, S_{n-1}, S_n\\}U={S1â€‹,Sâˆ’2,â‹¯,Snâˆ’1â€‹,Snâ€‹}ï¼Œä¸”æ»¡è¶³å…¶ä¸­ä»»æ„ iii ä¸ªé›†åˆçš„å¹¶é›†ã€äº¤é›†å¤§å°éƒ½ç›¸ç­‰ã€‚g(x)g(x)g(x) æ˜¯å…¶ä¸­ä»»æ„ xxx ä¸ªé›†åˆçš„äº¤é›†çš„å¤§å°ï¼Œf(x)f(x)f(x) æ˜¯ä»»æ„ xxx ä¸ªé›†åˆçš„è¡¥é›†çš„äº¤é›†çš„å¤§å°ã€‚ç‰¹åˆ«åœ°ï¼Œg(0)=f(0)=âˆ£Uâˆ£g(0)=f(0)=|U|g(0)=f(0)=âˆ£Uâˆ£ã€‚ æˆ‘ä»¬æœ‰ï¼š g(n)= âˆ£S1âˆ©S2âˆ©â‹¯Snâˆ’1âˆ©Snâˆ£= âˆ£Uâˆ£âˆ’âˆ£S1â€¾âˆªâ‹¯âˆªSnâ€¾âˆ£= âˆ£Uâˆ£âˆ’âˆ‘m=1n(âˆ’1)mâˆ’1âˆ‘ai&lt;ai+1âˆ£Sa1â€¾âˆ©â‹¯âˆ©Samâ€¾âˆ£= âˆ£Uâˆ£âˆ’âˆ‘i=1n(âˆ’1)iâˆ’1(ni)f(i)= âˆ‘i=0n(âˆ’1)i(ni)f(i)\\begin{aligned} g(n)=\\ &amp;|S_1\\cap S_2\\cap\\cdots S_{n-1}\\cap S_n|\\\\ =\\ &amp;|U|-|\\overline{S_1}\\cup\\cdots\\cup\\overline{S_n}|\\\\ =\\ &amp;|U|-\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i &lt;a_{i+1}}|\\overline{S_{a_1}}\\cap\\cdots\\cap\\overline{S_{a_m}}|\\\\ =\\ &amp; |U|-\\sum_{i=1}^n(-1)^{i-1}\\binom{n}{i}f(i)\\\\ =\\ &amp;\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}f(i) \\end{aligned} g(n)= = = = = â€‹âˆ£S1â€‹âˆ©S2â€‹âˆ©â‹¯Snâˆ’1â€‹âˆ©Snâ€‹âˆ£âˆ£Uâˆ£âˆ’âˆ£S1â€‹â€‹âˆªâ‹¯âˆªSnâ€‹â€‹âˆ£âˆ£Uâˆ£âˆ’m=1âˆ‘nâ€‹(âˆ’1)mâˆ’1aiâ€‹&lt;ai+1â€‹âˆ‘â€‹âˆ£Sa1â€‹â€‹â€‹âˆ©â‹¯âˆ©Samâ€‹â€‹â€‹âˆ£âˆ£Uâˆ£âˆ’i=1âˆ‘nâ€‹(âˆ’1)iâˆ’1(inâ€‹)f(i)i=0âˆ‘nâ€‹(âˆ’1)i(inâ€‹)f(i)â€‹ g(n)=âˆ‘i=0n(âˆ’1)i(ni)f(i) âŸº f(n)=âˆ‘i=0n(âˆ’1)i(ni)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}g(i) \\end{aligned} âŸºâ€‹g(n)=i=0âˆ‘nâ€‹(âˆ’1)i(inâ€‹)f(i)f(n)=i=0âˆ‘nâ€‹(âˆ’1)i(inâ€‹)g(i)â€‹ å¦‚æœä»¤ f(i)â€²=(âˆ’1)if(i)f(i)&#x27;=(-1)^i f(i)f(i)â€²=(âˆ’1)if(i)ï¼Œé‚£ä¹ˆå¯ä»¥å¾—åˆ°å¦ä¸€ä¸ªå½¢å¼ï¼ˆè¿™ä¸ªå½¢å¼æ›´ä¸ºå¸¸ç”¨ï¼Œå› ä¸ºå¤§å¤šæ•°é¢˜å¹¶ä¸ä¼šå‡‘å‡ºä¸€ä¸ª âˆ’1-1âˆ’1ï¼Œä»¥ä¸‹å¼å­ä¸­çš„ f,gf,gf,g å‡æ²¡æœ‰ç‰¹å®šçš„å«ä¹‰ï¼‰ï¼š g(n)=âˆ‘i=0n(ni)f(i) âŸº f(n)=âˆ‘i=0n(âˆ’1)nâˆ’i(ni)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=0}^n\\binom{n}{i}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=0}^n(-1)^{n-i}\\binom{n}{i}g(i) \\end{aligned} âŸºâ€‹g(n)=i=0âˆ‘nâ€‹(inâ€‹)f(i)f(n)=i=0âˆ‘nâ€‹(âˆ’1)nâˆ’i(inâ€‹)g(i)â€‹ åŒæ—¶è¿˜æœ‰ä¸€ç§ä¸ŠæŒ‡æ ‡çš„äºŒé¡¹å¼åæ¼”ï¼š g(n)=âˆ‘i=nN(âˆ’1)i(in)f(i) âŸº f(n)=âˆ‘i=nN(âˆ’1)i(in)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=n}^N(-1)^i\\binom{i}{n}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=n}^N(-1)^i\\binom{i}{n}g(i) \\end{aligned} âŸºâ€‹g(n)=i=nâˆ‘Nâ€‹(âˆ’1)i(niâ€‹)f(i)f(n)=i=nâˆ‘Nâ€‹(âˆ’1)i(niâ€‹)g(i)â€‹ g(n)=âˆ‘i=nN(in)f(i) âŸº f(n)=âˆ‘i=nN(âˆ’1)iâˆ’n(in)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=n}^N\\binom{i}{n}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=n}^N(-1)^{i-n}\\binom{i}{n}g(i) \\end{aligned} âŸºâ€‹g(n)=i=nâˆ‘Nâ€‹(niâ€‹)f(i)f(n)=i=nâˆ‘Nâ€‹(âˆ’1)iâˆ’n(niâ€‹)g(i)â€‹ Prufer åºåˆ— Prufer åºåˆ—çš„æ„å»ºè¿‡ç¨‹å¹¶ä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯å®ƒçš„æ€§è´¨ã€‚ Prufer åºåˆ—å¯ä»¥å°†ä¸€ä¸ª nnn ä¸ªèŠ‚ç‚¹çš„æ— æ ¹æ ‘ç”¨ [1,n][1,n][1,n] ä¸­çš„ nâˆ’2n-2nâˆ’2 ä¸ªæ•´æ•°è¡¨ç¤ºï¼Œé‚£ä¹ˆå®Œå…¨å›¾æœ‰ nnâˆ’2n^{n-2}nnâˆ’2 æ£µç”Ÿæˆæ ‘ï¼Œå› ä¸ºæ¯ä¸€ä¸ª Prufer åºåˆ—éƒ½å¯¹åº”ä¸€æ£µæ ‘ã€‚è¿™å°±æ˜¯ Cayley å…¬å¼ã€‚ ä¸€ä¸ªæ•°åœ¨ Prufer åºåˆ—ä¸­å‡ºç°çš„æ¬¡æ•°æ˜¯å®ƒåœ¨åŸæ ‘ä¸­çš„åº¦æ•°å‡ä¸€ã€‚ æ ¼è·¯è®¡æ•° åœ¨æ ¼ç‚¹è·¯å¾„ä¸Šï¼Œ(0,0)â†’(n,m)(0,0)\\rightarrow (n,m)(0,0)â†’(n,m) çš„æ–¹æ¡ˆæ•°æ˜¯ (n+mn)\\dbinom{n+m}{n}(nn+mâ€‹)ã€‚ å¯¹äºä¸èƒ½ç»è¿‡æŸä¸€æ¡ç›´çº¿çš„é™åˆ¶ï¼Œå¯ä»¥é‡‡ç”¨åå°„å®¹æ–¥ã€‚å‘ç°å®ƒä»¬åå°„ä¹‹åéƒ½ä¼šåˆ°è¾¾åŒä¸€ä¸ªç‚¹ï¼š [JLOI2015] éª—æˆ‘å‘¢ã€‚å†™å‡ºæš´åŠ› DP è½¬ç§»æ–¹ç¨‹åå‘ç°è¿™å…¶å®æ˜¯ä¸ªæ ¼è·¯è®¡æ•°é—®é¢˜ï¼Œèµ·ç‚¹æ˜¯ (0,0)(0,0)(0,0)ï¼Œç»ˆç‚¹æ˜¯ (n+m+1,n)(n+m+1,n)(n+m+1,n)ï¼Œä¸èƒ½ç¢°åˆ° y=x+1,y=xâˆ’mâˆ’2y=x+1, y=x-m-2y=x+1,y=xâˆ’mâˆ’2ã€‚ æˆ‘ä»¬å°†ç»ˆç‚¹ TTT åšå…³äºä¸¤æ¡ç›´çº¿çš„å¯¹ç§°ï¼Œå¾—åˆ° T1,T2T1,T2T1,T2ï¼ˆç¿»è½¬ä¹‹åçš„è·¯å¾„ä¹Ÿæ˜¯å¯ä»¥ç¿»è½¬çš„ï¼‰ã€‚è¿™æ ·æˆ‘ä»¬åªéœ€è¦å‡å»ç»è¿‡ä¸¤æ¡ç›´çº¿çš„æ–¹æ¡ˆæ•°ï¼Œè€Œä¸”æ˜¯æœ€åç»è¿‡çš„ï¼ˆå¦åˆ™å…ˆç»è¿‡ä¸€æ¡ç›´çº¿å†ç»è¿‡å¦ä¸€æ¡çš„è¿™ç§ä¼šç®—é‡ï¼Œè¦åŠæ—¶å‡å»ï¼‰ã€‚ è§£é¢˜æ€è·¯ è®¡æ•°é¢˜æœ‰ä¸€äº›æœºæ¢°åŒ–æ€è€ƒçš„æ–¹å¼ï¼Œè¿™é‡Œä»‹ç»ä¸€äº›ï¼š å¯»æ‰¾å”¯ä¸€æ€§ ç»„åˆè®¡æ•°ä¸­æœ€å¸¸è§çš„é—®é¢˜æ˜¯â€œæ•°é‡â€å’Œâ€œæ•°æ¼â€ã€‚è§£å†³æ–¹å¼ä¸€èˆ¬åªæœ‰ä¸¤ç§ï¼š æ„é€ åŒå°„ï¼ŒæŠŠåˆæ³•å…ƒç´ å”¯ä¸€å¯¹åº”åˆ°ä¸€ç§åˆæ³•æ–¹æ¡ˆä¸Šï¼Œç›¸å½“äºæ·»åŠ äº†é™åˆ¶æ¡ä»¶ï¼› é‡çš„æ–¹æ¡ˆå¯ä»¥ä½¿ç”¨å®¹æ–¥åŸç†è§£å†³ï¼Œç­‰ä»·æ–¹æ¡ˆå¯ä»¥ä½¿ç”¨ Polya å®šç†è§£å†³ã€‚ [AGC021E] Ball Eat Chameleons.æœ‰ nnn åªé¾™ï¼Œä¸€å¼€å§‹éƒ½æ˜¯è“è‰²ï¼Œç°åœ¨å–‚ kkk æ¬¡è“çƒæˆ–è€…çº¢çƒç»™ä½ æŒ‡å®šçš„é¾™ã€‚ä»è“è‰²å˜æˆçº¢è‰²å½“ä¸”ä»…å½“åƒçš„çº¢è‰²æ¯”è“è‰²å¤šï¼Œåä¹‹åŒç†ã€‚æ±‚æœ€åèƒ½ä½¿æ‰€æœ‰å˜è‰²é¾™éƒ½å˜æˆçº¢è‰²çš„æ–¹æ¡ˆæ•°ï¼Œä¸¤ä¸ªæ–¹æ¡ˆä¸åŒå½“ä¸”ä»…å½“è‡³å°‘ä¸€æ¬¡å–‚çš„çƒé¢œè‰²ä¸åŒã€‚O(k)O(k)O(k)ã€‚ ç”±äºæ–¹æ¡ˆä¸åŒä»…å½“é¢œè‰²ä¸åŒï¼Œå› æ­¤æˆ‘ä»¬ä»çƒçš„é¢œè‰²è§’åº¦è€ƒè™‘å»è®¡æ•°ã€‚ æœ‰ RRR ä¸ªçº¢çƒï¼ŒBBB ä¸ªè“çƒï¼Œé‚£ä¹ˆ Râ‰¥B+nR\\ge B+nRâ‰¥B+n æ—¶å¿…å®šæœ‰è§£ï¼Œå¦åˆ™æœ‰è§£æ»¡è¶³ Bâ‰¤R&lt;B+nB\\le R&lt;B+nBâ‰¤R&lt;B+nã€‚æ­¤æ—¶è®© Râˆ’BR-BRâˆ’B åªé¾™çº¢çƒåƒçš„æ¯”è“çƒå¤šä¸€ä¸ªï¼Œnâˆ’(Râˆ’B)n-(R-B)nâˆ’(Râˆ’B) åªé¾™åƒçš„çº¢çƒå’Œè“çƒä¸€æ ·å¤šï¼Œä½†æœ€åä¸€ä¸ªåƒäº†ä¸ªè“çƒã€‚ R=BR=BR=B çš„æƒ…å†µç­‰ä»·äº (R,Bâˆ’1)(R,B-1)(R,Bâˆ’1)ã€‚ æˆ‘ä»¬å¼ºåˆ¶è¦æ±‚è“çº¢åƒçš„ä¸€æ ·å¤šçš„é¾™åƒçš„åºåˆ—å½¢å¦‚ RBRBRBRBï¼Œå¦åˆ™æˆ‘ä»¬å¯ä»¥å°†å…¶ä¸­ä¸æ»¡è¶³çš„æ‹‰å‡ºæ¥ï¼Œå–‚ç»™å¤šåƒäº†çº¢è‰²çƒçš„é¾™åƒã€‚ ç°åœ¨è¦æ±‚åœ¨åºåˆ—ä¸­å¯ä»¥æå–å‡ºè‡³å°‘ nâˆ’(Râˆ’B)n-(R-B)nâˆ’(Râˆ’B) ä¸ª RB å­åºåˆ—ã€‚å¯ä»¥çœ‹ä½œæ¨ªç€çš„æ ¼è·¯è®¡æ•°ï¼Œä¸èƒ½è¶Šè¿‡ y=âˆ’(nâˆ’R)y=-(n-R)y=âˆ’(nâˆ’R)ã€‚ä»£ç ã€‚ ä¾‹é¢˜ æŸäº›ä¸œè¥¿çš„éš¾åº¦å¯èƒ½æ¯”è¾ƒå¤§ã€‚ [ABC160F] Distributing Integers Portal. éå¸¸ç»å…¸ã€‚å‘ç°åªéœ€è¦æ»¡è¶³å­æ ‘ä¸­æ ¹èŠ‚ç‚¹æ˜¯ç¬¬ä¸€ä¸ªå‡ºç°çš„ï¼Œå› æ­¤å¯¹äºä¸€ä¸ªå­æ ‘å°†ç­”æ¡ˆé™¤æ‰ szszszï¼Œæ¢æ ¹ DP å³å¯ã€‚ä»£ç ã€‚ [CF1762E] Tree Sum Portal. è®¾è¿æ¥ iii çš„è¾¹æƒä¸º did_idiâ€‹ï¼Œè€Œæ¯æ¡è¾¹å¯¹ âˆdi\\prod d_iâˆdiâ€‹ çš„è´¡çŒ®ä¸º 111ï¼Œç„¶è€Œ nnn ä¸ºå¥‡æ•°æ—¶ âˆdi=âˆ’1\\prod d_i=-1âˆdiâ€‹=âˆ’1 æ°¸è¿œä¸å¯èƒ½æ»¡è¶³ï¼Œå› æ­¤ nnn ä¸ºå¥‡æ•°æ—¶æ— è§£ã€‚ å¦‚æœ nnn ä¸ºå¶æ•°ä¸”æ ‘çš„å½¢æ€å›ºå®šï¼Œé‚£ä¹ˆå‚è€ƒ Prufer åºåˆ—çš„æ„é€ æ–¹å¼ï¼Œä»å¶å­å¼€å§‹èµ‹äºˆè¾¹æƒï¼Œé‚£ä¹ˆæ–¹å¼ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºç»™å®šçš„æ ‘çš„å½¢æ€åªæœ‰ä¸€ç§æ–¹å¼ã€‚ è¿™æ ·çš„è¯ï¼Œä¸€æ¡è¾¹ (u,v)(u,v)(u,v) çš„æƒå€¼ä¸º 111 çš„å……è¦æ¡ä»¶æ˜¯ï¼šæ–­æ‰è¿™æ¡è¾¹ä¹‹åä¸¤ä¸ªè¿é€šå—å¤§å°å‡ä¸ºå¶æ•°ã€‚å› ä¸ºè¿™æ ·ä¸¤ä¸ªè¿é€šå—éƒ½æ»¡è¶³æ¡ä»¶äº†ï¼Œè¿™æ¡è¾¹å¡« 111 å³å¯ã€‚ è€ƒè™‘é€è¾¹è®¡ç®—è´¡çŒ®ï¼Œæšä¸¾ 111 æ‰€åœ¨çš„è¿é€šå—å¤§å° iiiï¼Œè¿™æ · nnn æ‰€å¯¹åº”çš„è¿é€šå—å¤§å°ä¾¿ä¸º nâˆ’in-inâˆ’iã€‚ æ­¤æ—¶è¿™æ¡è¾¹çš„è¾¹æƒä¸º (âˆ’1)i(-1)^i(âˆ’1)iã€‚ å‰©ä¸‹ nnn ä¸ªç‚¹ä¸­éšä¾¿æ‰”ï¼Œæ–¹æ¡ˆæ•°ä¸º (nâˆ’2iâˆ’1)\\binom{n-2}{i-1}(iâˆ’1nâˆ’2â€‹)ã€‚ ä¸¤å—éšä¾¿åˆ¶é€ æ— æ ¹æ ‘ï¼Œæ ¹æ® Cayley å…¬å¼è®¡ç®—å³å¯ã€‚ éšä¾¿æ‰¾ä¸¤ä¸ªç‚¹è¿æ¥ã€‚ ä»£ç ã€‚ [AGC002F] Leftmost Ball Portal. è€ƒè™‘æœ€ç»ˆå½¢æˆçš„åˆæ³•åºåˆ—ï¼Œä¸€å®šæ˜¯ kkk ä¸ªç™½è‰²çƒåŠ ä¸Š nnn ä¸­é¢œè‰²çš„çƒå„ kâˆ’1k-1kâˆ’1 ä¸ªï¼Œåˆæ³•æƒ…å†µæ˜¯å‰ç¼€ç™½çƒä¸ªæ•°å¤§äºç­‰äºå…¶å®ƒé¢œè‰²æ•°ã€‚ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤º iii ä¸ªç™½çƒï¼Œæ”¾äº† jjj ä¸ªé¢œè‰²çš„æ–¹æ¡ˆæ•°ã€‚ å†³ç­–æœ‰ä¸¤ç§ï¼š æ”¾ç½®ä¸€ä¸ªç™½çƒï¼Œæœ‰ fi,jâ†+fiâˆ’1,jf_{i,j}\\stackrel{+}{\\leftarrow} f_{i-1,j}fi,jâ€‹â†+fiâˆ’1,jâ€‹ï¼› åŠ å…¥æ–°é¢œè‰²çš„çƒï¼Œå³ä» fi,jâˆ’1f_{i,j-1}fi,jâˆ’1â€‹ è½¬ç§»ã€‚ç³»æ•°æ˜¯å¤šå°‘ï¼Ÿé¦–å…ˆéœ€è¦åœ¨ nâˆ’j+1n-j+1nâˆ’j+1 ä¸­é€‰æ‹©ä¸€ä¸ªä½œä¸ºè¿™æ—¶æ”¾ç½®çš„é¢œè‰²ï¼Œå°†å…¶ä¸­ä¸€ä¸ªæ”¾ç½®åœ¨ç¬¬ä¸€ä¸ªç©ºä½ï¼Œç„¶åå‰©ä¸‹çš„ kâˆ’2k-2kâˆ’2 ä¸ªåœ¨åé¢çš„ nkâˆ’iâˆ’(jâˆ’1)(kâˆ’1)âˆ’1nk-i-(j-1)(k-1)-1nkâˆ’iâˆ’(jâˆ’1)(kâˆ’1)âˆ’1 ä¸­æ‰¾ kâˆ’2k-2kâˆ’2 ä¸ªæ”¾å³å¯ã€‚ ç„¶åå°±å®Œäº†ã€‚ä»£ç ã€‚ * [LNOI2022] ç›’ Portal. çœŸÂ·ç»„åˆæ•°åŸºç¡€ç»ƒä¹ é¢˜ï¼ å‘ç° wiw_iwiâ€‹ ä¼šè¢«ä½¿ç”¨ âˆ‘âˆ£âˆ‘j=1ibjâˆ’âˆ‘j=1iajâˆ£\\sum |\\sum_{j=1}^i b_j-\\sum_{j=1}^i a_j|âˆ‘âˆ£âˆ‘j=1iâ€‹bjâ€‹âˆ’âˆ‘j=1iâ€‹ajâ€‹âˆ£ æ¬¡ã€‚æšä¸¾ j=âˆ‘k=1ibkj=\\sum_{k=1}^i b_kj=âˆ‘k=1iâ€‹bkâ€‹ï¼Œå°† aaa è½¬åŒ–ä¸ºå…¶å‰ç¼€å’Œï¼Œåˆæ³•çš„ i,ji,ji,j çš„å‡ºç°æ¡ä»¶æ˜¯å‰ iii ä¸ªæ•°å’Œä¸º jjjï¼Œå nâˆ’in-inâˆ’i ä¸ªæ•°å’Œä¸º Sâˆ’jS-jSâˆ’jï¼Œäºæ˜¯ç›´æ¥æ’æ¿å¯ä»¥å¾—åˆ°æ€»è´¡çŒ®ï¼š âˆ‘i=1nâˆ’1wiâˆ‘j=0Sâˆ£jâˆ’aiâˆ£(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^S |j-a_i|\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} i=1âˆ‘nâˆ’1â€‹wiâ€‹j=0âˆ‘Sâ€‹âˆ£jâˆ’aiâ€‹âˆ£(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹) è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(nS)O(nS)O(nS) çš„ã€‚è€ƒè™‘æ‹†ç»å¯¹å€¼ï¼Œå¤§æ¦‚åƒè¿™æ ·ï¼š âˆ‘i=1nâˆ’1wiâˆ‘j=0S(jâˆ’ai)(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)+2âˆ‘i=1nâˆ’1wiâˆ‘j=0ai(aiâˆ’j)(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^S (j-a_i)\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1}+2\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^{a_i} (a_i-j)\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} i=1âˆ‘nâˆ’1â€‹wiâ€‹j=0âˆ‘Sâ€‹(jâˆ’aiâ€‹)(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹)+2i=1âˆ‘nâˆ’1â€‹wiâ€‹j=0âˆ‘aiâ€‹â€‹(aiâ€‹âˆ’j)(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹) è¿™æ ·è®© jjj ä» 000 å¼€å§‹æšä¸¾çš„ç›®çš„æ˜¯è®©æ¥ä¸‹æ¥å¥½ç®—ã€‚åé¢çš„å¼å­æ˜¾ç„¶æ¡ä»¶æ›´å¼ºï¼Œå› æ­¤ä»¥åé¢é‚£ä¸ªä¸ºä¾‹ã€‚ç”±äºå‡ºç°å‡æ³•ä¸å¥½æï¼Œå› æ­¤æ‹†æ‰ï¼š âˆ‘j=0aiai(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)âˆ’âˆ‘j=0aij(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)\\sum_{j=0}^{a_i} a_i \\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1}-\\sum_{j=0}^{a_i} j\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} j=0âˆ‘aiâ€‹â€‹aiâ€‹(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹)âˆ’j=0âˆ‘aiâ€‹â€‹j(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹) å‰é¢é‚£ä¸ª aia_iaiâ€‹ å¯ä»¥ç›´æ¥æå‡ºæ¥ï¼Œåé¢é‚£ä¸ªåˆ©ç”¨ (nm)=(nmâˆ’1)(nâˆ’m+1)\\binom{n}{m}=\\binom{n}{m-1}(n-m+1)(mnâ€‹)=(mâˆ’1nâ€‹)(nâˆ’m+1) å°† jjj æ”¹ä¸º iii å†æ‰”å‡ºæ¥ã€‚ ç°åœ¨ä»…å‰©çš„é—®é¢˜å°±æ˜¯å¿«é€Ÿè®¡ç®—ï¼š f(n,m,i,k)=âˆ‘j=0k(j+iâˆ’1iâˆ’1)(mâˆ’jâˆ’1+nâˆ’inâˆ’iâˆ’1)f(n,m,i,k)=\\sum_{j=0}^k \\binom{j+i-1}{i-1}\\binom{m-j-1+n-i}{n-i-1} f(n,m,i,k)=j=0âˆ‘kâ€‹(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1mâˆ’jâˆ’1+nâˆ’iâ€‹) å¿«é€Ÿè®¡ç®— f(n,m,i,k)f(n,m,i,k)f(n,m,i,k)ï¼Ÿç„¶è€Œè¿™ä¸ªå¼å­æ˜¯æ‹†ä¸åŠ¨äº†ï¼Œè€ƒè™‘ä½¿ç”¨å¢é‡æ³•è®¡ç®—ã€‚kkk çš„å¢é‡æ˜¯å¥½å¤„ç†çš„ï¼Œä½†æ˜¯ iii å‘¢ï¼Ÿä¸çŸ¥é“ã€‚ä»ç»„åˆæ„ä¹‰çš„è§’åº¦è€ƒè™‘ï¼Œfff æ˜¯å°†å‰ iii ä¸ªå’Œ â‰¤k\\le kâ‰¤k çš„æ•°ï¼Œä¸”æ‰€æœ‰ nnn ä¸ªæ•°å’Œä¸º mmm çš„æ–¹æ¡ˆæ•°ã€‚ç›¸å½“äºæ˜¯å°† mmm ä¸ªç›¸åŒçš„çƒæ”¾åˆ° nnn ä¸ªä¸åŒçš„ç›’å­ä¸­ï¼Œå‰ iii ä¸ªç›’å­æœ€å¤šåªèƒ½æ”¾ kkk ä¸ªçƒï¼Œç›¸å½“äºç¬¬ k+1k+1k+1 ä¸ªå°çƒä¸åœ¨å‰ iii ä¸ªç›’å­é‡Œï¼é‚£ä¹ˆæšä¸¾æ”¾çš„ä½ç½®ï¼Œæ’æ¿æœ‰ï¼š f(n,m,i,k)=âˆ‘j=i+1n(k+jâˆ’1jâˆ’1)(mâˆ’kâˆ’1+nâˆ’jnâˆ’j)f(n,m,i,k)=\\sum_{j=i+1}^n \\binom{k+j-1}{j-1}\\binom{m-k-1+n-j}{n-j} f(n,m,i,k)=j=i+1âˆ‘nâ€‹(jâˆ’1k+jâˆ’1â€‹)(nâˆ’jmâˆ’kâˆ’1+nâˆ’jâ€‹) é‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨è¿™ä¸ªå¼å­ç»´æŠ¤ iii çš„å¢é‡äº†ã€‚ä»£ç ã€‚ [CF985G] Team Players Portal. ä¸€çœ¼çœ‹å»åœ¨è¡¥å›¾ä¸Šè·‘ä¸‰å…ƒç¯è®¡æ•°ï¼Œç„¶åå‘ç°è¾¹æ•°çˆ†ç‚¸ï¼Œç›´æ¥å‘Šè¾ã€‚ ä½†æ˜¯å”¯ä¸€ä¼šçš„å¥½åƒå°±æ˜¯æ•°ä¸‰å…ƒç¯ã€‚è€ƒè™‘æ±‚ç­”æ¡ˆçš„è¡¥é›†ï¼Œç­”æ¡ˆåº”è¯¥æ˜¯æ‰€æœ‰ä¸‰å…ƒç»„çš„ç­”æ¡ˆï¼Œå‡å»è‡³å°‘æœ‰ä¸€æ¡è¾¹çš„ä¸‰å…ƒç»„çš„ç­”æ¡ˆã€‚ ç„¶ååé¢è¿™ä¸ªæ€ä¹ˆåšå‘¢ï¼Ÿæˆ‘ä»¬è‚¯å®šæ˜¯è¦å»çœ‹è¾¹çš„ï¼Œè¿™æ ·å°±ä¼šå¯¼è‡´å¯¹äºä¸€ä¸ªæœ‰ä¸¤æ¡è¾¹çš„ä¸‰å…ƒç»„ï¼Œè¢«ç»Ÿè®¡ä¸¤æ¬¡ã€‚å› æ­¤åé¢è¿™ä¸ªä¹Ÿéœ€è¦å®¹æ–¥ã€‚ æœ€ç»ˆç­”æ¡ˆå°±æ˜¯æ‰€æœ‰ä¸‰å…ƒç»„çš„ç­”æ¡ˆï¼ˆ1ï¼‰ï¼Œå‡å»è‡³å°‘æœ‰ä¸€æ¡è¾¹çš„ç­”æ¡ˆï¼ˆ2ï¼‰ï¼ŒåŠ ä¸Šè‡³å°‘æœ‰ä¸¤æ¡è¾¹çš„ç­”æ¡ˆï¼ˆ3ï¼‰ï¼Œå‡å»æœ‰ä¸‰æ¡è¾¹çš„ç­”æ¡ˆï¼ˆ4ï¼‰ã€‚æ¥ä¸‹æ¥åˆ†åˆ«çœ‹è¿™å››ä¸ªä¸œè¥¿æ€ä¹ˆåšã€‚ æšä¸¾ uâˆˆ[0,n)u\\in [0,n)uâˆˆ[0,n) ä¸­åœ¨ä¸‰å…ƒç»„ (i,j,k)(i,j,k)(i,j,k) çš„ä½ç½®ï¼Œç„¶ååˆ©ç”¨ä¹˜æ³•åŸç†è®¡ç®—ç­”æ¡ˆã€‚ åªæœ‰ä¸€æ¡è¾¹ï¼Œé‚£ä¹ˆæšä¸¾æ‰€æœ‰è¾¹ (x,y)(x,y)(x,y)ï¼Œä¸å¦¨ä»¤ x&lt;yx&lt;yx&lt;yï¼Œç„¶åä»¤ç¬¬ä¸‰ä¸ªç‚¹ä¸º zzzï¼Œè€ƒè™‘ x,y,zx,y,zx,y,z å¯¹ä¸‰å…ƒç»„ (i,j,k)(i,j,k)(i,j,k) çš„è´¡çŒ®ã€‚ x=ix=ix=iï¼Œæ­¤æ—¶ z&gt;xz&gt;xz&gt;xï¼Œxxx çš„è´¡çŒ®ä¸º AÃ—xÃ—(nâˆ’xâˆ’2)A\\times x\\times (n-x-2)AÃ—xÃ—(nâˆ’xâˆ’2)ï¼› x=jx=jx=jï¼Œæ­¤æ—¶ z&lt;xz&lt;xz&lt;xï¼Œxxx çš„è´¡çŒ®ä¸º BÃ—xÃ—xB\\times x\\times xBÃ—xÃ—xï¼› y=jy=jy=jï¼Œæ­¤æ—¶ z&gt;yz&gt;yz&gt;yï¼Œyyy çš„è´¡çŒ®ä¸º BÃ—yÃ—(nâˆ’yâˆ’1)B\\times y\\times (n-y-1)BÃ—yÃ—(nâˆ’yâˆ’1)ï¼› y=ky=ky=kï¼Œæ­¤æ—¶ z&lt;yz&lt;yz&lt;yï¼Œyyy çš„è´¡çŒ®ä¸º CÃ—yÃ—(yâˆ’1)C\\times y\\times (y-1)CÃ—yÃ—(yâˆ’1)ï¼› z=iz=iz=iï¼Œæ­¤æ—¶ 0â‰¤z&lt;x0\\le z&lt;x0â‰¤z&lt;xï¼Œzzz çš„è´¡çŒ®ä¸º AÃ—âˆ‘p=0xâˆ’1p=AÃ—xÃ—(xâˆ’1)2\\displaystyle A\\times \\sum_{p=0}^{x-1}p=A\\times \\frac {x\\times (x-1)} 2AÃ—p=0âˆ‘xâˆ’1â€‹p=AÃ—2xÃ—(xâˆ’1)â€‹ï¼› z=jz=jz=jï¼Œæ­¤æ—¶ x&lt;z&lt;yx&lt;z&lt;yx&lt;z&lt;yï¼Œzzz çš„è´¡çŒ®ä¸º BÃ—âˆ‘p=x+1yâˆ’1p=BÃ—(x+y)Ã—(yâˆ’xâˆ’1)2\\displaystyle B\\times \\sum_{p=x+1}^{y-1}p=B\\times\\frac{(x+y) \\times (y-x-1)} 2BÃ—p=x+1âˆ‘yâˆ’1â€‹p=BÃ—2(x+y)Ã—(yâˆ’xâˆ’1)â€‹ï¼› z=kz=kz=kï¼Œæ­¤æ—¶ y&lt;z&lt;ny&lt;z&lt;ny&lt;z&lt;nï¼Œzzz çš„è´¡çŒ®ä¸º CÃ—âˆ‘p=y+1nâˆ’1p=CÃ—(n+y)Ã—(nâˆ’yâˆ’1)2\\displaystyle C\\times \\sum_{p=y+1}^{n-1}p=C\\times \\frac{(n+y)\\times (n-y-1)} 2CÃ—p=y+1âˆ‘nâˆ’1â€‹p=CÃ—2(n+y)Ã—(nâˆ’yâˆ’1)â€‹ã€‚ ä¸¤æ¡è¾¹ï¼Œè¦æ±‚çš„æ˜¯ä¸‰ä¸ªç‚¹çš„é“¾ã€‚ä¸å¦¨è€ƒè™‘æšä¸¾çš„æ˜¯ä¸­é—´ç‚¹ xxxï¼Œæ­¤æ—¶ x=jx=jx=jã€‚æšä¸¾ xxx çš„æ¯ä¸€æ¡å‡ºè¾¹åˆ°è¾¾ç‚¹ yyyï¼Œè®¾ xxx çš„å‡ºåº¦ä¸º tttã€‚ç”±äº xxx ä¹Ÿä¼šå½±å“ yyy å……å½“çš„æ˜¯ i,ji,ji,j è¿˜æ˜¯ kkkï¼Œå› æ­¤ä¸å¦¨æŠŠ xxx ä¹ŸåŠ è¿› xxx çš„å‡ºè¾¹ä¸­ï¼ˆttt åŒæ—¶ä¹Ÿå¢å¤§ 111ï¼‰ã€‚è®¾ yyy åœ¨è¿™äº›æ•°ä¸­çš„æ’åä¸º rrrï¼Œåˆ†ä¸¤ç§æƒ…å†µè®¡ç®— yyy çš„è´¡çŒ®ï¼š y&lt;xy&lt;xy&lt;xï¼Œæ­¤æ—¶è€ƒè™‘ç¬¬ä¸‰ä¸ªç‚¹ zzz ï¼š z&gt;yz&gt;yz&gt;yï¼Œyyy çš„è´¡çŒ®ä¸º AÃ—yÃ—(tâˆ’râˆ’2)A\\times y\\times (t-r-2)AÃ—yÃ—(tâˆ’râˆ’2)ï¼› z&lt;yz&lt;yz&lt;yï¼Œyyy çš„è´¡çŒ®ä¸º BÃ—yÃ—rB\\times y\\times rBÃ—yÃ—rï¼› y&gt;xy&gt;xy&gt;xï¼Œæ­¤æ—¶è€ƒè™‘ç¬¬ä¸‰ä¸ªç‚¹ zzzï¼› z&gt;yz&gt;yz&gt;yï¼Œyyy çš„è´¡çŒ®ä¸º BÃ—yÃ—(tâˆ’râˆ’1)B\\times y\\times (t-r-1)BÃ—yÃ—(tâˆ’râˆ’1)ï¼› z&lt;yz&lt;yz&lt;yï¼Œyyy çš„è´¡çŒ®ä¸º CÃ—yÃ—(râˆ’1)C\\times y\\times (r-1)CÃ—yÃ—(râˆ’1)ã€‚ ç„¶åå¯¹äº xxx è‡ªå·±è¦è¿›è¡Œä¸€ä¸ªç»Ÿè®¡ï¼Œè€ƒè™‘ä¸‰ç§æƒ…å†µï¼š y,z&lt;xy,z&lt;xy,z&lt;xï¼Œxxx çš„è´¡çŒ®ä¸º CÃ—xÃ—rÃ—(râˆ’1)2C\\times x\\times \\dfrac{r\\times (r-1)}{2}CÃ—xÃ—2rÃ—(râˆ’1)â€‹ï¼› y,z&gt;xy,z&gt;xy,z&gt;xï¼Œxxx çš„è´¡çŒ®ä¸º AÃ—xÃ—(tâˆ’râˆ’1)Ã—(tâˆ’râˆ’2)2A\\times x\\times \\dfrac{(t-r-1)\\times (t-r-2)}{2}AÃ—xÃ—2(tâˆ’râˆ’1)Ã—(tâˆ’râˆ’2)â€‹ï¼› y&lt;x,z&gt;xy&lt;x,z&gt;xy&lt;x,z&gt;xï¼Œxxx çš„è´¡çŒ®ä¸º BÃ—xÃ—rÃ—(tâˆ’râˆ’1)B\\times x\\times r\\times (t-r-1)BÃ—xÃ—rÃ—(tâˆ’râˆ’1)ã€‚ ç›´æ¥æä¸€ä¸ªä¸‰å…ƒç¯è®¡æ•°æ¨¡æ¿å°±è¡Œã€‚ äºæ˜¯å°±å¾ˆé«˜å…´åœ°åšå®Œäº†ï¼Œæ—¶é—´å¤æ‚åº¦åº”è¯¥æ˜¯ O(n)+O(m)+O(n+m)+O(mm)=O(n+mm)O(n)+O(m)+O(n+m)+O(m\\sqrt{m})=O(n+m\\sqrt{m})O(n)+O(m)+O(n+m)+O(mmâ€‹)=O(n+mmâ€‹)ã€‚ä»£ç ã€‚ Polya è®¡æ•°ç†è®º å®¹æ–¥åŸç†å¯ä»¥é˜²æ­¢ç®—é‡ï¼Œè€Œæƒ³è¦çŸ¥é“é—®é¢˜æœ‰å¤šå°‘ä¸ªäº’ä¸ç­‰ä»·çš„è§£ï¼Œå¯ä»¥ä½¿ç”¨ Polya å®šç†ã€‚ ç¾¤è®ºæ¦‚è¿° ç¾¤æ˜¯ç”±ä¸€ç§é›†åˆ GGG ä»¥åŠä¸€ä¸ªäºŒå…ƒè¿ç®—æ‰€ç»„æˆçš„ï¼Œå®ƒçš„äºŒå…ƒè¿ç®—ç”¨ aâ‹…ba\\cdot baâ‹…b è¡¨ç¤ºï¼Œè¦æ±‚æ»¡è¶³ç¾¤å…¬ç†ï¼š å°é—­æ€§ï¼Œâˆ€a,bâˆˆG,aâ‹…bâˆˆG\\forall a,b\\in G, a\\cdot b\\in Gâˆ€a,bâˆˆG,aâ‹…bâˆˆGã€‚ ç»“åˆå¾‹ï¼Œå¯¹äº GGG ä¸­çš„ä»»æ„å…ƒç´ ï¼Œå…¶äºŒå…ƒè¿ç®—éœ€è¦æ»¡è¶³ç»“åˆå¾‹ã€‚ å•ä½å…ƒï¼ŒGGG ä¸­å­˜åœ¨ä¸€ä¸ªå…ƒç´  eeeï¼Œä½¿å¾—å¯¹äº GGG ä¸­çš„ä»»æ„ä¸€ä¸ªå…ƒç´  aaaï¼Œéƒ½æœ‰ä¸€ä¸ª eâ‹…a=aâ‹…e=ae\\cdot a=a\\cdot e=aeâ‹…a=aâ‹…e=a æˆç«‹ã€‚è¿™ä¸ªå…ƒç´ åº”è¯¥æ˜¯å”¯ä¸€çš„ï¼Œè¢«ç§°ä¸ºç¾¤çš„å•ä½å…ƒ eeeã€‚ é€†å…ƒï¼Œå¯¹äº GGG ä¸­çš„ aaaï¼Œæ€»å­˜åœ¨ GGG ä¸­çš„ä¸€ä¸ª bbb æ»¡è¶³ aâ‹…b=bâ‹…a=ea\\cdot b=b\\cdot a=eaâ‹…b=bâ‹…a=eï¼Œç§° bbb ä¸º aaa çš„é€†å…ƒï¼Œè®°ä¸º aâˆ’1a^{-1}aâˆ’1ã€‚ä»»ä½•ä¸€ä¸ªå…ƒç´ çš„é€†å…ƒæ˜¯å”¯ä¸€çš„ã€‚ è¿™æ ·ï¼Œ(G,â‹…)(G,\\cdot)(G,â‹…) è¢«ç§°ä¸ºä¸€ä¸ªç¾¤ã€‚ä¾‹å¦‚ï¼Œ(Z,+)(\\mathbb{Z},+)(Z,+) æ˜¯ä¸€ä¸ªç¾¤ï¼Œe=0e=0e=0ï¼Œä¸€ä¸ªæ•°çš„é€†å…ƒæ˜¯å®ƒçš„ç›¸åæ•°ã€‚ å¦‚æœ (G,â‹…)(G,\\cdot)(G,â‹…) æ»¡è¶³å°é—­æ€§å’Œç»“åˆå¾‹ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªåŠç¾¤ï¼›å¦‚æœè¿˜æ»¡è¶³å•ä½å…ƒï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯å¹ºåŠç¾¤ï¼›å¦‚æœç¾¤ (G,â‹…)(G,\\cdot)(G,â‹…) æ»¡è¶³äº¤æ¢å¾‹ï¼Œå³ âˆ€a,bâˆˆG,aâ‹…b=bâ‹…a\\forall a,b\\in G, a\\cdot b=b\\cdot aâˆ€a,bâˆˆG,aâ‹…b=bâ‹…aï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€ä¸ªé˜¿è´å°”ç¾¤ï¼Œåˆç§°äº¤æ¢ç¾¤ã€‚ è‹¥ HâŠ†GH\\subseteq GHâŠ†Gï¼Œä¸” (H,â‹…)(H,\\cdot)(H,â‹…) æ˜¯ç¾¤ï¼Œé‚£ä¹ˆ (H,â‹…)(H,\\cdot)(H,â‹…) æ˜¯ (G,â‹…)(G,\\cdot)(G,â‹…) çš„ä¸€ä¸ªå­ç¾¤ã€‚å¯ä»¥è®°ä½œ Hâ‰¤GH\\le GHâ‰¤Gã€‚ å®šä¹‰ gH={gâ‹…hâˆ£hâˆˆH}gH=\\{g\\cdot h|h\\in H\\}gH={gâ‹…hâˆ£hâˆˆH} ä¸º HHH å…³äº ggg çš„å·¦é™ªé›†ï¼ŒHg={hâ‹…gâˆ£hâˆˆH}Hg=\\{h\\cdot g|h\\in H\\}Hg={hâ‹…gâˆ£hâˆˆH} ä¸º HHH å…³äº ggg çš„å³é™ªé›†ï¼Œå…¶ä¸­æ»¡è¶³ gâˆˆGg\\in GgâˆˆGã€‚ å¦‚æœ Hg1âˆ©Hg2â‰ âˆ…Hg_1\\cap Hg_2\\ne \\varnothingHg1â€‹âˆ©Hg2â€‹î€ =âˆ…ï¼Œé‚£ä¹ˆ Hg1=Hg2Hg_1=Hg_2Hg1â€‹=Hg2â€‹ã€‚è¿™ä¸€ç‚¹ä¸éš¾æ„Ÿæ€§ç†è§£ã€‚å¦å¤–ï¼Œâˆ£Hâˆ£=âˆ£Hgâˆ£|H|=|Hg|âˆ£Hâˆ£=âˆ£Hgâˆ£ï¼Œå› ä¸º ghigh_ighiâ€‹ å¿…ç„¶äº’ä¸ç›¸åŒã€‚ æ‹‰æ ¼æœ—æ—¥å®šç†ï¼šHHH å…³äº GGG ä¸­å…ƒç´ çš„é™ªé›†æœ‰ âˆ£Gâˆ£âˆ£Hâˆ£\\frac{|G|}{|H|}âˆ£Hâˆ£âˆ£Gâˆ£â€‹ ç§ï¼Œä¸¤ä¸¤ä¸äº¤ä¸”å¤§å°å‡ä¸º HHHã€‚é™ªé›†çš„ç§ç±»æ•°å¯ä»¥è®°ä½œ [G:H][G:H][G:H]ã€‚ ç½®æ¢ç¾¤ ç½®æ¢ç¾¤ G=(M,â‹…)G=(M,\\cdot)G=(M,â‹…)ï¼Œå…¶ä¸­ MMM æ˜¯ç½®æ¢çš„é›†åˆï¼Œè¿ç®—æ˜¯ç½®æ¢çš„åˆå¹¶è¿ç®—ã€‚ Burnside å¼•ç† å®šä¹‰ç½®æ¢ç¾¤ GGGï¼Œå…¶ä½œç”¨äº XXXï¼Œå¦‚æœ x,yâˆˆXx,y\\in Xx,yâˆˆX åœ¨ GGG çš„ä½œç”¨ä¸‹å¯ä»¥ç›¸ç­‰ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå­˜åœ¨ gâˆˆGg\\in GgâˆˆG ä½¿å¾— g(x)=yg(x)=yg(x)=yï¼Œé‚£ä¹ˆ x,yx,yx,y æ˜¯ç­‰ä»·çš„ã€‚å¯ä»¥å¾—åˆ°ä¸åŒç­‰ä»·ç±»çš„æ•°é‡ï¼š âˆ£X/Gâˆ£=1âˆ£Gâˆ£âˆ‘gâˆˆGXg|X/G|=\\frac{1}{|G|}\\sum_{g\\in G}X^g âˆ£X/Gâˆ£=âˆ£Gâˆ£1â€‹gâˆˆGâˆ‘â€‹Xg XgX^gXg æŒ‡ XXX åœ¨ ggg ä½œç”¨ä¸‹çš„ä¸åŠ¨ç‚¹çš„æ•°é‡ï¼Œå³æ»¡è¶³ g(x)=xg(x)=xg(x)=x çš„ xxx çš„æ•°é‡ã€‚ Polya å®šç† æ¨¡æ¿ã€‚nnn ä¸ªç‚¹ nnn æ¡è¾¹çš„ç¯ï¼Œæœ‰ nnn ç§é¢œè‰²ï¼Œç»™æ¯ä¸ªé¡¶ç‚¹æŸ“è‰²ï¼Œé—®æœ‰å¤šå°‘ç§æœ¬è´¨ä¸åŒçš„æŸ“è‰²æ–¹æ¡ˆã€‚nâ‰¤109n\\le 10^9nâ‰¤109ã€‚ åœ¨æœ¬é¢˜ä¸­ï¼Œç½®æ¢ç¾¤ GGG å¯ä»¥çœ‹ä½œæ—‹è½¬ 0âˆ¼nâˆ’10\\sim n-10âˆ¼nâˆ’1 ä¸ªç‚¹çš„é›†åˆã€‚æˆ‘ä»¬å¾—åˆ°ï¼š Ans=1âˆ£Gâˆ£âˆ‘gâˆˆGXgAns=\\frac{1}{|G|}\\sum_{g\\in G}X^g Ans=âˆ£Gâˆ£1â€‹gâˆˆGâˆ‘â€‹Xg æˆ‘ä»¬ä¾æ¬¡è€ƒè™‘æ¯ä¸ªç½®æ¢å¯¹äºç­”æ¡ˆçš„è´¡çŒ®ï¼Œæ—‹è½¬ 000 ä¸ªçš„ç­”æ¡ˆæ˜¯ nnn^nnnï¼Œå‰©ä¸‹çš„å‘¢ï¼Ÿ æ—‹è½¬ kkk ä¸ªæ—¶ï¼Œä¸€ä¸ªå…ƒç´ æ˜¯ä¸åŠ¨ç‚¹ï¼Œå½“ä¸”ä»…å½“åœ¨é¢œè‰²åºåˆ—ä¸­ï¼Œå­˜åœ¨ä¸€ä¸ªé•¿åº¦ä¸º aaa çš„å¾ªç¯èŠ‚æ»¡è¶³ aâˆ£gcdâ¡(n,k)a\\mid \\gcd(n,k)aâˆ£gcd(n,k)ã€‚é‚£ä¹ˆï¼Œæ¯ä¸ªå­ä¸²çš„å‰ gcdâ¡(n,k)\\gcd(n,k)gcd(n,k) ä¸ªéƒ½æ˜¯éšä¾¿å–çš„ï¼Œæ‰€ä»¥æœ€ç»ˆç­”æ¡ˆä¸ºï¼š 1nâˆ‘k=1nngcdâ¡(n,k)\\frac 1 n \\sum_{k=1}^{n}n^{\\gcd(n,k)} n1â€‹k=1âˆ‘nâ€‹ngcd(n,k) æ¬§æ‹‰åæ¼”å³å¯ï¼Œä¹Ÿå°±æ˜¯ï¼š 1nâˆ‘dâˆ£nndÃ—âˆ‘k=1n[gcdâ¡(n,k)=d]\\frac 1 n \\sum_{d\\mid n}n^d\\times \\sum_{k=1}^{n} \\left[\\gcd\\left(n,k\\right)=d\\right] n1â€‹dâˆ£nâˆ‘â€‹ndÃ—k=1âˆ‘nâ€‹[gcd(n,k)=d] æ¬§æ‹‰å‡½æ•°å¯ä»¥ç›´æ¥è®¡ç®—ï¼Œä»£ç ã€‚ è¯´äº†åŠå¤©ï¼ŒPolya å®šç†æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬è¦çŸ¥é“ä¸åŠ¨ç‚¹çš„æ•°é‡ï¼Œå®é™…ä¸Šå°±æ˜¯ç½®æ¢ç¯çš„ä¸ªæ•°ï¼å› ä¸ºç½®æ¢ç¯å†…çš„ç‚¹åº”è¯¥æ˜¯ç›¸åŒçš„é¢œè‰²ï¼Œå¦åˆ™æ¢ä¸€æ¢å°±é‡äº†ã€‚é‚£ä¹ˆå¯ä»¥å†™å‡ºï¼ˆccc ä»£è¡¨ ggg ä¸­ç½®æ¢ç¯çš„ä¸ªæ•°ï¼‰ï¼š 1âˆ£Gâˆ£âˆ‘gâˆˆGnc(g)\\frac{1}{|G|}\\sum_{g\\in G}n^{c(g)} âˆ£Gâˆ£1â€‹gâˆˆGâˆ‘â€‹nc(g) ä¾‹é¢˜ ç†è®ºä¸Šæ¥è®²ä¸å¤ªå¸¸è§ã€‚ [CF1065E] Side Transmutations Portal. ä¸€ä¸ªæ“ä½œåªæœ‰ç”¨å’Œä¸ç”¨ä¸¤ç§æƒ…å†µï¼Œå°† bbb æ•°ç»„å·®åˆ†ä¹‹åæ¯ä¸€æ®µæ˜¯ç‹¬ç«‹çš„ï¼Œç„¶åå¯ä»¥å†™å‡ºï¼š 12mâˆ‘Ctnâˆ’âˆ‘C\\frac {1}{2^m}\\sum_{C} t^{n-\\sum C} 2m1â€‹Câˆ‘â€‹tnâˆ’âˆ‘C è¿™ä¸œè¥¿æ‹†æ‰å°±èƒ½åšäº†ã€‚ä»£ç ã€‚ [ARC062D] Painting Graphs with AtCoDeer Portal. å¦‚æœä¸æ˜¯ç‚¹åŒä¸Šçš„è¾¹ï¼Œé‚£éšä¾¿å¡«ï¼›å¦‚æœæ˜¯åªæœ‰ä¸€ä¸ªç¯çš„ç‚¹åŒä¸Šçš„è¾¹ï¼Œé‚£ä¹ˆ Polya å®šç†æ¨¡æ¿ï¼›å¦‚æœæ˜¯å…¶å®ƒï¼Œé‚£ä¹ˆæ’æ¿å³å¯ã€‚ä»£ç ã€‚ [SHOI2006] æœ‰è‰²å›¾ Portalã€‚ ç½®æ¢ä¾ç„¶è€ƒè™‘ç‚¹çš„ç½®æ¢ï¼Œä½†æ˜¯è¿™æ¬¡æŸ“è‰²çš„æ˜¯è¾¹ã€‚æˆ‘ä»¬è¦çŸ¥é“è¾¹æœ‰å¤šå°‘ä¸ªç­‰ä»·ç±»ã€‚ è€ƒè™‘æ‰¾åˆ°æ‰€æœ‰çš„ç½®æ¢ç¯ï¼Œè®¾å…¶å¤§å°ä¸º cic_iciâ€‹ï¼Œç„¶åè®¨è®ºç­‰ä»·ç±»ï¼š ä¸¤ä¸ªç¯å†…ç‚¹ï¼šæˆ‘ä»¬åªå…³å¿ƒä¸¤ç‚¹åœ¨ç¯ä¸Šçš„è·ç¦»ï¼Œå¯ä»¥è¿›è¡ŒæŸ“è‰²çš„ä¸åŠ¨ç‚¹æ•°é‡æ˜¯ ci/2c_i/2ciâ€‹/2ï¼› ä¸€ä¸ªç¯å†…ï¼Œä¸€ä¸ªç¯å¤–ç‚¹ï¼šå¯æŸ“è‰²çš„ä¸åŠ¨ç‚¹æ•°é‡æ˜¯ gcdâ¡(ci,cj)\\gcd(c_i,c_j)gcd(ciâ€‹,cjâ€‹)ã€‚ æšä¸¾ nnn çš„æ‹†åˆ†å³å¯ã€‚æ³¨æ„å½“ä¸­ä¸èƒ½ç®—é‡ï¼Œåœ¨æ‰€æœ‰ç‚¹å…¨æ’åˆ—çš„åŸºç¡€ä¸Šï¼ˆç„¶åå‘ç½®æ¢é‡Œé¢å¡«ï¼‰ï¼ŒåŸæœ¬çš„åŒæ ·å¤§å°çš„ç½®æ¢ç¯è¦é™¤ä»¥å…¶å…¨æ’åˆ—ï¼Œç½®æ¢ç¯å†…çš„ç‚¹æ²¡æœ‰é¡ºåºã€‚ä»£ç ã€‚ æ¦‚ç‡è®º é¢˜è½¦ æ­¤éƒ¨åˆ†ä»‹ç»çš„å†…å®¹å¯èƒ½æ˜¯ç›®å‰ç®—æ³•ç«èµ›ä¸­æœ€å¸¸å‡ºç°çš„å†…å®¹ï¼Œå› æ­¤é¢˜éå¸¸å¤šã€‚ åˆ·åŸºç¡€ 1 ç®€å•è®¡æ•°ã€‚ [COCI2009-2010#6] XOR Portal. ä¸éš¾çœ‹å‡ºæ˜¯å®¹æ–¥ï¼Œä½†æ˜¯ç³»æ•°æ˜¯ä»€ä¹ˆï¼Ÿæ‰‹ç©ä¹‹åå‘ç°æ˜¯ 2sâˆ’12^{s-1}2sâˆ’1ï¼Œå…¶ä¸­ sss æ˜¯ä¸‰è§’å½¢çš„ä¸ªæ•°ã€‚ä»£ç ã€‚ [CF1227F] Wrong Answer on test 233 Portal. å…¶ä¸­ä¸€ä¸ªç­”å¯¹çš„æ›´å¤šï¼Œéƒ½å¯ä»¥ swap ä¸€ä¸‹å˜æˆå¦ä¸€ä¸ªç­”å¯¹çš„æ›´å¤šï¼Œå› æ­¤è€ƒè™‘å®¹æ–¥æ±‚å‡ºä¸¤è€…ç­”å¯¹çš„ä¸€æ ·å¤šçš„æ–¹æ¡ˆæ•°ã€‚ å…ˆæ’é™¤æ‰ç›¸é‚» hih_ihiâ€‹ ç›¸ç­‰çš„æƒ…å†µï¼Œå› ä¸ºè¿™æ ·å¿…å®šéƒ½å¯¹ï¼Œéšä¾¿å¡«éƒ½è¡Œã€‚ æšä¸¾ç­”å¯¹çš„æ•°é‡ï¼Œç”±äºä¸€ä¸ªæ˜¯å¯¹çš„ä½ç§»çš„å°±ä¸å¯èƒ½æ˜¯å¯¹çš„ï¼Œå› æ­¤å…ˆåé€‰æ‹©ä¸¤æ¬¡ç­”å¯¹çš„æ•°ï¼Œç„¶åå¼ºåˆ¶é’¦å®šå‰©ä¸‹çš„éƒ½ä¸å¯¹ã€‚ä»£ç ã€‚ [CF1503E] 2-Coloring Portal. è€ƒè™‘ä»€ä¹ˆæ ·çš„æŸ“è‰²æ–¹å¼æ˜¯ç¬¦åˆè¦æ±‚çš„ã€‚è¦ä¹ˆè“è‰²è´¯ç©¿ï¼Œè¦ä¹ˆä¸è´¯ç©¿ã€‚ è“è‰²ä¸è´¯ç©¿ é’¦å®šå·¦è¾¹è“è‰²çš„é«˜åº¦å’Œä¸¤ä¸ªè“è‰²å³°å€¼çš„ä½ç½®ï¼Œæšä¸¾æœ€å³é¢çš„å³°å€¼ï¼Œç„¶åé«˜åº¦è¦æ±‚å’Œæ˜¯ nnnã€‚ è“è‰²è´¯ç©¿ è¿™ä¸ªç¿»è½¬ä¹‹åæ˜¯ä¸€æ ·çš„ï¼Œæ³¨æ„ç¬¬äºŒæ¬¡è®¡ç®—æ—¶è¦å¼ºåˆ¶é’¦å®š iâˆ’jâ‰¥2i-j\\ge 2iâˆ’jâ‰¥2ï¼Œé˜²æ­¢å‡ºç°ä¸¤ä¸ªéƒ½æ˜¯å³°çš„æƒ…å†µã€‚å‰ç¼€å’Œä¼˜åŒ–å³å¯ã€‚ä»£ç ã€‚ * [JLOI2016] æˆç»©æ¯”è¾ƒ Portal. é¦–å…ˆåœ¨ nâˆ’1n-1nâˆ’1 ååŒå­¦ä¸­é’¦å®š kkk ååŒå­¦è¢« B ç¥ç¢¾å‹ã€‚ éœ€è¦é’¦å®šåŒå­¦åˆ†æ•°çš„å…·ä½“æƒ…å†µï¼Œæ­¤æ—¶å¯¹äºæ¯ä¸€ç§‘å¯ä»¥åˆ†å¼€è€ƒè™‘ã€‚ è€ƒè™‘ G(u,a,b)G(u,a,b)G(u,a,b) ä»£è¡¨æœ‰ uuu ç§å¯é€‰åˆ†æ•°ï¼Œaaa äººæ¯” B ç¥é«˜ï¼Œbbb äººä¸æ¯” B ç¥é«˜ï¼Œåˆ™ï¼š G(u,a,b)=âˆ‘i=0uia(uâˆ’i)bG(u,a,b)=\\sum_{i=0}^u i^a (u-i)^b G(u,a,b)=i=0âˆ‘uâ€‹ia(uâˆ’i)b ç›´æ¥åšä¼šçˆ†ç‚¸ï¼Œè€ƒè™‘æšä¸¾æœ‰ ttt ç§å¾—åˆ†ï¼Œç­”æ¡ˆä¸º d(t)d(t)d(t)ï¼Œæ ¹æ®å®¹æ–¥åŸç†å¾—ï¼š d(t)=(ut)(G(t,a,b)âˆ’âˆ‘i=1tâˆ’1d(i)Ã—(ti))d(t)=\\binom{u}{t}\\left(G(t,a,b)-\\sum_{i=1}^{t-1}d(i)\\times \\binom{t}{i}\\right) d(t)=(tuâ€‹)(G(t,a,b)âˆ’i=1âˆ‘tâˆ’1â€‹d(i)Ã—(itâ€‹)) ç„¶åéœ€è¦åˆ†é…è¿™äº›åˆ†æ•°ç»™æ¯ä¸€ä¸ªäººï¼Œè¿™é‡Œè€ƒè™‘åˆ†é…ç»™ä¸è¢« B ç¥ç¢¾å‹çš„æ¯”è¾ƒæ–¹ä¾¿ï¼Œåœ¨ nâˆ’1âˆ’kn-1-knâˆ’1âˆ’k ä¸ªåŒå­¦ä¸­ï¼Œè®© riâˆ’1r_i-1riâ€‹âˆ’1 ä¸ªäººç¬¬ iii ç§‘åˆ†æ•°æ¯” B å›é«˜ï¼Œæ–¹æ¡ˆæ•°ä¸º (nâˆ’kâˆ’1riâˆ’1)\\dbinom{n-k-1}{r_i-1}(riâ€‹âˆ’1nâˆ’kâˆ’1â€‹)ã€‚ä½†æ˜¯ä¸å¯¹ï¼æˆ‘ä»¬éœ€è¦ä¿è¯è¿™äº›äººéƒ½ä¸èƒ½è¢« B å›ç¢¾å‹ï¼è®¾ fif_ifiâ€‹ ä»£è¡¨ä¸è¶…è¿‡ iii ä¸ªäººè¢«ç¢¾å‹çš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆï¼š fi=âˆj=1m(nâˆ’iâˆ’1rjâˆ’1)f_i=\\prod_{j=1}^{m} \\binom{n-i-1}{r_j-1} fiâ€‹=j=1âˆmâ€‹(rjâ€‹âˆ’1nâˆ’iâˆ’1â€‹) å®¹æ–¥åŸç†ï¼Œå¾—åˆ°ç­”æ¡ˆï¼š âˆ‘i=0nâˆ’kâˆ’1(âˆ’1)nâˆ’kâˆ’1âˆ’ifi(nâˆ’kâˆ’1i)\\sum_{i=0}^{n-k-1}(-1)^{n-k-1-i} f_i\\binom{n-k-1}i i=0âˆ‘nâˆ’kâˆ’1â€‹(âˆ’1)nâˆ’kâˆ’1âˆ’ifiâ€‹(inâˆ’kâˆ’1â€‹) å°†ä¸‰ä¸ªä¸œè¥¿å…¨éƒ¨ä¹˜èµ·æ¥å³å¯ï¼Œä»£ç ã€‚ åˆ·åŸºç¡€ 2 å«æœ‰æ¦‚ç‡å’ŒæœŸæœ›çš„é—®é¢˜ã€‚ [CF850F] Rainbow Balls Portal. è®¾ f(x)f(x)f(x) ä»£è¡¨é’¦å®šä¸€ä¸ªå½“å‰æœ‰ xxx ä¸ªçƒçš„é¢œè‰²ï¼Œå°†å…¨éƒ¨ sss ä¸ªçƒè½¬åŒ–æˆè¿™ä¸ªé¢œè‰²çš„æœŸæœ›æ“ä½œæ¬¡æ•°ã€‚æ ¹æ®æœŸæœ›çš„çº¿æ€§æ€§è´¨ï¼Œæœ€ç»ˆç­”æ¡ˆæ˜¯ âˆ‘f(ai)\\sum f(a_i)âˆ‘f(aiâ€‹)ã€‚ å¦‚æœè½¬ç§»åˆ° f(0)f(0)f(0) å°±å®Œè›‹äº†ã€‚ ç›´è§‰ä¸Šæ¥è®²æ˜¯è¿™æ ·çš„ï¼š p=x(sâˆ’x)s(sâˆ’1)fx=p(fxâˆ’1+fx+1)+(1âˆ’2p)fx+1p=\\frac{x(s-x)}{s(s-1)}\\\\ f_x=p(f_{x-1}+f_{x+1})+(1-2p)f_x + 1 p=s(sâˆ’1)x(sâˆ’x)â€‹fxâ€‹=p(fxâˆ’1â€‹+fx+1â€‹)+(1âˆ’2p)fxâ€‹+1 ç›´æ¥è½¬ç§»åˆ°äº† f(0)f(0)f(0) æ€ä¹ˆåŠï¼Ÿä¸ï¼Œè´¡çŒ®ä¸èƒ½æ˜¯ 111ï¼Œå®ƒæƒ³è¦èµ°åˆ° sss ä¸€å®šä¸èƒ½ä¸­é€”æš´æ¯™ï¼Œæ‰€ä»¥è´¡çŒ®æ˜¯ is\\cfrac i ssiâ€‹ã€‚ çŸ¥é“ f1f_1f1â€‹ æ˜¯å¤šå°‘ï¼Œä¸€åˆ‡å°±è§£å†³äº†ã€‚æˆ‘ä»¬è¿˜çŸ¥é“ fs=0f_s=0fsâ€‹=0ï¼Œé‚£ä¹ˆï¼šf1=f1âˆ’fs=âˆ‘i=2sfiâˆ’fiâˆ’1f_1=f_1-f_s=\\sum_{i=2}^s f_i-f_{i-1}f1â€‹=f1â€‹âˆ’fsâ€‹=âˆ‘i=2sâ€‹fiâ€‹âˆ’fiâˆ’1â€‹ï¼Œä»£å…¥å³å¯å¾—åˆ° f1=(sâˆ’1)2sf_1=\\cfrac{(s-1)^2}{s}f1â€‹=s(sâˆ’1)2â€‹ã€‚ä»£ç ã€‚ [Ptz 2019 Summer Day 3] Minimum Spanning Trees Portal. è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨ iii ä¸ªç‚¹çš„æ ‘ MST ä¸º jjj çš„ç­”æ¡ˆã€‚è½¬ç§»æ—¶ç”¨ gi,jg_{i,j}gi,jâ€‹ ä»£è¡¨å½¢æˆå¤§å°å’Œä¸º iii çš„è¿é€šå—ï¼ŒMST ä¸º jjj çš„ç­”æ¡ˆã€‚æ­¤æ—¶çš„ MST è¿æ¥å„è¿é€šå—çš„è¾¹ç”¨å½“å‰æšä¸¾çš„è¾¹æƒå®šä¹‰ã€‚ä¹‹åå†æŠŠå½“å‰ä¸è¿é€šçš„å‡å»å³å¯ã€‚ä»£ç ã€‚ åˆ·æå‡ ç»å…¸å¥—è·¯çš„ç»¼åˆåº”ç”¨ã€‚çœŸçš„æ˜¯éå¸¸æœ‰è¶£å‘¢ * [ARC128F] Game against Robot Portal. é¦–å…ˆç»™å®š ppp æ€ä¹ˆåšï¼Ÿæ¯æ¬¡å°†åä¸¤ä¸ªæ•°ä¸¢è¿›å¤§æ ¹å †é‡Œï¼Œé€‰æ‹©æœ€å¤§çš„å³å¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬åªéœ€è¦ç»´æŠ¤ç¬¬ iii å¤§çš„æ•°å‡ºç°çš„æ¬¡æ•° fif_ifiâ€‹ã€‚ ç„¶åè¿˜æ˜¯æœ‰å€¼çš„é™åˆ¶ï¼Œä¸å¥½åšï¼Œç»§ç»­é™ç»´ï¼Œå°† fif_ifiâ€‹ æ”¹ä¸ºæ±‚å‰ iii å¤§çš„æ•°è¢«ç»Ÿè®¡çš„æ¬¡æ•°ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ âˆ‘aiÃ—(fiâˆ’fiâˆ’1)\\sum a_i\\times (f_i-f_{i-1})âˆ‘aiâ€‹Ã—(fiâ€‹âˆ’fiâˆ’1â€‹)ã€‚è¿™æ ·å°±è€ƒè™‘ 01 åºåˆ—çš„å½¢æ€å³å¯ã€‚ æ¯ä¸¤ä½ä¸€ç»„ï¼Œä¸€ä¸ª 111 æ¨ªç€èµ°ï¼ˆæ–¹æ¡ˆæ•°ä¸º 222ï¼‰ï¼Œå³ä¸Šèµ°å’Œå³ä¸‹èµ°æ–¹æ¡ˆæ•°ä¸º 111ï¼Œèµ°åˆ° (n,m)(n,m)(n,m)ã€‚æ€ä¹ˆåšï¼æ‰“è¡¨ï¼Œæ˜¯ (2nn+m)\\dbinom{2n}{n+m}(n+m2nâ€‹)ã€‚ ç°åœ¨æ±‚çš„æ˜¯è¿™ä¸ªä¸œè¥¿ï¼š ä½†æ˜¯æˆ‘ä»¬è¦æ±‚è¿™ä¸ªï¼š æšä¸¾çº¢çº¿çš„ä¸ªæ•°ï¼ˆè§¦å‘å¤§æ ¹å †é‡Œæ‰¾ä¸åˆ° 1 çš„æ¬¡æ•°ï¼‰kkkï¼Œé‚£ä¹ˆæœ€ç»ˆè¦èµ°åˆ° (n/2,mâˆ’n/2)(n/2,m-n/2)(n/2,mâˆ’n/2)ï¼Œæ°å¥½è¦ç»è¿‡æœ€ä½ç‚¹ y=âˆ’ky=-ky=âˆ’kï¼Œåå°„å®¹æ–¥å†å·®åˆ†ï¼Œç­”æ¡ˆæ˜¯ï¼š (nm+2k)âˆ’(nm+2k+2)\\dbinom{n}{m+2k} - \\dbinom{n}{m+2k+2} (m+2knâ€‹)âˆ’(m+2k+2nâ€‹) ç„¶åæšä¸¾ kâˆˆ[maxâ¡{0,n/2âˆ’m},n/2]k\\in [\\max\\{0,n/2-m\\},n/2]kâˆˆ[max{0,n/2âˆ’m},n/2]ï¼Œä»¤ p=maxâ¡{0,n/2âˆ’m}p=\\max\\{0,n/2-m\\}p=max{0,n/2âˆ’m}ï¼Œç»Ÿè®¡ç­”æ¡ˆï¼š fmm!(nâˆ’m)!=âˆ‘k=pn/2(n2âˆ’k)((nm+2k)âˆ’(nm+2k+2))=n2âˆ‘k=pn/2((nm+2k)âˆ’(nm+2k+2))âˆ’âˆ‘k=pn/2k((nm+2k)âˆ’(nm+2k+2))=n2âˆ‘k=pn/2((nm+2k)âˆ’(nm+2(k+1)))âˆ’âˆ‘k=pn/2k(nm+2k)+âˆ‘k=p+1n/2+1(kâˆ’1)(nm+2k)=n2(nm+2p)âˆ’p(nm+2p)âˆ’âˆ‘k=p+1n/2(nm+2k)\\begin{aligned} \\frac{f_m}{m!(n-m)!}&amp;=\\sum_{k=p}^{n/2}\\left(\\frac n 2-k\\right) \\left( \\dbinom{n}{m+2k} - \\dbinom{n}{m+2k+2}\\right)\\\\ &amp;=\\frac n 2 \\sum_{k=p}^{n/2} \\left( \\dbinom{n}{m+2k} - \\dbinom{n}{m+2k+2}\\right)-\\sum_{k=p}^{n/2}k \\left( \\dbinom{n}{m+2k} - \\dbinom{n}{m+2k+2}\\right)\\\\ &amp;=\\frac n 2 \\sum_{k=p}^{n/2} \\left( \\dbinom{n}{m+2k} - \\dbinom{n}{m+2(k+1)}\\right)-\\sum_{k=p}^{n/2}k \\dbinom{n}{m+2k} + \\sum_{k=p+1}^{n/2+1}(k-1)\\dbinom{n}{m+2k}\\\\ &amp;=\\frac n 2 \\dbinom{n}{m+2p} -p\\binom{n}{m+2p} - \\sum_{k=p+1}^{n/2} \\dbinom{n}{m+2k} \\end{aligned} m!(nâˆ’m)!fmâ€‹â€‹â€‹=k=pâˆ‘n/2â€‹(2nâ€‹âˆ’k)((m+2knâ€‹)âˆ’(m+2k+2nâ€‹))=2nâ€‹k=pâˆ‘n/2â€‹((m+2knâ€‹)âˆ’(m+2k+2nâ€‹))âˆ’k=pâˆ‘n/2â€‹k((m+2knâ€‹)âˆ’(m+2k+2nâ€‹))=2nâ€‹k=pâˆ‘n/2â€‹((m+2knâ€‹)âˆ’(m+2(k+1)nâ€‹))âˆ’k=pâˆ‘n/2â€‹k(m+2knâ€‹)+k=p+1âˆ‘n/2+1â€‹(kâˆ’1)(m+2knâ€‹)=2nâ€‹(m+2pnâ€‹)âˆ’p(m+2pnâ€‹)âˆ’k=p+1âˆ‘n/2â€‹(m+2knâ€‹)â€‹ å°±å®Œæˆäº†ã€‚ä»£ç ã€‚ [AGC043D] Merge Triplets Portal. è€ƒè™‘æŒ‰ç…§æ•°ä»å°åˆ°å¤§è¿›è¡Œ DPã€‚å‘ç°å‰ç¼€æœ€å¤§å€¼æ®µçš„é•¿åº¦ â‰¤3\\le 3â‰¤3ï¼Œç„¶åé•¿åº¦ä¸º 222 çš„æ®µä¸ªæ•°ä¸è¶…è¿‡é•¿åº¦ä¸º 111 çš„æ®µä¸ªæ•°ã€‚ä»£ç ã€‚ [ARC082C] ConvexScore Portal. è´¡çŒ®æ˜¯åˆæ³•ç‚¹é›†çš„æ•°é‡ï¼Œå…¶ä¸­åˆæ³•çš„å®šä¹‰æ˜¯å®ƒä»¬ä¸­å¯ä»¥é€‰å‡ºä¸€äº›ç‚¹æ„æˆä¸€ä¸ªå‡¸å¤šè¾¹å½¢å›´ä½æ‰€æœ‰çš„ç‚¹ã€‚å› æ­¤ç›´æ¥ç»Ÿè®¡æ‰€æœ‰çš„çº¿æ®µå³å¯ã€‚ä»£ç ã€‚ åˆ·ç»¼åˆ ç»¼åˆè®¡æ•°é¢˜ã€‚ [AGC040F] Two Pieces Portal. ä»£æ•°æ¨å¯¼å¤©åœ°ç­ã€‚ è€ƒè™‘æ²¡æœ‰ 222 æ“ä½œæ€ä¹ˆåšã€‚ä¸ºäº†é¿å…é‡å¤è®¡æ•°ï¼Œå¼ºåˆ¶è®© a,ba,ba,b è·ç¦» â‰¥1\\ge 1â‰¥1ï¼ˆæˆ‘ä»¬åªåŒºåˆ†æ“ä½œæ—¶çš„ä½ç½®ï¼Œå› æ­¤ =0=0=0 çš„ä¼šåœ¨è€ƒè™‘ 222 æ“ä½œæ—¶ç»Ÿè®¡ï¼‰ã€‚åå°„å®¹æ–¥åšä¸€ä¸‹å³å¯ã€‚ è€ƒè™‘åŠ å…¥æ“ä½œ 222ã€‚è€ƒè™‘æšä¸¾ä¸€æ¬¡æ“ä½œ 222 é€ æˆçš„ç§»ç‚¹è´¡çŒ®ï¼Œä¹Ÿå°±æ˜¯æšä¸¾æœ€åä¸€æ¬¡è¿›è¡Œæ“ä½œ 222 æ—¶çš„ k=xâˆ’yk=x-yk=xâˆ’yï¼Œé‚£ä¹ˆå¯ä»¥è§†ä½œå°†ç»ˆç‚¹æ‹‰åˆ° (A,Bâˆ’k)(A,B-k)(A,Bâˆ’k)ï¼Œå°†æ­¤è§†ä¸ºæ–°çš„æ ¼è·¯ã€‚ å°†å‰©ä½™çš„ nâˆ’Aâˆ’(Bâˆ’k)âˆ’1n-A-(B-k)-1nâˆ’Aâˆ’(Bâˆ’k)âˆ’1 ä¸ª 333 æ“ä½œåˆ†é…åˆ°æ“ä½œåºåˆ—ä¸­ï¼Œå®é™…ä¸Šæ˜¯è¦ç»™åˆ° k+1k+1k+1 ä¸ªç‚¹ï¼ˆåœ¨å®ƒä»¬èº«ä¸Šè¿›è¡Œ 333 æ“ä½œï¼‰ï¼Œå®ƒä»¬æ˜¯ç›´çº¿ y=xâˆ’dy=x-dy=xâˆ’dï¼ˆdâˆˆ[0,k]d\\in [0,k]dâˆˆ[0,k]ï¼Œd&gt;kd&gt;kd&gt;k è¶Šè¿‡äº†ä¹‹å‰é’¦å®šçš„æœ€åä¸€æ¬¡ 333 æ“ä½œï¼‰ä¸æ–°çš„æ ¼è·¯çš„æœ€åä¸€ä¸ªäº¤ç‚¹ï¼Œåªæœ‰æœ€åä¸€ä¸ªäº¤ç‚¹æ˜¯åˆæ³•çš„ï¼Œå¦åˆ™ä¼šæœ‰å°† yyy åæ ‡ +1 ç±»çš„æ“ä½œæ— æ³•è¿›è¡Œã€‚åˆ†é…ä¹‹åï¼Œä¼šå°†ç§»åŠ¨ kkk çš„è´¡çŒ®åˆ†æ‘Šæ‰ã€‚ ç‰¹åˆ¤ A+B=nA+B=nA+B=n çš„æƒ…å†µå³å¯ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"å…«æœˆäºŒæ—¥é—²è¯ï¼šå¾®æ³¢ç‚‰æˆ˜ç¥","slug":"summaries/é—²è¯/2023/8/2023-8-2","date":"2023-08-02T00:00:00.000Z","updated":"2023-08-02T00:00:00.000Z","comments":true,"path":"3dc46655/","link":"","permalink":"https://james1badcreeper.github.io/3dc46655/","excerpt":"","text":"æŸä¸€æ¬¡ B å›å°è¯•æŠŠå†·é¢æ”¾åˆ°å¾®æ³¢ç‚‰é‡ŒåŠ çƒ­ï¼Œä½†æ˜¯è¿™ç©æ„å„¿æ€ä¹ˆèƒ½æ”¾å¾®æ³¢ç‚‰é‡Œå‘¢ï¼Ÿç±»ä¼¼çš„æ“ä½œï¼ŒåƒæŠŠ I å›æ”¾åˆ°å¾®æ³¢ç‚‰é‡Œï¼Œéƒ½æ˜¯ä¸å¯è¡Œçš„ã€‚ ä½†æ˜¯ B å›å¹²å‡ºäº†æ›´åŠ ç–¯ç‹‚çš„äº‹æƒ…ã€‚ä»–æŠŠ I å›çš„å†°æ¿€å‡Œæ”¾åˆ°äº†å¾®æ³¢ç‚‰é‡Œï¼ç„¶è€Œ I å›çš„å†°æ¿€å‡Œå®åœ¨æ˜¯å¤ªå‡‰äº†ï¼Œå®¶é‡Œçš„å¾®æ³¢ç‚‰çˆ†ç‚¸äº†ï¼ B å›å¾ˆç”Ÿæ°”ã€‚â€œæˆ‘è¦åˆ¶é€ ä¸€ä¸ªå®‡å®™è¶…çº§æ— æ•Œè±ªåå¾®æ³¢ç‚‰ï¼â€ äº”å¤©è¿‡å»åï¼Œå®šåˆ¶çš„å¾®æ³¢ç‚‰é€åˆ°äº†ï¼ŒB å›å†æ¬¡å°†å†°æ¿€å‡Œæ”¾äº†è¿›å»ï¼Œå†°æ¿€å‡ŒèåŒ–äº†ï¼ I å›å›åˆ°å®¶åå‘ç°ä»–çš„å†°æ¿€å‡Œä¸è§äº†ï¼Œéå¸¸ç”Ÿæ°”ï¼Œè€Œä¸” B å›çš„ å®‡å®™è¶…çº§æ— æ•Œè±ªåå¾®æ³¢ç‚‰ å æ®äº†åŠä¸ªå¨æˆ¿çš„ä½“ç§¯ã€‚I å›è¯´ä¸åŠ¨ B å›ï¼Œåªå¥½ç»™è¿œåœ¨åŒ—æçš„ i å›æ‰“äº†ä¸ªç”µè¯ã€‚ i å›è§‰å¾—è¿™éå¸¸æœ‰æ„æ€ï¼šâ€œä½ è®© B å›ç­‰å‡ å¤©ï¼Œæˆ‘é€ä¸€ä¸ªä¸œè¥¿è¿‡æ¥ï¼Œå¦‚æœ B å›çš„å¾®æ³¢ç‚‰èä¸æ‰å®ƒï¼Œé‚£ä¹ˆ B å›å°±éœ€è¦ç ¸æ‰ä»–çš„å¾®æ³¢ç‚‰ã€‚â€ ä¸‰å¤©åï¼Œå¦ä¸€ä¸ªå†°æ¿€å‡Œé€äº†è¿‡æ¥ã€‚è¿™å¯ä¸æ˜¯ä¸€èˆ¬çš„å†°æ¿€å‡Œï¼Œè¿™æ˜¯å‹ç¼©å†°æ¿€å‡Œï¼Œè¿™æ˜¯ i å›çš„æå¯’å†°æ²™ï¼Œåœ°çƒä¸Šæœ€å‡‰çš„å†°æ¿€å‡Œï¼ ä¸è´Ÿä¼—æœ›ï¼Œåœ¨ å®‡å®™è¶…çº§æ— æ•Œè±ªåå¾®æ³¢ç‚‰ å¯¹æˆ˜æå¯’å†°æ²™çš„æˆ˜æ–—ä¸­ï¼Œå®‡å®™è¶…çº§æ— æ•Œè±ªåå¾®æ³¢ç‚‰ è´¥åŒ—äº†ï¼ B å›ä¸æœï¼šâ€œæˆ‘è¦åˆ¶é€  å®‡å®™è¶…çº§æ— æ•Œè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é—ªçç‹—çœ¼çš„å¾®æ³¢ç‚‰ Pro Plus Max Ultra è‡³å°Šæ— æ•Œç‰ˆï¼â€ å®‡å®™è¶…çº§æ— æ•Œè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é—ªçç‹—çœ¼çš„å¾®æ³¢ç‚‰ Pro Plus Max Ultra è‡³å°Šæ— æ•Œç‰ˆ å æ®äº†æ•´ä¸ªæ—¶ä»£å¹¿åœºã€‚ä»æ­¤ï¼Œè¿™é‡Œæ”¹åå«ï¼Œå¾®æ³¢ç‚‰å¹¿åœºï¼ ä½†æ˜¯ï¼ŒB å›ä¾ç„¶æ²¡èƒ½æˆåŠŸèåŒ–æå¯’å†°æ²™ã€‚ B å›å¾ˆç”Ÿæ°”ï¼Œéå¸¸çš„ç”Ÿæ°”ã€‚ä»–è¯´ï¼šâ€œæˆ‘è¦åˆ¶é€  å®‡å®™è¶…çº§æ— æ•Œè‡³å°Šè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é‡é‡çº§ä¸­çš„é‡é‡çº§é—ªçæ‰€æœ‰äººçš„çœ¼ç›çš„å¯ä»¥èåŒ–åä¸ªæå¯’å†°æ²™è¶…çº§æ— æ•Œå¼ºåŒ–ç‰ˆç»ˆæè¶…æ¨¡å¾®æ³¢ç‚‰ Pro Plus Max Ultra æ— æ•ŒåŠ å¼ºåŠ å¼ºåŠ å¼ºå†åŠ å¼ºè±ªåç‰ˆï¼â€ ä¸€å¹´åå¾®æ³¢ç‚‰é€ å¥½äº†ï¼Œå‡ºä¹æ„æ–™çš„ï¼Œè¿™æ¬¡çš„å¾®æ³¢ç‚‰å¤§å°æ­£å¸¸äº†è®¸å¤šã€‚â€œè¿™æ ·å¯ä»¥è¾¾åˆ°æ›´é«˜çš„æ¸©åº¦ï¼â€B å›è‡ªä¿¡åè¶³ï¼Œäºæ˜¯ï¼Œå®‡å®™è¶…çº§æ— æ•Œè‡³å°Šè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é‡é‡çº§ä¸­çš„é‡é‡çº§é—ªçæ‰€æœ‰äººçš„çœ¼ç›çš„å¯ä»¥èåŒ–åä¸ªæå¯’å†°æ²™è¶…çº§æ— æ•Œå¼ºåŒ–ç‰ˆç»ˆæè¶…æ¨¡å¾®æ³¢ç‚‰ Pro Plus Max Ultra æ— æ•ŒåŠ å¼ºåŠ å¼ºåŠ å¼ºå†åŠ å¼ºè±ªåç‰ˆ å¯¹æˆ˜æå¯’å†°æ²™ï¼Œå¼€å§‹ï¼ ä½† B å›åˆå¤±è´¥äº†ã€‚ B å›å½»åº•ç–¯ç‹‚ï¼Œå˜æˆäº†å¾®æ³¢ç‚‰çš„å½¢çŠ¶ã€‚ä»–ä¸€å£åƒä¸‹äº†æå¯’å†°æ²™ï¼Œæå¯’å†°æ²™ç»ˆäºåŒ–æ‰äº†ï¼å¾®æ³¢ç‚‰ B å›æ‹¿ç€ å®‡å®™è¶…çº§æ— æ•Œè‡³å°Šè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é‡é‡çº§ä¸­çš„é‡é‡çº§é—ªçæ‰€æœ‰äººçš„çœ¼ç›çš„å¯ä»¥èåŒ–åä¸ªæå¯’å†°æ²™è¶…çº§æ— æ•Œå¼ºåŒ–ç‰ˆç»ˆæè¶…æ¨¡å¾®æ³¢ç‚‰ Pro Plus Max Ultra æ— æ•ŒåŠ å¼ºåŠ å¼ºåŠ å¼ºå†åŠ å¼ºè±ªåç‰ˆ åœ¨å¤§è¡—ä¸Šæ¸¸èµ°ã€‚ æŸå¤©ï¼Œé˜¿é‡Œå˜æ‹‰å›½å¯¹å…‹è±å› å¸å›½å‘åŠ¨äº†å¤§è§„æ¨¡çš„è¿›æ”»ã€‚B å›å‡ºå›½è¿æˆ˜ï¼Œåªè§ä¸€ä¸ªé‡å‹å¾®æ³¢ç‚‰å³æ‰‹æ‹¿ç€ å®‡å®™è¶…çº§æ— æ•Œè‡³å°Šè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é‡é‡çº§ä¸­çš„é‡é‡çº§é—ªçæ‰€æœ‰äººçš„çœ¼ç›çš„å¯ä»¥èåŒ–åä¸ªæå¯’å†°æ²™è¶…çº§æ— æ•Œå¼ºåŒ–ç‰ˆç»ˆæè¶…æ¨¡å¾®æ³¢ç‚‰ Pro Plus Max Ultra æ— æ•ŒåŠ å¼ºåŠ å¼ºåŠ å¼ºå†åŠ å¼ºè±ªåç‰ˆï¼Œå·¦è‚©ä¸Šæ‰›ç€å¦ä¸€ä¸ª å®‡å®™è¶…çº§æ— æ•Œè‡³å°Šè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é‡é‡çº§ä¸­çš„é‡é‡çº§é—ªçæ‰€æœ‰äººçš„çœ¼ç›çš„å¯ä»¥èåŒ–åä¸ªæå¯’å†°æ²™è¶…çº§æ— æ•Œå¼ºåŒ–ç‰ˆç»ˆæè¶…æ¨¡å¾®æ³¢ç‚‰ Pro Plus Max Ultra æ— æ•ŒåŠ å¼ºåŠ å¼ºåŠ å¼ºå†åŠ å¼ºè±ªåç‰ˆï¼Œåˆé‡æ•Œäººï¼ŒB å›å°†å³æ‰‹çš„ å®‡å®™è¶…çº§æ— æ•Œè‡³å°Šè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é‡é‡çº§ä¸­çš„é‡é‡çº§é—ªçæ‰€æœ‰äººçš„çœ¼ç›çš„å¯ä»¥èåŒ–åä¸ªæå¯’å†°æ²™è¶…çº§æ— æ•Œå¼ºåŒ–ç‰ˆç»ˆæè¶…æ¨¡å¾®æ³¢ç‚‰ Pro Plus Max Ultra æ— æ•ŒåŠ å¼ºåŠ å¼ºåŠ å¼ºå†åŠ å¼ºè±ªåç‰ˆ ç ¸å‘æ•Œäººï¼Œæ•Œäººè¢«ç ¸çš„æºƒä¸æˆå†›ã€‚B å›å¼€å¯äº†ç‹‚æš´æ¨¡å¼ï¼Œä»æ‰‹é‡Œå˜å‡ºæ— æ•°çš„ å®‡å®™è¶…çº§æ— æ•Œè‡³å°Šè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é‡é‡çº§ä¸­çš„é‡é‡çº§é—ªçæ‰€æœ‰äººçš„çœ¼ç›çš„å¯ä»¥èåŒ–åä¸ªæå¯’å†°æ²™è¶…çº§æ— æ•Œå¼ºåŒ–ç‰ˆç»ˆæè¶…æ¨¡å¾®æ³¢ç‚‰ Pro Plus Max Ultra æ— æ•ŒåŠ å¼ºåŠ å¼ºåŠ å¼ºå†åŠ å¼ºè±ªåç‰ˆï¼Œä»¥ S å›æ‰“éŸ³æ¸¸èˆ¬çš„é€Ÿåº¦å°† å®‡å®™è¶…çº§æ— æ•Œè‡³å°Šè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é‡é‡çº§ä¸­çš„é‡é‡çº§é—ªçæ‰€æœ‰äººçš„çœ¼ç›çš„å¯ä»¥èåŒ–åä¸ªæå¯’å†°æ²™è¶…çº§æ— æ•Œå¼ºåŒ–ç‰ˆç»ˆæè¶…æ¨¡å¾®æ³¢ç‚‰ Pro Plus Max Ultra æ— æ•ŒåŠ å¼ºåŠ å¼ºåŠ å¼ºå†åŠ å¼ºè±ªåç‰ˆ æ‰”å‘æ•Œäººã€‚ä¸ä¹…ï¼Œæˆ‘ä»¬å°±åªèƒ½åœ¨å¤§é‡ å®‡å®™è¶…çº§æ— æ•Œè‡³å°Šè±ªå Super é‡é‡è¶…çº§é‡é‡çº§é‡é‡çº§ä¸­çš„é‡é‡çº§é—ªçæ‰€æœ‰äººçš„çœ¼ç›çš„å¯ä»¥èåŒ–åä¸ªæå¯’å†°æ²™è¶…çº§æ— æ•Œå¼ºåŒ–ç‰ˆç»ˆæè¶…æ¨¡å¾®æ³¢ç‚‰ Pro Plus Max Ultra æ— æ•ŒåŠ å¼ºåŠ å¼ºåŠ å¼ºå†åŠ å¼ºè±ªåç‰ˆ ä¸­å‘ç°å°‘é‡æ•Œäººå°¸ä½“ã€‚ B å›åªèº«å‡»è´¥äº†å®åŠ›å¼ºå¤§çš„é˜¿é‡Œå˜æ‹‰å›½å†›é˜Ÿï¼æ­è¿å¾®æ³¢ç‚‰æˆ˜ç¥ B å›ï¼","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"é—²è¯","slug":"æ–‡ç« /é—²è¯","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"}],"tags":[]},{"title":"NOI ä¸€è½®å¤ä¹  IIï¼šæ•°æ®ç»“æ„ A","slug":"notes/NOI å¤ä¹ /noi-1-2","date":"2023-06-30T00:00:00.000Z","updated":"2024-02-17T00:00:00.000Z","comments":true,"path":"3344a7ae/","link":"","permalink":"https://james1badcreeper.github.io/3344a7ae/","excerpt":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬äºŒç¯‡ï¼ŒåŒ…æ‹¬å„ç±»å¸¸ç”¨æ•°æ®ç»“æ„ã€‚","text":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬äºŒç¯‡ï¼ŒåŒ…æ‹¬å„ç±»å¸¸ç”¨æ•°æ®ç»“æ„ã€‚ å¾…è¡¥å……å†…å®¹ æ”¯é…å¯¹ã€‚Slope Trick æ ‘çŠ¶æ•°ç»„ åˆç§° Fenwick æ ‘ã€äºŒå‰ç´¢å¼•æ ‘ï¼ˆBITï¼‰ã€‚æ”¯æŒç»´æŠ¤å‰ç¼€åç¼€çš„ä¿¡æ¯ã€‚ æ¦‚è¿° æ ‘çŠ¶æ•°ç»„å°†åºåˆ—æ‹†åˆ†æˆäº†æ°å¥½ nnn ä¸ªåŒºé—´ï¼Œå¯¹äºæ¯ä¸€ä¸ªå‰ç¼€æ±‚è§£éƒ½å¯ä»¥æ‹†æˆ logâ¡p\\log plogp ä¸ªåŒºé—´è¿›è¡Œæ±‚è§£ï¼Œè€Œä¸”è‡ªå¸¦ä¸€ä¸ªå¡ä¸æ‰çš„ 1/21/21/2 çš„å¸¸æ•°ï¼Œéšæœºæ•°æ®ä¸‹åˆ™ä¸º 1/41/41/4 çš„å¸¸æ•°ï¼æˆ‘ä»¬é€šè¿‡ lowbitâ¡\\operatorname{lowbit}lowbit æ¥æ”¯æŒæ ‘çŠ¶æ•°ç»„çš„å·¥ä½œã€‚ ä¸€ä¸ªæ˜¾å¼çš„æ ‘çŠ¶æ•°ç»„ æ¨¡æ¿ï¼ŒåŒºé—´å’Œæˆ‘ä»¬å¯ä»¥ç”¨å‰ç¼€å’Œç›¸å‡æ¥æ±‚è§£ï¼Œä»£ç å¦‚ä¸‹ï¼š #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[500005]; i64 C[500005]; void add(int x, int k) &#123; for (; x &lt;= n; x += x &amp; -x) C[x] += k; &#125; i64 sum(int x) &#123; i64 r = 0; for (; x; x -= x &amp; -x) r += C[x]; return r; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), add(i, a[i]); while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) add(x, y); else printf(\"%lld\\n\", sum(y) - sum(x - 1)); &#125; return 0; &#125; æ ‘çŠ¶æ•°ç»„è‡ªèº«ä¹Ÿæœ‰è®¸å¤šæ¼‚äº®çš„æ“ä½œï¼Œè™½ç„¶æ•ˆç‡ä¸Šç•¥å¾®èƒœäºçº¿æ®µæ ‘å’Œå¹³è¡¡æ ‘ï¼Œä½†æ˜¯å¯æ‰©å±•æ€§å’Œç›´è§‚ç¨‹åº¦ä¸Šå´ä¸å¦‚å®ƒä»¬ã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€äº›å¿…é¡»æŒæ¡çš„ã€‚ çº¿æ€§å»ºæ ‘ å¯¹äºæ ‘çŠ¶æ•°ç»„ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½å‘ä¸Šä¼ é€’ï¼Œå…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼š for (int i = 1; i &lt;= n; ++i) &#123; int x; cin >> x; C[i] += x; if (i + lowbit(i) &lt;= n) C[i + lowbit(i)] += C[i]; &#125; å·®åˆ†ä¸å‰ç¼€å’Œ æ ‘çŠ¶æ•°ç»„å¯ä»¥è½»æ¾ç»´æŠ¤åºåˆ—çš„é«˜é˜¶å‰ç¼€å’Œï¼Œé¦–å…ˆå°†åŸåºåˆ—å·®åˆ†å¯ä»¥ç›´æ¥è§£å†³åŒºé—´åŠ å•ç‚¹æŸ¥è¯¢ã€‚ å°†åŸåºåˆ—å‰ç¼€å’Œï¼š ç¼–å· 1 2 3 4 5 åŸåºåˆ— 1 0 0 0 0 ä¸€é˜¶å‰ç¼€å’Œ 1 1 1 1 1 äºŒé˜¶å‰ç¼€å’Œ 1 2 3 4 5 ä¸‰é˜¶å‰ç¼€å’Œ 1 3 6 10 15 å¯ä»¥å¾—åˆ° bk,i=bk,iâˆ’1+bkâˆ’1,ib_{k,i}=b_{k,i-1}+b_{k-1,i}bk,iâ€‹=bk,iâˆ’1â€‹+bkâˆ’1,iâ€‹ã€‚è¿™æ˜¯ç½‘æ ¼å›¾è·¯å¾„è®¡æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œbk,i=(i+kâˆ’1kâˆ’1)b_{k,i}=\\dbinom {i+k-1}{k-1}bk,iâ€‹=(kâˆ’1i+kâˆ’1â€‹)ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¦æ±‚ï¼š âˆ‘i=1x(x+kâˆ’1âˆ’ikâˆ’1)ai\\sum_{i=1}^x \\binom{x+k-1-i} {k-1} a_i i=1âˆ‘xâ€‹(kâˆ’1x+kâˆ’1âˆ’iâ€‹)aiâ€‹ ç”±èŒƒå¾·è’™å¾·å·ç§¯å¾—ï¼š âˆ‘i=1xâˆ‘j=0kâˆ’1(xj)(kâˆ’1âˆ’ikâˆ’1âˆ’j)ai\\sum_{i=1}^x \\sum_{j=0}^{k-1} \\binom x j \\binom{k-1-i}{k-1-j} a_i i=1âˆ‘xâ€‹j=0âˆ‘kâˆ’1â€‹(jxâ€‹)(kâˆ’1âˆ’jkâˆ’1âˆ’iâ€‹)aiâ€‹ åˆ†ç¦»ï¼Œå¯å¾—ï¼š âˆ‘j=0kâˆ’1(xj)âˆ‘i=1x(kâˆ’1âˆ’ikâˆ’1âˆ’j)ai\\sum_{j=0}^{k-1} \\binom x j \\sum_{i=1}^x \\binom{k-1-i}{k-1-j} a_i j=0âˆ‘kâˆ’1â€‹(jxâ€‹)i=1âˆ‘xâ€‹(kâˆ’1âˆ’jkâˆ’1âˆ’iâ€‹)aiâ€‹ åé¢é‚£ä¸€å¨å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤ï¼Œå‰é¢ç›´æ¥ä¹˜å°±è¡Œã€‚æ³¨æ„è¿™é‡Œçš„æ˜¯å¹¿ä¹‰äºŒé¡¹å¼ç³»æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼š (nm)=âˆi=nâˆ’m+1nim!\\binom n m =\\frac {\\prod_{i=n-m+1}^{n}i}{m!} (mnâ€‹)=m!âˆi=nâˆ’m+1nâ€‹iâ€‹ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š int C(int n, int m) &#123; if (n &lt; 0) return 1ll * fac[m - n - 1] * ifac[-n - 1] % P * ifac[m] % P * (m &amp; 1 ? P - 1 : 1) % P; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; void add(int p, int x, int y) &#123; for (int i = x; i &lt;= n; i += i &amp; -i) a[p][i] = (a[p][i] + 1ll * C(k - x, k - p) * y % P) % P; &#125; int sum(int p, int x) &#123; int r = 0; for (int i = x; i; i -= i &amp; -i) r = (r + a[p][i]) % P; return r; &#125; main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;k, &amp;m); --k; for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); for (int j = 0; j &lt;= k; ++j) add(j, i, x); &#125; while (m--) &#123; int op, x; scanf(\"%d%d\", &amp;op, &amp;x); if (op == 1) &#123; int y; scanf(\"%d\", &amp;y); for (int i = 0; i &lt;= k; ++i) add(i, x, y); &#125; else &#123; int ans = 0; for (int i = 0; i &lt;= k; ++i) ans = (ans + 1ll * C(x, i) * sum(i, x) % P) % P; printf(\"%d\\n\", (ans + P) % P); &#125; &#125; &#125; å½“ kkk è¾ƒå°æ—¶ï¼Œä¹Ÿå¯ä»¥æ‰‹æ¨ç»“è®ºï¼šå¯¹äº kkk é˜¶å‰ç¼€å’Œï¼Œå†™å‡º (yâˆ’x+kâˆ’1kâˆ’1)\\dbinom{y-x+k-1}{k-1}(kâˆ’1yâˆ’x+kâˆ’1â€‹) çš„å¤šé¡¹å¼å½¢å¼ï¼Œç„¶å yyy è¡¨ç¤ºçš„æ˜¯ä¸‹æ ‡ï¼Œxxx è¡¨ç¤ºçš„æ˜¯å½“å‰ä½ç½®çš„å€¼ã€‚ æ¯”å¦‚ k=3k=3k=3 æ—¶ï¼š (yâˆ’x+22)=(yâˆ’x+2)(yâˆ’x+1)2\\dbinom{y-x+2}{2}=\\frac{(y-x+2)(y-x+1)}{2} (2yâˆ’x+2â€‹)=2(yâˆ’x+2)(yâˆ’x+1)â€‹ æ‰€ä»¥å±•å¼€ä¸ºï¼š x2âˆ’(2yâˆ’3)x1+(y2+3y+2)x02\\frac{x^2-(2y-3)x^1+(y^2+3y+2)x^0}{2} 2x2âˆ’(2yâˆ’3)x1+(y2+3y+2)x0â€‹ é‚£ä¹ˆç»´æŠ¤ vxivx^ivxi åœ¨ yyy å¤„çš„å‰ç¼€å’Œï¼Œç»Ÿè®¡ç­”æ¡ˆå³å¯ã€‚è¿™æ ·çš„å¥½å¤„æ˜¯ä¸ç”¨å†™å¹¿ä¹‰äºŒé¡¹å¼ç³»æ•°æ¥è®¡ç®—è´¡çŒ®ã€‚ [Code+#1] Yazid çš„æ–°ç”Ÿèˆä¼šã€‚ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n(nâ‰¤5Ã—105)n(n\\le 5\\times 10^5)n(nâ‰¤5Ã—105) çš„åºåˆ—ï¼Œé—®å…¶ä¸­æœ‰å¤šå°‘ä¸ªå­åŒºé—´å­˜åœ¨å‡ºç°æ¬¡æ•°ä¸¥æ ¼è¶…è¿‡å­åŒºé—´é•¿åº¦ä¸€åŠçš„ä¼—æ•°ã€‚ è€ƒè™‘æšä¸¾æ¯ä¸ªç§ç±»çš„æ•°åˆ†åˆ«è®¡ç®—ï¼Œè®¾å½“å‰é€‰ä¸­çš„æ•°ä¸º wwwï¼ŒSiS_iSiâ€‹ ä¸ºå‰ iii ä¸ªæ•°ä¸­ www çš„ä¸ªæ•°ã€‚ å¯¹äºä¸€æ®µåŒºé—´ [l+1,r][l+1,r][l+1,r]ï¼ˆæ–¹ä¾¿å·®åˆ†ï¼‰ï¼Œæ»¡è¶³æ¡ä»¶æ—¶æœ‰ Srâˆ’Sl&gt;râˆ’lâˆ’(Srâˆ’Sl)â†’2Srâˆ’r&gt;2Slâˆ’lS_r-S_l&gt;r-l-(S_r-S_l)\\rightarrow 2S_r-r&gt;2S_l-lSrâ€‹âˆ’Slâ€‹&gt;râˆ’lâˆ’(Srâ€‹âˆ’Slâ€‹)â†’2Srâ€‹âˆ’r&gt;2Slâ€‹âˆ’lï¼Œä¹Ÿå°±æ˜¯åœ¨æ±‚ Pi=2Siâˆ’iP_i=2S_i-iPiâ€‹=2Siâ€‹âˆ’i çš„é€†åºå¯¹ä¸ªæ•°ã€‚ å¯¹äºåŒä¸€ä¸ª wwwï¼ŒPiP_iPiâ€‹ å¯ä»¥åˆ’åˆ†æˆè‹¥å¹²ä¸ªå•è°ƒé€’å‡åŒºé—´ï¼Œæ€»æ•°åœ¨ O(n)O(n)O(n) çº§åˆ«ã€‚åŒä¸€ä¸ªåŒºé—´å†…æ˜¯æ²¡æœ‰è´¡çŒ®çš„ï¼Œåªéœ€è¦è®¡ç®— lll åœ¨å‰é¢åŒºé—´å†…çš„è´¡çŒ®ã€‚ è®¾ cic_iciâ€‹ ä»£è¡¨ iii åœ¨ PPP ä¸­çš„å‡ºç°æ¬¡æ•°ï¼ˆç”±äºå¯èƒ½æœ‰è´Ÿçš„ï¼Œæ‰€ä»¥éœ€è¦åŠ ä¸Šä¸€ä¸ªåç§»é‡ï¼‰ï¼ŒTTT è¡¨ç¤º cic_iciâ€‹ çš„å‰ç¼€å’Œï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ª PiP_iPiâ€‹ çš„è´¡çŒ®å°±æ˜¯å½“å‰çš„ TPiâˆ’1T_{P_i-1}TPiâ€‹âˆ’1â€‹ã€‚å¯¹äºä¸€æ®µ [x,y][x,y][x,y]ï¼Œæ€»è´¡çŒ®å°±æ˜¯ âˆ‘i=xâˆ’1yâˆ’1Ti\\sum\\limits_{i=x-1}^{y-1}T_ii=xâˆ’1âˆ‘yâˆ’1â€‹Tiâ€‹ï¼Œå†æ±‚ä¸€ä¸ª TTT çš„å‰ç¼€å’Œ GGG å³å¯ã€‚ è¿™ç©æ„å°±æ˜¯ä¸‰é˜¶å‰ç¼€å’Œã€‚ int n, type; int a[500005]; vector&lt;int> b[500005]; i64 C1[1000005], C2[1000005], C3[1000005]; i64 sum(int x) &#123; i64 res = 0; for (int i = x; i > 0; i -= i &amp; -i) res += C1[i] * (x + 2) * (x + 1) - C2[i] * (2 * x + 3) + C3[i]; return res; &#125; void add(int x, i64 k) &#123; for (int i = x; i &lt;= 2 * n + 1; i += i &amp; -i) C1[i] += k, C2[i] += k * x, C3[i] += k * x * x; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;type); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[a[i]].emplace_back(i); i64 ans = 0; const int N = n + 1; for (int i = 0; i &lt; n; ++i) &#123; b[i].emplace_back(n + 1); int last = 0; for (int j = 0; j &lt; b[i].size(); ++j) &#123; int x = 2 * j - b[i][j] + 1 + N, y = 2 * j - last + N; ans += sum(y - 1) - sum(x - 2); add(x, 1); add(y + 1, -1); last = b[i][j]; &#125; last = 0; for (int j = 0; j &lt; b[i].size(); ++j) &#123; int x = 2 * j - b[i][j] + 1 + N, y = 2 * j - last + N; add(x, -1); add(y + 1, 1); last = b[i][j]; &#125; &#125; return !printf(\"%lld\\n\", ans / 2); &#125; æ ‘çŠ¶æ•°ç»„äºŒåˆ†ä¸å€å¢ æˆ‘ä»¬å½“ç„¶å¯ä»¥ä½¿ç”¨äºŒåˆ†å¥—æ ‘çŠ¶æ•°ç»„è¾¾åˆ° O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n) çš„å¤æ‚åº¦ï¼Œç„¶è€Œæœ‰æ²¡æœ‰æ›´å¥½çš„æ–¹å¼é€‚é…æ ‘çŠ¶æ•°ç»„è¿™ç§ç»“æ„å‘¢ï¼Ÿæœ‰ï¼å€å¢ï¼ æŸ¥è¯¢ä¸€ä¸ªæƒå€¼æ ‘çŠ¶æ•°ç»„é‡Œçš„ kkk å°å€¼ã€‚ æˆ‘ä»¬ä»äºŒè¿›åˆ¶é«˜ä½åˆ°ä½ä½æšä¸¾ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚ // æƒå€¼æ ‘çŠ¶æ•°ç»„æŸ¥è¯¢ç¬¬ k å° int kth(int k) &#123; int sum = 0, x = 0; for (int i = 17; i >= 0; --i) &#123; // éœ€æ»¡è¶³ sum &lt; k x += 1 &lt;&lt; i; // å°è¯•æ‰©å±• if (x >= n || sum + C[x] >= k) x -= 1 &lt;&lt; i; // x ä¸åœ¨æ ‘çŠ¶æ•°ç»„èŒƒå›´å†…ï¼Œæˆ–æ‰©å±•å¤±è´¥ else sum += C[x]; &#125; return x + 1; &#125; [çœé€‰è”è€ƒ 2020 A/B å·] å†°ç«æˆ˜å£«ã€‚å°†æ¸©åº¦ç¦»æ•£åŒ–ï¼Œé‚£ä¹ˆæ±‚çš„å°±æ˜¯å†°äººå‰ç¼€å’Œï¼ˆIpI_pIpâ€‹ï¼‰å’Œç«äººåç¼€å’Œï¼ˆå‰ç¼€å’Œè®°ä¸º FpF_pFpâ€‹ï¼‰çš„æœ€å°å€¼æœ€å¤§ä¸ºå¤šå°‘ã€‚ç”±äºèƒ½åŠ›å€¼ä¸ä¸ºè´Ÿï¼Œå› æ­¤åªéœ€è¦æ±‚å‡º Ipâ‰¤Fsumâˆ’Fpâˆ’1I_p\\le F_{sum}-F_{p-1}Ipâ€‹â‰¤Fsumâ€‹âˆ’Fpâˆ’1â€‹ çš„æœ€å¤§ ppp å’Œ Ipâ‰¥Fsumâˆ’Fpâˆ’1I_p\\ge F_{sum}-F_{p-1}Ipâ€‹â‰¥Fsumâ€‹âˆ’Fpâˆ’1â€‹ çš„æœ€å¤§ pppï¼ˆä½†æ˜¯ Fpâˆ’1F_{p-1}Fpâˆ’1â€‹ æœ€å°ï¼‰ã€‚ å‰è€…å¥½æï¼Œä½†æ˜¯åè€…æ€ä¹ˆæ±‚ï¼Ÿè€ƒè™‘å°† FFF å¹³ç§»ä¸€ä½ï¼Œæ¡ä»¶ä¸€å˜æˆ Ipâ‰¤Fsumâˆ’FpI_p\\le F_{sum}-F_{p}Ipâ€‹â‰¤Fsumâ€‹âˆ’Fpâ€‹ï¼Œæ¡ä»¶äºŒå˜æˆ Ipâ‰¥Fsumâˆ’FpI_p\\ge F_{sum}-F_{p}Ipâ€‹â‰¥Fsumâ€‹âˆ’Fpâ€‹ã€‚å½“æ±‚å‡ºå‰é¢çš„ ppp åï¼Œå– pâ†p+1p\\leftarrow p+1pâ†p+1ï¼Œé‚£ä¹ˆæ­¤æ—¶ ppp å°±æ˜¯æ»¡è¶³æ¡ä»¶äºŒçš„æœ€å° pppï¼Œç„¶åå†æ¬¡å€å¢å‡ºæœ€å¤§çš„ ppp å³å¯ã€‚ä»£ç ã€‚ ä¾‹é¢˜ æ›´å¤šæ³¨é‡äºåˆ†æã€‚ [Ptz 2022 Summer Day 2] Ternary Search Portal. æˆ‘ä»¬åªéœ€è¦è€ƒè™‘å•è°·ã€‚ è°·çš„å€¼æ˜¯å¯ä»¥ç¡®å®šçš„ã€‚å¦‚æœæˆ‘ä»¬å°†è°·å·¦è¾¹çš„æ•°å…¨éƒ¨å–ç›¸åæ•°ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯å…¨å±€çš„é€†åºå¯¹æ•°ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬é€šè¿‡æ˜¯å¦å–ç›¸åæ•°æ¥ç¡®å®šå…¶åº”è¯¥æ˜¯åœ¨è°·å€¼çš„å·¦è¾¹è¿˜æ˜¯å³è¾¹ã€‚å¦‚æœå–ç›¸åæ•°ï¼Œé‚£ä¹ˆå®ƒåœ¨å·¦è¾¹ï¼Œå®ƒå¯¹ç­”æ¡ˆçš„è´¡çŒ®æ˜¯åœ¨å®ƒå·¦è¾¹æ¯”å…¶å°çš„ä¸ªæ•° LiL_iLiâ€‹ï¼›å¦‚æœä¸å–ç›¸åæ•°ï¼Œé‚£ä¹ˆå…¶å¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯æ­£å¸¸è®¡å…¥é€†åºå¯¹ç»Ÿè®¡äº†ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥æ­£å¸¸æ±‚é€†åºå¯¹çš„ä¸ªæ•°ï¼Œå½“å…¶èµ°åˆ°å·¦è¾¹çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±åœ¨æ ‘çŠ¶æ•°ç»„ä¸Šæ’¤é”€å®ƒçš„è´¡çŒ®ã€‚ä½•æ—¶å®ƒä¼šè·‘åˆ°å·¦è¾¹ï¼Ÿå½“åœ¨å®ƒå·¦è¾¹æœ‰ xxx ä¸ªæ¯”å®ƒå°çš„æ•°ï¼Œå³è¾¹æœ‰ xxx ä¸ªæ¯”å®ƒå°çš„æ•°çš„æ—¶å€™ï¼Œå°±ä¼šåˆ‡æ¢ï¼Œæ­¤æ—¶ç›´æ¥ç»§æ‰¿åŸæ¥çš„è´¡çŒ®å³å¯ã€‚æ ‘çŠ¶æ•°ç»„ä¸Šå€å¢å³å¯ã€‚ä»£ç ã€‚ çº¿æ®µæ ‘ çº¿æ®µæ ‘æ˜¯ä¸€ç§åŠŸèƒ½å¼ºå¤§çš„äºŒå‰æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç»´æŠ¤åŠç¾¤ä¸Šçš„ä¿¡æ¯ï¼ˆæ»¡è¶³ç»“åˆå¾‹ï¼‰ã€‚ å¯¹äºä¸€èˆ¬æƒ…å†µï¼Œæˆ‘ä»¬ä½¿ç”¨å †å¼çº¿æ®µæ ‘æ¥å­˜å‚¨çº¿æ®µæ ‘ï¼›å¯¹äºç©ºé—´å¼€ä¸ä¸‹çš„æƒ…å†µï¼Œæˆ‘ä»¬ä½¿ç”¨åŠ¨æ€å¼€ç‚¹æ¥å­˜å‚¨çº¿æ®µæ ‘ã€‚ çº¿æ®µæ ‘åŸºæœ¬ç»“æ„ è¿™é‡Œä¸å†èµ˜è¿°çº¿æ®µæ ‘çš„åŸºæœ¬ç»“æ„ï¼Œä½†æ˜¯å®ƒæ˜¯ä¸€ä¸ªå¾ˆæœ‰ç”¨çš„ä¸œè¥¿ã€‚ [CF1556G] Gates to Another Worldã€‚ç©ºé—´å¤§ç›—åœ¨ 2n2^n2n ä¸ªä¸–ç•Œä¸­æ—…è¡Œï¼Œç¼–å·ä¸º i,ji,ji,j çš„ä¸–ç•Œèƒ½ç©¿è¶Šå½“ä¸”ä»…å½“ popcount(iâŠ•j)=1\\mathrm{popcount}(i \\oplus j)=1popcount(iâŠ•j)=1ã€‚æœ‰ mmm æ¬¡æ“ä½œï¼Œæ¯æ¬¡è¯¢é—® a,ba,ba,b æ˜¯å¦èƒ½äº’ç›¸åˆ°è¾¾ï¼Œæˆ–è€…æ‘§æ¯ç¼–å·åœ¨ [l,r][l,r][l,r] ä¹‹é—´çš„æ‰€æœ‰ä¸–ç•Œï¼Œä¿è¯æ²¡æœ‰ä¸–ç•Œä¼šè¢«æ‘§æ¯ä¸¤æ¬¡ã€‚nâ‰¤50,mâ‰¤5Ã—104n\\le 50,m\\le 5\\times 10^4nâ‰¤50,mâ‰¤5Ã—104ã€‚ é¦–å…ˆæ— è„‘è€ƒè™‘é€†æ—¶æ—…äººï¼Œå°†åˆ ç‚¹æ”¹æˆåŠ ç‚¹ã€‚è¿™æ ·ä¸€å®šæ˜¯æ›´å¥½åšçš„ã€‚ æœ€ä¸»è¦çš„é—®é¢˜æ˜¯ï¼Œå¦‚ä½•ç”¨ä¸€ç§æ–¹å¼æ¥å‹ç¼©å›¾ï¼Ÿå¯¹äºä¸€ä¸ªæ²¡æœ‰è¢«åˆ ç‚¹çš„è¿ç»­ 2i2^i2i æ®µï¼Œä¸€å®šæ˜¯è¿é€šçš„ã€‚è¿™æ˜¯ä»€ä¹ˆï¼Ÿ çº¿æ®µæ ‘ã€‚ æ³¨æ„ä¸€ä¸ªä½ç½®åªä¼šè¢«åˆ é™¤ä¸€æ¬¡ï¼Œè¿™å¾ˆå¥½ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨çº¿æ®µæ ‘ä¸ŠåŒºé—´æŸ“è‰²ï¼Œä»£è¡¨è¿™äº›ç‚¹å­˜æ´»åˆ°äº† iii æ—¶åˆ»ã€‚ è¿™æ ·å¯¹äºåŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ä¸Šçš„å­˜åœ¨çš„ç‚¹ï¼Œæ‰æ˜¯æœ‰æ„ä¹‰çš„ç‚¹ï¼Œå…¶ä½™æ‰€æœ‰ç‚¹éƒ½å¯ä»¥è¢«æ˜ å°„åˆ°å®ƒä»¬èº«ä¸Šã€‚å¯¹äºæ¯ä¸ªèŠ‚ç‚¹å°†åœ¨ minâ¡{lsi,rsi}\\min\\{ls_i,rs_i\\}min{lsiâ€‹,rsiâ€‹} æ—¶åˆ»å°†å®ƒçš„å·¦å³å„¿å­åˆ†è£‚å¼€ï¼ˆä¸å†è¿é€šï¼‰ï¼Œå¹¶æŸ¥é›†ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ å»¶è¿Ÿæ ‡è®° è¿™ä¸ªä¸œè¥¿ä¸åªè¢«ç”¨åœ¨çº¿æ®µæ ‘ä¸Šï¼Œä½†ä»çº¿æ®µæ ‘ç»“æ„åŸºæœ¬å¯ä»¥ä»‹ç»å‡ºå®ƒçš„å¤§éƒ¨åˆ†åº”ç”¨ã€‚ä»¥ä¸‹é—®é¢˜éƒ½å¯ä»¥ç›´æ¥ä½¿ç”¨å¤šå…ƒæ ‡è®°æ¥å¤„ç†ï¼š åŒºé—´æœ€å¤§å­æ®µå’Œï¼šç»´æŠ¤å‰ç¼€åç¼€æœ€å¤§å­æ®µå’Œã€åŒºé—´å’Œå’Œç­”æ¡ˆå³å¯ï¼› åŒºé—´å¹³æ–¹å’Œï¼šä¸éš¾æ ¹æ®åŒºé—´å’Œè®¡ç®—å‡ºæ–°çš„åŒºé—´å¹³æ–¹å’Œï¼› åŒºé—´åŠ ç­‰å·®æ•°åˆ—å•ç‚¹æ±‚å’Œï¼šæ¯ä¸ªç‚¹ç»´æŠ¤ä¸€ä¸ª dddï¼Œä»£è¡¨å…¶åŠ ä¸Šçš„æ˜¯ dÃ—id\\times idÃ—iï¼Œå…¶ä¸­ iii æ˜¯ä¸‹æ ‡ï¼Œç„¶åå†ç»´æŠ¤ä¸€ä¸ªåŒºé—´åŠ æ ‡è®°å³å¯ã€‚ [CF446C] DZY Loves Fibonacci Numbers.åŒºé—´åŠ æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ŒåŒºé—´æ±‚å’Œã€‚ å°†å¹¿ä¹‰æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å‰ä¸¤é¡¹ä½œä¸ºæ ‡è®°æ‰“åœ¨çº¿æ®µæ ‘ä¸­ï¼Œåˆå¹¶æ—¶ç›´æ¥åŠ èµ·æ¥å°±å¯ä»¥ã€‚å†åŠ ä¸Šæ–æ³¢é‚£å¥‘æ•°åˆ—çš„æ±‚å’Œå…¬å¼ï¼šâˆ‘i=1nfi=fn+2âˆ’f2\\sum_{i=1}^{n}f_i=f_{n+2}-f_{2}âˆ‘i=1nâ€‹fiâ€‹=fn+2â€‹âˆ’f2â€‹ï¼Œå’Œä¾¿å¯ä»¥ç›´æ¥è®¡ç®—ã€‚ä»£ç ã€‚ çŸ©é˜µä¹˜æ³•ç»´æŠ¤æ ‡è®° å¯ä»¥å‚è€ƒ https://www.luogu.com.cn/blog/George-Plover/qian-tan-xian-xing-lan-biao-ji-wei-hu-ji-qiao-yi-xian-duan-shu-wei-liã€‚ å½“æ ‡è®°å¤§äºä¸€ä¸ªçš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±éœ€è¦æ€è€ƒä¸åŒæ ‡è®°åœ¨ä¸‹ä¼ è¿‡ç¨‹ä¸­çš„ç›¸äº’å½±å“ï¼Œç„¶è€Œè¿™å¾ˆéº»çƒ¦ã€‚å› æ­¤ï¼Œé€šè¿‡æ„é€ å‘é‡å’ŒçŸ©é˜µä¹˜æ³•ï¼Œå¯ä»¥å¾ˆå¥½åœ°ç®€åŒ–è¿™ç±»é—®é¢˜ã€‚ åŒºé—´åŠ åŒºé—´ä¹˜æ˜¯ä¸€ä¸ªç»å…¸é—®é¢˜ï¼Œæˆ‘ä»¬åœ¨ç»Ÿè®¡ä¿¡æ¯æ—¶éœ€è¦ç›´åˆ°å½“å‰ç‚¹çš„å’Œå’ŒåŒºé—´é•¿åº¦ï¼Œå› æ­¤ç»´æŠ¤ï¼š [sumlen]\\begin{bmatrix} sum\\\\ len \\end{bmatrix} [sumlenâ€‹] åŠ æ³•æ“ä½œçš„çŸ©é˜µæ˜¯ [1c01]\\begin{bmatrix}1 &amp; c\\\\0 &amp; 1\\end{bmatrix}[10â€‹c1â€‹]ï¼Œä¹˜æ³•æ“ä½œçš„çŸ©é˜µæ˜¯ [k001]\\begin{bmatrix}k &amp; 0\\\\ 0 &amp; 1 \\end{bmatrix}[k0â€‹01â€‹]ï¼Œè¿™æ ·å°±è½¬åŒ–æˆäº†ä¸€ç§æ“ä½œã€‚ [ICPC2021 Nanjing R] Paimon Segment Treeï¼Œå› ä¸ºè¿™é“é¢˜çš„å­˜åœ¨ï¼Œæˆ‘æƒ³ç§°è¿™ç§æŠ€å·§ä¸ºâ€œæ´¾è’™æ ‡è®°â€ã€‚ çº¿æ®µæ ‘ä¸Šä¸€ä¸ªç»“ç‚¹ç»´æŠ¤ [sa2alen]\\begin{bmatrix}s &amp; a^2 &amp; a &amp; len\\end{bmatrix}[sâ€‹a2â€‹aâ€‹lenâ€‹] ä»£è¡¨ç´¯åŠ å’Œã€åŒºé—´å¹³æ–¹å’Œï¼ŒåŒºé—´å’Œå’ŒåŒºé—´é•¿åº¦ï¼Œæ‰«æçº¿ç»´æŠ¤ç‰ˆæœ¬ç»´ï¼Œæ‰€æœ‰çš„ä¿¡æ¯éƒ½å¯ä»¥ç›´æ¥ç»´æŠ¤ã€‚ä»£ç ã€‚ æ´¾è’™çº¿æ®µæ ‘çš„ç»å…¸åº”ç”¨æ˜¯ç»´æŠ¤å†å²ç‰ˆæœ¬å’Œï¼Œå¾ˆå®¹æ˜“ä½¿ç”¨çŸ©é˜µæè¿°è¿™ä¸ªä¸œè¥¿ã€‚ [NOIP2022] æ¯”èµ›ã€‚ç»™å®šä¸¤ä¸ªåºåˆ—ï¼Œæ¯æ¬¡ç»™å®šä¸€ä¸ªåŒºé—´ [l,r][l,r][l,r]ï¼ŒæŸ¥è¯¢å­åŒºé—´çš„æƒå€¼å’Œï¼Œæƒå€¼å®šä¹‰ä¸ºä¸¤ä¸ªåºåˆ—åŒºé—´æœ€å¤§å€¼çš„ä¹˜ç§¯ã€‚ å¯¹äºè¿™ç§å­åŒºé—´æ±‚å’Œçš„é—®é¢˜ï¼Œå…¶æœ¬è´¨å°±æ˜¯å†å²ç‰ˆæœ¬å’Œã€‚æ‰«æçº¿æ‰«ä¸€ç«¯ï¼Œç„¶åç»´æŠ¤å†å²ç‰ˆæœ¬å’Œã€‚ å¸¸æ•°è¿‡å¤§ï¼Œéœ€è¦å°†çŸ©é˜µæ‹†é™¤ï¼Œå…·ä½“åœ°ï¼Œç”±äºçŸ©é˜µä¸Šä¸æ˜¯ 0/10/10/1 çš„ä½ç½®åªæœ‰ 999 ä¸ªï¼Œå› æ­¤ç»´æŠ¤è¿™äº›ä½ç½®çš„å€¼å³å¯ã€‚ä»£ç ã€‚ æè¶…çº¿æ®µæ ‘ è€ƒè™‘è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼šåŠ å…¥ç»™å®šå®šä¹‰åŸŸçš„ä¸€æ¬¡å‡½æ•°ï¼ŒæŸ¥è¯¢ x=kx=kx=k æ—¶çš„æœ€å°å€¼ã€‚ æ€ä¹ˆåšï¼Ÿè€ƒè™‘ä¸€ç§çº¿æ®µæ ‘ï¼Œç»´æŠ¤ [l,r][l,r][l,r] çš„èŠ‚ç‚¹åªå­˜å‚¨ä¸€ä¸ª midmidmid å¤„å€¼æœ€å°çš„çº¿æ®µã€‚ä¿®æ”¹æ“ä½œå¦‚ä½•å®ç°å‘¢ï¼Ÿå¦‚æœä¿®æ”¹çš„çº¿æ®µä¸æ¯”å½“å‰çº¿æ®µä¼˜ï¼Œé‚£ä¹ˆä¸‹ä¼ ä¿®æ”¹çº¿æ®µï¼›å¦‚æœä¿®æ”¹çº¿æ®µæ¯”å½“å‰çº¿æ®µä¼˜ï¼Œé‚£ä¹ˆä¸‹ä¼ å½“å‰çº¿æ®µã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦ä¸‹ä¼ çš„ä¸€å®šæ˜¯é‚£ä¸ªæ›´åŠ£çš„çº¿æ®µã€‚å¦‚ä½•ä¸‹ä¼ ï¼Ÿåªæœ‰å½“åœ¨æŸä¸€éƒ¨åˆ†çš„çº¿æ®µæœ‰äº¤ç‚¹æ—¶æ‰éœ€è¦ä¸‹ä¼ ã€‚ å•æ¬¡ä¿®æ”¹æ—¶é—´å¤æ‚åº¦ä¸º O(logâ¡2n)O(\\log^2 n)O(log2n)ï¼ŒæŸ¥è¯¢æ—¶ç›´æ¥è®°å½•è·¯è¿‡çš„æ‰€æœ‰çº¿æ®µçš„ç­”æ¡ˆå³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¾ç„¶ä¸º O(logâ¡n)O(\\log n)O(logn)ã€‚ inline void pushup(int o, int l, int r) &#123; T[o].v = min(&#123;T[o].v, T[o &lt;&lt; 1].v, T[o &lt;&lt; 1 | 1].v&#125;); T[o].v = min(&#123;T[o].v, calc(T[o].s, dis[idx[l]]), calc(T[o].s, dis[idx[r]])&#125;); &#125; void update(int o, int l, int r, int x, int y, Seg k) &#123; int mid = l + r >> 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; if (calc(k, dis[mid]) &lt; calc(T[o].s, dis[idx[mid]])) swap(k, T[o].s); // ä¸­ç‚¹å¤„ x å½“å‰çº¿æ®µæ¯” k åŠ£ if (calc(k, dis[idx[l]]) &lt; calc(T[o].s, dis[idx[l]])) update(o &lt;&lt; 1, l, mid, x, y, k); if (calc(k, dis[idx[r]]) &lt; calc(T[o].s, dis[idx[r]])) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); return pushup(o, l, r); &#125; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); pushup(o, l, r); &#125; å‰å¸æœºçº¿æ®µæ ‘ æŒ‡çš„æ˜¯ä¸€ç±»ç»´æŠ¤åŒºé—´æœ€å€¼æ“ä½œä¸å†å²æœ€å€¼çš„çº¿æ®µæ ‘ï¼ˆSegment Tree Beatsï¼‰ã€‚ åŒºé—´æœ€å€¼æ“ä½œ æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤æœ€å¤§å€¼ï¼Œä¸¥æ ¼æ¬¡å¤§å€¼å’Œæœ€å¤§å€¼çš„æ•°é‡ã€‚è¿™æ ·éå†èŠ‚ç‚¹æ—¶æœ‰ä¸‰ç§æƒ…å†µï¼š maâ‰¤xma\\le xmaâ‰¤xï¼Œé‚£ä¹ˆæ— å½±å“ã€‚ se&lt;x&lt;mase&lt;x&lt;mase&lt;x&lt;maï¼Œå¯ä»¥ç›´æ¥æ‰“ä¸Šå»¶è¿Ÿæ ‡è®°è®¡ç®—ã€‚ xâ‰¤sex\\le sexâ‰¤seï¼Œæš´åŠ›é€’å½’ã€‚ å¤§æ¦‚åŠ¿èƒ½åˆ†æä¸€ä¸‹åŠ ä¸Šå®é™…è¡¨ç°è¯æ˜ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¸ºçº¿æ€§å¯¹æ•°ã€‚ åŒºé—´å†å²æœ€å€¼ æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤ä¸€ä¸ªäºŒå…ƒæ ‡è®° (p,q)(p,q)(p,q)ï¼Œä»£è¡¨å…ˆåŠ  ppp å†å¯¹ qqq å– maxâ¡\\maxmaxã€‚é‚£ä¹ˆæ ‡è®°çš„åˆå¹¶å°±æ˜¯ (p1+p2,maxâ¡{q1+p2,q2})(p_1+p_2,\\max\\{q_1+p_2,q_2\\})(p1â€‹+p2â€‹,max{q1â€‹+p2â€‹,q2â€‹})ã€‚è¿™ä¸ªä¸œè¥¿å­˜åœ¨é¢œè‰²æ®µå‡æ‘Šï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º O((n+q)logâ¡n)O((n+q)\\log n)O((n+q)logn)ã€‚ä½¿ç”¨è¿™ç§å¤šå…ƒæ ‡è®°æ€æƒ³å¯ä»¥å¤„ç†ç»å¤§éƒ¨åˆ†çš„å†å²æœ€å€¼é—®é¢˜ã€‚ CPU ç›‘æ§ã€‚è€ƒè™‘æ²¡æœ‰æŸ“è‰²æ“ä½œæ€ä¹ˆåšã€‚ç®€å•ï¼Œç»´æŠ¤æœ€å¤§çš„å†å²åŠ æ ‡è®°ã€‚ å‘ç°ä¸€æ¬¡æŸ“è‰²åæ‰€æœ‰çš„åŠ éƒ½å¯ä»¥è½¬åŒ–ä¸ºæŸ“è‰²ï¼Œå› æ­¤æŸ“è‰²åç›´æ¥å¼€å§‹ç»´æŠ¤æ ‡è®°å³å¯é¿å¼€è®¨è®ºã€‚ int n, m, a[100005]; struct Node &#123; int mx, hmx, setv, addv, hset, hadd, tag; void cover(int v, int hv) &#123; setv = mx = v; addv =-0; if (tag) hset = max(hset, hv); else hset = hv, tag = 1; hmx = max(hmx, hv); &#125; void add(int v, int hv) &#123; hadd = max(hadd, addv + hv); hmx = max(hmx, mx + hv); addv += v; mx += v; &#125; void change(int v, int hv) &#123; if (tag) cover(setv + v, setv + hv); else add(v, hv); &#125; &#125; T[400005]; inline void pushup(int o) &#123; T[o].mx = max(T[o &lt;&lt; 1].mx, T[o &lt;&lt; 1 | 1].mx); T[o].hmx = max(T[o &lt;&lt; 1].hmx, T[o &lt;&lt; 1 | 1].hmx); &#125; inline void pushdown(int o) &#123; T[o &lt;&lt; 1].change(T[o].addv, T[o].hadd); T[o &lt;&lt; 1 | 1].change(T[o].addv, T[o].hadd); T[o].addv = T[o].hadd = 0; if (T[o].tag) &#123; T[o &lt;&lt; 1].cover(T[o].setv, T[o].hset); T[o &lt;&lt; 1 | 1].cover(T[o].setv, T[o].hset); T[o].tag = 0; &#125; &#125; void update(int o, int l, int r, int x, int y, int k, bool type) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return type ? T[o].cover(k, k) : T[o].change(k, k), void(); int mid = l + r >> 1; pushdown(o); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k, type); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k, type); pushup(o); &#125; æ‰«æçº¿ å¯¹äºä¸€ä¸ªé«˜ç»´ç©ºé—´çš„åæ ‡é™åˆ¶ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º BBB ç»´æ­£äº¤èŒƒå›´é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨æ‰«æçº¿å°†å…¶é™ç»´ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰«æçº¿ç»´æŠ¤ä¸€ç»´ï¼Œæ•°æ®ç»“æ„ç»´æŠ¤å¦ä¸€ç»´ã€‚ å·®åˆ†å¤„ç† å¦‚æœç»´æŠ¤çš„ä¿¡æ¯å¯ä»¥å·®åˆ†ï¼Œé‚£ä¹ˆç›´æ¥å·®åˆ†æ‰ã€‚æ¯”å¦‚çŸ©å½¢é¢ç§¯å¹¶é—®é¢˜ï¼Œé™æ€åŒºé—´å†…ä¸åŒæ•°ä¸ªæ•°é—®é¢˜ã€‚å°†é—®é¢˜è½¬åŒ–ä¸ºçŸ©å½¢æ“ä½œï¼Œç„¶åæ‰«æçº¿ç»´æŠ¤ã€‚ æ­¤é—®é¢˜çš„åŸºç¡€å½¢æ€æ˜¯äºŒç»´æ•°ç‚¹ï¼šå¹³é¢ä¸Šæœ‰ nnn ä¸ªç‚¹ (i,ai)(i,a_i)(i,aiâ€‹)ï¼Œæ¯æ¬¡æŸ¥è¯¢ä¸€ä¸ªçŸ©å½¢å†…çš„ç‚¹çš„ä¸ªæ•°ã€‚æ­¤çŸ©å½¢æ˜¯ä¸€ä¸ª 4-side çš„çŸ©å½¢ï¼Œå¯ä»¥é€šè¿‡å·®åˆ†çš„æ–¹å¼å°†å…¶è½¬åŒ–ä¸º 3-sideï¼Œç„¶åå†æ‰«æçº¿ç»´æŠ¤ä¸€ä¸‹å˜æˆ 2-sideï¼Œè¿™æ ·å°±æˆäº†ä¸€ä¸ªå¹³å‡¡çš„å•ç‚¹ä¿®æ”¹åŒºé—´æŸ¥è¯¢çš„é—®é¢˜ã€‚ äºŒç»´æ•°ç‚¹æ¨¡å‹éå¸¸çš„æœ‰ç”¨ï¼Œç±»ä¼¼äºä»¥ä¸‹é—®é¢˜éƒ½å¯ä»¥å¤„ç†ï¼š çŸ©å½¢é¢ç§¯å¹¶ã€‚4-side å·®åˆ†æˆ 3-side çš„ä¿®æ”¹ï¼Œç„¶åæ‰«æçº¿æ‰«æï¼Œçº¿æ®µæ ‘ç»´æŠ¤æ—¶çœ‹æ˜¯å¦è¢«è¦†ç›–æ¥è¿›è¡Œ pushupï¼Œæœ€åæŸ¥è¯¢å…¨å±€è¢«è¦†ç›–çš„æ•°é‡ã€‚ å°† xxx è½¬åŒ–ä¸º lll çš„é™åˆ¶ï¼Œyyy è½¬åŒ–ä¸º rrr çš„é™åˆ¶ï¼Œç„¶åçœ‹ iii ä¼šå¯¹å“ªäº› [l,r][l,r][l,r] äº§ç”Ÿè´¡çŒ®ï¼Œæœ€åæ˜¯çŸ©å½¢é¢ç§¯åŠ å’Œã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œå·®åˆ†å’Œæ‰«æçº¿æ˜¯æˆ‘ä»¬çš„é™ç»´æ‰‹æ®µï¼Œæœ€åä¸€ä¸ª 2-side çš„é—®é¢˜å°±æ˜¯å¹³å‡¡çš„ï¼Œä½¿ç”¨åˆé€‚çš„æ•°æ®ç»“æ„ï¼ˆåŒºé—´ä¿®æ”¹å•ç‚¹æŸ¥è¯¢ï¼Œå•ç‚¹ä¿®æ”¹åŒºé—´æŸ¥è¯¢ï¼ŒåŒºé—´ä¿®æ”¹åŒºé—´æŸ¥è¯¢ï¼‰ç»´æŠ¤å³å¯ã€‚ ç±»ä¼¼çš„è¿˜æœ‰å…¶å®ƒçš„æ•°ç‚¹é—®é¢˜ï¼Œæ¯”å¦‚ä¸‰ç»´ååºï¼ˆCDQ + æ‰«æçº¿ + æ•°æ®ç»“æ„ï¼‰ï¼Œå¼ºåˆ¶åœ¨çº¿çš„äºŒç»´æ•°ç‚¹ï¼ˆå¯ä»¥ä½¿ç”¨ä¸»å¸­æ ‘ï¼‰ï¼Œå¼ºåˆ¶åœ¨çº¿åŠ¨æ€äºŒç»´æ•°ç‚¹ï¼ˆå¿…é¡»æ ‘å¥—æ ‘ï¼‰ï¼Œä½¿ç”¨åˆç†çš„æ‰‹æ®µè¿›è¡Œé™ç»´å³å¯ã€‚ æ³¨æ„ï¼Œæ‰«æçº¿ä¸ä¸€å®šè¦æ‰«æ—¶é—´ç»´ï¼Œå¯ä»¥æ‰«åºåˆ—ç»´ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœå•ç‚¹ä¿®æ”¹å¯ä»¥è½»æ¾æ’¤é”€ï¼Œé‚£ä¹ˆåŒºé—´ä¿®æ”¹å°±é€€åŒ–æˆäº†å•ç‚¹ä¿®æ”¹ï¼Œç„¶åæ•°æ®ç»“æ„ç»´æŠ¤æ“ä½œåºåˆ—æ“ä½œçš„è¿‡ç¨‹ã€‚ å¤šæ¬¡è¯¢é—®åŒºé—´ä¸­åªå‡ºç°æ¬¡æ•°ä¸ºå¶æ•°çš„æ•°çš„å¼‚æˆ–å’Œï¼Œç»™å‡ºä¸€ä¸ªçº¿æ€§å¯¹æ•°çš„åšæ³•ã€‚ å“æˆ‘ä¼šç»´æŠ¤å¥‡æ•°ï¼æ‰€ä»¥è¿™é“é¢˜å°±æ˜¯ç›´æ¥åŒºé—´æ‰€æœ‰å‡ºç°æ•°çš„å¼‚æˆ–å’Œå¼‚æˆ–æ‰å¥‡æ•°å¼‚æˆ–å’Œã€‚å‰è€…å¯ä»¥é‡‡ç”¨æ‰«æçº¿ï¼Œåªç»´æŠ¤è¿™ä¸ªæ•°æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®çš„è´¡çŒ®ã€‚ ã€ç¾å›¢æ¯2021ã€‘A. æ•°æ®ç»“æ„ã€‚nnn ä¸ªæ•°çš„åºåˆ—ï¼Œæ¯æ¬¡æŸ¥è¯¢å¦‚æœå°† [l,r][l,r][l,r] ä¸­çš„å…ƒç´ éƒ½åŠ ä¸Š 111 åå…¨å±€å‡ºç°çš„æ•°çš„ä¸ªæ•°ã€‚ å…ˆå‡å®š n+1n+1n+1 ä¸ªæ•°å…¨éƒ¨å‡ºç°ï¼Œç„¶åè€ƒè™‘æ•° iii ä¸å‡ºç°çš„æ¡ä»¶ï¼š æ‰€æœ‰çš„ iii éƒ½å‡ºç°åœ¨ [l,r][l,r][l,r] å†…ï¼› æ‰€æœ‰çš„ iâˆ’1i-1iâˆ’1 éƒ½ä¸å‡ºç°åœ¨ [l,r][l,r][l,r] å†…ã€‚ ç„¶åå°±æ˜¯æ‰«æçº¿é™åˆ¶çŸ©å½¢å³å¯ã€‚ä»£ç ã€‚ [Ynoi2001] é›ªã«å’²ãèŠ±ã€‚å®šä¹‰ï¼šf(l,r)=andâ¡i=lraiÃ—orâ¡i=lrbiÃ—gcdâ¡i=lrcif(l,r)=\\operatorname{and}\\limits_{i=l}^r a_i\\times \\operatorname{or}\\limits_{i=l}^r b_i\\times \\gcd\\limits_{i=l}^r c_if(l,r)=andi=lrâ€‹aiâ€‹Ã—ori=lrâ€‹biâ€‹Ã—i=lgcdrâ€‹ciâ€‹å¤šæ¬¡è¯¢é—®ï¼šg(l,r)=âˆ‘i=lrâˆ‘j=irf(i,j) mod 232g(l,r)=\\sum_{i=l}^r \\sum_{j=i}^r f(i,j) \\bmod 2^{32}g(l,r)=i=lâˆ‘râ€‹j=iâˆ‘râ€‹f(i,j)mod232 æ‰«æçº¿ç»´æŠ¤å³ç«¯ç‚¹ rrrï¼Œç»´æŠ¤ sis_isiâ€‹ ä»£è¡¨ âˆ‘pâ‰¤iâˆ‘pâ‰¤qâ‰¤rf(p,q)\\sum_{p\\le i} \\sum_{p\\le q\\le r}f(p,q)âˆ‘pâ‰¤iâ€‹âˆ‘pâ‰¤qâ‰¤râ€‹f(p,q)ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º srâˆ’slâˆ’1s_r-s_{l-1}srâ€‹âˆ’slâˆ’1â€‹ã€‚ è®°æ‰«æåˆ°å½“å‰çŠ¶æ€æ—¶ï¼ŒA,B,CA,B,CA,B,C åˆ†åˆ«ä»£è¡¨è¿ç®—ä¹‹åçš„åç¼€ç»“æœã€‚ å½“ râ†’r+1r\\rightarrow r+1râ†’r+1 æ—¶ï¼Œè€ƒè™‘ sis_isiâ€‹ å¦‚ä½•æ”¹å˜ã€‚å¦‚æœ Ai,Bi,CiA_i,B_i,C_iAiâ€‹,Biâ€‹,Ciâ€‹ å‡æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆ sis_isiâ€‹ çš„å˜åŒ–é‡å’Œä¸Šæ¬¡ä¸€æ ·ï¼Œå°†å®ƒä»¬çš„â€œæ›´æ–°æ ‡è®°â€çš„æ—¶é—´æˆ³å¢å¤§ 111 å³å¯ï¼ˆå®é™…ä¸Šåªéœ€è¦è®°å½•æ›´æ–°æ—¶é—´ï¼Œç„¶åç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹çš„æœ€åæ›´æ–°æ—¶é—´ï¼‰ã€‚ åªæœ‰åé¢ä¸€æ®µ O(logâ¡V)O(\\log V)O(logV) çš„åŒºé—´çš„ fff å€¼ä¸åŒäº rrr å˜åŒ–ä¹‹å‰çš„ï¼ˆè®¾ä¸º pppï¼‰ã€‚å¯¹äº [p,r][p,r][p,r] ç›´æ¥æš´åŠ›è®¡ç®—å®ƒä»¬åœ¨å½“å‰ rrr ä¸‹çš„è´¡çŒ®çš„å¢é‡ã€‚å…·ä½“æ¥è¯´ï¼Œç»´æŠ¤ä¸€ä¸ª viv_iviâ€‹ ä»£è¡¨ âˆ‘l=1if(l,r)\\sum_{l=1}^{i}f(l,r)âˆ‘l=1iâ€‹f(l,r) å°±å¯ä»¥ç›´æ¥è®¡ç®—ã€‚ æ—¶é—´å¤æ‚åº¦ O(nlogâ¡V+m)O(n\\log V+m)O(nlogV+m)ï¼Œç¦»çº¿åæ‰‹å†™å†…å­˜æ± å¡å¸¸å³å¯ã€‚ä»£ç ã€‚ åˆ†æ²»å¤„ç† å¤–æ˜Ÿæ—…è€…ç¦»å¼€äº†åœ°çƒã€‚æˆ‘ä»¬å°†åœ¨æœªçŸ¥æ—¶é—´è¡¥å……è¿™éƒ¨åˆ†å†…å®¹ã€‚ çº¿æ®µæ ‘åˆå¹¶ å¯ä»¥ä»¥ O(nlogâ¡n)O(n\\log n)O(nlogn) çš„æ—¶é—´åˆå¹¶ä¸¤æ£µæ»¡çº¿æ®µæ ‘çš„ä¿¡æ¯ã€‚ä½†å¯¹äºå¸¸ç”¨çš„åœ¨æ ‘ä¸Šè¿›è¡Œçº¿æ®µæ ‘åˆå¹¶ï¼Œç”±äºæ¯æ£µçº¿æ®µæ ‘åˆå§‹åªç”¨ä¸€ä¸ªä¿¡æ¯ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogâ¡n)O(n\\log n)O(nlogn) çš„ã€‚ int merge(int p, int q, int l, int r) &#123; if (!p || !q) return p + q; if (l == r) return T[p].cnt += T[q].cnt, p; int mid = l + r >> 1; T[p].ls = merge(T[p].ls, T[q].ls, l, mid); T[p].rs = merge(T[p].rs, T[q].rs, mid + 1, r); pushup(p); return p; &#125; é¢œè‰²æ®µå‡æ‘Š å¯¹äºåŒºé—´æŸ“è‰²æ“ä½œï¼Œæ¯æ¬¡åªä¼šå¢åŠ  O(1)O(1)O(1) ä¸ªè¿ç»­é¢œè‰²æ®µï¼Œå‡æ‘Šçš„é¢œè‰²æ®µæ’å…¥åˆ é™¤æ¬¡æ•°ä¸º O(n+m)O(n+m)O(n+m)ã€‚ å¯¹äºåŒºé—´æŸ“è‰²ç±»é—®é¢˜ï¼ˆåŒºé—´æŸ“è‰²ã€æ’åºç­‰æ“ä½œï¼‰ï¼Œç”¨ç‚æœµè‰æ ‘ç»´æŠ¤ç±»çš„é—®é¢˜ï¼Œéƒ½å­˜åœ¨é¢œè‰²æ®µå‡æ‘Šã€‚å­˜åœ¨ 2âˆ¼32\\sim 32âˆ¼3 å€çš„å¸¸æ•°ã€‚ ç‚æœµè‰æ ‘æ¨¡æ¿é€ŸæŸ¥ struct Node &#123; int l, r; mutable int v; // è¿™ä¸ª v æ¥ä¸‹æ¥éœ€è¦ä¿®æ”¹ Node(int l = 0, int r = 0, int v = 0) : l(l), r(r), v(v) &#123;&#125; bool operator&lt; (const Node &amp;a) const &#123; return l &lt; a.l; &#125; &#125;; set&lt;Node> T; inline auto split(int p) &#123; if (p > n) return T.end(); auto it = T.lower_bound(Node(p)); if (it != T.end() &amp;&amp; it->l == p) return it; --it; int l = it->l, r = it->r; i64 v = it->v; T.erase(it); T.insert(Node(l, p - 1, v)); return T.insert(Node(p, r, v)).first; &#125; [CF444C] DZY Loves Colorsã€‚æœ‰ä¸€ä¸ª nnn ä¸ªå…ƒç´ ç»„æˆçš„åºåˆ—ï¼Œæ¯ä¸ªå…ƒç´ æœ‰ä¸¤ä¸ªå±æ€§ï¼šé¢œè‰² cic_iciâ€‹ å’Œæƒå€¼ wiw_iwiâ€‹ã€‚cic_iciâ€‹ åˆå§‹ä¸º iiiï¼Œwiw_iwiâ€‹ åˆå§‹ä¸º 000ã€‚mmm æ¬¡æ“ä½œï¼Œæ“ä½œæœ‰ä¸¤ç§ï¼š1 l r xï¼šå¯¹ iâˆˆ[l,r]i\\in [l,r]iâˆˆ[l,r] çš„æ‰€æœ‰ iii è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼šè®¾ç¬¬ iii ä¸ªå…ƒç´  åŸæ¥ çš„é¢œè‰²ä¸º yyyï¼Œæ‚¨è¦æŠŠç¬¬ iii ä¸ªå…ƒç´ çš„é¢œè‰²æ”¹ä¸º xxxï¼Œæƒå€¼ å¢åŠ  âˆ£yâˆ’xâˆ£|y-x|âˆ£yâˆ’xâˆ£ã€‚2 l rï¼šæ±‚ âˆ‘i=lrwi\\sum\\limits_{i=l}^r w_ii=lâˆ‘râ€‹wiâ€‹ã€‚1â‰¤n,mâ‰¤1051\\le n,m\\le 10^51â‰¤n,mâ‰¤105ï¼Œ1â‰¤xâ‰¤1081\\le x\\le 10^81â‰¤xâ‰¤108ã€‚ æˆ‘ä»¬è®°ä¸€ä¸ª ccc ä»£è¡¨åŒºé—´é¢œè‰²ï¼Œä¸ä¸€æ ·æ—¶è®°ä¸º âˆ’1-1âˆ’1ã€‚å¦‚æœä¸€æ ·åˆ™æ‰“æ ‡è®°ä¿®æ”¹ï¼Œä¸ä¸€æ ·åˆ™æš´åŠ›é€’å½’ä¿®æ”¹ã€‚ä¸€æ¬¡åŒºé—´æŸ“è‰²åªä¼šäº§ç”Ÿä¸¤ä¸ªæ–°çš„ç«¯ç‚¹ï¼Œæš´åŠ›æŸ¥è¯¢çš„æ¬¡æ•°ä¸º O(n+m)O(n+m)O(n+m) çº§åˆ«ã€‚å› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º O((n+m)logâ¡n)O((n+m)\\log n)O((n+m)logn)ã€‚ä»£ç ã€‚ å•ä¾§é€’å½’ç»“æ„ [CTT2012 Day 1] æ¥¼æˆ¿é‡å»ºã€‚å•ç‚¹ä¿®æ”¹ï¼Œè¯¢é—®å…¨å±€æœ‰å¤šå°‘ä½ç½®æ˜¯å‰ç¼€æœ€å¤§å€¼ã€‚ ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ã€‚ä¸€ä¸ªèŠ‚ç‚¹è®°å½•ä¸¤ä¸ªæ•°ï¼šåŒºé—´æ‰€å¯¹åº”çš„ç­”æ¡ˆï¼Œå½“å‰åŒºé—´çš„æœ€å¤§æ–œç‡ã€‚ä¿®æ”¹æ—¶å¾ˆå®¹æ˜“å®ç°ï¼Œå…³é”®æ˜¯ï¼Œpushupï¼Ÿé—®é¢˜åœ¨äºå¦‚ä½•ç»Ÿè®¡å½“å‰èŠ‚ç‚¹çš„ç­”æ¡ˆï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚ä½•ç»Ÿè®¡å³åŠæ®µåœ¨è¢«å·¦åŠæ®µå½±å“ä¹‹ååº”è¯¥å¦‚ä½•è®¡ç®—ç­”æ¡ˆã€‚æ€ä¹ˆåŠï¼Ÿä¸ä¼šï¼ä¿—è¯è¯´çš„å¥½ï¼Œé‚£ä¹ˆç›´æ¥é€’å½’ä¸‹å»ï¼ å¦‚æœå³åŒºé—´çš„æœ€å¤§å€¼å°äºç­‰äºå·¦åŒºé—´ï¼Œé‚£ä¹ˆå°±è¢«å…¨éƒ¨æŒ¡ä½äº†ã€‚å¦åˆ™é€’å½’è€ƒè™‘å³åŠæ®µï¼Œè¿™æ ·æ‰€æœ‰çš„è´¡çŒ®éƒ½å¯ä»¥è®¡ç®—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; struct Node &#123; int v; double k; &#125; T[400005]; double a[100005]; int pushup(int o, int l, int r, double k) &#123; if (T[o].k &lt;= k) return 0; if (a[l] > k) return T[o].v; if (l == r) return 0; int mid = l + r >> 1; if (T[o &lt;&lt; 1].k &lt;= k) return pushup(o &lt;&lt; 1 | 1, mid + 1, r, k); return pushup(o &lt;&lt; 1, l, mid, k) + T[o].v - T[o &lt;&lt; 1].v; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = &#123;1, a[x]&#125;, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o].k = max(T[o &lt;&lt; 1].k, T[o &lt;&lt; 1 | 1].k); T[o].v = T[o &lt;&lt; 1].v + pushup(o &lt;&lt; 1 | 1, mid + 1, r, T[o &lt;&lt; 1].k); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; while (m--) &#123; int x, y; cin >> x >> y; a[x] = 1.0 * y / x; update(1, 1, n, x, y); cout &lt;&lt; T[1].v &lt;&lt; \"\\n\"; &#125; return 0; &#125; [CF1340F] Nastya and CBSã€‚ç»´æŠ¤ä¸€ä¸ªæœ‰ kkk ä¸­æ‹¬å·çš„åºåˆ—ï¼Œæ”¯æŒå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢æ˜¯å¦å¯ä»¥åŒ¹é…ã€‚ å¿«é€Ÿæ±‚è§£æ‹¬å·åŒ¹é…å¯ä»¥ä½¿ç”¨å“ˆå¸Œï¼Œç”±æ­¤ä¸éš¾å¾—å‡ºä¸€ä¸ªåºåˆ—åˆ†å—çš„åšæ³•ã€‚è¿™é‡Œæˆ‘ä»¬è€ƒè™‘ logâ¡\\loglog åšæ³•ã€‚ æˆ‘ä»¬è€ƒè™‘å°†æ•´ä¸ªç»“æ„æ”¾åˆ°çº¿æ®µæ ‘ä¸Šï¼Œå½“åŒ¹é…å®Œä¹‹åï¼Œè¿˜å‰©ä¸‹ logâ¡\\loglog ä¸ªå“ˆå¸Œå€¼ï¼Œè¿™æ ·ç›´æ¥åˆå¹¶å³å¯ã€‚ å¦‚ä½•åˆå¹¶ä¸¤æ®µçš„å“ˆå¸Œå€¼ï¼Ÿå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œå…¶åŒ¹é…åå¿…å®šå‰©ä½™ä¸€å †å·¦æ‹¬å·æˆ–è€…ä¸€å †å³æ‹¬å·ã€‚ç”¨ vrvrvr ä»£è¡¨å³æ‹¬å·çš„åŒ¹é…æƒ…å†µï¼Œvlvlvl ä»£è¡¨å·¦æ‹¬å·çš„åŒ¹é…æƒ…å†µã€‚åœ¨åˆå¹¶æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æ±‚è§£ä¸€å®šé•¿åº¦çš„æ‹¬å·çš„å“ˆå¸Œå€¼ï¼Œè¿™åœ¨çº¿æ®µæ ‘ä¸Šå•ä¾§é€’å½’ä¸‹å»å°±å¯ä»¥å®ç°ã€‚ å¯¹äºæ±‚è§£ä¸€æ®µçš„ä¸€å®šé•¿åº¦çš„å“ˆå¸Œå€¼ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨çº¿æ®µæ ‘ä¸Šå•ä¾§é€’å½’ä¸‹å»æ¥æ±‚è§£ã€‚ä»£ç ã€‚ å‡½æ•°æœ€å€¼çš„åŠ¨æ€ç»´æŠ¤ æ—¶é—´å¤æ‚åº¦åˆ†æå¯ä»¥å‚è€ƒ EI çš„åšå®¢ æˆ–è€…é›†è®­é˜Ÿè®ºæ–‡ã€‚KTT ç”¨äºç»´æŠ¤å¢é‡å‡½æ•°çš„æœ€å€¼ã€‚æˆ‘ä»¬ç»´æŠ¤ xxx å˜å¤§åå­æ ‘é‡Œä½¿å¾—æŸä¸ª maxâ¡\\maxmax æ‰€å–å‡½æ•°ç¬¬ä¸€æ¬¡å‘ç”Ÿæ”¹å˜çš„ xxx çš„å€¼ï¼Œå½“ä¸‹ä¸€æ¬¡è¯¢é—®è¶…è¿‡è¿™ä¸€ xxx æ—¶ï¼Œæˆ‘ä»¬é€’å½’ä¸‹å»å°†å‘ç”Ÿæ›¿æ¢çš„éƒ¨åˆ†é‡ç½®ã€‚ æ¨¡æ¿ã€‚æ±‚æœ€å¤§å­æ®µå’Œéœ€è¦ç»´æŠ¤ sum,lmax,rmaxsum,lmax,rmaxsum,lmax,rmax å’Œ ansansansã€‚æˆ‘ä»¬è€ƒè™‘åŒºé—´åŠ æ“ä½œå¯¹å®ƒä»¬çš„æ”¹å˜ã€‚ åŒºé—´åŠ  kkkï¼Œå¦‚æœç­”æ¡ˆé€‰æ‹©çš„åŒºé—´æ²¡æœ‰æ”¹å˜ï¼Œé‚£ä¹ˆè¯¥å€¼ä¼šå¢åŠ  lklklkï¼Œlll ä¸ºé€‰æ‹©çš„åŒºé—´é•¿åº¦ã€‚å››ä¸ªä¿¡æ¯æ”¹ç”¨ä¸€æ¬¡å‡½æ•°æ¥ç»´æŠ¤ï¼Œä½¿å…¶è¡¨ç¤º ls+bls+bls+bã€‚è¿™æ ·å°±å¯ä»¥ç›´æ¥è®¡ç®—å½±å“ã€‚ çº¿æ®µæ ‘æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤ä¸€ä¸ª xxxï¼Œè¡¨ç¤ºåŒºé—´åŠ è¶…è¿‡ xxx æ—¶ï¼Œç­”æ¡ˆé€‰æ‹©åŒºé—´ä¼šå‘ç”Ÿæ”¹å˜ã€‚pushup æ—¶ï¼Œxxx è¦å¯¹ä¸‰ä¸ªå˜é‡çš„ä¸åŒæ–¹æ¡ˆçš„äº¤ç‚¹å– minâ¡\\minminã€‚ ä¿®æ”¹æ—¶é—´å¤æ‚åº¦ä¸º O(logâ¡3n)O(\\log^3 n)O(log3n)ã€‚ä»£ç ã€‚ ä¾‹é¢˜ çº¿æ®µæ ‘çš„æ›´å¤šæŠ€å·§å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ï¼ [Luogu P5278] ç®—æœ¯å¤©æ‰â‘¨ä¸ç­‰å·®æ•°åˆ— Portal. å‘ç°æ¡ä»¶éå¸¸ä¸¥è‹›ï¼Œå› æ­¤å¯ä»¥è€ƒè™‘å“ˆå¸Œä¹‹ç±»çš„æ–¹æ³•ï¼Œè¿™é‡Œä¸åšèµ˜è¿°ã€‚ ä¸€æ®µåŒºé—´å¯ä»¥é‡æ’ä¸ºç­‰å·®æ•°åˆ—ï¼Œå½“ä¸”ä»…å½“æ»¡è¶³ï¼ˆd=0d=0d=0 å…ˆç‰¹åˆ¤æ‰ï¼‰ï¼š maxâ¡âˆ’minâ¡=dÃ—(lenâˆ’1)\\max -\\min =d\\times (len-1)maxâˆ’min=dÃ—(lenâˆ’1)ï¼› gcdâ¡i=lrâˆ’1(ai+1âˆ’ai)=d\\gcd_{i=l}^{r-1}(a_{i+1}-a_i)=dgcdi=lrâˆ’1â€‹(ai+1â€‹âˆ’aiâ€‹)=dï¼› åºåˆ—ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚ ç”¨çº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ç¬¬ä¸‰æ¡å¯ä»¥ä½¿ç”¨ setã€map ç»´æŠ¤ä¸€ä¸ªæ•°æœ€å·¦è¾¹çš„å‡ºç°ä½ç½®ï¼Œç„¶åç”¨çº¿æ®µæ ‘ç»´æŠ¤è¿™ä¸ªå€¼çš„æœ€å°å€¼ï¼Œå¦‚æœè¿™ä¸ªæ•°å°äº lllï¼Œé‚£ä¹ˆä¸€å®šæ²¡æœ‰é‡å¤å…ƒç´ ã€‚ä»£ç ã€‚ * [Ynoi2015] çºµä½¿æ—¥è–„è¥¿å±± Portal.ç‚æœµè‰æƒ³è®©ä½ ç»´æŠ¤ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„æ­£æ•´æ•°åºåˆ— a1,a2,â€¦,ana_1,a_2,\\ldots,a_na1â€‹,a2â€‹,â€¦,anâ€‹ï¼Œæ”¯æŒä¿®æ”¹åºåˆ—ä¸­æŸä¸ªä½ç½®çš„å€¼ã€‚æ¯æ¬¡ä¿®æ”¹åé—®å¯¹åºåˆ—é‡å¤è¿›è¡Œä»¥ä¸‹æ“ä½œï¼Œéœ€è¦è¿›è¡Œå‡ æ¬¡æ“ä½œæ‰èƒ½ä½¿åºåˆ—å˜ä¸ºå…¨ 000ï¼ˆè¯¢é—®ååºåˆ—å’Œè¯¢é—®å‰ç›¸åŒï¼Œä¸ä¼šå˜ä¸ºå…¨ 000ï¼‰ï¼šé€‰å‡ºåºåˆ—ä¸­æœ€å¤§å€¼çš„å‡ºç°ä½ç½®ï¼Œè‹¥æœ‰å¤šä¸ªæœ€å¤§å€¼åˆ™é€‰ä½ç½®æ ‡å·æœ€å°çš„ä¸€ä¸ªï¼Œè®¾ä½ç½®ä¸º xxxï¼Œåˆ™å°† axâˆ’1,ax,ax+1a_{x-1},a_x,a_{x+1}axâˆ’1â€‹,axâ€‹,ax+1â€‹ çš„å€¼å‡ 111ï¼Œå¦‚æœåºåˆ—ä¸­å­˜åœ¨å°äº 000 çš„æ•°ï¼Œåˆ™æŠŠå¯¹åº”çš„æ•°æ”¹ä¸º 000ã€‚1â‰¤n,qâ‰¤1051\\leq n,q\\leq 10^51â‰¤n,qâ‰¤105ï¼Œ1â‰¤xiâ‰¤n1\\leq x_i\\leq n1â‰¤xiâ€‹â‰¤nï¼Œ1â‰¤ai,yiâ‰¤1091\\leq a_i,y_i\\leq 10^91â‰¤aiâ€‹,yiâ€‹â‰¤109ã€‚ è€ƒè™‘å“ªäº›æ•°å¯ä»¥è¢«å‡ã€‚å¦‚æœæˆ‘ä»¬å¼€å§‹å‡ aia_iaiâ€‹ï¼Œé‚£ä¹ˆå®ƒä¸€å®šä¼šä¸€ç›´å‡ä¸‹å»ï¼ˆå› ä¸ºå·¦å³ä¸¤ä¸ªæ°¸è¿œéƒ½æ¯”å®ƒå°ï¼‰ã€‚ å°†åŸåºåˆ—è¿›è¡Œå•è°ƒæé•¿åˆ’åˆ†ï¼Œå‘ç°å¯¹äºæ¯ä¸ªæé•¿å•è°ƒåŒºé—´ï¼Œç­”æ¡ˆä¸€å®šæ˜¯æ‰€æœ‰å¥‡æ•°ä½ç½®æˆ–è€…æ‰€æœ‰å¶æ•°ä½ç½®çš„å’Œã€‚ä½¿ç”¨ä¸€ä¸ª set å­˜å‚¨æ‰€æœ‰çš„æé•¿å•è°ƒåŒºé—´åˆ†å‰²ç‚¹ï¼ˆç§°ä¸ºæå€¼ç‚¹ï¼Œä»¤ä¸€ä¸ªæå€¼ç‚¹ä»£è¡¨æé•¿å•è°ƒåŒºé—´çš„ç»“æŸï¼‰ï¼Œä¿®æ”¹ä¸€ä¸ªæ•°æ—¶æœ€å¤šåªä¼šå½±å“åˆ°äº”ä¸ªæå€¼ç‚¹ï¼ˆä¿®æ”¹ä¸€ä¸ªæå€¼ç‚¹å¯èƒ½ä½¿å®ƒå³è¾¹çš„æå€¼ç‚¹ä¸å­˜åœ¨ï¼Œè¿›è€Œå½±å“å³è¾¹ç¬¬äºŒä¸ªæå€¼ç‚¹ï¼Œå·¦è¾¹åŒç†ï¼‰ï¼Œå¤æ‚åº¦å¯ä»¥æ¥å—ã€‚ æ ¹æ®æ­¤ç»´æŠ¤å³å¯ï¼Œç»†èŠ‚å¾ˆå¤šã€‚ä»£ç ã€‚ [NOI2022] ä¼—æ•° Portal. åŒºé—´ç»å¯¹ä¼—æ•°ä¹Ÿå¿…å®šæ˜¯ä¸­ä½æ•°ï¼Œè¿™æ ·å»ºç«‹æƒå€¼çº¿æ®µæ ‘ï¼Œç„¶åå°±å¯ä»¥ç›´æ¥çº¿æ®µæ ‘äºŒåˆ†ï¼Œç„¶åæ£€æŸ¥å‡ºç°æ¬¡æ•°æ˜¯å¦åˆæ³•å³å¯ã€‚å†ç”¨ä¸€ä¸ªé“¾è¡¨è¾…åŠ©åˆå¹¶åºåˆ—å°±å®Œæˆäº†ï¼Œä»£ç ã€‚ * [NOI2020] å‘½è¿ Portal. è€ƒè™‘è®¾ fx,yf_{x,y}fx,yâ€‹ ä»£è¡¨ä»¥ xxx ä¸ºæ ¹çš„å­æ ‘ä¸­å·²ç»å…¨éƒ¨æ»¡è¶³ï¼Œä¸æ»¡è¶³çš„è·ç¦»æœ€å¤šä¸º yyyï¼ˆä»æ ¹èŠ‚ç‚¹å‘ä¸‹å¼€å§‹ï¼‰çš„æ–¹æ¡ˆæ•°ï¼Œç­”æ¡ˆä¸º f1,0f_{1,0}f1,0â€‹ã€‚ è€ƒè™‘æ¯æ¬¡å°† (x,y)(x,y)(x,y) åˆå¹¶è¿›å½“å‰ç­”æ¡ˆï¼Œåˆ†åˆ«è€ƒè™‘è¿™æ¡è¾¹å¡« 1/01/01/0 çš„è´¡çŒ®ï¼š fx,iâ€²â†âˆ‘j=0depxfx,ify,j+âˆ‘j=0ifx,ify,j+âˆ‘j=0iâˆ’1fx,jfy,if&#x27;_{x,i} \\leftarrow \\sum_{j=0}^{dep_x} f_{x,i}f_{y,j}+\\sum_{j=0}^{i} f_{x,i}f_{y,j}+\\sum_{j=0}^{i-1} f_{x,j}f_{y,i} fx,iâ€²â€‹â†j=0âˆ‘depxâ€‹â€‹fx,iâ€‹fy,jâ€‹+j=0âˆ‘iâ€‹fx,iâ€‹fy,jâ€‹+j=0âˆ‘iâˆ’1â€‹fx,jâ€‹fy,iâ€‹ è®¾ gx,y=âˆ‘i=0yfx,ig_{x,y}=\\sum_{i=0}^y f_{x,i}gx,yâ€‹=âˆ‘i=0yâ€‹fx,iâ€‹ï¼Œåˆ™ï¼š fx,iâ€²=fx,i(gy,depx+gy,i)+fy,igx,iâˆ’1f&#x27;_{x,i}=f_{x,i}(g_{y,dep_x}+g_{y,i})+f_{y,i}g_{x,i-1} fx,iâ€²â€‹=fx,iâ€‹(gy,depxâ€‹â€‹+gy,iâ€‹)+fy,iâ€‹gx,iâˆ’1â€‹ æ‰€æœ‰çš„è½¬ç§»ä½ç½®éƒ½åªä¸æ·±åº¦æœ‰å…³ï¼Œå› æ­¤ç›´æ¥çº¿æ®µæ ‘åˆå¹¶ï¼Œç»´æŠ¤åŒºé—´ä¹˜æ³•çš„ä¿®æ”¹ã€‚ä»£ç ã€‚ [CF793F] Julia and snail Portal. æ‰«æçº¿æ‰«ä¸€éåºåˆ—ï¼Œé‡åˆ°ä¸€æ¡ç»³å­ (l,r)(l,r)(l,r) ç›¸å½“äº âˆ€iâ‰¤lâˆ§aiâ‰¥l,aiâ†maxâ¡{ai,r}\\forall i\\le l\\wedge a_i\\ge l,a_i\\leftarrow \\max\\{a_i,r\\}âˆ€iâ‰¤lâˆ§aiâ€‹â‰¥l,aiâ€‹â†max{aiâ€‹,r}ï¼Œå®é™…ä¸Šæ˜¯ aiâ†ra_i\\leftarrow raiâ€‹â†rï¼ŒSGT Beats ç»´æŠ¤å³å¯ã€‚ å…·ä½“åœ°ï¼Œæ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤æœ€å¤§å€¼å’Œæ¬¡å¤§å€¼ï¼Œä¿®æ”¹ä½¿ç”¨äºŒå…ƒç»„ (p,q)(p,q)(p,q) æ¥è¡¨ç¤ºï¼Œä»£è¡¨ âˆ€aiâ‰¥p,aiâ†q\\forall a_i\\ge p,a_i\\leftarrow qâˆ€aiâ€‹â‰¥p,aiâ€‹â†qã€‚ å¦‚æœ ma&lt;pma&lt;pma&lt;pï¼Œé‚£ä¹ˆè¿™ä¸ªåŒºé—´ä¸ä¼šåŠ¨ï¼›å¦‚æœ se&lt;pâ‰¤mase&lt;p\\le mase&lt;pâ‰¤maï¼Œé‚£ä¹ˆåªæœ‰æœ€å¤§å€¼ä¼šåŠ¨ï¼›å¦‚æœ pâ‰¤sep\\le sepâ‰¤seï¼Œé‚£ä¹ˆé€’å½’å¤„ç†ã€‚ä»£ç ã€‚ * [Ynoi2013] å¯¹æ•°æ®ç»“æ„çš„çˆ± Portal. è€ƒè™‘æ¨¡æ‹Ÿè¿™ä¸ªè¿‡ç¨‹ã€‚æˆ‘ä»¬éœ€è¦çŸ¥é“å¯¹äºä¸€æ®µåŒºé—´ï¼Œåˆ°åº•ä¼šå‡å»å¤šå°‘ä¸ª pppã€‚ æä¸€ä¸ªæ•°ç»„ cic_iciâ€‹ ä»£è¡¨è¿™æ®µåŒºé—´è¦å‡å» iii ä¸ª ppp çš„æœ€å°åˆå§‹å€¼ï¼Œé‚£ä¹ˆæŸ¥è¯¢çš„æ—¶å€™ç›´æ¥äºŒåˆ†å°±è¡Œã€‚ç°åœ¨è€ƒè™‘å¦‚ä½•è®¡ç®— ccc æ•°ç»„ã€‚ å°è¯•æšä¸¾å·¦å„¿å­çš„ cxc_xcxâ€‹ å’Œå³å„¿å­çš„ cyc_ycyâ€‹ æ¥è®¡ç®— cx+yc_{x+y}cx+yâ€‹ï¼Œä»€ä¹ˆæ—¶å€™ä¸èƒ½æ›´æ–°ï¼Ÿcxc_xcxâ€‹ çš„ä¸Šç•Œç»è¿‡æ“ä½œåä¾ç„¶å°äº cyc_ycyâ€‹ã€‚ ç”¨ maxâ¡{cx,cy+xÃ—pâˆ’sumls}\\max\\{c_x,c_y+x\\times p-sum_{ls}\\}max{cxâ€‹,cyâ€‹+xÃ—pâˆ’sumlsâ€‹} æ›´æ–° cx+yc_{x+y}cx+yâ€‹ã€‚ç”±äº cx+1âˆ’cxâ‰¥pc_{x+1}-c_{x}\\ge pcx+1â€‹âˆ’cxâ€‹â‰¥pï¼Œå› æ­¤ç›´æ¥åŒæŒ‡é’ˆæ‰«å°±è¡Œã€‚ å•æ¬¡è¯¢é—®ä¼šæ‹†æˆ logâ¡\\loglog ä¸ªåŒºé—´ï¼Œæ¯ä¸ªåŒºé—´ç”¨ logâ¡\\loglog æ—¶é—´äºŒåˆ†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n+mlogâ¡2n)O(n\\log n+m\\log^2 n)O(nlogn+mlog2n)ã€‚ä»£ç ã€‚ å¹³è¡¡æ ‘ å…¶åŒæ ·ä¸ºäºŒå‰æ•°æ®ç»“æ„ï¼Œæ»¡è¶³æ‰€è°“çš„â€œBST æ€§è´¨â€ã€‚ ç¬”è€…é€šå¸¸ä½¿ç”¨ FHQ æ¥å®ç°å¹³è¡¡æ ‘ã€‚ FHQ-Treap FHQ åˆ©ç”¨åˆ†ç¦»ä¸åˆå¹¶æ¥è¿›è¡Œç»´æŠ¤ï¼Œç„¶åé€šè¿‡éšæœºæƒå€¼æ¥ä¿è¯å¹³è¡¡ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœé‡‡ç”¨æŒ‡é’ˆå®ç°ï¼Œé‚£ä¹ˆ FHQ ä¼šå¾ˆå¿«ï¼Œè€Œä¸”éå¸¸å¥½å†™ã€‚å¤§æ¦‚åƒè¿™æ ·ï¼š struct Node &#123; int rnd; Node *ls, *rs; &#125; T[5000005]; Node* root; int tot; inline Node* newNode(int col, int l, int r) &#123; return &amp;(T[++tot] = Node(/*...*/)); &#125; æ›¿ç½ªç¾Šæ ‘ æ›¿ç½ªç¾Šæ ‘æ˜¯ä¸€ç§ä¾é é‡æ„æ“ä½œç»´æŒå¹³è¡¡çš„é‡é‡å¹³è¡¡æ ‘ã€‚æ›¿ç½ªç¾Šæ ‘ä¼šåœ¨æ’å…¥ã€åˆ é™¤æ“ä½œæ—¶ï¼Œæ£€æµ‹é€”ç»çš„èŠ‚ç‚¹ï¼Œè‹¥å‘ç°å¤±è¡¡ï¼Œåˆ™å°†ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘é‡æ„ã€‚ é¦–å…ˆï¼Œå¦‚å‰æ‰€è¿°ï¼Œæˆ‘ä»¬éœ€è¦åˆ¤å®šä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦åº”é‡æ„ã€‚ä¸ºæ­¤æˆ‘ä»¬å¼•å…¥ä¸€ä¸ªæ¯”ä¾‹å¸¸æ•° Î±\\alphaÎ±ï¼ˆä¸€èˆ¬é‡‡ç”¨ 0.70.70.7ï¼‰ï¼Œè‹¥æŸèŠ‚ç‚¹çš„å­èŠ‚ç‚¹å¤§å°å å®ƒæœ¬èº«å¤§å°çš„æ¯”ä¾‹è¶…è¿‡ Î±\\alphaÎ±ï¼Œåˆ™é‡æ„ã€‚ ä¾‹é¢˜ ç›¸æ¯”äºçº¿æ®µæ ‘ï¼Œå¹³è¡¡æ ‘çš„é¢˜ä¸æ˜¯å¾ˆå¤šã€‚ [HNOI2011] æ‹¬å·ä¿®å¤ Portal. ä¿®å¤ä¸€ä¸ªæ‹¬å·åºåˆ—çš„ä»£ä»·è¿™æ ·è®¡ç®—ï¼šè®¾ ( = -1, ) = 1ï¼Œå‰ç¼€æœ€å¤§å€¼ä¸º aaaï¼Œåç¼€æœ€å°å€¼ä¸º bbbï¼Œä»£ä»·æ˜¯ âŒˆaÃ·2âŒ‰+âŒˆâˆ’bÃ·2âŒ‰\\lceil a\\div 2\\rceil+\\lceil -b\\div 2\\rceilâŒˆaÃ·2âŒ‰+âŒˆâˆ’bÃ·2âŒ‰ã€‚ç„¶åç›´æ¥ä½¿ç”¨å¹³è¡¡æ ‘ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ [NOIP2017] åˆ—é˜Ÿ Portal. ä½¿ç”¨å¹³è¡¡æ ‘ç»´æŠ¤æ¯ä¸€è¡Œå’Œæœ€åä¸€åˆ—ï¼Œæ¯ä¸ªç‚¹å­˜å‚¨ä¸€æ®µåŒºé—´å³å¯ã€‚ä»£ç ã€‚ [ZJOI2006] ä¹¦æ¶ Portal. é—®é¢˜åœ¨äºå¦‚ä½•é«˜æ•ˆæ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹åœ¨å¹³è¡¡æ ‘ä¸Šçš„ä½ç½®ï¼ˆä¸­åºéå†çš„ç¼–å·ï¼‰ã€‚ç»´æŠ¤æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²ï¼Œç„¶åç›´æ¥ä»è¿™ä¸ªèŠ‚ç‚¹çš„ä½ç½®è·³åˆ°æ ¹ï¼Œç»´æŠ¤ä¸­åºéå†çš„ä½ç½®ã€‚è¿™ä¹‹åç›´æ¥ä¹±åšå³å¯ã€‚ä»£ç ã€‚ * [POI2015] LOG Portal. ä½¿ç”¨ä¸€æ£µç»´æŠ¤æƒå€¼çš„å¹³è¡¡æ ‘ã€‚åœ¨å‡ 111 çš„è¿‡ç¨‹ä¸­ï¼Œå¤§äºç­‰äº sss çš„æ˜¯éšä¾¿ç”¨ï¼Œå‰©ä¸‹çš„åªéœ€è¦è€ƒè™‘å®ƒä»¬çš„å’Œæ˜¯å¦å¤Ÿç”¨å³å¯ï¼ˆå¯ä»¥å°†åé¢çš„å‘å‰ç§»æ¥å åˆ° sssï¼Œè¿™æ ·ä¿è¯ä¸€å±‚ä¸­ä¸ä¼šæœ‰æ¥è‡ªåŒä¸€ä¸ªä½ç½®çš„æ•°ï¼‰ã€‚ä»£ç ã€‚ * [Luogu P3987] æˆ‘æ°¸è¿œå–œæ¬¢ç‚æœµè‰~ Portal. ä¸€ä¸ªæ•°æœ€å¤šè¢«é™¤ logâ¡\\loglog æ¬¡ï¼Œé‚£ä¹ˆå¯ä»¥æš´åŠ›ä¿®æ”¹å¹¶ä½¿ç”¨ Fenwick æ ‘æŸ¥è¯¢ï¼Œä½¿ç”¨å¹³è¡¡æ ‘ç»´æŠ¤æœ‰å› æ•° xxx çš„æ•°ï¼Œæ¯æ¬¡ä¿®æ”¹æ—¶ç›´æ¥ DFS åˆ†è£‚å‡ºçš„å­æ ‘ã€‚æ—¶é—´å¤æ‚åº¦ O(nd(V)+nlogâ¡nlogâ¡v+mlogâ¡n)O(nd(V)+n\\log n\\log v+m\\log n)O(nd(V)+nlognlogv+mlogn)ã€‚ä»£ç ã€‚ å¯¹äºæ•°æ®åŠ å¼ºç‰ˆ [Ynoi2013] å¤§å­¦ï¼Œå¹³è¡¡æ ‘å¸¸æ•°è¿‡å¤§ï¼Œä¸èƒ½é€šè¿‡ã€‚å¯¹äºæ¯ä¸€ä¸ªçº¦æ•°é‡‡ç”¨ä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œå¼€å§‹æ—¶æ¯ä¸ªæ•°éƒ½æŒ‡å‘è‡ªå·±ï¼Œåˆ é™¤æ—¶å°†å½“å‰æ•°çš„çˆ¶äº²è®¾ç½®ä¸ºä¸‹ä¸€ä¸ªæ•°ã€‚å¦å¤– STL vector çš„å¸¸æ•°è¿‡å¤§ï¼Œéœ€è¦æ‰‹å†™å†…å­˜æ± ã€‚ä»£ç ã€‚ [CF702F] T-shirts Portal. ç”±äºæ¯ä¸ªäººçš„å¤„ç†æ–¹å¼éƒ½æ˜¯ä¸€æ ·çš„ï¼Œå› æ­¤ä¸å¦‚è€ƒè™‘æ¯ä¸ªç‰©å“å¯¹äºäººçš„è´¡çŒ®ã€‚é‚£ä¹ˆä¸éš¾å¯¹äºäººç›´æ¥ç»´æŠ¤ï¼Œç„¶åæ‰“ä¸Šä¸ªå‡æ ‡è®°ã€‚å¯¹äºä½ç½®ä¼šæ”¹å˜çš„ä¸œè¥¿ï¼Œç›´æ¥æš´åŠ›æ’å…¥ï¼Œè¿™æ ·åªä¼šå‘ç”Ÿ logâ¡c\\log clogc æ¬¡ï¼Œå› æ­¤å¤æ‚åº¦æ˜¯å¯¹çš„ã€‚ä»£ç ã€‚ [Ynoi2011] é¥è¿œçš„è¿‡å» Portal. å¹³è¡¡æ ‘æ±‚å‡º aaa çš„æ‰€æœ‰å­ä¸²çš„å“ˆå¸Œå€¼ï¼Œåªéœ€è¦æ”¯æŒåˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼ŒåŠ å…¥æ–°å…ƒç´ å‰ç»™ä»¥å‰çš„ä¸œè¥¿æ‰“ä¸€ä¸ªæ ‡è®°å³å¯ã€‚ä»£ç ã€‚ ** [Ynoi2015] äººäººæœ¬ç€æ­£ä¹‰ä¹‹å Portal. é¦–å…ˆçœ‹ä¸€çœ‹æ“ä½œ 3âˆ¼63\\sim 63âˆ¼6 æ˜¯ä¸ªä»€ä¹ˆä¸œè¥¿ã€‚ å°† [l,râˆ’1][l,r-1][l,râˆ’1] ä¸­çš„æ•° aia_iaiâ€‹ åŒæ—¶å˜ä¸º aia_iaiâ€‹ ä¸ ai+1a_{i+1}ai+1â€‹ æŒ‰ä½æˆ–çš„å€¼ï¼Ÿç®€å•ï¼Œå°±æ˜¯æ‰€æœ‰æé•¿ 000 æ®µæœ€å³è¾¹ä¸€ä¸ª 000 å˜æˆ 111ã€‚ æä¸€ä¸ªå¹³è¡¡æ ‘ï¼Œæ‰“ä¸€ä¸ªæ ‡è®°è¡¨ç¤ºå·¦å³ç«¯ç‚¹çš„ç§»åŠ¨é‡ã€‚åªæœ‰ä¸¤ä¸ªé—®é¢˜ï¼š å¦‚ä½•ä¿è¯åŒºé—´æé•¿ï¼ŸåŒºé—´æŸ“è‰²æ—¶å‘å·¦å³æ‹“å±•ä¸€ä¸‹å³å¯ã€‚ å¦‚ä½•ä¿è¯æ²¡æœ‰ç©ºåŒºé—´ï¼ŸåŒºé—´æ•°é‡æ˜¯ O(n+m)O(n+m)O(n+m) çš„ï¼Œç»´æŠ¤æœ€çŸ­ 01 åŒºé—´é•¿åº¦ï¼Œæš´åŠ›æ‰¾ï¼Œç„¶åå°†å…¶å·¦å³åŒºé—´åˆå¹¶å³å¯ã€‚ æœ¬è´¨ä¸Šä¸éš¾ï¼Œä½†ä»£ç æ¯”è¾ƒå£®è§‚ï¼Œéœ€è¦ä½¿ç”¨æŒ‡é’ˆå®ç°å¹³è¡¡æ ‘è¿›è¡Œå¡å¸¸ï¼Œä»£ç ã€‚ * [NOI2021] å¯†ç ç®± Portal. æˆ‘ä»¬éœ€è¦ç”¨æ•°æ®ç»“æ„æè¿°è¿™äº›æ“ä½œï¼Œè€ƒè™‘ä½¿ç”¨è¿åˆ†æ•°è¡¨ç¤º fff çš„å€¼ï¼š a0+1a1+1a2+â‹¯a_0+\\cfrac{1}{a_1+\\cfrac{1}{a_2+\\cdots}} a0â€‹+a1â€‹+a2â€‹+â‹¯1â€‹1â€‹ ä¸ºäº†æ¥ä¸‹æ¥æ–¹ä¾¿æ“ä½œï¼Œæˆ‘ä»¬å–å…¶å€’æ•°è¿›è¡Œè®¡ç®—ã€‚è€ƒè™‘å…¶åœ¨åˆå¹¶æ—¶å‘ç”Ÿäº†ä»€ä¹ˆï¼Œä¸éš¾å‘ç°ï¼š aâ€²bâ€²=1ai+ab=baiÃ—b+a\\frac{a&#x27;}{b&#x27;}=\\cfrac{1}{a_i+\\cfrac{a}{b}}=\\cfrac{b}{a_i\\times b + a} bâ€²aâ€²â€‹=aiâ€‹+baâ€‹1â€‹=aiâ€‹Ã—b+abâ€‹ é‚£ä¹ˆè¿™ä¸ªæ“ä½œå°±å¯ä»¥ç”¨çŸ©é˜µæ¥æè¿°äº†ï¼š [aâ€²bâ€²]=[ab][011ai]\\begin{bmatrix} a&#x27; &amp; b&#x27; \\end{bmatrix} = \\begin{bmatrix} a &amp; b \\end{bmatrix} \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; a_i \\end{bmatrix} [aâ€²â€‹bâ€²â€‹]=[aâ€‹bâ€‹][01â€‹1aiâ€‹â€‹] æ¥ä¸‹æ¥è¦æè¿° W å’Œ E æ“ä½œã€‚é¦–å…ˆè€ƒè™‘ W æ“ä½œï¼Œå¯ä»¥æ„å‡º W ä¸º [1101]\\begin{bmatrix}1 &amp; 1 \\\\ 0 &amp; 1\\end{bmatrix}[10â€‹11â€‹]ã€‚ ç„¶åæ˜¯ E æ“ä½œã€‚å½“ ak&gt;1a_k&gt;1akâ€‹&gt;1 æ—¶ï¼Œä¸éš¾å‘ç°å…¶ä¸º [0âˆ’112]\\begin{bmatrix} 0 &amp; -1 \\\\ 1 &amp; 2 \\end{bmatrix}[01â€‹âˆ’12â€‹]ï¼Œå®é™…ä¸Šå¯¹ ak=1a_k=1akâ€‹=1 ä¹Ÿæ»¡è¶³ã€‚ ç„¶åç›´æ¥ä¸Šå¹³è¡¡æ ‘ç»´æŠ¤å³å¯ã€‚æ³¨æ„ä½ çš„å¸¸æ•°ï¼Œä»£ç ã€‚ * [æ¹–åŒ—çœé˜Ÿäº’æµ‹ 2014] æ²¡æœ‰äººçš„ç®—æœ¯ Portal. ä¸ºä»€ä¹ˆä¸å¥½åšï¼Ÿæˆ‘ä»¬æ— æ³•è½»æ˜“æ¯”è¾ƒè¿™ä¸ªä¸œè¥¿ã€‚ åªæœ‰ O(m)O(m)O(m) ä¸ªä¸åŒçš„æ•°ï¼Œè€ƒè™‘ç»™æ¯ä¸ªæ•°éƒ½èµ‹ä¸€ä¸ªå®æ•°æƒã€‚ç»´æŠ¤ä¸€æ£µå¹³è¡¡æ ‘ï¼Œæ¯æ¬¡æ’å…¥ä¸€ä¸ª pair&lt;double, double&gt;ï¼Œä»£è¡¨æ–°çš„æ•°çš„æƒå€¼ï¼Œå’Œå¹³è¡¡æ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹æ¯”è¾ƒï¼ˆèŠ‚ç‚¹å­˜å‚¨å®ƒçš„ double å’Œå®ƒæ˜¯ç”±å“ªä¸¤ä¸ª double ç»„æˆçš„ï¼‰ï¼ŒèŠ‚ç‚¹çš„æƒå€¼ç”±åŠ¨æ€æ ‡å·è€Œæ¥ï¼Œå®é™…ä¸Šæ˜¯ (l+r)/2(l+r)/2(l+r)/2ï¼Œä»£è¡¨ç€ dfn åºï¼Œè€Œå¹³è¡¡æ ‘ä¸Šçš„ dfn åºå°±ä»£è¡¨ç€å¤§å°ã€‚è¿™ä¸ª trick ä¹Ÿç§°ä¸ºåŠ¨æ€æ ‡å·ã€‚ ç”±äºæˆ‘ä»¬ä¸çŸ¥é“æ’å…¥çš„ä¸œè¥¿çš„å¤§å°æ— æ³•åˆ†è£‚ï¼Œè€Œæ—‹è½¬çš„å¤æ‚åº¦åˆæ— æ³•ä¿è¯ï¼ˆæ˜¯å­æ ‘å¤§å°çš„ï¼‰ã€‚å› æ­¤åªèƒ½ä½¿ç”¨æ›¿ç½ªç¾Šæ ‘ã€‚ä»£ç ã€‚ æŒä¹…åŒ–æ•°æ®ç»“æ„ æˆ‘ä»¬å¯¹äºä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œæƒ³ç»´æŠ¤å…¶æ‰€æœ‰çš„å†å²ç‰ˆæœ¬ã€‚è¿™æ ·çš„æ•°æ®ç»“æ„ç§°ä¸ºæŒä¹…åŒ–æ•°æ®ç»“æ„ã€‚ éƒ¨åˆ†æŒä¹…åŒ–ï¼šç‰ˆæœ¬åºåˆ—æ˜¯é“¾å¼ç»“æ„ï¼› å®Œå…¨æŒä¹…åŒ–ï¼šç‰ˆæœ¬åºåˆ—æ˜¯æ ‘çŠ¶ç»“æ„ï¼› å¯åˆå¹¶æŒä¹…åŒ–ï¼šæ”¯æŒåˆå¹¶ï¼Œä¹Ÿå°±æ˜¯è¯´ç‰ˆæœ¬æ˜¯ DAG ç»“æ„ã€‚ ä½†æ˜¯åœ¨ç®—æ³•ç«èµ›ä¸­ï¼ŒæŒä¹…åŒ–æœ€å¸¸è§çš„ä½œç”¨æ˜¯é™ç»´ã€‚ ç®—æ³•ç«èµ›é€šå¸¸é‡‡ç”¨ Path Copyï¼Œä¹Ÿå°±æ˜¯ä¿®æ”¹æ—¶æ–°å»ºèŠ‚ç‚¹çš„æ–¹å¼æ¥å®ç°æŒä¹…åŒ–æ•°æ®ç»“æ„ï¼Œè¦æ±‚æ•°æ®ç»“æ„æ˜¯ä¸€æ£µæœ‰æ ¹æ ‘å½¢æ€ã€‚ ç©ºé—´å¤§ç›—æ‰­æ›²äº†æ­¤å¤„çš„ç©ºé—´ã€‚Fat Node å’Œ Node-splitting ä¸ä¼šå‡ºç°åœ¨ NOI å¤ä¹ ä¸­ã€‚ æŒä¹…åŒ–çº¿æ®µæ ‘ é‡‡ç”¨åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ï¼Œä¿®æ”¹æ—¶æ–°å»ºèŠ‚ç‚¹å³å¯ã€‚ å¯¹äºæŒä¹…åŒ–çº¿æ®µæ ‘çš„åŒºé—´ä¿®æ”¹æ“ä½œï¼Œå¦‚æœæ ‡è®°å¯ä»¥æ°¸ä¹…åŒ–ï¼Œé‚£ä¹ˆæœ€å¥½è¿™æ ·åšï¼Œå› ä¸ºè¿™æ ·å¯ä»¥èŠ‚çœå¾ˆå¤šç©ºé—´ã€‚å¦åˆ™éœ€è¦ä¸‹ä¼ æ ‡è®°ï¼Œæ‰€æœ‰çš„ä¸‹ä¼ çš„ç‚¹éƒ½å¿…é¡»å¤åˆ¶åå†ä¸‹ä¼ ã€‚ æˆ‘ä»¬å¯ä»¥å¾ˆæ–¹ä¾¿åœ°åœ¨å¤šæ£µæŒä¹…åŒ–çº¿æ®µæ ‘ä¸ŠåŒæ—¶è¿›è¡ŒäºŒåˆ†ï¼Œç›´æ¥éƒ½åŠ èµ·æ¥å°±è¡Œã€‚ å…¶å®ƒæŒä¹…åŒ–æ•°æ®ç»“æ„ ä»¿ç…§æŒä¹…åŒ–çº¿æ®µæ ‘çš„æ€è·¯ï¼Œå…¶å®ƒéå‡æ‘Šå¤æ‚åº¦æ•°æ®ç»“æ„ä¹Ÿæ˜¯å¯ä»¥æŒä¹…åŒ–çš„ã€‚ æŒä¹…åŒ–æ•°ç»„ï¼šé€šå¸¸åˆ©ç”¨æŒä¹…åŒ–çº¿æ®µæ ‘æ¥å®ç°æŒä¹…åŒ–æ•°ç»„ï¼Œè¿›è€Œå®ç°ä¸èƒ½è·¯å¾„å‹ç¼©çš„æŒä¹…åŒ–å¹¶æŸ¥é›†ã€‚ æŒä¹…åŒ– Trieï¼šä¸æŒä¹…åŒ–çº¿æ®µæ ‘åŸç†å¤§è‡´ç›¸åŒï¼Œåœ¨æ–°å»ºèŠ‚ç‚¹çš„æ—¶å€™å¤åˆ¶ä¸€ä¸‹å°±è¡Œã€‚åŒæ—¶åº”æ³¨æ„ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°åœ¨å¤šæ£µ Trie ä¸ŠäºŒåˆ†ï¼Œç›´æ¥éƒ½åŠ èµ·æ¥å°±è¡Œã€‚ æŒä¹…åŒ–å¹³è¡¡æ ‘ï¼šé€šå¸¸æƒ…å†µä¸‹æŒä¹…åŒ– FHQ è¶³å¤Ÿåº”ä»˜å¤§éƒ¨åˆ†çš„é—®é¢˜ï¼Œå…¶ä½™çš„ä¹Ÿä¸å¤ªèƒ½è§åˆ°ã€‚å¦‚æœè§åˆ°äº†åŒºé—´å¹³ç§»ä¹‹ç±»çš„æ“ä½œï¼Œé‚£ä¹ˆå¤§æ¦‚ç‡å°±æ˜¯æŒä¹…åŒ–å¹³è¡¡æ ‘ï¼Œåœ¨åˆ†è£‚å’Œåˆå¹¶çš„æ—¶å€™æ–°å»ºä¸€ä¸‹èŠ‚ç‚¹å³å¯ã€‚ç›´æ¥å¤åˆ¶éšæœºæƒå€¼æ˜¯é”™çš„ï¼Œåº”è¯¥æŒ‰ç…§æ ‘çš„å¤§å°ä½œä¸ºä¾æ®æŒ‰ç…§æ¦‚ç‡è¿›è¡Œåˆå¹¶ã€‚ ä¾‹é¢˜ æœ‰äº›ä¸œè¥¿æ¯”è¾ƒéº»çƒ¦ã€‚ [THUSC2015] å¼‚æˆ–è¿ç®— Portal. å°†æ±‚ç¬¬ kkk å¤§è½¬åŒ–ä¸º kkk å°ï¼Œçœ‹ä¸€ä¸‹ n=1n=1n=1 æ€ä¹ˆåšï¼Ÿå¯¹ YYY å»ºç«‹æŒä¹…åŒ– 01 Trieï¼Œç„¶åæ‹¿ç€ X[1]X[1]X[1] å¼€å§‹ä»é«˜åˆ°ä½ä½å¼€å§‹è´ªå¿ƒã€‚ç­”æ¡ˆçš„è¿™ä¸€äºŒè¿›åˆ¶ä½èƒ½å–åˆ° 000 çš„ä¸ªæ•°å¦‚æœå°äº kkkï¼Œé‚£ä¹ˆè¿™ä¸€ä½å°±éœ€è¦å– 111ï¼Œç„¶åä»¤ kkk å‡å»è¿™ä¸ªä¸ªæ•°ï¼›å¦åˆ™è¿™ä¸€ä½å– 000ã€‚ å‘ç° n,qn,qn,q éƒ½ä¸æ˜¯å¾ˆå¤§ï¼Œå› æ­¤å¯¹äº n&gt;1n&gt;1n&gt;1 ç›´æ¥æš´åŠ›æ‰«ä¸€éï¼ŒæŠŠæ€»å’ŒåŠ èµ·æ¥è·Ÿ kkk æ¯”å³å¯ã€‚ä»£ç ã€‚ [CF1665E] MinimizOR Portal. å¦‚ä½•å¤„ç†æˆ–çš„æœ€å°å€¼å‘¢ï¼Ÿå¦‚æœå‡ºç°äº†ä¸¤ä¸ªä»¥ä¸Šçš„ 000ï¼Œé‚£ä¹ˆè¿™ä¸€ä½æ˜¾ç„¶å¡« 000ï¼›å¦‚æœæ²¡æœ‰ 000 å‡ºç°ï¼Œåˆ™å¡« 111ï¼›æœ‰ä¸€ä¸ª 000 å‘¢ï¼Ÿæ‰¾åˆ°è¿™ä¸ª 000 çš„ä½ç½®ï¼Œè®©å®ƒè‡ªå·±å¾€ 000 èµ°ï¼ŒåŒæ—¶æä¸¤ä¸ªå„¿å­å°±å¥½äº†ã€‚åªä¼šå¢åŠ  logâ¡\\loglog æ¬¡èŠ‚ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡2V)O(n\\log^2 V)O(nlog2V)ã€‚ä»£ç ã€‚ *ã€UNR #1ã€‘ç«è½¦ç®¡ç† Portal. æ“ä½œä¸€å’Œæ“ä½œä¸‰å¯ä»¥ç®€å•åœ°ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ã€‚å¯¹äºæ“ä½œäºŒï¼Œå°†çº¿æ®µæ ‘æŒä¹…åŒ–ï¼Œåœ¨æŸ“è‰²æ—¶è®°å½•æ¯ä¸ªèŠ‚ç‚¹æŸ“çš„æ˜¯å“ªä¸€ä¸ªç‰ˆæœ¬çš„é¢œè‰²ï¼Œè¿™æ ·åœ¨å›é€€æ—¶å°±å¯ä»¥æŸ¥è¯¢æŸ“è‰²çš„ç‰ˆæœ¬å·ï¼Œç„¶åå°†å…¶æŸ“æˆå®ƒä¸Šä¸€ä¸ªç‰ˆæœ¬çš„é¢œè‰²ã€‚ ä¾ç„¶æ³¨æ„ï¼ŒæŒä¹…åŒ–çº¿æ®µæ ‘çš„å¸¦æ ‡è®°ä¸‹ä¼ åŒºé—´ä¿®æ”¹ç©ºé—´å¸¸æ•°å¾ˆå¤§ï¼Œéœ€è‡³å°‘å¼€åˆ°å¹³æ—¶çš„ä¸¤å€ã€‚ä»£ç ã€‚ [CF1422F] Boring Queries Portal. å¯¹åºåˆ—å»ºç«‹ä¸€æ£µæŒä¹…åŒ–çº¿æ®µæ ‘ï¼Œå°†æ•°è´¨å› æ•°åˆ†è§£æ‰ï¼Œç„¶ååœ¨å·¦ç«¯ç‚¹ä¹˜ä¸Šç›¸åº”çš„é€†å…ƒå³å¯ã€‚ä»£ç ã€‚ åµŒå¥—æ•°æ®ç»“æ„ K-D Tree å¯ä»¥è§£å†³é«˜ç»´ç©ºé—´ä¸Šçš„çŸ©å½¢ä¿®æ”¹çŸ©å½¢æŸ¥è¯¢é—®é¢˜ï¼Œè€Œæ ‘å¥—æ ‘å’Œ CDQ åˆ†æ²»çš„åŠŸèƒ½æ˜¯ç­‰ä»·çš„ï¼Œé€šå¸¸åªèƒ½è§£å†³å•ç‚¹ä¿®æ”¹çŸ©å½¢æŸ¥è¯¢ç±»é—®é¢˜ã€‚ æ ‘å¥—æ ‘ æ­£å¸¸çš„æ ‘çŠ¶æ•°ç»„æ¯ä¸ªç‚¹ç»´æŠ¤çš„æ˜¯ä¸€ä¸ªæ•°ï¼Œå¦‚æœæ”¹æˆç»´æŠ¤ä¸€æ£µå¹³è¡¡æ ‘ï¼Œé‚£ä¹ˆå°±æˆäº†â€œæ ‘çŠ¶æ•°ç»„å¥—å¹³è¡¡æ ‘â€ã€‚ ä¸ä¸€å®šæ˜¯æ‰‹å†™æ•°æ®ç»“æ„çš„åµŒå¥—ï¼Œæœ‰äº›æ—¶å€™å­˜åœ¨ä¸€äº›ç±»ä¼¼äºåµŒå¥—ç»“æ„çš„é¢˜ç›®ã€‚ è¿™é‡Œé€šè¿‡å‡ é“ç®€å•çš„é¢˜æ¥ç®€å•ä»‹ç»ä¸€ä¸‹æ ‘å¥—æ ‘ã€‚ ã€æ¨¡æ¿ã€‘äºŒé€¼å¹³è¡¡æ ‘ï¼ˆæ ‘å¥—æ ‘ï¼‰ Portal. å¦‚æœä½¿ç”¨çº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘ï¼Œé‚£ä¹ˆå†æŸ¥è¯¢æ’åä¸º kkk çš„æ•°çš„æ—¶å€™å°±éœ€è¦åœ¨å¤–å±‚äºŒåˆ†ï¼ˆå¹³è¡¡æ ‘ä¸Šå¤šæ ‘äºŒåˆ†éå¸¸å¤æ‚ï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡3n)O(n\\log^3 n)O(nlog3n)ã€‚ä»£ç ã€‚ *ã€ŒC.E.L.U-02ã€è‹¦æ¶© Portal. å»ºç«‹ä¸€æ£µçº¿æ®µæ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¿å­˜ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ä½œä¸ºåŒºé—´åŠ çš„æ ‡è®°ï¼Œå¹¶æ°¸ä¹…åŒ–ï¼ˆå³å½“å‰èŠ‚ç‚¹çš„ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„å†…å®¹å¯¹å®ƒçš„å„¿å­éƒ½æœ‰æ•ˆï¼‰ã€‚åˆ é™¤æ—¶å¯ä»¥æš´åŠ›éå†çº¿æ®µæ ‘ï¼Œå› ä¸ºæ¯ä¸€æ¬¡æ·»åŠ åªä¼šæ·»åŠ ä¸€ä¸ªæ‹¥æœ‰æœ€å¤§æ•°å€¼æœ€å¤§çš„é¢œè‰²æ®µï¼Œè¿™æ ·åˆ é™¤å®ƒçš„æ—¶é—´å°±ä¼šåœ¨ O(logâ¡n)O(\\log n)O(logn) çº§åˆ«ã€‚è‹¥ n,mn,mn,m åŒé˜¶ï¼Œé‚£ä¹ˆæ€»æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ã€‚ä»£ç ã€‚ [ZJOI2017] æ ‘çŠ¶æ•°ç»„ Portal. æ–¹å‘åäº†æ˜¯ä»€ä¹ˆï¼Ÿå˜æˆäº†æ±‚åç¼€å’Œï¼ä¹Ÿå°±æ˜¯è¯´ï¼Œä½†æ˜¯æ•´ä¸ªä¸œè¥¿æ±‚çš„æ˜¯ Srâˆ’1âˆ’Slâˆ’2S_{r-1}-S_{l-2}Srâˆ’1â€‹âˆ’Slâˆ’2â€‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦æ±‚ vr=vlâˆ’1v_r=v_{l-1}vrâ€‹=vlâˆ’1â€‹ çš„æ¦‚ç‡ã€‚é‚£ä¹ˆå¯ä»¥è§†ä½œåŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ã€‚ ä½¿ç”¨äºŒç»´çº¿æ®µæ ‘ï¼Œå¤–å±‚ç»´æŠ¤ lllï¼Œå†…å±‚ç»´æŠ¤ rrrï¼Œæ–°çš„æ¦‚ç‡æ˜¯å¾ˆå¥½æ±‚çš„ï¼Œæ³¨æ„ l=1l=1l=1 æ—¶åªéœ€è¦æ³¨æ„ rrr çš„å˜åŒ–æƒ…å†µï¼Œç›´æ¥ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ * [THUSC2021] æ¬ä¸œè¥¿ Portal. å…ˆæ±‚è§£ä¸€è½®å¯ä»¥æ”¾ç½®å¤šå°‘ä¸ªç‰©å“ï¼Œè´ªå¿ƒå®Œæˆã€‚ç„¶åäºŒåˆ†å‡ºç¬¬ä¸€ä¸ªæœ€å¤§é€‰æ‹©çš„ä¸‹æ ‡ï¼Œä½¿ç”¨æ ‘çŠ¶æ•°ç»„å¥—ä¸»å¸­æ ‘å®Œæˆã€‚ä»£ç ã€‚ K-D Tree æ—¶é—´æ—…äººé€†è½¬äº†æ­¤å¤„çš„æ—¶é—´ã€‚æˆ‘ä»¬ä¼šåœ¨å¿…è¦æ—¶è¡¥å……è¿™éƒ¨åˆ†çš„å†…å®¹ã€‚ K-D Tree å…·æœ‰äºŒå‰æœç´¢æ ‘çš„ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½å¯¹åº”äº† kkk ç»´ç©ºé—´ä¸Šçš„ä¸€ä¸ªç‚¹ã€‚ ä¸ºäº†ä¿è¯ K-D Tree çš„æ ‘é«˜ï¼Œ ç®€å•æ ‘å½¢é—®é¢˜ å¯¹äºæ ‘ä¸Šé—®é¢˜æœ‰åŸºæœ¬çš„å¤„ç†æ–¹æ³•ï¼Œæ¯”å¦‚ LCAã€æ ‘å½¢ DPã€æ ‘ä¸Šå·®åˆ†ç­‰ï¼Œåœ¨æ­¤ä¸åšèµ˜è¿°ã€‚ å¸¸è§æ ‘å½¢é—®é¢˜å¤„ç†æ‰‹æ®µï¼š æ ‘å½¢ DPï¼› ç›´å¾„é‡å¿ƒåŠå…¶æ€§è´¨ï¼› æ ‘ä¸Šé“¾ä¿¡æ¯ç»´æŠ¤ï¼Œå·®åˆ†ã€é‡é“¾å‰–åˆ†ã€æ ‘ä¸Šå€å¢ï¼› æ ‘ä¸Šè·¯å¾„ä¿¡æ¯ç»Ÿè®¡ï¼šæ ‘åˆ†æ²»ï¼› çº¿æ®µæ ‘åˆå¹¶ã€ä¸¤ç§æ ‘ä¸Šå¯å‘å¼åˆå¹¶ï¼› ç¦»çº¿ï¼ŒæŒ‚ä¿¡æ¯åˆ°èŠ‚ç‚¹ä¸Šï¼› DFS åºã€æ‹¬å·åºã€æ¬§æ‹‰åºã€‚ æ ‘çš„é‡å¿ƒçš„æ€§è´¨ï¼šä»¥ä»»æ„èŠ‚ç‚¹ä¸ºæ ¹ï¼Œæ ‘çš„é‡å¿ƒçš„å­æ ‘å¤§å° â‰¥n2\\ge \\frac n 2â‰¥2nâ€‹ã€‚ DFS æœç´¢æ ‘çš„æ€§è´¨ï¼šåªå­˜åœ¨è¿”ç¥–è¾¹ï¼Œä¸å­˜åœ¨æ¨ªå‰è¾¹ã€‚ [Ynoi2008] stcmã€‚ç›´æ¥å¯¹äº DFS åºè¿›è¡Œåˆ†æ²»ï¼Œå› ä¸ºéƒ½åŒ…å«ä¸€ä¸ª midmidmid çš„å­æ ‘åŒºé—´ä¸€å®šæ˜¯ç›¸äº’åŒ…å«çš„ï¼Œå› æ­¤ç›´æ¥å¢é‡æ·»åŠ ä¿¡æ¯å³å¯ã€‚ä»£ç ã€‚ ç¬›å¡å°”æ ‘ ç¬›å¡å°”æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„ Treapï¼Œå…¶èŠ‚ç‚¹æƒå€¼ä¸å†æ˜¯éšæœºçš„ï¼Œè€Œæ˜¯ç»™å®šçš„ã€‚æ¯ä¸ªèŠ‚ç‚¹çš„æƒå€¼ç”¨ (xi,yi)(x_i,y_i)(xiâ€‹,yiâ€‹) è¡¨ç¤ºï¼Œåªè€ƒè™‘ xxx æ—¶å®ƒæ˜¯ BSTï¼Œåªè€ƒè™‘ yyy æ—¶å®ƒæ˜¯å †ï¼ˆæ­¤å¤„ä»¥å°æ ¹å †ä¸ºä¾‹ï¼‰ã€‚ åœ¨ xxx é€’å¢æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥çº¿æ€§å¤æ‚åº¦å»ºå‡ºç¬›å¡å°”æ ‘ã€‚æ’å…¥æ–°èŠ‚ç‚¹æ—¶ï¼Œä¸ºäº†ä¿è¯ xxx çš„æ€§è´¨æ»¡è¶³ï¼Œè¦å°† xxx æ’å…¥åˆ°å°½é‡å³çš„åœ°æ–¹ã€‚ å…·ä½“æ¥è®²ï¼Œç»´æŠ¤ä¸€ä¸ªä»æ ¹èŠ‚ç‚¹ä¸€ç›´èµ°åˆ°å³å„¿å­çš„é“¾ã€‚è®¾å½“å‰éœ€è¦æ’å…¥ uuuï¼Œåˆ™éœ€è¦æ‰¾åˆ°ç¬¬ä¸€ä¸ª yv&gt;yuy_v&gt;y_uyvâ€‹&gt;yuâ€‹ï¼Œå°† vvv çš„å³å„¿å­è®¾ä¸º uuuï¼ˆä¸å­˜åœ¨åˆ™å°† uuu è®¾ä¸ºæ ¹ï¼‰ï¼Œå¦‚æœ vvv åŸæœ¬æœ‰å³å­æ ‘ï¼Œåˆ™å°† vvv çš„å³å­æ ‘æ”¹è¿åœ¨ uuu çš„å·¦å­æ ‘ä¸‹é¢æ¥æ»¡è¶³ BST æ€§è´¨ã€‚ä½¿ç”¨å•è°ƒæ ˆç»´æŠ¤æ­¤é“¾ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ æ¨¡æ¿é¢˜æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š for (int i = 1, tot = 0, cur = 0; i &lt;= n; ++i) &#123; scanf(\"%d\", p + i); cur = tot; while (cur &amp;&amp; p[st[cur]] > p[i]) --cur; if (cur) rs[st[cur]] = i; if (cur &lt; tot) ls[i] = st[cur + 1]; // æ”¾åˆ°å·¦èŠ‚ç‚¹ä»¥æ»¡è¶³ BST æ€§è´¨ st[++cur] = i; tot = cur; &#125; æ€§è´¨ï¼šå¦‚æœèŠ‚ç‚¹ç¼–å· 1âˆ¼n1\\sim n1âˆ¼n ä¸º BST æƒå€¼ï¼Œç„¶åç‚¹æƒæ»¡è¶³å°æ ¹å †æ€§è´¨ï¼Œé‚£ä¹ˆ minâ¡{ax,â‹¯ ,ay}=aLCAâ¡(x,y)\\min\\{a_x,\\cdots,a_y\\}=a_{\\operatorname{LCA}(x,y)}min{axâ€‹,â‹¯,ayâ€‹}=aLCA(x,y)â€‹ã€‚ æ ‘é“¾å‰–åˆ† æˆ‘ä»¬å¯¹äºé“¾ä¸Šçš„é—®é¢˜æ›´ä¸ºç†Ÿæ‚‰ï¼Œå› æ­¤åœ¨é‡åˆ°æ ‘ä¸Šé—®é¢˜æ—¶ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨æ ‘é“¾å‰–åˆ†å°†å…¶è½¬ä¸ºé“¾ä¸Šé—®é¢˜å†è¿›è¡Œæ±‚è§£ã€‚å¸¸è§ç±»å‹æœ‰ä¸¤ç§ï¼š é‡é“¾å‰–åˆ†ã€‚æœ€ä¸ºä¼ ç»Ÿçš„å½¢å¼ï¼Œæœ€å¸¸ç”¨äºå°†æ ‘å‰–æˆ O(logâ¡n)O(\\log n)O(logn) æ¡é“¾ã€‚ä¸€ä¸ªæ¯”è¾ƒå¥½çš„æ€§è´¨æ˜¯ï¼Œæ¯æ¬¡é€‰æ‹©é‡å„¿å­è·³ï¼Œé‚£ä¹ˆæ ‘çš„è§„æ¨¡éƒ½ä¼šå‡å°ä¸€åŠã€‚ æˆ‘ä»¬åœ¨å¤„ç†æŸäº›é—®é¢˜æ—¶ï¼Œå¯ä»¥é€‰æ‹©åªè€ƒè™‘å½“å‰èŠ‚ç‚¹è½»å„¿å­çš„ç­”æ¡ˆï¼Œè¿™æ ·åœ¨é‡é“¾ä¸Šä¿®æ”¹ O(logâ¡n)O(\\log n)O(logn)ï¼Œåªæœ‰ O(logâ¡n)O(\\log n)O(logn) ä¸ªèŠ‚ç‚¹çš„ç­”æ¡ˆä¼šé‡æ–°è®¡ç®—ã€‚ é•¿é“¾å‰–åˆ†ã€‚åœ¨å¤„ç†ä¸æ·±åº¦ç›¸å…³çš„é—®é¢˜æ—¶å¯èƒ½æœ‰å¥‡æ•ˆï¼ˆå®ç°å¯å‘å¼åˆå¹¶ï¼‰ï¼Œä½†æ˜¯åŸºäºé•¿é“¾å‰–åˆ†å®ç°çš„ O(1)O(1)O(1) K çº§ç¥–å…ˆç”šè‡³æ‰“ä¸è¿‡æš´åŠ›è·³çš„é‡é“¾å‰–åˆ†ï¼ ä¾‹é¢˜ æ¯”è¾ƒæ‚ã€‚ * [CF1580D] Subsequence Portal. å…ˆæ¥çœ‹ä¸€ä¸‹è¦æ±‚çš„è¿™ä¸ªä¸œè¥¿ï¼š åŸå¼=âˆ‘i=1m(mâ‹…abi)âˆ’âˆ‘i=1mâˆ‘j=1mf(minâ¡(bi,bj),maxâ¡(bi,bj))=(mâˆ’1)âˆ‘i=1mabiâˆ’2âˆ‘i=1mâˆ‘j=i+1mminâ¡{abi,abi+1â‹¯ ,abjâˆ’1,abj}\\begin{aligned} \\text{åŸå¼}&amp;=\\sum_{i = 1}^m (m \\cdot a_{b_i}) - \\sum_{i = 1}^m \\sum_{j = 1}^m f(\\min(b_i, b_j), \\max(b_i, b_j))\\\\ &amp;=(m-1)\\sum_{i = 1}^m a_{b_i}-2\\sum_{i=1}^m\\sum_{j=i+1}^m \\min\\{a_{b_i},a_{b_i+1}\\cdots,a_{b_j-1},a_{b_j}\\} \\end{aligned} åŸå¼â€‹=i=1âˆ‘mâ€‹(mâ‹…abiâ€‹â€‹)âˆ’i=1âˆ‘mâ€‹j=1âˆ‘mâ€‹f(min(biâ€‹,bjâ€‹),max(biâ€‹,bjâ€‹))=(mâˆ’1)i=1âˆ‘mâ€‹abiâ€‹â€‹âˆ’2i=1âˆ‘mâ€‹j=i+1âˆ‘mâ€‹min{abiâ€‹â€‹,abiâ€‹+1â€‹â‹¯,abjâ€‹âˆ’1â€‹,abjâ€‹â€‹}â€‹ è¦æ±‚è¿™ä¸ªä¸œè¥¿çš„æœ€å¤§å€¼ï¼Œåé¢è¿™ä¸ªåŒºé—´æœ€å°å€¼å¯ä»¥è€ƒè™‘æ”¾åˆ°ç¬›å¡å°”æ ‘ä¸Šï¼Œç„¶åç”¨æ ‘å½¢ DP æ±‚è§£è¿™ä¸ªé—®é¢˜ã€‚ è®¾ fx,kf_{x,k}fx,kâ€‹ ä»£è¡¨ xxx ä¸­é€‰æ‹© kkk ä¸ªèŠ‚ç‚¹çš„æœ€å¤§ä»·å€¼ï¼Œåˆå§‹ fi,1=(mâˆ’1)aif_{i,1}=(m-1)a_ifi,1â€‹=(mâˆ’1)aiâ€‹ï¼Œç„¶åè½¬ç§»æ˜¯ä¸€ä¸ªç±»ä¼¼æ ‘å½¢èƒŒåŒ…çš„è¿‡ç¨‹ï¼š fx,i+j=maxâ¡{fx,i+fy,jâˆ’2Ã—axÃ—iÃ—j}f_{x,i+j}=\\max\\{f_{x,i}+f_{y,j}-2\\times a_x\\times i\\times j\\} fx,i+jâ€‹=max{fx,iâ€‹+fy,jâ€‹âˆ’2Ã—axâ€‹Ã—iÃ—j} ä»£ç ã€‚ * [APIO2021] å°é—­é“è·¯ Portal. ç›´æ¥æš´åŠ›æ ‘å½¢ DPã€‚è®¾ fx,0/1f_{x,0/1}fx,0/1â€‹ ä»£è¡¨ xxx ä¸çˆ¶äº²è¿æ¥çš„è¾¹æ˜¯å¦åˆ é™¤æ—¶ï¼Œuuu çš„å­æ ‘ä¸­æ»¡è¶³æ‰€æœ‰èŠ‚ç‚¹çš„åº¦æ•° â‰¤lim\\le \\text{lim}â‰¤lim çš„æœ€å°ä»£ä»·ã€‚è½¬ç§»æ—¶ï¼Œå°†è¾¹æŒ‰ç…§ fy,1+wâˆ’fy,0f_{y,1}+w-f_{y,0}fy,1â€‹+wâˆ’fy,0â€‹ æ‰”åˆ°å †é‡Œï¼Œç„¶åé€‰å‰ degxâˆ’limdeg_x -\\text{lim}degxâ€‹âˆ’lim å°çš„ã€‚è¿™æ ·å½“ degxâ‰¤limdeg_x\\le \\text{lim}degxâ€‹â‰¤lim æ—¶ï¼Œå°±å¯ä»¥ç›´æ¥æ‰”æ‰è¿™ä¸ªç‚¹ï¼ˆç›´æ¥æŠŠ www æ‰”åˆ° vvv çš„å †é‡Œï¼‰ï¼Œæ¯ä¸ªç‚¹ç»´æŠ¤ä¸€ä¸ªå †å³å¯ã€‚ä»£ç ã€‚ [Ynoi2011] ODT Portal. æ¯ä¸ªç‚¹ç»´æŠ¤ä¸€æ£µ Treapï¼Œç„¶ååªç»´æŠ¤è½»å„¿å­çš„ä¿¡æ¯ï¼Œä¿®æ”¹ O(logâ¡2n)O(\\log^2 n)O(log2n)ï¼ŒæŸ¥è¯¢ O(logâ¡n)O(\\log n)O(logn)ï¼Œå¯ä»¥ç»´æŠ¤è‹¥å¹²ä¸ªé‡å„¿å­æ¥å¹³è¡¡ï¼Œä½†æ²¡å¿…è¦ã€‚ä»£ç ã€‚ [CF536E] Tavas on the Path Portal. è€ƒè™‘ç»™å®š 01 è¾¹æƒæ€ä¹ˆåšï¼Œçº¿æ®µæ ‘ä¸Šç»´æŠ¤å‰åç¼€ 111 æ®µé•¿åº¦å’Œç­”æ¡ˆï¼Œæ€ä¹ˆéƒ½èƒ½å’Œå¹¶ï¼Œæœ‰é™åˆ¶çš„è¯ç›´æ¥æŒ‰ç…§è¾¹æƒæ’åºä¾æ¬¡åŠ å…¥å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ O(qlogâ¡2n+n)O(q\\log^2 n+n)O(qlog2n+n)ï¼Œä»£ç ã€‚ * [CF526G] Spiders Evil Plan Portal. é¦–å…ˆ kkk æ¡è·¯å¾„å¯ä»¥è¦†ç›– 2k2k2k å¶å­çš„æ ‘ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé€‰æ‹© yyy ä¸ªç‚¹å°±æ˜¯èƒ½é€‰æ‹© 2y2y2y ä¸ªå¶å­ï¼Œç„¶åæå°è¿é€šå—çš„è¾¹æƒå’Œå°½é‡å¤§ã€‚ ä»¥ xxx ä¸ºæ ¹æ—¶å¦‚ä½•é€‰æ‹©å¶å­å‘¢ï¼Ÿè€ƒè™‘è¿›è¡Œä¸€æ¬¡é•¿é“¾å‰–åˆ†ï¼Œé‚£ä¹ˆ xxx æ‰€åœ¨çš„é•¿é“¾çš„å¶å­ä¹Ÿä¸€å®šé€‰æ‹©äº†ï¼Œç„¶åæŒ‰ç…§è¾¹æƒæ’åºè´ªå¿ƒå³å¯ã€‚ å¤šæ¬¡è¯¢é—®æ€ä¹ˆåŠï¼Ÿç”±äºæ ‘ä¸Šç»è¿‡ xxx çš„æœ€é•¿é“¾ä¸€å®šç»è¿‡ç›´å¾„çš„æŸä¸€ç«¯ï¼Œé‚£ä¹ˆä»¥ç›´å¾„çš„ä¸¤ä¸ªç«¯ç‚¹åˆ†åˆ«åšä¸€æ¬¡é•¿é“¾å‰–åˆ†ï¼Œç„¶åè¦æƒ³åŠæ³•å°† xxx åŠ å…¥è¿é€šå—ï¼Œå¦‚æœä¸€å¼€å§‹æ²¡æœ‰æ»¡è¶³ï¼Œé‚£ä¹ˆåªæœ‰ä¸¤ç§æ–¹æ³•ï¼š å°†è´¡çŒ®æœ€å°çš„é•¿é“¾å»æ‰ï¼Œç„¶ååŠ å…¥ xxx æ‰€åœ¨é•¿é“¾ï¼› æ‰¾åˆ°ç¦» xxx æœ€è¿‘é•¿é“¾çš„ä¸‹åŠéƒ¨åˆ†å¹¶æ›¿æ¢ã€‚ å€å¢è·³é•¿é“¾å³å¯ã€‚ä»£ç ã€‚ æ ‘åˆ†æ²» æ ‘åˆ†æ²»å¸¸ç”¨æ¥è¢«è§£å†³è·¯å¾„ç»Ÿè®¡é—®é¢˜ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ä»€ä¹ˆåˆ†æ²»å¥½å†™ï¼Œå°±ç”¨ä»€ä¹ˆå°±å¯ä»¥äº†ã€‚ é™æ€ç‚¹åˆ†æ²» æ ‘çš„ç‚¹åˆ†æ²»æ¯æ¬¡æ‰¾ä¸€ä¸ªé‡å¿ƒï¼Œç„¶åç»Ÿè®¡ç»è¿‡é‡å¿ƒçš„è·¯å¾„ï¼Œç„¶åæŠŠè¿™ä¸ªç‚¹åˆ å»ï¼Œæ ‘å˜æˆäº†å¾ˆå¤šè¿é€šå­å›¾ï¼Œé€’å½’ä¸‹å»è®¡ç®—ã€‚ æ¨¡æ¿ã€‚ç»™å®šä¸€æ£µè¾¹å¸¦æƒçš„æ ‘ï¼Œå¤šæ¬¡è¯¢é—®æ ‘ä¸Šè·ç¦»ä¸º kkk çš„ç‚¹æ˜¯å¦å­˜åœ¨ã€‚ æˆ‘ä»¬å…ˆä»»æ„é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹ rootrootrootï¼ˆæ˜¾ç„¶é‡å¿ƒæ¯”è¾ƒå¥½ï¼‰ï¼Œæ‰€æœ‰å®Œå…¨ä½äºå…¶å­æ ‘ä¸­çš„è·¯å¾„å¯ä»¥åˆ†ä¸ºï¼š ä¸ç»è¿‡å½“å‰æ ¹èŠ‚ç‚¹çš„è·¯å¾„ï¼› ç»è¿‡å½“å‰æ ¹èŠ‚ç‚¹çš„è·¯å¾„ï¼Œåˆå¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼š ä»¥æ ¹èŠ‚ç‚¹ä¸ºä¸€ä¸ªç«¯ç‚¹çš„è·¯å¾„ï¼› è·¨è¶Šæ ¹èŠ‚ç‚¹çš„è·¯å¾„ï¼Œå®é™…ä¸Šæ˜¯æœ‰ä¸¤æ¡ä»¥ä¸€ä¸ªæ ¹èŠ‚ç‚¹ä¸ºç«¯ç‚¹çš„è·¯å¾„åˆå¹¶è€Œæˆï¼Œåˆ†æ²»çš„æ—¶å€™åªéœ€è¦åˆå¹¶è¿™ç§ä¿¡æ¯ã€‚ æ‰¾åˆ°é‡å¿ƒ rrr ä½œä¸ºåˆ†æ²»ä¸­å¿ƒï¼Œæ‰“ä¸Šåˆ é™¤æ ‡è®°ï¼Œå¹¶ dfs å®ƒçš„æ¯ä¸€æ£µå­æ ‘ã€‚æ±‚å‡ºå­æ ‘å†…æ¯ä¸ªèŠ‚ç‚¹åˆ°åˆ†æ²»é‡å¿ƒçš„è·ç¦»å’Œæ¥æºäºå“ªä¸ªå„¿å­çš„å­æ ‘ï¼Œç»Ÿä¸€å­˜åœ¨ä¸€ä¸ª vector é‡Œï¼Œä½¿ç”¨åŒæŒ‡é’ˆæ¥åˆå¹¶ç­”æ¡ˆï¼ˆæ³¨æ„åªèƒ½åˆå¹¶ä¸åŒçš„å­æ ‘ï¼‰ã€‚ ç¦»çº¿ç»Ÿä¸€å¤„ç†å¯ä»¥å°†æ—¶é—´å¤æ‚åº¦é™ä½ä¸º O(nlogâ¡n(m+logâ¡n))O(n\\log n(m+\\log n))O(nlogn(m+logn))ï¼Œæ­£å¸¸å•æ¬¡ç‚¹åˆ†æ²»çš„æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚ä»£ç ã€‚ é™æ€è¾¹åˆ†æ²» æ¯æ¬¡æ‰¾åˆ°ä¸€æ¡è¾¹ï¼Œç„¶åç»Ÿè®¡ç»è¿‡è¿™æ¡è¾¹çš„è·¯å¾„ã€‚ä½†æ˜¯èŠèŠ±å›¾æ—¶çš„å¤æ‚åº¦ä¼šç›´æ¥çˆ†ç‚¸ï¼Œä¸ºæ­¤æˆ‘ä»¬éœ€è¦å¯¹æ ‘è¿›è¡Œä¸‰åº¦åŒ–ã€‚ å¯¹äºåº¦æ•°æ¯” 333 å¤§çš„èŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡åŠ è™šç‚¹ï¼ˆåŠ ä¸Šå»ä¸ä¼šæ”¹å˜ä¿¡æ¯çš„ç‚¹ï¼‰çš„æ–¹å¼æ¥å°†æ ‘çš„èŠ‚ç‚¹åº¦æ•°æ”¹æ‰ã€‚ç±»ä¼¼äºä¸‹å›¾çš„æ–¹å¼ï¼š é™æ€é“¾åˆ†æ²» ä½¿ç”¨æ ‘é“¾å‰–åˆ†çš„ç»“æ„ï¼Œæ¯æ¬¡å°†ä¸€æ¡é“¾çš„ä¿¡æ¯è¿›è¡Œåˆå¹¶ã€‚ä¹Ÿå°±æ˜¯æ‰€è°“çš„â€œæ ‘ä¸Šå¯å‘å¼åˆå¹¶â€ã€‚æ ¹æ®æƒ…å†µä½¿ç”¨é‡é“¾å‰–åˆ†æˆ–é•¿é“¾å‰–åˆ†å®ç°ã€‚ [CF1009F] Dominant Indices.è®¾ d(u,x)d(u,x)d(u,x) ä¸º uuu å­æ ‘ä¸­åˆ° uuu è·ç¦»ä¸º xxx çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œå¯¹äºæ¯ä¸ªèŠ‚ç‚¹æ±‚ä¸€ä¸ªæœ€å°çš„ kkkï¼Œä½¿å¾— d(u,k)d(u,k)d(u,k) æœ€å¤§ã€‚ æˆ‘ä»¬åªå…³å¿ƒæ¯ä¸ªèŠ‚ç‚¹å†…æ·±åº¦ä¸º jjj çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œé‚£ä¹ˆæ·±åº¦ç›¸åŒçš„èŠ‚ç‚¹æ˜¯ç­‰ä»·çš„ã€‚è®¾ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤ºå­æ ‘ iii å†…æ·±åº¦ä¸º jjj çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œåˆ™ fi,j=âˆ‘kâˆˆson(i)fk,jâˆ’1f_{i,j}=\\sum_{k\\in son(i)}f_{k,j-1}fi,jâ€‹=âˆ‘kâˆˆson(i)â€‹fk,jâˆ’1â€‹ã€‚ è€ƒè™‘é•¿é“¾å‰–åˆ†ä¼˜åŒ–ï¼šå¯¹äºé‡å„¿å­ï¼Œç›´æ¥ç»§æ‰¿å®ƒçš„ç­”æ¡ˆã€‚ç„¶ååˆå¹¶è½»å„¿å­çš„ç­”æ¡ˆï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šè¢«åˆå¹¶ä¸€æ¬¡ã€‚ å› ä¸ºæ‰€æœ‰ç‚¹çš„æ·±åº¦ä¹‹å’ŒåŠ èµ·æ¥æ˜¯ O(n)O(n)O(n)ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦çº¿æ€§ã€‚ä»£ç ã€‚ åŠ¨æ€æ ‘åˆ†æ²» å°†ç‚¹åˆ†æ²»ä¾æ¬¡æ‰«æçš„ç‚¹æ‹‰ä¸‹æ¥å³å¯å»ºç«‹ç‚¹åˆ†æ ‘ã€‚å¯¹äºä¸å…³å¿ƒæ ‘çš„å½¢æ€çš„é—®é¢˜ï¼Œå¯ä»¥ç”¨è¿™ç§æ–¹å¼å¤„ç†ã€‚å…¶å…³é”®æ€§è´¨æ˜¯ç‚¹åˆ†æ ‘ä¸Šçš„ LCA ä¸€å®šåœ¨åŸæ ‘çš„ä¸¤ç‚¹è·¯å¾„ä¸Šï¼›æ ‘é«˜ä¸º O(logâ¡n)O(\\log n)O(logn)ã€‚ ä¾‹é¢˜ æœ¬è´¨è¿˜æ˜¯åˆ†æ²»ï¼Œä¸»è¦é—®é¢˜åœ¨äºæ€è€ƒå¦‚ä½•åˆå¹¶ã€‚ [JOISC2020] é¦–éƒ½ Portal. è¦æ±‚çš„æ˜¯ä¸€ä¸ªå«æœ‰é¢œè‰²æ•°æœ€å°çš„è¿é€šå—ï¼Œç„¶åè¿é€šå—å†…çš„é¢œè‰²å’Œå—å¤–ä¸¤ä¸¤ä¸åŒï¼Œç‚¹åˆ†æ²»æš´åŠ›æ›´æ–°å³å¯ã€‚ä»£ç ã€‚ * [Ynoi2013] æˆéƒ½ä¸ƒä¸­ Portal. å…ˆè½¬åŒ–è¦æŸ¥è¯¢çš„ä¿¡æ¯ï¼šç‚¹ ppp åˆ° xxx çš„è·¯å¾„ä¸Šçš„ç‚¹çš„ç¼–å·åœ¨ [l,r][l,r][l,r]ï¼Œæœ‰å¤šå°‘ç§ä¸åŒé¢œè‰²çš„ç‚¹ ppp é¢œè‰²ã€‚ ç›´æ¥ç‚¹åˆ†æ²»ä¸‹å»ï¼Œä¸€ä¸ªè¯¢é—®ç¬¬ä¸€æ¬¡ç»Ÿè®¡åœ¨åˆæ³•è·¯å¾„èƒ½è¦†ç›–åˆ°å®ƒçš„æ—¶å€™ï¼Œç„¶åäºŒç»´æ•°ç‚¹ã€‚æ—¶é—´å¤æ‚åº¦ O((n+m)logâ¡2n)O((n+m)\\log^2 n)O((n+m)log2n)ã€‚ä»£ç ã€‚ [PtzS 2019 Day2] Interactive Vertex Portal. ç›´æ¥ç‚¹åˆ†æ²»ä¸‹å»ï¼Œæ¯æ¬¡éœ€è¦äºŒåˆ†ï¼Œè¯¢é—®æ¬¡æ•°æ˜¯ O(logâ¡2n)O(\\log^2 n)O(log2n) çš„ï¼Œæ¯æ¬¡éœ€è¦æ’é™¤è‡³å°‘ä¸€åŠçš„å¤§å°ï¼Œå› æ­¤äºŒåˆ†æ—¶å€™å¸¦ä¸ªæƒå€¼å³å¯ã€‚ä»£ç ã€‚ å…¶å®ƒæ ‘ä¸Šé—®é¢˜ æ ‘ä¸Šé—®é¢˜è¿˜æœ‰ä¸€äº›å…¶å®ƒç»“æ„ï¼Œè¿™é‡Œè®°å½•äº†å‡ ä¸ªå¸¸ç”¨çš„ã€‚ è™šæ ‘ åŠ¨æ€æ ‘ æ­»çµæ³•å¸ˆæŠ¹é™¤äº†æ­¤å¤„çš„çµé­‚ã€‚æœ¬éƒ¨åˆ†å°†ä¸ä¼šåœ¨ NOI2024 å‰æ›´æ–°ã€‚å› ä¸ºæŸç§åŸå› å†³å®šæ›´æ–°ã€‚Top Tree å’Œå…¶ç›¸å…³å†…å®¹å°†ä¼šåœ¨å¾ˆä¹…çš„ä»¥åæ›´æ–°åœ¨æŸå¤„ï¼ŒETT åˆ™ä¸çŸ¥é“ä¼šæ”¾åœ¨ä»€ä¹ˆåœ°æ–¹ï¼ˆä¹Ÿè®¸è‡ªå·±çœ‹çœ‹å°±å®Œäº†ï¼‰ã€‚è¿™é‡Œåªä»‹ç» LCTã€‚ æˆ‘ä»¬ä½¿ç”¨æ•°æ®ç»“æ„ç»´æŠ¤æ ‘ä¸Šç»“æ„ï¼Œä½†æ˜¯å¯¹äºåŠ¨æ€æ ‘é—®é¢˜ï¼Œæˆ‘ä»¬ä¸èƒ½ç®€å•åœ°é€šè¿‡é‡é“¾å‰–åˆ†æ¥å®Œæˆè¿™ä¸ªä¸œè¥¿ã€‚ å¯¹äºä¸€ä¸ªç‚¹è¿å‘å®ƒæ‰€æœ‰å„¿å­çš„è¾¹ï¼Œæˆ‘ä»¬è‡ªå·±é€‰æ‹©ä¸€æ¡è¾¹è¿›è¡Œå‰–åˆ†ï¼Œæˆ‘ä»¬ç§°è¢«é€‰æ‹©çš„è¾¹ä¸ºå®è¾¹ï¼Œå…¶ä»–è¾¹åˆ™ä¸ºè™šè¾¹ã€‚å¯¹äºå®è¾¹ï¼Œæˆ‘ä»¬ç§°å®ƒæ‰€è¿æ¥çš„å„¿å­ä¸ºå®å„¿å­ã€‚å¯¹äºä¸€æ¡ç”±å®è¾¹ç»„æˆçš„é“¾ï¼Œæˆ‘ä»¬åŒæ ·ç§°ä¹‹ä¸ºå®é“¾ï¼Œå¯ä»¥é‡‡ç”¨ Splay æ¥ç»´æŠ¤è¿™äº›å®é“¾ã€‚ LCT æ˜¯ç”¨ä¸€äº› Splay æ¥ç»´æŠ¤åŠ¨æ€çš„æ ‘é“¾å‰–åˆ†ï¼Œæˆ‘ä»¬å°†å…¶æˆä¸ºâ€œè¾…åŠ©æ ‘â€ã€‚ ä¾‹é¢˜ è¿˜æœ‰ä¸€äº›å‡ºç°åœ¨æ ‘ä¸Šçš„é—®é¢˜ï¼Œä½†æ˜¯è¯´ä¸å¤ªæ¸…å®ƒä»¬åˆ°åº•æ˜¯ä»€ä¹ˆé¢˜ã€‚ [Ynoi ER2022] è™šç©ºå¤„åˆ‘ Portal. é¦–å…ˆï¼Œæ ‘ä¸Šé‚»åŸŸä¿¡æ¯ä¸€å®šåªèƒ½ç»´æŠ¤å­æ ‘çš„ä¿¡æ¯ï¼Œå¦åˆ™å•ç‚¹ä¿®æ”¹ä¼šå¯¼è‡´æ‰€æœ‰å„¿å­éƒ½éœ€è¦ä¿®æ”¹ï¼Œå¤æ‚åº¦ç›´æ¥çˆ†ç‚¸ã€‚ ä»¤ Ci,jC_{i,j}Ci,jâ€‹ è¡¨ç¤º iii ç‚¹æ‰€åœ¨å­æ ‘èŒƒå›´å†…çš„è¿é€šå—çš„ jjj è‰²è¿é€šå—åºåˆ—ï¼Œä¿®æ”¹æ—¶ç›´æ¥å¯å‘å¼åˆå¹¶ï¼Œåªéœ€è¦æ›´æ–° Cfax,yC_{fa_x,y}Cfaxâ€‹,yâ€‹ å³å¯ã€‚å¤§æ¦‚æ˜¯åŒ logâ¡\\loglog çš„ï¼Œä»£ç ã€‚ å…¶å®ƒæ•°æ®ç»“æ„ é™¤äº†ä¹‹å‰ä»‹ç»çš„æ•°æ®ç»“æ„ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº›æ¯”è¾ƒå¸¸ç”¨çš„æ•°æ®ç»“æ„ã€‚ å·¦åæ ‘ å·¦åæ ‘æ˜¯ä¸€ç§å¯å¹¶å †ï¼Œå…¶åˆå¹¶çš„æ—¶é—´å¤æ‚åº¦ä¸ºä¼˜ç§€çš„ O(logâ¡n)O(\\log n)O(logn)ã€‚å¾—ç›Šäºåˆå¹¶æ“ä½œï¼Œåˆ é™¤æ ¹èŠ‚ç‚¹çš„æ“ä½œä¹Ÿå˜å¾—éå¸¸æ–¹ä¾¿ï¼šåªéœ€è¦åˆå¹¶å·¦å³å­æ ‘å³å¯ã€‚ æ¨¡æ¿ã€‚æ¯ä¸ªç‚¹ç»´æŠ¤å¯¹åº”çš„å·¦å³å­æ ‘å’Œæ ¹èŠ‚ç‚¹ï¼Œåˆå¹¶æ—¶è€ƒè™‘å°† vvv å…¨éƒ¨æ¥åˆ° uuu çš„å³å­æ ‘ï¼Œç„¶åä¿è¯å·¦å­æ ‘æ¯”å³å­æ ‘æ·±åº¦å¤§ï¼ˆå·¦åï¼‰ï¼Œç”¨å³å­æ ‘çš„æ·±åº¦æ›´æ–°å½“å‰ç‚¹çš„æ·±åº¦ã€‚åˆ é™¤ä¹‹åè®°å¾—å°†å·¦å³å­æ ‘å’Œæ ¹èŠ‚ç‚¹æ ¹éƒ½èµ‹æˆå·¦å³å­æ ‘åˆå¹¶çš„ç»“æœã€‚ä»£ç ã€‚ å®è·µä¸­å¯ä»¥ç›´æ¥é‡‡ç”¨ pbds çš„å¯å¹¶å †ã€‚ å¸¸è§ç»´æŠ¤æ¨¡å‹ å¯¹äºåºåˆ—ä¸Šçš„é—®é¢˜æœ‰ä¸€äº›å¸¸è§çš„å¤„ç†æ‰‹æ®µã€‚é™¤äº†åœ¨ çº¿æ®µæ ‘ ä¸€èŠ‚ä¸­æåˆ°çš„æ‰«æçº¿ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº›æ¨¡å‹éå¸¸ç»å…¸ï¼ˆä¹Ÿè®¸çœŸçš„ä¸æ˜¯é‚£ä¹ˆç»å…¸ï¼‰ã€‚ æ”¯é…å¯¹ ä¸€äº›é¢˜ç›®è®©æˆ‘ä»¬æ±‚â€œæœ€ä¼˜ç‚¹å¯¹â€ä¹‹ç±»çš„ä¸œè¥¿ï¼Œå¯èƒ½æœ‰ O(n2)O(n^2)O(n2) ä¸ªï¼Œä½†å®é™…ä¸Šæœ‰æ•ˆçš„å¹¶æ²¡æœ‰é‚£ä¹ˆå¤šï¼Œé‚£ä¹ˆé€šç”¨è§£æ³•å°±æ˜¯åªç»´æŠ¤å¯èƒ½æˆä¸ºç­”æ¡ˆçš„ç‚¹å¯¹ã€‚æ ¹æ®æƒ…å†µä¸åŒï¼Œå¯ä»¥ä¼˜åŒ–æˆ O(n),O(nlogâ¡n)O(n),O(n\\log n)O(n),O(nlogn) ç­‰ä¸ªæ•°ï¼Œå¯ä»¥ä½¿ç”¨æ•°æ®ç»“æ„ç»Ÿè®¡ã€‚ å¤§è‡´åˆ†ä¸ºä¸¤ç§ï¼šæœ¬è´¨ä¸åŒçš„ç‚¹å¯¹åªæœ‰ O(n)O(n)O(n) ä¸ªï¼Œæ¯”å¦‚ LCA åªæœ‰è¿™ä¹ˆå¤šï¼›è´¡çŒ®ä¸åŒçš„æœ‰ O(n2)O(n^2)O(n2) ä¸ªï¼Œå¸¸è§äº minâ¡,maxâ¡\\min,\\maxmin,max ç­‰é—®é¢˜ã€‚ [Luogu P6617] æŸ¥æ‰¾ Search Portal. å®šä¹‰ä¸€ä¸‹ä¸¤ç§å…³ç³»ï¼š â€œè¡¥â€è¡¨ç¤ºä¸æ•° xxx ç›¸åŠ ä¸º wwwã€‚ â€œç­‰â€è¡¨ç¤ºä¸æ•° xxx ç›¸ç­‰ã€‚ è®°å½•æ¯ä¸ªæ•°çš„è¡¥å‰é©±ï¼Œç„¶åç”¨çº¿æ®µæ ‘æŸ¥è¯¢åŒºé—´å†…è¡¥å‰é©±çš„æœ€å¤§ç¼–å·ï¼Ÿå½“ç„¶å¯ä»¥ï¼Œä½†æ˜¯ 1 5 5 5 5 5 è¿™ç§ä¿®æ”¹ 111 å°±å¯ä»¥ç›´æ¥ç‚¸æ‰ï¼šåé¢æ‰€æœ‰æ•°çš„è¡¥å‰é©±éƒ½å°†ä¼šå˜åŠ¨ã€‚ ä»¤ä¸€ä¸ªæ•°çš„è¡¥å‰é©±å¯ä»¥è¢«è®°å½•ï¼Œå½“ä¸”ä»…å½“å®ƒè¡¥å‰é©±çš„ä½ç½®åœ¨å®ƒç­‰å‰é©±å³è¾¹ï¼Œå¦åˆ™è®°å½•ä¸º 000ã€‚ä¸éš¾å‘ç°è¿™æ ·ä¾æ¬¡ä¿®æ”¹æœ€å¤šåªä¼šå½±å“ 555 ä¸ªæ•°ï¼šè‡ªèº«ã€åŸæ¥ axa_xaxâ€‹ çš„è¡¥åé©±å’Œç­‰åé©±ã€yyy çš„è¡¥åé©±å’Œç­‰åé©±ã€‚ä½¿ç”¨ set åŠ çº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ [Ynoi2010] y-fast trie Portal. åŠ å…¥é›†åˆæ—¶å°† xxx å–æ¨¡ï¼Œç„¶åå¯¹äºä¸¤ä¸ªç­”æ¡ˆæ•° i,ji,ji,j åˆ†ç±»è®¨è®ºï¼š Câ‰¥i+j&lt;2CC\\ge i+j&lt;2CCâ‰¥i+j&lt;2Cï¼Œè¿™æ ·åªéœ€è¦ç»´æŠ¤é›†åˆçš„æœ€å¤§å’Œæ¬¡å¤§å€¼å³å¯ã€‚ 0â‰¤i+j&lt;C0\\le i+j&lt;C0â‰¤i+j&lt;Cï¼Œæˆ‘ä»¬è®¨è®ºè¿™ç§æƒ…å†µã€‚ ç§°ä¸€ä¸ªæ•° iii åœ¨é›†åˆä¸­æ»¡è¶³ i+j&lt;Ci+j&lt;Ci+j&lt;C çš„æœ€å¤§æ•° jjj æ˜¯ iii çš„æœ€ä¼˜åŒ¹é…ï¼Œæˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªå¯ä»¥æ±‚å‡º iii çš„åŒ¹é…çš„å‡½æ•°ï¼Œå¹¶ä¸”èƒ½å¤Ÿå‘å®ƒæŒ‡å®šæ˜¯å¦ä¸èƒ½åŒ¹é…åˆ°è‡ªèº«ã€‚ ä¸€ä¸ªæ•°çš„æ”¹å˜å¯èƒ½ä¼šå½±å“ O(n)O(n)O(n) ä¸ªåŒ¹é…ã€‚æˆ‘ä»¬éœ€è¦åˆ å»ä¸€äº›æ— ç”¨çš„åŒ¹é…ï¼Œè®©éœ€è¦ä¿®æ”¹çš„åŒ¹é…ä¸ªæ•°æ§åˆ¶åœ¨ O(1)O(1)O(1) çº§åˆ«ã€‚æ¯”å¦‚ xxx çš„æœ€ä¼˜åŒ¹é…æ˜¯ yyyï¼Œè€Œ yyy çš„æœ€ä¼˜åŒ¹é…æ˜¯ zzzï¼Œæœ‰ zâ‰¥xz\\ge xzâ‰¥xï¼Œé‚£ä¹ˆ xxx åŠ å…¥æ—¶å°±ä¸éœ€è¦ä¿®æ”¹ yyy çš„æœ€ä¼˜åŒ¹é…ï¼Œå› ä¸ºç°æœ‰çš„ç­”æ¡ˆ y+zy+zy+z ä¸€å®šæ¯” x+yx+yx+y å¤§ï¼Œè¿›è€Œ y,zy,zy,z å¿…é¡»åŒå‘äº’ä¸ºæœ€ä¼˜åŒ¹é…è¿™ä¸ªç­”æ¡ˆæ‰éœ€è¦è¢«åˆ é™¤ï¼ˆx,yx,yx,y å˜æˆåŒå‘åŒ¹é…äº†ï¼‰ï¼Œä½†æ˜¯ x+yx+yx+y ä¸€å®šè¦è¢«æ’å…¥ã€‚ åˆ é™¤ xxx æ—¶ï¼Œx+yx+yx+y ä¸€å®šè¦è¢«åˆ é™¤ï¼Œå¦‚æœ y,zy,zy,z äº’ä¸ºæœ€ä¼˜åŒ¹é…éœ€è¦å°† y+zy+zy+z æ’å…¥å›æ¥ã€‚ä»£ç ã€‚ [CF765F] Souvenirs Portal. æ‰«æçº¿æ‰«å³ç«¯ç‚¹ã€‚ç»å¯¹å€¼ä¸å¥½å¤„ç†ï¼Œæ‹†æˆ j&lt;i,ajâ‰¥aij&lt;i,a_j\\ge a_ij&lt;i,ajâ€‹â‰¥aiâ€‹ï¼Œå€¼åŸŸç¿»è½¬ä¹‹åå†åšä¸€éå³å¯ã€‚ è€ƒè™‘ aia_iaiâ€‹ ä¼šå¯¹å“ªäº› jjj äº§ç”Ÿè´¡çŒ®ï¼Œæ¯æ¬¡æ‰¾å‡º â‰¥ai\\ge a_iâ‰¥aiâ€‹ çš„æœ€å¤§ jjjï¼Œæ­¤æ—¶æ–°å¢çš„å€™é€‰ç­”æ¡ˆä¸º ajâˆ’aia_j-a_iajâ€‹âˆ’aiâ€‹ï¼Œä¸‹ä¸€ä¸ªæ»¡è¶³çš„æ˜¯ k&lt;j,akâ‰¥ai,akâˆ’ai&lt;ajâˆ’aik&lt;j,a_k\\ge a_i,a_k-a_i&lt;a_j-a_ik&lt;j,akâ€‹â‰¥aiâ€‹,akâ€‹âˆ’aiâ€‹&lt;ajâ€‹âˆ’aiâ€‹ï¼Œä¹Ÿå°±æ˜¯è¯´ aiâ‰¤ak&lt;ai+aj2a_i\\le a_k&lt; \\cfrac{a_i+a_j}{2}aiâ€‹â‰¤akâ€‹&lt;2aiâ€‹+ajâ€‹â€‹ã€‚å› æ­¤æŸ¥è¯¢æ¬¡æ•°åœ¨ O(logâ¡V)O(\\log V)O(logV) æ¬¡ï¼Œæ»¡è¶³æ¡ä»¶çš„ kkk å¯ä»¥ä½¿ç”¨çº¿æ®µæ ‘æ±‚å‡ºã€‚ æ ‘çŠ¶æ•°ç»„ç»´æŠ¤åç¼€ minâ¡\\minmin å³å¯æ±‚å‡ºç­”æ¡ˆã€‚ä»£ç ã€‚ * [Ynoi2006] rldcot Portal. ç”±äº LCA åªæœ‰ O(n)O(n)O(n) ä¸ªï¼Œå› æ­¤å¯ä»¥æƒ³åˆ°å¯¹ LCA è¿›è¡Œç»Ÿè®¡ã€‚ k å°é—®é¢˜ æˆ‘ä»¬å¸¸è§åˆ°ä¸€ç§æ±‚ kkk å°å€¼çš„é—®é¢˜ï¼Œä¸€ä¸ªé€šç”¨æ€æƒ³æ˜¯è¿­ä»£ kkk æ¬¡ï¼Œæ¯æ¬¡å¯»æ‰¾ä¸€ä¸ªè§£çš„æ¬¡ä¼˜è§£ï¼Œå¹¶ç”¨ä¸€äº›æ‰‹æ®µé˜²æ­¢ç®—é‡ã€‚æ¯”å¦‚ç»å…¸çš„ kkk çŸ­è·¯å’Œ kkk å°ç”Ÿæˆæ ‘ï¼ˆè§ä¸€è½®å¤ä¹  IVï¼‰ã€‚ * [NOI2010] è¶…çº§é’¢ç´ Portal. è€ƒè™‘å­æ®µçš„å’Œæ˜¯ä»€ä¹ˆã€‚å¯¹äºåŒä¸€ä¸ªå·¦ç«¯ç‚¹ï¼Œè¦åœ¨åˆæ³•èŒƒå›´å†…å–ä¸€ä¸ªå‰ç¼€å’Œæœ€å¤§çš„å³ç«¯ç‚¹ï¼Œé‚£ä¹ˆåªéœ€è¦åœ¨ä¼˜å…ˆé˜Ÿåˆ—é‡Œå­˜å‚¨ O(n)O(n)O(n) ä¸ªå…ƒç´ å³å¯ä»£è¡¨æ‰€æœ‰çš„å­æ®µã€‚ä»£ç ã€‚ [CCO2020] Shopping Plans Portal. ä¸€ä¸ªåºåˆ—çš„å¾ˆå®¹æ˜“ï¼Œè®°å½“å‰é•¿åº¦ã€å½“å‰æ¡ç€çš„å…ƒç´ ã€æ¡ç€çš„å…ƒç´ æœ€å¤šèƒ½æ‰©å±•åˆ°çš„ä½ç½®ï¼Œå°±æ²¡æœ‰é‡å¤çš„äº†ã€‚ ç„¶åå°±æ˜¯ä¸€äº›åºåˆ—ï¼Œæ¯ä¸ªåºåˆ—é€‰æ‹©ä¸€ä¸ªæ•°çš„ kkk å°ã€‚å¥½åšï¼è®°å½•å½“å‰æ‰©å±•åˆ°äº†ç¬¬å‡ ä¸ªåºåˆ—ï¼Œè¿™ä¸ªåºåˆ—é€‰æ‹©åˆ°äº†å“ªä¸€ä¸ªï¼Œåé¢çš„åºåˆ—é»˜è®¤é€‰æ‹©æœ€å°ã€‚ä½†æ˜¯è¿™æ ·é€‰æœ€å°çš„å°±ç®—é‡å¤äº†ï¼Œäºæ˜¯ç›´æ¥é€‰æ¬¡å°ï¼ŒçœŸçš„éœ€è¦é€‰æœ€å°çš„åæ‚”ä¸€ä¸‹å°±è¡Œäº†ã€‚ä»£ç ã€‚ å‡åŠè­¦æŠ¥å™¨ æ¨¡æ¿ã€‚å¯ä»¥ä»¥ O(logâ¡V)O(\\log V)O(logV) çš„ä»£ä»·å°†å¤šå…ƒé™åˆ¶è½¬åŒ–ä¸ºä¸€å…ƒé™åˆ¶ã€‚å…·ä½“æ¥è¯´ï¼Œç»´æŠ¤ä¸€ä¸ª set æ¥å­˜å‚¨é™åˆ¶ï¼Œæ¯æ¬¡å°†é™åˆ¶å¹³å‡åˆ†ç»™æ¯ä¸€å…ƒé™åˆ¶ï¼Œç„¶åä¿®æ”¹ä¸€å…ƒå…ƒç´ æ—¶å»æ£€æŸ¥ã€‚ä»£ç ã€‚ é¢˜è½¦ å¯¹äºå¯¹åº”çš„ç»„åˆ«æ¥è¯´ï¼Œä¸­æ¡£é¢˜ä¼šé™„å¸¦ä¸€ä¸ªæ˜Ÿå·ï¼Œéš¾é¢˜ä¼šé™„å¸¦ä¸¤ä¸ªæ˜Ÿå·ã€‚ åˆ·åŸºç¡€ 1 åºåˆ—ç»´æŠ¤ã€‚ [CF1000F] One Occurrence Portalã€‚æŒ‰å³ç«¯ç‚¹æ’åºï¼Œç„¶åä¾æ¬¡åŠ å…¥æ¯ä¸ªæ•°ï¼Œçº¿æ®µæ ‘ç»´æŠ¤è´¡çŒ®ä½ç½®ã€‚ä»£ç ã€‚ * [CF115E] Linear Kingdom Races Portalã€‚è®¾ fif_ifiâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii æ¡é“è·¯çš„æœ€å¤§ä»·å€¼ï¼Œçº¿æ®µæ ‘çš„ç¬¬ jjj ä¸ªèŠ‚ç‚¹ç»´æŠ¤å½“ j+1j+1j+1 ä»¥åèŠ‚ç‚¹å…¨éƒ¨ä¿®å¥½ï¼Œå…¶ä½™ä¸åšè€ƒè™‘çš„ä»·å€¼ï¼Œè¿™æ ·æ¯ä¸€ä¸ªæ¯”èµ›éƒ½æ˜¯åŒºé—´åŠ æ“ä½œã€‚ä»£ç ã€‚ * [å›½å®¶é›†è®­é˜Ÿ] ç­‰å·®å­åºåˆ— Portalã€‚æˆ‘ä»¬ä¾æ¬¡æ‰«ææ¯ä¸ª iiiï¼Œè¦æ±‚ iii ä¹‹å‰ aiâˆ’ka_i-kaiâ€‹âˆ’k å‡ºç°ï¼Œai+ka_i+kaiâ€‹+k ä¸å‡ºç°ï¼Œä¹Ÿå°±æ˜¯ aia_iaiâ€‹ ä¸ºä¸­å¿ƒçš„ä¸ä¸ºå›æ–‡ä¸²ï¼Œçº¿æ®µæ ‘ç»´æŠ¤å“ˆå¸Œå³å¯ã€‚ä»£ç ã€‚ [CF643G] Choosing Ads Portalã€‚ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤æ‘©å°”æŠ•ç¥¨ï¼Œæ¯æ¬¡æŠŠå‡ºç°æ¬¡æ•°æœ€å°çš„ä¸œè¥¿ç»™æŠ•å‡ºå»å³å¯ã€‚ä»£ç ã€‚ *ã€æ¨¡æ¿ã€‘åŒºé—´åç»§ Portalã€‚ç¦»çº¿ï¼Œæƒå€¼çº¿æ®µæ ‘ç»´æŠ¤æ¯ä¸ªæƒå€¼å‡ºç°çš„æœ€å¤§ä¸‹æ ‡ï¼Œçº¿æ®µæ ‘ä¸Šçš„æŸ¥è¯¢æœ€å¤šåªä¼šæŸ¥ä¸¤æ¡é“¾ã€‚ä»£ç ã€‚å¦ä¸€ç§åšæ³•æ˜¯æŒ‰ç…§ kkk ç¦»çº¿ï¼ŒåºŸæ‰æ¯” kkk å°çš„å…ƒç´ ï¼Œç„¶ååŒºé—´æŸ¥è¯¢æœ€å°å€¼å³å¯ã€‚ * [CF811E] Vladik and Entertaining Flags Portalã€‚çœ‹åˆ° nâ‰¤10n\\le 10nâ‰¤10 å’ŒåŒºé—´æŸ¥è¯¢ä¸éš¾æƒ³åˆ°çº¿æ®µæ ‘ï¼Œåˆå§‹å‡è®¾æ‰€æœ‰ç‚¹éƒ½ä¸åœ¨ä¸€ä¸ªè¿é€šå—å†…ï¼Œç„¶ååˆå¹¶ä¸¤æ®µåŒºé—´æ—¶æš´åŠ›å¹¶æŸ¥é›†åˆå¹¶å³å¯ã€‚ä»£ç ã€‚ * [Ynoi2015] æˆ‘å›æ¥äº† Portal. è€ƒè™‘å¯¹äºæ¯ä¸€ä¸ªå¯èƒ½çš„ ddd åˆ†åˆ«è€ƒè™‘ã€‚å¯¹äºä¸€ä¸ªäºµæ¸ä¼¤å®³ dddï¼Œä¾æ¬¡åˆ¤æ–­æ˜¯å¦å­˜åœ¨è¡€é‡ä¸º [1,d],[d+1,2d],â‹¯ ,[dÃ—âŒŠndâŒ‹+1,n][1,d],[d+1,2d],\\cdots,\\left[d\\times \\left\\lfloor\\dfrac n d \\right\\rfloor +1,n\\right][1,d],[d+1,2d],â‹¯,[dÃ—âŒŠdnâ€‹âŒ‹+1,n] çš„éšä»ã€‚ ç¦»çº¿ï¼Œå¤„ç†å‡º ST è¡¨æ±‚å‡º td,it_{d,i}td,iâ€‹ ä»£è¡¨ä¼¤å®³ä¸º ddd çš„äºµæ¸çš„ç¬¬ iii æ®µåŒºé—´æœ€æ—©å‡ºç°éšä»çš„æ—¶é—´ã€‚å¯¹ ttt åšä¸€æ¬¡å‰ç¼€ maxâ¡\\maxmax å³å¯æ±‚å‡ºäºµæ¸è§¦å‘çš„æ—¶é—´ï¼Œæ ‘çŠ¶æ•°ç»„ç»´æŠ¤å³å¯ã€‚æ³¨æ„åˆå§‹å¿…å®šè§¦å‘ä¸€æ¬¡äºµæ¸ã€‚ä»£ç ã€‚ [CF19D] Points Portalã€‚å¯¹äº xxx åæ ‡å»ºç«‹çº¿æ®µæ ‘ç»´æŠ¤ yyy åæ ‡çš„æœ€å¤§å€¼ï¼Œæ¯ä¸ª xxx å¼€ä¸€ä¸ª set æ¥è®°å½•è¿™é‡Œé¢çš„ yyy åæ ‡ï¼Œç„¶åç›´æ¥åšå°±è¡Œï¼Œæ—¶é—´å¤æ‚åº¦ O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚ä»£ç ã€‚ *ã€UR #19ã€‘å‰è¿›å›› Portal. åœ¨çº¿å¯ä»¥ç›´æ¥æ¥¼æˆ¿é‡å»ºï¼Œä½†æ˜¯è¿™é‡Œè¿‡ä¸å»ä¸€ç‚¹ã€‚ æ‰«æçº¿ç»´æŠ¤åºåˆ—ç»´ï¼Œæ•°æ®ç»“æ„ç»´æŠ¤æ—¶é—´ç»´ã€‚çº¿æ®µæ ‘ä¸Šçš„å€¼ä»£è¡¨å½“å‰çš„åç¼€æœ€å°å€¼ï¼Œæ‰«æçº¿ä»åå¾€å‰æ‰«ï¼Œå‡å®šå½“å‰æšä¸¾åˆ°äº† xxxï¼Œå®ƒçš„å€¼æ˜¯ vvvï¼Œå­˜åœ¨æ—¶é—´æ˜¯ [l,r][l,r][l,r]ï¼Œåˆ™è®© [l,r][l,r][l,r] ä¸­çš„æ•°éƒ½å¯¹ vvv å– minâ¡\\minminï¼ŒSGT Beats ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ [CF484E] Sign on Fence Portalã€‚å…ˆäºŒåˆ†åšæ‰ï¼Œç„¶åå¯¹äºæ¯ä¸ªå€¼å»ºç«‹ä¸»å¸­æ ‘ï¼ŒæŸ¥è¯¢æ—¶æŸ¥è¯¢åŒºé—´çš„æœ€é•¿è¿ç»­ 111 å­æ®µçš„é•¿åº¦æ˜¯å¦å°äºç­‰äº kkk å³å¯ã€‚ä»£ç ã€‚ [SP1557] GSS2 Portalã€‚æ‰«æçº¿æ‰«å³ç«¯ç‚¹ï¼ŒBeats ç»´æŠ¤å½“å‰æ¯ä¸ª lll å¯¹åº”çš„ [l,r][l,r][l,r] çš„å’Œï¼Œæ±‚å‡ºå†å²æœ€å¤§å€¼å³å¯ã€‚ä»£ç ã€‚ [CF1936D] Bitwise Paradox Portalã€‚æˆ–çš„å€¼åªä¼šæ”¹å˜ logâ¡\\loglog æ¬¡ï¼Œæ‰€ä»¥ç›´æ¥ç»´æŠ¤å‰ç¼€åç¼€çš„è¿ç»­æ®µï¼Œåˆå¹¶å³å¯ã€‚ä»£ç ã€‚ åˆ·åŸºç¡€ 2 æ ‘ä¸Šé—®é¢˜ã€‚ [SDOI2016] æ¸¸æˆ Portalã€‚æ ‘å‰–ï¼Œç„¶åæè¶…çº¿æ®µæ ‘ç»´æŠ¤ã€‚å¦‚ä½•æ”¯æŒåŒºé—´æŸ¥è¯¢ï¼Ÿé¢å¤–ç»´æŠ¤ä¸€ä¸ªåŒºé—´å¯¹åº”çš„æœ€å°å€¼å³å¯ã€‚ä»£ç ã€‚ [NOIP2012 æé«˜ç»„] ç–«æƒ…æ§åˆ¶ Portalã€‚ä¼˜å…ˆè€ƒè™‘äºŒåˆ†ï¼Œç„¶ååœ¨å…è®¸æ—¶é—´å†…å°½å¯èƒ½å°†å†›é˜Ÿå¾€ä¸Šæï¼Œå‰©ä½™çš„è¿˜èƒ½è¶Šè¿‡æ ¹èŠ‚ç‚¹å†ä¸‹æ¥çš„éœ€è¦å•ç‹¬è®°å½•ï¼Œè´ªå¿ƒå³å¯ã€‚ä»£ç ã€‚ [XXI Open Cup, GP of Korea] Query On A Tree 17 Portal. é¦–å…ˆæ˜¯æœ€å°æ·±åº¦é‡å¿ƒçš„æ€§è´¨ï¼Œå­æ ‘æƒå€¼å’Œä¸€å®šä¸¥æ ¼å¤§äºæ‰€æœ‰ç‚¹æƒå€¼å’Œçš„ä¸€åŠã€‚ å†™ DFS åºï¼Œç¬¬ iii ä¸ªæ•°å†™ aia_iaiâ€‹ æ¬¡ï¼Œæœ€ä¸­é—´çš„æ•°ä¸€å®šæ˜¯å­æ ‘é‡Œçš„ï¼Œå€å¢è·³çˆ¶äº²å³å¯ã€‚ä»£ç ã€‚ [CEOI2019] Dynamic Diameter Portal. è€ƒè™‘ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ç­”æ¡ˆï¼Œæ¯æ¬¡å¯ä»¥å°†é›†åˆçš„ä¸¤åŠåˆå¹¶æˆå½“å‰é›†åˆçš„ç­”æ¡ˆï¼ˆåªéœ€è¦è€ƒè™‘ 444 ä¸ªå¯èƒ½çš„ç›´å¾„ï¼‰ï¼Œé“¾ä¸Šè·ç¦»ä½¿ç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ åˆ·æå‡ 1 é€æ¸å¼€å§‹å˜å¾—æœ‰æ„æ€èµ·æ¥äº†ï¼Œè¯·åšå¥½æˆ˜æ–—å‡†å¤‡ï¼ [CF1290E] Cartesian Tree Portal. å»ºå‡ºå¤§æ ¹ç¬›å¡å°”æ ‘ï¼Œå­æ ‘å¤§å°ç›¸å½“äºä»¤å…¶å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå¤§çš„æ•°ä¸º lllï¼Œå³è¾¹ä¸º rrrï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ âˆ‘râˆ’lâˆ’1\\sum r-l-1âˆ‘râˆ’lâˆ’1ã€‚æ‰€æœ‰çš„æ“ä½œéƒ½å¯ä»¥ç”¨ SGT Beats ç»´æŠ¤ã€‚ä»£ç ã€‚ [Ynoi2015] å³ä¾¿çœ‹ä¸åˆ°æœªæ¥ Portal. kkk æ¯”è¾ƒå°ï¼Œå› æ­¤æˆ‘ä»¬å…ˆè€ƒè™‘åªæœ‰ä¸€ä¸ª kkk çš„æ—¶å€™æ€ä¹ˆåšã€‚ å¯¹å€¼åŸŸçš„ç»Ÿè®¡å®¹æ˜“æƒ³åˆ°ç¦»çº¿ï¼Œè€ƒè™‘æ‰«æçº¿ç»´æŠ¤å³ç«¯ç‚¹ï¼Œæ•°æ®ç»“æ„ç»´æŠ¤å·¦ç«¯ç‚¹ã€‚ç”±äº kkk å®åœ¨å¾ˆå°ï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥å¯¹ä¸€ä¸ªå…ƒç´ æ‰«å®ƒå‰å kkk ä¸ªæ•°æ¥ç»Ÿè®¡ã€‚ ç»´æŠ¤æ¯ä¸€ä¸ªæ•°çš„æœ€åä¸€æ¬¡å‡ºç°ã€‚å½“æ‰«åˆ°äº†ä¸€ä¸ª ar=xa_r=xarâ€‹=xï¼Œè€ƒè™‘ xxx çš„å‡ºç°ä¼šå¯¹æé•¿å€¼åŸŸè¿ç»­æ®µçš„é•¿åº¦äº§ç”Ÿä»€ä¹ˆå½±å“ã€‚è€ƒè™‘æ‰¾å‡º [xâˆ’9,x+9][x-9,x+9][xâˆ’9,x+9] æœ€åå‡ºç°çš„ä½ç½®ï¼ŒæŒ‰ç…§ä½ç½®ä»å¤§åˆ°å°æ’åºã€‚å¦‚æœè¯¢é—®çš„ lll ä½äº xâˆ’1x-1xâˆ’1 ä¹‹å‰ï¼Œé‚£ä¹ˆ xâˆ’1x-1xâˆ’1 å°±å¯ä»¥è¢«è®¡å…¥æé•¿å€¼åŸŸè¿ç»­æ®µä¸­ã€‚æ³¨æ„æ‰€æœ‰è®¡ç®—çš„ lll åº”è¯¥åœ¨ xxx ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ä¹‹åï¼Œå› ä¸ºè¿™æ ·æ‰èƒ½ä¿è¯ xxx æ˜¯æ–°åŠ å…¥çš„ã€‚ åœ¨ [â€¦,xâˆ’1][\\dots,x-1][â€¦,xâˆ’1] çš„åºåˆ—è®¡å…¥æé•¿å€¼åŸŸè¿ç»­æ®µæ—¶ï¼Œç”±äº xxx çš„åŠ å…¥ï¼Œè¿™ä¸€ä¸ªæé•¿å€¼åŸŸè¿ç»­æ®µè¦è¢«æ’¤é”€ã€‚æ•´ä½“çš„è¿‡ç¨‹æ˜¯ä¸€ä¸ªåŒºé—´ä¿®æ”¹å•ç‚¹æŸ¥è¯¢çš„è¿‡ç¨‹ï¼Œæ ‘çŠ¶æ•°ç»„å¯ä»¥å¾ˆæ–¹ä¾¿åœ°ç»´æŠ¤ã€‚ ç”±äºæˆ‘ä»¬è¦ç»Ÿè®¡çš„æœ€é•¿æ˜¯ [xâˆ’10,xâˆ’1][x-10,x-1][xâˆ’10,xâˆ’1] è¿™ä¸€æ®µçš„æé•¿ï¼Œå› æ­¤æ•´ä½“è¦æ‰«åˆ° [xâˆ’11,x+11][x-11,x+11][xâˆ’11,x+11] æ‰èƒ½ç»Ÿè®¡å…¨éƒ¨çš„å½±å“ã€‚æ—¶é—´å¤æ‚åº¦ O(k(n+m)logâ¡n)O(k(n+m)\\log n)O(k(n+m)logn)ã€‚ä»£ç ã€‚ [IOI2021] åˆ†ç³–æœ Portal. å¦‚æœä¸Šç•Œä¸€æ ·ï¼Œé‚£ä¹ˆç›´æ¥å‰å¸æœºçº¿æ®µæ ‘ã€‚ é¢˜ç›®å‡ ä¹ç›´æ¥å‘Šè¯‰äº†æˆ‘ä»¬åœ¨çº¿åšä¸äº†ã€‚æ‰«æçº¿ç»´æŠ¤åºåˆ—ç»´ï¼Œæ•°æ®ç»“æ„ç»´æŠ¤æ“ä½œåºåˆ—ï¼Œç„¶åä¸ä¼šã€‚ å¥—è·¯åœ°ï¼Œä¸»åŠ¨å¼±åŒ–é¢˜ç›®æ¡ä»¶ã€‚è€ƒè™‘æ²¡ä¸Šç•Œæ€ä¹ˆåšï¼Œå‘ç°åªéœ€è¦äºŒåˆ†æœ€åä¸€ä¸ªæœ€å°å‰ç¼€å’Œå°äº 000 çš„ä½ç½®ï¼Œç„¶åæ“ä½œåºåˆ—åç¼€å’Œå°±æ˜¯ç­”æ¡ˆã€‚ ç„¶åæ˜¯æœ‰ä¸Šç•Œï¼Œå¦‚æœç¢°åˆ°äº†ä¸Šç•Œï¼Œé‚£ä¹ˆ c,0c,0c,0 ä¹‹é—´çš„å˜åŒ–ä¸€å®šæ˜¯è¿™æ®µæ“ä½œåºåˆ—çš„å‰ç¼€æœ€å¤§å’Œå‡å‰ç¼€æœ€å°çš„å€¼å¤§äº cccã€‚ çº¿æ®µæ ‘äºŒåˆ†æ‰¾åˆ°æœ€å³çš„å·¦ç«¯ç‚¹åï¼Œå®ƒä¸€å®šæ˜¯æœ€åä¸€æ¬¡ç¢°ç•Œçš„ä¸€æ¬¡ï¼Œæ ¹æ®å…¶å€¼åˆ¤æ–­æ˜¯ç¢°ä¸‹ç•Œè¿˜æ˜¯ç¢°ä¸Šç•Œï¼Œç„¶åä¸éš¾è®¡ç®—å‡ºæ­£ç¡®çš„åç¼€å’Œã€‚ çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´å‰ç¼€æœ€å¤§æœ€å°å€¼å’ŒåŒºé—´å’Œå³å¯ã€‚ä»£ç ã€‚ * [CF1083D] The Fair Nutâ€™s getting crazy Portal. æšä¸¾ä¸¤ä¸ªå­æ®µç›¸äº¤çš„éƒ¨åˆ†ï¼Œç„¶åå°è¯•ç»Ÿè®¡ç­”æ¡ˆã€‚è®¾ prei,nxtipre_i,nxt_ipreiâ€‹,nxtiâ€‹ ä»£è¡¨ aia_iaiâ€‹ ä¸Šä¸€æ¬¡å’Œä¸‹ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œåˆ™ç­”æ¡ˆä¸ºï¼š âˆ‘l=1nâˆ‘r=lnmaxâ¡{0,lâˆ’maxpreâ¡(l,r)âˆ’1}Ã—maxâ¡{0,minnxtâ¡(l,r)âˆ’râˆ’1}\\sum_{l=1}^{n}\\sum_{r=l}^{n}\\max\\{0,l-\\operatorname{maxpre}(l,r)-1\\}\\times \\max\\{0,\\operatorname{minnxt}(l,r)-r-1\\} l=1âˆ‘nâ€‹r=lâˆ‘nâ€‹max{0,lâˆ’maxpre(l,r)âˆ’1}Ã—max{0,minnxt(l,r)âˆ’râˆ’1} æšä¸¾ lllï¼Œmaxpreâ¡(l,r)\\operatorname{maxpre}(l,r)maxpre(l,r) å•è°ƒä¸é™ï¼Œminnxtâ¡(l,r)\\operatorname{minnxt}(l,r)minnxt(l,r) å•è°ƒä¸å‡ï¼Œäºæ˜¯åŒæŒ‡é’ˆæ‰« rrr å³å¯ã€‚è®° f(l,r)=maxpreâ¡(l,r)+1f(l,r)=\\operatorname{maxpre}(l,r)+1f(l,r)=maxpre(l,r)+1ï¼Œg(l,r)=minnxtâ¡(l,r)âˆ’1g(l,r)=\\operatorname{minnxt}(l,r)-1g(l,r)=minnxt(l,r)âˆ’1ã€‚ä¸€ä¸ª lll å¯ä»¥æ‰¾åˆ°æœ€å¤§çš„ rrr ä½¿å¾— [l,l],[l,l+1],â‹¯ ,[l,r][l,l],[l,l+1],\\cdots,[l,r][l,l],[l,l+1],â‹¯,[l,r] è¢«è®¡å…¥ç­”æ¡ˆï¼Œç°åœ¨çš„é—®é¢˜æ˜¯è®¡ç®—ï¼š âˆ‘i=lr(lâˆ’f(l,i))Ã—(g(l,i)âˆ’i)=âˆ‘i=lrlÃ—g(l,i)+iÃ—f(l,i)âˆ’f(l,i)g(l,i)âˆ’lÃ—i\\begin{aligned} {} &amp; \\sum_{i=l}^r (l-f(l,i)) \\times(g(l,i)-i)\\\\ = &amp; \\sum_{i=l}^r l\\times g(l,i)+i\\times f(l,i)-f(l,i)g(l,i)-l\\times i \\end{aligned} =â€‹i=lâˆ‘râ€‹(lâˆ’f(l,i))Ã—(g(l,i)âˆ’i)i=lâˆ‘râ€‹lÃ—g(l,i)+iÃ—f(l,i)âˆ’f(l,i)g(l,i)âˆ’lÃ—iâ€‹ çº¿æ®µæ ‘ç»´æŠ¤å½“å‰å·¦ç«¯ç‚¹ä¸‹ f,gf,gf,g ä»¥åŠç›¸å…³ä¿¡æ¯ï¼Œå€’åºæšä¸¾ lllï¼Œè¿™æ ·å˜æˆäº†åŠ å…¥ä¿¡æ¯ã€‚ç”±äº f,gf,gf,g æ˜¯å­˜åœ¨å•è°ƒæ€§çš„ï¼Œæ¯æ¬¡å®é™…è¢«ä¿®æ”¹çš„å®é™…ä¸Šæ˜¯è¿ç»­çš„ä¸€æ®µï¼Œæ‰€ä»¥æ²¡å¿…è¦ç›´æ¥ä¸Š Beatsã€‚ä»¥ fff ä¸ºä¾‹ï¼Œæ‰¾åˆ° prei&gt;prel,i&gt;lpre_i&gt;pre_l,i&gt;lpreiâ€‹&gt;prelâ€‹,i&gt;l çš„æœ€å° iiiï¼Œ[l,i)[l,i)[l,i) æŸ“æˆ prelpre_lprelâ€‹ï¼Œå•è°ƒæ ˆæ‰¾å‡ºè¿™ä¸ªä½ç½®å³å¯ã€‚ä»£ç ã€‚ [CF1572F] Stations Portal. æ¯ä¸ªå¹¿æ’­ç«™èƒ½å‘å®ƒå³é¢è¿ç»­çš„ä¸€æ®µåŒºé—´ [i,ri][i,r_i][i,riâ€‹] ä¼ æ’­æ¶ˆæ¯ï¼Œä¿®æ”¹æ—¶ hih_ihiâ€‹ å˜æˆæœ€é«˜çš„ï¼Œä¹Ÿå°±æ˜¯ä»¤ rciâ†gir_{c_i}\\leftarrow g_irciâ€‹â€‹â†giâ€‹ï¼Œå¯¹äº cic_iciâ€‹ å·¦è¾¹çš„ä½ç½® jjjï¼Œåº”è¯¥ä»¤ rjâ†minâ¡{rj,iâˆ’1}r_j\\leftarrow \\min\\{r_j,i-1\\}rjâ€‹â†min{rjâ€‹,iâˆ’1}ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œrrr å¯ä»¥ç›´æ¥ SGT Beats ç»´æŠ¤ã€‚ä¿®æ”¹ rrr æ—¶å¯ä»¥ç»Ÿè®¡ bbb çš„è´¡çŒ®ï¼Œæ˜¯ä¸€ä¸ªåŒºé—´ä¿®æ”¹åŒºé—´æŸ¥è¯¢çš„é—®é¢˜ï¼Œæ ‘çŠ¶æ•°ç»„ç»´æŠ¤äºŒé˜¶å‰ç¼€å’Œå³å¯ã€‚ä»£ç ã€‚ [CF1368G] Shifting Dominoes Portal. å°†å›¾è¿›è¡Œé»‘ç™½æŸ“è‰²ï¼Œç„¶åæˆ‘ä»¬æ ¹æ®ä¸€ä¸ªéª¨ç‰Œï¼Œå°†å…¶ç§»åŠ¨è§†ä½œç©ºæ ¼ç§»åŠ¨ã€‚ç§»åŠ¨å‰åæ»¡è¶³é»‘ç™½é¢œè‰²ä¸å˜ï¼Œé‚£ä¹ˆè¿›è¡Œè¿è¾¹ï¼Œå¯ä»¥è¿æˆä¸€ä¸ªå¤–å‘æ ‘æ£®æ—ã€‚æœ€åæˆ‘ä»¬åªéœ€è¦æ±‚ç©ºæ ¼çš„ä½ç½®ï¼Œæ‰«æçº¿ç»´æŠ¤çŸ©å½¢é¢ç§¯å¹¶å³å¯ã€‚ä»£ç ã€‚ åˆ·æå‡ 2 æ ‘ä¸Šæ•°æ®ç»“æ„ç»¼åˆã€‚ [CF1017G] The Tree Portal. å¯¹äºæ“ä½œ 111ï¼Œæˆ‘ä»¬å•ç‚¹åŠ  111ã€‚å¦‚æœæ‰€æœ‰ç‚¹æƒåˆå§‹ä¸º âˆ’1-1âˆ’1ï¼Œé‚£ä¹ˆè¯¢é—®ç›¸å½“äºåˆ°æ ¹çš„æœ€å¤§åç¼€å’Œæ˜¯å¦ â‰¥0\\ge 0â‰¥0ã€‚ å¯¹äºæ“ä½œ 222ï¼Œåªéœ€è¦å°†å­æ ‘å†…éƒ¨çš„æƒå€¼èµ‹å€¼æˆ âˆ’1-1âˆ’1ï¼Œç„¶ååœ¨ xxx å¤„æ‰“ä¸€ä¸ªæ¸…é™¤è´¡çŒ®æ ‡è®°å³å¯ã€‚ä»£ç ã€‚ [é›†è®­é˜Ÿäº’æµ‹ 2021] å…³äºå› ä¸ºä¸å»å¹´äº’æµ‹â€¦â€¦ Portal. æ±‚çš„æ˜¯ ANDï¼Œæ‰€ä»¥æŠŠæœ€å¤§å€¼æå‡ºå°±è¡Œäº†ã€‚çº¿æ®µæ ‘æ¯ä¸ªèŠ‚ç‚¹å¼€ä¸€ä¸ª vector ä»å¤§åˆ°å°å­˜å‚¨æ‰€æœ‰çš„å€¼ï¼Œè¯¢é—®çš„æ—¶å€™è´ªå¿ƒå°±å¥½äº†ã€‚ä»£ç ã€‚ * [çœé€‰è”è€ƒ 2023] äººå‘˜è°ƒåº¦ Portal. 48 åˆ†ç›´æ¥ç»´æŠ¤å­æ ‘å†…çš„å‰ sizsizsiz å¤§å³å¯ã€‚ åˆ é™¤çš„è¯å¥—ä¸€å±‚çº¿æ®µæ ‘åˆ†æ²»å°±å¯ä»¥äº†ï¼Œç°åœ¨æƒ³ä¸€æƒ³æ€ä¹ˆåŠ å…¥ã€‚ è€ƒè™‘æ¨¡æ‹Ÿåæ‚”è´ªå¿ƒï¼Œæ‰¾åˆ° xxx çš„ç¥–å…ˆä¸­æ·±åº¦æœ€æ·±çš„æ»¡è¶³ s(u)=sizâ¡us(u)=\\operatorname{siz}_us(u)=sizuâ€‹ çš„ uuuï¼Œç„¶åæ›¿æ¢å­æ ‘å†…çš„æœ€å°å€¼ã€‚ æ ‘å‰–çº¿æ®µæ ‘ç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹çš„ sizuâ¡âˆ’ s(u)\\operatorname{siz_u}-\\ s(u)sizuâ€‹âˆ’ s(u) çš„æœ€å°å€¼ä»¥åŠå­æ ‘å†…çš„æœ€å°æƒå€¼ï¼Œç›´æ¥æ›¿æ¢å³å¯ã€‚æ ‘å‰–çº¿æ®µæ ‘è¢«å¡å¸¸äº†ï¼Œä»£ç ã€‚ åˆ·ç»¼åˆ ä¸€äº› logâ¡\\loglog æ•°æ®ç»“æ„ç»¼åˆé¢˜ã€‚ [CTT2014] ç„å­¦ Portal. å‘ç°æ“ä½œæ˜¯å…·æœ‰ç»“åˆå¾‹çš„ã€‚ç»´æŠ¤ä¸€æ£µé•¿åº¦ä¸º mmm çš„çº¿æ®µæ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸Šå¼€ä¸€ä¸ª vector æ¥å­˜å‚¨ â‰¤i\\le iâ‰¤i çš„è€³æœºä¼šæ‰§è¡Œçš„æ“ä½œã€‚åˆå¹¶çš„æ—¶å€™ç›´æ¥åŒæŒ‡é’ˆåˆå¹¶ï¼ŒæŸ¥è¯¢çš„æ—¶å€™äºŒåˆ†å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ O(qlogâ¡2n)O(q\\log^2 n)O(qlog2n)ï¼Œæœ¬è´¨ä¸Šæ˜¯äºŒè¿›åˆ¶åˆ†ç»„æ€æƒ³çš„ä¸€ç§è¿ç”¨ã€‚ä»£ç ã€‚ [CF1515H] Phoenix and Bits Portal. å¯¹äº 333 æ“ä½œç›´æ¥æ‰“æ ‡è®°ï¼Œå¯¹äº 444 æ“ä½œç›´æ¥åƒçº¿æ®µæ ‘ä¸€æ ·æŸ¥è¯¢ï¼Œæ“ä½œ 111 å¯ä»¥è½¬åŒ–ä¸ºæ“ä½œ 222ã€‚æ“ä½œ 222 ç›¸å½“äºå¯¹å·¦å„¿å­è¿›è¡Œæ“ä½œ 333 ç„¶ååˆå¹¶ã€‚é‚£ä¹ˆç›´æ¥åšå³å¯ã€‚ ä¸ºäº†ä¿è¯æ—¶é—´å¤æ‚åº¦ï¼Œåº”è¯¥è¿™æ ·åšï¼šå¦‚æœå¯ä»¥ç”¨å¼‚æˆ–æ“ä½œä»£æ›¿ï¼Œé‚£ä¹ˆä»£æ›¿ï¼Œå¦åˆ™æŒ‰ç…§ä¹‹å‰è¯´çš„é€’å½’ä¸‹å»ã€‚ å¦‚æœä¸èƒ½ä»£æ›¿ï¼Œè¯´æ˜åº•ä¸‹éœ€è¦åˆå¹¶çš„èŠ‚ç‚¹å’Œèƒ½å¤Ÿä»£æ›¿çš„èŠ‚ç‚¹éƒ½æ›´å¤šã€‚æœ€å¤šåˆå¹¶ O(nlogâ¡C)O(n\\log C)O(nlogC) ä¸ªèŠ‚ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦ O((n+q)logâ¡2C)O((n+q)\\log^2 C)O((n+q)log2C)ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"å¦ç±»åšé¢˜è®°å½•ï¼ˆä¸€ï¼‰","slug":"default/åšé¢˜è®°å½•/cf2023","date":"2023-06-28T00:00:00.000Z","updated":"2023-06-28T00:00:00.000Z","comments":true,"path":"539be67/","link":"","permalink":"https://james1badcreeper.github.io/539be67/","excerpt":"é€†å¤©çš„è®°å½•ã€‚","text":"é€†å¤©çš„è®°å½•ã€‚ PART I ä¸çŸ¥é“ã€‚ *1809. EDU 145 https://codeforces.com/contest/1809. E. Two Tanks å¦‚æœ c+dc+dc+d å›ºå®šï¼Œé‚£ä¹ˆç­”æ¡ˆåº”è¯¥æ—¶éšç€ ccc çš„å¢åŠ å…ˆä¸å˜ï¼Œå†é€’å¢ï¼Œæœ€ååˆä¸å˜çš„é¡ºåºè¿›è¡Œçš„ï¼Œè€Œä¸”æ¯æ¬¡çš„å·®å€¼åªæœ‰ 111ã€‚æ‰¾å‡ºè¿™ä¸¤ä¸ªä½ç½®å³å¯ã€‚ä»£ç ã€‚ F. Traveling in Berland å¦‚æœå½“å‰ä½ç½®æ²¹ä»·æ˜¯ 111ï¼Œé‚£ä¹ˆè‚¯å®šèƒ½åŠ æ»¡å°±åŠ æ»¡ï¼ˆä¼šç”¨å®Œï¼‰ï¼Œ222 çš„è¯èƒ½åŠ å¤šå°‘åŠ å¤šå°‘ã€‚è®¾ fif_{i}fiâ€‹ ä»£è¡¨ iii åˆ°ä¸‹ä¸€ä¸ªæ²¹ä»·æ˜¯ 111 çš„ä½ç½®çš„ä½ç½®ï¼Œsis_{i}siâ€‹ ä»£è¡¨ä»£ä»·ï¼Œå€å¢è¿™ä¸ªè¿‡ç¨‹å³å¯ã€‚ä»£ç ã€‚ G. Prediction å¯¹äºä¸€ä¸ªåˆæ³•çš„æ’åˆ— pppï¼Œåˆ é™¤ apia_{p_i}apiâ€‹â€‹ æœ€å°çš„ pip_ipiâ€‹ï¼Œæ–°çš„ pâ€²p&#x27;pâ€² å¿…å®šåˆæ³•ã€‚ è®¾ fif_{i}fiâ€‹ ä»£è¡¨å¡«å®Œ (i,n](i,n](i,n] çš„æ–¹æ¡ˆæ•°ï¼Œåˆå§‹ fn=1f_n=1fnâ€‹=1ï¼Œè€ƒè™‘ aia_iaiâ€‹ å¡«çš„ä½ç½®ï¼š ä¸å¡«åœ¨å½“å‰ç¬¬ä¸€ä¸ªä½ç½®ï¼Œä¸å½±å“åé¢å…ƒç´ çš„å‰ç¼€ maxâ¡\\maxmaxï¼Œfiâˆ’1â†+fi(nâˆ’i)f_{i-1}\\stackrel{+}{\\leftarrow} f_{i}(n-i)fiâˆ’1â€‹â†+fiâ€‹(nâˆ’i)ï¼› å¡«åœ¨å½“å‰ç¬¬ä¸€ä¸ªä½ç½®ã€‚è®¾ lstilst_ilstiâ€‹ ä»£è¡¨æœ€å¤§çš„ jjj ä½¿å¾— aiâˆ’aj&gt;ka_i-a_j&gt;kaiâ€‹âˆ’ajâ€‹&gt;kï¼Œé‚£ä¹ˆ (lsti,i)(lst_i,i)(lstiâ€‹,i) éƒ½éœ€è¦å‡ºç°åœ¨ iii ä¹‹å‰ï¼Œåˆ™ iâˆ’lstiâˆ’1i-lst_i-1iâˆ’lstiâ€‹âˆ’1 éœ€è¦å¡«å…¥ nâˆ’lstiâˆ’2n-lst_i-2nâˆ’lstiâ€‹âˆ’2 ä¸ªä½ç½®ï¼ˆé™¤äº†ç¬¬ä¸€ä¸ªï¼‰ã€‚ åŒæŒ‡é’ˆæ±‚ lstlstlstï¼Œæ—¶é—´å¤æ‚åº¦ O(n)O(n)O(n)ã€‚ä»£ç ã€‚ *1854. Div1 889 https://codeforces.com/contest/1854. B. Earn or Unlock å¦‚æœå‰ kkk ä¸ªèƒ½æ°å¥½è¢«è§£é”ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ âˆ‘i=1kaiâˆ’(kâˆ’1)\\sum_{i=1}^k a_i - (k-1)âˆ‘i=1kâ€‹aiâ€‹âˆ’(kâˆ’1)ã€‚å¯¹äºè§£é”æƒ…å†µå¯ä»¥ä½¿ç”¨ DP æ¥è§£å†³ï¼šè®¾ fif_ifiâ€‹ ä»£è¡¨å‰ç¼€ iii æ˜¯å¦æ°å¥½èƒ½è¢«è§£é”ï¼Œé‚£ä¹ˆ fj+aiâ†fj(jâ‰¥i)f_{j+a_i}\\leftarrow f_j(j\\ge i)fj+aiâ€‹â€‹â†fjâ€‹(jâ‰¥i)ï¼Œè¿™ä¸ªè¿‡ç¨‹å¯ä»¥ä½¿ç”¨ bitset åŠ é€Ÿã€‚ä»£ç ã€‚ *1856. Div2 890 (Done) https://codeforces.com/contest/1856. C. To Become Max æ²¡è°ƒå‡ºæ¥ï¼Œæˆ‘æ˜¯èœç‹—ï¼ nnn åªæœ‰ 100010001000ï¼Œæƒ³çš„æš´åŠ›ä¸€ç‚¹ï¼Œæšä¸¾æœ€ç»ˆæˆä¸ºç­”æ¡ˆçš„æ•° aia_iaiâ€‹ã€‚ä¸€å¼€å§‹è‚¯å®šè¦åˆ©ç”¨ ai+1a_{i+1}ai+1â€‹ è®© aia_iaiâ€‹ å˜å¾—å°½å¯èƒ½å¤§ï¼Œè¿™æ ·çš„ä»£ä»·æ˜¯æœ€å°çš„ã€‚å½“ ai&gt;ai+1a_i&gt;a_{i+1}aiâ€‹&gt;ai+1â€‹ æ—¶æ€ä¹ˆåŠï¼Ÿåˆ©ç”¨ ai+2a_{i+2}ai+2â€‹ è®© ai+1a_{i+1}ai+1â€‹ å˜å¤§ã€‚ å¦‚æœæ“ä½œæ¬¡æ•°è¶³å¤Ÿå¤šï¼Œé‚£ä¹ˆæœ€ç»ˆçš„åºåˆ—è‚¯å®šæ˜¯å½¢å¦‚ x,xâˆ’1,â‹¯ ,an+1,anx,x-1,\\cdots,a_n+1,a_nx,xâˆ’1,â‹¯,anâ€‹+1,anâ€‹ çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¾æ¬¡æšä¸¾ jâˆˆ[i+1,n]j\\in[i+1,n]jâˆˆ[i+1,n]ï¼Œå½“ ajâ‰¥ajâˆ’1a_j\\ge a_{j-1}ajâ€‹â‰¥ajâˆ’1â€‹ æ—¶ï¼Œè‡³å¤šå°±å¯ä»¥è®© aia_iaiâ€‹ å˜å¤§ ajâˆ’ajâˆ’1+1a_j-a_{j-1}+1ajâ€‹âˆ’ajâˆ’1â€‹+1ï¼Œæ­¤æ—¶æ›´æ–°ç­”æ¡ˆå³å¯ã€‚å¦‚æœä¸æ»¡è¶³ï¼Œaja_jajâ€‹ åœ¨åç»­çš„æ›´æ–°è¿‡ç¨‹ä¸­è‚¯å®šè¦å˜æˆ ajâˆ’1âˆ’1a_{j-1}-1ajâˆ’1â€‹âˆ’1ï¼Œå¦åˆ™æ— æ³•ä½¿ aia_iaiâ€‹ å˜å¾—æ›´å¤§ï¼Œæå‰æ›´æ–° aja_jajâ€‹ å³å¯ã€‚ä»£ç ã€‚ D. More Wrong çœ‹ä¸Šå»å°±å¾ˆåˆ†æ²»ã€‚å½“å‰ç‚¹ rrr åœ¨ [l,r][l,r][l,r] ä¸­æœ€å¤§çš„å……è¦æ¡ä»¶æ˜¯ Q(l,râˆ’1)=Q(l,r)Q(l,r-1)=Q(l,r)Q(l,râˆ’1)=Q(l,r)ï¼Œæ ¹æ®æ­¤åˆ†æ²»ä¸‹å»å³å¯ã€‚ä»£ç ã€‚ E. PermuTree åªè¦æ›´æ”¹å­æ ‘å†…çš„æƒå€¼åˆ†å¸ƒï¼Œå°±å¯ä»¥è¾¾åˆ°è´¡çŒ®æœ€å¤§åŒ–ï¼Œæ‰€ä»¥æ˜¯ä¸ªæ ‘ä¸ŠèƒŒåŒ…çŠ¶ç‰©ï¼Œå¯ä»¥é€šè¿‡ E1ï¼Œä»£ç ã€‚ å¯¹äº E2ï¼Œæˆ‘ä»¬è¦æ€è€ƒå¦‚ä½•é«˜æ•ˆè§£å†³â€œæŠŠå„¿å­å¤§å°æ„æˆçš„æ•°é›†åˆåˆ†æˆå·®å°½å¯èƒ½å°çš„ä¸¤éƒ¨åˆ†â€ã€‚å­æ ‘ä¸­ä¸åŒçš„ sizsizsiz æœ€å¤šåªæœ‰ n\\sqrt{n}nâ€‹ ç§ï¼ŒäºŒè¿›åˆ¶æ‹†åˆ†æ‰ä¿è¯ç‰©å“ä¸ªæ•°ä¸å¤šäº logâ¡n\\log nlogn ä¸ªï¼Œç„¶åæ˜¯å¯è¡Œæ€§èƒŒåŒ…é‡‡ç”¨ bitset ä¼˜åŒ–ï¼Œå•æ¬¡æ—¶é—´å¤æ‚åº¦æ˜¯ O(nnlogâ¡nw)O\\left(\\cfrac{n\\sqrt{n}\\log n}{w}\\right)O(wnnâ€‹lognâ€‹) çš„ã€‚ å¦‚ä½•å°†å…¶æ¬åˆ°æ ‘ä¸Šï¼Ÿç®€å•ã€‚å¦‚æœå­˜åœ¨ä¸€ä¸ªé‡å„¿å­ï¼Œå®ƒæ¯”æ‰€æœ‰è½»å„¿å­éƒ½é‡ï¼Œè¿™æ ·å¯ä»¥ç›´æ¥å¾—å‡ºç­”æ¡ˆã€‚å¦åˆ™ä¼šé€ æˆä¸€ä¸ªåˆ†æ²»çš„æ•ˆæœï¼Œæ¯æ¬¡é—®é¢˜è§„æ¨¡å¿…å®šå‡åŠï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nnlogâ¡2nw)O\\left(\\cfrac{n\\sqrt{n}\\log^2 n}{w}\\right)O(wnnâ€‹log2nâ€‹)ã€‚å®é™…æ•ˆç‡éå¸¸é«˜ã€‚ä»£ç ã€‚ *1859. Div2 892 https://codeforces.com/contest/1859. D. Andrey and Escape from Capygrad åªèƒ½è·³åˆ° [l,b][l,b][l,b]ï¼ˆå¦åˆ™æ²¡æœ‰æ„ä¹‰ï¼‰ï¼Œåˆå¹¶çº¿æ®µï¼ŒäºŒåˆ†æŸ¥æ‰¾ã€‚ä»£ç ã€‚ *1858. Div2 893 (Done) https://codeforces.com/contest/1858. D. Trees and Segments è€ƒè™‘ O(n2)O(n^2)O(n2) DP é¢„å¤„ç†å‡ºå‰åç¼€æ”¹ jjj æ¬¡å¾—åˆ°çš„ 000 çš„æœ€å¤§é•¿åº¦ï¼Œç„¶åæšä¸¾ä¸­é—´ 111 çš„é•¿åº¦ï¼ŒåŒæŒ‡é’ˆæ‰«ã€‚ä»£ç ã€‚ E. Rollbacks å®é™…ä¸Šè¿™æ˜¯ä¸ªå¤§æš´åŠ›é¢˜ã€‚ set è®°å½•æ‰€æœ‰æ•°çš„ä½ç½®ï¼Œä¸åŒæ•°çš„ä¸ªæ•°ç»å…¸åªç»´æŠ¤æœ€å°ä½ç½®æ•°çš„è´¡çŒ®ï¼Œåˆ é™¤æ“ä½œç›´æ¥å°†åºåˆ—é•¿åº¦å‡æ‰ä½†æ˜¯ä¿ç•™åºåˆ—ï¼Œå›æ»šç›´æ¥å›æ»šã€‚ä»£ç ã€‚ *1860. EDU 153 https://codeforces.com/contest/1860. D. *1354. EDU 87 (Done) https://codeforces.com/contest/1354. C2. Not So Simple Polygon Embedding å¤§è‡´æ€è·¯æ˜¯è§‚å¯Ÿè·å¾—å¤šè¾¹å½¢çš„æ—‹è½¬åº¦æ•°ï¼Œç„¶åè§£ä¸‰è§’å½¢ã€‚ä»£ç ã€‚ D. Multiset æƒå€¼æ ‘çŠ¶æ•°ç»„ç›´æ¥ç»´æŠ¤ã€‚ä»£ç ã€‚ E. Graph Coloring äºŒåˆ†å›¾æŸ“è‰²ï¼Œç„¶åèƒŒåŒ…åˆ¤æ–­å¯è¡Œæ€§ã€‚ä»£ç ã€‚ F. Summoning Minions å¿…å®šæ˜¯æ”¾æ»¡ kâˆ’1k-1kâˆ’1 å¼ åï¼Œæ‹¿å‰©ä¸‹çš„æ”¾å®Œå°±æ‰”ï¼ˆä¼šäº§ç”Ÿ bÃ—(kâˆ’1)b\\times (k-1)bÃ—(kâˆ’1) çš„è´¡çŒ®ï¼‰ï¼Œæœ€åå†æ”¾ä¸€å¼ ã€‚ æ”¾ç½®é¡ºåºå¿…å®šæ»¡è¶³ bbb é€’å¢ï¼ˆå¦åˆ™å¯ä»¥äº¤æ¢ï¼‰ï¼Œç„¶åæ ¹æ®æ­¤è¿›è¡Œ DPï¼šfi,jf_{i,j}fi,jâ€‹ ä»£è¡¨å‰ iii å¼ é€‰ jjj å¼ ä¸æ˜¯ç”¨å®Œå°±æ‰”çš„ã€‚ä»£ç ã€‚ G. Find a Gift å¦‚æœçŸ¥é“å…¶ä¸­ xxx ä¸ªæ˜¯çŸ³å¤´ï¼Œé‚£ä¹ˆå°±èƒ½ç”¨è¿™ xxx ä¸ªå»ç¡®å®šå¦å¤– xxx ä¸ªæ•°å½“ä¸­æœ‰æ²¡æœ‰çŸ³å¤´ã€‚å…ˆæ‰¾åˆ° 111 ä¸ªçŸ³å¤´ï¼Œç„¶åä»å¤´å¼€å§‹å€å¢æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ²¡æœ‰çŸ³å¤´çš„åŒºé—´ã€‚è¦ç¡®å®šè¿™æ®µæœ‰çŸ³å¤´çš„åŒºé—´çš„ç¬¬ 111 ä¸ªçŸ³å¤´ä½ç½®ï¼Œå¯ä»¥äºŒåˆ†ã€‚å¦‚ä½•æ‰¾åˆ°ä¸€ä¸ªçŸ³å¤´ï¼Ÿä¸çŸ¥é“ï¼Œé‡‡ç”¨éšæœºåŒ–ã€‚éšæœºæ‰¾åˆ°ä¸€äº›ä½ç½®ï¼Œæ‰¾åˆ°å½“ä¸­æœ€é‡çš„ï¼Œé‚£ä¹ˆå¯ä»¥ç¡®å®šé‚£ä¸ªæ˜¯çŸ³å¤´ã€‚ä»£ç ã€‚ *1867. Div2 897 https://codeforces.com/contest/1867. D. Cyclic Operations èµ›æ—¶ç»“è®ºå‡äº†ä¸€éƒ¨åˆ†ï¼Œåªå› ï¼ æœ€åå›¾å¤§æ¦‚å½¢å¦‚ä¸€ä¸ªå†…å‘åŸºç¯æ ‘æ£®æ—ä¹‹ç±»çš„ä¸œè¥¿ï¼Œé“¾ä¸Šçš„å¯ä»¥ä¸€æ¬¡æ»¡è¶³ kâˆ’1k-1kâˆ’1 ä¸ªï¼Œç¯çš„å¤§å°å¿…é¡»ä¸º kkkã€‚æ³¨æ„ k=1k=1k=1 çš„ç‰¹åˆ¤ã€‚ä»£ç ã€‚ PART II æœ¬ç€é¢˜æ˜¯ç”¨æ¥åˆ·çš„åŸåˆ™ï¼Œæˆ‘ä»¬ä» ARC 4 é¢˜åœºï¼Œä¸”æœ‰è‹±æ–‡é¢˜é¢çš„å¼€å§‹ã€‚ è¿›åº¦å¯è§†åŒ–ã€‚ ARC 058 å¯¹è¿œå¤ bot æ¥è¯´ï¼Œå¥½éš¾ã€‚ C. Iroha and Haiku Portal. æ•°æ®èŒƒå›´å¾ˆå°ï¼Œå› æ­¤è€ƒè™‘æƒ³å¾—æš´åŠ›ä¸€ç‚¹ã€‚å½“åç¼€å’Œè¶…è¿‡ X+Y+ZX+Y+ZX+Y+Z æ—¶ï¼Œå†è®°å½•å°±æ²¡æœ‰æ„ä¹‰ï¼ˆå› ä¸ºå¥½åŒºé—´ä¸å¯èƒ½å†è¢«é€‰å–åˆ°ï¼‰ï¼Œè¿™æ ·ç›´æ¥çŠ¶å‹åç¼€å’Œåºåˆ—ï¼ˆå°†åç¼€å’Œä¸­å‡ºç°çš„æ•°å­˜å‚¨èµ·æ¥ï¼‰ï¼Œä¾¿å¯ä»¥ç®€å•åˆ¤æ–­æ˜¯å¦å‡ºç°äº†å¥½åŒºé—´ã€‚ å¦‚æœä»æ»¡è¶³æ¡ä»¶çš„åŒºé—´è€ƒè™‘ï¼Œä¼šå‘ç°ä¸€ä¸ªåºåˆ—ä¸ä¸€å®šåªæœ‰ä¸€ä¸ªå¥½åŒºé—´ï¼Œè¿™æ ·å¾ˆå®¹æ˜“å¯¼è‡´ç®—é‡ã€‚å› æ­¤å¯¹ç­”æ¡ˆå–è¡¥é›†ï¼Œè€ƒè™‘è®¡ç®—æ²¡æœ‰æ»¡è¶³æ¡ä»¶çš„å­åŒºé—´çš„æ–¹æ¡ˆæ•°ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤ºè€ƒè™‘åºåˆ—å‰ iii ä½ï¼Œå½“å‰åç¼€å’ŒçŠ¶å‹åä¸º jjjã€‚è½¬ç§»æ—¶é‡‡ç”¨åˆ·è¡¨æ³•ï¼Œæšä¸¾æœ€åä¸€ä¸ªå¡«çš„æ•°ï¼Œè®¡ç®—æ–°çš„åç¼€å’Œï¼Œå¦‚æœæ»¡è¶³æ¡ä»¶ä¾¿ç»Ÿè®¡ç­”æ¡ˆã€‚ä»£ç ã€‚ D. æ–‡å­—åˆ—å¤§å¥½ãã„ã‚ã¯ã¡ã‚ƒã‚“ Portal. æ—¶é—´æ—…äººé€†è½¬äº†æ­¤å¤„çš„æ—¶é—´ã€‚å¤ªå›°éš¾äº†ï¼ ARC 059 è¿™åœºæ€ä¹ˆè¿™ä¹ˆç®€å•ã€‚ C. Children and Candies Portal. fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨å‰ iii ä¸ªäººåˆ†äº† jjj ä¸ªç³–æœçš„ç­”æ¡ˆï¼Œç›´æ¥è½¬ç§»ã€‚ä»£ç ã€‚ D. ãƒã‚¤ãƒŠãƒªãƒãƒƒã‚¯ Portal. å®¹æ˜“å‘ç°è¿™æ˜¯ä¸ªéª—å­é¢˜ï¼Œæ‰“çš„å­—ç¬¦ä¸²æ˜¯ä»€ä¹ˆè·Ÿç­”æ¡ˆæ²¡æœ‰å…³ç³»ã€‚è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨ iii æ¬¡ï¼Œé‚£ä¹ˆå¯ä»¥æ‰“ä¸€ä¸ªå­—ç¬¦ï¼ˆè´¡çŒ®ä¸º fiâˆ’1,maxâ¡{jâˆ’1,0}f_{i-1,\\max\\{j-1,0\\}}fiâˆ’1,max{jâˆ’1,0}â€‹ï¼Œj=0j=0j=0 æ—¶ç›¸å½“äºæ‰“ä¸€ä¸ªå›è½¦ï¼‰ï¼Œæ’¤å›ä¸€ä¸ªå­—ç¬¦ï¼ˆè´¡çŒ®ä¸º 2Ã—fiâˆ’1,j+12\\times f_{i-1,j+1}2Ã—fiâˆ’1,j+1â€‹ï¼Œå› ä¸ºæ’¤å›çš„æ˜¯ä»€ä¹ˆæ²¡å…³ç³»ï¼‰ã€‚ä»£ç ã€‚ ARC 060 åšè¿™ä¸ªä¸œè¥¿ä¸Šç˜¾ã€‚ B. Digit Sum Portal. å¦‚æœ b&lt;nb&lt;\\sqrt{n}b&lt;nâ€‹ï¼Œç›´æ¥æšä¸¾å³å¯ã€‚å¦åˆ™ nnn æ˜¯ bbb è¿›åˆ¶ä¸‹çš„ä¸¤ä½æ•°ï¼Œè§£ä¸å®šæ–¹ç¨‹å³å¯ã€‚ä»£ç ã€‚ C. Tak and Hotels Portal. å€å¢å¤„ç†å‡ºèƒ½èµ°åˆ°çš„æœ€è¿œä½ç½®ã€‚ä»£ç ã€‚ D. ??? æ­»çµæ³•å¸ˆæŠ¹é™¤äº†æ­¤å¤„çš„çµé­‚ã€‚è¿™æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä»¥åå†è¯´ã€‚ ARC 061 é˜¿å·´é˜¿å·´é˜¿å·´ã€‚ C. ã™ã¬ã‘å›ã®åœ°ä¸‹é‰„æ—…è¡Œ Portal. ç”¨åŒæ ·é¢œè‰²çš„è¾¹æ‰€è¿æ¥æˆçš„è¿é€šå—å¯ä»¥äº’ç›¸åˆ°è¾¾ï¼Œä¸éš¾æƒ³åˆ°å»ºä¸€ä¸ªè™šç‚¹ï¼Œå°†è¿™ä¸ªè”é€šå—å†…çš„æ‰€æœ‰ç‚¹å‘è™šç‚¹è¿ä¸€ä¸ªæƒå€¼ä¸º 000 çš„è¾¹ï¼Œç”±è¿™ä¸ªè¿é€šå—åˆ‡æ¢åˆ°åˆ«çš„è¿é€šå—éƒ½éœ€è¦ 111 çš„ä»£ä»·ï¼Œå› æ­¤è™šç‚¹å‘è¿é€šå—å†…æ‰€æœ‰ç‚¹è¿æƒå€¼ä¸º 111 çš„è¾¹ã€‚å¹¶æŸ¥é›†åŠ  01 BFS å°±å¯ä»¥å®Œæˆè¿™ä¸ªè¿‡ç¨‹ï¼Œåº”è¯¥æ˜¯ O(mlogâ¡m)O(m\\log m)O(mlogm) çš„ã€‚ä»£ç ã€‚ D. 3äººã§ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ  Portal. è€ƒè™‘æ„é€ åŒå°„ï¼Œæ¯ä¸€ä¸ªæ–¹æ¡ˆå¯ä»¥æ˜ å°„åˆ°ä¸€ä¸ªé•¿åº¦ä¸º mmm çš„åºåˆ—ï¼Œè¿™ä¸ªåºåˆ—å½“ä¸­æœ‰ n1n_1n1â€‹ ä¸ª 111ï¼Œä¸”ç¬¬ mmm ä½å¿…å®šæ˜¯ 111ã€‚ æšä¸¾åºåˆ—ä¸­ä¸æ˜¯ 111 çš„ä¸ªæ•° kkkï¼Œè´¡çŒ®ç³»æ•°ä¸º 3n2+n3âˆ’k3^{n_2+n_3-k}3n2â€‹+n3â€‹âˆ’kï¼Œé‚£ä¹ˆç­”æ¡ˆä¸ºï¼š (k+n1âˆ’1n1âˆ’1)âˆ‘kâˆ’n3â‰¤iâ‰¤n2(ki)\\binom{k+n_1-1}{n_1-1}\\sum_{k-n_3\\le i\\le n_2} \\binom k i (n1â€‹âˆ’1k+n1â€‹âˆ’1â€‹)kâˆ’n3â€‹â‰¤iâ‰¤n2â€‹âˆ‘â€‹(ikâ€‹) åé¢çš„ä¸œè¥¿ä¸å¯èƒ½ç›´æ¥è®¡ç®—ï¼Œè€ƒè™‘å¢é‡æ³•ç»´æŠ¤ï¼š S(k)=âˆ‘kâˆ’n3â‰¤iâ‰¤n2(ki)=âˆ‘kâˆ’n3â‰¤iâ‰¤n2(kâˆ’1i)+(kâˆ’1iâˆ’1)=âˆ‘kâˆ’n3â‰¤iâ‰¤n2(kâˆ’1i)+âˆ‘kâˆ’1âˆ’n3â‰¤iâ‰¤n2âˆ’1(kâˆ’1i)=S(kâˆ’1)âˆ’(kâˆ’1kâˆ’n3âˆ’1)+S(kâˆ’1)âˆ’(kâˆ’1n2)\\begin{aligned} S(k)&amp;=\\sum_{k-n_3\\le i\\le n_2} \\binom k i\\\\ &amp;=\\sum_{k-n_3\\le i\\le n_2} \\binom{k-1}{i}+\\binom{k-1}{i-1}\\\\ &amp;=\\sum_{k-n_3\\le i\\le n_2} \\binom{k-1}{i}+\\sum_{k-1-n_3\\le i\\le n_2-1} \\binom{k-1}{i}\\\\ &amp;=S(k-1)-\\binom{k-1}{k-n_3-1}+S(k-1)-\\binom{k-1}{n_2} \\end{aligned} S(k)â€‹=kâˆ’n3â€‹â‰¤iâ‰¤n2â€‹âˆ‘â€‹(ikâ€‹)=kâˆ’n3â€‹â‰¤iâ‰¤n2â€‹âˆ‘â€‹(ikâˆ’1â€‹)+(iâˆ’1kâˆ’1â€‹)=kâˆ’n3â€‹â‰¤iâ‰¤n2â€‹âˆ‘â€‹(ikâˆ’1â€‹)+kâˆ’1âˆ’n3â€‹â‰¤iâ‰¤n2â€‹âˆ’1âˆ‘â€‹(ikâˆ’1â€‹)=S(kâˆ’1)âˆ’(kâˆ’n3â€‹âˆ’1kâˆ’1â€‹)+S(kâˆ’1)âˆ’(n2â€‹kâˆ’1â€‹)â€‹ ç„¶åå°±å¯ä»¥ç›´æ¥è®¡ç®—äº†ï¼Œä»£ç ã€‚ PART III æ¥æºæ˜¯ 2015 é›†è®­é˜Ÿä½œä¸šï¼Œå®é™…ä¸Šå°±æ˜¯è¿œå¤æ—¶æœŸ CF é¢˜ã€‚ ç¬¬ä¸€ç»„ å‘œå‘œå‘œã€‚ [CF293B] Distinct Paths Portal. è¦æ±‚æ‰€æœ‰è·¯å¾„ä¸Šçš„é¢œè‰²éƒ½ä¸ç›¸åŒï¼Œè·¯å¾„é•¿åº¦æœ€å¤§ä¸º kkkï¼Œè€Œ kkk æœ€å¤§åªæœ‰ 101010ï¼Œæ‰€ä»¥è¿™å®é™…ä¸Šæ˜¯ä¸ªå¤§æš´åŠ›é¢˜ã€‚ è€ƒè™‘æšä¸¾æ‰€æœ‰æ²¡æ¶‚è‰²çš„æ ¼å­çš„é¢œè‰²ï¼Œå¹¶çŠ¶å‹ç»è¿‡çš„è·¯ä¸Šçš„é¢œè‰²ã€‚ä½†æ˜¯è¿™æ ·çŠ¶æ€æ•°å¹²åˆ°äº† O((nm)k)O((nm)^k)O((nm)k) çš„ç­‰çº§ã€‚ æƒ³ä¸€æƒ³ä¸ºä»€ä¹ˆä¼šç®—è¿™ä¹ˆå¤šã€‚å› ä¸ºï¼Œæˆ‘ä»¬è®¡ç®—äº†å¾ˆå¤šæ— ç”¨çŠ¶æ€ï¼æ‰€ä»¥ï¼š å¦‚æœè¿˜å‰©çš„é¢œè‰²å·²ç»ä¸èƒ½å¤Ÿå¡«æ»¡æ¥ä¸‹æ¥çš„è·¯å¾„ï¼Œé‚£ä¹ˆç›´æ¥å†è§ã€‚ å¦‚æœå½“å‰é¢œè‰²æ˜¯å…¨å±€ä¸­å”¯ä¸€å¡«çš„ï¼Œé‚£ä¹ˆå¡«å…¶å®ƒå…¨å±€ä¹Ÿæ²¡æœ‰å‡ºç°çš„é¢œè‰²æ˜¯ç­‰æ•ˆçš„ï¼Œåªéœ€è¦ç®—ä¸€æ¬¡å°±å¯ä»¥äº†ã€‚ ä»£ç ã€‚ * [CF325E] The Red Button Portal. çœŸçš„æŒºå¦™çš„ã€‚ è¿™æ˜¯ä¸ªä»€ä¹ˆï¼Ÿä¸çŸ¥é“ã€‚å…ˆæ‰“è¡¨æ‰¾è§„å¾‹ï¼Œç„¶åå‘ç° nnn ä¸ºå¥‡æ•°æ—¶æ— è§£ã€‚ ç„¶åå‘¢ï¼Ÿä»¥ä¸‹æ˜¯ nnn ä¸ºå¶æ•°æ—¶æš´åŠ›è·‘å‡ºçš„ç­”æ¡ˆï¼š 0 1 0 0 1 3 2 0 0 1 2 5 4 3 0 0 1 2 5 3 7 6 4 0 0 1 2 4 9 8 6 3 7 5 0 èƒ½çœ‹å‡ºä»€ä¹ˆå—ï¼Ÿå¥½åƒä¸èƒ½ï¼Œé‚£å†ä»å›¾ä¸Šå‡ºå‘çœ‹çœ‹èƒ½ä¸èƒ½å‘ç°ç‚¹ä»€ä¹ˆã€‚ æ¯ä¸ªç‚¹çš„å‡ºåº¦å‡ä¸º 222ï¼Œè¦æ˜¯ 111 æˆ‘ç›´æ¥æ¬§æ‹‰è·¯ï¼è¯¶å¯ä¸å¯ä»¥é€šè¿‡ç‰¹æ®Šé™åˆ¶ææˆ 111 å‘¢ï¼Ÿè¿˜çœŸèƒ½ã€‚ æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ›´å¥½çš„ä»£æ•°å½¢å¼æ¥åˆ»ç”»æ¯ä¸ªç‚¹çš„å‡ºè¾¹ã€‚æˆ‘ä»¬æœ‰ï¼š iÃ—2â‰¡(i+n2)Ã—2(modn)iÃ—2+1â‰¡(i+n2)Ã—2+1(modn)\\begin{aligned} i\\times 2\\equiv (i+\\frac n 2)\\times 2 \\pmod n \\\\ i\\times 2 + 1\\equiv (i+\\frac n 2)\\times 2 + 1 \\pmod n \\end{aligned} iÃ—2â‰¡(i+2nâ€‹)Ã—2(modn)iÃ—2+1â‰¡(i+2nâ€‹)Ã—2+1(modn)â€‹ ä¹Ÿå°±æ˜¯è¯´ iii å’Œ i+n2i+\\frac n 2i+2nâ€‹ æ‰€è¿çš„è¾¹åº”è¯¥æ˜¯åŒä¸€ä¸ªä¸œè¥¿ã€‚é‚£è¿™å¥½åŠäº†ï¼Œæƒ³è¦æœ‰ç­”æ¡ˆå¿…é¡»ä¸€äººåˆ†ä¸€ä¸ªï¼Œé‚£å°±éšä¾¿ã€‚ ç„¶åç­”æ¡ˆæˆäº†ä»€ä¹ˆçŠ¶ç‰©ï¼Ÿè‹¥å¹²ä¸ªç¯ï¼æˆ‘ä»¬éœ€è¦åˆå¹¶å®ƒä»¬ã€‚ å¦‚æœå›¾ä¸Šæœ‰å¤šä¸ªç¯ï¼Œé‚£ä¹ˆå¿…å®šæœ‰ä¸€å¯¹ç­‰æ•ˆç‚¹ä¸åœ¨åŒä¸€ä¸ªç¯ä¸­ï¼Œäº¤æ¢å®ƒä»¬åˆ†çš„è¾¹å³å¯åˆå¹¶ç¯ã€‚ æˆ‘ä»¬å·²ç»é€šè¿‡æš´åŠ›éªŒè¯äº† nnn ä¸ºå¶æ•°æ—¶ä¸€å®šæœ‰è§£ï¼Œæ‰€ä»¥è¿™æ ·ä¸€å®šå¯ä»¥åˆå¹¶æ‰€æœ‰çš„ç¯ï¼ˆå¦åˆ™æ²¡å¾—å¯èµ°äº†ï¼‰ã€‚ä»£ç ã€‚ [CF335D] Rectangles and Square Portal. æ‹¼æˆçš„æ­£æ–¹å½¢çš„å³ä¸Šè§’ä¸€å®šæ˜¯ä¸€ä¸ªçŸ©å½¢çš„å³ä¸Šè§’ï¼Œæ­£æ–¹å½¢çš„å·¦ä¸‹è§’ä¸€å®šæ˜¯ä¸€ä¸ªçŸ©å½¢çš„å³ä¸‹è§’ã€‚ç„¶åæ€ä¹ˆé™åˆ¶ï¼Ÿ æ³¨æ„åˆ°æ‰€æœ‰çŸ©å½¢éƒ½ä¸ç›¸äº¤ã€‚è¿™æ ·æˆ‘ä»¬å¯ä»¥ç”¨ä¸€äº›å‰ç¼€å’Œçš„æ–¹å¼ç›´æ¥åˆ¤æ–­ä¸€äº›å†…å®¹ã€‚é¦–å…ˆä¸€å®šèƒ½é“ºæ»¡ï¼Œå…¶æ¬¡æ­£æ–¹å½¢çš„è¾¹ç•Œä¸€å®šç”±çŸ©å½¢çš„è¾¹ç•Œæ„æˆã€‚è¿™äº›éƒ½å¾ˆå¥½ä½¿ç”¨äºŒç»´å‰ç¼€å’Œç»´æŠ¤ã€‚ æšä¸¾æ­£æ–¹å½¢çš„å³ä¸Šè§’å’Œåœ¨è¿™æ¡æ–œçº¿ä¸Šçš„åˆæ³•å·¦ä¸‹è§’ï¼Œæ—¶é—´å¤æ‚åº¦ O(k2+n)O(k^2+n)O(k2+n)ã€‚ä»£ç ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"NOI ä¸€è½®å¤ä¹  Iï¼šä¼˜åŒ–æŠ€å·§","slug":"notes/NOI å¤ä¹ /noi-1-1","date":"2023-04-30T00:00:00.000Z","updated":"2023-11-04T00:00:00.000Z","comments":true,"path":"48d03b22/","link":"","permalink":"https://james1badcreeper.github.io/48d03b22/","excerpt":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬ä¸€ç¯‡ï¼ŒåŒ…æ‹¬æ— æ³•å½’æˆå¤§ç±»çš„æ‚é¡¹ç®—æ³•ã€‚","text":"æœ¬æ–‡æ˜¯ NOI ä¸€è½®å¤ä¹ çš„ç¬¬ä¸€ç¯‡ï¼ŒåŒ…æ‹¬æ— æ³•å½’æˆå¤§ç±»çš„æ‚é¡¹ç®—æ³•ã€‚ æ›´æ–°æ—¥å¿— 2023/11/04æ›´æ–°äº†æ›¼å“ˆé¡¿è·ç¦»å’Œåˆ‡æ¯”é›ªå¤«è·ç¦»çš„è½¬åŒ–ã€‚2023/10/25æ–‡ç« å¤§è‡´å®Œæˆã€‚ ä¸åŒäºå¸¸è§„çš„å­¦ä¹ ç¬”è®°ï¼Œè¿™ä¸€éƒ¨åˆ†çš„æ–‡ç« ä¼šç•¥æ˜¾ç®€ç•¥ï¼Œé‡ç‚¹åˆ»ç”»çŸ¥è¯†ä¹‹é—´çš„ç»“æ„ä¸é€»è¾‘ï¼Œå¹¶ä¿ç•™ç»å…¸ä¾‹é¢˜ï¼Œå¢åŠ å¤§é‡æ‚é¢˜ï¼Œä¸”é¢˜ç›®å®æ—¶æ›´æ–°ã€‚ äºŒåˆ†ä¸å€å¢ ä¸¤è€…çš„æœ¬è´¨å‡åŸºäºå•è°ƒæ€§ï¼Œå¯»æ‰¾é¢˜ç›®ä¸­å…·æœ‰å•è°ƒæ€§çš„å‡½æ•°å…³ç³»ï¼Œç„¶åæ–½å±•äºŒåˆ†æˆ–è€…å€å¢ã€‚äºŒåˆ†ç­”æ¡ˆå¯ä»¥ç”¨æ¥è§£å†³åˆ†æ•°è§„åˆ’é—®é¢˜ï¼Œä¸‰åˆ†æ³•å¯ä»¥æ±‚è§£å•å³°/è°·å‡½æ•°ã€‚åŒæ—¶ï¼ŒäºŒåˆ†ä¸Šç•Œä¸ç¡®å®šçš„å†…å®¹çš„æœ€ä½³æ–¹å¼æ˜¯å€å¢ï¼Œé€šè¿‡å…ˆå€å¢åˆ°ä¸Šç•Œï¼Œå†å€å¢ç­”æ¡ˆæ¥è§£å†³ã€‚ ST è¡¨ ST è¡¨ä½¿ç”¨å€å¢ç»“æ„æ¥å®ç°ï¼Œæ”¯æŒåœ¨æœ«å°¾æ’å…¥ä¸€ä¸ªæ•°ã€‚å¤§æ¦‚é•¿è¿™æ ·ï¼š f[0][n] = a[n]; for (int j = 1; 1 &lt;&lt; j &lt;= n; ++j) f[j][n - (1 &lt;&lt; j) + 1] = max(f[j - 1][n - (1 &lt;&lt; j) + 1], f[j - 1][n - (1 &lt;&lt; j - 1) + 1]); wqs äºŒåˆ† å­¦åå¸¦æƒäºŒåˆ†ã€‚å¸¸ç”¨äº 2D /1D çš„ DPï¼ŒçŠ¶æ€çš„å…¶ä¸­ä¸€ç»´æ˜¯ç‰©å“ä¸ªæ•°ã€‚è¿™æ˜¯å®ƒçš„æ˜æ˜¾æ ‡å¿—ï¼Œå› æ­¤å®ƒæ¯”è¾ƒå¥—è·¯ã€‚fif_ifiâ€‹ è¡¨ç¤ºæ°å¥½ï¼ˆæœ€å¤š/è‡³å°‘ï¼‰é€‰å– iii ä¸ªç‰©å“æ—¶çš„ç­”æ¡ˆï¼Œå¦‚æœ fff æ˜¯å‡¸å‡½æ•°é‚£ä¹ˆåˆ™å¯ä»¥ä½¿ç”¨ wqsã€‚æˆ‘ä»¬å¯ä»¥çŒœæµ‹ O(nk)O(nk)O(nk) è¿‡ä¸å»å°±æ˜¯å‡¸çš„ï¼Œæˆ–è€…ä¹Ÿå¯ä»¥æ‰“è¡¨ã€‚ ç”±äº fff æ˜¯å‡¸çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é€‰æ‹©äºŒåˆ†æ–œç‡ï¼Œä»¥æ­¤è®¡ç®—å‡ºå®ƒçš„åˆ‡çº¿ã€‚æœ‰æ—¶å®ƒèƒ½ç›´æ¥ç”¨ï¼Œæœ‰æ—¶å¯ä»¥å¯¹ DP è¿›è¡Œé™ç»´ï¼Œæœ‰æ—¶å’Œæ–œç‡ä¼˜åŒ–ç­‰å†…å®¹ä¸€èµ·å‡ºç°ã€‚ å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬ç”»å‡ºæ‰€æœ‰ç‚¹ (i,f(i))(i,f(i))(i,f(i))ï¼Œå‡è®¾å®ƒä»¬æ„æˆä¸€ä¸ªä¸Šå‡¸å£³ã€‚äºŒåˆ†æ–œç‡ kkkï¼Œå‘ç°éšç€ kkk çš„å‡å°ï¼Œç›´çº¿çš„åˆ‡ç‚¹ä¼šè¶Šæ¥è¶Šé å³ã€‚ å› æ­¤äºŒåˆ† kkk ç›´åˆ°æ¨ªåæ ‡åˆ‡åˆ°æˆ‘ä»¬æƒ³è¦çš„ä½ç½®ï¼ˆæ¯”å¦‚æ°å¥½é€‰æ‹© mmm ä¸ªæ•°ï¼‰ï¼Œé‚£ä¹ˆæ­¤æ—¶çš„çºµåæ ‡å°±æ˜¯ç­”æ¡ˆäº†ã€‚ å¦‚ä½•æ±‚å‡ºåˆ‡ç‚¹ï¼Ÿæˆ‘ä»¬å¸Œæœ›è¿™ä¸ªåˆ‡ç‚¹çš„ yyy åæ ‡æœ€å¤§ï¼Œä¹Ÿå°±æ˜¯åœ¨ yyy è½´ä¸Šçš„æˆªè·æœ€å¤§ã€‚è®¾æˆªè·ä¸º g(x)g(x)g(x)ï¼Œé‚£ä¹ˆåˆ‡ç‚¹ (x,f(x))(x,f(x))(x,f(x)) åœ¨ yyy è½´ä¸Šçš„æˆªè·å°±æ˜¯ g(x)=f(x)âˆ’kxg(x)=f(x)-kxg(x)=f(x)âˆ’kxã€‚é—®é¢˜å°±æ˜¯å¦‚ä½•æ±‚å‡º g(x)g(x)g(x) çš„å€¼äº†ã€‚ è€ƒè™‘ g(x)g(x)g(x) çš„æ„ä¹‰ï¼Œç›¸å½“äºé’¦å®šçš„ xxx ä¸ªç‰©å“çš„ä»£ä»·éƒ½æ¯”åŸæ¥å°‘ kkkï¼Œg(x)g(x)g(x) ç›¸å½“äºæ¯ä¸ªç‰©å“ä»£ä»·å‡ kkk ä¹‹åçš„æœ€ä¼˜è§£ã€‚ l,rl,rl,r å¦‚ä½•è°ƒæ•´ï¼Ÿè¦é€¼è¿‘ (m,f(m))(m,f(m))(m,f(m)) å¦‚æœæ­¤æ—¶åˆ‡ç‚¹ (x,f(x))(x,f(x))(x,f(x)) æ»¡è¶³ x&lt;mx&lt;mx&lt;m æ—¶ï¼Œé‚£ä¹ˆåº”è¯¥å°†æ–œç‡å‡å°ï¼Œæ‰èƒ½è®©åˆ‡ç‚¹å³ç§»ã€‚ ä¸‹å‡¸å£³å¤§è‡´æ˜¯ä¸€æ ·çš„ã€‚ [å›½å®¶é›†è®­é˜Ÿ] Tree Iã€‚ç»™å®šä¸€ä¸ªæ— å‘è¿é€šå›¾ï¼Œæ±‚ä¸€æ£µæ°å¥½æœ‰ kkk æ¡ç™½è¾¹çš„æœ€å°ç”Ÿæˆæ ‘ã€‚nâ‰¤5Ã—104,mâ‰¤105,wâ‰¤100n\\le 5\\times 10^4,m\\le 10^5,w\\le 100nâ‰¤5Ã—104,mâ‰¤105,wâ‰¤100ã€‚ è®¾ç™½è¾¹æ•°é‡ä¸º kkk çš„æœ€å°ç”Ÿæˆæ ‘æ˜¯ f(k)f(k)f(k)ï¼Œé‚£ä¹ˆ fff æ˜¯ä¸€ä¸ªä¸‹å‡¸å‡½æ•°ï¼ˆå…¶å®æŒºæ˜¾ç„¶çš„ï¼‰ã€‚ç›´æ¥ wqs å³å¯ã€‚ int n, m, need; struct edge &#123; int u, v, w, c; bool operator&lt; (const edge &amp;a) const &#123; if (w != a.w) return w &lt; a.w; return c &lt; a.c; &#125; &#125; a[100005]; int fa[50005], res; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; bool check(int x) &#123; for (int i = 1; i &lt;= m; ++i) if (a[i].c == 0) a[i].w -= x; sort(a + 1, a + m + 1); for (int i = 1; i &lt;= n; ++i) fa[i] = i; int wc = 0; res = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = find(a[i].u), v = find(a[i].v); if (u == v) continue; fa[u] = v; res += a[i].w; wc += (a[i].c == 0); &#125; for (int i = 1; i &lt;= m; ++i) if (a[i].c == 0) a[i].w += x; return wc >= need; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m >> need; for (int i = 1; i &lt;= m; ++i) cin >> a[i].u >> a[i].v >> a[i].w >> a[i].c, ++a[i].u, ++a[i].v; int L = -500, R = 500, ans; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) ans = res + need * mid, R = mid; else L = mid; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; ä¾‹é¢˜ è™½ç„¶éƒ½æ˜¯å¾ˆç®€å•çš„æ€æƒ³ï¼Œä½†æ˜¯ä¸¤è€…èƒ½è§£å†³çš„é—®é¢˜ä¸å°‘ï¼Œè€Œä¸”å„æœ‰ç‰¹ç‚¹ã€‚ * [CF1661F] Teleporters Portal. å¯ä»¥å°†åŸé—®é¢˜åˆ’åˆ†æˆå‡ æ®µï¼Œç„¶åå¯¹äºæ¯ä¸€æ®µæ”¾ç½®ä¼ é€å™¨çš„è¯åˆ†çš„çº¦å‡åŒ€è¶Šå¥½ï¼Œå…¨å±€çš„æœ€å°ä¸¤ç›¸é‚»ä¼ é€æœºè·ç¦»åº”è¯¥æ˜¯ä¸€ä¸ªï¼ˆå°½å¯èƒ½æ»¡è¶³å¹³å‡ï¼‰ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ f(x,k)f(x,k)f(x,k) æ¥è¡¨ç¤º 0â†’x0\\rightarrow x0â†’x ä¸­é¢å¤–æ’å…¥ kkk ä¸ªçš„æœ€å°ä»£ä»·ï¼Œæ˜¾ç„¶æ˜¯å¥½æ±‚çš„ã€‚ ç›´æ¥äºŒåˆ†éœ€è¦å®‰è£…çš„ä¼ é€æœºæ•°é‡ï¼Ÿæˆ‘ä»¬å¥½åƒæ²¡æœ‰åŠæ³• checkï¼ŒåªçŸ¥é“æœ€å¤šä¼ é€æœºæ•°é‡çš„è¯æ²¡æœ‰ä¸€ä¸ªåˆé€‚çš„è´ªå¿ƒç­–ç•¥ã€‚æˆ‘ä»¬å¯¹å¦ä¸€ä¸ªæ¡ä»¶â€”â€”æ€»èŠ±è´¹è¿›è¡Œè€ƒè™‘ã€‚å› ä¸ºèŠ±è´¹è¶Šå¤§ç›´æ¥æ„å‘³ç€ä¼ é€æœºæ•°é‡è¶Šå°‘ã€‚ æ³¨æ„åˆ° f(x,kâˆ’1)âˆ’f(x,k)f(x,k-1)-f(x,k)f(x,kâˆ’1)âˆ’f(x,k) éšç€ kkk çš„å¢å¤§å•è°ƒä¸å¢ï¼Œè¿™æ ·å¯ä»¥åœ¨å¤–å±‚äºŒåˆ†å…¶å€¼ vvv æ¥ä»£è¡¨ä¸€ä¸ªæ®µå†…çš„æœ€å°ä¼ é€æœºè·ç¦»ï¼ˆç±»ä¼¼ wqs çš„æ€æƒ³ï¼‰ï¼Œæ‰¾å‡ºä¸€ä¸ª f(x,kâˆ’1)âˆ’f(x,k)â‰¥vf(x,k-1)-f(x,k)\\ge vf(x,kâˆ’1)âˆ’f(x,k)â‰¥v çš„æœ€å¤§ kkkï¼Œè€Œ kkk è¶Šå¤§èŠ±è´¹è¶Šå°ï¼Œç›´æ¥åˆ©ç”¨ kkk æ¥è¿›è¡Œè´ªå¿ƒæ±‚å‡ºæ¯ä¸€æ®µçš„æœ€å°ä»£ä»·ï¼Œä¸ mmm æ¯”è¾ƒæ¥ç¡®å®šäºŒåˆ†çš„ç­”æ¡ˆã€‚ è®¾äºŒåˆ†å‡ºæ¥çš„ç­”æ¡ˆæ˜¯ kkkï¼Œé€‰å®Œä¹‹å mmm çš„å€¼è¿˜æœ‰å‰©ä½™ï¼Œæˆ‘ä»¬å°½å¯èƒ½å¤šçš„å€¼é€‰æ‹© k+1k+1k+1 æ¥æ¦¨å¹² mmm çš„å‰©ä½™ä»·å€¼ã€‚ æ—¶é—´å¤æ‚åº¦ O(nlogâ¡2V)O(n\\log^2 V)O(nlog2V)ï¼Œä»£ç ã€‚ æˆ‘ä»¬å‘ç°ï¼ŒäºŒåˆ†ç­”æ¡ˆä¸ä»…éœ€è¦æœ‰å•è°ƒæ€§ï¼Œè€Œä¸”éœ€è¦æœ‰ä¸€ä¸ªè´ªå¿ƒç­–ç•¥æ¥ checkï¼Œå¹¶ä¸ä¸€å®šæ˜¯ç›´æ¥äºŒåˆ†æœ€ç»ˆçš„ç­”æ¡ˆã€‚å½“å‘ç°æ— æ³• check æ—¶å¯ä»¥æ‰¾æ‰¾æˆ‘ä»¬ç¼ºå°‘äº†ä»€ä¹ˆå¯¼è‡´æ— æ³•è´ªå¿ƒï¼Œç„¶åæ”¹ä¸ºäºŒåˆ†è¿™ä¸ªç¼ºå°‘çš„ä¸œè¥¿ã€‚ [ZJOI2018] èƒ– Portal. ä» 000 å·ç‚¹åˆ°è¾¾æŸä¸€ä¸ªç‚¹åï¼Œå¯ä»¥è¢«æ›´æ–°çš„ç­æœ›å¡”æ˜¾ç„¶æ˜¯ä¸€æ®µè¿ç»­çš„åŒºé—´ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åˆ†åˆ«å¯¹å·¦å³ç«¯ç‚¹è¿›è¡ŒäºŒåˆ†ã€‚ è®¾è¦ä» ppp æ›´æ–°ï¼Œè¿™æ¡è·¯çš„è·ç¦»ä¸º lllï¼Œåˆ°è¾¾ç¬¬ xxx ä¸ªç‚¹ï¼Œé‚£ä¹ˆä»¤ d=âˆ£lâˆ’xâˆ£d=|l-x|d=âˆ£lâˆ’xâˆ£ï¼Œåœ¨ [xâˆ’d,x+d][x-d,x+d][xâˆ’d,x+d] å½“ä¸­ä¸åº”è¯¥å­˜åœ¨è·ç¦»å°äº ppp æ—¶è·ç¦»çš„ç‚¹ã€‚é¢„å¤„ç†å‡ºå›¾ä¸Šè·ç¦»çš„å‰ç¼€å’Œ disdisdisï¼Œè·ç¦»çš„æœ€å°å€¼è¦åˆ†åœ¨ xxx çš„å·¦å³è®¨è®ºï¼Œåœ¨ xxx å·¦è¾¹æ—¶æ˜¯ disx+(lâˆ’disp)dis_x+(l-dis_p)disxâ€‹+(lâˆ’dispâ€‹)ï¼Œå³è¾¹æ—¶æ˜¯ âˆ’disx+(l+disp)-dis_x+(l+dis_p)âˆ’disxâ€‹+(l+dispâ€‹)ï¼Œè¯¢é—®å‰ ST è¡¨é¢„å¤„ç†ä¸¤ä¸ªä¿¡æ¯å³å¯æ±‚å‡ºè·ç¦»çš„æœ€å°å€¼ï¼ˆå»ºç«‹å¤§å°ä¸º KKK çš„ ST è¡¨ï¼Œè¯¢é—®çš„æ—¶å€™ç›´æ¥äºŒåˆ†å‡ºå·¦å³ç«¯ç‚¹çš„ä½ç½®ï¼‰ã€‚ æ³¨æ„è·ç¦»ç›¸ç­‰æ—¶æ›´æ–°é¡ºåºçš„é—®é¢˜ï¼ŒäºŒåˆ†å³ç«¯ç‚¹æ—¶è¦å¯¹ x+dx+dx+d çš„ä½ç½®åšä¸€ä¸ªå•ç‹¬çš„è®¨è®ºã€‚ä»£ç ã€‚ ** [CF1764G] Doremyâ€™s Perfect DS Class è¿™æ˜¯ä¸€é“éå¸¸ç²¾å½©çš„é¢˜ç›®ã€‚G1ï¼ŒG2ï¼ŒG3ã€‚ç»™å®šä¸€ä¸ª 1âˆ¼n1\\sim n1âˆ¼n çš„æ’åˆ— pppï¼ˆnâ‰¤1024n \\le 1024nâ‰¤1024ï¼Œæ³¨æ„ 210=10242^{10}=1024210=1024ï¼‰ï¼Œæ¯æ¬¡ä½ å¯ä»¥è¯¢é—® l,r,kl,r,kl,r,kï¼Œäº¤äº’åº“ä¼šè¿”å› âŒŠplkâŒ‹,âŒŠpl+1kâŒ‹,â‹¯ ,âŒŠprkâŒ‹\\left\\lfloor\\cfrac{p_l}k\\right\\rfloor,\\left\\lfloor\\cfrac{p_{l+1}}k\\right\\rfloor,\\cdots,\\left\\lfloor\\cfrac{p_r}k\\right\\rfloorâŒŠkplâ€‹â€‹âŒ‹,âŒŠkpl+1â€‹â€‹âŒ‹,â‹¯,âŒŠkprâ€‹â€‹âŒ‹ ä¸­ä¸åŒæ•°çš„ä¸ªæ•°ï¼Œéœ€è¦æ‰¾åˆ° 111 çš„ä½ç½®ã€‚äº¤äº’æ¬¡æ•°åˆ†åˆ«é™åˆ¶åœ¨ 30,25,2030,25,2030,25,20 æ¬¡ã€‚ è¯¢é—®èƒ½å‘Šè¯‰æˆ‘ä»¬ä»€ä¹ˆï¼Ÿå¥½å¥‡æ€ªå•Šï¼Œä¸çŸ¥é“ã€‚å°è¯•ä»ç»™å®šçš„ kkk å€¼å¼€å§‹åˆ†æã€‚k=1k=1k=1 æ²¡ä»€ä¹ˆæ„ä¹‰ï¼Œç„¶åå°è¯•ä»ç‰¹æ®Šçš„ï¼Œæ¯”å¦‚ k=2,nk=2,nk=2,n å¼€å§‹åˆ†æã€‚k=nk=nk=n æ¯”è¾ƒå¥½è¯´ï¼Œåªæœ‰ nnn å¯ä»¥è¢«è®°å…¥ç­”æ¡ˆï¼Œå¯ä»¥æ ¹æ®æ­¤æ‰¾å‡º nnn çš„ä½ç½®ã€‚k=2k=2k=2 åˆ™å¯ä»¥å°†æ•°åˆ†ä¸ºä¸¤ç»„ï¼Œåœ¨ nnn ä¸ºå¥‡æ•°æ—¶åªæœ‰ 111 æ˜¯å•ç‹¬ä¸€ç»„ï¼Œnnn ä¸ºå¶æ•°æ—¶åªæœ‰ 1,n1,n1,n æ˜¯å•ç‹¬ä¸€ç»„ã€‚ ä»åˆ«çš„åœ°æ–¹å†æƒ³ä¸€æƒ³ï¼Œéƒ½è¦æ±‚ logâ¡\\loglog çº§åˆ«çš„è¯¢é—®ï¼Œä¸éš¾æƒ³åˆ°äºŒåˆ†ã€‚è®¾ solve(l, r) ä»£è¡¨ç­”æ¡ˆåœ¨ [l,r][l,r][l,r] çš„ä½ç½®ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ç¡®å®š 111 åœ¨ [l,mid][l,mid][l,mid] è¿˜æ˜¯ [mid+1,r][mid+1,r][mid+1,r] é‡Œã€‚å’¦ï¼Œæ„Ÿè§‰ä¸å¤ªå¯¹ï¼Œä¸æ˜¯ä¸¥æ ¼çš„å­é—®é¢˜ï¼ä½†æ˜¯æˆ‘ä»¬åªéœ€è¦å¯»æ‰¾ç­”æ¡ˆåœ¨å“ªé‡Œï¼Œå› æ­¤åªéœ€è¦åˆ†åˆ«ç­”æ¡ˆåœ¨ [1,mid][1,mid][1,mid] è¿˜æ˜¯ [mid+1,n][mid+1,n][mid+1,n] å°±å¥½äº†ã€‚ é€‰æ‹©ä» k=2k=2k=2 å…¥æ‰‹ï¼Œx,yx,yx,y åˆ†ä¸ºä¸€ç»„ä»…å½“å®ƒä»¬é™¤ä»¥äºŒä¸‹å–æ•´åçš„å€¼ç›¸ç­‰ã€‚æˆ‘ä»¬å¯ä»¥æ±‚å‡ºä¸¤ä¸ªåŒºé—´ä¸­åœ¨è‡ªå·±åŒºé—´å†…æ²¡æœ‰åŒ¹é…çš„æ•°çš„æ•°é‡ï¼Œç„¶åè¿™ä¸ªæ•°é‡å¤§çš„ï¼Œç­”æ¡ˆå°±åœ¨é‚£é‡Œï¼ˆå› ä¸ºå‰©ä¸‹çš„æ¯æœ‰ä¸€ä¸ªéƒ½æ˜¯æˆå¯¹çš„ï¼‰ã€‚ nnn æ˜¯å¶æ•°æ€ä¹ˆåŠå‘¢ï¼Ÿæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ° nnn å°±è¡Œï¼Œä¸éš¾å‘ç° k=nk=nk=n å¯ä»¥å¾ˆå¥½çš„å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚å½“ä¸¤ä¸ªåŒºé—´çš„å€¼ç›¸ç­‰æ—¶ï¼Œè¯´æ˜ 1,n1,n1,n å„å ä¸€ä¸ªï¼Œæˆ‘ä»¬ä»¤ k=nk=nk=nï¼Œè¯¢é—®å…¶ä¸­ä¸€ä¸ªï¼Œçœ‹ nnn æ˜¯å¦åœ¨å…¶ä¸­ã€‚æ‰¾åˆ° nnn çš„ä½ç½®ä¹‹åå‘ç°ä¹‹åçš„é€’å½’ä¸ä¼šå—åˆ°å½±å“ï¼ˆå¦‚æœ pn&gt;midp_n&gt; midpnâ€‹&gt;midï¼Œæˆ‘ä»¬ä¼šé€’å½’åˆ° [l,mid][l,mid][l,mid]ï¼Œå¿…å®šæœ‰ pn&gt;midâ€²p_n&gt;mid&#x27;pnâ€‹&gt;midâ€²ï¼‰ã€‚ è¿™ä¸ªåšæ³•å¯ä»¥é€šè¿‡ G2ï¼Œä»£ç ã€‚æƒ³è¿‡æ‰ G3ï¼Œæˆ‘ä»¬éœ€è¦æƒ³æ–¹æ³•æ€æ‰é‚£ä¸€æ¬¡å¤šä½™çš„è¯¢é—®ã€‚ æ€ä¹ˆæ€ï¼Ÿå¯¹äº râˆ’l+1=2r-l+1=2râˆ’l+1=2 çš„æƒ…å†µï¼Œä½¿ç”¨ä¸¤æ¬¡è¯¢é—®æœ‰ç‚¹æ‰¯çš®ï¼Œæˆ‘ä»¬çœ‹èƒ½ä¸èƒ½åªç”¨ä¸€æ¬¡è¯¢é—®æ€æ‰å®ƒã€‚æ ¸å¿ƒæ€æƒ³æ˜¯ï¼Œå……åˆ†åˆ©ç”¨æˆ‘ä»¬ä¹‹å‰é—®å‡ºæ¥çš„ä¿¡æ¯ã€‚å½“æˆ‘ä»¬é€’å½’åˆ° [l,r][l,r][l,r] æ—¶ï¼Œæ›¾ä»¤ä¸€ä¸ª mid=lâˆ’1mid=l-1mid=lâˆ’1ï¼Œä¹Ÿä»¤äº†ä¸€ä¸ª mid=rmid=rmid=rï¼Œå› æ­¤æˆ‘ä»¬çŸ¥é“ Q(1,lâˆ’1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l-1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,lâˆ’1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2) çš„ç­”æ¡ˆã€‚ç°åœ¨ l,rl,rl,r ä¸­ä¸€ä¸ªæ˜¯ 111ï¼Œä¸€ä¸ªæ˜¯å’Œå…¶ä»–æ•°èƒ½åŒ¹é…ä¸Šçš„æŸä¸ªå¥‡æ€ªçš„ä¸œè¥¿ï¼Œå—ï¼Ÿæ³¨æ„ï¼Œå¦ä¸€ä¸ªå¯èƒ½æ˜¯ nnnï¼Œå¦‚æœæˆ‘ä»¬è¿˜æ²¡æœ‰ç¡®å®š nnn çš„ä½ç½®ï¼Œé‚£ä¹ˆé€šè¿‡è¯¢é—® Q(r,n,n)Q(r,n,n)Q(r,n,n) æˆ– Q(1,l,n)Q(1,l,n)Q(1,l,n) å°†å…¶åˆ¤æ‰ã€‚ ç°åœ¨å†çœ‹æ€ä¹ˆæ l,rl,rl,r ä¸€ä¸ªæ˜¯ 111ï¼Œå¦ä¸€ä¸ªæ˜¯å¯åŒ¹é…æ•°ã€‚å¯åŒ¹é…æ•°åªèƒ½é…åœ¨ [1,lâˆ’1][1,l-1][1,lâˆ’1] æˆ– [r+1,n][r+1,n][r+1,n]ï¼Œå¦‚æœ Q(1,lâˆ’1,2)+1=Q(1,r,2)Q(1,l-1,2)+1=Q(1,r,2)Q(1,lâˆ’1,2)+1=Q(1,r,2)ï¼Œé‚£ä¹ˆè¯´æ˜å¯åŒ¹é…æ•°çš„åŒ¹é…æ•°æ˜¯å¼€åœ¨ [1,lâˆ’1][1,l-1][1,lâˆ’1] çš„ï¼ˆè¿™ä¸ªæ•°é™¤ä»¥äºŒä¸‹å»æ•´çš„å€¼ä¸ [1,lâˆ’1][1,l-1][1,lâˆ’1] ä¸­çš„æŸä¸ªæ•°æ’äº†ï¼‰ï¼Œå¦åˆ™å¼€åœ¨ [r+1,n][r+1,n][r+1,n]ã€‚ç¡®å®šäº†è¿™ä¸€ç‚¹ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥é”å®š 111 çš„ä½ç½®äº†ï¼ä»¥å¼€åœ¨ [1,lâˆ’1][1,l-1][1,lâˆ’1] ä¸ºä¾‹ï¼Œå¦‚æœ Q(1,lâˆ’1,2)=Q(1,l,2)Q(1,l-1,2)=Q(1,l,2)Q(1,lâˆ’1,2)=Q(1,l,2)ï¼Œè¯´æ˜ lll å¤„å¼€å¯åŒ¹é…æ•°ï¼Œä¸ [1,lâˆ’1][1,l-1][1,lâˆ’1] ä¸­çš„æŸä¸ªæ•°åŒ¹é…ï¼Œ111 å°±å¼€åœ¨ rrr å¤„ã€‚ è¿™æ ·åœ¨ râˆ’l+1=2r-l+1=2râˆ’l+1=2 æ—¶æˆ‘ä»¬åªèŠ±è´¹äº†ä¸€æ¬¡è¯¢é—®ï¼Œå¯ä»¥é€šè¿‡ G3ã€‚ä»£ç ã€‚ * ã€ŒWdoi-2ã€æ­»äº¡ä¹‹åæ„ˆå‘æ„‰æ‚¦ Portal. i+1i+1i+1 ä¸ªå¯çˆ±æ•°è¿ç€ iii ä¸ªéå¯çˆ±æ•°ã€‚è®¾ j(a)j(a)j(a) ä»£è¡¨ aaa æ˜¯å¦ä¸ºå¯çˆ±æ•°ã€‚æ±‚å‡º j(a)=j(a+p)j(a)=j(a+p)j(a)=j(a+p) çš„æœ€å¤§ pppï¼Œj(a+p+1)=j(a+p+q)j(a+p+1)=j(a+p+q)j(a+p+1)=j(a+p+q) çš„æœ€å¤§ qqqï¼Œåˆ™å®¹æ˜“æ ¹æ® p,q,j(a)p,q,j(a)p,q,j(a) è§£å‡º aaaã€‚ å¯¹äºæ±‚è§£ p,qp,qp,qï¼Œè€ƒè™‘å€å¢ã€‚æ³¨æ„å€å¢æ—¶è¦å…ˆè·³ä¸¤ä¸ª 202^020ï¼Œè¿™æ ·ä¿è¯æ¯ä¸€æ¬¡è·³è·ƒçš„é•¿åº¦ä¸å¤§äºä»¥å‰è·³è·ƒçš„é•¿åº¦ï¼Œå› ä¸ºåŒºé—´å¹¶ä¸æ˜¯ä¸¥æ ¼å•è°ƒçš„ï¼Œè¿™æ ·é˜²æ­¢è·³å‡ºåŒºé—´ã€‚ å¯¹äº qqq çš„å€å¢å¹¶ä¸éœ€è¦ä» 000 å¼€å§‹ï¼Œå¯ä»¥å‘ç° pâ‰¤qp\\le qpâ‰¤qï¼Œå› æ­¤å¯ä»¥ç›´æ¥å…ˆè·³ä¸€ä¸ªä¸è¶…è¿‡ pâˆ’1p-1pâˆ’1 çš„æ•°ï¼Œä»£ç ã€‚ [SCOI2016] èŒèŒå“’ Portal. å¹¶æŸ¥é›†ï¼Ÿå¤æ‚åº¦ä¸å¯¹ï¼Œè€ƒè™‘å€å¢å¹¶æŸ¥é›†ã€‚ä½¿ç”¨ç±»ä¼¼äº ST è¡¨çš„ç»“æ„ï¼Œæ“ä½œæ—¶ç›´æ¥æ“ä½œé«˜å±‚èŠ‚ç‚¹çš„å¹¶æŸ¥é›†ï¼Œå¤„ç†å®Œä¹‹åå°†é«˜å±‚å†…å®¹ä¸‹æ”¾ï¼Œè¿™æ ·å¯ä»¥å¾—åˆ°å®Œæ•´çš„ç­”æ¡ˆã€‚ä»£ç ã€‚ * [CF802O] April Foolsâ€™ Problem Portal. å…³äºé¢˜ç›®ä¸ªæ•°çš„æ˜¯ä¸€ä¸ªä¸‹å‡¸å‡½æ•°ï¼Œè€Œä¸”æ–œç‡å•è°ƒä¸é™ï¼Œå¯ä»¥é‡‡ç”¨ wqs äºŒåˆ†ã€‚ å¦‚ä½•è´ªå¿ƒ checkï¼Ÿå¯¹äºæ¯ä¸ª bib_ibiâ€‹ï¼Œæ‰¾åˆ°ä¹‹å‰æ²¡é€‰è¿‡çš„ aja_jajâ€‹ï¼Œå¦‚æœ aj+biâ‰¤0a_j+b_i\\le 0ajâ€‹+biâ€‹â‰¤0 é‚£ä¹ˆé€‰æ‹© aja_jajâ€‹ã€‚è®©å®ƒæ”¯æŒåæ‚”ï¼Œå¯ä»¥é¡¶æ›¿æ‰ä¸€ä¸ª bjb_jbjâ€‹ï¼Œè´¡çŒ®ä¸º biâˆ’bjb_i-b_jbiâ€‹âˆ’bjâ€‹ã€‚ä»£ç ã€‚ åˆ†æ²» åˆ†æ²»æ˜¯å°†å¤æ‚çš„é—®é¢˜æ‹†æˆå¤šä¸ªï¼ˆä¸€èˆ¬æ˜¯ä¸¤ä¸ªï¼‰ç›¸ä¼¼çš„å­é—®é¢˜ï¼Œç›´åˆ°æœ€ååˆ†æˆçš„å­é—®é¢˜å¯ä»¥ç®€å•æ±‚è§£ï¼Œç„¶åé€šè¿‡å­é—®é¢˜çš„ç­”æ¡ˆåˆå¹¶å‡ºå¤§é—®é¢˜çš„ç­”æ¡ˆã€‚ ä»¿ç…§åˆ†æ²»çš„ç»“æ„å¯ä»¥è¡ç”Ÿå‡ºä¸€å¤§å †é™æ€åˆ†æ²»ç®—æ³•ã€‚ æ™®é€šåˆ†æ²» å¹³é¢æœ€è¿‘ç‚¹å¯¹ã€‚æ±‚ä¸€ä¸ªå¹³é¢ä¸Šæœ€è¿‘çš„ç‚¹å¯¹ï¼Œç‚¹æ•°åœ¨ 10510^5105 çº§åˆ«ã€‚ å…ˆå°†æ‰€æœ‰ç‚¹æŒ‰ç…§ xxx åæ ‡æ’åºï¼Œç„¶åå¼€å§‹åˆ†æ²»ã€‚å…³é”®åœ¨äºå¦‚ä½•åˆå¹¶ï¼šå¦‚æœä¸€ä¸ªç‚¹æ»¡è¶³ âˆ£x[mid]âˆ’x[i]âˆ£&lt;d|x[mid]-x[i]|&lt;dâˆ£x[mid]âˆ’x[i]âˆ£&lt;dï¼Œå…¶ä¸­ ddd ä»£è¡¨å·¦å³ä¸¤è¾¹ç­”æ¡ˆçš„æœ€å°å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°ç‚¹ iii æ˜¯åˆæ³•çš„ã€‚ç„¶åå°†è¿™äº›åˆæ³•çš„ç‚¹å†æŒ‰ç…§ yyy åæ ‡æ’åºï¼Œå†è¿›è¡Œæšä¸¾ï¼Œyyy åæ ‡è·ç¦»å¤§äº ddd å°± break æ‰ã€‚ è¿™æ ·å¯ä»¥ä¿è¯åˆå¹¶çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)O(n)O(n) çš„ï¼ˆéœ€è¦é‡‡ç”¨å½’å¹¶æ’åºï¼‰ï¼Œå…·ä½“è¯æ˜éœ€è¦é€šè¿‡ä¸€äº›å‡ ä½•çš„æ–¹å¼ï¼Œä¸æ‰“ç®—ç ”ç©¶ã€‚ä»£ç ã€‚ äºŒç»´åˆ†æ²» å…¶å®å°±æ˜¯å¯¹ä¸¤ä¸ªä¸œè¥¿è¿›è¡Œåˆ†æ²»ï¼Œæ¯æ¬¡å°†å…¶ä¸­ä¸€ä¸ªä¸œè¥¿åˆ‡åŠï¼ˆä¸ºäº†ä¿è¯æ•ˆç‡ï¼Œä¸€èˆ¬é€‰æ‹©å…¶ä¸­åŒºé—´æ›´é•¿çš„ä¸€ä¸ªåˆ‡åŠï¼‰ï¼Œç„¶ååˆå¹¶ç­”æ¡ˆã€‚ [CF364E] Empty Rectangles.ç»™å®šä¸€ä¸ª nÃ—m(1â‰¤n,mâ‰¤2.5Ã—103)n\\times m(1\\le n, m\\le 2.5\\times 10^3)nÃ—m(1â‰¤n,mâ‰¤2.5Ã—103) çš„ 01 çŸ©é˜µï¼Œè¯¢é—®æœ‰å¤šå°‘ä¸ªå­çŸ©é˜µæ»¡è¶³åªæœ‰ k(1â‰¤kâ‰¤6)k(1\\le k\\le 6)k(1â‰¤kâ‰¤6) ä¸ª 1ã€‚ æœ¬é¢˜è¦æ±‚æ°å¥½æœ‰ kkk ä¸ª 1 çš„å­çŸ©å½¢æ•°é‡ï¼Œæˆ‘ä»¬å°†å½“å‰çŸ©å½¢åŠˆæˆä¸¤åŠï¼ˆä»¥åŠˆæˆå·¦ä¸€åŠå’Œå³ä¸€åŠä¸ºä¾‹ï¼‰ï¼Œé‚£ä¹ˆç¬¦åˆæ¡ä»¶çš„å­çŸ©å½¢è¦ä¹ˆåœ¨å·¦åŠï¼Œè¦ä¹ˆåœ¨å³åŠï¼Œè¦ä¹ˆè·¨è¶Šä¸­çº¿ã€‚ è€ƒè™‘è·¨è¶Šä¸­çº¿çš„å¦‚ä½•åˆå¹¶ã€‚æˆ‘ä»¬æšä¸¾å­çŸ©å½¢çš„ä¸Šä¸‹è¾¹ç•Œï¼Œç„¶åå¼€ä¸ªæ¡¶ ppp ç»Ÿè®¡å·¦åŠçŸ©å½¢æ‰€å« 111 æ•°é‡å°äº iii æ—¶å·¦è¾¹ç•Œçš„æœ€å°å€¼ï¼ˆå³åŠçŸ©å½¢åŒç†ï¼‰ï¼Œç„¶åç›´æ¥æšä¸¾å·¦åŠè¾¹çš„ 111 çš„ä¸ªæ•°å°±å¯ä»¥ç»Ÿè®¡äº†ã€‚ä»£ç ã€‚ CDQ åˆ†æ²» æ ‘å¥—æ ‘çš„æœ¬è´¨ä½œç”¨æ˜¯é™ç»´ï¼Œä½†æ˜¯å¦‚æœå…è®¸ç¦»çº¿ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ CDQ åˆ†æ²»é«˜æ•ˆåœ°å®Œæˆè¿™ä¸ªé—®é¢˜ã€‚ æœ€é‡è¦çš„åº”ç”¨æ˜¯è§£å†³ä¸‰ç»´ååºé—®é¢˜ã€‚åˆ†åˆ«å¤„ç†ä¸‰ä¸ªä¿¡æ¯ã€‚ç¬¬ä¸€ç»´å¯ä»¥å°†åŸæ•°ç»„æŒ‰ç…§ xxx æ’åºï¼Œxiâ‰¤xjx_i\\le x_jxiâ€‹â‰¤xjâ€‹ è½¬åŒ–ä¸º i&lt;ji&lt;ji&lt;jã€‚æ³¨æ„æ­¤æ—¶å¦‚æœæ•°éƒ½ç›¸åŒä¼šå‡ºé—®é¢˜ï¼Œå› æ­¤å»ä¸ªé‡ã€‚ç¬¬äºŒç»´å¯ä»¥åœ¨åˆ†æ²»æ—¶é‡‡ç”¨ç±»ä¼¼äºå½’å¹¶æ’åºçš„æ–¹å¼è§£å†³ï¼ˆæ±‚æ­£åºå¯¹ï¼‰ï¼Œä¸è¿‡ç”±äºç¬¬ä¸‰ç»´çš„é™åˆ¶ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„ä¿¡æ¯éƒ½å¯ä»¥åŠ åˆ°ç­”æ¡ˆé‡Œçš„ï¼Œéœ€è¦æ•´ä¸€ä¸ªæƒå€¼æ ‘çŠ¶æ•°ç»„æ¥å¤„ç†ç¬¬ä¸‰ç»´çš„ä¿¡æ¯ï¼šå·¦åŠæ®µåºåˆ—çš„ä¿¡æ¯åŠ å…¥æ ‘çŠ¶æ•°ç»„ï¼Œå³åŠæ®µä¿¡æ¯è¿›è¡Œç»Ÿè®¡ã€‚ä»£ç ã€‚ CDQ åˆ†æ²»çš„å†™æ³•éå¸¸çµæ´»ï¼Œåƒä¸‰ç»´ååºé—®é¢˜æ˜¯å¯¹åˆ†æ²»æ ‘è¿›è¡Œååºéå†æ¥ç»Ÿè®¡ç­”æ¡ˆçš„ã€‚å¯¹äºä¸€äº› DP é—®é¢˜ï¼Œå¾€å¾€å¯ä»¥åœ¨ä¸­åºéå†æ—¶ç»Ÿè®¡å‰é¢ä¸€åŠå¯¹åé¢ä¸€åŠçš„å½±å“ã€‚ é«˜ç»´ CDQ åˆ†æ²»ã€‚ä»¥ CDQ å¥— CDQ ä¸ºä¾‹å­ï¼Œå®é™…ä¸Šä¹Ÿå¾ˆç®€å•ï¼Œå¯¹äºå¤–å±‚ CDQ é‡‡ç”¨ä¸­åºéå†è®¡ç®—æ¥å¤„ç†ç¬¬ä¸€ç»´ååºï¼Œç„¶åå¯¹äº [l,r][l,r][l,r] è¿›è¡Œå†…å±‚ CDQã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ï¼ˆå†…å±‚åªå½’å¹¶ï¼‰ã€‚ ä»¥ä¸‹æ˜¯å››ä¸ªå…³é”®å­—çš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„ä¾‹å­ã€‚ void CDQ2(int l, int r) &#123; if (l == r) return; int mid = l + r >> 1; CDQ2(l, mid); CDQ2(mid + 1, r); for (int i = l; i &lt;= mid; ++i) if (b[i].op == 0) b[i].op = 2; for (int i = mid + 1; i &lt;= r; ++i) if (b[i].op == 1) b[i].op = 3; sort(b + l, b + r + 1, cmp2); for (int i = l; i &lt;= r; ++i) &#123; if (b[i].op == 2) add(b[i].d, f[b[i].id]); else if (b[i].op == 3) f[b[i].id] = max(f[b[i].id], sum(b[i].d)), b[i].op = 1; &#125; for (int i = l; i &lt;= r; ++i) if (b[i].op == 2) clr(b[i].d), b[i].op = 0; &#125; void CDQ1(int l, int r) &#123; if (l == r) return f[a[l].id] += a[l].cnt, void(); int mid = l + r >> 1; CDQ1(l, mid); for (int i = l; i &lt;= r; ++i) b[i] = a[i]; for (int i = mid + 1; i &lt;= r; ++i) b[i].op = 1; sort(b + l, b + r + 1, cmp1); CDQ2(l, r); CDQ1(mid + 1, r); &#125; æ•´ä½“äºŒåˆ† å¦‚æœåˆ†æ²»ä¸­éµå¾ªå…ˆé€’å½’å·¦å­æ ‘ï¼Œå†é€’å½’å³å­æ ‘çš„æ³•åˆ™ï¼Œé‚£ä¹ˆç»´æŠ¤ä¸€ä¸ªæŒ‡é’ˆå»â€œè·Ÿè¸ªâ€åˆ†æ²»ä¸­å¿ƒï¼Œè¿™ä¸ªæŒ‡é’ˆçš„ç§»åŠ¨è·ç¦»æ˜¯ O(nlogâ¡n)O(n\\log n)O(nlogn) çš„ã€‚è¿‡ç¨‹ç±»ä¼¼äºå°†å¤šæ¬¡äºŒåˆ†åˆå¹¶åˆ°ä¸€èµ·è¿›è¡Œï¼Œå¯ä»¥å€Ÿæ­¤å¾—åˆ°ä¼˜ç§€çš„å¤æ‚åº¦ã€‚ æœ¬èº«å¸¸æ•°æå°ï¼Œè§£å†³åŒºé—´ kkk å°é—®é¢˜çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ï¼Œä½†å´è·Ÿä¸»å¸­æ ‘çš„ O(nlogâ¡n)O(n\\log n)O(nlogn) çš„é€Ÿåº¦å·®ä¸å¤šã€‚ [CTSC2018] æ··åˆæœæ±ã€‚è¾ƒå¤æ‚ï¼Œè¯·å‚è€ƒåŸé¢˜é¢ã€‚ å¯ä»¥äºŒåˆ†å‡ºç¾å‘³åº¦çš„ç­”æ¡ˆï¼Œè€Œåˆæœ‰å¤šç»„è¯¢é—®ï¼Œå› æ­¤è€ƒè™‘æ•´ä½“äºŒåˆ†ã€‚å…ˆåŠ å…¥ä¸€ä¸ªç¾å‘³åº¦ä¸º âˆ’1-1âˆ’1ï¼Œå¯ä»¥æ— é™ä¹°çš„å…è´¹æœæ±æ–¹ä¾¿å¤„ç†ã€‚å°†æœæ±æŒ‰ç…§ç¾å‘³åº¦ä»å¤§åˆ°å°æ’åºã€‚ æˆ‘ä»¬å°†ç¾å‘³åº¦ â‰¤mid\\le midâ‰¤mid çš„æœæ±å…¨éƒ¨åŠ å…¥æ ‘çŠ¶æ•°ç»„ã€‚å¯¹å½“å‰è¯¢é—®çš„åˆ†ç»„éœ€è¦äºŒåˆ†å‡ºæ»¡è¶³å…¶ä½“ç§¯é™åˆ¶çš„æœ€å°ä»·æ ¼ï¼Œåªéœ€è¦è€ƒè™‘æ¯”è¿™ä¸ªä»·æ ¼ä½çš„æœæ±ä¸€å®šè¦å…¨ä¹°ï¼Œä¸è¶³çš„ç”¨ä»·æ ¼ç­‰äºè¿™ä¸ªçš„æœæ±è¡¥å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦ O(nlogâ¡3n)O(n\\log^3 n)O(nlog3n)ï¼Œæ¢æˆæ ‘çŠ¶æ•°ç»„å€å¢å¯ä»¥åšåˆ° O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ï¼Œä»£ç ã€‚ çº¿æ®µæ ‘åˆ†æ²» æŒ‰æ—¶é—´å»ºç«‹çº¿æ®µæ ‘ï¼Œå°†æ“ä½œè¦†ç›–åˆ°çº¿æ®µæ ‘ä¸Šçš„ç‚¹ï¼Œé‚£ä¹ˆå¤„ç†ä¸€ä¸ªæ—¶é—´çš„ç­”æ¡ˆå°±æ˜¯ä»å¶å­åˆ°æ ¹æ‰€æœ‰èŠ‚ç‚¹ä¿¡æ¯çš„å¹¶ã€‚åˆ©ç”¨å¯æ’¤é”€æ•°æ®ç»“æ„å¯ä»¥é€šè¿‡åœ¨çº¿æ®µæ ‘ä¸Š DFS å³å¯å¾—åˆ°æ¯ä¸ªæ—¶é—´çš„ç­”æ¡ˆã€‚ [CF576E] Painting Edgesã€‚ç»™å®šä¸€å¼  nnn ä¸ªç‚¹ mmm æ¡è¾¹çš„æ— å‘å›¾ã€‚ä¸€å…±æœ‰ kkk ç§é¢œè‰²ï¼Œä¸€å¼€å§‹ï¼Œæ¯æ¡è¾¹éƒ½æ²¡æœ‰é¢œè‰²ã€‚å®šä¹‰åˆæ³•çŠ¶æ€ä¸ºä»…ä¿ç•™æŸ“æˆ kkk ç§é¢œè‰²ä¸­çš„ä»»ä½•ä¸€ç§é¢œè‰²çš„è¾¹ï¼Œå›¾éƒ½æ˜¯ä¸€å¼ äºŒåˆ†å›¾ã€‚æœ‰ qqq æ¬¡æ“ä½œï¼Œç¬¬ iii æ¬¡æ“ä½œå°†ç¬¬ eie_ieiâ€‹ æ¡è¾¹çš„é¢œè‰²æŸ“æˆ cic_iciâ€‹ã€‚ä½†å¹¶ä¸æ˜¯æ¯æ¬¡æ“ä½œéƒ½ä¼šè¢«æ‰§è¡Œï¼Œåªæœ‰å½“æ‰§è¡Œåä»ç„¶åˆæ³•ï¼Œæ‰ä¼šæ‰§è¡Œæœ¬æ¬¡æ“ä½œã€‚ä½ éœ€è¦åˆ¤æ–­æ¯æ¬¡æ“ä½œæ˜¯å¦ä¼šè¢«æ‰§è¡Œã€‚n,m,qâ‰¤5Ã—105n,m,q \\le 5 \\times 10^5n,m,qâ‰¤5Ã—105ï¼Œkâ‰¤50k \\le 50kâ‰¤50ã€‚ ä½¿ç”¨ kkk ä¸ªå¯æ’¤é”€å¹¶æŸ¥é›†ç»´æŠ¤æ¯ä¸€ä¸ªé¢œè‰²ã€‚ä½†æ˜¯å¦‚æœç­”æ¡ˆæ˜¯ NO ä¸æ‰§è¡Œæ­¤æ“ä½œå¦‚ä½•å¤„ç†ï¼Ÿ çº¿æ®µæ ‘åˆ†æ²»çš„ç‰¹æ€§æ˜¯ 1â†’q1\\rightarrow q1â†’q ä¾æ¬¡å¤„ç†ï¼Œç¬¬ iii æ¬¡è¯¢é—®çš„ç”Ÿæ•ˆåŒºé—´æ˜¯ [i+1,yâˆ’1][i+1,y-1][i+1,yâˆ’1]ï¼ˆyyy ä»£è¡¨ä¸‹ä¸€æ¬¡ä¿®æ”¹è¿™æ¡è¾¹çš„æ—¶é—´ï¼‰ã€‚å¯ä»¥åœ¨æ¯ä¸ªå¶å­ä¸Šå†è€ƒè™‘æ˜¯å¦æ»¡è¶³äºŒåˆ†å›¾çš„æ¡ä»¶ï¼ˆæ¯ä¸ªè¯¢é—®åªä¼šå¤šä¸€æ¡è¾¹ï¼‰ï¼Œç„¶åä¸æ»¡è¶³çš„è¯è¿™ä¸ªä¿®æ”¹çš„é¢œè‰²æ”¹ä¸ºè¾¹å½“å‰çš„é¢œè‰²ã€‚ä»£ç ã€‚ çŒ«æ ‘åˆ†æ²» åœ¨åˆ†æ²»æ—¶ç»´æŠ¤å‰åç¼€çš„ä¿¡æ¯ï¼Œç„¶åé€šè¿‡è¿™äº›ä¿¡æ¯æ±‚å‡ºè·¨è¿‡åˆ†æ²»ä¸­å¿ƒçš„ç­”æ¡ˆã€‚ [Luogu P6240] å¥½åƒçš„é¢˜ç›®ã€‚å¤šæ¬¡è¯¢é—®åŒºé—´ 01 èƒŒåŒ…ã€‚nâ‰¤4Ã—104,mâ‰¤2Ã—105,Wâ‰¤200n\\le 4\\times 10^4,m\\le 2\\times 10^5,W\\le 200nâ‰¤4Ã—104,mâ‰¤2Ã—105,Wâ‰¤200ã€‚ è€ƒè™‘åˆ†æ²»ï¼Œå¯¹äº râ‰¤midr\\le midrâ‰¤mid çš„è¯¢é—®ï¼Œåˆ’åˆ†åˆ°å·¦è¾¹å¤„ç†ï¼Œå¯¹äº l&gt;midl&gt;midl&gt;mid çš„è¯¢é—®ï¼Œåˆ’åˆ†åˆ°å³è¾¹å¤„ç†ï¼Œå¯¹äºè·¨è¶Š midmidmid çš„è¯¢é—®ï¼Œä» midmidmid å¼€å§‹å‘å·¦å³éå†ï¼Œåˆå¹¶èƒŒåŒ…å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ O((nlogâ¡n+q)t)O((n\\log n+ q)t)O((nlogn+q)t)ã€‚ int n, m, h[40005], w[40005]; struct Query &#123; int l, r, V; &#125; Q[200005]; int ans[200005], p[200005], T[200005]; int f[40005][205]; void solve(int l, int r, int ql, int qr) &#123; if (ql > qr) return; int mid = l + r >> 1; for (int i = 0; i &lt;= 200; ++i) f[mid][i] = 0; for (int i = mid + 1; i &lt;= r; ++i) &#123; for (int j = 0; j &lt; h[i]; ++j) f[i][j] = f[i - 1][j]; for (int j = h[i]; j &lt;= 200; ++j) f[i][j] = max(f[i - 1][j], f[i - 1][j - h[i]] + w[i]); &#125; for (int i = h[mid]; i &lt;= 200; ++i) f[mid][i] = w[mid]; for (int i = mid - 1; i >= l; --i) &#123; for (int j = 0; j &lt; h[i]; ++j) f[i][j] = f[i + 1][j]; for (int j = h[i]; j &lt;= 200; ++j) f[i][j] = max(f[i + 1][j], f[i + 1][j - h[i]] + w[i]); &#125; int qmid = ql - 1, tm = 0; for (int i = ql; i &lt;= qr; ++i) &#123; int id = p[i]; if (Q[id].r &lt;= mid) p[++qmid] = id; else if (Q[id].l > mid) T[++tm] = id; else &#123; int &amp;res = ans[id]; for (int x = 0; x &lt;= Q[id].V; ++x) res = max(res, f[Q[id].l][x] + f[Q[id].r][Q[id].V - x]); &#125; &#125; for (int i = 1; i &lt;= tm; ++i) p[qmid + i] = T[i]; qr = qmid + tm; solve(l, mid, ql, qmid); solve(mid + 1, r, qmid + 1, qr); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> h[i]; for (int i = 1; i &lt;= n; ++i) cin >> w[i]; int tm = 0; for (int i = 1; i &lt;= m; ++i) &#123; cin >> Q[i].l >> Q[i].r >> Q[i].V; if (Q[i].l == Q[i].r) ans[i] = (Q[i].V >= h[Q[i].l] ? w[Q[i].l] : 0); else p[++tm] = i; &#125; solve(1, n, 1, tm); for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; ä¾‹é¢˜ å¤šç§å¤šæ ·ï¼ * [CF1442D] Sum Portal.ç»™å®š nnn ä¸ªä¸é™çš„æ•°ç»„ã€‚æœ‰ä¸€ä¸ªå€¼ ansansansï¼Œåˆå§‹ä¸º 000ã€‚ä½ éœ€è¦è¿›è¡Œå¦‚ä¸‹æ“ä½œ kkk æ¬¡ï¼šé€‰æ‹©ä¸€ä¸ªæ•°ç»„ï¼ŒæŠŠ ansansans åŠ ä¸Šæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä¹‹åæŠŠå®ƒåˆ é™¤ã€‚è¯·æ±‚å‡º ansansans æœ€å¤§æ˜¯å¤šå°‘ã€‚æ‰€æœ‰æ•°ç»„çš„å…ƒç´ æ€»ä¸ªæ•° â‰¤106\\leq 10^6â‰¤106ï¼Œn,kâ‰¤3000n,k\\leq 3000n,kâ‰¤3000ã€‚ æ³¨æ„åˆ°æ•°ç»„æ˜¯å•è°ƒä¸é™çš„ï¼Œå› æ­¤è¦å–ä¸€ä¸ªæ•°ç»„å°±ä¼šä¸€ç›´å–ä¸‹å»ç›´åˆ°ä¸èƒ½å–æˆ–è€…å–å…‰äº†ã€‚ æ‰€ä»¥å¯ä»¥æƒ³åˆ°ä¸€ä¸ªæš´åŠ›ä¸€ç‚¹çš„åšæ³•ï¼šå°†ä¸€ä¸ªæ•°ç»„è§†ä¸ºä¸€ä¸ªæœ‰ä½“ç§¯æœ‰ä»·å€¼çš„ç‰©å“ï¼Œç„¶åæ­£ååšä¸¤é 01 èƒŒåŒ…ï¼Œæšä¸¾æ²¡å–æ»¡çš„é‚£ä¸ªæ•°ç»„å’Œè¿™ä¸ªæ•°ç»„å–å¤šå°‘ä¸ªï¼Œå†æšä¸¾å‰é¢å–çš„ä½“ç§¯ï¼Œè¿™æ ·å°±å¯ä»¥å¾—å‡ºåé¢å–çš„ä½“ç§¯ï¼Œå¹¶è®¡ç®—å‡ºæ€»ä»·å€¼ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nk2)O(nk^2)O(nk2)ã€‚ è¿™æ ·è‚¯å®šè¿‡ä¸å»ï¼Œå‘ç°å°±æ˜¯åˆå¹¶å¤ªæ…¢äº†ï¼Œè€ƒè™‘ä½¿ç”¨åˆ†æ²»ç®—æ³•åˆå¹¶ï¼šæ±‚è§£ (l,r)(l,r)(l,r) æ—¶ï¼Œæˆ‘ä»¬å…ˆå°† (l,mid)(l,mid)(l,mid) åŠ å…¥èƒŒåŒ…ï¼Œç„¶åé€’å½’æ±‚è§£ (mid+1,r)(mid+1,r)(mid+1,r)ï¼Œå½“ l=rl=rl=r æ—¶å°±å¯ä»¥æšä¸¾å½“å‰ä½“ç§¯äº†ã€‚æ—¶é—´å¤æ‚åº¦ O(nklogâ¡n)O(nk\\log n)O(nklogn)ã€‚ è¿™ä¸ªé—®é¢˜è¢«ç§°ä¸ºç¼ºä¸€èƒŒåŒ…ï¼Œæ„æ€æ˜¯å…¶ä¸­æœ‰ä¸€ä¸ªå¯ä»¥å–ä¸æ»¡ï¼Œä¸€èˆ¬é‡‡ç”¨ä¸Šè¿°åˆ†æ²»æ³•è§£å†³ã€‚ int n, k; vector&lt;i64> a[3005]; i64 ans = 0, f[3005]; void merge(int l, int r) &#123; if (l == r) &#123; for (int i = 0; i &lt;= min(k, (int)a[l].size() - 1); ++i) ans = max(ans, a[l][i] + f[k - i]); return; &#125; int mid = l + r >> 1; i64 g[3005]; memcpy(g, f, sizeof(g)); for (int i = mid + 1; i &lt;= r; ++i) for (int j = k; j >= a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(l, mid); memcpy(f, g, sizeof(f)); for (int i = l; i &lt;= mid; ++i) for (int j = k; j >= a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(mid + 1, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; int m; scanf(\"%d\", &amp;m); a[i].resize(m + 1); for (int j = 1, x; j &lt;= m; ++j) scanf(\"%lld\", &amp;a[i][j]), a[i][j] += a[i][j - 1]; &#125; merge(1, n); printf(\"%lld\\n\", ans); return 0; &#125; [Ynoi2016] é•œä¸­çš„æ˜†è™« Portal. ç»´æŠ¤ prexpre_xprexâ€‹ ä»£è¡¨ xxx ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œxxx åœ¨åŒºé—´ç¬¬ä¸€æ¬¡å‡ºç°å½“ä¸”ä»…å½“ prex&lt;l,xâˆˆ[l,r]pre_x&lt;l,x\\in [l,r]prexâ€‹&lt;l,xâˆˆ[l,r]ã€‚é‚£ä¹ˆè¿™ä¸ªé—®é¢˜å°±å˜æˆäº†å…è®¸ç¦»çº¿çš„å¸¦ä¿®äºŒç»´æ•°ç‚¹ã€‚ è¿™ä¸ªä¿®æ”¹å­˜åœ¨é¢œè‰²æ®µå‡æ‘Šï¼Œå¯ä»¥ç›´æ¥åšã€‚å…·ä½“åœ°ï¼Œä½¿ç”¨ set ç»´æŠ¤é¢œè‰²æ®µï¼Œä¹Ÿè®°å½•æ‰€æœ‰é¢œè‰²å¯¹åº”çš„æ®µï¼Œç„¶åå¯¹äºä¿®æ”¹çš„ä¸œè¥¿çš„åç»§éƒ½é‡æ–°è®¡ç®— preprepreã€‚ äºæ˜¯å°±å˜æˆäº†ä¸‰ç»´ååºæ¨¡æ¿ã€‚ä»£ç ã€‚ [CF603E] Pastoral Oddities Portal. æ»¡è¶³é¢˜ç›®æ¡ä»¶æ„å‘³ç€æ‰€æœ‰è¿é€šå—çš„å¤§å°éƒ½æ˜¯å¶æ•°ã€‚å°†è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºï¼Œç„¶åçº¿æ®µæ ‘åˆ†æ²»ä»å³åˆ°å·¦ä¾æ¬¡å¤„ç†æ¯ä¸€æ¡è¾¹ï¼Œè®¡ç®—æ¯ä¸€æ¡è¾¹å¯ä»¥è¢«è®°å…¥ç­”æ¡ˆçš„èŒƒå›´ã€‚ä»£ç ã€‚ éšæœºåŒ–ç®—æ³• æœ‰çš„æ—¶å€™ä¸çŸ¥é“æ€ä¹ˆåšï¼Ÿæˆ–è€…é‡åˆ°ç¥ç§˜çš„æäº¤ç­”æ¡ˆé¢˜ï¼ˆæœ‰äº›æäº¤ç­”æ¡ˆæ˜¯ä¸å¯åšä¼˜åŒ–é¢˜ï¼‰ï¼Ÿå¯ä»¥è€ƒè™‘ä½¿ç”¨éšæœºåŒ–ã€‚ éšæœºåŒ–æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯æ“ä½œæ¬¡æ•°ä¸€å®šï¼Œæ­£ç¡®æ€§ä¸è¿›è¡Œçš„è½®æ•°æœ‰å…³ï¼ˆæ¨¡æ‹Ÿé€€ç«ç­‰ï¼‰ï¼›å¦ä¸€ç§æ˜¯æœŸæœ›æ“ä½œæ¬¡æ•°ï¼Œè¦æ±‚æ•°æ®éšæœºï¼ˆé™¤éä½ çš„æ–¹æ³•å¾ˆç¥ç§˜ï¼Œå‡ºé¢˜äººæ²¡æƒ³åˆ°ï¼Œä½†æ˜¯å¦‚æœäº¤äº’åº“æ˜¯è‡ªé€‚åº”çš„å°±æ²¡è¾™äº†ï¼‰ã€‚ mt19937 Rnd(time(0)); int rndint(int l, int r) &#123; return uniform_int_distribution&lt;>(l, r)(Rnd); &#125; double rnddb(int l, int r) &#123; return uniform_real_distribution&lt;>(l, r)(Rnd); &#125; çˆ¬å±±æ³• ç»™å‡º nnn ç»´ç©ºé—´çš„ n+1n+1n+1 ä¸ªç‚¹ï¼Œæ±‚å‡ºçƒå¿ƒï¼ˆä¿è¯å­˜åœ¨ï¼‰ã€‚ ç­”æ¡ˆä¸ºå•å³°å‡½æ•°æ—¶å¯ä»¥é‡‡ç”¨çˆ¬å±±æ³•ï¼Œæ¯æ¬¡è®¡ç®—ç­”æ¡ˆåº”è¯¥çš„æ”¹å˜ canscanscansï¼Œç„¶å ansâ†ans+cansÃ—Tans\\leftarrow ans+cans\\times Tansâ†ans+cansÃ—Tã€‚ void check(void) &#123; double tot = 0; for (int i = 1; i &lt;= n + 1; ++i) &#123; dis[i] = cans[i] = 0; for (int j = 1; j &lt;= n; ++j) dis[i] += (a[i][j] - ans[j]) * (a[i][j] - ans[j]); tot += (dis[i] = sqrt(dis[i])) / (n + 1); &#125; for (int i = 1; i &lt;= n + 1; ++i) for (int j = 1; j &lt;= n; ++j) cans[j] += (dis[i] - tot) / tot * (a[i][j] - ans[j]); // dis[i] - tot ä¸ºå½“å‰ç‚¹ä¸åŸçƒå¿ƒçš„è·ç¦»å·®ä¸å¹³å‡è·ç¦»çš„å·®ï¼Œé™¤ä»¥ tot ä»¥è®¡ç®—è¿™ä¸€ç»´åº¦å¯¹å¹³å‡è·ç¦»çš„è´¡çŒ®å æ¯” // a[i][j] - ans[j] ä¸ºåœ¨å½“å‰ç»´åº¦çš„å½“å‰ç‚¹ä¸åŸçƒå¿ƒè·ç¦»å·®ï¼Œæ ¹æ®æ­¤å€¼è¿›è¡Œç§»åŠ¨ &#125; // ç»™ ans èµ‹ä¸€ä¸ªè¿‘ä¼¼çš„åˆå€¼ for (double T = 20000; T > 1e-4; T *= 0.99996) &#123; check(); for (int i = 1; i &lt;= n; ++i) ans[i] += cans[i] * T; &#125; æ¨¡æ‹Ÿé€€ç« æ–°çš„ç­”æ¡ˆé€‰æ‹©è¦ä¸ºéšæœºæ•´æ•°ä¹˜ä¸Šå½“å‰çš„æ¸©åº¦ï¼ˆæˆ–è€ƒè™‘éšæœºè°ƒæ•´ä¹‹ç±»çš„ï¼‰ï¼Œä»¥ eÎ”/Te^{\\Delta / T}eÎ”/Tï¼Œå³ exp(Delta / T) çš„æ¦‚ç‡æ¥å—å½“å‰éæœ€ä¼˜è§£ï¼ˆä¿è¯ Î”\\DeltaÎ” ä¸ºæ­£ï¼Œå¤§äº rnd(0, 1) æ¥å—ï¼Œå°äºä¸æ¥å—ï¼‰ã€‚å®é™…ä¸Šï¼Œåªæœ‰åœ¨ Î”T\\Delta TÎ”T è¾ƒå°çš„æ—¶å€™ï¼Œå–æ‰€æœ‰æƒ…å†µçš„æœ€ä¼˜ç­”æ¡ˆä¼šå¾—åˆ°éå¸¸æ£’çš„ç­”æ¡ˆï¼Œä½†æ˜¯ Î”T\\Delta TÎ”T è¶³å¤Ÿå¤§æ—¶æ²¡ä»€ä¹ˆåŒºåˆ«ï¼Œç›´æ¥å°†ç­”æ¡ˆä¹Ÿæ”¹æˆä¸ä¼˜çš„ä¹Ÿå¯ï¼Œè¿™ç§æ–¹å¼å¯ä»¥ç”¨äºæŸäº›æäº¤ç­”æ¡ˆé¢˜ã€‚ å®é™…ä¸Šæœ‰æ—¶åè€Œå°†æ¨¡æ‹Ÿé€€ç«æ¥å—é”™è§£çš„æ¦‚ç‡æ”¹æˆå›ºå®šçš„èƒ½å¾—åˆ°æ›´å¥½çš„ç»“æœï¼Œä½†æ˜¯è¿™æ—¶å®ƒåº”è¯¥ä¸å«é€€ç«äº†ã€‚ å…¶å®ƒéšæœºåŒ– å¯¹äºæœ€ä¼˜åŒ–é—®é¢˜å’Œå­˜åœ¨ç±»é—®é¢˜ï¼Œé€šå¸¸ç­”æ¡ˆçš„æ„é€ æ–¹å¼ä¸æ­¢ä¸€ç§ï¼Œè¿™æ—¶å¯ä»¥è€ƒè™‘éšæœºåŒ–ã€‚ä¹Ÿæœ‰éšæœºåŒ–è´ªå¿ƒã€éšæœºæ’’ç‚¹ç­‰åšæ³•ã€‚å…·ä½“è§é¢˜è½¦ã€‚ ä¾‹é¢˜ æ¯”è¾ƒè€ƒéªŒé€‰æ‰‹çš„ä¹±æèƒ½åŠ›ã€‚ * [CF1556H] DIY Tree Portal. ç»™ç”Ÿæˆæ ‘å®šä¹‰ä¼°ä»·å‡½æ•° f(T)=âˆ‘i=1Kmaxâ¡{0,Diâˆ’di}f(T)=\\sum_{i=1}^K \\max\\{0,D_i-d_i\\}f(T)=âˆ‘i=1Kâ€‹max{0,Diâ€‹âˆ’diâ€‹}ï¼Œå…¶ä¸­ DiD_iDiâ€‹ ä»£è¡¨å®é™…åº¦æ•°ã€‚ å…ˆæ±‚å‡ºæœ€å°ç”Ÿæˆæ ‘ï¼Œç„¶åå¯¹å…¶è¿›è¡Œè°ƒæ•´ã€‚æ¯æ¬¡é€‰æ‹©ä¸€æ¡è¾¹æƒæœ€å¤§çš„ï¼Œåˆ å»å fff ä¼šå‡å°çš„è¾¹ e1e_1e1â€‹ï¼Œæ›¿æ¢æˆåŠ ä¸Šå fff ä¸ä¼šå˜å¤§çš„è¾¹æƒæœ€å°çš„è¾¹ e2e_2e2â€‹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n3)O(n^3)O(n3)ã€‚ éšæœºåŒ–è¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬ç»™ e1e_1e1â€‹ å’Œ e2e_2e2â€‹ çš„é€‰æ‹©åŠ ä¸Šä¸€ä¸ªæ¦‚ç‡ï¼Œä¸é€‰å°±æ¥ç€æ‰«ã€‚ä»£ç ã€‚ æäº¤ç­”æ¡ˆé¢˜ ç›´æ¥ç»™å®šè¾“å…¥æ–‡ä»¶ï¼Œè®©ä½ ä¸æ‹©æ‰‹æ®µæ±‚è§£ç­”æ¡ˆçš„é¢˜ç›®ç±»å‹ã€‚æ›¾åœ¨ 2016 ä»¥å‰é¢‘ç¹åœ¨è€ƒåœºä¸Šå‡ºç°ï¼Œä¸è¿‡è¿‘å¹´æ¥éä¼ ç»Ÿé¢˜çš„åœ°ä½æ­£é€æ­¥è¢«äº¤äº’é¢˜éœ¸å ã€‚ å¸¸è§ç±»å‹ é€šå¸¸ä»¥ä¸‹ç±»å‹çš„æ•°æ®ç‚¹ä¼šè¢«ç»„åˆæˆæäº¤ç­”æ¡ˆé¢˜ï¼š å¯ä»¥è¢«æ‰‹ç©æˆ–è€…è¶…çº§å¤§æš´åŠ›è§£å‡ºæ¥çš„æ•°æ®ç‚¹ï¼› ç‰¹æ®Šæ„é€ çš„æ•°æ®ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨ç‰¹åˆ«çš„è§£æ³•ï¼› éœ€è¦ä½¿ç”¨ä¹±ææ–¹æ³•è§£å†³çš„æ•°æ®ç‚¹ã€‚ ä¾‹é¢˜ ç”±äºç°åœ¨è€ƒçš„ä¸æ˜¯å¾ˆå¤šï¼Œå› æ­¤åªçœ‹ä¸€äº›æ¯”è¾ƒå¸¸è§„çš„ã€‚ [eJOI2018] äº’ç´ æ ‘ Portal. ç”±äºé¢˜ç›®ä¸­ä¿è¯å­˜åœ¨ X=0X=0X=0ï¼Œéšæœºä¸€ä¸ªæ’åˆ—ç„¶åæŒ‰ç…§æ¡ä»¶è´ªå¿ƒå¾€æ ‘é‡Œå¡«éƒ½æ˜¯å¾ˆå®¹æ˜“å‡ºè§£çš„ï¼Œå› æ­¤ç›´æ¥éšæœºåŒ–åŠ è´ªå¿ƒï¼Œè·‘åŠä¸ªå°æ—¶å°±è¡Œã€‚ [JRKSJ R2] Dark Forest Portal. ä½¿ç”¨å¢é‡æ³• O(1)O(1)O(1) è®¡ç®—äº¤æ¢ä½ç½®çš„è´¡çŒ®ï¼Œç„¶åéšæœºæ¥å—æ—¶æŠŠç­”æ¡ˆä¹Ÿç»™æ¥å—äº†å°±è¡Œï¼ˆå› ä¸ºæ–¹æ¡ˆä¸å¥½å­˜å‚¨ï¼Œè¿™æ ·çš„é€€ç«ä¹Ÿå¾ˆä¼˜ï¼‰ï¼Œç„¶åå°½é‡è°ƒä½ Î”\\DeltaÎ”ã€‚æ³¨æ„ç‰¹åˆ¤ #3ã€‚ #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, p[1005]; i64 a[1005], ans; mt19937 Rand(time(0)); inline int rndint(int l, int r) &#123; return uniform_int_distribution&lt;>(l, r)(Rand); &#125; inline double rnddb(double l, double r) &#123; return uniform_real_distribution&lt;>(l, r)(Rand); &#125; inline int P(int x) &#123; if (x &lt;= 0) return x + n; if (x > n) return x - n; return x; &#125; void calc(int x, int y) &#123; // å°† p[x] èµ‹å€¼ä¸º y æ—¶ç­”æ¡ˆæ”¹å˜ int A = p[P(x - 2)], B = p[P(x - 1)], &amp;C = p[x], D = p[P(x + 1)], E = p[P(x + 2)]; ans -= (B * a[A] * a[B] + C * a[B] * a[D] + D * a[D] * a[E]) * a[C]; C = y; ans += (B * a[A] * a[B] + C * a[B] * a[D] + D * a[D] * a[E]) * a[C]; &#125; void SA(double T, const double ET, const double delta) &#123; for (int i = 1; i &lt;= n; ++i) calc(i, i); while (T > ET) &#123; int x = rndint(1, n), y = rndint(1, n), px = p[x], py = p[y]; i64 tmp = ans; calc(x, py); calc(y, px); if (ans &lt;= tmp &amp;&amp; exp((ans - tmp) / T) &lt; rnddb(0, 1)) // å›é€€ç­”æ¡ˆ ans = tmp, swap(p[x], p[y]); T *= delta; &#125; cerr &lt;&lt; \"ans = \" &lt;&lt; ans &lt;&lt; \"\\n\"; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", p[i]); putchar('\\n'); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); return SA(1e15, 1e-15, 0.99999), 0; &#125; å“ˆå¸Œæ–¹æ³• å“ˆå¸Œçš„ç§ç±»æœ‰å¾ˆå¤šç§ï¼Œå¦‚æœä¸€ä¸ªä¸œè¥¿çœ‹èµ·æ¥åªèƒ½ O(n)O(n)O(n) è¿›è¡Œæ¯”è¾ƒï¼Œä½†æ˜¯æˆ‘ä»¬å¿…é¡» O(1)O(1)O(1) æ¯”è¾ƒæ—¶ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨å“ˆå¸Œã€‚ åºåˆ—å“ˆå¸Œ å³å­—ç¬¦ä¸²å“ˆå¸Œï¼Œå¿«é€Ÿæ¯”è¾ƒä¸¤ä¸ªåºåˆ—çš„ç›¸ç­‰æƒ…å†µã€‚ä¸€èˆ¬æ¥è®²æˆ‘ä»¬é‡‡ç”¨ bbb è¿›åˆ¶æ–¹å¼çš„å“ˆå¸Œï¼Œå³ f(s)=âˆ‘i=1lsiÃ—blâˆ’if(s)=\\sum_{i=1}^{l}s_i\\times b^{l-i}f(s)=âˆ‘i=1lâ€‹siâ€‹Ã—blâˆ’iã€‚ é…åˆäºŒåˆ†ï¼Œå­—ç¬¦ä¸²å“ˆå¸Œå¯ä»¥ä»¥ O(knlogâ¡n)O(kn\\log n)O(knlogn) çš„æ—¶é—´å¤æ‚åº¦å®Œæˆå…è®¸å¤±é… kkk æ¬¡çš„å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜ã€‚ é›†åˆå“ˆå¸Œ é’ˆå¯¹é›†åˆå“ˆå¸Œæˆ‘ä»¬é€šå¸¸å°†æ¯ä¸ªå…ƒç´ éšæœºæ˜ å°„æˆä¸€ä¸ªæ•°ï¼Œç„¶åå“ˆå¸Œå‡½æ•°å®šä¹‰ä¸ºå¼‚æˆ–å’Œä¹‹ç±»çš„ä¸œè¥¿ã€‚ [CSP-S 2022] æ˜Ÿæˆ˜ã€‚è¯´çš„æ˜¯æ‰€æœ‰ç‚¹çš„å‡ºåº¦ä¸º 111ï¼Œä½†æ˜¯è¿™æ ·ä¸å¥½ç»´æŠ¤ï¼Œè½¬åŒ–ä¸ºå…¥åº¦è¿›è¡Œç»´æŠ¤ï¼Œæä¸€ä¸ªå“ˆå¸Œæé«˜æ­£ç¡®ç‡ã€‚ä»£ç ã€‚ æ ‘å“ˆå¸Œ æ¨¡æ¿ã€‚æˆ‘ä»¬ç»™å­æ ‘å®šä¹‰ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ï¼Œç„¶åå°†å­æ ‘åŠ èµ·æ¥ï¼Œå°±å¯ä»¥åˆ¤æ–­æ˜¯å¦åŒæ„äº†ã€‚ int n; vector&lt;int> G[1000005]; u64 h[1000005]; mt19937_64 Rand(time(0)); map&lt;u64, u64> mp; inline u64 get(u64 x) &#123; if (mp.find(x) == mp.end()) return mp[x] = Rand(); return mp[x]; &#125; set&lt;u64> s; void dfs(int x, int fa) &#123; h[x] = 1; for (int y : G[x]) if (y != fa) dfs(y, x), h[x] += get(h[y]); s.emplace(h[x]); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); cout &lt;&lt; s.size() &lt;&lt; \"\\n\"; return 0; &#125; ä¾‹é¢˜ ä¹Ÿå¾ˆå¤šç§å¤šæ ·ï¼ [CF1746F] Kazaee Portal. å°†æ¯ä¸ªæ•°å“ˆå¸Œæˆä¸€ä¸ªéšæœºæ•°ï¼Œç„¶åæ ‘çŠ¶æ•°ç»„ç»´æŠ¤åŒºé—´å’Œï¼Œå¦‚æœèƒ½è¢« kkk æ•´é™¤é‚£å°±åº”è¯¥æ˜¯å¯¹çš„ã€‚æ­£ç¡®ç‡æ˜¯ 1k\\frac 1 kk1â€‹ï¼Œè·‘ä¸ª 303030 è½®å³å¯ã€‚ä»£ç ã€‚ [CF1794E] Labeling the Tree with Distances Portal. æ ¹æ®æ ‘ä¸Šè·ç¦»è¿›è¡Œæ ‘å“ˆå¸Œï¼Œæ¢æ ¹ DP æ±‚è§£æ ‘å“ˆå¸Œï¼Œç„¶åå¿…é¡»æ˜¯è¿™ä¸ªæ ¹èŠ‚ç‚¹å ä¸€ä¸ª BiB^iBiï¼Œåˆ¤ä¸€ä¸‹å°±è¡Œã€‚ä»£ç ã€‚ *ã€XR-3ã€‘ç³»ç»Ÿè®¾è®¡ Portal. äºŒåˆ†è·³è½¬ç”¨åˆ°çš„åºåˆ—é•¿åº¦ï¼Œå¦‚æœåœ¨ xxx ä¸ºæ ¹çš„å­æ ‘ä¸­èƒ½å¤Ÿæ‰¾åˆ°ä¸€æ¡é“¾å’Œæ­¤æ—¶ Hash å€¼ç›¸ç­‰ï¼Œé‚£ä¹ˆå°±èƒ½è·³ã€‚åºåˆ—çš„ Hash å€¼ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ å¿«é€ŸæŸ¥è¯¢æ ‘ä¸Š Hashï¼Ÿå…ˆçœ‹çœ‹å›ºå®šæ ¹çš„æ—¶å€™æ€ä¹ˆåšï¼Ÿå¾ˆæ˜¾ç„¶ï¼Œé¢„å¤„ç†å‡ºæ ¹åˆ°å½“å‰èŠ‚ç‚¹çš„å“ˆå¸Œå°±å¯ä»¥ã€‚ç”±äºä¿è¯äº†æ˜¯æœ‰æ ¹æ ‘ï¼Œå› æ­¤ç›´æ¥å·®åˆ†å³å¯å¤„ç†åˆ«çš„æ ¹ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ï¼Œéå¸¸é«˜æ•ˆã€‚ä»£ç ã€‚ [NOI2022] æŒ‘æˆ˜ NPC II Portal. é¢˜ç›®å·²ç»å‘Šè¯‰æˆ‘ä»¬è¿™æ˜¯ä¸€ä¸ªæ ‘å“ˆå¸Œï¼Œè€Œä¸” kkk å°çš„ç¦»è°±ï¼Œå› æ­¤å¾€æœ€æš´åŠ›çš„æƒ³ï¼ ç®€å•ï¼èƒ½åŒ¹é…çš„å­æ ‘ç›´æ¥åŒ¹é…æ‰ï¼Œä¸èƒ½åŒ¹é…çš„æœ€å¤šåªæœ‰äº”ä¸ªï¼Œæšä¸¾å…¨æ’åˆ—å‘ä¸‹é€’å½’ï¼Œè®°å¿†åŒ–çˆ†æœå°±è¡Œï¼ä»£ç ã€‚ æ‚é¡¹ä¼˜åŒ–æŠ€å·§ ä¸€äº›å…¶å®ƒå†…å®¹ã€‚ è´ªå¿ƒ æ¯”è¾ƒé çŒœï¼Œæ¯”è¾ƒäººç±»æ™ºæ…§ã€‚ åˆ†ä¸ºæ’åºè´ªå¿ƒå’Œåæ‚”è´ªå¿ƒä¸¤ç§ã€‚ ä¸åˆ é™¤åŒæŒ‡é’ˆ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ—ï¼Œå®šä¹‰ f(l,r)f(l,r)f(l,r) ä¸ºåŒºé—´è¿›è¡ŒæŸç§è¿ç®—åçš„ç»“æœã€‚æœ‰ä¸€äº›åˆæ³•åŒºé—´ï¼Œåˆæ³•åŒºé—´å·¦ç«¯ç‚¹ç»™å®šï¼Œå³ç«¯ç‚¹æ˜¯è¿ç»­çš„ï¼Œä¸”ä¸å­˜åœ¨åŒ…å«çš„åˆæ³•åŒºé—´ã€‚ åŒæŒ‡é’ˆï¼å¯¹å•¦ï¼ä½†æ˜¯æœ‰ä¸€äº›é—®é¢˜æ— æ³•å¿«é€Ÿåˆ é™¤ï¼ˆå¦‚ gcdâ¡\\gcdgcdï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸åˆ é™¤åŒæŒ‡é’ˆã€‚ æ¡ä»¶æ˜¯ï¼Œä¿¡æ¯å¯ä»¥å¿«é€Ÿå½’å¹¶ã€‚ å…¶å¤§è‡´æ€æƒ³æ˜¯æå‰é¢„å¤„ç†ä¸€é lll å³ç§»æ—¶çš„ä¿¡æ¯ï¼Œå€’ç€æ‰«ä¸€é lll çš„ç§»åŠ¨è·¯å¾„å³å¯ã€‚ å…·ä½“æ¥è¯´ï¼Œç»´æŠ¤å·¦å³æŒ‡é’ˆ l,rl,rl,rï¼Œè¿˜æœ‰ä¸­é—´æŒ‡é’ˆ mmmã€‚åˆå§‹æ—¶æ‰€æœ‰æŒ‡é’ˆéƒ½æŒ‡å‘ 111ï¼Œç„¶åé‡å¤ä»¥ä¸‹æ­¥éª¤ç›´åˆ° rrr ç§»åˆ°äº† nnnã€‚ å°† l,ml,ml,m æŒ‡å‘ rrrï¼Œç„¶åå·¦ç§» lllï¼Œç›´åˆ° [l,m][l,m][l,m] ä¸åˆæ³•ï¼Œè®°å½• pi=f(i,m)p_i=f(i,m)piâ€‹=f(i,m)ã€‚ rrr å³ç§»ä¸€æ¬¡ï¼Œå³ç§» lll æŒ‡é’ˆä½¿å¾—åŒºé—´é‡æ–°åˆæ³•ï¼Œf(l,r)f(l,r)f(l,r) é€šè¿‡ f(l,m)f(l,m)f(l,m) å’Œ f(m+1,r)f(m+1,r)f(m+1,r) æ±‚å‡ºã€‚å½“ l&gt;ml&gt;ml&gt;m æ—¶ï¼Œè¿”å›æ­¥éª¤ 111ã€‚ ç”±äº lll çš„å·¦ç§»ä¸ä¼šè¶…è¿‡ä¸Šä¸€æ¬¡çš„ mmmï¼ˆå¤§æ¦‚æ˜¯å·¦ç§»ä¹‹åå†å³ç§»å›æ¥çš„æ ·å­ï¼Œä¼šç§»åŠ¨ 2n2n2n æ¬¡ï¼‰ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ Portalã€‚ç›¸å½“äºå¯¹å·®åˆ†åºåˆ—æ±‚ GCD ä¸ä¸º 111 çš„æœ€é•¿å­æ®µã€‚ åˆšå¥½å¯ä»¥ä½¿ç”¨ä¸åˆ é™¤åŒæŒ‡é’ˆï¼ cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1; i &lt; n; ++i) a[i] = abs(a[i + 1] - a[i]); int ans = 0; for (int m, l, r = 1; r &lt; n; ) &#123; for (m = l = r, p[l + 1] = 0; l >= 1; --l) &#123; p[l] = gcd(p[l + 1], a[l]); if (p[l] == 1) break; &#125; ++l; i64 w = 0; while (1) &#123; ans = max(ans, r - l + 1); ++r; if (r >= n) break; for (w = gcd(w, a[r]); l &lt;= m &amp;&amp; gcd(p[l], w) == 1; ) ++l; if (l > m) break; &#125; &#125; cout &lt;&lt; ans + 1 &lt;&lt; \"\\n\"; å‰ç¼€å’Œä¸å·®åˆ† è¿™é‡Œä¸»è¦é‡æä¸€ä¸‹é«˜ç»´çš„æƒ…å†µã€‚å¯ä»¥ä½¿ç”¨ sosDP æ¥è¿›è¡Œæ±‚è§£ï¼Œä¹Ÿå°±æ˜¯æšä¸¾å­é›†ã€‚ for (int j = 0; j &lt; n; ++j) for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) if (i >> j &amp; 1) f[i] += f[i ^ (1 &lt;&lt; j)]; é«˜ç»´å·®åˆ†è¿˜æ˜¯è€ƒè™‘å®¹æ–¥æ¥è®¡ç®—ã€‚ æ ¹å·åˆ†æ²»ï¼ˆå¹³è¡¡ï¼‰ æœ‰å…³äºæ ¹å·æ•°æ®ç»“æ„ï¼Œè¯·å‚è€ƒ NOI ä¸€è½®å¤ä¹  IXï¼šæ•°æ®ç»“æ„ Bã€‚ç”±äºå¤§éƒ¨åˆ†æ ¹å·åˆ†æ²»éƒ½ä¼šå’Œå…¶å®ƒæ•°æ®ç»“æ„ç»“åˆï¼Œå› æ­¤è¿™é‡Œåªä»‹ç»åŸºæœ¬æ–¹æ³•ã€‚ æ ¹å·åˆ†æ²»æ˜¯ä¸€ç§æŒ‰è§„æ¨¡å¤§å°åˆ†ç±»è®¨è®ºçš„æ€æƒ³ã€‚å¯¹äºè§„æ¨¡ä¸º xxx çš„é—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ O(x)O(x)O(x) å’Œ O(nx)O(\\frac{n}{x})O(xnâ€‹) çš„å¤æ‚åº¦è§£å†³ï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ xâ‰¤nx\\le \\sqrt{n}xâ‰¤nâ€‹ æ—¶ä½¿ç”¨ O(x)O(x)O(x) ç®—æ³•ï¼Œå¦åˆ™ä½¿ç”¨ O(nx)O(\\frac{n}{x})O(xnâ€‹) ç®—æ³•ã€‚è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä¸º O(nn)O(n\\sqrt{n})O(nnâ€‹)ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™ç§æ€æƒ³å¾ˆå¸¸ç”¨ï¼Œä¸”å¤æ‚åº¦ä¸ä¸€å®šæ˜¯æ ¹å·çš„ã€‚ æ ¹å·å¹³è¡¡ è€ƒè™‘è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼š O(1)O(1)O(1) å•ç‚¹ä¿®æ”¹ï¼ŒO(n)O(\\sqrt{n})O(nâ€‹) æŸ¥è¯¢åŒºé—´å’Œã€‚ ç®€å•ï¼åˆ†å—ç»´æŠ¤å—å†…çš„å’Œï¼Œæ¯æ¬¡ä¿®æ”¹çš„æ—¶å€™æ›´æ–°å—å†…å’Œå³å¯ã€‚ O(n)O(\\sqrt{n})O(nâ€‹) å•ç‚¹ä¿®æ”¹ï¼ŒO(1)O(1)O(1) æŸ¥è¯¢åŒºé—´å’Œã€‚ åˆ†å—ç»´æŠ¤å—å†…å—å¤–å‰ç¼€å’Œï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªå—å†…å‰ xxx ä¸ªæ•°çš„å’Œå’Œå‰ xxx å—çš„å’Œï¼Œé‚£ä¹ˆæŸ¥è¯¢å°±æ˜¯ O(1)O(1)O(1) çš„äº†ã€‚ O(1)O(1)O(1) åŒºé—´ä¿®æ”¹ï¼ŒO(n)O(\\sqrt{n})O(nâ€‹) æŸ¥è¯¢å•ç‚¹ã€‚ å°†ç¬¬ä¸€ä¸ªå·®åˆ†æ‰ç›´æ¥åšå³å¯ã€‚ ç»´æŠ¤ä¸€ä¸ªé›†åˆï¼ŒO(n)O(\\sqrt{n})O(nâ€‹) æ’å…¥æ•°ï¼ŒO(1)O(1)O(1) æŸ¥è¯¢ kkk å°ã€‚ è€ƒè™‘å€¼åŸŸåˆ†å—ï¼Œæ¯ä¸ªæ•°ç»´æŠ¤å…¶æ‰€åœ¨çš„å—ï¼Œå¯¹å—ç»´æŠ¤ä¸€ä¸ªæœ‰åºè¡¨ï¼Œæ’å…¥çš„æ—¶å€™ç›´æ¥å½’å¹¶ï¼Œkkk å°å°±å¯ä»¥ç›´æ¥æŸ¥è¯¢ã€‚ å›¾ä¸Šä¸‰å››å…ƒç¯è®¡æ•° æ— å‘å›¾ä¸‰å…ƒç¯è®¡æ•°ã€‚è®©åº¦æ•°å°çš„ç‚¹å‘åº¦æ•°å¤§çš„ç‚¹è¿è¾¹ï¼Œç„¶åæš´åŠ› for æŸ¥æ‰¾ã€‚å¦‚æœä¸€ä¸ªç‚¹çš„åº¦æ•°å¤§äº m\\sqrt{m}mâ€‹ï¼Œè¿™æ ·çš„ç‚¹ä¸è¶…è¿‡ m\\sqrt{m}mâ€‹ ä¸ªï¼›å¦‚æœä¸€ä¸ªç‚¹åº¦æ•°å°äº m\\sqrt{m}mâ€‹ï¼Œé‚£ä¹ˆè¿™æ ·çš„ç‚¹æœ€å¤š mmm ä¸ªã€‚å› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º O(mm)O(m\\sqrt{m})O(mmâ€‹)ã€‚ int n, m, ans, deg[100005]; int u[200005], v[200005], vis[100005]; vector&lt;int> G[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", u + i, v + i); ++deg[u[i]]; ++deg[v[i]]; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x = u[i], y = v[i]; if (deg[x] > deg[y] || (deg[x] == deg[y] &amp;&amp; x > y)) swap(x, y); G[x].emplace_back(y); &#125; for (int u = 1; u &lt;= n; ++u) &#123; for (int v : G[u]) vis[v] = u; for (int v : G[u]) for (int w : G[v]) if (vis[w] == u) ++ans; &#125; printf(\"%d\\n\", ans); return 0; &#125; å››å…ƒç¯è®¡æ•°ã€‚æ•´ä½“æ€è·¯è·Ÿä¸‰å…ƒç¯è®¡æ•°ä¸€æ ·ï¼Œè€ƒè™‘æ€æ ·æ•°çš„ä¸é‡ä¸æ¼ã€‚æšä¸¾ä¸€ä¸ªèµ·ç‚¹ uuuï¼Œä¿è¯å®ƒæ˜¯æ’åæœ€å¤§çš„ç‚¹ï¼Œç„¶åæšä¸¾ä¸å®ƒè·ç¦»ä¸º 222 çš„ç‚¹ï¼Œç»Ÿè®¡å…¶ä¸­æ— åºå¯¹ (x,y)(x,y)(x,y) çš„ä¸ªæ•°å³å¯ã€‚ä»£ç ã€‚ bitset ä¼˜åŒ– bitset å¯ä»¥ä½¿ç”¨ string æ¥èµ‹åˆå€¼ï¼š bitset&lt;N> b(string(\"000100101\")); ä½¿ç”¨ set() å°† bitset èµ‹å€¼ä¸ºå…¨ 111ï¼Œreset() å°† bitset æ¸…ç©ºã€‚ bitset å¯ä»¥è¿›è¡Œéšæœºè®¿é—®ï¼Œæ˜¯ O(1)O(1)O(1) çš„ã€‚è€Œå…¶æ‰€æœ‰ä½è¿ç®—æ“ä½œéƒ½æ˜¯ O(nw)O\\left(\\frac n w\\right)O(wnâ€‹) çš„ã€‚cin, cout éƒ½å¯ä»¥ç›´æ¥è¾“å…¥è¾“å‡º bitsetã€‚ å¯ä»¥ä½¿ç”¨ b.to_ullong() æ¥å°†å…¶è½¬åŒ–ä¸º u64 ç±»å‹ã€‚ å¯ä»¥ä½¿ç”¨ _Find_first() å’Œ _Find_next(x) æ¥æ‰¾åˆ°ç¬¬ä¸€ä¸ªå’Œä¸‹ä¸€ä¸ªä¸º 1 çš„ä½ç½®ã€‚ CF1584Bã€‚å¦‚æœå‰ kkk ä¸ªèƒ½æ°å¥½è¢«è§£é”ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯ âˆ‘i=1kaiâˆ’(kâˆ’1)\\sum_{i=1}^k a_i - (k-1)âˆ‘i=1kâ€‹aiâ€‹âˆ’(kâˆ’1)ã€‚å¯¹äºè§£é”æƒ…å†µå¯ä»¥ä½¿ç”¨ DP æ¥è§£å†³ï¼šè®¾ fif_ifiâ€‹ ä»£è¡¨å‰ç¼€ iii æ˜¯å¦æ°å¥½èƒ½è¢«è§£é”ï¼Œé‚£ä¹ˆ fj+aiâ†fj(jâ‰¥i)f_{j+a_i}\\leftarrow f_j(j\\ge i)fj+aiâ€‹â€‹â†fjâ€‹(jâ‰¥i)ï¼Œè¿™ä¸ªè¿‡ç¨‹å¯ä»¥ä½¿ç”¨ bitset åŠ é€Ÿã€‚ä»£ç ã€‚ å¯è¡Œæ€§èƒŒåŒ… CF1856Eã€‚åªè¦æ›´æ”¹å­æ ‘å†…çš„æƒå€¼åˆ†å¸ƒï¼Œå°±å¯ä»¥è¾¾åˆ°è´¡çŒ®æœ€å¤§åŒ–ï¼Œæ‰€ä»¥æ˜¯ä¸ªæ ‘ä¸ŠèƒŒåŒ…çŠ¶ç‰©ï¼Œå¯ä»¥é€šè¿‡ E1ï¼Œä»£ç ã€‚ å¯¹äº E2ï¼Œæˆ‘ä»¬è¦æ€è€ƒå¦‚ä½•é«˜æ•ˆè§£å†³â€œæŠŠå„¿å­å¤§å°æ„æˆçš„æ•°é›†åˆåˆ†æˆå·®å°½å¯èƒ½å°çš„ä¸¤éƒ¨åˆ†â€ã€‚å­æ ‘ä¸­ä¸åŒçš„ sizsizsiz æœ€å¤šåªæœ‰ n\\sqrt{n}nâ€‹ ç§ï¼ŒäºŒè¿›åˆ¶æ‹†åˆ†æ‰ä¿è¯ç‰©å“ä¸ªæ•°ä¸å¤šäº logâ¡n\\log nlogn ä¸ªï¼Œç„¶åæ˜¯å¯è¡Œæ€§èƒŒåŒ…é‡‡ç”¨ bitset ä¼˜åŒ–ï¼Œå•æ¬¡æ—¶é—´å¤æ‚åº¦æ˜¯ O(nnw)O\\left(\\dfrac{n\\sqrt{n}}{w}\\right)O(wnnâ€‹â€‹) çš„ã€‚ ä»¥ä¸‹æ˜¯ bitset å®ç°å¯è¡Œæ€§èƒŒåŒ…çš„ä»£ç ï¼š bitset&lt;524288> b; b = 0; b[0] = 1; for (int x : a) b |= (b &lt;&lt; x); å¦‚ä½•å°†å…¶æ¬åˆ°æ ‘ä¸Šï¼Ÿç®€å•ã€‚å¦‚æœå­˜åœ¨ä¸€ä¸ªé‡å„¿å­ï¼Œå®ƒæ¯”æ‰€æœ‰è½»å„¿å­éƒ½é‡ï¼Œè¿™æ ·å¯ä»¥ç›´æ¥å¾—å‡ºç­”æ¡ˆã€‚å¦åˆ™ä¼šé€ æˆä¸€ä¸ªåˆ†æ²»çš„æ•ˆæœï¼Œæ¯æ¬¡é—®é¢˜è§„æ¨¡å¿…å®šå‡åŠï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nnlogâ¡nw)O\\left(\\dfrac{n\\sqrt{n}\\log n}{w}\\right)O(wnnâ€‹lognâ€‹)ã€‚å®é™…æ•ˆç‡éå¸¸é«˜ã€‚ä»£ç ã€‚ å­—ç¬¦ä¸²åŒ¹é… å‡å®šæ–‡æœ¬ä¸²ä¸º sssï¼Œå¯¹äºæ¯ä¸€ä¸ªå­—ç¬¦å¼€ä¸€ä¸ªå¤§å°ä¸º âˆ£sâˆ£|s|âˆ£sâˆ£ çš„ bitset NcN_cNcâ€‹ã€‚å¯¹äºè¯¢é—®ï¼Œæ–°å»ºä¸€ä¸ª bitsetï¼Œåˆå§‹éƒ½æ˜¯ 111ï¼Œä»å‰åˆ°åæšä¸¾è¯¢é—®ä¸²çš„æ¯ä¸ªä½ç½® yiy_iyiâ€‹ï¼Œå’Œè¿™ä¸ªå­—æ¯å¯¹åº”çš„ bitset å³ç§» iii ä½å–æŒ‰ä½ä¸ï¼Œæœ€åå°±æ˜¯æ‰€æœ‰åŒ¹é…æˆåŠŸçš„ä½ç½®ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(nmw)O\\left(\\frac{nm}{w}\\right)O(wnmâ€‹)ï¼Œè€Œä¸”æ”¯æŒå¸¦ä¿®ï¼Œç›´æ¥ä¿®æ”¹æˆ–è€…ä½ç§» bitset å³å¯ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š char t[N]; bitset&lt;N> a[10], ans, _1, res; int main(void) &#123; int q; scanf(\"%d\", &amp;q); _1.set(); while (q--) &#123; int op, l, r; scanf(\"%d\", &amp;op); if (op == 0) &#123; scanf(\"%d%s\", &amp;l, t); ++l; int m = strlen(t); res = ~(_1 &lt;&lt; l); for (int i = 0; i &lt; 10; ++i) a[i] = (a[i] &amp; _1 &lt;&lt; l) &lt;&lt; m | (a[i] &amp; res); for (int i = 0; i &lt; m; ++i) a[t[i] - '0'][l + i] = 1; &#125; else if (op == 1) &#123; scanf(\"%d%d\", &amp;l, &amp;r); ++l; res = ~(_1 &lt;&lt; l); for (int i = 0; i &lt; 10; ++i) a[i] = (a[i] &amp; _1 &lt;&lt; r + 1) >> r - l + 1 | (a[i] &amp; res); &#125; else &#123; scanf(\"%d%d%s\", &amp;l, &amp;r, t); ++l; int m = strlen(t); if (m > r - l + 1) &#123; puts(\"0\"); continue; &#125; ans.set(); for (int i = 0; i &lt; m; ++i) ans &amp;= a[t[i] - '0'] >> i; printf(\"%d\\n\", (ans >> l).count() - (ans >> r - m + 2).count()); &#125; &#125; return 0; &#125; çŸ©é˜µä¹˜æ³• å¯¹äºå®šä¹‰ä¹˜æ³•ä¸ºä¸è¿ç®—ï¼ŒåŠ æ³•ä¸ºæˆ–è¿ç®—çš„å¹¿ä¹‰çŸ©é˜µä¹˜æ³•å¯ä»¥ä½¿ç”¨ bitset ä¼˜åŒ–ã€‚ [CF576D] Flights for Regular Customersã€‚ä¸€å¼  nnn ä¸ªç‚¹ mmm æ¡è¾¹çš„æœ‰å‘å›¾ï¼Œèµ·ç‚¹ä¸º 111ï¼Œç»ˆç‚¹ä¸º nnnã€‚åªæœ‰èµ°è¿‡äº†è‡³å°‘ did_idiâ€‹ æ¡è¾¹æ‰èƒ½èµ°ç¬¬ iii æ¡è¾¹ï¼Œé—®æœ€çŸ­è·ç¦»ã€‚n,mâ‰¤150n,m \\le 150n,mâ‰¤150ï¼Œdiâ‰¤109d_i \\le 10^9diâ€‹â‰¤109ã€‚ æŒ‰ç…§è¾¹æƒä»å°åˆ°å¤§æ’åºï¼Œç„¶åä¾æ¬¡è€ƒè™‘ã€‚ç»´æŠ¤ä¸€ä¸ªæ•°ç»„ä»£è¡¨å½“å‰èƒ½åˆ°è¾¾çš„èŠ‚ç‚¹ï¼Œç„¶åæ¯æ¬¡æ›´æ–°å½“å‰æ—¶é—´ï¼Œâ€œè§£é”â€æ¯ä¸€æ¡è¾¹ã€‚ å¦‚æœæˆ‘çŸ¥é“å½“å‰çš„å¯è¾¾æ€§ï¼Œé‚£ä¹ˆæˆ‘è¦çŸ¥é“èµ°ä¸€æ¡è¾¹çš„å¯è¾¾æ€§ï¼Œç”¨ bitset åŠ é€Ÿéœ€è¦è®°å½•æ‰€æœ‰çš„å…¥è¾¹ï¼Œå› æ­¤å»ºåå›¾å³å¯ã€‚ int n, m; i64 d[N]; struct Edge &#123; int u, v, w; bool operator&lt; (const Edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[N]; bitset&lt;N> vis; struct Matrix &#123; bitset&lt;N> a[N]; friend bitset&lt;N> operator* (const bitset&lt;N> &amp;x, const Matrix &amp;y) &#123; bitset&lt;N> r; for (int i = 1; i &lt;= n; ++i) r[i] = (x &amp; y.a[i]).any(); return r; &#125; friend Matrix operator* (const Matrix &amp;x, const Matrix &amp;y) &#123; Matrix z; for (int i = 1; i &lt;= n; ++i) for (int k = 1; k &lt;= n; ++k) if (x.a[i][k]) z.a[i] |= y.a[k]; return z; &#125; &#125; a; inline void poww(Matrix a, int b, bitset&lt;N> &amp;ans) &#123; for (; b; b >>= 1, a = a * a) if (b &amp; 1) ans = ans * a; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); sort(e + 1, e + m + 1); i64 ans = INF; vis[1] = 1; for (int i = 1, t = 0; i &lt;= m; ++i) &#123; if (e[i].w >= ans) break; poww(a, e[i].w - t, vis); a.a[e[i].v][e[i].u] = 1; t = e[i].w; queue&lt;int> q; for (int x = 1; x &lt;= n; ++x) if (vis[x]) q.push(x), d[x] = 0; else d[x] = INF; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v = 1; v &lt;= n; ++v) if (a.a[v][u] &amp;&amp; d[v] == INF) d[v] = d[u] + 1, q.emplace(v); &#125; ans = min(ans, t + d[n]); &#125; if (ans == INF) puts(\"Impossible\"); else printf(\"%lld\\n\", ans); return 0; &#125; ååº å¯ä»¥ç”¨æ¥è§£å†³é«˜ç»´ååºé—®é¢˜ï¼Œè®¾æ±‚è§£ mmm ç»´ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ä¸º O(n2mw)O\\left(\\frac{n^2m}{w}\\right)O(wn2mâ€‹)ï¼Œä¹Ÿå°±æ˜¯ä¸€ç»´ååºåš mmm è½®ï¼Œæ¯è½®æ¯”è¾ƒæ¯ä¸ªæ•°ï¼Œç„¶åæŠŠè¿™ mmm è½®çš„ç»“æœéƒ½ä¸èµ·æ¥ã€‚å¯èƒ½éœ€è¦é€å—å¤„ç† bitsetã€‚æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š int n; int p[3][N], a[3][N], w[N]; bitset&lt;N> b[10005], s; int main(void) &#123; scanf(\"%d%*d\", &amp;n); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; 3; ++j) scanf(\"%d\", a[j] + i), p[j][i] = i; for (int i = 0; i &lt; 3; ++i) sort(p[i] + 1, p[i] + n + 1, [i](int x, int y) &#123; return a[i][x] &lt; a[i][y]; &#125;); // æŒ‰æ¯ä¸€ç»´æ’åº for (int l = 1, r = 0; l &lt;= n; l = r + 1) &#123; r = min(l + 10000, n); for (int i = l; i &lt;= r; ++i) b[i - l].set(); for (int i = 0; i &lt; 3; ++i) &#123; s.reset(); for (int j = 1, k = 1; j &lt;= n; ++j) &#123; int o = p[i][j]; for (; k &lt;= n &amp;&amp; a[i][p[i][k]] &lt;= a[i][o]; ) s[p[i][k++]] = 1; if (l &lt;= o &amp;&amp; o &lt;= r) b[o - l] &amp;= s; &#125; &#125; for (int i = l; i &lt;= r; ++i) ++w[b[i - l].count()]; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", w[i]); return 0; &#125; æœ‰å‘å›¾è¿é€šæ€§ bitset å¯ä»¥åŠ é€Ÿä¼ é€’é—­åŒ…çš„è®¡ç®—ï¼ˆé€šå¸¸æ˜¯åŠ é€Ÿ Floydï¼‰ï¼Œå¦ä¸€ä¸ªé«˜æ•ˆåšæ³•æ˜¯ç¼©ç‚¹å bitset åŠ é€Ÿ BFSã€‚ for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) if (b[i][k]) b[i] |= b[k]; é€å—å¤„ç† bitset æœ‰æ—¶ç›´æ¥å¼€ nnn ä¸ª bitset ä¼š MLEï¼Œå› æ­¤è€ƒè™‘æ¯æ¬¡åªå¤„ç† BBB ä¸ª bitsetï¼Œç„¶åå¤„ç† nB\\frac n BBnâ€‹ æ¬¡å³å¯ã€‚ ä¾‹é¢˜ ä»¥ä¸‹å†…å®¹å°†å‘Šè¯‰ä½  bitset ä¸ºä»€ä¹ˆæ˜¯ç¥ã€‚ [Luogu P6328] æˆ‘æ˜¯ä»™äººæŒ Portal. ç”¨ bitset æ±‚å›¾çš„å¯è¾¾æ€§çš„æ¨¡æ¿ã€‚ä»£ç ã€‚ * [CF1239E] Turtle Portal. ç”±äºç¬¬ä¸€è¡Œèµ°çš„æ˜¯å‰ç¼€å’Œï¼Œç¬¬äºŒè¡Œèµ°çš„æ˜¯åç¼€å’Œï¼Œå› æ­¤å°†ç¬¬ä¸€è¡Œæ’ä¸ºä¸é™ï¼Œç¬¬äºŒè¡Œæ’ä¸ºä¸å‡ã€‚è¿™æ ·å®ƒè¦ä¹ˆåœ¨ 111 å¾€ä¸‹èµ°ï¼Œè¦ä¹ˆåœ¨ nnn å¾€ä¸‹èµ°ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œå»æ‰ a1,a2a_1,a_2a1â€‹,a2â€‹ åï¼Œå°†å‰©ä¸‹æ•°åˆ†ä¸ºä¸¤å † A,BA,BA,Bï¼Œæœ€å°åŒ– maxâ¡{âˆ‘A,âˆ‘B}\\max\\{\\sum A,\\sum B\\}max{âˆ‘A,âˆ‘B}ã€‚ è€ƒè™‘ DPï¼Œfi,j,kf_{i,j,k}fi,j,kâ€‹ è¡¨ç¤ºå‰ iii ä¸ªæ•°ï¼Œjjj ä¸ªæ”¾å…¥ AAAï¼Œâˆ‘A=k\\sum A=kâˆ‘A=k çš„å­˜åœ¨æ€§ã€‚å¯¹ (i,j)(i,j)(i,j) å¼€å¤§å°ä¸º kkk çš„ bitsetï¼Œç›´æ¥è½¬ç§»å³å¯ã€‚ä»£ç ã€‚ * [JSOI2015] æœ€å°è¡¨ç¤º Portal. æ³¨æ„åˆ°å›¾æ˜¯ä¸€ä¸ª DAGï¼Œå› æ­¤å¯¹äºä¸€æ¡è¾¹ (u,v)(u,v)(u,v)ï¼Œå¦‚æœåˆ äº†è¿™æ¡è¾¹ä¾ç„¶å­˜åœ¨ uâ†’vu\\rightarrow vuâ†’v çš„é—´æ¥è·¯å¾„ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹å¿…å®šè¢«åˆ å»ã€‚ å¯¹äºæ¯ä¸ªç‚¹æ±‚å‡ºå®ƒèƒ½åˆ°è¾¾çš„ç‚¹å’Œèƒ½åˆ°è¾¾å®ƒçš„ç‚¹ï¼ˆä¸å«è‡ªå·±ï¼‰ã€‚å¦‚æœ uuu èƒ½åˆ°è¾¾çš„ç‚¹å’Œèƒ½åˆ° vvv çš„ç‚¹æœ‰äº¤é›†ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹å¯ä»¥è¢«åˆ å»ã€‚ å‰è€…æ¯ä¸ªç‚¹ç»´æŠ¤ä¸€ä¸ª bitsetï¼ŒæŒ‰ç…§æ‹“æ‰‘åºä»å¤§åˆ°å°è½¬ç§»å³å¯ã€‚åè€…å»ºåå›¾åè·Ÿå‰è€…ä¸€æ ·ã€‚æ—¶é—´å¤æ‚åº¦ O(nmw)O\\left(\\frac{nm}{w}\\right)O(wnmâ€‹)ã€‚ä»£ç ã€‚ ç‰¹æ®Šé—®é¢˜å¤„ç†æ–¹æ³• æœ¬èŠ‚ä¼šä»‹ç»ä¸€äº›ç»å…¸é—®é¢˜çš„å¤„ç†æ–¹æ³•ã€‚ ä½è¿ç®— ä½è¿ç®—æœ¬èº«çš„æ€§è´¨å‡ ä¹åªé’ˆå¯¹ä½è¿ç®—æœ¬èº«ï¼Œå› æ­¤å’Œå…¶å®ƒè¿ç®—ç»„åˆèµ·æ¥çš„æ—¶å€™ä¸æ˜¯é‚£ä¹ˆå¥½çœ‹ã€‚ è¿™æ—¶å¾€å¾€è€ƒè™‘æŒ‰ä½å¤„ç†ï¼Œå› ä¸ºè¿™æ ·åªéœ€è¦è€ƒè™‘ 01 ä¸¤ç§æ•°å­—ï¼Œç»å¸¸å¯ä»¥ä½¿ç”¨æ•°æ®ç»“æ„æ¥ç»´æŠ¤ã€‚ æšä¸¾å­é›†å’Œæšä¸¾è¶…é›†ï¼š for (int i = s; i; i = (i - 1) &amp; s) for (int i = s; i &lt;= u; i = (i + 1) | s) æ‹¬å·åºåˆ— å¸¸ç”¨çš„æ€è·¯æ˜¯ä»¤ ( = 1, ) = -1ï¼Œæ€§è´¨ä»€ä¹ˆçš„å¾ˆæ˜¾ç„¶ã€‚ æœ€é•¿ä¸Šå‡å­åºåˆ— å°†ä¸€ä¸ªåºåˆ—æ”¹ä¸ºéä¸¥æ ¼å•è°ƒé€’å¢çš„ï¼Œè‡³å°‘éœ€è¦ä¿®æ”¹è¿™ä¸ªåºåˆ—é•¿åº¦å‡å»å•è°ƒä¸é™å­åºåˆ—çš„é•¿åº¦ã€‚ è€Œä¸¥æ ¼å•è°ƒé€’å¢å‘¢ï¼Ÿè€ƒè™‘ 1 1 2 2 3 3ï¼Œç”¨åºåˆ—é•¿åº¦å‡å»å®ƒçš„ LIS é•¿åº¦æ˜¯é”™è¯¯çš„ã€‚å› æ­¤æ„é€  Bi=Aiâˆ’iB_i=A_i-iBiâ€‹=Aiâ€‹âˆ’i å¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸ºéä¸¥æ ¼å•è°ƒé€’å¢ã€‚ [CF713C] Sonya and Problem Wihtout a Legendã€‚ç»™å®šä¸€ä¸ªæœ‰ n(nâ‰¤106)n(n\\le 10^6)n(nâ‰¤106) ä¸ªæ­£æ•´æ•°çš„æ•°ç»„ï¼Œä¸€æ¬¡æ“ä½œä¸­ï¼Œå¯ä»¥æŠŠä»»æ„ä¸€ä¸ªå…ƒç´ åŠ ä¸€æˆ–å‡ä¸€ï¼Œæ±‚ä½¿å¾—åŸåºåˆ—ä¸¥æ ¼é€’å¢çš„æ±‚æœ€å°æ“ä½œæ¬¡æ•°ã€‚ å…ˆè½¬åŒ–ä¸ºè¦å˜æˆéä¸¥æ ¼å•è°ƒé€’å¢ã€‚å¯¹äºä¹‹å‰çš„æ•°ç»´æŠ¤ä¸€ä¸ªå¤§æ ¹å †ï¼Œå¦‚æœå½“å‰çš„ aia_iaiâ€‹ æ¯”ä¹‹å‰æœ€å¤§çš„æ•°å°ï¼Œé‚£ä¹ˆå°±å°†é‚£ä¸ªæœ€å¤§çš„æ•°å¼ºè¡Œæ”¹ä¸º aia_iaiâ€‹ã€‚å‘ç°è¿™æ ·æ„é€ å‡ºæ¥çš„ç­”æ¡ˆä¸€å®šä¸ä¼šæ›´åŠ£ï¼Œä½†æ˜¯æ˜¯å¦åˆæ³•å‘¢ï¼Ÿ å®šä¹‰â€œå¾®è°ƒâ€ä¸ºåœ¨ä¸æ”¹å˜èŠ±è´¹çš„å‰æä¸‹æ”¹å˜æ•°å¯¹çš„å€¼ã€‚æˆ‘ä»¬ç°åœ¨è¦æ‰¾å°† yyy ä¿®æ”¹ä¸º xxx åæ˜¯å¦ä¼šä½¿å¾—ä¸€ä¸ª yyy å‰é¢çš„ zzz æ»¡è¶³ z&gt;yz&gt;yz&gt;yã€‚ å½“ z&gt;yz&gt;yz&gt;y æ—¶çŸ›ç›¾ï¼Œé‚£ä¹ˆè€ƒè™‘å°† x,yx,yx,y å¾®è°ƒæˆ zzzï¼Œæ­¤æ—¶èŠ±è´¹ä¸º (yâˆ’z)+(zâˆ’x)=yâˆ’x(y-z)+(z-x)=y-x(yâˆ’z)+(zâˆ’x)=yâˆ’xï¼Œè¿™æ ·ç­”æ¡ˆä¾ç„¶åˆæ³•ã€‚ å¦‚ä½•è¾“å‡ºç­”æ¡ˆï¼Ÿä»¤ bib_ibiâ€‹ ä¸º iii æ—¶åˆ»çš„å †é¡¶ï¼Œå¯¹ bbb å–ä¸€éåç¼€æœ€å°å€¼å³å¯ã€‚ for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); q.push(a[i]); if (q.top() > a[i]) &#123; ans += q.top() - a[i]; q.pop(); q.push(a[i]); &#125; b[i] = q.top(); &#125; printf(\"%lld\\n\", ans); for (int i = n - 1; i >= 1; --i) b[i] = min(b[i], b[i + 1]); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", b[i]); æ›¼å“ˆé¡¿ä¸åˆ‡æ¯”é›ªå¤«è·ç¦» æ›¼å“ˆé¡¿è·ç¦»æ˜¯æŒ‡ x,yx,yx,y åæ ‡çš„å·®çš„å’Œï¼Œè€Œåˆ‡æ¯”é›ªå¤«è·ç¦»æŒ‡çš„æ˜¯å·®çš„æœ€å¤§å€¼ã€‚ ä»æ›¼å“ˆé¡¿è·ç¦»è½¬åŒ–æˆåˆ‡æ¯”é›ªå¤«è·ç¦»ï¼Œä»¤ xiâ€²=xi+yi,yiâ€²=xiâˆ’yix_i&#x27;=x_i+y_i,y_i&#x27;=x_i-y_ixiâ€²â€‹=xiâ€‹+yiâ€‹,yiâ€²â€‹=xiâ€‹âˆ’yiâ€‹ï¼Œåç€è½¬çš„æ—¶å€™åè¿‡æ¥è§£ä¸€ä¸‹äºŒå…ƒä¸€æ¬¡æ–¹ç¨‹ç»„å°±è¡Œã€‚ [TJOI2013] æ¾é¼ èšä¼šã€‚ç»™å®šå¹³é¢ä¸Šçš„ nnn ä¸ªç‚¹ï¼Œæ±‚å…¶ä½™ç‚¹åˆ°ä¸€ç‚¹çš„åˆ‡æ¯”é›ªå¤«è·ç¦»ä¹‹å’Œçš„æœ€å°å€¼ã€‚ å®¹æ˜“è§£å‡ºè½¬ä¸ºæ›¼å“ˆé¡¿è·ç¦»åç‚¹çš„åæ ‡ä¸º (x+y2,xâˆ’y2)\\left(\\cfrac{x+y}{2},\\cfrac{x-y}{2}\\right)(2x+yâ€‹,2xâˆ’yâ€‹)ã€‚æšä¸¾ä¸­å¿ƒç‚¹ iiiï¼Œåˆ†åˆ«è®¨è®ºæ¨ªçºµåæ ‡çš„è´¡çŒ®å³å¯ç›´æ¥è®¡ç®—ã€‚ä»£ç ã€‚ æœ‰åºåºåˆ—çš„äº¤æ¢æ•° ç»™å®šä¸€ä¸ªæ’åˆ—ï¼Œè¦è®©å®ƒå˜å¾—æœ‰åºã€‚ æ¯æ¬¡äº¤æ¢ä¸€ä¸ªç›¸é‚»æ•°ï¼Œæœ€å°æ“ä½œæ•°æ˜¯é€†åºå¯¹æ•°ã€‚ æ¯æ¬¡äº¤æ¢ä¸€ä¸ªä»»æ„æ•°ï¼Œæœ€å°æ“ä½œæ•°æ˜¯åºåˆ—é•¿åº¦å‡ç½®æ¢ç¯æ•°ã€‚ å¸¸ç”¨å…¬å¼ å¹³æ–¹å’Œå…¬å¼æ–æ³¢é‚£å¥‘æ•°åˆ—âˆ‘i=1ni2=n(n+1)(2n+1)6=n(n+12)âˆ’(n+13)\\sum_{i=1}^n i^2 = \\frac{n(n+1)(2n+1)}{6} =n\\binom{n+1}{2} - \\binom{n+1}{3} i=1âˆ‘nâ€‹i2=6n(n+1)(2n+1)â€‹=n(2n+1â€‹)âˆ’(3n+1â€‹) è¯æ˜å¦‚ä¸‹ï¼š (n+1)3âˆ’n3=3n2+3n+1â‹¯23âˆ’13=3Ã—12+3Ã—1+1(n+1)^3 - n^3 = 3n^2+3n+1\\\\ \\cdots\\\\ 2^3-1^3=3\\times 1^2 + 3\\times 1 +1 (n+1)3âˆ’n3=3n2+3n+1â‹¯23âˆ’13=3Ã—12+3Ã—1+1 å› æ­¤ï¼š (n+1)3âˆ’1=3âˆ‘i=1ni2+3âˆ‘i=1ni+n(n+1)^3-1=3\\sum_{i=1}^n i^2 + 3\\sum_{i=1}^n i+n (n+1)3âˆ’1=3i=1âˆ‘nâ€‹i2+3i=1âˆ‘nâ€‹i+n ç§»é¡¹å³å¯ã€‚ç«‹æ–¹å’Œå…¬å¼ä¹Ÿå¯ä»¥è¿™ä¹ˆå¹²ã€‚âˆ‘i=1nfi=fn+2âˆ’f2\\sum_{i=1}^{n}f_i=f_{n+2}-f_{2} i=1âˆ‘nâ€‹fiâ€‹=fn+2â€‹âˆ’f2â€‹ é¢˜è½¦ å¯¹äºå¯¹åº”çš„ç»„åˆ«æ¥è¯´ï¼Œä¸­æ¡£é¢˜ä¼šé™„å¸¦ä¸€ä¸ªæ˜Ÿå·ï¼Œéš¾é¢˜ä¼šé™„å¸¦ä¸¤ä¸ªæ˜Ÿå·ã€‚ åˆ·åŸºç¡€ 1 å·©å›ºæ‰€å­¦å†…å®¹ï¼Œè®­ç»ƒæ€ç»´çš„ç†Ÿç»ƒåº¦ã€å‡†ç¡®åº¦å’Œé€Ÿåº¦ã€‚æœ¬èº«éš¾åº¦ä¸å¤§ã€‚ [CF1114E] Arithmetic Progression Portalã€‚æ“ä½œäºŒç”¨äºäºŒåˆ†å‡ºç­‰å·®æ•°åˆ—çš„æœ€å¤§æ•°ï¼Œéšæœºå‡ ä¸ªæ•°æ±‚å‡ºå…¬å·® gcd å³å¯ã€‚ä»£ç ã€‚ [HNOI2009] æœ€å°åœˆ Portalã€‚åˆ†æ•°è§„åˆ’ï¼ŒSPFA æ£€æŸ¥æ˜¯å¦å­˜åœ¨è´Ÿç¯ã€‚ä»£ç ã€‚ * [CF1354G] Find a Gift Portalã€‚å¦‚æœçŸ¥é“å…¶ä¸­ xxx ä¸ªæ˜¯çŸ³å¤´ï¼Œé‚£ä¹ˆå°±èƒ½ç”¨è¿™ xxx ä¸ªå»ç¡®å®šå¦å¤– xxx ä¸ªæ•°å½“ä¸­æœ‰æ²¡æœ‰çŸ³å¤´ã€‚å…ˆæ‰¾åˆ° 111 ä¸ªçŸ³å¤´ï¼Œç„¶åä»å¤´å¼€å§‹å€å¢æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ²¡æœ‰çŸ³å¤´çš„åŒºé—´ã€‚è¦ç¡®å®šè¿™æ®µæœ‰çŸ³å¤´çš„åŒºé—´çš„ç¬¬ 111 ä¸ªçŸ³å¤´ä½ç½®ï¼Œå¯ä»¥äºŒåˆ†ã€‚å¦‚ä½•æ‰¾åˆ°ä¸€ä¸ªçŸ³å¤´ï¼Ÿä¸çŸ¥é“ï¼Œé‡‡ç”¨éšæœºåŒ–ã€‚éšæœºæ‰¾åˆ°ä¸€äº›ä½ç½®ï¼Œæ‰¾åˆ°å½“ä¸­æœ€é‡çš„ï¼Œé‚£ä¹ˆå¯ä»¥ç¡®å®šé‚£ä¸ªæ˜¯çŸ³å¤´ã€‚ä»£ç ã€‚ * [TJOI2017] å¼‚æˆ–å’Œ Portalã€‚æŒ‰ä½å¤„ç†æœ€ç»ˆç­”æ¡ˆçš„ç¬¬ kkk ä½æ˜¯å¦ä¸º 111ã€‚è®°å½•åºåˆ—çš„å‰ç¼€å’Œï¼Œç¬¬ kkk ä½èƒ½å¦å‡ºç° 111 ä»…è·Ÿå½“å‰ä½å’Œåé¢çš„ä½ä½ï¼ˆéœ€è¦è€ƒè™‘å€Ÿä½ï¼‰æœ‰å…³ï¼Œæ ‘çŠ¶æ•°ç»„ç»´æŠ¤ä½ä½å³å¯ã€‚ä»£ç ã€‚ [CF1175F] The Number of Subpermutations Portalã€‚è€ƒè™‘æšä¸¾ 111 çš„ä½ç½®ï¼Œç„¶åå‘å³æ‰«æœ€å¤§å€¼ï¼Œç”¨å“ˆå¸Œåˆ¤æ–­æ˜¯å¦æ‰€æœ‰æ•°éƒ½æ°å¥½å‡ºç°ä¸€æ¬¡ã€‚è¿™ç§æƒ…å†µç»Ÿè®¡äº†æœ€å¤§å€¼åœ¨ 111 çš„å³è¾¹ï¼Œäºæ˜¯åè¿‡æ¥å†åšä¸€éå³å¯ã€‚ä»£ç ã€‚ [Luogu P5631] æœ€å° mex ç”Ÿæˆæ ‘ Portalã€‚ä¸éš¾æƒ³åˆ°çº¿æ®µæ ‘åˆ†æ²»ï¼Œåœ¨ç­”æ¡ˆå€¼åŸŸä¸Šå»ºç«‹çº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ * [CF1418G] Three Occurrences Portalã€‚æ‰«æçº¿ä»å·¦å¾€å³æ‰«æ‰¾åˆ°æ•°æœ€å¤šå‡ºç°ä¸‰æ¬¡çš„åŒºé—´ï¼Œç„¶åå“ˆå¸Œç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ [CF1795E] Explosions? Portalã€‚æ€»èŠ±è´¹æ›´å°‘ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¸Œæœ›ç‚¸æ‰çš„è¡€é‡æ›´å¤šã€‚å½“å˜æˆä¸€ä¸ªä¸¥æ ¼å•å³°å‡½æ•°çš„æ—¶å€™ï¼ˆä»¤ aiâ†aiâˆ’ia_i\\leftarrow a_i-iaiâ€‹â†aiâ€‹âˆ’i å˜æˆå•å³°æ¥å¤„ç†ï¼‰ï¼Œä¹Ÿå°±æ˜¯ææˆä¸€æ®µä¸€æ®µå…¬å·®ä¸º 111 çš„ç­‰å·®æ•°åˆ—ï¼Œå°±å¯ä»¥ç‚¸äº†ã€‚å®¹æ˜“æƒ³åˆ°é€šè¿‡å•è°ƒæ ˆå¤„ç†è¿™ä¸ªä¸œè¥¿ï¼Œæ­£ååšä¸¤éç„¶ååˆå¹¶å³å¯ã€‚ä»£ç ã€‚ [CF1237D] Balanced Playlist Portalã€‚ç ´ç¯æˆé“¾ï¼Œå•è°ƒé˜Ÿåˆ—ç»´æŠ¤æœ€å¤§å€¼ï¼Œæ ¹æ®æ­¤æ¥åˆ¤æ–­ä»€ä¹ˆæ—¶å€™ç ¸æ‰æ’­æ”¾å™¨å³å¯ã€‚ä»£ç ã€‚ * [CF1500B] Two chandeliers Portalã€‚ç”±äº a,ba,ba,b ä¸­å‡ºç°çš„æ•°å®Œå…¨ä¸åŒï¼Œå› æ­¤è€ƒè™‘æ‰¾å‡ºå®ƒä»¬ç¬¬ä¸€æ¬¡å‡ºç°ç›¸åŒçš„ä½ç½®ï¼Œæœ€åäºŒåˆ† check å³å¯ã€‚æ€ä¹ˆæ‰¾ä½ç½®ï¼Ÿé¦–å…ˆåˆ¤æ‰æ— è§£ï¼Œç„¶å excrt æ‰¾ä½ç½®å³å¯ã€‚ [ARC067D] Yakiniku Restaurants Portalã€‚å‘ç°èµ°çš„å¿…å®šæ˜¯ä¸€æ¡çº¿æ®µã€‚ä»å³ç«¯ç‚¹å¼€å§‹æšä¸¾å·¦ç«¯ç‚¹ï¼Œç»´æŠ¤æ•°ç»„ ansians_iansiâ€‹ è¡¨ç¤ºå³ç«¯ç‚¹åœ¨ iii çš„æœ€ä¼˜ç­”æ¡ˆã€‚æ¯æ¬¡è€ƒè™‘æ˜¯å¦å°†è´¡çŒ®æ¢åˆ°å·¦ç«¯ç‚¹ï¼Œå•è°ƒæ ˆç»´æŠ¤å‰ç¼€æœ€å¤§å€¼æ¥è®¡ç®—è´¡çŒ®å³å¯ã€‚ä»£ç ã€‚ åˆ·åŸºç¡€ 2 å¦ä¸€äº›åŸºç¡€é¢˜ã€‚ [2nd ucup #21] Festival Decorating Portal. æˆ‘ä»¬è€ƒè™‘å¯¹äºæ¯ä¸ªç¯å¼€ä¸€ä¸ª bitset ç»´æŠ¤è·ç¦»å®ƒå³è¾¹ xxx çš„ç¯æ˜¯å¦å­˜åœ¨ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ O(n2/w)O(n^2/w)O(n2/w)ï¼Œç©ºé—´å¼€ä¸ä¸‹ã€‚æˆ‘ä»¬å¯ä»¥æœ‰ 50%50\\%50% çš„è¯¯å·®ï¼Œå› æ­¤å¼€å¯¹æ•°ä¸ª bitsetï¼Œå­˜åˆ°å¯¹æ•°é‡Œå³å¯ã€‚ä»£ç ã€‚ åˆ·æå‡ ç¨æœ‰ä¸€å®šéš¾åº¦çš„é¢˜ç›®ã€‚ [CF232E] Quick Tortoise Portal. ç”±äºè¿™ä¸ªé—®é¢˜å¯ä»¥ç”¨ DP çš„æ–¹å¼è¿›è¡Œæ‰©å±•ï¼Œå› æ­¤ä¸éš¾æƒ³åˆ°ç¦»çº¿ã€‚åˆå‘ç°å…¶å¥½æ‰©å±•ä¸å¥½æ’¤é”€ï¼Œå› æ­¤ä¸éš¾æƒ³åˆ°çŒ«æ ‘åˆ†æ²»å¤„ç†ã€‚ è€ƒè™‘æŒ‰ç…§ xxx åæ ‡è¿›è¡Œåˆ†æ²»ï¼Œè€ƒè™‘ï¼š xxx çš„èµ·ç‚¹ç»ˆç‚¹è·¨è¶Šäº† midmidmidï¼Œè®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ ä»£è¡¨ (i,j)(i,j)(i,j) èƒ½å¦è¾¾åˆ° (mid,k)(mid,k)(mid,k)ï¼Œgi,j,kg_{i,j,k}gi,j,kâ€‹ ä»£è¡¨ (mid,k)(mid,k)(mid,k) èƒ½å¦è¾¾åˆ° (i,j)(i,j)(i,j)ã€‚fff çš„è½¬ç§»ä¸º fi,j,k=fi+1,j,korâ¡fi,j+1,kf_{i,j,k}=f_{i+1,j,k}\\operatorname{or}f_{i,j+1,k}fi,j,kâ€‹=fi+1,j,kâ€‹orfi,j+1,kâ€‹ï¼Œggg åŒç†ï¼Œä¸¤è€…éƒ½å¯ä»¥ä½¿ç”¨ bitset ä¼˜åŒ–ã€‚ å¦åˆ™é€’å½’ä¸‹å»å¤„ç†ã€‚ æ—¶é—´å¤æ‚åº¦ O(nmlogâ¡nw)O\\left(\\cfrac{nm\\log n}{w}\\right)O(wnmlognâ€‹)ã€‚ä»£ç ã€‚ * [CF793E] Problem of offices Portal.ç»™å®šä¸€æ£µæœ‰æ ¹æ ‘ï¼Œç»™å®š (a,b)(a,b)(a,b) å’Œ (c,d)(c,d)(c,d)ã€‚æœ‰ mmm ä¸ªå¶å­ã€‚è¦æ±‚æ„é€ ä¸€ç§æ¬§æ‹‰åºï¼Œp1,p2,â‹¯ ,p2nâˆ’2p_1,p_2,\\cdots,p_{2n-2}p1â€‹,p2â€‹,â‹¯,p2nâˆ’2â€‹ï¼Œä½¿å¾— a,ba,ba,b ä¹‹é—´ç»è¿‡çš„å¶å­ä¸ªæ•°ï¼ˆä¸å«è‡ªå·±ï¼‰æ˜¯ m2âˆ’1\\frac m 2 -12mâ€‹âˆ’1ï¼Œc,dc,dc,d äº¦ç„¶ã€‚åˆ¤æ–­æ˜¯å¦å¯è¡Œã€‚ä¿è¯ a,b,c,da,b,c,da,b,c,d éƒ½ä¸åœ¨æ ¹çš„åŒä¸€å­æ ‘å†…ä¸”éƒ½æ˜¯å¶å­ã€‚ è·¯å¾„ä¸Šçš„å¶å­ä¸ªæ•°ç­‰åŒäºè·¯å¾„å¤–çš„ï¼Œè€Œä¸”æœ‰ä¸¤æ¡è·¯å¾„ï¼Œæ‰‹ç©ä¹‹åä¸éš¾å‘ç°è¿™ä¸¤æ¡è·¯å¾„å¿…å®šç›¸äº¤ï¼Œä¸å¦¨å…ˆä»¤å…¶ä¸º a c b dã€‚ æ¬§æ‹‰åºä¸€å®šä¼šé€‰å–å…¨éƒ¨çš„å­æ ‘ã€‚å¯¹äº a,b,c,da,b,c,da,b,c,d æ¥è¯´ï¼Œå…¶å†…éƒ¨çš„å­æ ‘ä¸€å®šä¼šè¢«é€‰å–ã€‚è€ƒè™‘ aâ†’ba\\rightarrow baâ†’bï¼Œaaa å‘ä¸Šèµ°åˆ°æ ¹ï¼Œè¿™æ¡è·¯å¾„ä¸Šå†…éƒ¨çš„å­æ ‘å¯ä»¥è‡ªç”±å†³å®šæ˜¯å¦è¢«è®¡å…¥ aâ†’ba\\rightarrow baâ†’bï¼Œbbb ä¹Ÿæ˜¯åŒç†ã€‚ä½†å…¶ä¸­ ccc æ‰€å¯¹åº”çš„å­æ ‘çš„ç­”æ¡ˆä¸€å®šè¦è¢«è®¡å…¥ã€‚ câ†’dc\\rightarrow dcâ†’d ä¹Ÿæ˜¯ä¸€æ ·ï¼Œbbb çš„ç­”æ¡ˆä¸€å®šè¦è¢«è®¡å…¥ã€‚æœ€å câ†’bc\\rightarrow bcâ†’b è¿™éƒ¨åˆ†çš„ç­”æ¡ˆæ˜¯ä¸¤æ¡è·¯å¾„çš„äº¤é›†ã€‚ bitset ä¼˜åŒ–å¯è¡Œæ€§èƒŒåŒ…å³å¯ã€‚ä»£ç ã€‚ [AGC020D] Min Max Repetition Portal. å­—ç¬¦ä¸²å¡«å†™çš„æ–¹å¼ä¸éš¾å¾—å‡ºï¼Œæœ€å°è¿ç»­é•¿åº¦ k=maxâ¡{âŒˆAB+1âŒ‰,âŒˆBA+1âŒ‰}k=\\max\\left\\{\\left\\lceil\\cfrac{A}{B+1}\\right\\rceil,\\left\\lceil\\cfrac{B}{A+1}\\right\\rceil\\right\\}k=max{âŒˆB+1Aâ€‹âŒ‰,âŒˆA+1Bâ€‹âŒ‰}ã€‚ å­—ç¬¦ä¸²ä¸€å®šæ˜¯ (AkB)(A^kB)(AkB) çš„ä¸€ä¸ªå‰ç¼€åŠ ä¸Š (ABk)(AB^k)(ABk) çš„ä¸€ä¸ªåç¼€ã€‚å¦‚ä½•æ‰¾åˆ°åˆ†ç•Œç‚¹ï¼Ÿæœ€ä¼˜æƒ…å†µä¸‹åˆ†ç•Œç‚¹ä¸€å®šæ˜¯ä¸€ä¸ª AAAï¼Œæ˜¯å‰åç¼€å…¬ç”¨çš„ã€‚å‡è®¾åˆ†ç•Œç‚¹ä¹‹å‰æœ‰ bbb ä¸ª BBB å’Œ aaa ä¸ª AAAï¼Œé‚£ä¹ˆåº”æ»¡è¶³ bâ‰¤maxâ¡{0,âŒŠaâˆ’1kâŒ‹}b\\le \\max\\left\\{0,\\left\\lfloor\\cfrac{a-1}{k}\\right\\rfloor\\right\\}bâ‰¤max{0,âŒŠkaâˆ’1â€‹âŒ‹}ï¼Œä¹Ÿå°±æ˜¯ a=Aâˆ’âŒˆBâˆ’bkâŒ‰+1a=A-\\left\\lceil\\cfrac{B-b}{k}\\right\\rceil+1a=Aâˆ’âŒˆkBâˆ’bâ€‹âŒ‰+1ã€‚äºŒåˆ†æ‰¾åˆ°æœ€å¤§çš„ bbb å³å¯ç¡®å®šä¸€åˆ‡ã€‚ä»£ç ã€‚ [CF1795G] Removal Sequences Portal. ai=0a_i=0aiâ€‹=0 ä¸€å®šæ˜¯æœ€åè¢«åˆ å»çš„ï¼Œè€ƒè™‘é€†æ—¶æ—…äººï¼Œä»¤ diâ†degâ¡(i)âˆ’aid_i\\leftarrow \\operatorname{deg}(i)-a_idiâ€‹â†deg(i)âˆ’aiâ€‹ï¼ŒæŒ‰ç…§è¿™ä¸ªè¿›è¡Œæ‹“æ‰‘æ’åºå³å¯æ±‚å‡ºä¸€ç»„åˆæ³•è§£ã€‚ è€ƒè™‘æ±‚å‡ºä¸ç¾å¥½çš„ç‚¹å¯¹ï¼Œå¦‚æœè¿™å¼ æœ‰å‘å›¾çš„ä¸¤ä¸ªç‚¹ç›´æ¥äº’ç›¸å¯è¾¾ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸ç¾å¥½çš„ã€‚bitset ç›´æ¥ç»Ÿè®¡å³å¯ã€‚ç”±äºä¼š MLEï¼Œå› æ­¤é€å—å¤„ç†ï¼Œæ¯æ¬¡åªç»Ÿè®¡ 1âˆ¼n1\\sim n1âˆ¼n å¯¹äº lâˆ¼rl\\sim rlâˆ¼r çš„å¯è¾¾æ€§å³å¯ã€‚ä»£ç ã€‚ [ARC065C] Manhattan Compass Portal. å°†æ›¼å“ˆé¡¿è·ç¦»è½¬ä¸ºåˆ‡æ¯”é›ªå¤«è·ç¦»ï¼Œæ’åºäºŒåˆ†ä¸éš¾æ‰¾å‡ºåˆæ³•çš„ç‚¹çš„åŒºé—´ã€‚å¦‚ä½•æ±‚æ–¹æ¡ˆæ•°ï¼Ÿå¯¹äº iii æ‰€å¯¹åº”çš„åˆæ³•åŒºé—´ [l,r][l,r][l,r]ï¼Œiii å‘ lll è¿è¾¹ï¼Œç„¶ååŒºé—´å†…ä¾æ¬¡è¿è¾¹ã€‚å¯¹äºè¿åˆ°äº† aaa ç‚¹çš„ç‚¹ï¼Œå…¶æ–¹æ¡ˆæ•°å‡å¯ä»¥è¢«ç»Ÿè®¡ã€‚ ä¸ºäº†é¿å…é‡å¤ç»Ÿè®¡ï¼Œéœ€è¦æ³¨æ„å¯¹äº yyy ç»Ÿè®¡æ—¶ä¸èƒ½è®¡ç®— xxx ç›¸ç­‰çš„æƒ…å†µã€‚ä»£ç ã€‚ åˆ·ç»¼åˆ ç»¼åˆåº”ç”¨ã€‚ [Ptz 2023 Winter Day 6] 4 Portal. ä¾ç„¶æ˜¯å°åº¦æ•°è¿å‘å¤§åº¦æ•°ã€‚å¯¹äº uuu èƒ½åˆ°è¾¾çš„ç‚¹ vvvï¼Œç»Ÿè®¡ vvv èƒ½åˆ°è¾¾å“ªäº› uuu èƒ½åˆ°è¾¾çš„ç‚¹ã€‚ç„¶åæšä¸¾ä¸‰å…ƒç¯ï¼Œå°±èƒ½ O(m/w)O(\\sqrt{m}/w)O(mâ€‹/w) ç»Ÿè®¡å‡º K4ã€‚ä»£ç ã€‚ [CF1237G] Balanced Distribution Portal. ä¸€ä¸ªé•¿åº¦ä¸º lll çš„åŒºé—´ä¸€å®šå¯ä»¥ç”¨ âŒˆlâˆ’1kâˆ’1âŒ‰\\lceil\\frac{l-1}{k-1}\\rceilâŒˆkâˆ’1lâˆ’1â€‹âŒ‰ æ¬¡æ“ä½œå®Œæˆã€‚å¯ä»¥å…ˆä»¤ aiâ†aiâˆ’avga_i\\leftarrow a_i-avgaiâ€‹â†aiâ€‹âˆ’avgã€‚ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œåˆå¹¶ä¸¤ä¸ªåŒºé—´è¿›è¡Œæ“ä½œçœ‹ä¸Šå»éƒ½ä¸åŠ£ï¼Œä½†ä¸€ç§æƒ…å†µé™¤å¤–ï¼šä¸¤ä¸ªåŒºé—´éƒ½æ»¡è¶³ (kâˆ’1)âˆ£(lâˆ’1)(k-1)\\mid (l-1)(kâˆ’1)âˆ£(lâˆ’1)ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ‡æ–­çš„ä½ç½®çš„å…ƒç´ å‰ç¼€å’Œä¸€å®šç›¸ç­‰ã€‚ å› æ­¤æœ€ä¼˜è§£ç”±è‹¥å¹²æ®µåŒºé—´æ‹¼æˆï¼Œæ¯æ®µéƒ½èƒ½ç‹¬ç«‹æ“ä½œå®Œæˆï¼Œè€Œä¸”æ¯ä¸€æ®µéƒ½æ»¡è¶³ l mod (kâˆ’1)=1,âˆ‘ai=0l\\bmod (k-1)=1,\\sum a_i=0lmod(kâˆ’1)=1,âˆ‘aiâ€‹=0ã€‚å€å¢ç»´æŠ¤è¿™æ ·çš„æ®µï¼Œè´ªå¿ƒå°½å¯èƒ½å¤šçš„é€‰å–è¿™æ ·çš„æ®µã€‚ è¾“å‡ºæ–¹æ¡ˆæ—¶ç›´æ¥ä»å³åˆ°å·¦æšä¸¾æ¯ä¸€æ®µï¼Œæ®µå³è¾¹çš„å†…å®¹å¹³å‡æ•° â‰¥avg\\ge avgâ‰¥avg æ—¶å°±ä»è¿™é‡Œå¼€å§‹å‘å³æ‰«ç­”æ¡ˆï¼Œå°†å¤šä½™æ•°ç•™åœ¨å·¦è¾¹ã€‚ä»£ç ã€‚ * [JSOI2019] ç²¾å‡†é¢„æµ‹ æ— ç›¸å¹½é—­è’™è”½äº†ä½ çš„åŒçœ¼ã€‚å°†äºè¿‘æ—¥è¡¥å……ã€‚ * [NOI2020] åˆ¶ä½œèœå“ é’è›™å¤§é˜Ÿè¸ç¢äº†æ­¤å¤„çš„è’åŸã€‚å°†äºè¿‘æ—¥è¡¥å……ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"æ•°å­¦æ‚é¡¹","slug":"notes/æ•°å­¦/math-iii","date":"2023-03-29T00:00:00.000Z","updated":"2023-03-29T00:00:00.000Z","comments":true,"path":"6dc044c5/","link":"","permalink":"https://james1badcreeper.github.io/6dc044c5/","excerpt":"åœ¨æ•°å­¦å’ŒæŠ½è±¡ä»£æ•°ä¸­ï¼Œç¾¤è®ºï¼ˆGroup Theoryï¼‰ä¸»è¦ç ”ç©¶å«åšâ€œç¾¤â€çš„ä»£æ•°ç»“æ„ã€‚åšå¼ˆè®ºï¼Œæ˜¯ç»æµå­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œä¸»è¦ç ”ç©¶å…·æœ‰ç«äº‰æˆ–å¯¹æŠ—æ€§è´¨çš„å¯¹è±¡ã€‚æœ¬æ–‡å°†ä»‹ç»è¿™ä¸¤å—å†…å®¹ã€‚","text":"åœ¨æ•°å­¦å’ŒæŠ½è±¡ä»£æ•°ä¸­ï¼Œç¾¤è®ºï¼ˆGroup Theoryï¼‰ä¸»è¦ç ”ç©¶å«åšâ€œç¾¤â€çš„ä»£æ•°ç»“æ„ã€‚åšå¼ˆè®ºï¼Œæ˜¯ç»æµå­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œä¸»è¦ç ”ç©¶å…·æœ‰ç«äº‰æˆ–å¯¹æŠ—æ€§è´¨çš„å¯¹è±¡ã€‚æœ¬æ–‡å°†ä»‹ç»è¿™ä¸¤å—å†…å®¹ã€‚ æ”¾åœ¨ä¸€èµ·çš„åŸå› æ˜¯åœ¨ OI ä¸­å®ƒä»¬éƒ½å±äºæ‚é¡¹ã€‚ ç¾¤è®º ç¾¤æ˜¯ç”±ä¸€ç§é›†åˆ GGG ä»¥åŠä¸€ä¸ªäºŒå…ƒè¿ç®—æ‰€ç»„æˆçš„ï¼Œå®ƒçš„äºŒå…ƒè¿ç®—ç”¨ aâ‹…ba\\cdot baâ‹…b è¡¨ç¤ºï¼Œè¦æ±‚æ»¡è¶³ç¾¤å…¬ç†ï¼š å°é—­æ€§ï¼Œâˆ€a,bâˆˆG,aâ‹…bâˆˆG\\forall a,b\\in G, a\\cdot b\\in Gâˆ€a,bâˆˆG,aâ‹…bâˆˆGã€‚ ç»“åˆå¾‹ï¼Œå¯¹äº GGG ä¸­çš„ä»»æ„å…ƒç´ ï¼Œå…¶äºŒå…ƒè¿ç®—éœ€è¦æ»¡è¶³ç»“åˆå¾‹ã€‚ å•ä½å…ƒï¼ŒGGG ä¸­å­˜åœ¨ä¸€ä¸ªå…ƒç´  eeeï¼Œä½¿å¾—å¯¹äº GGG ä¸­çš„ä»»æ„ä¸€ä¸ªå…ƒç´  aaaï¼Œéƒ½æœ‰ä¸€ä¸ª eâ‹…a=aâ‹…e=ae\\cdot a=a\\cdot e=aeâ‹…a=aâ‹…e=a æˆç«‹ã€‚è¿™ä¸ªå…ƒç´ åº”è¯¥æ˜¯å”¯ä¸€çš„ï¼Œè¢«ç§°ä¸ºç¾¤çš„å•ä½å…ƒ eeeã€‚ é€†å…ƒï¼Œå¯¹äº GGG ä¸­çš„ aaaï¼Œæ€»å­˜åœ¨ GGG ä¸­çš„ä¸€ä¸ª bbb æ»¡è¶³ aâ‹…b=bâ‹…a=ea\\cdot b=b\\cdot a=eaâ‹…b=bâ‹…a=eï¼Œç§° bbb ä¸º aaa çš„é€†å…ƒï¼Œè®°ä¸º aâˆ’1a^{-1}aâˆ’1ã€‚ä»»ä½•ä¸€ä¸ªå…ƒç´ çš„é€†å…ƒæ˜¯å”¯ä¸€çš„ã€‚ è¿™æ ·ï¼Œ(G,â‹…)(G,\\cdot)(G,â‹…) è¢«ç§°ä¸ºä¸€ä¸ªç¾¤ã€‚ä¾‹å¦‚ï¼Œ(Z,+)(\\mathbb{Z},+)(Z,+) æ˜¯ä¸€ä¸ªç¾¤ï¼Œe=0e=0e=0ï¼Œä¸€ä¸ªæ•°çš„é€†å…ƒæ˜¯å®ƒçš„ç›¸åæ•°ã€‚ å¦‚æœ (G,â‹…)(G,\\cdot)(G,â‹…) æ»¡è¶³å°é—­æ€§å’Œç»“åˆå¾‹ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªåŠç¾¤ï¼›å¦‚æœè¿˜æ»¡è¶³å•ä½å…ƒï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯å¹ºåŠç¾¤ï¼›å¦‚æœç¾¤ (G,â‹…)(G,\\cdot)(G,â‹…) æ»¡è¶³äº¤æ¢å¾‹ï¼Œå³ âˆ€a,bâˆˆG,aâ‹…b=bâ‹…a\\forall a,b\\in G, a\\cdot b=b\\cdot aâˆ€a,bâˆˆG,aâ‹…b=bâ‹…aï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€ä¸ªé˜¿è´å°”ç¾¤ï¼Œåˆç§°äº¤æ¢ç¾¤ã€‚ ç¯ ç¯æ˜¯ä¸€ä¸ªé›†åˆ RRR åŠå¯¹ RRR çš„ä¸¤ä¸ªäºŒå…ƒè¿ç®—ï¼Œè¿™é‡Œè®°ä½œåŠ æ³•å’Œä¹˜æ³• +,â‹…+,\\cdot+,â‹…ï¼ˆä½†æ˜¯å¹¶ä¸æ˜¯å››åˆ™è¿ç®—ä¸­çš„åŠ ä¹˜ï¼‰ï¼Œè¿™ä¸ªç¯è®°ä½œ (R,+,â‹…)(R,+,\\cdot)(R,+,â‹…)ï¼Œå¹¶æ»¡è¶³å¦‚ä¸‹ä»£æ•°æ€§è´¨ï¼š (R,+)(R,+)(R,+) æ˜¯äº¤æ¢ç¾¤ï¼Œå…¶å•ä½å…ƒè®°ä¸º 000ï¼ŒRRR ä¸­å…ƒç´  aaa çš„åŠ æ³•é€†å…ƒä¸º âˆ’a-aâˆ’aï¼› (R,â‹…)(R,\\cdot)(R,â‹…) æ˜¯åŠç¾¤ï¼› åˆ†é…å¾‹ï¼Œâˆ€a,b,câˆˆR,aâ‹…(b+c)=aâ‹…b+aâ‹…c\\forall a,b,c\\in R,a\\cdot(b+c)=a\\cdot b+a\\cdot câˆ€a,b,câˆˆR,aâ‹…(b+c)=aâ‹…b+aâ‹…cã€‚ å¦‚æœ RRR ä¸­çš„ä¹˜æ³•æ»¡è¶³äº¤æ¢å¾‹ï¼Œé‚£ä¹ˆ RRR æ˜¯äº¤æ¢ç¯ï¼›å¦‚æœ RRR å­˜åœ¨ä¹˜æ³•å•ä½å…ƒ 111ï¼Œé‚£ä¹ˆå®ƒæ˜¯å¹ºç¯ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šè‹¥æ‰€æœ‰éé›¶å…ƒç´  aaa å­˜åœ¨ä¹˜æ³•é€†å…ƒ aâˆ’1a^{-1}aâˆ’1ï¼Œé‚£ä¹ˆ RRR ä¸ºé™¤ç¯ã€‚ åŸŸ ç¾¤çš„åŸºæœ¬æ¦‚å¿µ ç½®æ¢ç¾¤ åšå¼ˆè®º ä¸»è¦ç ”ç©¶ä¸€ä¸ªæ¸¸æˆä¸­å¤šä½ç©å®¶çš„ç­–ç•¥ã€‚ Problemset","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"ç¾¤è®º","slug":"ç¾¤è®º","permalink":"https://james1badcreeper.github.io/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"åšå¼ˆè®º","slug":"åšå¼ˆè®º","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"é›†è®­é˜Ÿä½œä¸š 2020","slug":"default/ioihw-2020","date":"2023-03-23T00:00:00.000Z","updated":"2023-03-23T00:00:00.000Z","comments":true,"path":"a31ed993/","link":"","permalink":"https://james1badcreeper.github.io/a31ed993/","excerpt":"å¼€å§‹åšé›†è®­é˜Ÿä½œä¸šï¼Œä½†æ˜¯æˆ‘æ˜¯èœç‹—ã€‚","text":"å¼€å§‹åšé›†è®­é˜Ÿä½œä¸šï¼Œä½†æ˜¯æˆ‘æ˜¯èœç‹—ã€‚ æ„Ÿè°¢ CYJã€‚ PART I Portal. ç¬¬ä¸€ç»„ 50 é“å¾ˆå¤šï¼Œæä¸€ä¸ªåˆ†å‰²çº¿ã€‚ [CF504E] Misha and LCP on Tree Portal. æ ‘å‰–å°†å­—ç¬¦ä¸²åŒºé—´å–å‡ºï¼Œç„¶åä¸€ä¸ªä¸€ä¸ªåŒ¹é…ï¼ŒåŒ¹é…ä¸äº†çš„å°±äºŒåˆ†ã€‚æˆ‘åœ¨ 2023/3/23 ä¾ç„¶ä¸ä¼š SAï¼Œåªä¼šå“ˆå¸Œï¼Œæ²¡æ•‘äº†ã€‚ä»£ç ã€‚ [CF505E] Mr. Kitayuta vs. Bamboos Portal. äºŒåˆ†ç­”æ¡ˆï¼Œç„¶åå€’ç€åšï¼Œè®¾æ¯ä¸€æ£µç«¹å­åˆå§‹é«˜åº¦ä¸ºäºŒåˆ†å‡ºçš„ MMMï¼Œç„¶åæ¯æ¬¡å‡å» aia_iaiâ€‹ï¼Œä½¿å¾—æœ€ç»ˆç­”æ¡ˆå¤§äºç­‰äº hih_ihiâ€‹ï¼Œå¹¶ä¸”è¿‡ç¨‹ä¸­é«˜åº¦ä¸èƒ½å˜æˆè´Ÿçš„ã€‚ç›´æ¥è´ªå¿ƒå°±è¡Œã€‚ä»£ç ã€‚ * [CF506E] Mr. Kitayutaâ€™s Gift | å‹ç¼© DP è‡ªåŠ¨æœº Portal. è¿™é¢˜ï¼Œå¤ªç‰›é€¼äº†ã€‚ä¸ä¼šã€‚ * [CF512D] Fox And Travelling Portal. ç¯ä¸Šçš„ç‚¹æ˜¯æ ¹æœ¬é€‰ä¸åˆ°çš„ï¼Œå‰©ä¸‹çš„å¯ä»¥åˆ†è§£æˆæ£®æ—ã€‚å¦‚æœä¸€æ£µæ ‘è¿æ¥ç€ä¸¤ä¸ªç¯é‚£ä¹ˆè¿ç€çš„è¿™äº›ç‚¹å°±åºŸæ‰äº†ã€‚ è¿™æ ·æ ‘å¯ä»¥å˜æˆæœ‰æ ¹æ ‘å’Œæ— æ ¹æ ‘ï¼Œéƒ½å¯ä»¥é€šè¿‡æ ‘å½¢èƒŒåŒ…è®¡ç®—å‡ºé€‰ç‚¹çš„æ–¹æ¡ˆæ•°ï¼Œç„¶åå¯ä»¥ç®€å•ç»„åˆèµ·æ¥ã€‚ä»£ç ã€‚ ** [CF516D] Drazil and Morning Exercise Portal. ä¸¤æ¬¡ DFS å¯ä»¥ç®€å•æ±‚å‡º fff æ•°ç»„ï¼Œç„¶åå¼€å§‹ç¥æ¯”äº†ï¼š fff æœ€å°çš„ uuu å°†å…¶ç§°ä¸ºâ€œä¸­å¿ƒç‚¹â€ï¼Œä»¥è¿™ä¸ªç‚¹ä¸ºæ ¹ï¼Œä¸€ä¸ªå­æ ‘ä¸­çš„èŠ‚ç‚¹ä¸€å®šæ¯”è¿™ä¸ªèŠ‚ç‚¹çš„ fff å¤§ï¼Œå› æ­¤å°† fff ä»å¤§åˆ°å°æ’åºï¼Œfff å˜å°çš„è¿‡ç¨‹ä¸­è¿é€šå—çš„èŒƒå›´åªä¼šå˜å¤§ã€‚ æŒ‰ç…§ fff ä»å°åˆ°è¾¾æ’åºï¼Œç›´æ¥åŒæŒ‡é’ˆå¼€æ‰«ï¼Œç„¶åå‘ç°è¿é€šå—åªä¼šä¸æ–­åˆå¹¶ï¼Œå¹¶æŸ¥é›†ç»´æŠ¤å³å¯ã€‚ä»£ç ã€‚ * [CF516E] Drazil and His Happy Friends Portal. è²Œä¼¼æ˜¯ç¥ä»™åŒä½™æœ€çŸ­è·¯ï¼Œçœé€‰ä»¥åå¡«å‘ã€‚ [CF521D] Shop Portal. æœ€åæ±‚çš„æ˜¯ä¹˜ç§¯ï¼Œå› æ­¤ 333 æ“ä½œçš„é¡ºåºæ˜¯æ— æ‰€è°“çš„ã€‚è€ƒè™‘å°† 222 æ“ä½œè½¬åŒ–ä¸º 333 æ“ä½œï¼ˆæ˜¾ç„¶åªä¼šä¸€å¼€å§‹èµ‹å€¼ä¸€æ¬¡ï¼Œè½¬æˆåŠ æ³•å³å¯ï¼‰ã€‚å¯¹äºåŠ æˆ‘ä»¬å¯ä»¥å°†å…¶è½¬åŒ–æˆä¹˜ä¸Šä¸€ä¸ªåˆ†æ•°ï¼Œåˆ†å­æ˜¯åŠ ä¸Šçš„ä¸œè¥¿ï¼Œåˆ†æ¯æ˜¯å‰é¢åŠ ä¸Šçš„å’Œï¼ˆåŒ…æ‹¬åŸæ¥çš„æ•°ï¼‰ï¼Œä¹˜æ³•æ“ä½œä¹˜ä¸Šçš„ä¸œè¥¿åˆ™éƒ½å‡å» 111ã€‚ è¿™æ ·ç®—çš„å…¶å®æ˜¯å¢åŠ çš„é‡ï¼Œç›´æ¥è´ªå¿ƒå³å¯ã€‚ä»£ç ã€‚ [CF526F] Pudding Monsters Portal. å°†é—®é¢˜è½¬åˆ°ä¸€ç»´ä¸Šï¼Œå°±æ˜¯é—®æœ‰å¤šå°‘ä¸ªå­åŒºé—´æ»¡è¶³ maxâ¡âˆ’minâ¡âˆ’lenâ¡=âˆ’1\\max-\\min-\\operatorname{len} = -1maxâˆ’minâˆ’len=âˆ’1ï¼Œå•è°ƒæ ˆç»´æŠ¤åç¼€æœ€å¤§æœ€å°å€¼ï¼Œæ‰«æçº¿åŠ çº¿æ®µæ ‘ç»´æŠ¤ç­”æ¡ˆã€‚ä»£ç ã€‚ ç¬¬äºŒç»„ å˜¿å˜¿å˜¿ï¼ [CF536D] Tavas in Kansas Portal. æ±‚å‡ºæœ€çŸ­è·¯åç›´æ¥ DP å³å¯ã€‚ä»£ç ã€‚ UPD å¯èƒ½ä¸æ›´æ–°äº†ï¼Œä»¥åçš„é›†è®­é˜Ÿä½œä¸šä¼šæ”¾åœ¨åŠ è®­è®°å½•é‡Œã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"åŸºäºè½¬ç§»è¿›è¡Œä¼˜åŒ–çš„ DP","slug":"notes/DP/transfer-dp","date":"2023-03-12T00:00:00.000Z","updated":"2023-10-12T00:00:00.000Z","comments":true,"path":"ab715ea1/","link":"","permalink":"https://james1badcreeper.github.io/ab715ea1/","excerpt":"ä»åŠ¨æ€è§„åˆ’çš„è½¬ç§»å…¥æ‰‹ï¼Œå¯ä»¥ç”¨æ•°æ®ç»“æ„ç›´æ¥ä¼˜åŒ–è½¬ç§»è¿‡ç¨‹ï¼Œæˆ–è€…æ ¹æ®å†³ç­–å•è°ƒæ€§ä½¿ç”¨æ–œç‡ä¼˜åŒ–ã€å››è¾¹å½¢ä¸ç­‰å¼ç­‰ã€‚","text":"ä»åŠ¨æ€è§„åˆ’çš„è½¬ç§»å…¥æ‰‹ï¼Œå¯ä»¥ç”¨æ•°æ®ç»“æ„ç›´æ¥ä¼˜åŒ–è½¬ç§»è¿‡ç¨‹ï¼Œæˆ–è€…æ ¹æ®å†³ç­–å•è°ƒæ€§ä½¿ç”¨æ–œç‡ä¼˜åŒ–ã€å››è¾¹å½¢ä¸ç­‰å¼ç­‰ã€‚ è½¬ç§»ä¼˜åŒ–ç»¼è¿° è¿‡æ—©çš„ä¼˜åŒ–æ˜¯ä¸‡æ¶ä¹‹æºã€‚ å®é™…ä¸Šæœ€å…³é”®çš„äº‹æƒ…æ˜¯æœ‰ä¸€ä¸ªå¥½çš„çŠ¶æ€è®¾è®¡ï¼Œå¦åˆ™ç¬¬ä¸€æ­¥å°±èµ°é”™åé¢å°±å®Œè›‹äº†ã€‚ è®¾è®¡çŠ¶æ€å‰ï¼Œéœ€è¦æ˜ç¡®è®¡ç®—çš„æ˜¯ä»€ä¹ˆä¸œè¥¿ã€‚å¦‚æœçŠ¶æ€è®¾è®¡çš„ä¸å¤Ÿä¼˜ç§€ï¼Œè¦è€ƒè™‘æ›´æ¢ã€‚å¦åˆ™ï¼Œè½¬ç§»ä¼šå˜å¾—ç›¸å½“å›°éš¾ç”šè‡³ä¸å¯åšã€‚åšäº†è¿™ä¹ˆå¤š DP é¢˜ï¼Œè¯»è€…åº”è¯¥æœ‰ä¸€å®šç»éªŒäº†ã€‚ å½“ç„¶ï¼Œéœ€è¦ä¿è¯æ— åæ•ˆæ€§ã€æ»¡è¶³æœ€ä¼˜å­ç»“æ„ã€‚ åœ¨è®¾è®¡å¥½çŠ¶æ€åï¼Œå…ˆä¸æ€¥ç€è®¾è®¡ä¸€ä¸ªå®Œç¾é«˜æ•ˆçš„è½¬ç§»ã€‚å…ˆæƒ³æƒ³æœ€æš´åŠ›çš„è½¬ç§»æ€ä¹ˆå†™ï¼Œç„¶ååœ¨è€ƒè™‘è¿›è¡Œä¼˜åŒ–ï¼Œæ¯”å¦‚åŒ–ç®€å¼å­ã€ä½¿ç”¨æ•°æ®ç»“æ„ã€åˆ†æå…¶å•è°ƒæ€§ç­‰ã€‚ wqs äºŒåˆ† å­¦åå¸¦æƒäºŒåˆ†ã€‚å¸¸ç”¨äº 2D/1D çš„ DPï¼ŒçŠ¶æ€çš„å…¶ä¸­ä¸€ç»´æ˜¯ç‰©å“ä¸ªæ•°ã€‚è¿™æ˜¯å®ƒçš„æ˜æ˜¾æ ‡å¿—ï¼Œå› æ­¤å®ƒæ¯”è¾ƒå¥—è·¯ã€‚fif_ifiâ€‹ è¡¨ç¤ºæ°å¥½ï¼ˆæœ€å¤š/è‡³å°‘ï¼‰é€‰å– iii ä¸ªç‰©å“æ—¶çš„ç­”æ¡ˆï¼Œå¦‚æœ fff æ˜¯å‡¸å‡½æ•°é‚£ä¹ˆåˆ™å¯ä»¥ä½¿ç”¨ wqsã€‚æˆ‘ä»¬å¯ä»¥çŒœæµ‹ï¼š O(nk)O(nk)O(nk) è¿‡ä¸å»å°±æ˜¯å‡¸çš„ã€‚ æˆ–è€…ä¹Ÿå¯ä»¥æ‰“è¡¨ã€‚ ç”±äº fff æ˜¯å‡¸çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é€‰æ‹©äºŒåˆ†æ–œç‡ï¼Œä»¥æ­¤è®¡ç®—å‡ºå®ƒçš„åˆ‡çº¿ã€‚æœ‰æ—¶å®ƒèƒ½ç›´æ¥ç”¨ï¼Œæœ‰æ—¶å¯ä»¥å¯¹ DP è¿›è¡Œé™ç»´ï¼Œæœ‰æ—¶å’Œæ–œç‡ä¼˜åŒ–ç­‰å†…å®¹ä¸€èµ·å‡ºç°ã€‚ å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬ç”»å‡ºæ‰€æœ‰ç‚¹ (i,f(i))(i,f(i))(i,f(i))ï¼Œå‡è®¾å®ƒä»¬æ„æˆä¸€ä¸ªä¸Šå‡¸å£³ã€‚äºŒåˆ†æ–œç‡ kkkï¼Œå‘ç°éšç€ kkk çš„å‡å°ï¼Œç›´çº¿çš„åˆ‡ç‚¹ä¼šè¶Šæ¥è¶Šé å³ã€‚ å› æ­¤äºŒåˆ† kkk ç›´åˆ°æ¨ªåæ ‡åˆ‡åˆ°æˆ‘ä»¬æƒ³è¦çš„ä½ç½®ï¼ˆæ¯”å¦‚æ°å¥½é€‰æ‹© mmm ä¸ªæ•°ï¼‰ï¼Œé‚£ä¹ˆæ­¤æ—¶çš„çºµåæ ‡å°±æ˜¯ç­”æ¡ˆäº†ã€‚ å¦‚ä½•æ±‚å‡ºåˆ‡ç‚¹ï¼Ÿæˆ‘ä»¬å¸Œæœ›è¿™ä¸ªåˆ‡ç‚¹çš„ yyy åæ ‡æœ€å¤§ï¼Œä¹Ÿå°±æ˜¯åœ¨ yyy è½´ä¸Šçš„æˆªè·æœ€å¤§ã€‚è®¾æˆªè·ä¸º g(x)g(x)g(x)ï¼Œé‚£ä¹ˆåˆ‡ç‚¹ (x,f(x))(x,f(x))(x,f(x)) åœ¨ yyy è½´ä¸Šçš„æˆªè·å°±æ˜¯ g(x)=f(x)âˆ’kxg(x)=f(x)-kxg(x)=f(x)âˆ’kxã€‚é—®é¢˜å°±æ˜¯å¦‚ä½•æ±‚å‡º g(x)g(x)g(x) çš„å€¼äº†ã€‚ è€ƒè™‘ g(x)g(x)g(x) çš„æ„ä¹‰ï¼Œç›¸å½“äºé’¦å®šçš„ xxx ä¸ªç‰©å“çš„ä»£ä»·éƒ½æ¯”åŸæ¥å°‘ kkkï¼Œg(x)g(x)g(x) ç›¸å½“äºæ¯ä¸ªç‰©å“ä»£ä»·å‡ kkk ä¹‹åçš„æœ€ä¼˜è§£ã€‚ l,rl,rl,r å¦‚ä½•è°ƒæ•´ï¼Ÿè¦é€¼è¿‘ (m,f(m))(m,f(m))(m,f(m)) å¦‚æœæ­¤æ—¶åˆ‡ç‚¹ (x,f(x))(x,f(x))(x,f(x)) æ»¡è¶³ x&lt;mx&lt;mx&lt;m æ—¶ï¼Œé‚£ä¹ˆåº”è¯¥å°†æ–œç‡å‡å°ï¼Œæ‰èƒ½è®©åˆ‡ç‚¹å³ç§»ã€‚ ä¸‹å‡¸å£³å¤§è‡´æ˜¯ä¸€æ ·çš„ã€‚ ä¸‰ç‚¹è´¡çŒ®å¯èƒ½ä¼šå¯¼è‡´æ— æ³•äºŒåˆ†å‡ºæƒ³è¦çš„æ–œç‡ã€‚ä½†æ˜¯å‘ç°æ— è®ºåˆ‡åˆ°è¿™æ¡çº¿ä¸Šçš„å“ªä¸ªç‚¹ï¼Œéƒ½ä¸å½±å“æœ€ç»ˆç­”æ¡ˆã€‚é‡‡ç”¨ä¸€ä¸ªä¼˜ç§€çš„äºŒåˆ†å†™æ³•å¯ä»¥å®Œå…¨é¿å…è¿™ä¸ªé—®é¢˜ã€‚ æ¦‚è¿° [å›½å®¶é›†è®­é˜Ÿ] Tree Iã€‚ç»™å®šä¸€ä¸ªæ— å‘è¿é€šå›¾ï¼Œæ±‚ä¸€æ£µæ°å¥½æœ‰ kkk æ¡ç™½è¾¹çš„æœ€å°ç”Ÿæˆæ ‘ã€‚nâ‰¤5Ã—104,mâ‰¤105,wâ‰¤100n\\le 5\\times 10^4,m\\le 10^5,w\\le 100nâ‰¤5Ã—104,mâ‰¤105,wâ‰¤100ã€‚ è®¾ç™½è¾¹æ•°é‡ä¸º kkk çš„æœ€å°ç”Ÿæˆæ ‘æ˜¯ f(k)f(k)f(k)ï¼Œé‚£ä¹ˆ fff æ˜¯ä¸€ä¸ªä¸‹å‡¸å‡½æ•°ï¼ˆå…¶å®æŒºæ˜¾ç„¶çš„ï¼‰ã€‚ç›´æ¥ wqs å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, need; struct edge &#123; int u, v, w, c; bool operator&lt; (const edge &amp;a) const &#123; if (w != a.w) return w &lt; a.w; return c &lt; a.c; &#125; &#125; a[100005]; int fa[50005], res; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; bool check(int x) &#123; for (int i = 1; i &lt;= m; ++i) if (a[i].c == 0) a[i].w -= x; sort(a + 1, a + m + 1); for (int i = 1; i &lt;= n; ++i) fa[i] = i; int wc = 0; res = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = find(a[i].u), v = find(a[i].v); if (u == v) continue; fa[u] = v; res += a[i].w; wc += (a[i].c == 0); &#125; for (int i = 1; i &lt;= m; ++i) if (a[i].c == 0) a[i].w += x; return wc >= need; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m >> need; for (int i = 1; i &lt;= m; ++i) cin >> a[i].u >> a[i].v >> a[i].w >> a[i].c, ++a[i].u, ++a[i].v; int L = -500, R = 500, ans; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) ans = res + need * mid, R = mid; else L = mid; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; æ•°æ®ç»“æ„ä¼˜åŒ– DP æ•°æ®ç»“æ„å¾ˆå¤šï¼Œèƒ½ä¼˜åŒ– DP çš„ä¹Ÿä¸å°‘ã€‚æœ¬è´¨æ€æƒ³å°±æ˜¯è¯´ï¼ŒDP çš„å†³ç­–é›†åˆæ˜¯åœ¨å˜åŒ–çš„ï¼Œæˆ‘ä»¬ä½¿ç”¨æ•°æ®ç»“æ„ç»´æŠ¤è¿™ä¸€ä¸ªé›†åˆä»¥å®ç°é«˜é€Ÿä¿®æ”¹å’ŒæŸ¥è¯¢ã€‚ å‰ç¼€å’Œä¼˜åŒ– å½“è½¬ç§»æ–¹ç¨‹ä¸­æœ‰åŒºé—´å’Œä¹‹ç±»çš„å†…å®¹ï¼Œå‰ç¼€å’Œå°±æ´¾ä¸Šç”¨åœºäº†ã€‚ [HAOI2008] æœ¨æ£åˆ†å‰²ã€‚æœ‰ nnn æ ¹æœ‰ä¸åŒé•¿åº¦çš„æœ¨æ£ä¾æ¬¡è¿ç»“äº†ä¸€èµ·ã€‚ç°åœ¨å…è®¸ä½ æœ€å¤šç æ–­ mmm ä¸ªè¿æ¥å¤„ï¼Œç å®Œå nnn æ ¹æœ¨æ£è¢«åˆ†æˆäº†å¾ˆå¤šæ®µï¼Œè¦æ±‚æ»¡è¶³æ€»é•¿åº¦æœ€å¤§çš„ä¸€æ®µé•¿åº¦æœ€å°ï¼Œå¹¶ä¸”è¾“å‡ºæœ‰å¤šå°‘ç§ç çš„æ–¹æ³•ä½¿å¾—æ€»é•¿åº¦æœ€å¤§çš„ä¸€æ®µé•¿åº¦æœ€å°ã€‚ ç¬¬ä¸€é—®å¯ä»¥äºŒåˆ†å‡ºç­”æ¡ˆï¼Œç¬¬äºŒé—®è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨å°†æœ¨æ£åˆ†æˆ iii æ®µï¼Œè€ƒè™‘åˆ°ç¬¬ jjj ä¸ªæœ¨æ£çš„æ–¹æ¡ˆæ•°ã€‚ç„¶åå¯ä»¥åœ¨ iâˆ’1i-1iâˆ’1 æ®µçš„æ–¹æ¡ˆä¸­æ‰¾å‡ºå¯ä»¥æ®µçš„éƒ¨åˆ†å°†æ–¹æ¡ˆæ•°åŠ èµ·æ¥ï¼Œå‰ç¼€å’Œä¼˜åŒ–ä¸€ä¸‹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 10007; int n, m; int a[50005], s[50005]; int f[50005], pre[50005], g[50005]; inline bool check(int x) &#123; int res = 0, len = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] > x) return 0; if (len + a[i] > x) ++res, len = a[i]; else len += a[i]; &#125; return res &lt;= m; &#125; int calc(int x) &#123; // æ€»é•¿åº¦æœ€å¤§ä¸º x int k = 0; for (int i = 1; i &lt;= n; ++i) for (; k &lt; i; ++k) if (s[i] - s[k] &lt;= x) &#123; pre[i] = k; break; &#125; int ans = s[n] &lt;= x; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] &lt;= x) f[i] = 1; g[i] = (g[i - 1] + f[i]) % P; &#125; for (int i = 2; i &lt;= m + 1; ++i) &#123; for (int j = 1; j &lt;= n; ++j) f[j] = (g[j - 1] - g[pre[j] - 1] + P) % P; for (int j = 1; j &lt;= n; ++j) g[j] = (g[j - 1] + f[j]) % P; ans = (ans + f[n]) % P; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), s[i] = s[i - 1] + a[i]; int L = 0, R = s[n] + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) R = mid; else L = mid; &#125; printf(\"%d %d\\n\", R, calc(R)); return 0; &#125; çº¿æ®µæ ‘ä¼˜åŒ– çº¿æ®µæ ‘å¾ˆå¼ºå¤§ï¼Œå¯ä»¥è¿›è¡ŒåŒºé—´æŸ¥è¯¢ï¼Œä¹Ÿå¯ä»¥å¯¹æƒå€¼è¿›è¡Œç»Ÿè®¡ã€‚è¿™å°±æ„å‘³ç€å®ƒèƒ½ä¼˜åŒ–çš„ä¸œè¥¿å¾ˆå¤šã€‚ [CF833B] The Bakery Portal. å°†ä¸€ä¸ªé•¿åº¦ä¸º n(1â‰¤â‰¤35000)n(1\\le \\le 35000)n(1â‰¤â‰¤35000) çš„åºåˆ—åˆ†ä¸º k(1â‰¤kâ‰¤50)k(1\\le k\\le 50)k(1â‰¤kâ‰¤50) æ®µï¼Œä½¿å¾—æ€»ä»·å€¼æœ€å¤§ã€‚ä¸€æ®µåŒºé—´çš„ä»·å€¼è¡¨ç¤ºä¸ºåŒºé—´å†…ä¸åŒæ•°å­—çš„ä¸ªæ•°ã€‚ è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªæ•°ï¼Œåˆ†ä¸º jjj æ®µçš„æ€»ä»·å€¼ã€‚é‡‡ç”¨åˆ·è¡¨æ³•ï¼š f(i,j)f(i,j)f(i,j) æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct Segment_Tree &#123; int T[140005], tag[140005]; inline void pushdown(int o) &#123; if (!tag[o]) return; T[o &lt;&lt; 1] += tag[o], T[o &lt;&lt; 1 | 1] += tag[o]; tag[o &lt;&lt; 1] += tag[o], tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o] += k, tag[o] += k, void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; pushdown(o); int mid = l + r >> 1, res = 0; if (x &lt;= mid) res = max(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = max(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; &#125; T[51]; int n, k, a[35005], pre[35005], lst[35005]; int f[35005][55]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); pre[i] = lst[a[i]], lst[a[i]] = i; for (int j = 0; j &lt; k; ++j) &#123; T[j].update(1, 0, n, pre[i], i - 1, 1); int f = T[j].query(1, 0, n, 0, i - 1); T[j + 1].update(1, 0, n, i, i, f); &#125; &#125; printf(\"%d\\n\", T[k].query(1, 0, n, n, n)); return 0; &#125; æ•´ä½“ DP å½“è½¬ç§»æ–¹ç¨‹å®Œå…¨ç›¸åŒæ—¶ï¼Œå¯ä»¥è€ƒè™‘åˆ©ç”¨çº¿æ®µæ ‘â€œæ•´ä½“â€è¿›è¡Œè½¬ç§»ã€‚ [CF115E] Linear Kingdom Racesã€‚ è®¾ fif_ifiâ€‹ ä¸º 1âˆ¼i1\\sim i1âˆ¼i ä¸­è·å–çš„æœ€å¤§ä»·å€¼ï¼Œæœ‰ fi=maxâ¡0â‰¤j&lt;i{fj+valâ¡(j+1,i)âˆ’costâ¡(j+1,i)}f_i=\\max\\limits_{0\\le j &lt;i} \\{f_j+\\operatorname{val}(j+1,i)-\\operatorname{cost}(j+1,i)\\}fiâ€‹=0â‰¤j&lt;imaxâ€‹{fjâ€‹+val(j+1,i)âˆ’cost(j+1,i)}ã€‚ è½¬ç§»å¼å®Œå…¨ä¸€æ ·ï¼Œè€ƒè™‘æ•´ä½“ DPã€‚çº¿æ®µæ ‘å°† [0,iâˆ’1][0,i-1][0,iâˆ’1] éƒ½å‡å» aia_iaiâ€‹ï¼Œå› ä¸ºå®ƒä»¬ä¼šä¿®å»ºè¿™æ¡é“è·¯ã€‚å¯¹äºæ¯”èµ›æ¥è¯´ï¼Œç»™ [0,lâˆ’1][0,l-1][0,lâˆ’1] åŠ ä¸Šä»·å€¼ï¼Œå› ä¸ºåœ¨è¿™é‡Œå¯ä»¥å¾—åˆ°å®Œæ•´çš„é“è·¯ï¼Œä¹Ÿå°† fif_ifiâ€‹ åŠ å…¥çº¿æ®µæ ‘ã€‚é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯çº¿æ®µæ ‘ä¸Šçš„æœ€å¤§å€¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[200005]; i64 f[200005]; vector&lt;pair&lt;int, int>> c[200005]; i64 T[800005], tag[800005]; inline void maketag(int o, i64 k) &#123; T[o] += k; tag[o] += k; &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, i64 k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, k); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; while (m--) &#123; int x, y, w; cin >> x >> y >> w; c[y].emplace_back(x, w); &#125; for (int i = 1; i &lt;= n; ++i) &#123; update(1, 0, n, 0, i - 1, -a[i]); for (auto [p, v] : c[i]) update(1, 0, n, 0, p - 1, v); f[i] = max(f[i - 1], T[1]); update(1, 0, n, i, i, f[i]); &#125; return cout &lt;&lt; f[n] &lt;&lt; \"\\n\", 0; &#125; å†³ç­–å•è°ƒæ€§ æœ‰äº› DP çš„è½¬ç§»å†³ç­–æ˜¯å…·æœ‰å•è°ƒæ€§çš„ï¼Œè¿™ç§æ—¶å€™å°±å¯ä»¥å¯¹å†³ç­–é›†åˆè¿›è¡Œå•è°ƒæ€§ç»´æŠ¤ã€‚å•è°ƒé˜Ÿåˆ—å¯ä»¥ç»´æŠ¤å†³ç­–å–å€¼èŒƒå›´ä¸Šä¸‹ç•Œå‡å•è°ƒå˜åŒ–ã€‚ wqs äºŒåˆ† äºŒåˆ†é˜Ÿåˆ—å’Œæ ˆ äºŒåˆ†é˜Ÿåˆ—å¸¸ç”¨æ¥ä¼˜åŒ–æœ‰å†³ç­–å•è°ƒæ€§çš„ DP é—®é¢˜ï¼Œè¦æ±‚å¯¹äº i,ji,ji,j çš„æœ€ä¼˜å†³ç­–ç‚¹ pi,pjp_i,p_jpiâ€‹,pjâ€‹ï¼Œè‹¥ i&lt;ji&lt;ji&lt;j åˆ™å¿…æœ‰ piâ‰¤pjp_i\\le p_jpiâ€‹â‰¤pjâ€‹ï¼Œä¸”èƒ½å¿«é€Ÿè®¡ç®—è½¬ç§»è´¡çŒ®ã€‚ å·¥ä½œæ—¶å»ºç«‹ä¸€ä¸ªå‚¨å­˜ (j,l,r)(j,l,r)(j,l,r) çš„é˜Ÿåˆ—ï¼Œä»£è¡¨ lâˆ¼rl\\sim rlâˆ¼r çš„æœ€ä¼˜å†³ç­–ç‚¹æ˜¯ jjjï¼Œè¦ä¿è¯é˜Ÿé¦–çš„ä¸‰å…ƒç»„æ»¡è¶³ lâ‰¥il\\ge ilâ‰¥iã€‚ åŠ å…¥å†³ç­–æ—¶ï¼Œå¦‚æœ iii æ¯”é˜Ÿå°¾çš„ jjj è½¬ç§»åˆ° lll æ›´ä¼˜ï¼Œé‚£ä¹ˆæ„å‘³ç€é˜Ÿå°¾çš„ä¸‰å…ƒç»„åºŸäº†ï¼å¹²çƒ‚å®ƒï¼Œç›´åˆ°å‰©ä¸‹æœ€åçš„ä¸‰å…ƒç»„ã€‚ å–å‡ºé˜Ÿå°¾ä¸‰å…ƒç»„ï¼Œè¦æ‰¾åˆ°ä¸€ä¸ªä½ç½® pppï¼Œä½¿å¾— ppp ä»¥å‰ä» jjj è½¬ç§»æ›´ä¼˜ï¼Œppp ä»¥åŠä»¥åä» iii è½¬ç§»æ›´ä¼˜ï¼ŒäºŒåˆ†å³å¯ã€‚ [NOI2009] è¯—äººå° Gã€‚å®Œæˆä¸€ä¸ªéœ€è¦å¼€ long doubleã€è¡Œæœ«è¾“å‡ºä¸èƒ½æœ‰ç©ºæ ¼çš„å¤§æ¯’ç˜¤ã€‚ è®¾ fif_ifiâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªè¯—å¥çš„æœ€å°ä»£ä»·ï¼Œæœ‰ fi=minâ¡j=0iâˆ’1{fj+âˆ£siâˆ’sjâˆ’1âˆ’Lâˆ£P}f_i=\\min\\limits_{j=0}^{i-1}\\{f_j+|s_i-s_j-1-L|^P\\}fiâ€‹=j=0miniâˆ’1â€‹{fjâ€‹+âˆ£siâ€‹âˆ’sjâ€‹âˆ’1âˆ’Lâˆ£P}ã€‚ç„¶åäºŒåˆ†é˜Ÿåˆ—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long double ldb; const ldb INF = 1e18; ldb poww(ldb a, int b) &#123; ldb r = 1; for (; b; b >>= 1, a = a * a) if (b &amp; 1) r = r * a; return r; &#125; int n, LEN, P, g[100005], s[100005]; char a[100005][35]; ldb f[100005]; ldb val(int i, int j) &#123; return f[i] + poww(abs(s[j] - s[i] - 1 - LEN), P); &#125; struct Node &#123; int j, l, r; &#125; Q[100005]; int L, R; void print(int x) &#123; if (!x) return; print(g[x]); for (int i = g[x] + 1; i &lt;= x; ++i) printf(\"%s%c\", a[i], i == x ? '\\n' : ' '); &#125; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;LEN, &amp;P); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", a[i]); s[i] = s[i - 1] + strlen(a[i]) + 1; &#125; Q[L = R = 1] = &#123;0, 1, n&#125;; for (int i = 1; i &lt;= n; ++i) &#123; while (L &lt; R &amp;&amp; Q[L].r &lt; i) ++L; Q[L].l = i; int j = Q[L].j; g[i] = j; f[i] = val(j, i); while (L &lt; R &amp;&amp; val(i, Q[R].l) &lt;= val(Q[R].j, Q[R].l)) --R; int LL = Q[R].l - 1, RR = Q[R].r + 2; while (LL + 1 != RR) &#123; int mid = LL + RR >> 1; if (val(i, mid) &lt;= val(Q[R].j, mid)) RR = mid; else LL = mid; &#125; if (RR &lt;= n) Q[R].r = RR - 1, Q[++R] = &#123;i, RR, n&#125;; &#125; if (f[n] > INF) puts(\"Too hard to arrange\"); else printf(\"%lld\\n\", (long long)f[n]), print(n); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(), puts(\"--------------------\"); return 0; &#125; å››è¾¹å½¢ä¸ç­‰å¼ åˆ†æ²»ä¼˜åŒ– æ–œç‡ä¼˜åŒ– Problemset","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"å•è°ƒé˜Ÿåˆ—","slug":"å•è°ƒé˜Ÿåˆ—","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"wqs äºŒåˆ†","slug":"wqs-äºŒåˆ†","permalink":"https://james1badcreeper.github.io/tags/wqs-%E4%BA%8C%E5%88%86/"},{"name":"æ–œç‡ä¼˜åŒ–","slug":"æ–œç‡ä¼˜åŒ–","permalink":"https://james1badcreeper.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"},{"name":"å››è¾¹å½¢ä¸ç­‰å¼","slug":"å››è¾¹å½¢ä¸ç­‰å¼","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/"},{"name":"æ•°æ®ç»“æ„ä¼˜åŒ–","slug":"æ•°æ®ç»“æ„ä¼˜åŒ–","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/"}]},{"title":"å—çŠ¶æ•°æ®ç»“æ„","slug":"notes/DS/sqrt-algorithm","date":"2023-03-01T00:00:00.000Z","updated":"2023-03-01T00:00:00.000Z","comments":true,"path":"f2886e9e/","link":"","permalink":"https://james1badcreeper.github.io/f2886e9e/","excerpt":"åˆ†å—ï¼ˆåˆç§°æ ¹å·ç®—æ³•ï¼Œå› ä¸ºå•æ¬¡æ“ä½œå¤æ‚åº¦æ˜¯æ ¹å·çº§åˆ«ï¼‰ï¼Œæ˜¯ä¸€ç§é‡è¦çš„æ€æƒ³ï¼Œå¯ä»¥ç”¨æ¥è§£å†³è¾ƒä¸ºç®€å•çš„é¢˜ç›®ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥è§£å†³å„ç§å¯æ€•çš„é—®é¢˜ã€‚å°½ç®¡å¦‚æ­¤ï¼Œåˆ†å—çš„æ€æƒ³ä¸éš¾ç†è§£ã€‚","text":"åˆ†å—ï¼ˆåˆç§°æ ¹å·ç®—æ³•ï¼Œå› ä¸ºå•æ¬¡æ“ä½œå¤æ‚åº¦æ˜¯æ ¹å·çº§åˆ«ï¼‰ï¼Œæ˜¯ä¸€ç§é‡è¦çš„æ€æƒ³ï¼Œå¯ä»¥ç”¨æ¥è§£å†³è¾ƒä¸ºç®€å•çš„é¢˜ç›®ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥è§£å†³å„ç§å¯æ€•çš„é—®é¢˜ã€‚å°½ç®¡å¦‚æ­¤ï¼Œåˆ†å—çš„æ€æƒ³ä¸éš¾ç†è§£ã€‚ å¤§å®¶åœ¨æ•°æ®ç»“æ„ä¸­åº”è¯¥éƒ½å¬è¯´è¿‡åˆ†å—ï¼Œå› ä¸ºåµŒå¥—æ•°æ®ç»“æ„ã€åˆ†å—æ•°æ®ç»“æ„å’Œå¯æŒä¹…åŒ–æ•°æ®ç»“æ„èƒŒç§°ä¸ºæ•°æ®ç»“æ„ä¸‰å¤§æ¯’ç˜¤é‡è¦æ€æƒ³ã€‚ä½†å®é™…ä¸Šï¼Œé™¤äº†åœ¨æ•°æ®ç»“æ„ä¸­çš„åº”ç”¨ï¼Œåˆ†å—åœ¨å…¶å®ƒæ–¹é¢ä¹Ÿæœ‰è®¸å¤šåº”ç”¨ã€‚ åˆ†å—åŸºç¡€ åˆ†å—çš„åŸºæœ¬æ€æƒ³æ˜¯ï¼Œé€šè¿‡å¯¹åŸæ•°æ®çš„é€‚å½“åˆ’åˆ†ï¼Œå¹¶åœ¨åˆ’åˆ†åçš„æ¯ä¸€ä¸ªå—ä¸Šé¢„å¤„ç†éƒ¨åˆ†ä¿¡æ¯ï¼Œä»è€Œè¾ƒä¸€èˆ¬çš„æš´åŠ›ç®—æ³•å–å¾—æ›´ä¼˜çš„æ—¶é—´å¤æ‚åº¦ã€‚ è¿™ä¹ˆè¯´å¾ˆç©ºè™šï¼Œæˆ‘ä»¬é€šè¿‡å‡ é“å…¥é—¨é¢˜æ¥ä¸€ä¸€çœ‹ä¸€ä¸‹åˆ†å—çš„ç®€å•åº”ç”¨ã€‚ æ•°åˆ—åˆ†å—å…¥é—¨ è¿™æ˜¯ Loj ä¸Šçš„ä¸€ä¸ªç³»åˆ—é¢˜ã€‚ä½†æ˜¯å‰ä¸¤ä¸ªéƒ½æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥è¿™é‡Œä¸å†™äº†ï¼Œå¤§å®¶å¯ä»¥å­¦ä¹ å®Œä¹‹åå†™ä¸€ä¸‹ç»ƒä¹ ç»ƒä¹ ï¼Œæˆ‘ä»¬å…ˆåšä¸€ä¸‹æœ€ä¸ºç»å…¸çš„ 3ã€‚ Portal. å•Šï¼Œæˆ‘çŸ¥é“ä½ ä¼šæ ‘çŠ¶æ•°ç»„å’Œçº¿æ®µæ ‘ï¼Œæˆ‘ä»¬ä»Šå¤©è¦ç”¨åˆ†å—ä»¥é¾Ÿé€Ÿè§£å†³è¿™é“é¢˜ã€‚ æˆ‘ä»¬æŠŠåºåˆ— AAA åˆ†æˆè‹¥å¹²ä¸ªé•¿åº¦å—ï¼Œå¦‚ä¸‹å›¾ï¼š åˆ†å—åçš„åºåˆ— å…·ä½“æ€ä¹ˆåˆ†å‘¢ï¼ŸæŠŠè‹¥å¹²ä¸ªæ•°åˆ†æˆä¸€å—ã€‚æˆ‘ä»¬è®°å½•æ¯ä¸ªç‚¹çš„æ•°å€¼ï¼Œå†è®°å½•æ¯ä¸ªå—çš„å’Œï¼ˆè®°ä½œ sum[i]sum[i]sum[i]ï¼‰ï¼Œè¿˜è¦ç»™æ¯ä¸ªå—æ‰“ä¸Šä¸€ä¸ªæ ‡è®° add[i]add[i]add[i]ï¼ˆç±»ä¼¼äºçº¿æ®µæ ‘çš„å»¶è¿Ÿæ ‡è®°ï¼Œè€Œä¸”æ ‡è®°æ˜¯æ°¸ä¹…çš„ï¼Œå¦åˆ™ä½ å¾€å“ªä¼ ï¼‰ã€‚ åœ¨è¿›è¡Œæ“ä½œçš„æ—¶å€™ï¼Œæˆ‘ä»¬æŠŠè¿ç»­çš„å—ç§°ä¹‹ä¸ºæ•´å—ï¼Œä¸¤è¾¹çš„ä¸å®Œæ•´çš„å—ç§°ä¸ºé›¶æ•£å—ã€‚ å¯¹äºä¿®æ”¹æ“ä½œï¼Œåˆ†ä¸¤ç§æƒ…å†µè¿›è¡Œï¼š å½“ xxx å’Œ yyy å¤„äºåŒä¸€æ®µæ—¶ï¼Œç›´æ¥æš´åŠ›åŠ ï¼Œç„¶åä»¤è¿™ä¸€æ®µ sum[i]+=kÃ—(yâˆ’x+1)sum[i]+=k\\times(y-x+1)sum[i]+=kÃ—(yâˆ’x+1)ï¼› å¦åˆ™ï¼Œè®¾ xxx å¤„äºç¬¬ ppp æ®µï¼Œrrr å¤„äºç¬¬ qqq æ®µã€‚å¯¹äº iâˆˆ[p+1,qâˆ’1]i\\in [p+1,q-1]iâˆˆ[p+1,qâˆ’1]ï¼Œä»¤ add[i]+=kadd[i]+=kadd[i]+=kã€‚å¯¹äºå¼€å¤´ã€ç»“å°¾ä¸è¶³ä¸€æ•´æ®µçš„ä¸¤éƒ¨åˆ†ï¼ŒæŒ‰ç…§å‰ä¸€ç§æƒ…å†µæš´åŠ›æ›´æ–°ã€‚ å¯¹äºæŸ¥è¯¢æ“ä½œï¼Œä¹Ÿåˆ†ä¸¤ç§æƒ…å†µï¼š å½“ xxx å’Œ yyy å¤„äºåŒä¸€æ®µæ—¶ï¼Œâˆ‘i=xy+add[i]Ã—(yâˆ’x+1)\\sum\\limits_{i=x}^{y}+add[i]\\times (y-x+1)i=xâˆ‘yâ€‹+add[i]Ã—(yâˆ’x+1) å°±æ˜¯ç­”æ¡ˆã€‚ å¦åˆ™ï¼Œè®¾ xxx å¤„äºç¬¬ ppp æ®µï¼Œrrr å¤„äºç¬¬ qqq æ®µã€‚è®° ans=0ans=0ans=0ã€‚å¯¹äº iâˆˆ[p+1,qâˆ’1]i\\in [p+1,q-1]iâˆˆ[p+1,qâˆ’1]ï¼Œä»¤ ans+=sum[i]+add[i]Ã—len[i]ans+=sum[i]+add[i]\\times len[i]ans+=sum[i]+add[i]Ã—len[i]ï¼Œlenlenlen è¡¨ç¤ºè¿™ä¸€æ®µçš„é•¿åº¦ã€‚å¯¹äºå¼€å¤´ã€ç»“å°¾ä¸è¶³ä¸€æ•´æ®µçš„ä¸¤éƒ¨åˆ†ï¼ŒæŒ‰ç…§å‰ä¸€ç§æƒ…å†µæš´åŠ›æŸ¥è¯¢ã€‚ å½“å—çš„é•¿åº¦è¾ƒé•¿æ—¶ï¼Œæ“ä½œçš„æš´åŠ›ä¼šæ¯”è¾ƒæ…¢ï¼ˆå…¨å †åœ¨ä¸€ä¸ªå—é‡Œï¼‰ï¼›å—çš„é•¿åº¦è¾ƒçŸ­æ—¶ï¼Œç»´æŠ¤éƒ¨åˆ†ä¼šæ¯”è¾ƒæ…¢ï¼ˆå—å˜å¤šäº†ï¼Œæ”¹çš„ addaddadd æ ‡è®°æ•°é‡å˜å¤šäº†ï¼‰ã€‚ æ ¹æ®ç»éªŒï¼Œå½“å—çš„å¤§å°åœ¨åºåˆ—é•¿åº¦çš„ç®—æœ¯å¹³æ–¹æ ¹æ—¶ä¼šæ¯”è¾ƒå¿«ï¼Œè¯æ˜å¯ä»¥é‡‡ç”¨å‡å€¼ä¸ç­‰å¼ï¼Œè®¾å—çš„å¤§å°ä¸º tttï¼š t+ntâ‰¥2tÃ—nt=2nt+\\frac{n}{t}\\ge 2\\sqrt{t\\times\\frac{n}{t}} = 2\\sqrt{n} t+tnâ€‹â‰¥2tÃ—tnâ€‹â€‹=2nâ€‹ å½“ä¸”ä»…å½“ t=nt âŸº t2=nt=\\frac{n}{t}\\iff t^2=nt=tnâ€‹âŸºt2=n æ—¶ç­‰å·æˆç«‹ã€‚ ç„¶è€Œåœ¨æŸäº›æ¯’ç˜¤é¢˜ä¸­ï¼Œè¿˜å¯èƒ½éœ€è¦é€šè¿‡å®éªŒç¡®å®šæœ€å¥½çš„å—å€¼ï¼ˆæˆ‘ä»¬æ¥ä¸‹æ¥ä¼šçœ‹åˆ°çš„ï¼‰ã€‚ æ¥ä¸‹æ¥å°±åˆ°äº†æ„‰å¿«çš„å†™ä»£ç æ—¶é—´ï¼ŒåŸºæœ¬ç»“æ„æ˜¯è¿™æ ·ï¼š #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; using i64 = long long; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m, t; i64 a[100005], sum[100005], add[100005]; // åŸåºåˆ—ï¼Œå—å’Œï¼Œå»¶è¿Ÿæ ‡è®° int pos[100005], L[100005], R[100005]; // å…ƒç´ æ‰€åœ¨é¢å—çš„ç¼–å·ï¼Œå—çš„å·¦å³ç«¯ç‚¹ inline void update(int l, int r, i64 k) &#123; // do update &#125; inline i64 query(int l, int r) &#123; // do query &#125; int main(void) &#123; n = read(), m = read(); t = sqrt(n); // åˆ†å— for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= t; ++i) // å…ˆå¤„ç†å¥½è¿™ t ä¸ªå—çš„å·¦å³ç«¯ç‚¹ &#123; L[i] = (i - 1) * t + 1; R[i] = i * t; &#125; if (R[t] &lt; n) ++t, L[t] = R[t - 1] + 1, R[t] = n; // æœ€åå‰©ä¸€å°æ®µä¸å¤Ÿå‡‘æˆå®Œæ•´çš„å— //========== é¢„å¤„ç† ========== start > for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) &#123; pos[j] = i; sum[i] += a[j]; &#125; //========== é¢„å¤„ç† ========== end > while (m--) &#123; int op = read(), x = read(), y = read(); if (op == 1) update(x, y, read()); else printf(\"%lld\\n\", query(x, y)); &#125; return 0; &#125; å®é™…ä¸Š sum, L, R æ•°ç»„æ— éœ€å¼€è¿™ä¹ˆå¤§ï¼Œä½†å·²ç»æ²¡æœ‰ä¼˜åŒ–çš„å¿…è¦äº†ã€‚ ä¸¤ä¸ªæ“ä½œçš„ä»£ç å¦‚ä¸‹ï¼š void update(int l, int r, i64 k) &#123; int p = pos[l], q = pos[r]; if (p == q) // åŒä¸ªå—å†…ï¼Œæš´åŠ› &#123; for (int i = l; i &lt;= r; ++i) a[i] += k; sum[p] += (r - l + 1) * k; return; &#125; for (int i = p + 1; i &lt; q; ++i) add[i] += k; // å¤§å—æ‰“æ ‡è®° for (int i = l; i &lt;= R[p]; ++i) a[i] += k; // å·¦ sum[p] += (R[p] - l + 1) * k; // å’Œ for (int i = L[q]; i &lt;= r; ++i) a[i] += k; // å³ sum[q] += (r - L[q] + 1) * k; // å’Œ &#125; i64 query(int l, int r) &#123; // åŒ update int p = pos[l], q = pos[r]; i64 ans = 0; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) ans += a[i]; ans += add[p] * (r - l + 1); return ans; &#125; for (int i = p + 1; i &lt; q; ++i) ans += sum[i] + add[i] * (R[i] - L[i] + 1); for (int i = l; i &lt;= R[p]; ++i) ans += a[i]; ans += add[p] * (R[p] - l + 1); for (int i = L[q]; i &lt;= r; ++i) ans += a[i]; ans += add[q] * (r - L[q] + 1); return ans; &#125; æ—¶é—´å¤æ‚åº¦ä¸º O(mn)\\mathcal{O}(m\\sqrt{n})O(mnâ€‹)ã€‚ ä¸Šè¿°åšæ³•è¿˜å¯ä»¥ä¼˜åŒ–ï¼Œä¸è¿‡æ—¶é—´å¤æ‚åº¦å¹¶æ²¡æœ‰å˜ã€‚ ä¼˜åŒ–çš„æ–¹å¼æ˜¯å‰ç¼€å’Œï¼Œå¤§ä½“æ€è·¯æ˜¯æ˜ç¡®çš„ã€‚ç„¶è€Œåœ¨æœ‰ä¿®æ”¹çš„æƒ…å†µä¸‹ï¼Œå‰ç¼€å’Œä¸æ–¹ä¾¿ç»´æŠ¤ï¼Œåªèƒ½ç»´æŠ¤å•ä¸ªå—å†…çš„å‰ç¼€å’Œï¼Œè¿™æ ·é›¶æ•£å—çš„æŸ¥è¯¢å°±å¯ä»¥ä½¿ç”¨å‰ç¼€å’Œäº†ã€‚ å¤æ‚åº¦åˆ†æ åˆ†å—çš„å¤æ‚åº¦è¦ä»æŸ¥è¯¢å’Œä¿®æ”¹ï¼Œæ•´å—å’Œé›¶æ•£å—æ¥çœ‹ã€‚æ¯”å¦‚åˆšæ‰çš„é¢˜ï¼Œè‹¥å°†åºåˆ—åˆ†ä¸º ttt å—ï¼š æŸ¥è¯¢ï¼š æ•´å— O(t)O(t)O(t)ï¼Œ é›¶æ•£å— O(nt)O(\\frac{n}{t})O(tnâ€‹)ï¼Œ ä¿®æ”¹ æ•´å— O(t)O(t)O(t)ï¼Œ é›¶æ•£å— O(nt)O(\\frac{n}{t})O(tnâ€‹)ã€‚ å—çŠ¶æ•°ç»„ åˆšæ‰çš„åˆ†å—æ˜¯é’ˆå¯¹æ•°ç»„çš„ï¼Œè¿™ç±»åˆ†å—æˆ‘ä»¬ç»Ÿç§°ä¸ºå—çŠ¶æ•°ç»„ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬å°†è§è¯†æ›´å¤šçš„é¢˜ç›®æ¥è¯¦ç»†è®¤è¯†å—çŠ¶æ•°ç»„ã€‚ åŸºç¡€è®­ç»ƒ è¿™äº›é¢˜éƒ½å¾ˆåŸºç¡€ã€‚ [Luogu P2801] æ•™ä¸»çš„é­”æ³• Portal. åŒºé—´åŠ ï¼ŒæŸ¥è¯¢åŒºé—´å¤§äºç­‰äºæŸä¸ªæ•°çš„æ•°çš„ä¸ªæ•°ã€‚ æ ‘çŠ¶æ•°ç»„ç»´æŠ¤çš„æ˜¯å‰ç¼€å’Œï¼Œçº¿æ®µæ ‘ç»´æŠ¤çš„ä¿¡æ¯æ»¡è¶³å¤§åŒºé—´çš„è§£å¯ä»¥ç”±å°åŒºé—´åˆå¹¶å¾—åˆ°ï¼ˆåŒºé—´å¯åŠ æ€§ï¼‰ã€‚ä½†æ˜¯å¾ˆå¯æƒœï¼Œè¿™ä¹ˆå¥‡æ€ªçš„æŸ¥è¯¢å†…å®¹è™½ç„¶æ»¡è¶³åŒºé—´å¯åŠ æ€§ï¼Œä½†æ˜¯æ¯ä¸€ä¸ªä¸åŒçš„ c å€¼éœ€è¦æœ‰ä¸åŒçš„çº¿æ®µæ ‘ï¼Œæ‰€ä»¥ç»“è®ºå°±æ˜¯ç”¨æ™®é€šçº¿æ®µæ ‘åšå°±æ˜¯é€çŒªå¤´ã€‚ ä½†æ˜¯æ ‘å¥—æ ‘æ˜¯å¯ä»¥ç»´æŠ¤è¿™ç§å¤æ‚ä¿¡æ¯çš„ï¼Œç„¶è€Œæ ‘å¥—æ ‘åšä¸åˆ°åŒºé—´ä¿®æ”¹ï¼Œæ‰€ä»¥ä½¿ç”¨åˆ†å—æ¥è§£å†³ã€‚ åˆ†å—ä¹‹åï¼Œæˆ‘ä»¬çœ‹ä¸€çœ‹è¦æ€ä¹ˆæŸ¥è¯¢ã€‚æˆ‘ä»¬å°†æ¯ä¸€ä¸ªå—ä½œä¸ºä¸€ä¸ªå­é—®é¢˜åˆ†åˆ«æ±‚è§£ã€‚å…ˆå°†è¿™ä¸ªå—æ’å¥½åºï¼Œé‚£ä¹ˆæŸ¥è¯¢æ—¶å°±èƒ½å¿«å¾ˆå¤šï¼ˆç›´æ¥äºŒåˆ†ï¼‰ã€‚ä»€ä¹ˆæ—¶å€™æ’åºï¼Ÿæ˜¾ç„¶æ˜¯ä¿®æ”¹çš„æ—¶å€™ï¼Œè€Œä¸”åªæœ‰æš´åŠ›ä¿®æ”¹çš„éƒ¨åˆ†ï¼ˆå› ä¸ºåªæœ‰å®ƒçš„é¡ºåºä¼šå˜åŒ–ï¼‰ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, q, t; int L[1000005], R[1000005], pos[1000005]; int a[1000005], T[1000005], add[1000005]; inline void calc(int p) &#123; for (int i = L[p]; i &lt;= R[p]; ++i) T[i] = a[i]; sort(T + L[p], T + R[p] + 1); &#125; inline void update(int l, int r, int k) &#123; int p = pos[l], q = pos[r]; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) a[i] += k; return calc(p); &#125; for (int i = l; i &lt;= R[p]; ++i) a[i] += k; for (int i = L[q]; i &lt;= r; ++i) a[i] += k; for (int i = p + 1; i &lt; q; ++i) add[i] += k; calc(p), calc(q); &#125; inline int answer(int l, int r, int c) &#123; int ans = 0, p = pos[l], q = pos[r]; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) if (a[i] + add[p] >= c) ++ans; return ans; &#125; for (int i = l; i &lt;= R[p]; ++i) if (a[i] + add[p] >= c) ++ans; for (int i = L[q]; i &lt;= r; ++i) if (a[i] + add[q] >= c) ++ans; for (int i = p + 1; i &lt; q; ++i) ans += R[i] - (lower_bound(T + L[i], T + R[i] + 1, c - add[i]) - T) + 1; return ans; &#125; int main(void) &#123; n = read(), q = read(); t = sqrt(n); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= t; ++i) L[i] = (i - 1) * t + 1, R[i] = i * t; if (R[t] &lt; n) R[++t] = n, L[t] = R[t - 1] + 1; for (int i = 1; i &lt;= t; ++i) &#123; for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; calc(i); &#125; while (q--) &#123; char op[3]; scanf(\"%s\", op); if (op[0] == 'M') &#123; int l = read(), r = read(), k = read(); update(l, r, k); &#125; else &#123; int l = read(), r = read(), c = read(); printf(\"%d\\n\", answer(l, r, c)); &#125; &#125; return 0; &#125; æˆ‘ä»¬è®¾æŠŠåŸåºåˆ—åˆ†æˆ xxx ä¸ªå—ï¼Œé‚£ä¹ˆæŸ¥è¯¢çš„æ—¶å€™ï¼š æ•´å— O(xlogâ¡nx)O\\left(x\\log \\cfrac{n}{x}\\right)O(xlogxnâ€‹)ï¼Œ é›¶æ•£å— O(nx)O\\left(\\cfrac{n}{x}\\right)O(xnâ€‹)ã€‚ ä¿®æ”¹å¤æ‚åº¦ï¼š æ•´å— O(1)O(1)O(1)ï¼Œ é›¶æ•£å— O(nx)O\\left(\\cfrac{n}{x}\\right)O(xnâ€‹)ã€‚ å½“å—çš„å¤§å°ä¸º nlogâ¡n\\sqrt{n\\log n}nlognâ€‹ çš„æ—¶å€™ï¼Œæ—¶é—´å¤æ‚åº¦å¯ä»¥è¾¾åˆ°åˆ©ç”¨è¿™ç§åšæ³•çš„æœ€ä¼˜çš„ O(mnlogâ¡n)O(m\\sqrt{n\\log n})O(mnlognâ€‹)ã€‚ åŒæ ·ï¼Œä½ ä¹Ÿå¯ä»¥é€šè¿‡å®éªŒæ¥ç¡®å®šæ›´å¥½çš„å—é•¿ã€‚ é™æ€åˆ†å— ä»¥å¼ºåˆ¶åœ¨çº¿çš„åŒºé—´ä¼—æ•°ä¸ºä»£è¡¨ã€‚ä»¥ä¸Šæåˆ°çš„åˆ†å—éƒ½æ˜¯åŠ¨æ€åˆ†å—ï¼Œå®ƒä»¬å¯ä»¥å¤„ç†å¸¦ä¿®é—®é¢˜ã€‚è€Œé™æ€åˆ†å—åˆ™ä¸å¸¦ä¿®ï¼Œé€šè¿‡é¢„å¤„ç†å—çš„ä¿¡æ¯æ¥å¾—åˆ°å¤æ‚åº¦è¾ƒä¼˜çš„åšæ³•ã€‚é™æ€åˆ†å—åœ¨åŠŸèƒ½ä¸Šæ˜¯æ¥ä¸‹æ¥è¦ä»‹ç»çš„è«é˜Ÿç®—æ³•çš„å­é›†ï¼Œè€Œä¸”æ—¶ç©ºå¸¸æ•°é™æ€åˆ†å—éƒ½ä¼šæ›´å¤§ã€‚ä½†æ˜¯å¦‚æœå¼ºåˆ¶åœ¨çº¿çš„è¯ï¼Œåªèƒ½ä½¿ç”¨é™æ€åˆ†å—ã€‚ [Violet] è’²å…¬è‹± Portal. é™æ€å¤šæ¬¡è¯¢é—®åŒºé—´ä¼—æ•°ï¼Œå¼ºåˆ¶åœ¨çº¿ã€‚ åŒºé—´ä¼—æ•°ä¸å…·æœ‰åŒºé—´å¯åŠ æ€§ï¼Œæ‰€ä»¥ä¸å¯ä»¥ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ã€‚ æˆ‘ä»¬é¢„å¤„ç†å‡ºæ•°ç»„ c[x][y][num]c[x][y][num]c[x][y][num]ï¼Œä»£è¡¨ numnumnum åœ¨å— [x][y][x][y][x][y] ä¸­çš„å‡ºç°æ¬¡æ•°ï¼ŒåŒæ—¶é¢„å¤„ç†å‡ºç­”æ¡ˆã€‚åœ¨æŸ¥è¯¢çš„æ—¶å€™ï¼Œæ•´å—çš„ç­”æ¡ˆå¯ä»¥ç›´æ¥å¾—åˆ°ï¼Œé›¶æ•£å—åªéœ€è¦å•æ¬¡æ‰«æç»Ÿè®¡å³å¯ã€‚ è®¾å—çš„å¤§å°ä¸º TTTï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸º O(nT2+mn/T)O(nT^2+mn/T)O(nT2+mn/T)ï¼Œé‚£ä¹ˆå½“ T=n3T=\\sqrt[3]{n}T=3nâ€‹ æ—¶ä¼šæ¯”è¾ƒå¿«ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n35)O(n^{\\frac{3}{5}})O(n53â€‹)ã€‚è¿™ç§åšæ³•æ¯”è¾ƒæ…¢ï¼Œè€Œä¸”ç©ºé—´è¾ƒå¤§ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, tot, ans[2]; int a[40005], b[40005]; int c[37][37][40005], f[37][37][2]; int L[205], R[205], pos[40005]; void work(int x, int y, int num) &#123; ++c[x][y][num]; if (c[x][y][num] > ans[0] || (c[x][y][num] == ans[0] &amp;&amp; num &lt; ans[1])) ans[1] = num, ans[0] = c[x][y][num]; &#125; int query(int l, int r) &#123; int p = pos[l], q = pos[r]; int x = 0, y = 0; if (p + 1 &lt;= q - 1) x = p + 1, y = q - 1; memcpy(ans, f[x][y], sizeof(ans)); if (p == q) &#123; for (int i = l; i &lt;= r; ++i) work(x, y, a[i]); for (int i = l; i &lt;= r; ++i) --c[x][y][a[i]]; &#125; else &#123; for (int i = l; i &lt;= R[p]; ++i) work(x, y, a[i]); for (int i = L[q]; i &lt;= r; ++i) work(x, y, a[i]); for (int i = l; i &lt;= R[p]; ++i) --c[x][y][a[i]]; for (int i = L[q]; i &lt;= r; ++i) --c[x][y][a[i]]; &#125; return b[ans[1]]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memcpy(b, a, sizeof(b)); sort(b + 1, b + n + 1); tot = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b; int t = pow(double(n), (double)1 / 3); int len = t ? n / t : n; for (int i = 1; i &lt;= t; ++i) &#123; L[i] = R[i - 1] + 1; R[i] = i * len; &#125; if (R[t] &lt; n) &#123; L[t + 1] = R[t] + 1; R[++t] = n; &#125; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; memset(c, 0, sizeof(c)); memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= t; ++i) for (int j = i; j &lt;= t; ++j) &#123; for (int k = L[i]; k &lt;= R[j]; ++k) ++c[i][j][a[k]]; for (int k = 1; k &lt;= tot; ++k) if (c[i][j][k] > f[i][j][0]) &#123; f[i][j][0] = c[i][j][k]; f[i][j][1] = k; &#125; &#125; int last = 0; while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l = (l + last - 1) % n + 1; r = (r + last - 1) % n + 1; if (l > r) swap(l, r); printf(\"%d\\n\", last = query(l, r)); &#125; return 0; &#125; [Ynoi2019 æ¨¡æ‹Ÿèµ›] Yuno loves sqrt technology III Portal. è¿™æ¬¡è¯¢é—®çš„æ˜¯åŒºé—´ä¼—æ•°çš„å‡ºç°æ¬¡æ•°ï¼Œä½†æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ã€‚æˆ‘ä»¬è®°å½• f(i,j)f(i,j)f(i,j) ä»£è¡¨ç¬¬ [i,j][i,j][i,j] å—çš„åŒºé—´ä¼—æ•°å‡ºç°æ¬¡æ•°ã€‚æˆ‘ä»¬å¯¹æ¯ä¸€ä¸ªæ•°éƒ½å¼€ä¸€ä¸ª STL vectorï¼Œè®°å½•å…¶å‡ºç°çš„ä½ç½®ï¼Œå¹¶è®° ax[i]ax[i]ax[i] ä¸ºç¬¬ iii ä¸ªæ•°å‡ºç°åœ¨å…¶ vector ä¸­çš„ä½ç½®ã€‚ æ•´å—çš„ç­”æ¡ˆæ˜¯å¯ä»¥ç›´æ¥ç»Ÿè®¡çš„ï¼Œè€Œå¯¹äºé›¶æ•£å—ï¼Œåˆ™è·å–å½“å‰çš„æ•°åœ¨ vector ä¸­çš„ä½ç½®ï¼Œè€ƒè™‘ ansansans æ˜¯å¦å¯ä»¥å˜å¤§ï¼Œè¿›è¡Œæš´åŠ›æ›´æ–°å³å¯ã€‚ç”±äº ansansans æœ€å¤šå˜å¤§ 2n2\\sqrt{n}2nâ€‹ï¼Œå› æ­¤è¯¢é—®çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)O(\\sqrt{n})O(nâ€‹)ã€‚ æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(nn)O(n\\sqrt{n})O(nnâ€‹)ã€‚å¦‚æœæƒ³è¦æ±‚å‡ºåŒºé—´ä¼—æ•°çš„å€¼ï¼Œé¢å¤–è®°å½•ä¸€ä¸ªå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; void print(int x) &#123; if (x > 9) print(x / 10); putchar_unlocked(x % 10 + '0'); &#125; int n, m, tot; int a[500005], b[500005], pos[500005]; int L[720], R[720], f[720][720]; int cnt[500005], ax[500005]; std::vector &lt;int> v[500005]; int query(int l, int r) &#123; int p = pos[l], q = pos[r], ans = f[p + 1][q - 1]; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) cnt[a[i]] = 0; for (int i = l; i &lt;= r; ++i) ans = std::max(ans, ++cnt[a[i]]); return ans; &#125; for (int i = l; i &lt;= R[p]; ++i) &#123; int p = ax[i]; while (p + ans &lt; v[a[i]].size() &amp;&amp; v[a[i]][p + ans] &lt;= r) ++ans; &#125; for (int i = L[q]; i &lt;= r; ++i) &#123; int p = ax[i]; while (p - ans >= 0 &amp;&amp; v[a[i]][p - ans] >= l) ++ans; &#125; return ans; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) b[i] = a[i] = read(); std::sort(b + 1, b + n + 1); tot = std::unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = std::lower_bound(b + 1, b + tot + 1, a[i]) - b; v[a[i]].emplace_back(i); ax[i] = v[a[i]].size() - 1; &#125; int t = sqrt(n); for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * t; if (R[t] &lt; n) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = n;&#125; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 1; i &lt;= t; ++i) &#123; memset(cnt, 0, sizeof(cnt)); for (int j = i; j &lt;= t; ++j) &#123; f[i][j] = f[i][j - 1]; for (int k = L[j]; k &lt;= R[j]; ++k) f[i][j] = std::max(f[i][j], ++cnt[a[k]]); &#125; &#125; int last = 0; while (m--) &#123; int l = (read() ^ last), r = (read() ^ last); print(last = query(l, r)); putchar_unlocked('\\n'); &#125; return 0; &#125; [Luogu P3709] å¤§çˆ·çš„å­—ç¬¦ä¸²é¢˜ Portal. å¯ä»¥å°†åºåˆ—åˆ’åˆ†æˆè‹¥å¹²ä¸ªå•è°ƒä¸Šå‡åºåˆ—ï¼Œé‚£ä¹ˆé—®çš„å°±æ˜¯åŒºé—´ä¼—æ•°å‡ºç°æ¬¡æ•°çš„ç›¸åæ•°ã€‚ [Ynoi2019 æ¨¡æ‹Ÿèµ›] Yuno loves sqrt technology I Portal. å¼ºåˆ¶åœ¨çº¿çš„åŒºé—´é€†åºå¯¹ï¼ æ•´å—å†…éƒ¨ï¼šé¢„å¤„ç†ï¼› æ•£å—å†…éƒ¨ï¼šç”¨æ ‘çŠ¶æ•°ç»„é¢„å¤„ç†å‰åç¼€ï¼› æ•£å—å¯¹æ•£å—ï¼šå¤„ç†å¥½æ¯ä¸ªæ•°çš„æ’åï¼Œç›´æ¥å½’å¹¶ï¼› æ•£å—å¯¹æ•´å—ï¼šé¢„å¤„ç†å‡º gi,jg_{i,j}gi,jâ€‹ ä»£è¡¨ 1âˆ¼j1\\sim j1âˆ¼j å¯¹ iii å—çš„è´¡çŒ®ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int B = 350; template&lt;typename T> inline void read(T &amp;x) &#123; x = 0; int c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); &#125; int n, m; int a[100005], pos[100005]; int b[100005], idx[100005], T[100005]; int L[750], R[750]; i64 f[750][750]; int g[750][100005], pre[100005], nxt[100005]; // 1 ~ j å¯¹ç¬¬ i å—çš„è´¡çŒ® int T1[750], T2[750], t1, t2; struct Fenwick &#123; int C[100005]; inline void add(int x, int k) &#123; for (; x &lt;= n; x += x &amp; -x) C[x] += k; &#125; inline int sum(int x) &#123; int r = 0; for (; x; x -= x &amp; -x) r += C[x]; return r; &#125; &#125; F; inline int merge(int *a, int na, int *b, int nb) &#123; int res = 0; for (int p = 1, q = 1; p &lt;= na &amp;&amp; q &lt;= nb; ) &#123; if (q &lt;= nb &amp;&amp; (p > na || b[q] &lt; a[p])) ++q, res += na - p + 1; else ++p; &#125; return res; &#125; inline i64 query(int l, int r) &#123; int p = pos[l], q = pos[r]; if (p == q) &#123; i64 ans = pre[r] - (l == L[p] ? 0 : pre[l - 1]); t1 = 0; t2 = 0; for (int i = L[p]; i &lt;= R[p]; ++i) if (idx[b[i]] >= L[p] &amp;&amp; idx[b[i]] &lt;= l - 1) T1[++t1] = b[i]; else if (idx[b[i]] >= l &amp;&amp; idx[b[i]] &lt;= r) T2[++t2] = b[i]; return ans - merge(T1, t1, T2, t2); &#125; i64 ans = f[p + 1][q - 1] + nxt[l] + pre[r]; t1 = 0; t2 = 0; for (int i = L[p]; i &lt;= R[p]; ++i) if (idx[b[i]] >= l) T1[++t1] = b[i]; for (int i = L[q]; i &lt;= R[q]; ++i) if (idx[b[i]] &lt;= r) T2[++t2] = b[i]; ans += merge(T1, t1, T2, t2); for (int i = p + 1; i &lt; q; ++i) ans += g[i][R[p]] - g[i][l - 1] + g[i][r] - g[i][L[q] - 1]; return ans; &#125; int main(void) &#123; read(n); read(m); int t = (n - 1) / B + 1; for (int i = 1; i &lt;= n; ++i) read(a[i]), idx[a[i]] = i, T[i] = b[i] = a[i]; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * B; R[t] = n; for (int i = 1; i &lt;= t; ++i) &#123; for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; sort(b + L[i], b + R[i] + 1); &#125; // æ•£å—å†…éƒ¨ï¼Œé¢„å¤„ç† for (int op = 1; op &lt;= t; ++op) &#123; for (int i = L[op]; i &lt;= R[op]; ++i) pre[i] = (i == L[op] ? 0 : pre[i - 1]) + ((i - L[op]) - F.sum(a[i] - 1)), F.add(a[i], 1); for (int i = L[op]; i &lt;= R[op]; ++i) F.add(a[i], -1); for (int i = R[op]; i >= L[op]; --i) nxt[i] = (i == R[op] ? 0 : nxt[i + 1]) + F.sum(a[i] - 1), F.add(a[i], 1); for (int i = R[op]; i >= L[op]; --i) F.add(a[i], -1); f[op][op] = pre[R[op]]; &#125; // æ•£å—å¯¹æ•´å—ï¼Œæ•´å—å¯¹æ•´å—ï¼Œé¢„å¤„ç† sort(T + 1, T + n + 1); for (int op = 1; op &lt;= t; ++op) for (int i = 1, k = L[op] - 1; i &lt;= n; ++i) &#123; while (k &lt; R[op] &amp;&amp; T[i] > b[k + 1]) ++k; int p = idx[T[i]]; if (p &lt; L[op]) g[op][p] = k - L[op] + 1; else if (p > R[op]) g[op][p] = R[op] - k; &#125; for (int op = 1; op &lt;= t; ++op) for (int i = 1; i &lt;= n; ++i) g[op][i] += g[op][i - 1]; for (int len = 1; len &lt; t; ++len) for (int i = 1; i + len &lt;= t; ++i) &#123; int j = i + len; f[i][j] = f[i + 1][j] + f[i][j - 1] - f[i + 1][j - 1] + g[j][R[i]] - g[j][L[i] - 1]; &#125; for (i64 last = 0; m--; ) &#123; i64 l, r; read(l); read(r); l ^= last, r ^= last; printf(\"%lld\\n\", last = query(l, r)); &#125; return 0; &#125; ä¸€äº›ç®€å•é¢˜ ç®€å•çš„åˆ†å—é¢˜ã€‚ [Ynoi2017] ç”±ä¹ƒæ‰“æ‰‘å…‹ Portal. å¥—ç”¨ã€Šæ•™ä¸»çš„é­”æ³•ã€‹çš„äºŒåˆ†æ³•ï¼Œåœ¨æŸ¥è¯¢çš„æ—¶å€™äºŒåˆ†å‡ºæ’åä¸º kkk çš„æ•°å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 200; const int INF = 2e9 + 1e8; inline int read(void) &#123; int x = 0, c = getchar_unlocked(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar_unlocked();&#125; while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x * f; &#125; int n, m, t; int a[100005], T[100005]; int L[800], R[800], add[800], pos[100005]; inline void calc(int p) &#123; for (int i = L[p]; i &lt;= R[p]; ++i) T[i] = a[i]; sort(T + L[p], T + R[p] + 1); &#125; inline void update(int l, int r, int k) &#123; int p = pos[l], q = pos[r]; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) a[i] += k; calc(p); return; &#125; for (int i = p + 1; i &lt; q; ++i) add[i] += k; for (int i = l; i &lt;= R[p]; ++i) a[i] += k; for (int i = L[q]; i &lt;= r; ++i) a[i] += k; calc(p); calc(q); &#125; inline pair&lt;int, int> get(int l, int r) &#123; int p = pos[l], q = pos[r], minn = INF, maxx = -INF; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) minn = min(minn, a[i] + add[p]), maxx = max(maxx, a[i] + add[p]); return make_pair(minn, maxx); &#125; for (int i = p + 1; i &lt; q; ++i) minn = min(minn, T[L[i]] + add[i]), maxx = max(maxx, T[R[i]] + add[i]); for (int i = l; i &lt;= R[p]; ++i) minn = min(minn, a[i] + add[p]), maxx = max(maxx, a[i] + add[p]); for (int i = L[q]; i &lt;= r; ++i) minn = min(minn, a[i] + add[q]), maxx = max(maxx, a[i] + add[q]); return make_pair(minn, maxx); &#125; inline int check(int l, int r, int x) &#123; // è¯¢é—® [l,r] ä¸­ x æ˜¯ç¬¬å‡ å°çš„æ•° int p = pos[l], q = pos[r], cnt = 0; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) if (a[i] + add[p] &lt;= x) ++cnt; return cnt; &#125; for (int i = l; i &lt;= R[p]; ++i) if (a[i] + add[p] &lt;= x) ++cnt; for (int i = L[q]; i &lt;= r; ++i) if (a[i] + add[q] &lt;= x) ++cnt; for (int i = p + 1; i &lt; q; ++i) if (T[L[i]] + add[i] &lt;= x) &#123; if (T[R[i]] + add[i] &lt;= x) cnt += R[i] - L[i] + 1; else cnt += upper_bound(T + L[i], T + R[i] + 1, x - add[i]) - (T + L[i]); &#125; return cnt; &#125; inline int query(int l, int r, int k) &#123; if (r - l + 1 &lt; k) return -1; int p = pos[l], q = pos[r]; pair&lt;int, int> t = get(l, r); int ll = t.first - 1, rr = t.second + 1; while (ll + 1 != rr) &#123; int mid = ((long long)ll + rr) / 2; if (check(l, r, mid) &lt; k) ll = mid; else rr = mid; &#125; return rr; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); t = n / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = BLOCK_SIZE * i; R[t] = n; for (int i = 1; i &lt;= t; ++i) &#123; for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; calc(i); &#125; while (m--) &#123; int op = read(), l = read(), r = read(), k = read(); if (op == 1) printf(\"%d\\n\", query(l, r, k)); else update(l, r, k); &#125; return 0; &#125; è«é˜Ÿ æœ‰æ—¶é¢˜ç›®çš„æŸ¥è¯¢éå¸¸è¯¡å¼‚ï¼Œå¸¸è§„çš„åœ¨çº¿åšæ³•ï¼ˆè¯»å…¥ä¸€ä¸ªè¯¢é—®å›ç­”ä¸€ä¸ªï¼‰ä¸èµ·ä½œç”¨ï¼Œéœ€è¦ç¦»çº¿åšæ³•ï¼ˆè¯»å…¥æ‰€æœ‰è¯¢é—®åç»Ÿä¸€å¤„ç†ï¼‰ã€‚å¦‚æœè¿˜è¦å¯¹è¯¢é—®è¿›è¡Œåˆ†å—ï¼Œé‚£ä¹ˆè«é˜Ÿå°±å‡ºç°äº†ã€‚ æ™®é€šè«é˜Ÿ [å›½å®¶é›†è®­é˜Ÿ] å° Z çš„è¢œå­ã€‚nnn ä¸ªä¸åŒçš„æ•°ï¼Œæ¯æ¬¡è¯¢é—®ä¸€ä¸ªåŒºé—´ [l,r][l,r][l,r]ï¼Œé—®åœ¨å½“ä¸­æœ‰å¤šå¤§æ¦‚ç‡æŠ½åˆ°ä¸¤ä¸ªä¸€æ ·çš„æ•°ã€‚ å¸¸è§„çš„ç¦»çº¿åšæ³•ä¼¼ä¹ä¸å¤ªè¡Œï¼Œåªæ˜¯å°†è¯¢é—®æŒ‰ç…§å³ç«¯ç‚¹æ’åºçš„è¯ï¼Œæ— æ³•é€šè¿‡å‰ç¼€å’Œç›¸å‡çš„æ–¹å¼å¾—åˆ°åŒºé—´æ¯ä¸ªç§ç±»æ•°çš„ä¸ªæ•°ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è«é˜Ÿè§£å†³è¿™ä¸ªé—®é¢˜ï¼š å°†è¯¢é—®æŒ‰ç…§å·¦ç«¯ç‚¹æ’åºï¼Œç„¶ååˆ†æˆ n\\sqrt{n}nâ€‹ å—ï¼Œæ¯ä¸ªå—å†…å†æŒ‰ç…§å³ç«¯ç‚¹æ’åºã€‚è¿™æ ·ä¿è¯äº†åœ¨æ¯ä¸ªå—å†…ï¼Œè¯¢é—®çš„å·¦ç«¯ç‚¹å˜åŒ–èŒƒå›´åœ¨ n\\sqrt{n}nâ€‹ å†…ã€‚è¿™æ ·ä¹‹åæˆ‘ä»¬å°±å¯ä»¥æš´åŠ›ç§»åŠ¨è¯¢é—®åŒºé—´ï¼Œè€Œä¸”æ³¨å®šäº†ç§»åŠ¨æ¬¡æ•°ä¸º O(nn)O(n\\sqrt{n})O(nnâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 250; i64 gcd(i64 x, i64 y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int n, m; int a[50005], cnt[50005], pos[50005]; i64 ans, ans1[50005], ans2[50005]; struct Question &#123; int l, r, id; bool operator &lt; (const Question &amp;a) &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[50005]; void update(int p, int f) &#123; if (cnt[a[p]]) ans -= cnt[a[p]] * (cnt[a[p]] - 1); cnt[a[p]] += f; if (cnt[a[p]]) ans += cnt[a[p]] * (cnt[a[p]] - 1); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; for (; r + 1 &lt;= Q[i].r; ++r) update(r + 1, 1); for (; r - 1 >= Q[i].r; --r) update(r, -1); for (; l + 1 &lt;= Q[i].l; ++l) update(l, -1); for (; l - 1 >= Q[i].l; --l) update(l - 1, 1); if (Q[i].l == Q[i].r) &#123; ans1[Q[i].id] = 0, ans2[Q[i].id] = 1; continue; &#125; ans1[Q[i].id] = ans; ans2[Q[i].id] = 1ll * (r - l + 1) * (r - l); &#125; for (int i = 1; i &lt;= m; ++i) &#123; if (ans1[i] == 0) ans2[i] = 1; else &#123; int g = gcd(ans1[i], ans2[i]); ans1[i] /= g, ans2[i] /= g; &#125; printf(\"%lld/%lld\\n\", ans1[i], ans2[i]); &#125; return 0; &#125; å¥‡å¶æ’åºä¼˜åŒ–ã€‚å½“ lll ä½äºçš„å—ç¡®å®šæ—¶ï¼Œæ ¹æ®å…¶å¥‡å¶æ€§åˆ†åˆ«è®© rrr å‡åº / é™åºæ’åˆ—ï¼Œé€šå¸¸å¯ä»¥å¿« 30%30\\%30%ã€‚ æ ‘ä¸Šè«é˜Ÿ è«é˜Ÿä¸Šæ ‘ï¼ä½†æ˜¯å…³é”®æ˜¯æ‹åˆ°åºåˆ—ä¸Šã€‚ é“¾ä¸Šç»´æŠ¤ å¯ä»¥åˆ©ç”¨æ¬§æ‹‰åºå°†å…¶æ‹åˆ°çº¿æ€§ç»“æ„ä¸Šï¼ˆæ¬§æ‹‰åºåœ¨ä¸åœ¨é“¾ä¸Šçš„å†…å®¹ä¼šç›´æ¥è®¿é—®ä¸¤æ¬¡æ¥æ¶ˆé™¤å…¶å½±å“ï¼‰ [COT2] Count on a tree II.nnn ä¸ªèŠ‚ç‚¹çš„å¸¦é¢œè‰²æ ‘ï¼Œè¯¢é—®è·¯å¾„ä¸Šä¸åŒé¢œè‰²çš„æ•°é‡ã€‚ æ ‘ä¸Šè«é˜Ÿæ¨¡æ¿ï¼Œæ³¨æ„ LCA å¤„çš„è®¨è®ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 300; int n, m, pos[80005], Ans[40005], dep[40005]; int a[40005], b[40005], f[16][40005]; int idx[80005], tot, L[80005], R[80005]; vector&lt;int> G[40005]; struct Query &#123; int l, r, lca, id; bool operator&lt; (const Query &amp;a) const &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[100005]; void dfs(int x, int fa) &#123; idx[L[x] = ++tot] = x; dep[x] = dep[f[0][x] = fa] + 1; for (int i = 1; i &lt;= 15; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x); idx[R[x] = ++tot] = x; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 15; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = 15; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; int ans, buc[40005]; bool vis[40005]; void update(int x) &#123; vis[x] ^= 1; if (vis[x] == 1) &#123; if (buc[a[x]] == 0) ++ans; ++buc[a[x]]; &#125; else &#123; if (buc[a[x]] == 1) --ans; --buc[a[x]]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= tot; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= m; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); Q[i].id = i; int d = LCA(x, y); if (L[x] > L[y]) swap(x, y); if (x == d) Q[i].l = L[x], Q[i].r = L[y]; else Q[i].l = R[x], Q[i].r = L[y], Q[i].lca = d; &#125; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; while (r &lt; Q[i].r) update(idx[++r]); while (r > Q[i].r) update(idx[r--]); while (l > Q[i].l) update(idx[--l]); while (l &lt; Q[i].l) update(idx[l++]); if (Q[i].lca) update(Q[i].lca); Ans[Q[i].id] = ans; if (Q[i].lca) update(Q[i].lca); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", Ans[i]); return 0; &#125; å­æ ‘ç»´æŠ¤ è™½ç„¶å¯ä»¥ä½¿ç”¨ DFS åºæ‹åˆ°é“¾ä¸Šï¼Œä½†æ˜¯è¿™æ—¶ä¸å¦‚ç›´æ¥ç”¨æ ‘ä¸Šå¯å‘å¼åˆå¹¶ï¼Œå¯ä»¥åšåˆ°æ›´å¥½çš„å¤æ‚åº¦ã€‚ å¸¦ä¿®è«é˜Ÿ [å›½å®¶é›†è®­é˜Ÿ] æ•°é¢œè‰² / ç»´æŠ¤é˜Ÿåˆ—ã€‚æœ‰ nnn ä¸ªæ•°ï¼Œæ”¯æŒè¯¢é—®åŒºé—´æœ‰å¤šå°‘ä¸ªä¸åŒçš„æ•°å’Œå•ç‚¹ä¿®æ”¹ã€‚ å’Œä¸Šä¸€é¢˜ç›¸æ¯”å¤šäº†ä¸€ä¸ªä¿®æ”¹ï¼Œå› æ­¤æˆ‘ä»¬æ¥ä»‹ç»å¸¦ä¿®è«é˜Ÿï¼šå°±æ˜¯å¤šäº†ä¸€ä¸ªæ—¶é—´è½´ï¼Œæ’åºçš„æ—¶å€™è¦çœ‹å·¦å³ç«¯ç‚¹çš„å—çš„ç¼–å·ï¼Œç„¶åç»Ÿè®¡ç­”æ¡ˆæ—¶ç›´æ¥ä¿®æ­£æˆå¯¹åº”çš„ä¿®æ”¹æ¬¡æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 2600; int n, m; int a[133340], pos[133340], b[133340]; int opp[133340], opv[133340], bck[133340]; struct Operation &#123; int l, r, t, id; Operation(int l = 0, int r = 0, int t = 0, int id = 0) : l(l), r(r), t(t), id(id) &#123;&#125; bool operator &lt; (const Operation &amp;a) const &#123; if (pos[l] == pos[a.l]) &#123; if (pos[r] == pos[a.r]) return id &lt; a.id; return r &lt; a.r; &#125; return l &lt; a.l; &#125; &#125; Q[133340]; int c1 = 0, c2 = 0; int Ans[133340], ans, c[1000005]; void update(int p, int f) &#123; if (c[p] == 0 &amp;&amp; f == 1) ++ans; if (c[p] == 1 &amp;&amp; f == -1) --ans; c[p] += f; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; for (int i = 1; i &lt;= n; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; for (int i = 1, x, y; i &lt;= m; ++i) &#123; char s[5]; scanf(\"%s%d%d\", s, &amp;x, &amp;y); if (s[0] == 'Q') &#123; ++c1; Q[c1] = Operation(x, y, c2, c1); &#125; else &#123; ++c2; opp[c2] = x; opv[c2] = y; bck[c2] = b[x]; b[x] = y; &#125; &#125; sort(Q + 1, Q + c1 + 1); for (int i = 1, l = 1, r = 0, lst = 0; i &lt;= c1; ++i) &#123; for (; lst + 1 &lt;= Q[i].t; ++lst) &#123; if (l &lt;= opp[lst + 1] &amp;&amp; opp[lst + 1] &lt;= r) update(bck[lst + 1], -1), update(opv[lst + 1], 1); a[opp[lst + 1]] = opv[lst + 1]; &#125; for (; lst - 1 >= Q[i].t; --lst) &#123; if (l &lt;= opp[lst] &amp;&amp; opp[lst] &lt;= r) update(opv[lst], -1), update(bck[lst], 1); a[opp[lst]] = bck[lst]; &#125; for (; r + 1 &lt;= Q[i].r; ++r) update(a[r + 1], 1); for (; r - 1 >= Q[i].r; --r) update(a[r], -1); for (; l + 1 &lt;= Q[i].l; ++l) update(a[l], -1); for (; l - 1 >= Q[i].l; --l) update(a[l - 1], 1); Ans[Q[i].id] = ans; &#125; for (int i = 1; i &lt;= c1; ++i) printf(\"%d\\n\", Ans[i]); return 0; &#125; å›æ»šè«é˜Ÿ æœ‰çš„æ—¶å€™å¢åŠ åˆ é™¤æ— æ³•ç®€å•å®ç°ï¼Œæ¯”å¦‚è¯´åˆ é™¤ä¹‹åä½ çš„ç­”æ¡ˆè¦æ›´æ–°ä¸ºæ¬¡å¤§ï¼Œè¿™å°±æ„å‘³ç€ä½ éœ€è¦æŠŠ kkk å¤§éƒ½å­˜ä¸‹æ¥ï¼Œè¿™æ ·æ˜¯æ— æ³•æ¥å—çš„ã€‚è¿™æ—¶å°±éœ€è¦é‡‡ç”¨å›æ»šè«é˜Ÿã€‚ [joisc2014] æ­´å²ã®ç ”ç©¶ã€‚ç»™å®šä¸€ä¸ªåºåˆ—ï¼Œå¤šæ¬¡è¯¢é—®åŒºé—´ä¸­é‡è¦åº¦ï¼ˆä¸€ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°ä¹˜ä»¥è‡ªèº«æ•°å€¼ï¼‰çš„æœ€å¤§å€¼ã€‚ åˆ é™¤çš„è¯å¯èƒ½éœ€è¦æ›´æ–°ä¸ºæ¬¡å¤§å€¼ï¼Œç„¶è€Œè¿™ä¸ªä¸œè¥¿æ˜¯æ²¡æœ‰è®°å½•çš„ï¼Œè¿™æ—¶å€™éœ€è¦é‡‡ç”¨ä¸åˆ é™¤è«é˜Ÿï¼Œè¿‡ç¨‹å¤§æ¦‚åƒè¿™æ ·ï¼š æ’åºï¼› è§‚å¯Ÿ p=pos[l],q=pos[r]p=pos[l],q=pos[r]p=pos[l],q=pos[r]ï¼Œp,qp,qp,q çš„ä½ç½®ï¼š å¦‚æœ p=qp=qp=qï¼Œé‚£ä¹ˆæš´åŠ›æ±‚è§£ï¼› å¦‚æœ ppp å’Œä¸Šä¸€ä¸ªè¯¢é—®çš„ ppp ä¸åŒï¼Œé‚£ä¹ˆå°†è«é˜ŸåŒºé—´çš„å·¦ç«¯ç‚¹è®¾ç½®ä¸ºä¸Šä¸€ä¸ªå—çš„å³ç«¯ç‚¹ +1ï¼Œå³ç«¯ç‚¹ä¸ºä¸Šä¸€ä¸ªå—çš„å³ç«¯ç‚¹ï¼› å¦åˆ™ï¼š å°†è«é˜Ÿå³ç«¯ç‚¹æ‰©å±•è‡³è¯¢é—®çš„å³ç«¯ç‚¹ï¼Œç”±äºå³ç«¯ç‚¹æ˜¯ä¸é™çš„ï¼Œå› æ­¤ä¸å¯èƒ½å›æ¥ï¼› æ‰©å±•è«é˜Ÿå·¦ç«¯ç‚¹åˆ°è¯¢é—®å·¦ç«¯ç‚¹ï¼Œå¹¶å›ç­”è¯¢é—®ï¼› å›æ»šï¼Œå°†è«é˜Ÿçš„å·¦ç«¯ç‚¹æ»šå›ä¸Šä¸€ä¸ªå—çš„å³ç«¯ç‚¹ +1ã€‚ æ—¶é—´å¤æ‚åº¦ä¸º O(nm)O(n\\sqrt{m})O(nmâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 300; int n, m, a[100005], b[100005]; int pos[100005], L[1005], R[1005]; struct Quesiton &#123; int l, r, id; bool operator &lt; (const Quesiton &amp;a) const &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[100005]; int cnt[100005], _cnt[100005]; i64 Ans[100005], ans; inline void add(int x, i64 &amp;t) &#123; ++cnt[x]; t = max(t, 1ll * b[x] * cnt[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int tot = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; int t = n / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0, last = 0; i &lt;= m; ++i) &#123; if (pos[Q[i].l] == pos[Q[i].r]) &#123; for (int j = Q[i].l; j &lt;= Q[i].r; ++j) ++_cnt[a[j]]; for (int j = Q[i].l; j &lt;= Q[i].r; ++j) Ans[Q[i].id] = max(Ans[Q[i].id], 1ll * _cnt[a[j]] * b[a[j]]); for (int j = Q[i].l; j &lt;= Q[i].r; ++j) --_cnt[a[j]]; continue; &#125; if (pos[Q[i].l] != last) &#123; for (; l + 1 &lt;= R[pos[Q[i].l]] + 1; ++l) --cnt[a[l]]; for (; r - 1 >= R[pos[Q[i].l]]; --r) --cnt[a[r]]; ans = 0; last = pos[Q[i].l]; &#125; for (; r + 1 &lt;= Q[i].r; ++r) add(a[r + 1], ans); i64 tmp = ans; int _l = l; for (; _l - 1 >= Q[i].l; --_l) add(a[_l - 1], tmp); Ans[Q[i].id] = tmp; for (; _l + 1 &lt;= l; ++_l) --cnt[a[_l]]; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%lld\\n\", Ans[i]); return 0; &#125; å½“ç„¶ç±»ä¼¼çš„è¿˜æœ‰ä¸æ·»åŠ è«é˜Ÿï¼Œè¯·è§ Problemsetã€‚ è«é˜ŸäºŒæ¬¡ç¦»çº¿ æ ‘åˆ†å— Problemset éå¸¸æœ‰è¶£ï¼ ç®€å•åºåˆ—åˆ†å— ä¸€äº›ç®€å•çš„åˆ†å—ç»´æŠ¤åºåˆ—çš„é¢˜ã€‚ [HNOI2010] å¼¹é£ç»µç¾Š Portal. åˆ†å—ç»´æŠ¤æ¯ä¸€ä¸ªç‚¹è·³å‡ æ­¥è·³åˆ°å—å¤–å’Œè·³åˆ°å—å¤–çš„ä½ç½®ï¼Œæ—¶é—´å¤æ‚åº¦ O((n+m)n)O((n+m)\\sqrt{n})O((n+m)nâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 450; int n, m; int a[200005], L[2005], R[2005], pos[200005], f[200005], g[200005]; int main(void) &#123; scanf(\"%d\", &amp;n); int t = (n - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = n; i >= 1; --i) if (i + a[i] > R[pos[i]]) f[i] = 1, g[i] = i + a[i]; else f[i] = f[i + a[i]] + 1, g[i] = g[i + a[i]]; for (scanf(\"%d\", &amp;m); m--; ) &#123; int op, x, y; scanf(\"%d%d\", &amp;op, &amp;x); ++x; if (op == 1) &#123; int res = 0; while (g[x] &lt;= n) res += f[x], x = g[x]; printf(\"%d\\n\", res + f[x]); &#125; else &#123; scanf(\"%d\", &amp;y); a[x] = y; for (int i = R[pos[x]]; i >= L[pos[x]]; --i) if (i + a[i] > R[pos[i]]) f[i] = 1, g[i] = i + a[i]; else f[i] = f[i + a[i]] + 1, g[i] = g[i + a[i]]; &#125; &#125; return 0; &#125; [Luogu P3863] åºåˆ— Portal. å¦‚æœåªæœ‰ä¸€ä¸ªæ•°æ˜¯å¥½åšçš„ï¼Œå¯¹æ—¶é—´è¿›è¡Œåˆ†å—ï¼ŒæŸ¥è¯¢åŒºé—´çš„æ’åã€‚è€Œæœ‰å¤šä¸ªæ•°ï¼Œç”¨æ‰«æçº¿æ¥ç¦»çº¿ç»´æŠ¤åºåˆ—å³å¯ï¼ˆå› ä¸ºæ˜¯å•ç‚¹æŸ¥è¯¢ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 300; int n, m, t, ans[100005]; int L[10005], R[10005], pos[100005]; int tot; i64 tag[10005]; struct Line &#123; int op, t, v; // t æ˜¯æ—¶é—´ç»´ä¸Šçš„ä½ç½® Line(int op = 0, int t = 0, int v = 0) : op(op), t(t), v(v) &#123;&#125; &#125;; vector&lt;Line> C[100005]; // åºåˆ—ç»´ struct Number &#123; int pos; i64 v; bool operator &lt; (const Number &amp;a) const &#123; if (v != a.v) return v &lt; a.v; return pos &lt; a.pos; &#125; &#125; a[100005]; void update(int l, int k) &#123; // [x, m] çš„æ—¶é—´åŠ ä¸Š k int p = pos[l]; for (int i = L[p]; i &lt;= R[p]; ++i) if (a[i].pos >= l) a[i].v += k; sort(a + L[p], a + R[p] + 1); for (int i = p + 1; i &lt;= t; ++i) tag[i] += k; &#125; int query(int r, i64 x) &#123; // [1, x] æœ‰å¤šå°‘ä¸å°äº y int res = 0, p = pos[r]; for (int i = L[p]; i &lt;= R[p]; ++i) if (a[i].pos &lt;= r &amp;&amp; a[i].v + tag[p] >= x) ++res; for (int i = 1; i &lt; p; ++i) res += R[i] - (lower_bound(a + L[i], a + R[i] + 1, Number&#123;0, x - tag[i]&#125;) - a) + 1; return res; &#125; int main(void) &#123; memset(ans, -1, sizeof ans); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, x; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); C[i].emplace_back(1, 0, x); C[i + 1].emplace_back(1, 0, -x); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int op, l, r, x; scanf(\"%d%d\", &amp;op, &amp;l); if (op == 1) &#123; scanf(\"%d%d\", &amp;r, &amp;x); C[l].emplace_back(1, i, x); C[r + 1].emplace_back(1, i, -x); &#125; else &#123; scanf(\"%d\", &amp;x); C[l].emplace_back(2, i, x); &#125; a[i] = &#123;i, 0&#125;; &#125; t = m / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; if (R[t] &lt; m) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = m; &#125; L[1] = 0; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 1; i &lt;= n; ++i) for (auto it : C[i]) if (it.op == 1) update(it.t, it.v); else ans[it.t] = query(it.t - 1, it.v); for (int i = 1; i &lt;= m; ++i) if (ans[i] != -1) printf(\"%d\\n\", ans[i]); return 0; &#125; æ™®é€šè«é˜Ÿ è¿™é‡Œæ˜¯æ™®é€šè«é˜Ÿã€‚ [SNOI2017] ä¸€ä¸ªç®€å•çš„è¯¢é—® Portal.ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º NNN çš„åºåˆ— aia_iaiâ€‹ï¼Œ1â‰¤iâ‰¤N1\\leq i\\leq N1â‰¤iâ‰¤Nï¼Œå’Œ qqq ç»„è¯¢é—®ï¼Œæ¯ç»„è¯¢é—®è¯»å…¥ l1,r1,l2,r2l_1,r_1,l_2,r_2l1â€‹,r1â€‹,l2â€‹,r2â€‹ï¼Œéœ€è¾“å‡ºâˆ‘x=0âˆget(l1,r1,x)Ã—get(l2,r2,x)\\sum\\limits_{x=0}^\\infty \\text{get}(l_1,r_1,x)\\times \\text{get}(l_2,r_2,x)x=0âˆ‘âˆâ€‹get(l1â€‹,r1â€‹,x)Ã—get(l2â€‹,r2â€‹,x)get(l,r,x)\\text{get}(l,r,x)get(l,r,x) è¡¨ç¤ºè®¡ç®—åŒºé—´ [l,r][l,r][l,r] ä¸­ï¼Œæ•°å­— xxx å‡ºç°äº†å¤šå°‘æ¬¡ã€‚ åˆ©ç”¨å·®åˆ†å°† get æ‹†å¼€ï¼Œç„¶åå°±å¯ä»¥ç›´æ¥ä½¿ç”¨è«é˜Ÿç»´æŠ¤äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 223; int n, m; int a[50005], pos[50005]; i64 Ans[50005], ans; struct Question &#123; int x, y, id, flag; Question(int x = 0, int y = 0, int id = 0, int flag = 0) : x(x), y(y), id(id), flag(flag) &#123;&#125; bool operator &lt; (const Question &amp;a) const &#123; if (pos[x] == pos[a.x]) return y &lt; a.y; return x &lt; a.x; &#125; &#125; Q[2000005]; int cx[500005], cy[500005]; void updatex(int p, int flag) &#123; cx[a[p]] += flag; ans += cy[a[p]] * flag; &#125; void updatey(int p, int flag) &#123; cy[a[p]] += flag; ans += cx[a[p]] * flag; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int l1, r1, l2, r2; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); Q[i * 4 - 3] = Question(r1, r2, i, 1); Q[i * 4 - 2] = Question(r1, l2 - 1, i, -1); Q[i * 4 - 1] = Question(r2, l1 - 1, i, -1); Q[i * 4] = Question(l1 - 1, l2 - 1, i, 1); &#125; for (int i = 1; i &lt;= m * 4; ++i) if (Q[i].x > Q[i].y) swap(Q[i].x, Q[i].y); sort(Q + 1, Q + m * 4 + 1); for (int i = 1, x = 0, y = 0; i &lt;= m * 4; ++i) &#123; for (; x + 1 &lt;= Q[i].x; ++x) updatex(x + 1, 1); for (; x - 1 >= Q[i].x; --x) updatex(x, -1); for (; y + 1 &lt;= Q[i].y; ++y) updatey(y + 1, 1); for (; y - 1 >= Q[i].y; --y) updatey(y, -1); Ans[Q[i].id] += ans * Q[i].flag; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%lld\\n\", Ans[i]); return 0; &#125; [Luogu P3604] ç¾å¥½çš„æ¯ä¸€å¤© Portal. æŸ¥è¯¢çš„å†…å®¹éå¸¸å¥—è·¯ï¼Œå‡ºç°å¥‡æ•°æ¬¡çš„å­—ç¬¦åªèƒ½æœ‰ä¸€ä¸ªï¼Œå¯ä»¥çœ‹æˆåŒºé—´å¼‚æˆ–ï¼Œå°†å­—ç¬¦çŠ¶å‹ï¼Œç›´æ¥è«é˜Ÿå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 500; int n, m, pos[60005]; uint Ans[60005]; char s[60005]; int a[60005]; struct Question &#123; int l, r, id; bool operator&lt; (const Question &amp;a) &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[60005]; uint ans, buc[67108870]; inline void add(int msk) &#123; ans += buc[msk]; ++buc[msk]; for (int i = 0; i &lt; 26; ++i) ans += buc[msk ^ (1 &lt;&lt; i)]; &#125; inline void del(int msk) &#123; --buc[msk]; ans -= buc[msk]; for (int i = 0; i &lt; 26; ++i) ans -= buc[msk ^ (1 &lt;&lt; i)]; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, s + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = (1 &lt;&lt; s[i] - 'a') ^ a[i - 1]; pos[i] = (i - 1) / BLOCK_SIZE + 1; &#125; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; while (r &lt; Q[i].r) add(a[++r]); while (r > Q[i].r) del(a[r--]); while (l > Q[i].l - 1) add(a[--l]); while (l &lt; Q[i].l - 1) del(a[l++]); Ans[Q[i].id] = ans; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%u\\n\", Ans[i]); return 0; &#125; [HNOI2016] å¤§æ•° Portal. è®¾ tit_itiâ€‹ ä»£è¡¨ [i,n][i,n][i,n] æ‰€ä»£è¡¨çš„æ•°ï¼Œè¿™æ ·å¯ä»¥ç›´æ¥ç›¸å‡ã€‚è¦æ±‚ (tlâˆ’tr+1)Ã·10kâ‰¡0(modp)(t_l-t_{r+1})\\div 10^{k}\\equiv 0\\pmod p(tlâ€‹âˆ’tr+1â€‹)Ã·10kâ‰¡0(modp)ã€‚ä¸¤è¾¹å¯ä»¥ç›´æ¥ç›¸ä¹˜ï¼Œå½“ä¸”ä»…å½“ pâ‰ 2,pâ‰ 5p\\ne 2,p\\ne 5pî€ =2,pî€ =5ï¼Œè¿™ä¸¤ç§æƒ…å†µçš„ç­”æ¡ˆå¯ä»¥åœ¨çº¿è®¡ç®—ï¼Œå‰©ä¸‹çš„ç”¨è«é˜Ÿç»´æŠ¤ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 5000; int n, p, m, pos[200005]; i64 Ans[200005]; char s[200005]; struct Query &#123; int l, r, id; bool operator&lt; (const Query &amp;a) const &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[200005]; namespace Subtask &#123; bool tag[15]; i64 cnt[200005], a[200005]; void MAIN(void) &#123; if (p == 2) tag[0] = tag[2] = tag[4] = tag[6] = tag[8] = 1; else tag[0] = tag[5] = 1; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = a[i - 1] + tag[s[i] - '0']; cnt[i] = cnt[i - 1] + tag[s[i] - '0'] * i; &#125; while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%lld\\n\", cnt[r] - cnt[l - 1] - (a[r] - a[l - 1]) * (l - 1)); &#125; &#125; &#125; i64 ans; int t[200005], c[200005], cnt[200005]; inline void add(int x) &#123; ans += cnt[x]; ++cnt[x]; &#125; inline void del(int x) &#123; --cnt[x]; ans -= cnt[x]; &#125; int main(void) &#123; scanf(\"%d%s%d\", &amp;p, s + 1, &amp;m); n = strlen(s + 1); if (p == 2 || p == 5) return Subtask::MAIN(), 0; for (int i = n, b = 1; i >= 1; --i, b = 10ll * b % p) &#123; c[i] = t[i] = (t[i + 1] + 1ll * (s[i] - '0') * b % p) % p; pos[i] = (i - 1) / BLOCK_SIZE + 1; &#125; sort(c + 1, c + n + 2); int nn = unique(c + 1, c + n + 2) - (c + 1); for (int i = 1; i &lt;= n + 1; ++i) t[i] = lower_bound(c + 1, c + nn + 1, t[i]) - c; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; ++Q[i].r; for (; r + 1 &lt;= Q[i].r; ++r) add(t[r + 1]); for (; r - 1 >= Q[i].r; --r) del(t[r]); for (; l + 1 &lt;= Q[i].l; ++l) del(t[l]); for (; l - 1 >= Q[i].l; --l) add(t[l - 1]); Ans[Q[i].id] = ans; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", Ans[i]); return 0; &#125; [HNOI2016] åºåˆ— Portal. è€ƒè™‘è®¾ fl,rf_{l,r}fl,râ€‹ ä»£è¡¨ [l,r][l,r][l,r] çš„ç­”æ¡ˆï¼Œpip_ipiâ€‹ ä¸º iii å¾€å‰ pi&lt;aip_i&lt;a_ipiâ€‹&lt;aiâ€‹ çš„ pip_ipiâ€‹ æœ€å°çš„ä½ç½®ã€‚é‚£ä¹ˆæœ‰ fl,r=fl,piâˆ’1+(iâˆ’pi+1)Ã—apif_{l,r}=f_{l,p_i-1}+(i-p_i+1)\\times a_{p_i}fl,râ€‹=fl,piâ€‹âˆ’1â€‹+(iâˆ’piâ€‹+1)Ã—apiâ€‹â€‹ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸ lll æ— å…³ï¼Œå› æ­¤å¯ä»¥é¢„å¤„ç†å‡º f1,if_{1,i}f1,iâ€‹ã€‚ è€ƒè™‘è«é˜Ÿç»´æŠ¤è¿™ä¸ªè¿‡ç¨‹ã€‚ä»¥ rrr çš„å‘å³å¢åŠ ä¸ºä¾‹ï¼Œæˆ‘ä»¬éœ€è¦ç»Ÿè®¡ âˆ‘i=lrfi,r\\sum_{i=l}^r f_{i,r}âˆ‘i=lrâ€‹fi,râ€‹ã€‚æ‰¾å‡º [l,r][l,r][l,r] ä¸­æœ€å°å€¼çš„ä½ç½® pppï¼Œå¯¹äº fl,râ‹¯fp,rf_{l,r}\\cdots f_{p,r}fl,râ€‹â‹¯fp,râ€‹ ç­”æ¡ˆéƒ½æ˜¯ apa_papâ€‹ã€‚ lll çš„ç§»åŠ¨ç»´æŠ¤ fff åç¼€å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int B = 350; int n, m; int a[100005], pos[100005]; struct Query &#123; int l, r, id; bool operator&lt; (const Query &amp;a) const &#123; if (pos[l] != pos[a.l]) return l &lt; a.l; if (pos[l] &amp; 1) return r &lt; a.r; return r > a.r; &#125; &#125; Q[100005]; i64 ans[100005], pre[100005], nxt[100005]; int l[100005], r[100005]; int st[100005], tot, f[17][100005]; inline int qpos(int l, int r) &#123; int k = __lg(r - l + 1); return a[f[k][l]] &lt; a[f[k][r - (1 &lt;&lt; k) + 1]] ? f[k][l] : f[k][r - (1 &lt;&lt; k) + 1]; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i], f[0][i] = i; for (int i = 1; 1 &lt;&lt; i &lt;= n; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) f[i][j] = (a[f[i - 1][j]] &lt; a[f[i - 1][j + (1 &lt;&lt; i - 1)]] ? f[i - 1][j] : f[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = i; while (l[i] > 1 &amp;&amp; a[i] &lt; a[l[i] - 1]) l[i] = l[l[i] - 1]; pre[i] = pre[l[i] - 1] + 1ll * (i - l[i] + 1) * a[i]; &#125; for (int i = n; i >= 1; --i) &#123; r[i] = i; while (r[i] &lt; n &amp;&amp; a[i] &lt; a[r[i] + 1]) r[i] = r[r[i] + 1]; nxt[i] = nxt[r[i] + 1] + 1ll * (r[i] - i + 1) * a[i]; &#125; for (int i = 1; i &lt;= n; ++i) pos[i] = (i - 1) / B + 1; for (int i = 1; i &lt;= m; ++i) cin >> Q[i].l >> Q[i].r, Q[i].id = i; sort(Q + 1, Q + m + 1); i64 res = 0; for (int L = 1, R = 0, i = 1; i &lt;= m; ++i) &#123; while (R &lt; Q[i].r) &#123; ++R; int p = qpos(L, R); res += 1ll * (p - L + 1) * a[p] + pre[R] - pre[p]; &#125; while (L > Q[i].l) &#123; --L; int p = qpos(L, R); res += 1ll * (R - p + 1) * a[p] + nxt[L] - nxt[p]; &#125; while (R > Q[i].r) &#123; int p = qpos(L, R); res -= 1ll * (p - L + 1) * a[p] + pre[R] - pre[p]; --R; &#125; while (L &lt; Q[i].l) &#123; int p = qpos(L, R); res -= 1ll * (R - p + 1) * a[p] + nxt[L] - nxt[p]; ++L; &#125; ans[Q[i].id] = res; &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; å¸¦ä¿®è«é˜Ÿ å¸¦ä¿®è«é˜Ÿçš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n53)O(n^{\\frac{5}{3}})O(n35â€‹)ï¼Œå—é•¿å– n23n^{\\frac{2}{3}}n32â€‹ï¼Œæ¯”è¾ƒæ…¢ã€‚ [WC2013] ç³–æœå…¬å›­ Portal. åˆ©ç”¨æ¬§æ‹‰åºå°†æ ‘ä¸Šçš„é“¾æ‹åˆ°çº¿æ€§ç»“æ„ä¸Šã€‚å‘ç°é“¾çš„å¤„ç†æ–¹å¼æ˜¯é“¾çš„ä¸¤ä¸ªç«¯ç‚¹ç¬¬ä¸€æ¬¡å‡ºç°ä½ç½®çš„ä¸€æ®µï¼ˆLCA è¦è®¨è®ºï¼‰ã€‚ç„¶åç›´æ¥å¸¦ä¿®è«é˜Ÿã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 3000; int n, m, q, pos[200005], lg[100005]; int idx[200005], tot, siz[100005], dep[100005]; int mi[17][100005], dfn[100005], num; int L[100005], R[100005]; int v[100005], w[100005], a[100005]; vector&lt;int> G[100005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; idx[++tot] = x; L[x] = tot; mi[0][dfn[x] = ++num] = fa; siz[x] = 1; dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); siz[x] += siz[y]; &#125; idx[++tot] = x; R[x] = tot; &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; struct Operation &#123; int l, r, lca, time, id; bool operator&lt; (const Operation &amp;a) const &#123; if (pos[l] == pos[a.l]) &#123; if (pos[r] == pos[a.r]) return time &lt; a.time; return r &lt; a.r; &#125; return l &lt; a.l; &#125; &#125; Q[100005]; struct Change &#123; int x, y; &#125; C[100005]; int c1, c2; i64 Ans[100005], ans; bool vis[100005]; int cnt[100005]; inline void modify(int x) &#123; if (vis[x]) ans -= 1ll * v[a[x]] * w[cnt[a[x]]--]; else ans += 1ll * v[a[x]] * w[++cnt[a[x]]]; vis[x] ^= 1; &#125; inline void update(int x) &#123; if (vis[C[x].x]) &#123; modify(C[x].x); swap(C[x].y, a[C[x].x]); modify(C[x].x); &#125; else swap(C[x].y, a[C[x].x]); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", v + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", w + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1; i &lt;= q; ++i) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; if (L[x] > L[y]) swap(x, y); int d = LCA(x, y); ++c1; if (x == d) Q[c1].l = L[x], Q[c1].r = L[y]; else Q[c1].l = R[x], Q[c1].r = L[y], Q[c1].lca = d; Q[c1].id = c1; Q[c1].time = c2; &#125; else &#123; C[++c2] = &#123;x, y&#125;; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; sort(Q + 1, Q + c1 + 1); for (int i = 1, l = 1, r = 0, lst = 0; i &lt;= c1; ++i) &#123; while (r &lt; Q[i].r) modify(idx[++r]); while (r > Q[i].r) modify(idx[r--]); while (l &lt; Q[i].l) modify(idx[l++]); while (l > Q[i].l) modify(idx[--l]); while (lst &lt; Q[i].time) update(++lst); while (lst > Q[i].time) update(lst--); if (Q[i].lca) modify(Q[i].lca); Ans[Q[i].id] = ans; if (Q[i].lca) modify(Q[i].lca); &#125; for (int i = 1; i &lt;= c1; ++i) printf(\"%lld\\n\", Ans[i]); return 0; &#125; å›æ»šè«é˜Ÿ è¿™é‡Œæ˜¯å›æ»šè«é˜Ÿã€‚ ã€æ¨¡æ¿ã€‘å›æ»šè«é˜Ÿ &amp; ä¸åˆ é™¤è«é˜Ÿ Portal. å¯ä»¥å†ç»ƒä¹ ä¸€ä¸‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 400; const int INF = 0x3f3f3f3f; int n, m; int a[200005], b[200005]; int pos[200005], L[1000], R[1000]; struct Question &#123; int l, r, id; bool operator &lt; (const Question &amp;a) const &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[200005]; int Ans[200005], ans; int st[200005], ed[200005], tpst[200005], tped[200005]; int vis[200005], lst[200005]; int main(void) &#123; scanf(\"%d\", &amp;n); int t = n / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int tot = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) st[a[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b] = INF; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1); memset(st, 0x3f, sizeof(st)); for (int i = 1, l = 1, r = 0, last = 0; i &lt;= m; ++i) &#123; if (pos[Q[i].l] == pos[Q[i].r]) &#123; int res = 0; for (int j = Q[i].l; j &lt;= Q[i].r; ++j) lst[a[j]] = j; for (int j = Q[i].l; j &lt;= Q[i].r; ++j) res = max(res, lst[a[j]] - j); for (int j = Q[i].l; j &lt;= Q[i].r; ++j) lst[a[j]] = 0; Ans[Q[i].id] = res; continue; &#125; if (pos[Q[i].l] != last) &#123; memset(st, 0x3f, sizeof(st)); memset(ed, 0, sizeof(ed)); last = pos[Q[i].l]; ans = 0; l = R[last] + 1, r = R[last]; &#125; for (; r + 1 &lt;= Q[i].r; ++r) &#123; int p = r + 1; st[a[p]] = min(st[a[p]], p); ed[a[p]] = max(ed[a[p]], p); ans = max(ans, ed[a[p]] - st[a[p]]); &#125; int _l = l, tmp = ans; for (; _l - 1 >= Q[i].l; --_l) &#123; int p = _l - 1; if (vis[a[p]] != i) &#123; vis[a[p]] = i; tpst[a[p]] = st[a[p]], tped[a[p]] = ed[a[p]]; &#125; tpst[a[p]] = min(tpst[a[p]], p), tped[a[p]] = max(tped[a[p]], p); tmp = max(tmp, tped[a[p]] - tpst[a[p]]); &#125; Ans[Q[i].id] = tmp; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", Ans[i]); return 0; &#125; å¤æ‚é—®é¢˜ ä¸€äº›æ¯”è¾ƒå›°éš¾çš„é—®é¢˜ã€‚ ã€ŒRdOI R3.5ã€RMSQ Portal. å°† aaa é‡æ–°ç¼–å·ï¼Œé—®é¢˜è½¬åŒ–ä¸ºæ±‚åŒºé—´æœ€é•¿è¿ç»­å­åºåˆ—ã€‚ è€ƒè™‘æš´åŠ›è¿›è¡Œ DPï¼šè®¾ fif_ifiâ€‹ ä»£è¡¨ä»¥ iii ç»“å°¾çš„æ•°çš„æœ€å¤§ç­”æ¡ˆï¼Œé‚£ä¹ˆ fi=fiâˆ’1+1f_{i}=f_{i-1}+1fiâ€‹=fiâˆ’1â€‹+1ã€‚ å°†åŸåºåˆ—åˆ†å—ï¼Œå¦‚æœæ²¡æœ‰æ•´å—åˆ™ç›´æ¥æš´åŠ›ï¼Œå¦åˆ™è€ƒç‡é¢„å¤„ç†å‡ºæ•´å—çš„ç­”æ¡ˆï¼Œç„¶åå°†é›¶æ•£å—çš„ç­”æ¡ˆåˆå¹¶è¿›æ•´å—ã€‚å¯æ˜¯æ€ä¹ˆåˆå¹¶ï¼Ÿå¥½åƒä¸å¤ªå¥½åšï¼Œæˆ‘ä»¬æ— æ³•é«˜æ•ˆé¢„å¤„ç†å‡ºæ•´å—çš„ DP å€¼ï¼Œæ— æ³•å¯¹æ•£å—è¿›è¡Œ DPã€‚ æƒ³æƒ³æœ‰æ²¡æœ‰ç®€å•çš„æ–¹æ³•ï¼Œæˆ‘ä»¬åœ¨æ‰©å±•å³åŒºé—´æ—¶ï¼Œä¼šå¯¹æ•´å—å†…çš„å…ƒç´ äº§ç”Ÿè´¡çŒ®ï¼Œä¹Ÿä¼šå¯¹å³åŒºé—´è‡ªå·±äº§ç”Ÿè´¡çŒ®ã€‚æ•´å—çš„å…ƒç´ å¹¶ä¸ä¼šæ”¹å˜ï¼æˆ‘ä»¬åªéœ€è¦é¢„å¤„ç†å‡ºæŸä¸€ä¸ªæ•´å—åˆ° iii çš„ DP æ•°ç»„å³å¯ï¼è½¬ç§»ä¹Ÿè¦å‘ç”Ÿæ”¹å˜ï¼Œè®¾ fif_ifiâ€‹ ä»£è¡¨ä»¥ iii å¼€å§‹çš„æœ€å¤§ç­”æ¡ˆï¼Œè¿™æ ·è®¡ç®—å¾ˆæ–¹ä¾¿ã€‚ åŒç†ï¼Œæˆ‘ä»¬é¢„å¤„ç†å‡ºæ¯ä¸€ä¸ªæ•´å—åˆ°åºåˆ—å¼€å¤´çš„ DP æ•°ç»„ï¼Œç„¶åç›´æ¥åˆå¹¶å³å¯ã€‚å¯ä»¥å°†è¿™ä¸€ä¸ª DP æ•°ç»„å­˜åˆ°ä¸‹ä¸ªæ•´å—çš„è®°å½•åˆ° iii çš„ DP æ•°ç»„ä¸­ï¼ˆå› ä¸ºå®ƒä»¬æ²¡æœ‰é‡åˆéƒ¨åˆ†ï¼‰ã€‚ è¿™æ ·å°±ä»¥ O(nn)O(n\\sqrt{n})O(nnâ€‹) åœ¨çº¿è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 450; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar(); return x; &#125; int m, n, q, T, tmp[300005], f[300005]; int b[300005], a[300005], bb[300005], Ans[805][805]; int pos[300005], L[805], R[805], ls[300005], rs[300005]; int pd[805][300005]; // pd[i] è®°å½• i åˆ°æœ«å°¾çš„ DPï¼Œpd[i + 1] è®°å½•å— i å°¾åˆ°å¤´éƒ¨çš„ DP inline int query(int l, int r) &#123; int p = pos[l] + 1, q = pos[r] - 1, ans = 0; // æ•´å—å·¦ç«¯å’Œå³ç«¯ if (p > q) &#123; for (int i = l; i &lt;= r; ++i) ans = max(ans, f[a[i]] = f[a[i] - 1] + 1); for (int i = l; i &lt;= r; ++i) f[a[i]] = 0; return ans; &#125; ans = Ans[p][q]; // å³åŒºé—´æ‰©å±• // å¯¹æ•´å—è´¡çŒ®ï¼Œå¯¹å³æ•£å—ä¹‹å‰çš„å…ƒç´ è´¡çŒ® for (int i = R[q] + 1; i &lt;= r; ++i) &#123; f[a[i] - pd[p][i] + 1] = max(f[a[i] - pd[p][i] + 1], pd[p][i]); ans = max(ans, f[a[i] - pd[p][i] + 1]); &#125; // å·¦åŒºé—´æ‰©å±• // è‡ªå·±è´¡çŒ®ï¼Œå¯¹å³æ•£å—è´¡çŒ® | å¯¹æ•´å—è´¡çŒ® for (int i = L[p] - 1; i >= l; --i) &#123; f[a[i]] = max(&#123;f[a[i]], f[a[i] + 1] + 1, pd[q + 1][i]&#125;); // prer[q][i] ans = max(ans, f[a[i]]); &#125; for (int i = R[q] + 1; i &lt;= r; ++i) f[a[i] - pd[p][i] + 1] = 0; for (int i = L[p] - 1; i >= l; --i) f[a[i]] = 0; return ans; &#125; int main(void) &#123; m = read(), n = read(), q = read(), T = read(); for (int i = 1; i &lt;= m; ++i) b[read()] = i; for (int i = 1; i &lt;= n; ++i) a[i] = b[read()]; int t = n / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; if (R[t] &lt; n) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = n; &#125; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 1; i &lt;= n; ++i) ls[i] = tmp[a[i] - 1], tmp[a[i]] = i; memset(tmp, 0, sizeof tmp); for (int i = n; i >= 1; --i) rs[i] = tmp[a[i] + 1], tmp[a[i]] = i; for (int l = 1; l &lt;= n; l += BLOCK_SIZE) &#123; int ans = 0; int *dp = pd[pos[l]]; // ç»´æŠ¤ç¬¬ l å—åˆ°æœ«å°¾çš„ DP æ•°ç»„ for (int r = l; r &lt;= n; ++r) &#123; ans = max(ans, dp[r] = dp[ls[r]] + 1); if (pos[r] != pos[r + 1]) Ans[pos[l]][pos[r]] = ans; &#125; &#125; for (int r = BLOCK_SIZE; r &lt;= n; r += BLOCK_SIZE) &#123; int *dp = pd[pos[r] + 1]; for (int l = r; l >= 1; --l) f[l] = f[rs[l]] + 1; for (int l = r; l >= 1; --l) dp[l] = f[l]; memset(f, 0, sizeof f); &#125; for (int last = 0; q--; ) &#123; int l = read(), r = read(); if (T) l ^= last, r ^= last; printf(\"%d\\n\", last = query(l, r)); &#125; return 0; &#125; [Ynoi2007] rfplca Portal. ç»´æŠ¤ä¸€ä¸ªæ•°çš„çˆ¶äº²å’Œè·³å‡ºå—å†…çš„çˆ¶äº²ã€‚æ•£å—æš´åŠ›é‡æ„å—çš„ä¿¡æ¯ï¼Œæ•´å—è¢«ä¿®æ”¹å—é•¿æ¬¡ä»¥ä¸Šåä¼šç›´æ¥è·³å‡ºå—ï¼Œçˆ¶äº²å€¼å¯ä»¥ç›´æ¥è®¡ç®—ã€‚æŸ¥è¯¢æ—¶æœ€å¤šè·³å—çš„ä¸ªæ•°æ¬¡ã€‚æ—¶é—´å¤æ‚åº¦ O(nn)O(n\\sqrt{n})O(nnâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 600; int n, m; int fa[400005], L[4005], R[4005], tag[4005], c[4005], pos[400005], pa[400005]; inline void change(int i) &#123; if (pos[i] == pos[fa[i]]) pa[i] = pa[fa[i]]; else pa[i] = fa[i]; &#125; void rebuild(int l, int r, int x) &#123; for (int i = l; i &lt;= r; ++i) fa[i] = max(fa[i] - x, 1); for (int i = l; i &lt;= R[pos[l]]; ++i) change(i); &#125; void update(int l, int r, int x) &#123; int p = pos[l], q = pos[r]; if (p == q) return rebuild(l, r, x); rebuild(l, R[p], x); rebuild(L[q], r, x); for (int i = p + 1; i &lt; q; ++i) &#123; if (c[i] &lt;= BLOCK_SIZE) &#123; for (int j = L[i]; j &lt;= R[i]; ++j) fa[j] = max(fa[j] - x, 1), change(j); &#125; else tag[i] = min(tag[i] + x, n); ++c[i]; &#125; &#125; inline int Pa(int x) &#123; if (c[pos[x]] &lt;= BLOCK_SIZE) return pa[x]; return max(1, fa[x] - tag[pos[x]]); &#125; inline int Fa(int x) &#123; if (c[pos[x]] &lt;= BLOCK_SIZE) return fa[x]; return max(1, fa[x] - tag[pos[x]]); &#125; int query(int u, int v) &#123; while (u != v) &#123; int pu = Pa(u), pv = Pa(v); if (pos[pu] != pos[pv]) pos[pu] &lt; pos[pv] ? v = pv : u = pu; else if (pu != pv) pu &lt; pv ? v = pv : u = pu; else u &lt; v ? v = Fa(v) : u = Fa(u); &#125; return u; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); fa[1] = pa[1] = 1; int t = (n - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 2; i &lt;= n; ++i) scanf(\"%d\", fa + i), change(i); for (int last = 0; m--; ) &#123; int op, l, r, x; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); l ^= last, r ^= last; if (op == 1) scanf(\"%d\", &amp;x), x ^= last, update(l, r, x); else printf(\"%d\\n\", last = query(l, r)); &#125; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"æ•°æ®ç»“æ„","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"åˆ†å—","slug":"åˆ†å—","permalink":"https://james1badcreeper.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"æ•°æ®ç»“æ„f","slug":"æ•°æ®ç»“æ„f","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84f/"}]},{"title":"2023 å¹´ 2ã€3 æœˆåšé¢˜è®°å½•","slug":"default/åšé¢˜è®°å½•/2023-2","date":"2023-02-18T00:00:00.000Z","updated":"2023-01-08T00:00:00.000Z","comments":true,"path":"d9f4b0a5/","link":"","permalink":"https://james1badcreeper.github.io/d9f4b0a5/","excerpt":"","text":"æ¿åˆ·æ²¡æœ‰å¤ªå¤§æ„ä¹‰ã€‚Codeforces çš„çœŸæ­£ä½œç”¨æ˜¯ä¸€ä¸ªåºå¤§çš„é¢˜åº“ï¼Œè¯·å–„ç”¨ Problemset çš„æ ‡ç­¾åŠŸèƒ½ã€‚ æ‰“ * çš„ä»£è¡¨ç„äº†çœ¼é¢˜è§£ï¼Œæ‰“ ** çš„ä»£è¡¨å‹æ ¹ä¸ä¼šã€‚ ç¬¬å››å‘¨ ï¼Ÿï¼Ÿï¼Ÿ 2.18 å¼€å§‹äº†ï¼ * [CF1788D] Moving Dots *2000 Portal. æ­£å¸¸æ¥è®²ä¼šæ±‡èšåˆ°ä¸€ä¸ªç‚¹ï¼Œç­”æ¡ˆä¸º 2nâˆ’nâˆ’12^n-n-12nâˆ’nâˆ’1ã€‚å¦‚æœä¼šåœç•™åœ¨å¤šä¸ªä½ç½®ï¼Œä»…å½“å­˜åœ¨ä¸€å¯¹ç›¸é‚»çš„ç‚¹ä¼šæ¯…ç„¶ç›¸èƒŒè€Œç¦»ï¼Œè¿™æ—¶å€™å¯ä»¥ç»Ÿè®¡æœ‰å¤šå°‘ç§æƒ…å†µä¼šä½¿å¾—è¿™ä¸¤ä¸ªç‚¹æ˜¯ç›¸é‚»çš„ã€‚å‘ç°æ¯å­˜åœ¨ä¸€å¯¹è¿™æ ·çš„ç‚¹ï¼Œç­”æ¡ˆå°±ä¼šå˜å¤§ä¸€ã€‚ O(n2logâ¡n)O(n^2\\log n)O(n2logn) ç»Ÿè®¡å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n; int a[3005], p[3005]; int find(int x) &#123; int L = 0, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (a[mid] >= x) R = mid; else L = mid; &#125; return R; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = p[0] = 1; i &lt;= n; ++i) p[i] = 1ll * p[i - 1] * 2 % P; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); int res = 0; for (int l = 1; l &lt; n; ++l) for (int r = l + 1; r &lt;= n; ++r) &#123; int len = a[r] - a[l]; int x = find(a[l] - len), y = find(a[r] + len) - 1; if (x >= l || y &lt;= r) continue; res = (res + 1ll * (p[l - x] - 1) * (p[y - r] - 1) % P * p[x - 1] % P * p[n - y] % P) % P; &#125; printf(\"%d\\n\", ((p[n] - n - 1 + res) % P + P) % P); return 0; &#125; [CF1780F] Three Chairs *2300 Portal. å°† aaa æ’åºï¼Œè¦æ±‚çš„å°±æ˜¯ï¼š ans=âˆ‘1â‰¤i&lt;jâ‰¤n(jâˆ’i+1)[gcdâ¡(ai,aj)=1]=âˆ‘1â‰¤i&lt;jâ‰¤n(jâˆ’i+1)âˆ‘dâˆ£ai,dâˆ£ajÎ¼(d)=âˆ‘dÎ¼(d)âˆ‘1â‰¤i&lt;jâ‰¤kpjâˆ’piâˆ’1\\begin{aligned} ans&amp;=\\sum_{1\\le i&lt;j\\le n} (j-i+1)[\\gcd(a_i, a_j)=1]\\\\ &amp;=\\sum_{1\\le i&lt;j\\le n} (j-i+1)\\sum_{d\\mid a_i,d\\mid a_j}\\mu(d)\\\\ &amp;=\\sum_{d}\\mu(d)\\sum_{1\\le i&lt;j\\le k} p_j-p_i-1 \\end{aligned} ansâ€‹=1â‰¤i&lt;jâ‰¤nâˆ‘â€‹(jâˆ’i+1)[gcd(aiâ€‹,ajâ€‹)=1]=1â‰¤i&lt;jâ‰¤nâˆ‘â€‹(jâˆ’i+1)dâˆ£aiâ€‹,dâˆ£ajâ€‹âˆ‘â€‹Î¼(d)=dâˆ‘â€‹Î¼(d)1â‰¤i&lt;jâ‰¤kâˆ‘â€‹pjâ€‹âˆ’piâ€‹âˆ’1â€‹ å…¶ä¸­ ppp è¡¨ç¤ºæ˜¯ ddd çš„å€æ•°çš„æ•°çš„ä¸‹æ ‡ä½ç½®ã€‚ç®€å•è½¬åŒ–ä¸€ä¸‹è´¡çŒ®ï¼Œåé¢é‚£ä¸€å¨å°±æ˜¯ï¼š âˆ’k(kâˆ’1)2+âˆ‘i=1kpiÃ—(2iâˆ’kâˆ’1)-\\frac{k(k-1)} 2+\\sum_{i=1}^{k}p_i\\times (2i-k-1) âˆ’2k(kâˆ’1)â€‹+i=1âˆ‘kâ€‹piâ€‹Ã—(2iâˆ’kâˆ’1) æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 300000; int n; int a[300005], mu[300005]; int prime[100005], tot, pos[300005], idx[300005]; bool v[300005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); mu[1] = 1; for (int i = 1; i &lt;= n; ++i) pos[a[i]] = i; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; i64 ans = 0; for (int d = 1; d &lt;= N; ++d) if (mu[d]) &#123; int k = 0; for (int i = d; i &lt;= N; i += d) if (pos[i]) idx[++k] = pos[i]; i64 res = -1ll * k * (k - 1) / 2; for (int i = 1; i &lt;= k; ++i) res += 1ll * idx[i] * (2 * i - k - 1); ans += mu[d] * res; &#125; printf(\"%lld\\n\", ans); return 0; &#125; 2.21 é¸½äº†å¥½å‡ å¤© ** [CF1781F] Bracket Insertion *2700 Portal. tourist çš„ç¥ä»™é¢˜ï¼Œorzã€‚ é‡‡ç”¨å¸¸è§çš„æ‹¬å·å¤„ç†æ–¹æ³•ï¼Œè®¾ ( = 1, ) = -1ï¼Œéœ€è¦è®©æœ€å°å‰ç¼€å’Œä¸º 000ã€‚åœ¨å‰ç¼€å’Œ xxx åé¢æ’å…¥ () å¯ä»¥å¾—åˆ° x,x+1,xx,x+1,xx,x+1,xï¼Œæ’å…¥ )( å¯ä»¥å¾—åˆ° x,xâˆ’1,xx,x-1,xx,xâˆ’1,xã€‚ å‰ç¼€å’Œæ€ä¹ˆç»´æŠ¤ï¼Ÿè®¾ fn,xf_{n,x}fn,xâ€‹ ä»£è¡¨è¦å¯¹å‰ç¼€å’Œ xxx æ nnn æ¬¡ä¾ç„¶åˆæ³•çš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆï¼š fn,x=âˆ‘i=0nâˆ’1âˆ‘j=0nâˆ’1âˆ’ip(nâˆ’1i)(nâˆ’1âˆ’ij)fi,xfj,x+1fnâˆ’1âˆ’iâˆ’j,x+âˆ‘i=0nâˆ’1âˆ‘j=0nâˆ’1âˆ’i(1âˆ’p)(nâˆ’1i)(nâˆ’1âˆ’ij)fi,xfj,xâˆ’1fnâˆ’1âˆ’iâˆ’j,xf_{n,x}= \\sum\\limits_{i=0}^{n-1} \\sum\\limits_{j=0}^{n-1-i} p \\binom{n-1}{i} \\binom{n-1-i}{j} f_{i, x} f_{j, x + 1} f_{n - 1 - i - j, x}\\\\ + \\sum\\limits_{i=0}^{n-1} \\sum\\limits_{j=0}^{n-1-i} (1 - p) \\binom{n-1}{i} \\binom{n-1-i}{j} f_{i, x} f_{j, x - 1} f_{n - 1 - i - j, x} fn,xâ€‹=i=0âˆ‘nâˆ’1â€‹j=0âˆ‘nâˆ’1âˆ’iâ€‹p(inâˆ’1â€‹)(jnâˆ’1âˆ’iâ€‹)fi,xâ€‹fj,x+1â€‹fnâˆ’1âˆ’iâˆ’j,xâ€‹+i=0âˆ‘nâˆ’1â€‹j=0âˆ‘nâˆ’1âˆ’iâ€‹(1âˆ’p)(inâˆ’1â€‹)(jnâˆ’1âˆ’iâ€‹)fi,xâ€‹fj,xâˆ’1â€‹fnâˆ’1âˆ’iâˆ’j,xâ€‹ åˆ©ç”¨ä¹˜æ³•åˆ†é…å¾‹æŠŠ jjj ç›¸å…³çš„ä¸œè¥¿æå‡ºæ¥å¯ä»¥æ¶ˆæ‰ä¸€ä¸ªæ±‚å’Œç¬¦å·ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦ä¸º O(n3)O(n^3)O(n3)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; inline void add(i64 &amp;x, i64 t) &#123; x = (x + t) % P; &#125; int n, p, C[505][505]; i64 f[505][505], g[505][505]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); p = 1ll * p * poww(10000, P - 2) % P; for (int i = 0; i &lt;= n; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; for (int i = 0; i &lt;= n; ++i) f[0][i] = g[0][i] = 1; for (int i = 1; i &lt;= n; ++i) for (int x = 0; x &lt;= n; ++x) &#123; for (int j = 0; j &lt; i; ++j) add(f[i][x], C[i - 1][j] * (p * f[j][x + 1] % P + (1 - p + P) * (x ? f[j][x - 1] : 0) % P) % P * g[i - j - 1][x] % P); for (int j = 0; j &lt;= i; ++j) add(g[i][x], C[i][j] * f[j][x] % P * f[i - j][x] % P); &#125; i64 ans = f[n][0]; for (int i = 1; i &lt;= n * 2; i += 2) ans = ans * poww(i, P - 2) % P; printf(\"%lld\\n\", ans); return 0; &#125; 2.22 ä¸ºä»€ä¹ˆæˆ‘è¿™ä¹ˆæ‘†ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿå•¥éƒ½ä¸ä¼šè¿˜æ‘†ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿç ´å¤§é˜²ã€‚ ** [CF1591F] Non-equal Neighbours *2400 Portal. ä»¤ fi,0/1f_{i,0/1}fi,0/1â€‹ è¡¨ç¤ºå°† a1â€¦ia_{1\\dots i}a1â€¦iâ€‹ åˆ’åˆ†æˆå¶æ•°/å¥‡æ•°æ®µçš„æ–¹æ¡ˆæ•°ï¼Œåˆ’åˆ†æˆçš„æ®µè¦æ±‚å†…éƒ¨å…¨éƒ¨ç›¸ç­‰ã€‚é‚£ä¹ˆæ ¹æ®å®¹æ–¥åŸç†ï¼Œç­”æ¡ˆä¸º (âˆ’1)n(fn,0âˆ’fn,1)(-1)^n (f_{n,0}-f_{n,1})(âˆ’1)n(fn,0â€‹âˆ’fn,1â€‹)ã€‚ è½¬ç§»å¾ˆç®€å•ï¼Œæšä¸¾å½“å‰è¿™ä¸€æ®µçš„å·¦ç«¯ç‚¹å³å¯ï¼š fi,0/1=âˆ‘j=1ifjâˆ’1,1/0Ã—minâ¡{ajâ€¦i}f_{i,0/1}=\\sum_{j=1}^{i}f_{j-1,1/0}\\times \\min\\{a_{j\\dots i}\\} fi,0/1â€‹=j=1âˆ‘iâ€‹fjâˆ’1,1/0â€‹Ã—min{ajâ€¦iâ€‹} è€ƒè™‘åˆ©ç”¨ minâ¡\\minmin çš„å•è°ƒæ€§æ¥ä¼˜åŒ–å¤æ‚åº¦ã€‚ç»´æŠ¤ä¸€ä¸ª aia_iaiâ€‹ ä¸¥æ ¼é€’å¢çš„å•è°ƒæ ˆï¼Œè€ƒè™‘æ‰«æåˆ° iii æ—¶çš„æ ˆé¡¶åœ¨åºåˆ—ä¸­çš„ä¸‹æ ‡ä¸º xxxï¼Œé‚£ä¹ˆï¼š fi,0/1=fx,0/1+aiâˆ‘j=x+1ifjâˆ’1,1/0f_{i,0/1}=f_{x,0/1}+a_i\\sum_{j=x+1}^i f_{j-1,1/0} fi,0/1â€‹=fx,0/1â€‹+aiâ€‹j=x+1âˆ‘iâ€‹fjâˆ’1,1/0â€‹ å› ä¸ºå·¦ç«¯ç‚¹ xxx ä¹‹åçš„æœ€å°å€¼å…¨æ˜¯ aia_iaiâ€‹ï¼Œè€Œå¯¹äºå·¦ç«¯ç‚¹åœ¨ xxx åŠå‰é¢ aia_iaiâ€‹ å¯¹æœ€å°å€¼æ²¡æœ‰å½±å“ï¼Œç›´æ¥å°±æ˜¯ fx,0f_{x,0}fx,0â€‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 998244353; int n, a[200005], st[200005], tot; i64 f[200005][2], s[200005][2]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); f[0][0] = s[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; while (tot &amp;&amp; a[st[tot]] >= a[i]) --tot; f[i][0] = ((tot ? f[st[tot]][0] : 0) + (s[i - 1][1] - (tot ? s[st[tot] - 1][1] : 0)) * a[i]) % P; f[i][1] = ((tot ? f[st[tot]][1] : 0) + (s[i - 1][0] - (tot ? s[st[tot] - 1][0] : 0)) * a[i]) % P; s[i][0] = (s[i - 1][0] + f[i][0]) % P; s[i][1] = (s[i - 1][1] + f[i][1]) % P; st[++tot] = i; &#125; printf(\"%lld\\n\", (((n &amp; 1) ? -1 : 1) * (f[n][0] - f[n][1]) % P + P) % P); return 0; &#125; 2.23 æˆ‘æ­»ã€‚ ** [CF888F] Connecting Vertices *2500 Portal. å¯ä»¥å°†å¤šè¾¹å½¢å±•å¼€æˆä¸€æ¡é“¾ï¼Œè¿è¾¹æ—¶åªèƒ½è¦†ç›–æˆ–ä¸äº¤ã€‚è€ƒè™‘åŒºé—´ DPï¼Œå¯ä»¥æšä¸¾ä¸­é—´çš„è¿æ¥ç‚¹ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ [l,r][l,r][l,r] è¿æ¥ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; int n, a[505][505]; int f[505][505][2]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[i][j]); for (int i = 1; i &lt;= n; ++i) f[i][i][0] = 1; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (a[i][j]) &#123; for (int k = i; k &lt; j; ++k) add(f[i][j][1], 1ll * (f[i][k][0] + f[i][k][1]) * (f[k + 1][j][0] + f[k + 1][j][1]) % P); &#125; for (int k = i + 1; k &lt; j; ++k) if (a[i][k]) add(f[i][j][0], 1ll * f[i][k][1] * (f[k][j][0] + f[k][j][1]) % P); &#125; printf(\"%d\\n\", (f[1][n][0] + f[1][n][1]) % P); return 0; &#125; 2.24 æˆ‘æ€ä¹ˆä»€ä¹ˆéƒ½ä¸ä¼šã€‚ ** [CF840C] On the Bench *2500 Portal. é¦–å…ˆä¹˜ç§¯ä¸ºå®Œå…¨å¹³æ–¹æ•°æœ‰ç±»ä¼¼ä¸ä¼ é€’æ€§çš„æ€§è´¨ï¼Œå› æ­¤å¯ä»¥å°†æ•°åˆ†ä¸º mmm ç»„ï¼Œç¬¬ iii ç»„çš„æ•°å­—ä¸ªæ•°ä¸º sis_isiâ€‹ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªç»„ï¼Œæœ‰ jjj ä¸ªç›¸é‚»æ•°ä¹˜ç§¯ä¸ºå®Œå…¨å¹³æ–¹æ•°çš„å¯¹ã€‚å¯ä»¥å°†ç¬¬ iii ä¸ªç»„åˆ†æˆ kkk ä¸ªè¿ç»­æ®µï¼ˆè¿™ä¸€éƒ¨åˆ†çš„æ–¹æ¡ˆæ•°å¯ä»¥é¢„å¤„ç†ï¼‰ï¼Œä¸åˆæ³•çš„æ•°é‡ä¼šå¢åŠ  siâˆ’ks_i-ksiâ€‹âˆ’kï¼Œç„¶åé€‰æ‹©ç ´åæ‰ä¹‹é—´ jjj ä¸ªç›¸é‚»ä¸­çš„ l(0â‰¤lâ‰¤k)l(0\\le l\\le k)l(0â‰¤lâ‰¤k) ä¸ªï¼Œè¿™æ · fiâˆ’1,jf_{i-1,j}fiâˆ’1,jâ€‹ è½¬ç§»åˆ°äº† fi,j+siâˆ’kâˆ’lf_{i,j+s_i-k-l}fi,j+siâ€‹âˆ’kâˆ’lâ€‹ã€‚åœ¨ jjj ä¸­é€‰æ‹© lll ä¸ªç ´åæ‰ä¼šä½¿ç”¨è¿™ä¸€ç»„ä¸­çš„ lll æ®µï¼Œè¿˜å‰© kâˆ’lk-lkâˆ’l æ®µé€‰æ‹©æ’å…¥åœ¨å‰©ä¸‹çš„ sum+1âˆ’jsum+1-jsum+1âˆ’j ä¸ªç©ºä¸­å³å¯ï¼ˆsum=âˆ‘p=1iâˆ’1sisum=\\sum_{p=1}^{i-1}s_isum=âˆ‘p=1iâˆ’1â€‹siâ€‹ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000007; int n, m, cnt[305], p[305]; int a[305]; int C[305][305]; int f[305][305], g[305][305]; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; // g[i][j] : å°† i ä¸ªä¸åŒçš„æ•°åˆ†æˆ k ä¸ªè¿ç»­æ®µè½ int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); bool flag = 0; for (int j = 1; j &lt;= m; ++j) &#123; i64 u = 1ll * p[j] * a[i], v = sqrt(u); if (v * v == u) &#123; ++cnt[j]; flag = 1; break; &#125; &#125; if (!flag) p[++m] = a[i], cnt[m] = 1; &#125; for (int i = 0; i &lt;= n; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; f[0][0] = 1, g[0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= i; ++j) g[i][j] = (1ll * g[i - 1][j] * (i - 1 + j) + 1ll * g[i - 1][j - 1] * j) % P; int sum = 0; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 0; j &lt;= sum; ++j) for (int k = 1; k &lt;= cnt[i]; ++k) for (int l = 0; l &lt;= k; ++l) add(f[i][j + (cnt[i] - k) - l], 1ll * f[i - 1][j] * g[cnt[i]][k] % P * C[j][l] % P * C[sum + 1 - j][k - l] % P); sum += cnt[i]; &#125; printf(\"%d\\n\", f[m][0]); return 0; &#125; 2.28 å“¼å“¼ï¼Œè¿™éƒ½è¦ NOIP äº†ã€‚ [CF1779F] Xorcererâ€™s Stones *2500 Portal. æ‹æˆ DFS åºåœ¨åºåˆ—ä¸Šåšã€‚ä»æ ¹å¾€å­æ ‘è¿›è¡Œæ“ä½œï¼ˆå¦åˆ™äº¤æ¢ä¹Ÿå¯ï¼‰ï¼Œæ‰€ä»¥è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨è€ƒè™‘åˆ° [1,iâˆ’1][1,i-1][1,iâˆ’1] çš„é€‰æ‹©æƒ…å†µï¼Œå½“å‰çš„å¼‚æˆ–å’Œä¸º jjjï¼Œè®°å½•ä»å“ªé‡Œæ¥çš„å’Œå¼‚æˆ–å€¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int sum[200005], siz[200005], idx[200005], num; vector&lt;int> G[200005]; pair&lt;int, int> f[200005][32]; void dfs(int x) &#123; idx[++num] = x; siz[x] = 1; for (int y : G[x]) dfs(y), siz[x] += siz[y], sum[x] ^= sum[y]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", sum + i); for (int i = 2; i &lt;= n; ++i) &#123; int f; scanf(\"%d\", &amp;f); G[f].emplace_back(i); &#125; dfs(1); memset(f, -1, sizeof f); f[1][sum[1]] = &#123;0, 0&#125;; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; 32; ++j) if (f[i][j].first != -1) &#123; int v = (siz[idx[i]] &amp; 1) ? 0 : sum[idx[i]]; f[i + 1][j] = &#123;i, j&#125;; f[i + siz[idx[i]]][j ^ v] = &#123;i, j&#125;; &#125; if (f[n + 1][0].first == -1) return puts(\"-1\"), 0; vector&lt;int> ans; int u = n + 1, v = 0; while (u) &#123; int tu = f[u][v].first, tv = f[u][v].second; if (u - tu == siz[idx[tu]]) ans.emplace_back(idx[tu]); u = tu, v = tv; &#125; ans.emplace_back(1); printf(\"%d\\n\", ans.size()); for (int x : ans) printf(\"%d \", x); putchar('\\n'); return 0; &#125; * [CF1733E] Conveyor *2700 Portal. è°”è°”é¢˜ã€‚ä¾¿è°”è°”åœ°å¼€å§‹æƒ³ã€‚ æ˜¾ç„¶ä¸¤åªå²è±å§†ä¸ä¼šå˜æˆå¤§å²è±å§†ã€‚å› ä¸ºè·ç¦»éƒ½ä¸ä¸€æ ·ã€‚ è¿™æ ·æ±‚å‡º ttt æ—¶åˆ»å†…æ‰€æœ‰ç»è¿‡ x,yx,yx,y çš„å²è±å§†æ˜¯å®¹æ˜“è®¡ç®—çš„ã€‚å‘ç°ç»è¿‡ (x,y)(x,y)(x,y) çš„ aaa å²è±å§†æœ‰ âŒˆa2âŒ‰\\left\\lceil\\frac a 2 \\right\\rceilâŒˆ2aâ€‹âŒ‰ èµ°åˆ° (x,y+1)(x,y+1)(x,y+1)ï¼ŒâŒŠa2âŒ‹\\left\\lfloor\\frac a 2 \\right\\rfloorâŒŠ2aâ€‹âŒ‹ èµ°åˆ° (x+1,y)(x+1,y)(x+1,y)ã€‚ ä¼¼ä¹å¯ä»¥é€’æ¨ï¼ä½†æ˜¯æ³¨æ„åˆå§‹æ—¶ f0,0=tâˆ’xâˆ’y+1f_{0,0}=t-x-y+1f0,0â€‹=tâˆ’xâˆ’y+1ã€‚å› ä¸ºåœ¨è¿™ä¸ªæ—¶åˆ»å¼€å§‹ï¼Œæ–°å‡ºç”Ÿçš„å²è±å§†å°±åˆ°ä¸äº† (x,y)(x,y)(x,y)ã€‚ è¿™æ ·å·®åˆ†ï¼Œçœ‹ tâˆ’1t-1tâˆ’1 å’Œ ttt æ—¶åˆ»ç»è¿‡ (x,y)(x,y)(x,y) çš„å²è±å§†ä¸ªæ•°ï¼Œç›¸ç­‰çš„è¯å°±æ²¡æœ‰å²è±å§†åœ¨ ttt æ—¶åˆ»å‡ºç°åœ¨ (x,y)(x,y)(x,y)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000007; i64 t, f[125][125]; int x, y; i64 calc(i64 t, int x, int y) &#123; if (x + y > t) return 0; memset(f, 0, sizeof f); f[0][0] = t - x - y + 1; for (int i = 0; i &lt; 120; ++i) for (int j = 0; j &lt; 120; ++j) &#123; f[i][j + 1] += f[i][j] + 1 >> 1; f[i + 1][j] += f[i][j] >> 1; &#125; return f[x][y]; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld%d%d\", &amp;t, &amp;x, &amp;y); if (t == 0) puts(x == 0 &amp;&amp; y == 0 ? \"YES\" : \"NO\"); else puts(calc(t - 1, x, y) == calc(t, x, y) ? \"NO\" : \"YES\"); &#125; return 0; &#125; 3.1 æˆ‘è°”è°”ã€‚ * [CF1774F2] Magician and Pigs *2700 Portal. éå¸¸æœ‰è¶£ã€‚ è€ƒè™‘å¤åˆ¶æ“ä½œæ˜¯å¹²äº†ä»€ä¹ˆã€‚æ–°ç”Ÿæˆçš„çŒªå’ŒåŸæ¥çš„çŒªæ˜¯ä¸€æ ·çš„ï¼Œä½†åŸæ¥çš„çŒªè¿˜è¦å†å—åˆ°ä¸€éä¼¤å®³æ‰“å‡»ã€‚æ‰€ä»¥è¯´ï¼Œç›¸å½“äºå¤åˆ¶æ“ä½œä¼šå…‹éš†å‡ºå½“å‰æ‰€æœ‰çš„çŒªï¼Œç„¶åè®©å…‹éš†çŒªå†æ‰¿å—ä¸€éå‰é¢å—åˆ°çš„ä¼¤å®³ã€‚ è¿™æ ·å¯ä»¥å¤„ç†å‡ºæ¯ä¸ªå¤åˆ¶æ“ä½œå‰é¢æ‰€é™„å¸¦çš„ä¼¤å®³ï¼Œç„¶åå€’åºæ‰«æã€‚å¯¹äºæ¯ä¸€å¤´çŒªï¼Œå…ˆå‡æ‰å®ƒåé¢ä¼šè¢«æ‰£å»çš„è¡€é‡ã€‚ç„¶åä»åå¾€å‰æ‰«ææ‰€æœ‰çš„å¤åˆ¶æ“ä½œçœ‹å…¶æ˜¯å¦å¯ä»¥è¿›è¡Œã€‚å¦‚æœè¿™å¤´çŒªå¯ä»¥åƒå¾—ä½è¿™ä¸ªå¤åˆ¶æ“ä½œæ‰“å‡ºçš„ä¼¤å®³ï¼Œé‚£ä¹ˆè¿™ä¸ªå¤åˆ¶æ“ä½œä¹‹å‰çš„æ‰€æœ‰å¤åˆ¶æ“ä½œæ‰€å…‹éš†å‡ºçš„çŒªéƒ½æ˜¯å¯ä»¥å­˜æ´»åˆ°æœ€åçš„ã€‚ç„¶åçŒªçš„è¡€é‡è¦å‡å»è¿™ä¸ªä¼¤å®³ï¼ˆæ¥ä¸‹æ¥æ±‚è§£çš„å°±æ˜¯å½“å‰å¤åˆ¶æ“ä½œçš„å…‹éš†çŒªäº†ï¼‰ã€‚ æ—¶é—´å¤æ‚åº¦ O(nlogâ¡V)O(n\\log V)O(nlogV)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 998244353; const i64 S = 1000000000; int n, tot; int a[800005]; i64 b[800005], c[800005]; int main(void) &#123; scanf(\"%d\", &amp;n); i64 sum = 0, ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] != 3) scanf(\"%lld\", b + i); if (a[i] == 2) sum = min(sum + b[i], S); if (a[i] == 3) b[i] = sum, sum = min(sum * 2, S); &#125; sum = 0; i64 res = 1; for (int i = n; i >= 1; --i) &#123; if (a[i] == 1) &#123; b[i] -= sum; // æ‰£æ‰åé¢æ“ä½œé™„åŠ çš„çœŸä¼¤ if (b[i] &lt;= 0) continue; i64 r = b[i], cnt = 1; // åŸæœ¬ä¼šæœ‰ä¸€åªï¼Œå°±æ˜¯ä¸€ä¸ªå¤åˆ¶æ“ä½œéƒ½ä¸è¿›è¡Œ for (int j = 1; j &lt;= tot; ++j) // çœ‹èƒ½å¤Ÿå¤åˆ¶åˆ°å“ªé‡Œ if (r > c[j]) &#123; cnt = (cnt + (1ll &lt;&lt; tot - j)) % P; // è¿›è¡Œç¬¬ j ä¸ªå¤åˆ¶æ“ä½œ r -= c[j]; &#125; ans = (ans + res * cnt) % P; &#125; else if (a[i] == 2) sum += b[i]; else &#123; if (b[i] == S) continue; // æ¯ç­æ‰“å‡»ï¼Œå…‹éš†çš„çŒªéƒ½æ­» if (b[i] == 0) &#123; res = res * 2 % P; continue; &#125; // æ— ä¼¤å®³ï¼ŒçŒªç¿»å€ c[++tot] = b[i]; &#125; &#125; printf(\"%lld\\n\", ans); return 0; &#125; * [CF1762E] Tree Sum *2600 Portal. è®¾è¿æ¥ iii çš„è¾¹æƒä¸º did_idiâ€‹ï¼Œè€Œæ¯æ¡è¾¹å¯¹ âˆdi\\prod d_iâˆdiâ€‹ çš„è´¡çŒ®ä¸º 111ï¼Œç„¶è€Œ nnn ä¸ºå¥‡æ•°æ—¶ âˆdi=âˆ’1\\prod d_i=-1âˆdiâ€‹=âˆ’1 æ°¸è¿œä¸å¯èƒ½æ»¡è¶³ï¼Œå› æ­¤ nnn ä¸ºå¥‡æ•°æ—¶æ— è§£ã€‚ å¦‚æœ nnn ä¸ºå¶æ•°ä¸”æ ‘çš„å½¢æ€å›ºå®šï¼Œé‚£ä¹ˆå‚è€ƒ Prufer åºåˆ—çš„æ„é€ æ–¹å¼ï¼Œä»å¶å­å¼€å§‹èµ‹äºˆè¾¹æƒï¼Œé‚£ä¹ˆæ–¹å¼ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºç»™å®šçš„æ ‘çš„å½¢æ€åªæœ‰ä¸€ç§æ–¹å¼ã€‚ è¿™æ ·çš„è¯ï¼Œä¸€æ¡è¾¹ (u,v)(u,v)(u,v) çš„æƒå€¼ä¸º 111 çš„å……è¦æ¡ä»¶æ˜¯ï¼šæ–­æ‰è¿™æ¡è¾¹ä¹‹åä¸¤ä¸ªè¿é€šå—å¤§å°å‡ä¸ºå¶æ•°ã€‚å› ä¸ºè¿™æ ·ä¸¤ä¸ªè¿é€šå—éƒ½æ»¡è¶³æ¡ä»¶äº†ï¼Œè¿™æ¡è¾¹å¡« 111 å³å¯ã€‚ è€ƒè™‘é€è¾¹è®¡ç®—è´¡çŒ®ï¼Œæšä¸¾ 111 æ‰€åœ¨çš„è¿é€šå—å¤§å° iiiï¼Œè¿™æ · nnn æ‰€å¯¹åº”çš„è¿é€šå—å¤§å°ä¾¿ä¸º nâˆ’in-inâˆ’iã€‚ æ­¤æ—¶è¿™æ¡è¾¹çš„è¾¹æƒä¸º (âˆ’1)i(-1)^i(âˆ’1)iã€‚ å‰©ä¸‹ nnn ä¸ªç‚¹ä¸­éšä¾¿æ‰”ï¼Œæ–¹æ¡ˆæ•°ä¸º (nâˆ’2iâˆ’1)\\binom{n-2}{i-1}(iâˆ’1nâˆ’2â€‹)ã€‚ ä¸¤å—éšä¾¿åˆ¶é€ æ— æ ¹æ ‘ï¼Œæ ¹æ® Cayley å…¬å¼è®¡ç®—å³å¯ã€‚ éšä¾¿æ‰¾ä¸¤ä¸ªç‚¹è¿æ¥ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n; int fac[500005], ifac[500005]; int C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; int f(int n) &#123; if (n == 1) return 1; return poww(n, n - 2); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); if (n &amp; 1) return puts(\"0\"), 0; for (int i = fac[0] = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; ifac[n] = poww(fac[n], P - 2); for (int i = n - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; int ans = 0; for (int i = 1; i &lt; n; ++i) ans = (ans + (i &amp; 1 ? -1ll : 1ll) * i * (n - i) % P * C(n - 2, i - 1) % P * f(i) % P * f(n - i) % P) % P; printf(\"%d\\n\", (ans % P + P) % P); return 0; &#125; 3.3 æœ€åçš„æŒ£æ‰ã€‚ ** [CF1626F] A Random Code Problem *2800 Portal. å®é™…ä¸Šæ±‚çš„æ˜¯æ‰€æœ‰æ•°çš„å’Œã€‚ æˆ‘ä»¬åªå…³å¿ƒå‰ kâˆ’1k-1kâˆ’1 è½®æ“ä½œæ•°è¢«å‡å»äº†å¤šå°‘ï¼Œå› æ­¤å°†æ•°å¯¹ L=lcmâ¡(0âˆ¼kâˆ’1)L=\\operatorname{lcm}(0\\sim k-1)L=lcm(0âˆ¼kâˆ’1) å–æ¨¡åå‡å»çš„å€¼æ˜¯ç­‰ä»·çš„ã€‚ åˆå§‹æ—¶æˆ‘ä»¬ä»¤æ‰€æœ‰æ•°éƒ½è¦å‡å»å®ƒä»¬ä¼šå‡å»çš„å€¼ï¼Œæ¯ä¸ªæ•°ä¼šè¢«é€‰ kÃ—nkâˆ’1k\\times n^{k-1}kÃ—nkâˆ’1 æ¬¡ã€‚ å¼€å§‹ DPï¼è®¾ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤ºè¿›è¡Œ jjj è½®åæ¨¡ LLL ç­‰äº iii çš„æ•°çš„ä¸ªæ•°ã€‚æ¯æ¬¡ç»™ç­”æ¡ˆåŠ ä¸Šæ²¡æœ‰å‡å»çš„è´¡çŒ®ï¼Œç„¶åæ›´æ–°æœ‰å¤šå°‘ä¸ªæ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int n, a[10000005], x, y, k, M, L = 1; int f[10000005], p[20]; int ans; int main(void) &#123; cin >> n >> a[0] >> x >> y >> k >> M; for (int i = p[0] = 1; i &lt;= k; ++i) p[i] = 1ll * p[i - 1] * n % P; for (int i = 1; i &lt; k; ++i) L = L / __gcd(L, i) * i; for (int i = 0; i &lt; n; ++i) &#123; if (i) a[i] = (1ll * a[i - 1] * x + y) % M; ans = (ans + 1ll * (a[i] / L * L) * k % P * p[k - 1] % P) % P; ++f[a[i] % L]; &#125; for (int i = 1; i &lt;= k; ++i) for (int j = 0; j &lt; L; ++j) &#123; int c = f[j]; ans = (ans + 1ll * c * j % P * p[k - i] % P) % P; // åŠ ä¸Šå‡å»çš„è´¡çŒ® f[j] = 1ll * c * (n - 1) % P; f[j - j % i] = (f[j - j % i] + c) % P; &#125; printf(\"%d\\n\", ans); return 0; &#125; 3.4 NOIP æ­»äº†ï¼Œçœé€‰éœ€è¦å¤šè€ƒ 50+ åˆ†ã€‚ [CF955C] Sad powers *2100 Portal. å‘†å‘†é¢˜ã€‚è¿™æ˜¯åŸé¢˜ã€‚æ°”æ­»äººï¼Œä¸ºä»€ä¹ˆæˆ‘å¹³æ—¶ä¸å¤šåˆ·ç‚¹é¢˜ï¼ï¼ï¼ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 N = 1e18; int tot; i64 num[30000005]; int calc(i64 n) &#123; int idx = lower_bound(num + 1, num + tot + 1, n) - num; if (idx > tot || (idx &lt;= tot &amp;&amp; num[idx] > n)) --idx; return idx + sqrt(n); &#125; int main(void) &#123; for (i64 i = 2; i &lt;= 1000000; ++i) &#123; i64 k = i * i; for (; k &lt;= N / i; ) &#123; k *= i; i64 sq = sqrt(k); if (sq * sq != k) num[++tot] = k; &#125; &#125; sort(num + 1, num + tot + 1); tot = unique(num + 1, num + tot + 1) - (num + 1); int T; i64 l, r; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld%lld\", &amp;l, &amp;r); printf(\"%d\\n\", calc(r) - calc(l - 1)); &#125; return 0; &#125; [CF316D3] PE Lesson *2400 Portal. å‘†å‘†é¢˜ã€‚å¦‚æœåªèƒ½äº¤æ¢ä¸€æ¬¡å¯ä»¥ç®€å• DPï¼Œäº¤æ¢ä¸¤æ¬¡å¯ä»¥å˜æˆä»»æ„ä¸€ä¸ªäººã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, cnt; int f[1000005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), cnt += (x == 1); f[0] = f[1] = 1; for (int i = 2; i &lt;= n; ++i) f[i] = (f[i - 1] + 1ll * (i - 1) * f[i - 2]) % P; int ans = f[cnt]; for (int i = n; i > cnt; --i) ans = 1ll * ans * i % P; printf(\"%d\\n\", ans); return 0; &#125; ï¼Ÿï¼Ÿï¼Ÿ ä¸çŸ¥é“ã€‚ 3.20 ä¸çŸ¥é“ã€‚ [SNOI2022] å€å¢ Portal. å¦‚æœæ„é€ å‡ºæ¥äº†ä¸€ä¸ªç­”æ¡ˆï¼Œé‚£ä¹ˆåªéœ€è¦åœ¨è¿›ä½çš„åœ°æ–¹åé¢å¡« Bâˆ’1B-1Bâˆ’1 å³å¯ã€‚ æšä¸¾ç­”æ¡ˆçš„é•¿åº¦ã€2Ã—ai2\\times a_i2Ã—aiâ€‹ å¯¹åº” apia_{p_i}apiâ€‹â€‹ã€æ¯ä¸€ä½æ˜¯å¦è¿›ä½ï¼Œè¿™æ ·åœ¨ç½®æ¢ ppp ä¸Šå½¢æˆçš„ç¯æ‰€æ„æˆçš„æ–¹ç¨‹ç»„å¯ä»¥è§£å‡ºæ¥ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int ans[200005]; vector&lt;int> ans0[200005], ans1[200005]; void solve(int B) &#123; int p[20], w[20]; bool vis[20]; for (int n = 2;; ++n) &#123; // 2(a[n] a[n-1] a[1]) = (a[p[n]], a[p[n-1]], a[p[1]]) for (int i = 1; i &lt;= n; ++i) p[i] = i; do &#123; for (int s = 2; s &lt; 1 &lt;&lt; n; s += 2) &#123; // å¿…é¡»æœ‰ä¸€ä¸ªè¿›ä½ for (int i = 1; i &lt;= n; ++i) w[i] = -1, vis[i] = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; int a[20] = &#123;0&#125;, wx[20] = &#123;0&#125;, wy[20] = &#123;0&#125;, m = 0; for (int j = i; !vis[j]; j = p[j]) vis[a[++m] = j] = 1; wx[1] = 1; wy[1] = 0; for (int j = 2; j &lt;= m; ++j) &#123; wx[j] = wx[j - 1] * 2; wy[j] = wy[j - 1] * 2 + (s >> a[j - 1] - 1 &amp; 1) - B * (s >> a[j - 1] &amp; 1); &#125; wx[1] = wx[m] * 2 - 1; wy[1] = wy[m] * 2 + (s >> a[m] - 1 &amp; 1) - B * (s >> a[m] &amp; 1); if (wy[1] % wx[1] != 0) continue; w[a[1]] = -wy[1] / wx[1]; for (int j = 2; j &lt;= m; ++j) w[a[j]] = wx[j] * w[a[1]] + wy[j]; &#125; bool flag = 1; for (int i = 1; i &lt;= n; ++i) flag &amp;= (0 &lt;= w[i] &amp;&amp; w[i] &lt; B); if (flag) &#123; ans[B] = n; for (int i = 1; i &lt;= n; ++i) if (s >> i &amp; 1) &#123; for (int j = n; j > i; --j) ans0[B].emplace_back(w[j]); for (int j = i; j >= 1; --j) ans1[B].emplace_back(w[j]); return; &#125; &#125; &#125; &#125; while (next_permutation(p + 1, p + n + 1)); &#125; &#125; int main(void) &#123; int T, n, B; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;B); if (!ans[B]) solve(B); if (ans[B] > n) &#123; puts(\"-1\"); continue; &#125; vector&lt;int> A; for (int x : ans0[B]) A.emplace_back(x); for (int i = 0; i &lt; n - ans[B]; ++i) A.emplace_back(B - 1); for (int x : ans1[B]) A.emplace_back(x); for (int x : A) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; 3.21 ä¹Ÿä¸çŸ¥é“ã€‚ [ARC117E] Zero-Sum Ranges 2 Portal. å®¹æ˜“æƒ³åˆ°åœ¨å‰ç¼€å’Œåºåˆ—ä¸Šè¿›è¡Œæ€è€ƒã€‚è®¾ cic_iciâ€‹ ä»£è¡¨ iii åœ¨å‰ç¼€å’Œåºåˆ—ä¸­çš„å‡ºç°æ¬¡æ•°ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º âˆ‘i(ci2)\\sum_{i}\\binom{c_i}{2}âˆ‘iâ€‹(2ciâ€‹â€‹)ã€‚ æŒ‰ç…§å‰ç¼€å’Œä»å¤§åˆ°å°çš„é¡ºåºï¼ˆäºº ç±» æ™º æ…§ï¼‰å¼€å§‹æ”¾ç½®ï¼Œè®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ ä»£è¡¨å½“å‰æ”¾äº† iii ä¸ªæ•°ï¼Œç­”æ¡ˆæ˜¯ kkkï¼Œæœ‰ jjj ä¸ªæ´ï¼ˆä¸‹ä¸€å±‚æœ‰ j+1j+1j+1 ä¸ªéœ€è¦æ”¾ï¼‰ã€‚æšä¸¾å½“å‰å±‚æ”¾ç½®å‡ ä¸ªï¼Œè½¬ç§»å¾ˆæ˜¾ç„¶ã€‚ è®¡ç®—ç­”æ¡ˆçš„æ—¶å€™éœ€è¦åˆå¹¶æ­£è´Ÿå‰ç¼€å’Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 62; inline void add(i64 &amp;x, i64 t) &#123; x += t; &#125; int n, s; i64 C[65][65]; i64 f[65][65][3605]; int main(void) &#123; for (int i = 0; i &lt;= N; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; scanf(\"%d%d\", &amp;n, &amp;s); for (int i = 1; i &lt;= n + 1; ++i) f[i][i - 1][i * (i - 1) / 2] = 1; for (int i = 1; i &lt;= n * 2 + 1; ++i) &#123; int t = min(i * (i - 1) / 2, s); for (int j = 0; j &lt;= i; ++j) for (int k = 0; k &lt;= t; ++k) if (f[i][j][k]) &#123; for (int x = j + 2; x &lt;= n * 2 + 1 - i; ++x) // ä¸‹ä¸€å±‚æ”¾ç½® x ä¸ª add(f[i + x][x - (j + 2)][k + x * (x - 1) / 2], f[i][j][k] * C[x - 1][j + 1]); &#125; &#125; i64 ans = f[n * 2 + 1][0][s]; for (int i = 2; i &lt;= n * 2 + 1; ++i) for (int j = 1; j &lt;= n + 1; ++j) for (int k = 0; k &lt;= s; ++k) ans += f[i][j][k] * f[n * 2 + 1 - i][j - 1][s - k]; printf(\"%lld\\n\", ans); return 0; &#125; 3.23 ä¼‘é—²ä¹‹ä½™åšä¸€ç‚¹å¥‡æ€ªçš„ï¼ˆè¿™ä¸€å¤©å¼€å§‹äº† 2020 é›†è®­é˜Ÿä½œä¸šï¼‰ã€‚ [AGC001B] Mysterious Light Portal. å…ˆç…§ä¸€æ¬¡ä¹‹åå°±æ˜¯å¹³è¡Œå››è¾¹å½¢ï¼Œç›´æ¥é€’å½’å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; i64 ans; void calc(i64 n, i64 x) &#123; if (n % x == 0) return ans += n * 2 - x, void(); ans += (n - n % x) * 2; calc(x, n % x); &#125; int main(void) &#123; i64 n, x; cin >> n >> x; ans = n; n -= x; calc(max(n, x), min(n, x)); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; [AGC001C] Shorten Diameter Portal. æŒ‰ç…§ç›´å¾„çš„å¥‡å¶æ€§æšä¸¾ç‚¹æˆ–è¾¹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, k, ans = 1e9, cnt; bool vis[2005], vis2[2005], *v; vector&lt;int> G[2005]; vector&lt;pair&lt;int, int>> E; void dfs(int x, int dis, int len) &#123; if (dis > len) return; ++cnt; v[x] = 1; for (int y : G[x]) if (!v[y]) dfs(y, dis + 1, len); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E.emplace_back(u, v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; if (k % 2 == 0) &#123; for (int i = 1; i &lt;= n; ++i) &#123; v = vis; memset(vis, 0, sizeof vis); dfs(i, cnt = 0, k / 2); ans = min(ans, n - cnt); &#125; &#125; else &#123; for (auto [x, y] : E) &#123; v = vis; memset(vis, 0, sizeof vis); dfs(x, 0, k / 2); v = vis2; memset(vis2, 0, sizeof vis2); dfs(y, 0, k / 2); cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += vis[i] | vis2[i]; ans = min(ans, n - cnt); &#125; &#125; return printf(\"%d\\n\", ans), 0; &#125; 3.25 ï¼Ÿï¼Ÿï¼Ÿ [AGC001D] Arrays and Palindrome Portal. å‡ºç°ä¸¤ä¸ªä»¥ä¸Šçš„å¥‡æ•°æ— è§£ï¼Œå¦åˆ™é”™ä½ä¸€ä¸‹å°±è¡Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, t; int a[100005], b[100005], cnt[2]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", a + i), ++cnt[a[i] &amp; 1]; if (cnt[1] > 2) return puts(\"Impossible\"), 0; if (m == 1) &#123; if (a[1] == 1) printf(\"1\\n1\\n1\\n\"); else printf(\"%d\\n2\\n1 %d\\n\", a[1], a[1] - 1); return 0; &#125; sort(a + 1, a + m + 1, [&amp;](int x, int y) &#123; return x % 2 > y % 2; &#125;); printf(\"%d \", a[1]); for (int i = 3; i &lt;= m; ++i) printf(\"%d \", a[i]); printf(\"%d\\n\", a[2]); b[++t] = a[1] + 1; for (int i = 3; i &lt;= m; ++i) b[++t] = a[i]; if (a[2] > 1) b[++t] = a[2] - 1; printf(\"%d\\n\", t); for (int i = 1; i &lt;= t; ++i) printf(\"%d \", b[i]); putchar('\\n'); return 0; &#125; [AGC001E] BBQ Hard Portal. å¯ä»¥æŠ½è±¡æˆ (0,0)â†’(ai+aj,bi+bj)(0,0)\\rightarrow(a_i+a_j,b_i+b_j)(0,0)â†’(aiâ€‹+ajâ€‹,biâ€‹+bjâ€‹)ï¼Œä¹Ÿå°±æ˜¯ (âˆ’ai,âˆ’bi)â†’(aj,bj)(-a_i,-b_i)\\rightarrow(a_j,b_j)(âˆ’aiâ€‹,âˆ’biâ€‹)â†’(ajâ€‹,bjâ€‹)ï¼Œå°±å¯ä»¥ç›´æ¥ç»Ÿè®¡äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int D = 2010, N = 10000; int poww(int a, int b) &#123; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int n; int a[200005], b[200005]; int fac[10005], ifac[10005], f[4100][4100]; int C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; int main(void) &#123; for (int i = fac[0] = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % P; ifac[N] = poww(fac[N], P - 2); for (int i = N - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", a + i, b + i), ++f[D - a[i]][D - b[i]]; for (int i = 1; i &lt;= D * 2; ++i) for (int j = 1; j &lt;= D * 2; ++j) f[i][j] = (f[i][j] + f[i - 1][j] + f[i][j - 1]) % P; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; ans = (ans + f[D + a[i]][D + b[i]]) % P; ans = (ans - C((a[i] + b[i]) * 2, a[i] * 2)) % P; &#125; printf(\"%lld\\n\", (1ll * ans * poww(2, P - 2) % P + P) % P); return 0; &#125; 3.26 To the crazy ones, wish us good luck. [CF1542E2] Abnormal Permutation Pairs (hard version) Portal. å¯¹äºç¬¬ä¸€æ¡é™åˆ¶ï¼Œæˆ‘ä»¬è®¾ç›¸åŒå‰ç¼€çš„é•¿åº¦ä¸º LLLï¼Œåˆ™ pL+1&lt;qL+1p_{L+1}&lt;q_{L+1}pL+1â€‹&lt;qL+1â€‹ã€‚åé¢çš„è´¡çŒ®ç»Ÿè®¡å‡ºæ¥ä¹‹åï¼Œå‰é¢æ˜¾ç„¶æ˜¯å¯ä»¥éšæ„æ’çš„ã€‚ è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨ iii é˜¶æ’åˆ—ï¼Œppp çš„é€†åºå¯¹æ•°å‡å» qqq çš„é€†åºå¯¹æ•°ä¸º jjj æ—¶çš„æ–¹æ¡ˆæ•°ã€‚è®¾å½“å‰è¦å¡« p1p_1p1â€‹ å’Œ q1q_1q1â€‹ åœ¨ iâˆ’1i-1iâˆ’1 é˜¶æ’åˆ—çš„é¦–ä½ï¼Œè½¬ç§»æ˜¯å®¹æ˜“çš„ï¼š fi,j=âˆ‘p1=1iâˆ‘q1=1ifiâˆ’1,jâˆ’p1+q1f_{i,j}=\\sum_{p_1=1}^i\\sum_{q_1=1}^i f_{i-1,j-p_1+q_1} fi,jâ€‹=p1â€‹=1âˆ‘iâ€‹q1â€‹=1âˆ‘iâ€‹fiâˆ’1,jâˆ’p1â€‹+q1â€‹â€‹ å®é™…ä¸Šæˆ‘ä»¬åªå…³å¿ƒ p1âˆ’q1p_1-q_1p1â€‹âˆ’q1â€‹ çš„å€¼ï¼Œå› æ­¤æšä¸¾ d=p1âˆ’q1d=p_1-q_1d=p1â€‹âˆ’q1â€‹ï¼š fi,j=âˆ‘âˆ£dâˆ£&lt;ifiâˆ’1,jâˆ’d(iâˆ’âˆ£dâˆ£)f_{i,j}=\\sum_{|d|&lt;i} f_{i-1,j-d} (i-|d|) fi,jâ€‹=âˆ£dâˆ£&lt;iâˆ‘â€‹fiâˆ’1,jâˆ’dâ€‹(iâˆ’âˆ£dâˆ£) æ‹†å¼€åå‘ç°ç»´æŠ¤ fi,jf_{i,j}fi,jâ€‹ å’Œ jÃ—fi,jj\\times f_{i,j}jÃ—fi,jâ€‹ å…³äº jjj çš„å‰ç¼€å’Œå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 505, D = N * (N - 1) / 2; int n, M; int C[N][N], fac[N]; int A(int n, int m) &#123; return 1ll * C[n][m] * fac[m] % M; &#125; i64 f[D * 2 + 10], s1[D * 2 + 10], s2[D * 2 + 10]; int main(void) &#123; cin >> n >> M; f[D] = 1; for (int i = 0; i &lt;= n; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % M; for (int i = fac[0] = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % M; i64 ans = 0; for (int i = 2; i &lt;= n; ++i) &#123; // i é˜¶æ’åˆ— int lim = i * (i - 1) / 2; i64 c = 0; for (int j = D - lim - i; j &lt;= D + lim + i; ++j) s1[j] = (s1[j - 1] + f[j]) % M, s2[j] = (s2[j - 1] + 1ll * f[j] * j % M) % M; for (int j = D - lim; j &lt;= D + lim; ++j) &#123; f[j] = (1ll * (s1[j + i] - s1[j]) * (i + j) % M - s2[j + i] + s2[j]) % M; if (j > D) c = (c + f[j]) % M; &#125; ans = (ans + 1ll * c * A(n, n - i) % M) % M; for (int j = D - lim; j &lt;= D + lim; ++j) f[j] = (f[j] + 1ll * ((s1[j] - s1[j - i]) * (i - j) % M + s2[j] - s2[j - i])) % M; &#125; return printf(\"%lld\\n\", (ans % M + M) % M), 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"æ•°è®ºè¿›é˜¶","slug":"notes/æ•°å­¦/ntex","date":"2023-02-16T00:00:00.000Z","updated":"2023-02-16T00:00:00.000Z","comments":true,"path":"7f8fede0/","link":"","permalink":"https://james1badcreeper.github.io/7f8fede0/","excerpt":"é«˜çº§çš„æ•°è®ºçŸ¥è¯†æ›´ä¸ºå›°éš¾ï¼Œä½†ä¹Ÿæ›´æœ‰æ„æ€ã€‚æœ¬æ–‡å°†ä»‹ç»çœé€‰ä»¥å†…çš„å¸¸è§æ•°è®ºçŸ¥è¯†ç‚¹ï¼Œè¿›ä¸€æ­¥å­¦ä¹ æ¨¡æ„ä¹‰ä¸‹çš„æ•°è®ºã€æ•°è®ºå‡½æ•°å’Œæ•´é™¤æ€§ç›¸å…³é—®é¢˜ï¼Œå¹¶é€šè¿‡é¢˜ç›®ä»‹ç»å®ƒä»¬çš„åº”ç”¨ã€‚","text":"é«˜çº§çš„æ•°è®ºçŸ¥è¯†æ›´ä¸ºå›°éš¾ï¼Œä½†ä¹Ÿæ›´æœ‰æ„æ€ã€‚æœ¬æ–‡å°†ä»‹ç»çœé€‰ä»¥å†…çš„å¸¸è§æ•°è®ºçŸ¥è¯†ç‚¹ï¼Œè¿›ä¸€æ­¥å­¦ä¹ æ¨¡æ„ä¹‰ä¸‹çš„æ•°è®ºã€æ•°è®ºå‡½æ•°å’Œæ•´é™¤æ€§ç›¸å…³é—®é¢˜ï¼Œå¹¶é€šè¿‡é¢˜ç›®ä»‹ç»å®ƒä»¬çš„åº”ç”¨ã€‚ æ•´é™¤æ€§é—®é¢˜ ä¸æ•´é™¤ç›¸å…³çš„å†…å®¹æ˜¯æ•°è®ºçš„æ ¹åŸºï¼Œæˆ‘ä»¬å†æ¥æ¢³ç†ä¸€ä¸‹è¿™äº›å†…å®¹ã€‚ ç®—æœ¯åŸºæœ¬å®šç† ä¹‹å‰ä»‹ç»è¿‡ç®—æœ¯åŸºæœ¬å®šç†çš„æ ‡å‡†åˆ†è§£å¼ï¼š n=âˆpiÎ±in=\\prod p_i^{\\alpha_i} n=âˆpiÎ±iâ€‹â€‹ å®ƒè¿˜å¯ä»¥å†™æˆ ppp è¿›èµ‹å€¼åºåˆ—ã€‚è®° vp(n)=maxâ¡{kâˆˆNâˆ£pkâˆ£n}v_p(n)=\\max\\{k\\in \\mathbb{N}\\mid p^k\\mid n\\}vpâ€‹(n)=max{kâˆˆNâˆ£pkâˆ£n}ï¼Œå®šä¹‰ nnn çš„ ppp è¿›èµ‹å€¼åºåˆ—ä¸ºï¼š{v2(n),v3(n),v5(n),v7(n),â‹¯ }\\{v_2(n),v_3(n),v_5(n),v_7(n),\\cdots\\}{v2â€‹(n),v3â€‹(n),v5â€‹(n),v7â€‹(n),â‹¯}ã€‚ è¿™æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿppp è¿›èµ‹å€¼åºåˆ—æ˜¯ä»æ•°è®ºè§’åº¦åˆ»ç”»æ­£æ•´æ•°çš„é‡è¦å·¥å…·ï¼Œåœ¨è¿™ä¸ªè§†è§’ä¸‹ï¼Œæ¯ä¸ªæ•´æ•°å‡å¯ä»¥å®šä½åœ¨ä¸€ä¸ªæ— ç©·ç»´ç©ºé—´ä¸Šçš„æ•´ç‚¹ï¼Œæ¯ä¸ªç»´åº¦éƒ½å¯¹åº”ä¸€ä¸ªç´ æ•°ã€‚ å–æ¨¡ä¸æ•´é™¤ é¦–å…ˆï¼ša mod b=aâˆ’bÃ—âŒŠabâŒ‹a\\bmod b=a-b\\times \\left\\lfloor\\frac{a}{b}\\right\\rflooramodb=aâˆ’bÃ—âŒŠbaâ€‹âŒ‹ï¼Œå®ç°äº†å–æ¨¡ä¸æ•´é™¤çš„è½¬åŒ–ï¼Œéœ€è¦æ ¹æ®å…·ä½“æƒ…å†µåˆ†æä½¿ç”¨å“ªç§å½¢å¼ã€‚ è€Œ âŒŠâŒŠabâŒ‹câŒ‹=âŒŠabcâŒ‹\\left\\lfloor\\frac{\\lfloor\\frac{a}{b}\\rfloor}{c}\\right\\rfloor=\\left\\lfloor\\frac{a}{bc}\\right\\rfloorâŒŠcâŒŠbaâ€‹âŒ‹â€‹âŒ‹=âŒŠbcaâ€‹âŒ‹ å¯ä»¥å°†ä¸€éƒ¨åˆ†çš„é™¤æ³•é—®é¢˜è½¬åŒ–ä¸ºä¹˜æ³•é—®é¢˜ã€‚ æ•°è®ºåˆ†å— æ•°è®ºåˆ†å—ã€‚âŒŠniâŒ‹\\left\\lfloor\\frac{n}{i}\\right\\rfloorâŒŠinâ€‹âŒ‹ åªæœ‰ O(n)O(\\sqrt{n})O(nâ€‹) ä¸­ä¸åŒçš„å–å€¼ï¼Œå¹¶ä¸”æ¯ä¸€ç§å–å€¼éƒ½æ˜¯ä¸€ä¸ªè¿ç»­çš„åŒºé—´ã€‚ æ¯”å¦‚å…‰é€Ÿå¹‚æ˜¯åˆ©ç”¨è¿™ä¸€ç‚¹æ¥å®ç°çš„ï¼Œè¿™ä¸ªæŠ€å·§ä¹Ÿå¯ä»¥åœ¨ O(n)O(\\sqrt{n})O(nâ€‹) æ—¶é—´å†…æšä¸¾åˆ°æ‰€æœ‰åŒºé—´ã€‚ æœ€ç»å…¸çš„åº”ç”¨å°±æ˜¯å¿«é€Ÿè®¡ç®— âˆ‘i=1nf(i)g(âŒŠniâŒ‹)\\sum_{i=1}^n f(i)g\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)âˆ‘i=1nâ€‹f(i)g(âŒŠinâ€‹âŒ‹)ï¼Œéœ€è¦ O(1)O(1)O(1) è®¡ç®— âˆ‘i=lrf(i)\\sum_{i=l}^{r}f(i)âˆ‘i=lrâ€‹f(i)ï¼Œç„¶åå°† ggg ç›¸åŒçš„æ‰“åŒ…è®¡ç®—ã€‚ ä½¿å¾— âŒŠniâŒ‹=âŒŠnjâŒ‹\\lfloor\\frac{n}{i}\\rfloor=\\lfloor\\frac{n}{j}\\rfloorâŒŠinâ€‹âŒ‹=âŒŠjnâ€‹âŒ‹ æˆç«‹çš„æœ€å¤§æ»¡è¶³ iâ‰¤jâ‰¤ni\\le j\\le niâ‰¤jâ‰¤n çš„å—çš„å³ç«¯ç‚¹ä¸º âŒŠnâŒŠniâŒ‹âŒ‹\\left\\lfloor\\cfrac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloorâŒŠâŒŠinâ€‹âŒ‹nâ€‹âŒ‹ã€‚ä¸ºä»€ä¹ˆï¼Ÿä»¤ k=âŒŠniâŒ‹k=\\lfloor\\frac{n}{i}\\rfloork=âŒŠinâ€‹âŒ‹ï¼Œå¯çŸ¥ kâ‰¤nik\\le \\frac{n}{i}kâ‰¤inâ€‹ï¼Œé‚£ä¹ˆ âŒŠnkâŒ‹â‰¥i\\lfloor\\frac{n}{k}\\rfloor\\ge iâŒŠknâ€‹âŒ‹â‰¥iï¼Œæ‰€ä»¥ j=nij=\\frac{n}{i}j=inâ€‹ã€‚æ—¶é—´å¤æ‚åº¦ O(n)O(\\sqrt{n})O(nâ€‹)ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; i64 H(i64 n) &#123; i64 res = 0; i64 l = 1, r; while (l &lt;= n) &#123; r = n / (n / l); res += (r - l + 1) * (n / l); l = r + 1; &#125; return res; &#125; int main(void) &#123; int T; i64 x; cin >> T; while (T--) &#123; cin >> x; cout &lt;&lt; H(x) &lt;&lt; \"\\n\"; &#125; return 0; &#125; åŒæ ·å¯ä»¥æ‰©å±•åˆ°æœ‰å¤šä¸ªå½¢å¦‚ âŒŠniâŒ‹\\lfloor\\frac{n}{i}\\rfloorâŒŠinâ€‹âŒ‹ çš„æ±‚å’Œï¼Œåªéœ€è¦å¯¹ rrr å– minâ¡\\minminï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(âˆ‘n)O(\\sum \\sqrt{n})O(âˆ‘nâ€‹)ã€‚ æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³• è¾—è½¬ç›¸é™¤æ³•å’Œæ›´ç›¸å‡æŸæ³•æ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„ç»“æ„ï¼Œå‡ºç°æ—¶ä¸€èˆ¬éƒ½ä¼´éšç€ gcdâ¡\\gcdgcd ç›¸å…³çš„ç»“è®ºã€‚ ç±»æ¬§å‡ é‡Œå¾—ç®—æ³• å¤§è‡´æ„ä¹‰æ˜¯ä½¿ç”¨ä¸€ä¸ªç±»ä¼¼è¾—è½¬ç›¸é™¤æ³•çš„æ–¹æ³•è¿›è¡Œå‡½æ•°æ±‚å’Œã€‚ è®¾ï¼š f(a,b,c,n)=âˆ‘i=0nâŒŠai+bcâŒ‹f(a,b,c,n)=\\sum_{i=0}^n \\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor f(a,b,c,n)=i=0âˆ‘nâ€‹âŒŠcai+bâ€‹âŒ‹ éœ€è¦ç»™å‡ºä¸€ä¸ª O(logâ¡n)O(\\log n)O(logn) çš„ç®—æ³•ã€‚ æ•°è®ºåˆ†å—ä¼¼ä¹åº”å¯¹ä¸äº†è¿™æ ·çš„æ±‚å’Œï¼Œå› æ­¤æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªå¥‡æ€ªçš„æ–¹å¼ã€‚è¦å°† aâ‰¥ca\\ge caâ‰¥c æˆ– bâ‰¥b\\gebâ‰¥ çš„æƒ…å†µè½¬åŒ–ä¸º a,b&lt;ca,b&lt;ca,b&lt;cã€‚ æˆ‘ä»¬æœ‰ï¼š f(a,b,c,n)=âˆ‘i=0nâŒŠ(a mod c)i+(aâˆ’a mod c)i+(b mod c)+(bâˆ’b mod c)câŒ‹=âˆ‘i=0nâŒŠ(a mod c)i+(b mod c)câŒ‹+(aâˆ’a mod c)ic+bâˆ’b mod cc\\begin{aligned} f(a,b,c,n) &amp;=\\sum_{i=0}^n \\left\\lfloor\\frac{(a\\bmod c)i+(a-a\\bmod c)i+(b\\bmod c)+(b-b\\bmod c)}{c}\\right\\rfloor\\\\ &amp;=\\sum_{i=0}^n \\left\\lfloor\\frac{(a\\bmod c)i+(b\\bmod c)}{c}\\right\\rfloor +\\frac{(a-a\\bmod c)i}{c}+\\frac{b-b\\bmod c}{c} \\end{aligned} f(a,b,c,n)â€‹=i=0âˆ‘nâ€‹âŒŠc(amodc)i+(aâˆ’amodc)i+(bmodc)+(bâˆ’bmodc)â€‹âŒ‹=i=0âˆ‘nâ€‹âŒŠc(amodc)i+(bmodc)â€‹âŒ‹+c(aâˆ’amodc)iâ€‹+cbâˆ’bmodcâ€‹â€‹ æ³¨æ„ç¬¬äºŒè¡Œä¸­çš„åä¸¤ä¸ªä¸€å®šæ˜¯å¯ä»¥æ•´é™¤çš„ã€‚ å› æ­¤åŸå¼ç­‰äºï¼š =âˆ‘i=0nâŒŠ(a mod c)i+(b mod c)câŒ‹+âŒŠacâŒ‹x+âŒŠbcâŒ‹=n(n+1)2âŒŠacâŒ‹+(n+1)âŒŠbcâŒ‹+âˆ‘i=0nâŒŠ(a mod c)i+(b mod c)câŒ‹=n(n+1)2âŒŠacâŒ‹+(n+1)âŒŠbcâŒ‹+f(a mod c,b mod c,c,n)\\begin{aligned} &amp;=\\sum_{i=0}^n \\left\\lfloor\\frac{(a\\bmod c)i+(b\\bmod c)}{c}\\right\\rfloor+\\left\\lfloor\\frac{a}{c}\\right\\rfloor x+\\left\\lfloor\\frac{b}{c}\\right\\rfloor \\\\ &amp;=\\frac{n(n+1)}{2}\\left\\lfloor\\frac{a}{c}\\right\\rfloor+(n+1)\\left\\lfloor\\frac{b}{c}\\right\\rfloor+ \\sum_{i=0}^n\\left\\lfloor\\frac{\\left(a\\bmod c\\right)i+\\left(b\\bmod c\\right)}{c} \\right\\rfloor\\\\ &amp;=\\frac{n(n+1)}{2}\\left\\lfloor\\frac{a}{c}\\right\\rfloor +(n+1)\\left\\lfloor\\frac{b}{c}\\right\\rfloor+f(a\\bmod c,b\\bmod c,c,n) \\end{aligned} â€‹=i=0âˆ‘nâ€‹âŒŠc(amodc)i+(bmodc)â€‹âŒ‹+âŒŠcaâ€‹âŒ‹x+âŒŠcbâ€‹âŒ‹=2n(n+1)â€‹âŒŠcaâ€‹âŒ‹+(n+1)âŒŠcbâ€‹âŒ‹+i=0âˆ‘nâ€‹âŒŠc(amodc)i+(bmodc)â€‹âŒ‹=2n(n+1)â€‹âŒŠcaâ€‹âŒ‹+(n+1)âŒŠcbâ€‹âŒ‹+f(amodc,bmodc,c,n)â€‹ ç°åœ¨æœ‰ a,b&lt;ca,b&lt;ca,b&lt;c äº†ï¼Œç„¶åå‘¢ï¼Ÿå¼å­ä¸­åªæœ‰ iii ä¸€ä¸ªå˜é‡ã€‚åŸå¼ä¸­çš„æ¡ä»¶æ˜¯ 0â‰¤iâ‰¤n0\\le i\\le n0â‰¤iâ‰¤nï¼Œè´¡çŒ®æ˜¯ âŒŠai+bcâŒ‹\\left\\lfloor\\cfrac{ai+b}{c}\\right\\rfloorâŒŠcai+bâ€‹âŒ‹ã€‚è€ƒè™‘å°†è´¡çŒ®åˆå¹¶è®¡ç®—ï¼Œå°†å¼å­æ”¹ä¸ºï¼š âˆ‘i=0nâˆ‘j=0âŒŠai+bcâŒ‹âˆ’11\\sum_{i=0}^n\\sum_{j=0}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor-1}1\\\\ i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcai+bâ€‹âŒ‹âˆ’1â€‹1 è¿™ä¸ª jjj è¢« iii é™åˆ¶ç€ï¼Œä¸å¥½åšï¼Œæˆ‘ä»¬äº¤æ¢ i,ji,ji,jï¼Œè®© jjj è¢« nnn é™åˆ¶ï¼š âˆ‘j=0âŒŠan+bcâŒ‹âˆ’1âˆ‘i=0n[j&lt;âŒŠai+bcâŒ‹]\\sum_{j=0}^{\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor-1}\\sum_{i=0}^n\\left[j&lt;\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor\\right] j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹i=0âˆ‘nâ€‹[j&lt;âŒŠcai+bâ€‹âŒ‹] ä¸‡èƒ½æ¬§å‡ é‡Œå¾—ç®—æ³• ä¸‡èƒ½æ¬§å‡ é‡Œå¾—å¯ä»¥è§£å†³å‡ ä¹å…¨éƒ¨ç±»æ¬§å‡ é‡Œå¾—ç®—æ³•èƒ½è§£å†³çš„é—®é¢˜ã€‚å…¶ä¼˜åŠ¿åœ¨äºï¼Œä¸ç®¡è¦æ±‚ä»€ä¹ˆå¼å­çš„å€¼ï¼Œä»£ç éƒ½ç±»ä¼¼ã€‚ æ•°è®ºå‡½æ•° æˆ‘ä»¬ä¸€èˆ¬ç ”ç©¶æ•°è®ºå‡½æ•°ä¸­çš„ç§¯æ€§å‡½æ•°ã€‚ å¸¸è§ç§¯æ€§å‡½æ•° å•ä½å‡½æ•° Ïµ(n)=[n=1]\\epsilon(n)=[n=1]Ïµ(n)=[n=1]ï¼Œæ˜¯å®Œå…¨ç§¯æ€§å‡½æ•°ã€‚ å¸¸æ•°å‡½æ•° 1(n)=11(n)=11(n)=1ï¼Œæ˜¯å®Œå…¨ç§¯æ€§å‡½æ•°ã€‚ æ’ç­‰å‡½æ•° idâ¡k(n)=nk\\operatorname{id}_k(n)=n^kidkâ€‹(n)=nkï¼Œæ˜¯å®Œå…¨ç§¯æ€§å‡½æ•°ï¼Œå½“ k=1k=1k=1 æ—¶å¯ä»¥çœç•¥ä¸å†™ã€‚ é™¤æ•°å‡½æ•° Ïƒk(n)=âˆ‘dâˆ£ndk\\sigma_k(n)=\\sum_{d\\mid n}d^kÏƒkâ€‹(n)=âˆ‘dâˆ£nâ€‹dkã€‚è¿™æ ·çš„è¯ï¼ŒÏƒ0(n)=Ï„(n)\\sigma_0(n)=\\tau(n)Ïƒ0â€‹(n)=Ï„(n)ï¼ŒÏƒ1(n)\\sigma_1(n)Ïƒ1â€‹(n) ä»£è¡¨çº¦æ•°å’Œï¼Œæœ‰ Ïƒk(n)=âˆi=1s(âˆ‘j=0Î±ipijk)=âˆi=1sÏƒk(piÎ±i)\\sigma_k(n)=\\prod_{i=1}^s\\left(\\sum_{j=0}^{\\alpha_i}p_i^{jk}\\right)=\\prod_{i=1}^s\\sigma_k(p_i^{\\alpha_i})Ïƒkâ€‹(n)=âˆi=1sâ€‹(âˆ‘j=0Î±iâ€‹â€‹pijkâ€‹)=âˆi=1sâ€‹Ïƒkâ€‹(piÎ±iâ€‹â€‹)ã€‚ æ¬§æ‹‰å‡½æ•°ï¼ŒÏ†(n)\\varphi(n)Ï†(n) ä»£è¡¨ 1âˆ¼n1\\sim n1âˆ¼n ä¸­ä¸ nnn äº’è´¨çš„æ•°çš„ä¸ªæ•°ï¼Œä½ è‚¯å®šä¸ä¼šå¿˜è®°å®ƒã€‚ æœ¬è´¨ä¸åŒè´¨å› å­ä¸ªæ•°å‡½æ•° Ï‰(n)=âˆ‘p[pâˆ£n]\\omega(n)=\\sum_{p}[p\\mid n]Ï‰(n)=âˆ‘pâ€‹[pâˆ£n]ã€‚ çº¿æ€§ç­›æ±‚ç§¯æ€§å‡½æ•° æ–¹æ³•å¾ˆç®€å•ï¼Œè®°å½• lowlowlow è¡¨ç¤ºæœ€å°è´¨å› å­çš„æœ€é«˜æ¬¡å¹‚ï¼Œç„¶ååˆ†ç±»è®¨è®ºä¸€ä¸‹å³å¯ã€‚ for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[++tot] = i, f[i] = ..., low[i] = i; // å•ç‹¬ç®— f(p) for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; // i ä¸ p ä¸äº’è´¨ low[i * prime[j]] = low[i] * prime[j]; if (i == low[i]) f[i * prime[j]] = ...; // i = p^kï¼Œå•ç‹¬ç®— f(p^&#123;k+1&#125;) else f[i * prime[j]] = f[i / low[i]] * f[low[i] * prime[j]]; break; &#125; low[i * prime[j]] = prime[j]; f[i * prime[j]] = f[i] * f[prime[j]]; // i ä¸ p äº’è´¨ï¼Œf(ip) = f(i)f(p) &#125; &#125; ç‹„åˆ©å…‹é›·å·ç§¯ ç‹„åˆ©å…‹é›·å·ç§¯æ˜¯æ•°è®ºå‡½æ•°çš„åŸºæœ¬è¿ç®—ã€‚å®šä¹‰ï¼š h(n)=âˆ‘dâˆ£nf(d)g(nd)h(n)=\\sum_{d\\mid n}f(d)g\\left(\\frac{n}{d}\\right) h(n)=dâˆ£nâˆ‘â€‹f(d)g(dnâ€‹) ç®€è®°ä¸º h=fâˆ—gh=f*gh=fâˆ—gã€‚ ç‹„åˆ©å…‹é›·å·ç§¯å…·æœ‰äº¤æ¢å¾‹ã€ç»“åˆå¾‹å’Œåˆ†é…å¾‹ã€‚ é¦–å…ˆï¼ŒÏµâˆ—f=f\\epsilon*f=fÏµâˆ—f=fã€‚å› æ­¤å•ä½å‡½æ•° Ïµ\\epsilonÏµ ä¸ºç‹„åˆ©å…‹é›·å·ç§¯çš„å•ä½å…ƒï¼Œé‚£ä¹ˆå°±å¯ä»¥å®šä¹‰æ•°è®ºå‡½æ•°çš„é€†å…ƒ fâˆ’1f^{-1}fâˆ’1ï¼Œæ»¡è¶³ fâˆ—fâˆ’1=Ïµf*f^{-1}=\\epsilonfâˆ—fâˆ’1=Ïµã€‚ ä¸€ä¸ª fff å­˜åœ¨é€†å…ƒï¼Œå½“ä¸”ä»…å½“ f(1)â‰ 0f(1)\\ne 0f(1)î€ =0ï¼Œå¹¶ä¸”é€†å…ƒå”¯ä¸€ã€‚f=gf=gf=g çš„å……è¦æ¡ä»¶æ˜¯ fâˆ—h=gâˆ—h(h(1)â‰ 1)f*h=g*h(h(1)\\ne 1)fâˆ—h=gâˆ—h(h(1)î€ =1)ã€‚è¿™æ ·ä¸€æ¥æœ‰ g(n)=âˆ’âˆ‘dâˆ£n,dâ‰ ng(d)f(nd)f(1)g(n) = -\\cfrac{\\sum\\limits_{d \\mid n, d \\neq n} g(d)f\\left(\\dfrac n d\\right)} {f(1)}g(n)=âˆ’f(1)dâˆ£n,dî€ =nâˆ‘â€‹g(d)f(dnâ€‹)â€‹ã€‚ ç§¯æ€§å‡½æ•°çš„ç‹„åˆ©å…‹é›·å·ç§¯æ˜¯ç§¯æ€§å‡½æ•°ï¼Œç§¯æ€§å‡½æ•°çš„é€†å…ƒä¹Ÿæ˜¯ç§¯æ€§å‡½æ•°ã€‚ ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸ç”¨çš„ç‹„åˆ©å…‹é›·å·ç§¯ï¼š 1âˆ—1=Ï„1*1=\\tau1âˆ—1=Ï„ï¼Œ Ï†âˆ—1=idâ¡\\varphi *1=\\operatorname{id}Ï†âˆ—1=idã€‚ ç‹„åˆ©å…‹é›·å‰ç¼€å’Œ ä»»æ„æ•°è®ºå‡½æ•° fff å·å¸¸æ•°å‡½æ•° 111 ç­‰ä»·äºåš fff çš„ç‹„åˆ©å…‹é›·å‰ç¼€å’Œï¼Œå³ï¼šg=fâˆ—1,g(n)=âˆ‘dâˆ£nf(d)g=f*1,g(n)=\\sum_{d\\mid n}f(d)g=fâˆ—1,g(n)=âˆ‘dâˆ£nâ€‹f(d)ã€‚å«ä¹‰æ˜¯å¯¹æ¯ä¸ª nnn è®¡ç®—ç»™å®šæ•°è®ºå‡½æ•°åœ¨å…¶æ‰€å› æ•°å¤„çš„å–å€¼å’Œã€‚ å°†æ¯ä¸ªæ•°å†™æˆæ— ç©·åºåˆ— an={c1,c2,â‹¯ }a_n=\\{c_1,c_2,\\cdots\\}anâ€‹={c1â€‹,c2â€‹,â‹¯} è¡¨ç¤º n=âˆpicin=\\prod p_i^{c_i}n=âˆpiciâ€‹â€‹ã€‚ç”±äº xâˆ£yx\\mid yxâˆ£y çš„å……è¦æ¡ä»¶ä¸º ax(ci)â‰¤ay(ci)a_x(c_i)\\le a_y(c_i)axâ€‹(ciâ€‹)â‰¤ayâ€‹(ciâ€‹)ï¼Œå› æ­¤ fâˆ—1f*1fâˆ—1 å¯ä»¥çœ‹æˆå¯¹ä¸‹æ ‡åšå…¶æ— ç©·åºåˆ—çš„é«˜ç»´å‰ç¼€å’Œã€‚ æ¨¡æ¿ï¼Œé‡‡ç”¨é«˜ç»´å‰ç¼€å’Œå®ç°å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef unsigned int uint; uint n, seed; inline uint getnext(void) &#123; seed ^= seed &lt;&lt; 13, seed ^= seed >> 17, seed ^= seed &lt;&lt; 5; return seed; &#125; bool v[20000005]; uint prime[10000005], tot; uint a[20000005]; int main(void) &#123; cin >> n >> seed; for (int i = 1; i &lt;= n; ++i) a[i] = getnext(); for (int i = 2; i &lt;= n; ++i) &#123; if (!v[i]) prime[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) for (int j = 1; j * prime[i] &lt;= n; ++j) a[j * prime[i]] += a[j]; uint ans = 0; for (int i = 1; i &lt;= n; ++i) ans ^= a[i]; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; è«æ¯”ä¹Œæ–¯åæ¼” æˆ‘ä»¬å®šä¹‰è«æ¯”ä¹Œæ–¯å‡½æ•°ï¼š Î¼(n)={1,n=1,0,âˆƒd&gt;1,d2âˆ£n,(âˆ’1)Ï‰(n),otherwise.\\mu(n)=\\begin{cases}1,&amp;n=1,\\\\0,&amp;\\exists d&gt;1,d^{2}\\mid n, \\\\(-1)^{\\omega(n)},&amp;\\mathrm{otherwise}. \\end{cases} Î¼(n)=â©â¨â§â€‹1,0,(âˆ’1)Ï‰(n),â€‹n=1,âˆƒd&gt;1,d2âˆ£n,otherwise.â€‹ ä½¿ç”¨çº¿æ€§ç­›æ±‚è§£è«æ¯”ä¹Œæ–¯å‡½æ•° mu[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; mu[i * prime[j]] = 0; break; &#125; mu[i * prime[j]] = -mu[i]; &#125; &#125; æˆ‘ä»¬å®šä¹‰è«æ¯”ä¹Œæ–¯å‡½æ•°ï¼š Î¼(n)={1,n=1,0,âˆƒd&gt;1,d2âˆ£n,(âˆ’1)Ï‰(n),otherwise.\\mu(n)=\\begin{cases}1,&amp;n=1,\\\\0,&amp;\\exists d&gt;1,d^{2}\\mid n, \\\\(-1)^{\\omega(n)},&amp;\\mathrm{otherwise}. \\end{cases} Î¼(n)=â©â¨â§â€‹1,0,(âˆ’1)Ï‰(n),â€‹n=1,âˆƒd&gt;1,d2âˆ£n,otherwise.â€‹ ä¸ºä»€ä¹ˆè¦å®šä¹‰è¿™æ ·ä¸€ä¸ªå¥‡æ€ªçš„å‡½æ•°å‘¢ï¼Ÿå®é™…ä¸Šå®ƒæ˜¯åœ¨å¯¹ N\\mathbb{N}N åšå®¹æ–¥ã€‚è®¾ g(n)=âˆ‘nâˆ£df(d)g(n)=\\sum_{n\\mid d} f(d)g(n)=âˆ‘nâˆ£dâ€‹f(d)ï¼Œå·²çŸ¥ gggï¼Œè¦æ±‚ f(1)f(1)f(1)ã€‚f(1)f(1)f(1) ç­‰äº ggg åœ¨ 111 çš„å€æ•°å¤„å–çš„å–å€¼å’Œï¼Œå‡å»è´¨æ•°å¤„çš„å–å€¼å’Œï¼Œä½†æ˜¯å¤šå‡äº†ä¸¤ä¸ªè´¨æ•°ä¹˜ç§¯çš„åœ°æ–¹ï¼Œå› æ­¤è¿˜è¦åŠ å›æ¥ã€‚è¿™å°±æ˜¯å®¹æ–¥åŸç†ï¼Œå®¹æ–¥ç³»æ•°æ˜¯ (âˆ’1)Ï‰(n)(-1)^{\\omega(n)}(âˆ’1)Ï‰(n)ã€‚æ¯”å¦‚æ±‚æ— å¹³æ–¹å› å­çš„æ•°çš„ä¸ªæ•°å°±æ˜¯åƒè¿™æ ·å®¹æ–¥ã€‚ è«æ¯”ä¹Œæ–¯å‡½æ•°ä¸ä»…æ˜¯ç§¯æ€§å‡½æ•°ï¼Œè¿˜æ»¡è¶³ï¼š âˆ‘dâˆ£nÎ¼(d)={1,n=1,0,nâ‰ 1.\\sum_{d\\mid n}\\mu(d)=\\begin{cases} 1,&amp;n=1,\\\\ 0,&amp;n\\neq 1. \\end{cases} dâˆ£nâˆ‘â€‹Î¼(d)={1,0,â€‹n=1,nî€ =1.â€‹ ä¸Šè¿°å¼å­æè¿°çš„å…¶å®æ˜¯ Î¼âˆ—1=Ïµ\\mu*1=\\epsilonÎ¼âˆ—1=Ïµï¼Œè¿™æ˜¯è«æ¯”ä¹Œæ–¯å‡½æ•°æœ€é‡è¦çš„æ€§è´¨ï¼Œå…¶å¼•å‡ºäº†æ€§è´¨ï¼šâˆ‘dâˆ£nÎ¼(d)=[n=1]\\sum_{d\\mid n}\\mu(d)=[n=1]âˆ‘dâˆ£nâ€‹Î¼(d)=[n=1]ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªåˆ¤æ–­å¼è½¬åŒ–ä¸ºå’Œå¼ï¼Œè¿™æ ·æ›´åŠ æ–¹ä¾¿è®¡ç®—ã€‚ä¸¤è€…çš„è½¬åŒ–ç§°ä¹‹ä¸ºè«æ¯”ä¹Œæ–¯åæ¼”ã€‚ è«æ¯”ä¹Œæ–¯åæ¼”æœ‰ä»¥ä¸‹ç»“è®ºï¼š è‹¥ g=fâˆ—1g=f*1g=fâˆ—1ï¼Œåˆ™ f=gâˆ—Î¼f=g*\\muf=gâˆ—Î¼ã€‚ è‹¥ g(n)=âˆ‘nâˆ£df(d)g(n)=\\sum_{n\\mid d}f(d)g(n)=âˆ‘nâˆ£dâ€‹f(d)ï¼Œåˆ™ f(n)=âˆ‘nâˆ£dÎ¼(dn)g(d)f(n)=\\sum_{n\\mid d} \\mu\\left(\\dfrac d n\\right) g(d)f(n)=âˆ‘nâˆ£dâ€‹Î¼(ndâ€‹)g(d)ã€‚è¿™ä¹Ÿè¢«ç§°ä¸ºè«æ¯”ä¹Œæ–¯å˜æ¢ã€‚ ç”±äº Ï†âˆ—1=idâ¡\\varphi * 1 = \\operatorname{id}Ï†âˆ—1=idï¼Œå› æ­¤ idâ¡âˆ—Î¼=Ï†\\operatorname{id}*\\mu =\\varphiidâˆ—Î¼=Ï†ã€‚ ä¸€ä¸ªå¸¸è§çš„åº”ç”¨æ˜¯ï¼Œ[gcdâ¡(i,j)=1]=âˆ‘dâˆ£gcdâ¡(i,j)Î¼(d)[\\gcd(i,j)=1]=\\sum_{d\\mid \\gcd(i,j)}\\mu(d)[gcd(i,j)=1]=âˆ‘dâˆ£gcd(i,j)â€‹Î¼(d)ã€‚è™½ç„¶çœ‹èµ·æ¥è¿™åƒæ˜¯åºŸè¯ï¼Œä½†è¿™ä¸€æ­¥å°† i,ji,ji,j äº’è´¨è½¬åŒ–ä¸ºäº†æšä¸¾ gcdâ¡(i,j)\\gcd(i,j)gcd(i,j) çš„çº¦æ•° dddã€‚å¦‚æœ i,ji,ji,j åŒæ ·éœ€è¦æšä¸¾ï¼Œé‚£ä¹ˆæšä¸¾ ddd å¹¶è®¡ç®—åˆæ³•çš„ i,ji,ji,j ä¸ªæ•°ï¼ˆå½“ä¸”ä»…å½“ dâˆ£i,dâˆ£jd\\mid i,d\\mid jdâˆ£i,dâˆ£jï¼‰å³å¯ã€‚å…·ä½“æ¥è¯´ï¼š âˆ‘i=1nâˆ‘j=1m[gcdâ¡(i,j)=1]=âˆ‘i=1nâˆ‘j=1mâˆ‘dâˆ£gcdâ¡(i,j)Î¼(d)=âˆ‘d=1minâ¡(n,m)Î¼(d)âˆ‘i=1nâˆ‘j=1m[dâˆ£iâˆ§dâˆ£j]=âˆ‘d=1minâ¡(n,m)Î¼(d)âŒŠndâŒ‹âŒŠmdâŒ‹\\begin{aligned} \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [\\gcd(i, j) = 1] &amp; = \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m \\sum\\limits_{d\\mid \\gcd(i, j)} \\mu(d) \\\\ &amp; = \\sum\\limits_{d = 1} ^ {\\min(n, m)} \\mu(d) \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [d\\mid i\\land d\\mid j] \\\\ &amp; = \\sum\\limits_{d = 1} ^ {\\min(n, m)} \\mu(d) \\left\\lfloor \\dfrac n d \\right\\rfloor \\left\\lfloor \\dfrac m d \\right\\rfloor \\\\ \\end{aligned} i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹[gcd(i,j)=1]â€‹=i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹dâˆ£gcd(i,j)âˆ‘â€‹Î¼(d)=d=1âˆ‘min(n,m)â€‹Î¼(d)i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹[dâˆ£iâˆ§dâˆ£j]=d=1âˆ‘min(n,m)â€‹Î¼(d)âŒŠdnâ€‹âŒ‹âŒŠdmâ€‹âŒ‹â€‹ å°±å¯ä»¥ç›´æ¥ä½¿ç”¨æ•°è®ºåˆ†å—åœ¨ O(n+m)O(\\sqrt{n}+\\sqrt{m})O(nâ€‹+mâ€‹) çš„æ—¶é—´å†…è®¡ç®—ã€‚ å…³äºè«æ¯”ä¹Œæ–¯åæ¼”çš„æ›´å¤šåº”ç”¨è¯·åœ¨é¢˜ç›®ä¸­å¯»æ‰¾ã€‚ æ¬§æ‹‰åæ¼” æ¬§æ‹‰å‡½æ•°æœ‰ä¸€æ¡æ€§è´¨ï¼šn=âˆ‘dâˆ£nÏ†(d)n = \\sum_{d\\mid n} \\varphi(d)n=âˆ‘dâˆ£nâ€‹Ï†(d)ã€‚ ç”¨ä¸è«æ¯”ä¹Œæ–¯åæ¼”ä¸€æ ·çš„å¥—è·¯ï¼Œæœ‰ï¼š âˆ‘i=1nâˆ‘j=1mgcdâ¡(i,j)=âˆ‘i=1nâˆ‘j=1mâˆ‘dâˆ£gcdâ¡(i,j)Ï†(d)=âˆ‘d=1minâ¡(n,m)Ï†(d)âˆ‘i=1nâˆ‘j=1m[dâˆ£iâˆ§dâˆ£j]=âˆ‘d=1minâ¡(n,m)Ï†(d)âŒŠndâŒ‹âŒŠmdâŒ‹\\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^m\\gcd(i,j)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{d\\mid \\gcd(i,j)} \\varphi(d)\\\\ &amp;=\\sum_{d=1}^{\\min(n,m)}\\varphi(d)\\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [d\\mid i\\land d\\mid j] \\\\ &amp;=\\sum\\limits_{d = 1} ^ {\\min(n, m)} \\varphi(d) \\left\\lfloor \\frac n d \\right\\rfloor \\left\\lfloor \\frac m d \\right\\rfloor \\end{aligned} i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹gcd(i,j)â€‹=i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹dâˆ£gcd(i,j)âˆ‘â€‹Ï†(d)=d=1âˆ‘min(n,m)â€‹Ï†(d)i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹[dâˆ£iâˆ§dâˆ£j]=d=1âˆ‘min(n,m)â€‹Ï†(d)âŒŠdnâ€‹âŒ‹âŒŠdmâ€‹âŒ‹â€‹ è¿™å°±æ˜¯æ¬§æ‹‰åæ¼”çš„å…¬å¼ã€‚ æ¨¡æ„ä¹‰ä¸‹çš„æ•°è®º æ•°è®ºç®—æ³•çš„ç»¼åˆåº”ç”¨ Problemset è¿™é‡Œçš„é¢˜å¯èƒ½æœ‰ä¸€äº›éš¾ï¼Œä¹Ÿä¼šä¸åˆ«çš„ç®—æ³•ç»¼åˆï¼Œä½†æ˜¯éƒ½åº”è¯¥å®Œæˆã€‚ ç®€å•é—®é¢˜ ä¸é€‚åˆæ”¾åœ¨ã€Šæ•°è®ºåˆæ­¥ã€‹ï¼Œä½†æ˜¯åˆæ²¡ç”¨åˆ°æœ¬æ–‡ä»‹ç»çš„çŸ¥è¯†ç‚¹çš„ç®€å•é¢˜ã€‚ [SP5971] LCMSUM - LCM Sum Portal. âˆ‘i=1nlcmâ¡(i,n)=nâˆ‘i=1nigcdâ¡(i,n)=nâˆ‘dâˆ£nâˆ‘i=1nid[gcdâ¡(i,n)=d]=nâˆ‘dâˆ£nâˆ‘i=1ndi[gcdâ¡(i,nd)=1]\\begin{aligned} \\sum\\limits_{i = 1} ^ n \\operatorname{lcm}(i, n) &amp; = n \\sum\\limits_{i = 1} ^ n \\frac{i}{\\gcd(i, n)} \\\\ &amp; = n \\sum\\limits_{d\\mid n} \\sum\\limits_{i = 1} ^ n \\frac{i}{d} [\\gcd(i, n) = d] \\\\ &amp; = n \\sum\\limits_{d\\mid n} \\sum\\limits_{i = 1} ^ {\\frac n d} i \\left[\\gcd\\left(i, \\frac n d\\right) = 1\\right] \\end{aligned} i=1âˆ‘nâ€‹lcm(i,n)â€‹=ni=1âˆ‘nâ€‹gcd(i,n)iâ€‹=ndâˆ£nâˆ‘â€‹i=1âˆ‘nâ€‹diâ€‹[gcd(i,n)=d]=ndâˆ£nâˆ‘â€‹i=1âˆ‘dnâ€‹â€‹i[gcd(i,dnâ€‹)=1]â€‹ åé¢è¿™ä¸ªä¸œè¥¿æ˜¯åœ¨ ddd ä»¥å†…æ‰€æœ‰ä¸ ddd äº’è´¨çš„æ•°çš„å’Œï¼Œæ˜¯æ¬§æ‹‰å‡½æ•°çš„ç»“è®ºï¼Œç­”æ¡ˆæ˜¯ nÃ—Ï†(n)2\\frac{n\\times \\varphi(n)}{2}2nÃ—Ï†(n)â€‹ï¼Œæ³¨æ„ d=1d=1d=1 è¦ç‰¹åˆ¤æ‰ã€‚ çº¿æ€§ç­›å‡º 1âˆ—idâ¡âˆ— Ï†1*\\operatorname{id}*\\ \\varphi1âˆ—idâˆ— Ï† å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 1000000; int tot, prime[500005], low[1000005]; i64 f[1000005]; int main(void) &#123; f[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!f[i]) prime[++tot] = low[i] = i, f[i] = 1 + 1ll * i * (i - 1); for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; if (i % prime[j] == 0) &#123; low[i * prime[j]] = low[i] * prime[j]; if (i == low[i]) f[i * prime[j]] = f[i] + 1ll * (i * prime[j]) * i * (prime[j] - 1); else f[i * prime[j]] = f[i / low[i]] * f[low[i] * prime[j]]; break; &#125; low[i * prime[j]] = prime[j]; f[i * prime[j]] = f[i] * f[prime[j]]; &#125; &#125; int T, n; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); printf(\"%lld\\n\", (f[n] + 1) * n / 2); &#125; return 0; &#125; [å…­çœè”è€ƒ 2017] ç›¸é€¢æ˜¯é—®å€™ Portal.ç»™å®š p,cp,cp,cï¼Œç»´æŠ¤ä¸€ä¸ªæ­£æ•´æ•°åºåˆ—ï¼Œæ”¯æŒåŒºé—´æ›¿æ¢ä¸º caic^{a_i}caiâ€‹ï¼ŒåŒºé—´æ±‚å’Œï¼ˆå¯¹ ppp å–æ¨¡ï¼‰ã€‚ æ•°è®ºåˆ†å— è¿™é‡Œçš„æ•°è®ºåˆ†å—ä¸ä¼šå¾ˆéš¾ï¼Œå› ä¸ºå…¶å¾€å¾€ä¼šå’Œè«æ¯”ä¹Œæ–¯åæ¼”å’Œæœæ•™ç­›ç»¼åˆã€‚ [Luogu P2424] çº¦æ•°å’Œ Portal. å°† fff åšå‰ç¼€å’Œä¹‹åå°±å¯ä»¥ç›´æ¥ä½¿ç”¨æ•°è®ºåˆ†å—è®¡ç®—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; i64 H(int n) &#123; i64 res = 0, l = 1, r; while (l &lt;= n) &#123; r = n / (n / l); res += (l + r) * (r - l + 1) * (n / l) / 2; l = r + 1; &#125; return res; &#125; int main(void) &#123; int x, y; cin >> x >> y; cout &lt;&lt; H(y) - H(x - 1) &lt;&lt; \"\\n\"; return 0; &#125; [CQOI2007] ä½™æ•°æ±‚å’Œ Portal. å°†å–æ¨¡æ‹†å¼€å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int main(void) &#123; i64 n, k; scanf(\"%lld%lld\", &amp;n, &amp;k); i64 ans = n * k; for (i64 l = 1, r; l &lt;= n; l = r + 1) &#123; if (k / l != 0) r = min(n, k / (k / l)); else break; ans -= (l + r) * (r - l + 1) * (k / l) / 2; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [CTT2012] æ¨¡ç§¯å’Œ Portal. ç›´æ¥æ•°è®ºåˆ†å—å³å¯ï¼Œéœ€è¦å°†å¼å­æ‹†å¼€ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 19940417; i64 n, m; i64 a, b, c; i64 calc(int n) &#123; return 3323403ll * n % P * (n + 1) % P * (n * 2 % P + 1) % P; &#125; i64 calc(int l, int r) &#123; return calc(r) - calc(l - 1); &#125; int main(void) &#123; cin >> n >> m; if (n > m) swap(n, m); a = n * n % P; b = m * m % P; c = n * m % P * n % P; for (int l = 1, r = 0; l &lt;= n; l = r + 1) &#123; r = n / (n / l); a = (a - 1ll * (l + r) * (r - l + 1) / 2 % P * (n / l) % P) % P; &#125; for (int l = 1, r = 0; l &lt;= m; l = r + 1) &#123; r = m / (m / l); b = (b - 1ll * (l + r) * (r - l + 1) / 2 % P * (m / l) % P) % P; &#125; for (int l = 1, r = 0; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); i64 len = 1ll * (l + r) * (r - l + 1) / 2 % P; c = (c + calc(l, r) * (n / l) % P * (m / l) % P - m * len % P * (n / l) % P - n * len % P * (m / l) % P) % P; &#125; cout &lt;&lt; ((a * b % P - c) % P + P) % P &lt;&lt; \"\\n\"; return 0; &#125; è«æ¯”ä¹Œæ–¯åæ¼” å¸¦æœ‰ç‰¹æ®ŠæŠ€å·§çš„é¢˜ç›®ä¼šæ ‡æ³¨ã€‚ è«æ¯”ä¹Œæ–¯åæ¼”å¾€å¾€åªèƒ½å»æ‰è‰¾å¼—æ£®æ‹¬å·ï¼ˆè™½ç„¶è«æ¯”ä¹Œæ–¯å‡½æ•°è‡ªèº«è¿˜æœ‰å®¹æ–¥çš„æ€§è´¨ï¼‰ï¼Œå› æ­¤é‡è¦çš„åè€Œæ˜¯æ¨å¼å­ã€‚ [HAOI2011] Problem b Portal. åˆ©ç”¨äºŒç»´å·®åˆ†è¿›è¡Œè®¡ç®—ï¼Œè€Œä¸”å‘ç°åªæœ‰ kkk çš„å€æ•°æœ‰ç”¨ï¼Œå› æ­¤å¯ä»¥å°†æ‰€æœ‰æ•°é™¤ä»¥ kkk è½¬å˜ä¸ºæ±‚äº’è´¨ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int mu[50005], prime[50005], tot; bool v[50005]; i64 calc(int x, int y) &#123; i64 res = 0; for (int l = 1, r; l &lt;= x &amp;&amp; l &lt;= y; l = r + 1) &#123; r = min(x / (x / l), y / (y / l)); res += 1ll * (mu[r] - mu[l - 1]) * (x / l) * (y / l); &#125; return res; &#125; int main(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= 50000; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= 50000; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 2; i &lt;= 50000; ++i) mu[i] += mu[i - 1]; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int a, b, c, d, k; scanf(\"%d%d%d%d%d\", &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); a = (a - 1) / k, c = (c - 1) / k, b /= k, d /= k; printf(\"%d\\n\", calc(a, c) - calc(a, d) - calc(b, c) + calc(b, d)); &#125; return 0; &#125; æ¬§æ‹‰åæ¼” | [NOI2010] èƒ½é‡é‡‡é›† Portal. è¦æ±‚çš„æ˜¾ç„¶æ˜¯ï¼š âˆ‘i=1nâˆ‘i=1m2Ã—gcdâ¡(i,j)âˆ’1\\sum_{i=1}^n\\sum_{i=1}^m 2\\times \\gcd(i,j)-1 i=1âˆ‘nâ€‹i=1âˆ‘mâ€‹2Ã—gcd(i,j)âˆ’1 ç„¶åæ¬§æ‹‰åæ¼”ç›´æ¥æ‹ä¸Šå»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int prime[50005], tot; i64 phi[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); if (m > n) swap(n, m); phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!phi[i]) prime[++tot] = i, phi[i] = i - 1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125; for (int i = 1; i &lt;= n; ++i) phi[i] += phi[i - 1]; i64 ans = 0; for (int l = 1, r; l &lt;= m; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans += 1ll * (phi[r] - phi[l - 1]) * (n / l) * (m / l); &#125; printf(\"%lld\\n\", 2 * ans - 1ll * n * m); return 0; &#125; è«æ¯”ä¹Œæ–¯å‡½æ•°ä¸å®¹æ–¥åŸç† | [Luogu P4318] å®Œå…¨å¹³æ–¹æ•° Portal. è®¾ f(n)f(n)f(n) ä»£è¡¨ 1âˆ¼n1\\sim n1âˆ¼n ä¸­æ— å¹³æ–¹å› å­çš„æ•°çš„ä¸ªæ•°ï¼Œç„¶åäºŒåˆ†ç­”æ¡ˆï¼Œæ‰¾åˆ° f(r)â‰¥Kf(r)\\ge Kf(r)â‰¥K çš„æœ€å° rrrã€‚ç°åœ¨è€ƒè™‘å¦‚ä½•è®¡ç®— fffã€‚ é¦–å…ˆå»æ‰ 22,32,â‹¯ ,p22^2,3^2,\\cdots,p^222,32,â‹¯,p2 çš„å€æ•°ï¼Œä½†æ˜¯å…¶ä¸­æœ‰çš„ä¼šç®—å…¥ä¸¤æ¬¡ï¼Œæ‰€ä»¥å¯¹äº 626^262 è¿™ç§è¦å‡å»ã€‚è€Œåƒ 424^242 è¿™ç§åœ¨ 222^222 æ—¶å·²ç»ç®—å®Œäº†ï¼Œä¸èƒ½ç»Ÿè®¡ã€‚å‘ç°è¿™å°±æ˜¯è«æ¯”ä¹Œæ–¯å‡½æ•°ï¼Œå› æ­¤è«æ¯”ä¹Œæ–¯å‡½æ•°æ˜¯åœ¨å¯¹ N\\mathbb{N}N åšå®¹æ–¥ã€‚ç­”æ¡ˆæ˜¯ï¼š f(n)=âˆ‘iÎ¼(i)âŒŠni2âŒ‹f(n)=\\sum_{i}\\mu(i)\\left\\lfloor\\frac n {i^2}\\right\\rfloor f(n)=iâˆ‘â€‹Î¼(i)âŒŠi2nâ€‹âŒ‹ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 200000; int mu[200005], prime[100005], tot; bool v[200005]; int calc(int n) &#123; int res = 0; for (int i = 1; i * i &lt;= n; ++i) res += mu[i] * (n / (i * i)); return res; &#125; int main(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; int T, n; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); int L = 0, R = 2000000001; while (L + 1 != R) &#123; int mid = L + (R - L) / 2; if (calc(mid) >= n) R = mid; else L = mid; &#125; printf(\"%d\\n\", R); &#125; return 0; &#125; [Luogu P2257] YY çš„ GCD Portal. æ ¹ä¹‹å‰çš„æ¨æ³•æ˜¯ä¸€æ ·çš„ï¼Œä¸è¿‡å¤–é¢è¦å¤šæšä¸¾ä¸€ä¸ª pppã€‚ æ¨å®Œä¹‹åæœ‰è¿™ä¹ˆä¸€ä¸ªä¸œè¥¿ï¼š âˆ‘pâˆ£kÎ¼(kp)\\sum_{p\\mid k}\\mu\\left(\\frac k p\\right) pâˆ£kâˆ‘â€‹Î¼(pkâ€‹) è¿™ä¸ªä¸œè¥¿å¯ä»¥ç›´æ¥åœ¨ O(nlogâ¡logâ¡n)O(n\\log \\log n)O(nloglogn) çš„æ—¶é—´é¢„å¤„ç†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 10000000; int mu[10000005], prime[4000005], tot; i64 f[10000005]; bool v[10000005]; int main(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) for (int j = 1; j * prime[i] &lt;= N; ++j) f[j * prime[i]] += mu[j]; for (int i = 2; i &lt;= N; ++i) f[i] += f[i - 1]; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); if (n > m) swap(n, m); i64 ans = 0; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans += (f[r] - f[l - 1]) * (n / l) * (m / l); &#125; printf(\"%lld\\n\", ans); &#125; return 0; &#125; [SDOI2015] çº¦æ•°ä¸ªæ•°å’Œ Portal. å…³é”®æ˜¯ï¼š Ï„(ij)=âˆ‘xâˆ£iâˆ‘yâˆ£j[gcdâ¡(x,y)=1]\\tau(ij)=\\sum_{x\\mid i}\\sum_{y\\mid j}[\\gcd(x,y)=1] Ï„(ij)=xâˆ£iâˆ‘â€‹yâˆ£jâˆ‘â€‹[gcd(x,y)=1] ç„¶åéšä¾¿æ¨å°±å¯ä»¥äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 50000; int prime[20005], tot; bool v[50005]; int mu[50005], g[50005]; void init(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 1; i &lt;= N; ++i) mu[i] += mu[i - 1]; for (int i = 1; i &lt;= N; ++i) &#123; i64 res = 0; for (int l = 1, r; l &lt;= i; l = r + 1) &#123; r = i / (i / l); res += 1ll * (r - l + 1) * (i / l); &#125; g[i] = res; &#125; &#125; int main(void) &#123; int T, n, m; scanf(\"%d\", &amp;T); init(); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); if (n > m) swap(n, m); i64 ans = 0; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans += 1ll * (mu[r] - mu[l - 1]) * g[n / l] * g[m / l]; &#125; printf(\"%lld\\n\", ans); &#125; return 0; &#125; [å›½å®¶é›†è®­é˜Ÿ] Crash çš„æ•°å­—è¡¨æ ¼ Portal. æ¥æ¨å¼å­ï¼ âˆ‘i=1nâˆ‘j=1mlcmâ¡(i,j)=âˆ‘i=1nâˆ‘j=1mijgcdâ¡(i,j)=âˆ‘d=1n1dâˆ‘i=1nâˆ‘j=1mij[gcdâ¡(i,j)=d]=âˆ‘d=1ndâˆ‘i=1âŒŠndâŒ‹âˆ‘j=1âŒŠmdâŒ‹ij[gcdâ¡(i,j)=1]\\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^m\\operatorname{lcm}(i,j)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\frac{ij}{\\gcd(i,j)}\\\\ &amp;=\\sum_{d=1}^n \\frac 1 d \\sum_{i=1}^n\\sum_{j=1}^m ij[\\gcd(i,j)=d]\\\\ &amp;=\\sum_{d=1}^n d \\sum_{i=1}^{\\lfloor \\frac n d\\rfloor}\\sum_{j=1}^{\\lfloor \\frac m d\\rfloor} ij[\\gcd(i,j)=1]\\\\ \\end{aligned} i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹lcm(i,j)â€‹=i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹gcd(i,j)ijâ€‹=d=1âˆ‘nâ€‹d1â€‹i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹ij[gcd(i,j)=d]=d=1âˆ‘nâ€‹di=1âˆ‘âŒŠdnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠdmâ€‹âŒ‹â€‹ij[gcd(i,j)=1]â€‹ è®¾ F(n,m)=âˆ‘i=1nâˆ‘j=1mij[gcdâ¡(i,j)=1]F(n,m)=\\sum_{i=1}^n\\sum_{j=1}^m ij[\\gcd(i,j)=1]F(n,m)=âˆ‘i=1nâ€‹âˆ‘j=1mâ€‹ij[gcd(i,j)=1]ï¼Œåˆ™åŸå¼ä¸º âˆ‘d=1ndÃ—F(âŒŠndâŒ‹,âŒŠmdâŒ‹)\\sum_{d=1}^n d\\times F(\\lfloor \\frac n d\\rfloor, \\lfloor \\frac m d \\rfloor)âˆ‘d=1nâ€‹dÃ—F(âŒŠdnâ€‹âŒ‹,âŒŠdmâ€‹âŒ‹)ã€‚ F(n,m)=âˆ‘i=1nâˆ‘j=1mijâˆ‘dâˆ£gcdâ¡(i,j)Î¼(d)=âˆ‘d=1nÎ¼(d)âˆ‘i=1nâˆ‘j=1mij[dâˆ£iâˆ§dâˆ£j]=âˆ‘d=1nÎ¼(d)d2âˆ‘i=1âŒŠndâŒ‹âˆ‘j=1âŒŠmdâŒ‹ij\\begin{aligned} F(n,m)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m ij\\sum_{d\\mid\\gcd(i,j)}\\mu(d)\\\\ &amp;=\\sum_{d=1}^n \\mu(d)\\sum_{i=1}^n\\sum_{j=1}^m ij[d\\mid i\\land d\\mid j]\\\\ &amp;=\\sum_{d=1}^n \\mu(d)d^2\\sum_{i=1}^{\\lfloor \\frac n d\\rfloor}\\sum_{j=1}^{\\lfloor \\frac m d\\rfloor}ij \\end{aligned} F(n,m)â€‹=i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹ijdâˆ£gcd(i,j)âˆ‘â€‹Î¼(d)=d=1âˆ‘nâ€‹Î¼(d)i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹ij[dâˆ£iâˆ§dâˆ£j]=d=1âˆ‘nâ€‹Î¼(d)d2i=1âˆ‘âŒŠdnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠdmâ€‹âŒ‹â€‹ijâ€‹ åé¢é‚£å¨ä¹Ÿå¯ä»¥é€šè¿‡æ•°è®ºåˆ†å—è®¡ç®—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 20101009; const int N = 10000000; int n, m, mu[10000005], prime[4000005], tot; bool v[10000005]; int F(int n) &#123; return 1ll * n * (n + 1) / 2 % P; &#125; int sum(int n, int m) &#123; int res = 0; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); res = (res + 1ll * (mu[r] - mu[l - 1]) * F(n / l) % P * F(m / l) % P) % P; &#125; return res; &#125; int main(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 2; i &lt;= N; ++i) mu[i] = (mu[i - 1] + 1ll * i * i % P * mu[i] % P) % P; scanf(\"%d%d\", &amp;n, &amp;m); if (n > m) swap(n, m); int ans = 0; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans = (ans + 1ll * (l + r) * (r - l + 1) / 2 % P * sum(n / l, m / l) % P) % P; &#125; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; [CF1780F] Three Chairs Portal. å°† aaa æ’åºï¼Œè¦æ±‚çš„å°±æ˜¯ï¼š ans=âˆ‘1â‰¤i&lt;jâ‰¤n(jâˆ’i+1)[gcdâ¡(ai,aj)=1]=âˆ‘1â‰¤i&lt;jâ‰¤n(jâˆ’i+1)âˆ‘dâˆ£ai,dâˆ£ajÎ¼(d)=âˆ‘dÎ¼(d)âˆ‘1â‰¤i&lt;jâ‰¤kpjâˆ’piâˆ’1\\begin{aligned} ans&amp;=\\sum_{1\\le i&lt;j\\le n} (j-i+1)[\\gcd(a_i, a_j)=1]\\\\ &amp;=\\sum_{1\\le i&lt;j\\le n} (j-i+1)\\sum_{d\\mid a_i,d\\mid a_j}\\mu(d)\\\\ &amp;=\\sum_{d}\\mu(d)\\sum_{1\\le i&lt;j\\le k} p_j-p_i-1 \\end{aligned} ansâ€‹=1â‰¤i&lt;jâ‰¤nâˆ‘â€‹(jâˆ’i+1)[gcd(aiâ€‹,ajâ€‹)=1]=1â‰¤i&lt;jâ‰¤nâˆ‘â€‹(jâˆ’i+1)dâˆ£aiâ€‹,dâˆ£ajâ€‹âˆ‘â€‹Î¼(d)=dâˆ‘â€‹Î¼(d)1â‰¤i&lt;jâ‰¤kâˆ‘â€‹pjâ€‹âˆ’piâ€‹âˆ’1â€‹ å…¶ä¸­ ppp è¡¨ç¤ºæ˜¯ ddd çš„å€æ•°çš„æ•°çš„ä¸‹æ ‡ä½ç½®ã€‚ç®€å•è½¬åŒ–ä¸€ä¸‹è´¡çŒ®ï¼Œåé¢é‚£ä¸€å¨å°±æ˜¯ï¼š âˆ’k(kâˆ’1)2+âˆ‘i=1kpiÃ—(2iâˆ’kâˆ’1)-\\frac{k(k-1)} 2+\\sum_{i=1}^{k}p_i\\times (2i-k-1) âˆ’2k(kâˆ’1)â€‹+i=1âˆ‘kâ€‹piâ€‹Ã—(2iâˆ’kâˆ’1) æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 300000; int n; int a[300005], mu[300005]; int prime[100005], tot, pos[300005], idx[300005]; bool v[300005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); mu[1] = 1; for (int i = 1; i &lt;= n; ++i) pos[a[i]] = i; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; i64 ans = 0; for (int d = 1; d &lt;= N; ++d) if (mu[d]) &#123; int k = 0; for (int i = d; i &lt;= N; i += d) if (pos[i]) idx[++k] = pos[i]; i64 res = -1ll * k * (k - 1) / 2; for (int i = 1; i &lt;= k; ++i) res += 1ll * idx[i] * (2 * i - k - 1); ans += mu[d] * res; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P4844] LJJ çˆ±æ•°æ•° Portal. æ–¹ç¨‹ä¸¤è¾¹åŒä¹˜ abcabcabc å¯ä»¥å¾—åˆ° ac+bc=abâ‡’abâˆ’acâˆ’bc+c2=c2â‡’(aâˆ’c)(bâˆ’c)=c2ac+bc=ab\\Rightarrow ab-ac-bc+c^2=c^2\\Rightarrow (a-c)(b-c)=c^2ac+bc=abâ‡’abâˆ’acâˆ’bc+c2=c2â‡’(aâˆ’c)(bâˆ’c)=c2ã€‚ è®¾ aâˆ’c=x,bâˆ’c=ya-c=x,b-c=yaâˆ’c=x,bâˆ’c=yï¼Œåˆ™ xy=c2xy=c^2xy=c2ï¼Œå¯ä»¥è¯æ˜ aâŠ¥bâŠ¥c âŸº xâŠ¥ya\\perp b\\perp c\\iff x\\perp yaâŠ¥bâŠ¥câŸºxâŠ¥yã€‚ éœ€è¦æ»¡è¶³ maxâ¡{x,y}+câ‰¤n\\max\\{x,y\\}+c\\le nmax{x,y}+câ‰¤nï¼Œè®¾ x&gt;yx&gt;yx&gt;yï¼Œåˆ™æœ‰ x+câ‰¤nx+c\\le nx+câ‰¤nã€‚æœ€åè®©ç­”æ¡ˆ Ã—2\\times 2Ã—2ï¼Œå†åŠ ä¸Šä¸€ä¸ª a=b=2,c=1a=b=2,c=1a=b=2,c=1 å³å¯ã€‚ ç”±äº xâŠ¥yx\\perp yxâŠ¥yï¼Œå› æ­¤ c2c^2c2 çš„æ¯ä¸€ç§è´¨å› å­åªèƒ½éƒ½ç»™ xxx æˆ–éƒ½ç»™ yyyï¼Œè¿™æ ·æœ‰ x=i2,y=j2(i&gt;j)x=i^2,y=j^2(i&gt;j)x=i2,y=j2(i&gt;j)ï¼Œå› æ­¤ i2+ijâ‰¤nâ‡’jâ‰¤niâˆ’ii^2+ij\\le n\\Rightarrow j\\le \\frac n i - ii2+ijâ‰¤nâ‡’jâ‰¤inâ€‹âˆ’iï¼Œè®¾ Ri=minâ¡{iâˆ’1,niâˆ’1}R_i=\\min\\{i-1,\\frac n i -1\\}Riâ€‹=min{iâˆ’1,inâ€‹âˆ’1}ï¼Œåˆ™ç­”æ¡ˆä¸º âˆ‘i=1nâˆ‘j=1Ri[gcdâ¡(i,j)=1]\\sum_{i=1}^{n}\\sum_{j=1}^{R_i}[\\gcd(i,j)=1]âˆ‘i=1nâ€‹âˆ‘j=1Riâ€‹â€‹[gcd(i,j)=1]ï¼Œè«æ¯”ä¹Œæ–¯åæ¼”ç¢¾è¿‡å»å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(\\sqrt{n}\\log \\sqrt{n})O(nâ€‹lognâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; i64 n, R[1000005]; int m; int mu[1000005], prime[400005], tot; bool v[1000005]; void init(int n) &#123; mu[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; &#125; int main(void) &#123; cin >> n; if (n == 1) return puts(\"0\"), 0; for (int i = 2; i &lt;= n; ++i) &#123; R[i] = n / i - i; if (i - 1 &lt; R[i]) R[i] = i - 1; if (R[i] &lt;= 0) break; m = i; &#125; init(m); i64 ans = 0; for (int d = 1; d &lt;= m; ++d) if (mu[d]) &#123; for (int i = d; i &lt;= m; i += d) ans += mu[d] * (R[i] / d); &#125; printf(\"%lld\\n\", ans * 2 + 1); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ•°è®º","slug":"æ•°è®º","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"æ•°è®ºåˆæ­¥","slug":"notes/æ•°å­¦/number-theory","date":"2023-02-12T00:00:00.000Z","updated":"2023-02-12T00:00:00.000Z","comments":true,"path":"d8a80121/","link":"","permalink":"https://james1badcreeper.github.io/d8a80121/","excerpt":"æ•°è®ºä¸»è¦ç ”ç©¶æ•´æ•°çš„æ€§è´¨ï¼Œè¢«æ•°å­¦ç‹å­é«˜æ–¯ç§°ä¸ºâ€œæ•°å­¦ä¸Šçš„çš‡å† â€ã€‚åˆç­‰æ•°è®ºæ˜¯ç”¨åˆç­‰æ–¹æ³•ç ”ç©¶çš„æ•°è®ºï¼Œå®ƒçš„ç ”ç©¶æ–¹æ³•æœ¬è´¨ä¸Šè¯´ï¼Œå°±æ˜¯åˆ©ç”¨æ•´æ•°ç¯çš„æ•´é™¤æ€§è´¨ï¼Œä¸»è¦åŒ…æ‹¬æ•´é™¤ç†è®ºã€åŒä½™ç†è®ºã€è¿åˆ†æ•°ç†è®ºã€‚åœ¨ OI ä¸­ï¼Œå‡ ä¹è·Ÿæ•°å­¦æœ‰å…³çš„é¢˜ç›®éƒ½ç»•ä¸å¼€åˆç­‰æ•°è®ºï¼Œæœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ åˆç­‰æ•°è®ºçš„åŸºç¡€çŸ¥è¯†ã€‚","text":"æ•°è®ºä¸»è¦ç ”ç©¶æ•´æ•°çš„æ€§è´¨ï¼Œè¢«æ•°å­¦ç‹å­é«˜æ–¯ç§°ä¸ºâ€œæ•°å­¦ä¸Šçš„çš‡å† â€ã€‚åˆç­‰æ•°è®ºæ˜¯ç”¨åˆç­‰æ–¹æ³•ç ”ç©¶çš„æ•°è®ºï¼Œå®ƒçš„ç ”ç©¶æ–¹æ³•æœ¬è´¨ä¸Šè¯´ï¼Œå°±æ˜¯åˆ©ç”¨æ•´æ•°ç¯çš„æ•´é™¤æ€§è´¨ï¼Œä¸»è¦åŒ…æ‹¬æ•´é™¤ç†è®ºã€åŒä½™ç†è®ºã€è¿åˆ†æ•°ç†è®ºã€‚åœ¨ OI ä¸­ï¼Œå‡ ä¹è·Ÿæ•°å­¦æœ‰å…³çš„é¢˜ç›®éƒ½ç»•ä¸å¼€åˆç­‰æ•°è®ºï¼Œæœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ åˆç­‰æ•°è®ºçš„åŸºç¡€çŸ¥è¯†ã€‚ OI ä¸­çš„æ•°å­¦å¹¶æ²¡æœ‰æ•°ç«ä¸­çš„é‚£ä¹ˆéš¾ï¼Œå› ä¸ºæ­£ç¡®è¯æ˜ä¸å†æ˜¯é¦–è¦ä»»åŠ¡ï¼ˆå°½ç®¡è¯æ˜å¯ä»¥å¸®åŠ©ä½ ç†è§£ï¼‰ï¼Œåº”ç”¨æ‰æ˜¯ç‹é“ã€‚ åœ¨é˜…è¯»æœ¬æ–‡å‰ï¼Œè¯·ä¿è¯æ‚¨å­¦è¿‡å°å­¦æ•°å­¦ï¼ˆé›¾ å¦‚æœä½ æƒ³ä»¥æ•°å­¦ç«èµ›çš„æ¨¡å¼å­¦ä¹ æ•°è®ºï¼Œè¯·å‚é˜…æ½˜æ‰¿æ´çš„ã€Šåˆç­‰æ•°è®ºã€‹ï¼Œå¹¶æå‰å­¦ä¹ é«˜ç­‰æ•°å­¦åŸºæœ¬å†…å®¹ï¼š æ‰€ä»¥è¿˜æ˜¯ä»¥ OI çš„æ¨¡å¼å­¦ä¹ æ•°è®ºå§(ï¿£ â€˜i ï¿£;)ã€‚ æ³¨æ„ï¼ŒOI çš„æ¨¡å¼å­¦ä¹ æ•°è®ºï¼Œæ˜¯æŒ‡è¯æ˜è¿‡ç¨‹ä¸ä¼šé‚£ä¹ˆè¯¦ç»†ï¼Œä¼šæ˜¾å¾—â€œæ„Ÿæ€§ç†è§£â€ï¼Œç”šè‡³æœ‰äº›ç›´æ¥è·³è¿‡è¯æ˜ï¼Œä½†è¶³ä»¥è®©ä½ åœ¨è€ƒåœºä¸Šå›å¿†èµ·è¿™äº›æ€§è´¨å¹¶ç”¨å®ƒä»¬è§£é¢˜ï¼ˆè€ƒåœºä¸Šæƒ³çš„åšæ³•å¾€å¾€å¯ä»¥ç”¨å¯¹æ‹æˆ–å…¶ä»–æ‰‹æ®µæ¥éªŒè¯ï¼Œæ„Ÿæ€§è¯æ˜â€œå¥½åƒæ˜¯å¯¹çš„â€å°±è¶³å¤Ÿäº†ï¼Œé‡è¦çš„è¿˜æ˜¯å¤§é‡åšé¢˜ï¼‰ã€‚ä¸¥è°¨ç”šè‡³å¤šç§çš„è¯æ˜è¿‡ç¨‹è¯·å‚è€ƒã€Šåˆç­‰æ•°è®ºã€‹ã€Šå…·ä½“æ•°å­¦ã€‹ç­‰ä¹¦ç±â€”â€”è¿™æœªå¿…ä¸æ˜¯å¥½äº‹ï¼Œè™½ç„¶ä¼šèŠ±è´¹æ—¶é—´ï¼Œä½†æ”¶è·ä¹Ÿæ˜¯å·¨å¤§çš„ã€‚ å¸Œæœ›åœ¨é˜…è¯»æ—¶æ‚¨èƒ½æ‹¿èµ·çº¸ç¬”å’Œé”®ç›˜ï¼Œé€‚å½“çš„æ¼”ç®—å’Œå®Œæˆä»£ç å®ç°ã€‚ åŸºç¡€çŸ¥è¯† æ¥ä¸‹æ¥è‹¥æ²¡æœ‰ç‰¹æ®Šè¯´æ˜ï¼Œæˆ‘ä»¬çš„æ‰€æœ‰æ•°éƒ½æ»¡è¶³ xâˆˆZx \\in \\mathbb{Z}xâˆˆZã€‚ æ¨¡è¿ç®— å¤§å®¶éƒ½åº”è¯¥çŸ¥é“å–æ¨¡ mod\\text{mod}modã€‚ éšæ—¶å–æ¨¡æ€§è´¨ å°±æ˜¯è¯´ âˆ‘(xi mod p)=(âˆ‘xi) mod p\\sum (x_i \\bmod p) = (\\sum x_i)\\bmod pâˆ‘(xiâ€‹modp)=(âˆ‘xiâ€‹)modpï¼Œâˆ(xi mod p)=(âˆxi) mod p\\prod (x_i \\bmod p) = (\\prod x_i)\\bmod pâˆ(xiâ€‹modp)=(âˆxiâ€‹)modpã€‚ç”¨äººè¯è¯´ï¼Œè¿ç®—çš„æœ€ç»ˆç»“æœè¦å–æ¨¡ï¼Œé‚£ä¹ˆè¿ç®—è¿‡ç¨‹ä¸­çš„åŠ æ³•ã€å‡æ³•å’Œä¹˜æ³•éƒ½å¯ä»¥éšæ—¶å–æ¨¡ï¼ˆä½†æ˜¯é™¤æ³•ä¸è¡Œï¼éœ€è¦ç”¨ä¸‹æ–‡ä»‹ç»çš„é€†å…ƒæ¥è§£å†³ï¼‰ã€‚ è¿™ä¸œè¥¿å¯ä»¥è¯æ˜ï¼Œä¸‹æ–‡ä¼šå‡ºç°ï¼ˆ C++ çš„å–æ¨¡ åœ¨ C++ ä¸­ï¼Œç”¨ % æ¥è¡¨ç¤ºå–æ¨¡ã€‚ è¿™é‡Œé—®ä¸ªé—®é¢˜ï¼Œâˆ’5 mod 3-5\\bmod 3âˆ’5mod3 æ˜¯å¤šå°‘ï¼Ÿ æœ‰çš„äººä¼šè¯´æ˜¯ âˆ’2-2âˆ’2ï¼Œå®é™…ä¸Šæ˜¯é”™è¯¯çš„ã€‚ æˆ‘ä»¬ä¸çŸ¥é“ âˆ’5 mod 3-5\\bmod 3âˆ’5mod3 æ˜¯å¤šå°‘ï¼Œä½†æˆ‘ä»¬çŸ¥é“å®ƒç­‰äº 1 mod 31\\bmod 31mod3ï¼Œæ‰€ä»¥å®ƒçš„ç­”æ¡ˆæ˜¯ 111ã€‚ ä» C99 å’Œ C++11 èµ·ï¼Œè§„å®šå•†å‘é›¶å–æ•´ï¼ˆèˆå¼ƒå°æ•°éƒ¨åˆ†ï¼‰ï¼Œå–æ¨¡çš„ç¬¦å·å³ä¸è¢«é™¤æ•°ç›¸åŒã€‚ä»æ­¤ä»¥ä¸‹è¿ç®—ç»“æœä¿è¯ä¸ºçœŸï¼š 5 % 3 == 2; 5 % -3 == 2; -5 % 3 == -2; -5 % -3 == -2; è¿™ä¹Ÿå°±æ„å‘³ç€ï¼Œå¦‚æœå­˜åœ¨è´Ÿæ•°ï¼Œé‚£ä¹ˆå¿…é¡»è¿™æ ·å®ç°å–æ¨¡ï¼š(a % b + b) % bã€‚ æ•´é™¤ä¸çº¦æ•° è‹¥ a=bka=bka=bkï¼Œåˆ™ bbb æ•´é™¤ aaaï¼Œè®°ä½œ bâˆ£ab\\mid abâˆ£aã€‚ä¸æ•´é™¤è®°ä½œ bâˆ¤ab\\nmid abâˆ¤aã€‚ ä¹Ÿç§° bbb æ˜¯ aaa çš„çº¦æ•°ï¼ˆå› æ•°ï¼‰ï¼Œaaa æ˜¯ bbb çš„å€æ•°ã€‚ æ•´é™¤æœ‰ä¸€äº›æ€§è´¨ï¼š aâˆ£b âŸº âˆ’aâˆ£b âŸº aâˆ£âˆ’b âŸº âˆ£aâˆ£âˆ£âˆ£bâˆ£a\\mid b \\iff -a\\mid b \\iff a\\mid -b \\iff |a| \\mid |b|aâˆ£bâŸºâˆ’aâˆ£bâŸºaâˆ£âˆ’bâŸºâˆ£aâˆ£âˆ£âˆ£bâˆ£ï¼› å¦‚æœ aâˆ£b,aâˆ£ca\\mid b, a\\mid caâˆ£b,aâˆ£cï¼Œåˆ™å¯å¾— aâˆ£b+ca\\mid b+caâˆ£b+cï¼› å¦‚æœ aâˆ£b,bâˆ£ca\\mid b, b\\mid caâˆ£b,bâˆ£cï¼Œåˆ™ aâˆ£ca\\mid caâˆ£cï¼Œä¹Ÿå°±æ˜¯æ•´é™¤çš„ä¼ é€’æ€§ï¼› è‹¥ mâ‰ 0m\\ne 0mî€ =0ï¼Œåˆ™ aâˆ£b âŸº maâˆ£mba\\mid b \\iff ma\\mid mbaâˆ£bâŸºmaâˆ£mbï¼› è¯æ˜å¦‚ä¸‹ï¼š ç”± b=aq âŸº b=(âˆ’a)(âˆ’q) âŸº âˆ’b=a(âˆ’q) âŸº âˆ£bâˆ£=âˆ£aâˆ£âˆ£âˆ£qâˆ£b=aq\\iff b=(-a)(-q) \\iff -b = a(-q) \\iff |b| = |a|\\mid |q|b=aqâŸºb=(âˆ’a)(âˆ’q)âŸºâˆ’b=a(âˆ’q)âŸºâˆ£bâˆ£=âˆ£aâˆ£âˆ£âˆ£qâˆ£ å¾—ã€‚aâˆ£b,aâˆ£ca\\mid b, a\\mid caâˆ£b,aâˆ£c å¯å¾— ak1=b,ak2=cak_1=b,ak_2=cak1â€‹=b,ak2â€‹=cï¼Œæ‰€ä»¥ a(k1+k2)=b+ca(k_1+k_2)=b+ca(k1â€‹+k2â€‹)=b+cï¼Œæ‰€ä»¥ aâˆ£b+ca\\mid b+caâˆ£b+cã€‚b=aq1,c=bq2b=aq_1,c=bq_2b=aq1â€‹,c=bq2â€‹ï¼Œå¾— c=a(q1q2)âŸ¹aâˆ£cc=a(q_1q_2)\\Longrightarrow a\\mid cc=a(q1â€‹q2â€‹)âŸ¹aâˆ£cã€‚aâˆ£b âŸº b=aq âŸº mb=(ma)q âŸº maâˆ£mba\\mid b \\iff b=aq \\iff mb = (ma)q \\iff ma\\mid mbaâˆ£bâŸºb=aqâŸºmb=(ma)qâŸºmaâˆ£mbã€‚ è¿˜æœ‰ï¼š aâˆ£ba\\mid baâˆ£b ä¸” bâˆ£aâŸ¹b=Â±ab\\mid a \\Longrightarrow b=\\pm abâˆ£aâŸ¹b=Â±aï¼Œè¿™æ˜¯å› ä¸ºè¿™ä¸¤ä¸ªå¼å­ä»£è¡¨ b=ap,a=bqâ‡’ab=abpqâ‡’pq=1â‡’p=Â±1b=ap,a=bq\\Rightarrow ab=abpq\\Rightarrow pq=1\\Rightarrow p=\\pm 1b=ap,a=bqâ‡’ab=abpqâ‡’pq=1â‡’p=Â±1ï¼› è®¾ bâ‰ 0b\\neq 0bî€ =0ï¼Œåˆ™ aâˆ£bâŸ¹âˆ£aâˆ£â‰¤âˆ£bâˆ£a\\mid b \\Longrightarrow |a|\\le |b|aâˆ£bâŸ¹âˆ£aâˆ£â‰¤âˆ£bâˆ£ï¼› è‹¥ aâ‰ 0,b=qa+ca\\neq 0,b=qa+caî€ =0,b=qa+cï¼Œé‚£ä¹ˆ aâˆ£b âŸº aâˆ£ca\\mid b \\iff a\\mid caâˆ£bâŸºaâˆ£cã€‚ æ ¸å¿ƒçš„è¯æ˜æ€è·¯å°±æ˜¯å°† aâˆ£ba\\mid baâˆ£b å†™ä½œ b=pab=pab=paã€‚ æ±‚ N çš„æ­£çº¦æ•°é›†åˆ è‹¥ aaa æ˜¯ nnn çš„çº¦æ•°ï¼Œåˆ™ na\\cfrac{n}{a}anâ€‹ ä¹Ÿæ˜¯ nnn çš„çº¦æ•°ï¼Œä¸” aaa å’Œ na\\cfrac{n}{a}anâ€‹ ä¹‹ä¸­å¿…æœ‰ä¸€ä¸ª â©½n\\leqslant \\sqrt{n}â©½nâ€‹ã€‚ æšä¸¾ 1âˆ¼n1\\sim \\sqrt{n}1âˆ¼nâ€‹ çš„æ‰€æœ‰æ•°ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯ nnn çš„çº¦æ•°å³å¯ï¼Œä»£ç å¦‚ä¸‹ï¼š int factor[1605]; inline int divisor(int n) // è¿”å›çº¦æ•°ä¸ªæ•°ï¼Œå­˜åœ¨ factor ä¸­ &#123; int m = 0, t = min(n, sqrt(n) + 1); for (int i = 1; i &lt;= t; ++i) if (n % i == 0) &#123; factor[++m] = i; if (i != n / i) factor[++m] = n / i; &#125; //sort(factor + 1, factor + m + 1); //æ­¤æ­¥æœ‰å¯èƒ½æ˜¯å¿…è¦çš„ï¼Œæ¯”å¦‚åœ¨æŸäº› DP ä¸­ï¼Œè½¬ç§»è¦æœ‰é¡ºåºã€‚ return m; &#125; ä»¥ä¸Šæ–¹æ³•ç§°ä¸ºè¯•é™¤æ³•ï¼Œé€šè¿‡è¯•é™¤æ³•å¯ä»¥è¯æ˜ï¼Œä¸€ä¸ªæ•´æ•° nnn çš„çº¦æ•°ä¸ªæ•°ï¼ˆè®°ä½œ d(n)d(n)d(n)ï¼‰ä¸Šç•Œä¸º 2n2\\sqrt{n}2nâ€‹ï¼ˆå®é™…ä¸Šè¿œè¿œä¸åˆ°ï¼Œç»è¿‡è¯•éªŒèƒ½å¾—åˆ°ä¸‹è¡¨ï¼‰ã€‚ èŒƒå›´ d(n)d(n)d(n) æœ€å¤§çš„ nnn maxâ¡{d(n)}\\max\\{d(n)\\}max{d(n)} â©½104\\leqslant 10^4â©½104 æ•°æ®ä¸¢å¤± 646464 â©½105\\leqslant 10^5â©½105 831608316083160 128128128 â©½106\\leqslant 10^6â©½106 720720720720720720 240240240 â©½107\\leqslant 10^7â©½107 864864086486408648640 448448448 â©½108\\leqslant 10^8â©½108 735134407351344073513440 768768768 â‰¤109\\le 10^9â‰¤109 134413441344 â‰¤1012\\le 10^{12}â‰¤1012 672067206720 â‰¤1015\\le 10^{15}â‰¤1015 268802688026880 64 ä½æ•´æ•° æœ‰è¿™ç§æ•°æ®å— 103680103680103680 â€œPollard Rhoâ€ æ˜¯ä¸€ä¸ªæ¯”â€œè¯•é™¤æ³•â€æ›´é«˜æ•ˆçš„ç®—æ³•ã€‚éš¾åº¦å¤§å¤§è¶…å‡ºäº†æœ¬æ–‡çš„èŒƒå›´ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œäº†è§£ã€‚ 1~n æ¯ä¸ªæ•°çš„æ­£çº¦æ•°é›†åˆ æ±‚ 1âˆ¼n1\\sim n1âˆ¼n æ¯ä¸ªæ•°çš„æ­£çº¦æ•°é›†åˆå¯ä»¥é‡‡ç”¨å€æ•°æ³•ã€‚å¯¹äºæ¯ä¸ªæ•° dddï¼Œd,2d,3d,â‹¯ ,âŒŠndâŒ‹Ã—dd,2d,3d,\\cdots,\\lfloor \\cfrac{n}{d}\\rfloor\\times dd,2d,3d,â‹¯,âŒŠdnâ€‹âŒ‹Ã—d çš„çº¦æ•°å°±æœ‰ dddã€‚ä»£ç å¦‚ä¸‹ï¼š vector &lt;int> factor[1000005]; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; j += i) factor[j].push_back(i); æ—¶é—´å¤æ‚åº¦ä¸º O(âˆ‘i=1nni)=O(nlogâ¡n)O(\\sum\\limits_{i=1}^{n}\\cfrac{n}{i})=O(n\\log n)O(i=1âˆ‘nâ€‹inâ€‹)=O(nlogn)ï¼Œè¿™ä¸€ç­‰å¼ç§°ä¹‹ä¸ºè°ƒå’Œçº§æ•°ã€‚ GCD ä¸ LCM è‹¥ ccc åŒæ—¶æ˜¯ aaa å’Œ bbb çš„çº¦æ•°ï¼Œåˆ™ç§° ccc æ˜¯ aaa å’Œ bbb çš„å…¬çº¦æ•°ã€‚ aaa å’Œ bbb çš„æœ€å¤§å…¬çº¦æ•°ï¼ˆGreatest Common Divisorï¼ŒGCDï¼‰è®°ä¸º gcdâ¡(a,b)\\gcd(a,b)gcd(a,b) ï¼Œæˆ–è€…åœ¨æ²¡æœ‰æ­§ä¹‰çš„æ¡ä»¶ä¸‹è®°ä½œ (a,b)(a,b)(a,b)ã€‚ è‹¥ ccc åŒæ—¶æ˜¯ aaa å’Œ bbb çš„å€æ•°ï¼Œåˆ™ç§° ccc æ˜¯ aaa å’Œ bbb çš„å…¬å€æ•°ã€‚ aaa å’Œ bbb çš„æœ€å°å…¬å€æ•°ï¼ˆLeast Common Multipleï¼ŒLCMï¼‰è®°ä¸º lcm(a,b)\\text{lcm}(a,b)lcm(a,b) ï¼Œæˆ–è€…åœ¨æ²¡æœ‰æ­§ä¹‰çš„æ¡ä»¶ä¸‹è®°ä½œ [a,b][a,b][a,b]ã€‚ GCD å’Œ LCM æœ‰ä¸€äº›æ˜¾ç„¶çš„æ€§è´¨ï¼Œå¦‚ä¸‹ï¼š (a,a)=(0,a)=a,(a,a)=(0,a)=a,(a,a)=(0,a)=a, âˆ€aâˆ£b,(a,b)=a,\\forall a\\mid b, (a,b)=a,âˆ€aâˆ£b,(a,b)=a, (a,b)=(a,a+b)=(a,ka+b)â‡’(a,b)=(a,b mod a),(a,b)=(a,a+b)=(a,ka+b) \\Rightarrow (a,b)=(a,b\\bmod a),(a,b)=(a,a+b)=(a,ka+b)â‡’(a,b)=(a,bmoda), (ka,kb)=kÃ—(a,b),(ka,kb)=k\\times(a,b),(ka,kb)=kÃ—(a,b), (a,b,c)=((a,b),c),(a,b,c)=((a,b),c),(a,b,c)=((a,b),c), [a,b,c]=[[a,b],c],[a,b,c]=[[a,b],c],[a,b,c]=[[a,b],c], [a,b]=aÃ—bÃ·(a,b),[a,b]=a\\times b \\div (a,b),[a,b]=aÃ—bÃ·(a,b), å¦‚æœ ddd æ˜¯ a,ba,ba,b çš„å…¬çº¦æ•°ï¼Œé‚£ä¹ˆ dâˆ£(a,b).d\\mid (a,b).dâˆ£(a,b). å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè‹¥ (a,b)=1(a,b)=1(a,b)=1ï¼Œåˆ™ç§° aaa å’Œ bbb äº’è´¨ï¼ˆäº’ç´ ï¼‰ï¼Œè®°ä½œ aâŠ¥ba\\perp baâŠ¥b[1]ã€‚ è¿˜æœ‰ä¸€äº›æ¯”è¾ƒéš¾è¯çš„å®¶ä¼™ï¼Œè¯·å…³æ³¨ä¸€ä¸‹ï¼š å¦‚æœ (n,x)=1(n,x)=1(n,x)=1ï¼Œé‚£ä¹ˆ (n,nâˆ’x)=1(n,n-x)=1(n,nâˆ’x)=1ï¼Œ è‹¥ aâŠ¥ma\\perp maâŠ¥mï¼Œåˆ™ (m,ab)=(m,b)(m,ab)=(m,b)(m,ab)=(m,b)ï¼Œ è‹¥ aâŠ¥m,mâˆ£aba\\perp m,m\\mid abaâŠ¥m,mâˆ£abï¼Œåˆ™ mâˆ£bm\\mid bmâˆ£bï¼Œ [a,b](a,b)=ab[a,b](a,b)=ab[a,b](a,b)=abã€‚ è¯æ˜ï¼š é‡‡ç”¨åè¯æ³•ã€‚å¦‚æœå­˜åœ¨ (n,i)=1(n,i)=1(n,i)=1 ä¸” (n,nâˆ’i)=k(kâ‰ 1)(n,n-i)=k(k\\ne 1)(n,nâˆ’i)=k(kî€ =1)ï¼Œé‚£ä¹ˆ (nâˆ’i) mod k=0,n mod k=0(n-i)\\bmod k = 0,n\\bmod k = 0(nâˆ’i)modk=0,nmodk=0ï¼Œç”¨åè€…å‡æ‰å‰è€…å¾— i mod k=0i\\bmod k = 0imodk=0ï¼Œå³ kâˆ£ik\\mid ikâˆ£iï¼Œè€Œ kkk åˆæ˜¯æ˜¯ nnn çš„å› å­ï¼Œæ‰€ä»¥ kkk æ˜¯ n,in,in,i çš„å…¬çº¦æ•°ï¼Œæ‰€ä»¥ (n,i)â‰ 1(n,i)\\ne 1(n,i)î€ =1ï¼ŒçŸ›ç›¾ã€‚äºŒä¸‰å¾ˆéš¾è¯ï¼Œè¿™é‡Œä¸è¯äº†ï¼ˆç¬¬å››ä¸ªæ˜¯è¿™æ ·çš„ï¼š[a,b](a,b)=abÃ·(a,b)Ã—(a,b)=ab[a,b](a,b)=ab\\div (a,b) \\times (a,b)=ab[a,b](a,b)=abÃ·(a,b)Ã—(a,b)=abã€‚ å®Œæ•´çš„æœ€å¤§å…¬çº¦æ•°ç†è®ºåŠå…¶ä¸åŒçš„è¯æ˜ä½“ç³»è¯·å‚è€ƒã€Šåˆç­‰æ•°è®ºã€‹ã€‚ æ±‚ GCD ä¸ LCM æ±‚ GCD æœ‰ä¸¤ç§æ–¹æ³•ï¼šè¾—è½¬ç›¸é™¤å’Œæ›´ç›¸å‡æŸã€‚ è¾—è½¬ç›¸é™¤æ³• åˆšæ‰æˆ‘ä»¬çŸ¥é“ï¼Œ(a,b)=(a,b mod a)(a,b)=(a,b\\bmod a)(a,b)=(a,bmoda)ï¼Œä½†æ³¨æ„ä»£ç å®ç°ä¸èƒ½è¿™ä¹ˆå†™ï¼ æ¯”å¦‚ç»™ä¸ª (2,1)(2,1)(2,1)ï¼Œå®ƒå°±ä¼šä¸€ç›´æ˜¯ (2,1)(2,1)(2,1)ã€‚ æ‰€ä»¥è¦è¿™ä¹ˆå†™ï¼š int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; çœ‹è§äº†å—ï¼Ÿåè¿‡æ¥å°±è¡Œäº†ã€‚ é‚£ä¹ˆå®ƒçš„å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ è‹¥ a&lt;ba&lt;ba&lt;bï¼Œè¿™æ—¶å€™ (a,b)=(b,a)(a,b)=(b,a)(a,b)=(b,a)ï¼› è‹¥ aâ‰¥ba\\geq baâ‰¥bï¼Œè¿™æ—¶å€™ (a,b)=(b,a mod b)(a,b)=(b,a \\bmod b)(a,b)=(b,amodb)ï¼Œè€Œå¯¹ aaa å–æ¨¡ä¼šè®© aaa è‡³å°‘æŠ˜åŠã€‚è¿™æ„å‘³ç€è¿™ä¸€è¿‡ç¨‹æœ€å¤šè¿›è¡Œ O(logâ¡n)\\mathcal{O}(\\log n)O(logn) æ¬¡ã€‚ è€Œä¸å¯èƒ½è¿ç»­ä¸¤æ¬¡å‘ç”Ÿç¬¬ä¸€ç§æƒ…å†µã€‚æ‰€ä»¥å¤æ‚åº¦æ˜¯ O(logâ¡(a+b))\\mathcal{O}(\\log(a+b))O(log(a+b))ï¼Œä½†å®é™…ä¸Šè¿œè¿œè¾¾ä¸åˆ°è¿™ä¸ªä¸Šç•Œã€‚å½“ a=Fx,b=Fxâˆ’1a=F_x,b=F_{x-1}a=Fxâ€‹,b=Fxâˆ’1â€‹ æ—¶ï¼ˆFFF æŒ‡æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼‰ï¼Œä¼šè·‘æ»¡ O(logâ¡(a+b))\\mathcal{O}(\\log(a+b))O(log(a+b))ï¼Œå› ä¸ºæ¨¡è¿ç®—ä¼šè¢«å¡æˆå‡æ³•ï¼Œä¹Ÿå°±æˆäº†æ›´ç›¸å‡æŸæ³•ã€‚ æ›´ç›¸å‡æŸæ³• è¿˜æ˜¯æ ¹æ®æ€§è´¨ï¼Œæœ‰ï¼š int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x - y); &#125; å®ƒçš„å¤æ‚åº¦æ˜¯ O(maxâ¡(a,b))\\mathcal{O}(\\max(a,b))O(max(a,b))ï¼Œä¸»è¦ç”¨äºé«˜ç²¾åº¦è¿ç®—ä¸­ï¼Œå› ä¸ºæ¨¡è¿ç®—ï¼ˆé™¤æ³•ï¼‰ä¸å¥½å®ç°ã€‚ ä½†æ¯”å¦‚è¿™æ ·ï¼šæ±‚ gcdâ¡(1,1010000)\\gcd(1,10^{10000})gcd(1,1010000) ç”¨æ›´ç›¸å‡æŸä¼šå¾ˆæ…¢ã€‚é™¤éæ•°æ®æœ‰ç‰¹æ®Šæ€§è´¨ï¼Œå¦åˆ™è¿˜æ˜¯è€è€å®å®å®ç°é«˜ç²¾æ¨¡è¿ç®—ã€‚ æ±‚è§£ LCM æ ¹æ®å®šä¹‰ï¼Œè¦è¿™ä¹ˆå†™ï¼š inline int lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125; æ³¨æ„é¡ºåºï¼Œå› ä¸º xÃ—yx\\times yxÃ—y å¯èƒ½ä¼šæº¢å‡ºï¼æ³¨æ„è¿™æ ·çš„ç»†èŠ‚ï¼Œæ¯•ç«Ÿç®—æ³•ç«èµ›ä¸æ˜¯æ•°å­¦ç«èµ›ã€‚ è´¨æ•°ï¼ˆç´ æ•°ï¼‰ å¦‚æœä¸€ä¸ªæ•° x(xâˆˆN)x(x\\in\\mathbb{N})x(xâˆˆN) çš„çº¦æ•°ä»…æœ‰ 111 å’Œå®ƒæœ¬èº«ï¼Œé‚£ä¹ˆå°±ç§° xxx æ˜¯è´¨æ•°ï¼ˆç´ æ•°ï¼‰ï¼Œç‰¹åˆ«åœ°ï¼Œ000 å’Œ 111 ä¸æ˜¯è´¨æ•°ï¼Œå¦‚æœä¸€ä¸ªè‡ªç„¶æ•°ä¸æ˜¯è´¨æ•°ï¼Œä»–å°±æ˜¯åˆæ•°ã€‚ è´¨æ•°çš„åˆ¤å®šã€‚è¯•é™¤æ³•æ˜¯æœ€å¸¸ç”¨çš„åˆ¤å®šè´¨æ•°æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š inline bool is_prime(int x) &#123; if (x &lt; 2) return false; for (int i = 2, t = min(x, sqrt(x) + 2); i &lt; t; ++i) if (x % i == 0) return false; return true; &#125; ç”¨åè¯æ³•å¯ä»¥è¯æ˜è¿™æ ·åšçš„æ­£ç¡®æ€§ï¼ˆå³è¯æ˜åˆæ•°ä¸€å®šå­˜åœ¨ä¸€ä¸ªä¸è¶…è¿‡ x\\sqrt{x}xâ€‹ çš„çº¦æ•°ï¼‰ã€‚ â€œMiller-Rabinâ€æ˜¯ä¸€ä¸ªè¿›é˜¶çš„ç´ æ•°éšæœºåˆ¤å®šæ–¹æ³•ï¼Œè™½ç„¶æ˜¯éšæœºç®—æ³•ï¼Œä½†æ²¡æœ‰ä»»ä½•å·²çŸ¥æ•°å­—é€šè¿‡äº†é«˜çº§æ¦‚ç‡æ€§æµ‹è¯•è¢«åˆ¤å®šä¸ºä¼ªç´ æ•°ã€‚æ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œäº†è§£ã€‚ ä¸ºæ–¹ä¾¿ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ç”¨ ppp ä»£è¡¨è´¨æ•°ã€‚ è®¡ç®—æŠ€å·§ è¿™æ˜¯ä¸€äº›ç¼–ç¨‹ä¸­çš„è®¡ç®—æŠ€å·§ã€‚ å¿«é€Ÿå¹‚ å¿«é€Ÿå¹‚æ˜¯ä¸€ç§åˆ†æ²»æ³•çš„åº”ç”¨ï¼Œä½†è¿™è´§åœ¨æ•°è®ºä¸­æœ‰å¤§é‡åº”ç”¨ã€‚è¿™é‡Œç›´æ¥ç»™å‡ºæ¨¡æ¿ã€‚ inline i64 mpow(i64 a, i64 p, i64 m) &#123; a %= p; // å¦‚æœ a åœ¨ int èŒƒå›´å†…ï¼Œæ­¤æ­¥ä¸å¿…è¦ i64 res = 1; while (p) &#123; if (p &amp; 1) res = res * a % m; a = a * a % m; p >>= 1; &#125; return res % m; // å°å¿ƒ m = 1 &#125; å¿«é€Ÿä¹˜ å¦‚æœæˆ‘ä»¬è¦æ±‚ 64 ä½æ•´æ•°ä¹˜ 64 ä½æ•´æ•°ï¼Œæ˜¾ç„¶ long long æ˜¯è¦ç‚¸æ‰çš„ã€‚é‚£ä¹ˆç”¨ä»€ä¹ˆï¼Ÿ__int128ï¼Ÿä½ è§‰å¾—æ¯’ç˜¤ CCF ä¸ä¼šä½¿ç”¨ 128 ä½æ•´æ•°ä¹˜æ³•å—ï¼ˆä¸ç”¨æ€•ï¼Œä¸ä¼šçš„ï¼Œä½¿ç”¨ __int128 å°±è¡Œäº†ï¼Œå¦åˆ™æ¥ä¸‹æ¥çš„è¿™ç§æ–¹æ³•ä¹Ÿä¸èµ·ä½œç”¨äº†ï¼‰ã€‚ ä¸€ç§è§£å†³æ–¹å¼æ˜¯æŠŠå¿«é€Ÿå¹‚ä¸­çš„ä¹˜æ³•æ”¹æˆåŠ æ³•ã€‚ä½†è¿™æ ·å®åœ¨æ˜¯å¤ªæ…¢äº†ï¼Œè¿™é‡Œç»™å‡ºä¸€ç§åˆ©ç”¨è¯­è¨€ç‰¹æ€§è¿›è¡Œè¿ç®—çš„æ–¹æ³•ï¼ŒåŸç†è¯·è¯»è€…è‡ªè¡Œå­¦ä¹ ï¼Œä»£ç å¦‚ä¸‹ï¼š using i64 = long long; inline i64 mul(i64 a, i64 b, i64 p) &#123; a %= p, b %= p; i64 c = (long double)a * b / p; i64 ans = a * b - c * p; if (ans &lt; 0) ans += p; else if (ans >= p) ans -= p; return ans; &#125; è€ƒåœºè¿˜æ˜¯èƒ½ç”¨ __int128 å°±ç”¨ã€‚ å”¯ä¸€åˆ†è§£å®šç† å¯¹äºä¸€ä¸ªæ•° nnnï¼Œå®ƒå¯ä»¥å”¯ä¸€åˆ†è§£æˆ n=âˆpikin=\\prod p_i^{k_i}n=âˆpikiâ€‹â€‹ã€‚ è¿™ç©æ„å¯ä»¥è¯æ˜ï¼Œæˆ‘ä¹Ÿä¸è¯äº†ï¼ˆè¿™è´§è¿˜å«ä½œç®—æœ¯åŸºæœ¬å®šç†ï¼Œæˆ‘æ€ä¹ˆä¼šè¯ è¿™ç©æ„çš„è¿‡ç¨‹ä¹Ÿå«åšåˆ†è§£è´¨å› æ•°ã€‚ä»£ç å¦‚ä¸‹ï¼š int p[105], c[105], m; void divide(int n) &#123; m = 0; int t = min(n, sqrt(n) + 1); for (int i = 2; i &lt;= t; ++i) if (n % i == 0) &#123; p[++m] = i, c[m] = 0; while (n % i == 0) n /= i, ++c[m]; &#125; if (n > 1) p[++m] = n, c[m] = 1; // å‰©ä¸‹çš„è¿™ä¸ª n å¯èƒ½æ˜¯è´¨æ•° &#125; åœ¨ Linux ç»ˆç«¯ä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ factor å‘½ä»¤å¿«é€Ÿåˆ†è§£è´¨å› æ•°ã€‚å‘½ä»¤å¦‚ä¸‹ï¼šfactor 998244353æ— è¯¯çš„è¯ï¼Œä¼šè¾“å‡ºï¼š998244353: 998244353 è¿™è´§æ—¢ç„¶æ•¢å«ç®—æœ¯åŸºæœ¬å®šç†ï¼Œé‚£ä¹ˆå¿…æœ‰è¿‡äººä¹‹å¤„ã€‚è¿™é‡Œä¸åŠ è¯æ˜çš„ç»™å‡ºç®—æœ¯åŸºæœ¬å®šç†çš„å¸¸ç”¨æ¨è®ºï¼ˆè¯æ˜å‚è€ƒã€Šåˆç­‰æ•°è®ºã€‹ï¼‰ã€‚ ç»™å®š a=âˆi=1spiÎ±ia=\\prod_{i=1}^{s} p_i^{\\alpha_i}a=âˆi=1sâ€‹piÎ±iâ€‹â€‹ï¼Œ ddd æ˜¯ aaa çš„çº¦æ•°çš„å……è¦æ¡ä»¶æ˜¯ d=âˆi=1spiei,eiâ‰¤Î±id=\\prod_{i=1}^s p_i^{e_i},e_i\\le\\alpha_id=âˆi=1sâ€‹pieiâ€‹â€‹,eiâ€‹â‰¤Î±iâ€‹ï¼Œ b=âˆi=1spiÎ²ib=\\prod_{i=1}^{s} p_i^{\\beta_i}b=âˆi=1sâ€‹piÎ²iâ€‹â€‹ï¼Œé‚£ä¹ˆ (a,b)=âˆi=1spiminâ¡(Î±i,Î²i),[a,b]=âˆi=1spimaxâ¡(Î±i,Î²i)(a,b)=\\prod_{i=1}^{s} p_i^{\\min(\\alpha_i,\\beta_i)},[a,b]=\\prod_{i=1}^{s} p_i^{\\max(\\alpha_i,\\beta_i)}(a,b)=âˆi=1sâ€‹pimin(Î±iâ€‹,Î²iâ€‹)â€‹,[a,b]=âˆi=1sâ€‹pimax(Î±iâ€‹,Î²iâ€‹)â€‹ï¼Œå¦‚æœæˆ‘ä»¬æ‰¿è®¤å®ƒæˆç«‹ï¼Œå¯ä»¥å‘ç° [a,b](a,b)=ab[a,b](a,b)=ab[a,b](a,b)=ab çš„åŸå› æ˜¯ minâ¡(Î±,Î²)+maxâ¡(Î±,Î²)=Î±+Î²\\min(\\alpha,\\beta)+\\max(\\alpha,\\beta) =\\alpha+\\betamin(Î±,Î²)+max(Î±,Î²)=Î±+Î²ï¼Œç›´å‘¼å‰å®³ï¼Œ ç”¨é™¤æ•°å‡½æ•° Ï„(a)\\tau(a)Ï„(a)ï¼ˆè¯»ä½œ tauï¼Œä¹Ÿå¯è®°ä½œ d(a)d(a)d(a)ï¼‰è¡¨ç¤º aaa çš„æ­£çº¦æ•°çš„ä¸ªæ•°ï¼Œåˆ™ Ï„(a)=âˆi=1s(Î±i+1)\\tau(a)=\\prod_{i=1}^s(\\alpha_i+1)Ï„(a)=âˆi=1sâ€‹(Î±iâ€‹+1)ï¼Œè¿™ä¹Ÿæ˜¯çº¦æ•°ä¸ªæ•°å®šç†ã€‚å…¶å®è¿™æ˜¯çº¦æ•°æ¡ä»¶çš„æ¨è®ºï¼Œå¯¹äºæ¯ä¸ªè´¨å› å­ä¸Šçš„å¹‚æ¬¡ï¼Œæˆ‘ä»¬å– 0âˆ¼Î±i0\\sim \\alpha_i0âˆ¼Î±iâ€‹ çš„ä»»æ„æ•´æ•°ï¼Œå…± Î±i+1\\alpha_i+1Î±iâ€‹+1 ä¸ªï¼Œç”±ä¹˜æ³•åŸç†ç›´æ¥å¾—å‡ºï¼Œ ç”¨é™¤æ•°å’Œå‡½æ•° Ïƒ(a)\\sigma(a)Ïƒ(a)ï¼ˆè¯»ä½œ sigmaï¼‰è¡¨ç¤º aaa æ‰€æœ‰æ­£çº¦æ•°çš„å’Œï¼Œåˆ™ Ïƒ(a)=âˆi=1s(âˆ‘j=0Î±i(pi)j)=âˆi=1sÏƒ(piÎ±i)\\sigma(a)=\\prod_{i=1}^s\\left(\\sum_{j=0}^{\\alpha_i}(p_i)^j\\right)=\\prod_{i=1}^s\\sigma(p_i^{\\alpha_i}) Ïƒ(a)=i=1âˆsâ€‹(j=0âˆ‘Î±iâ€‹â€‹(piâ€‹)j)=i=1âˆsâ€‹Ïƒ(piÎ±iâ€‹â€‹) æ•°è®ºå‡½æ•° å®šä¹‰åŸŸä¸ºæ•´æ•°çš„å‡½æ•°ç§°ä¸ºæ•°è®ºå‡½æ•°ã€‚ç‰¹åˆ«åœ°ï¼Œå¯¹äºæ•°è®ºå‡½æ•° fffï¼Œå¦‚æœ âˆ€aâŠ¥b,f(ab)=f(a)f(b)\\forall a\\perp b, f(ab)=f(a)f(b)âˆ€aâŠ¥b,f(ab)=f(a)f(b)ï¼Œåˆ™ç§° fff ä¸ºç§¯æ€§å‡½æ•°ï¼›å¦‚æœ âˆ€a,b,f(ab)=f(a)f(b)\\forall a,b,f(ab)=f(a)f(b)âˆ€a,b,f(ab)=f(a)f(b)ï¼Œåˆ™ç§° fff ä¸ºå®Œå…¨ç§¯æ€§å‡½æ•°ã€‚ å¯¹äºæ‰€æœ‰ç§¯æ€§å‡½æ•° fffï¼Œæœ‰ n=âˆpicin=\\prod p_i^{c_i}n=âˆpiciâ€‹â€‹ï¼Œåˆ™ f(n)=âˆf(pici)f(n)=\\prod f(p_i^{c_i})f(n)=âˆf(piciâ€‹â€‹)ã€‚è¯æ˜å¾ˆç®€å•ï¼Œç”±äºç¬¬äºŒä¸ªå¼å­ä¸­çš„æ‰€æœ‰ picip_i^{c_i}piciâ€‹â€‹ éƒ½å¿…å®šäº’è´¨ï¼Œå¤šæ¬¡åˆ©ç”¨ç§¯æ€§å‡½æ•°çš„å®šä¹‰å³å¯è¯æ˜ã€‚ ç®€å•æ•°è®ºé¢˜ ä»€ä¹ˆï¼Œä¸ºä»€ä¹ˆé¢˜ç›®æ¥çš„è¿™ä¹ˆå¿«ã€‚ ä½†æ˜¯ä¸ç”¨æ‹…å¿ƒï¼Œè¿™é‡Œéƒ½æ˜¯ä¸€äº›åŸºç¡€é¢˜ç›®ï¼Œç”¨ä»‹ç»çš„çŸ¥è¯†å’Œä¸€å°ç‚¹å°å­¦æ•°å­¦å°±å¯ä»¥è§£å†³ã€‚ å¥½ï¼Œé‚£å°±æ¥å§[2]ï¼ çº¿æ€§ GCD ç»™å®š n(nâ‰¤107)n(n \\le 10^7)n(nâ‰¤107) ä¸ªæ•´æ•°ï¼Œå¯¹äºæ¯ä¸ªæ•° AiA_iAiâ€‹ï¼Œæ±‚å‡ºåˆ é™¤å®ƒä»¥åå‰©ä¸‹çš„æ•°çš„æœ€å¤§å…¬çº¦æ•°ã€‚ è¿˜è®°å¾— (a,b,c)=((a,b),c)(a,b,c)=((a,b),c)(a,b,c)=((a,b),c) å—ï¼Ÿè¿™ä¸ªå¼å­å‘Šè¯‰æˆ‘ä»¬ï¼ŒGCD è¿ç®—å­˜åœ¨æŸç§â€œç»“åˆå¾‹â€ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ˜“åœ°æŠŠä¸¤å¨æ•°çš„ GCD æ‹¼èµ·æ¥ã€‚ æˆ‘ä»¬æœ‰ï¼š Ansi=(a1,â‹¯ ,aiâˆ’1,ai+1,â‹¯ ,an)=((a1,â‹¯ ,aiâˆ’1),(ai+1,â‹¯ ,an))Ans_i=(a_1,\\cdots,a_{i-1},a_{i+1},\\cdots,a_n)=((a_1,\\cdots,a_{i-1}),(a_{i+1},\\cdots,a_n)) Ansiâ€‹=(a1â€‹,â‹¯,aiâˆ’1â€‹,ai+1â€‹,â‹¯,anâ€‹)=((a1â€‹,â‹¯,aiâˆ’1â€‹),(ai+1â€‹,â‹¯,anâ€‹)) å¤„ç†å‡ºå‰ç¼€ GCD å’Œåç¼€ GCDï¼Œä¾¿å¯ä»¥å¿«é€Ÿæ±‚è§£äº†ã€‚ [NOIP2001 æ™®åŠç»„] æœ€å¤§å…¬çº¦æ•°å’Œæœ€å°å…¬å€æ•°é—®é¢˜ Portal. æœ‰ pâˆ£y0p\\mid y_0pâˆ£y0â€‹ï¼Œæˆ‘ä»¬å¯ä»¥æšä¸¾ y0y_0y0â€‹ çš„æ‰€æœ‰çº¦æ•°ï¼Œç„¶ååˆ©ç”¨ (p,q)[p,q]=pq(p,q)[p,q]=pq(p,q)[p,q]=pq åˆ¤æ–­æ˜¯å¦æ»¡è¶³æ¡ä»¶å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int gcd(int x, int y) &#123; return y == 0 ? x : gcd(y, x % y); &#125; int lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125; int main(void) &#123; int x, y, ans = 0; cin >> x >> y; for (int p = 1; p * p &lt;= y; ++p) if (y % p == 0) &#123; if (gcd(p, y / p * x) == x) ++ans; if (y / p != p &amp;&amp; gcd(y / p, p * x) == x) ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; [Luogu P1572] è®¡ç®—åˆ†æ•° Portal. gcd å¯ä»¥ç”¨äºæ¨¡æ‹Ÿåˆ†æ•°è¿ç®—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #define i64 long long using namespace std; i64 gcd(i64 x, i64 y) &#123; return y == 0 ? x : gcd(y, x % y); &#125; i64 lcm(i64 x, i64 y) &#123; return x / gcd(x, y) * y; &#125; struct frac &#123; i64 p, q; frac(i64 p = 0, i64 q = 0) : p(p), q(q) &#123;&#125; frac operator+ (const frac &amp;a) const &#123; frac res; res.q = lcm(q, a.q); res.p = res.q / q * p + res.q / a.q * a.p; i64 g = gcd(res.p, res.q); res.p /= g, res.q /= g; return res; &#125; &#125;; int main(void) &#123; i64 a, b; scanf(\"%lld/%lld\", &amp;a, &amp;b); frac ans(a, b); while (~scanf(\"%lld/%lld\", &amp;a, &amp;b)) ans = ans + frac(a, b); if (ans.q &lt; 0) ans.p = -ans.p, ans.q = -ans.q; if (ans.q == 1) printf(\"%lld\\n\", ans.p); else printf(\"%lld/%lld\\n\", ans.p, ans.q); return 0; &#125; [AHOI2005] çº¦æ•°ç ”ç©¶ Portal. æ¢ä¸€ç§æ€è·¯ï¼šæšä¸¾çº¦æ•°ï¼Œç„¶ååŠ èµ·æ¥å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, sum = 0; cin >> n; for (int i = 1; i &lt;= n; i++) sum += n / i; cout &lt;&lt; sum &lt;&lt; endl; return 0; &#125; [Luogu P2651] æ·»åŠ æ‹¬å·III Portal. ä¸éš¾å‘ç°é™¤äº† a2a_2a2â€‹ï¼Œå…¶å®ƒæ•°éƒ½å¯ä»¥æ”¾åœ¨åˆ†å­çš„ä½ç½®ä¸Šã€‚ç„¶åç›´æ¥çº¦åˆ†ï¼Œæ¯æ¬¡ç”¨æœ€å¤§å…¬çº¦æ•°é™¤ï¼Œæœ€å a2=1a_2=1a2â€‹=1 å°±æ˜¯å¯ä»¥ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, a, b; scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b); n -= 2; b /= gcd(a, b); while (n--) &#123; scanf(\"%d\", &amp;a); b /= gcd(a, b); &#125; if (b == 1) puts(\"Yes\"); else puts(\"No\"); &#125; return 0; &#125; [Luogu P2660] zzc ç§ç”° Portal. ç±»ä¼¼äºä¸€ä¸ª gcd çš„è¿­ä»£è¿‡ç¨‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int main(void) &#123; i64 a, b, ans = 0; cin >> a >> b; while (a &amp;&amp; b) &#123; if (a > b) swap(a, b); // ä»¤ a &lt; b ans += a * (b / a) * 4; // è¾¹é•¿ä¸º a çš„æ­£æ–¹å½¢ï¼Œç§ b / a ä¸ª b %= a; // ä¹‹å b %= a &#125; printf(\"%lld\\n\", ans); return 0; &#125; [NOIP2009 æé«˜ç»„] Hankson çš„è¶£å‘³é¢˜ Portal. ç”±äº [x,b0]=b1[x,b_0]=b_1[x,b0â€‹]=b1â€‹ï¼Œè¯æ˜ xxx æ˜¯ b1b_1b1â€‹ çš„çº¦æ•°ï¼Œç”¨è¯•é™¤æ³•æšä¸¾ï¼Œåˆ¤æ–­æ˜¯å¦æ»¡è¶³æ¡ä»¶å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int gcd(int x, int y) &#123; return y == 0 ? x : gcd(y, x % y); &#125; inline int lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125; int main(void) &#123; int T = read(); while (T--) &#123; int a0 = read(), a1 = read(), b0 = read(), b1 = read(), ans = 0; for (int i = 1; i * i &lt;= b1; ++i) if (b1 % i == 0) &#123; if (gcd(i, a0) == a1 &amp;&amp; lcm(i, b0) == b1) ++ans; if (i != b1 / i) &#123; int j = b1 / i; if (gcd(j, a0) == a1 &amp;&amp; lcm(j, b0) == b1) ++ans; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [Luogu P1414] åˆæ˜¯æ¯•ä¸šå­£II Portal. æˆ‘ä»¬å¯ä»¥è®¡ç®—æ¯ä¸ªæ•°çš„çº¦æ•°ï¼Œç„¶åæ”¾åˆ°ä¸€ä¸ªæ•°ç»„é‡Œé¢ç»Ÿè®¡ã€‚å›ç­”çš„æ—¶å€™ä»å¤§åˆ°å°çœ‹å½“å‰è¿™ä¸ªçº¦æ•°çš„æ•°é‡å¤Ÿä¸å¤Ÿå¤§ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int c[1000005]; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int x = read(); int t = sqrt(x + 0.5); for (int j = 1; j &lt;= t; ++j) if (x % j == 0) &#123; ++c[j]; if (j * j != x) ++c[x / j]; &#125; &#125; for (int i = 1, j = 1000000; i &lt;= n; ++i) &#123; while (c[j] &lt; i) --j; printf(\"%d\\n\", j); &#125; return 0; &#125; [NOIP2013 æé«˜ç»„] è½¬åœˆæ¸¸æˆ Portal. æ ¹æ®é¢˜æ„ä½¿ç”¨å¿«é€Ÿå¹‚è®¡ç®—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int poww(int a, int p, int m) &#123; int res = 1; while (p) &#123; if (p &amp; 1) res = (i64)res * a % m; a = (i64)a * a % m; p >>= 1; &#125; return res % m; &#125; int main(void) &#123; int n, m, k, x; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;x); printf(\"%d\\n\", (x + (i64)m * poww(10, k, n)) % n); return 0; &#125; [NOIP2009 æ™®åŠç»„] ç»†èƒåˆ†è£‚ Portal. å°† m1m_1m1â€‹ åˆ†è§£è´¨å› æ•°ï¼Œç„¶åæ¯ä¸ªæ¬¡æ•°ä¹˜ä¸Š m2m_2m2â€‹ï¼Œä¾¿ç›¸å½“äº m1m2m_1^{m_2}m1m2â€‹â€‹ã€‚å¯¹äºæ¯ä¸€ä¸ª sssï¼Œæƒ³è¦è®© m1m2âˆ£sxm_1^{m_2} \\mid s^xm1m2â€‹â€‹âˆ£sxï¼Œéœ€è¦ mmm çš„æ¯ä¸ªè´¨å› å­æ¬¡æ•°éƒ½å°äº sxs^xsx çš„ã€‚é‚£ä¹ˆä¾æ¬¡æ£€æŸ¥æ¯ä¸ªè´¨å› å­ï¼Œè¦æ±‚ exâ‰¥cex\\ge cexâ‰¥c å³å¯ï¼ˆeee ä»£è¡¨å°† sss åˆ†è§£è´¨å› æ•°åçš„å¹‚æ¬¡ï¼Œccc æ˜¯ mmm å¤„ç†è¿‡åçš„å¹‚æ¬¡ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int m1, m2; int p[10005], c[10005]; void init(void) &#123; for (int i = 2; i * i &lt;= m1; ++i) if (m1 % i == 0) &#123; p[++m] = i, c[m] = 0; while (m1 % i == 0) &#123; ++c[m]; m1 /= i; &#125; &#125; if (m1 > 1) p[++m] = m1, c[m] = 1; for (int i = 1; i &lt;= m; ++i) c[i] *= m2; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m1, &amp;m2); init(); int ans = 2e9, s; while (n--) &#123; scanf(\"%d\", &amp;s); int x = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (s % p[i] != 0) &#123; x = 2e9; break; &#125; else &#123; int res = 0; while (s % p[i] == 0) &#123; ++res; s /= p[i]; &#125; x = max(x, c[i] / res + (c[i] % res == 0 ? 0 : 1)); &#125; &#125; ans = min(ans, x); &#125; if (ans != 2e9) printf(\"%d\\n\", ans); else puts(\"-1\"); return 0; &#125; [UVA11889] Benefit Portal. å½“ aâˆ¤ca\\nmid caâˆ¤c çš„æ—¶å€™æ— è§£ã€‚å¦åˆ™è¦æ±‚æ»¡è¶³ä¸‹åˆ—æ¡ä»¶çš„æœ€å° xxxï¼š x(a,x)=ca=dâŸ¹x=dk(k=(a,x))âŸ¹k=(a,dk)âŸ¹kg=(ag,kÃ—dg)âŸ¹kg=(ag,k)(agâŠ¥dg)âŸ¹k(ag,k)=g\\begin{aligned} &amp;\\frac{x}{(a,x)}=\\frac{c}{a}=d\\\\ \\Longrightarrow &amp; x=dk(k=(a,x))\\\\ \\Longrightarrow &amp; k=(a,dk)\\\\ \\Longrightarrow &amp; \\frac{k}{g}=\\left(\\frac{a}{g},k\\times\\frac{d}{g}\\right)\\\\ \\Longrightarrow &amp; \\frac{k}{g}=\\left(\\frac{a}{g},k\\right) \\left(\\frac{a}{g}\\perp\\frac{d}{g}\\right) \\\\ \\Longrightarrow &amp; \\frac{k}{(\\frac{a}{g},k)}=g \\end{aligned} âŸ¹âŸ¹âŸ¹âŸ¹âŸ¹â€‹(a,x)xâ€‹=acâ€‹=dx=dk(k=(a,x))k=(a,dk)gkâ€‹=(gaâ€‹,kÃ—gdâ€‹)gkâ€‹=(gaâ€‹,k)(gaâ€‹âŠ¥gdâ€‹)(gaâ€‹,k)kâ€‹=gâ€‹ ç„¶åå°±å¯ä»¥é€’å½’æ±‚è§£äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int calc(int a, int d) &#123; // b / gcd(a, b) = d int g = gcd(a, d); if (g == 1) return d; return d * calc(a / g, g); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int a, c; scanf(\"%d%d\", &amp;a, &amp;c); if (c % a != 0) puts(\"NO SOLUTION\"); else printf(\"%d\\n\", calc(a, c / a)); &#125; return 0; &#125; æ¥ä¸‹æ¥æˆ‘ä»¬ä¼šä»‹ç»ä¸€äº›è¾ƒä¸ºæœ‰è¶£çš„æ•°è®ºç®—æ³•ã€‚ ç´ æ•°ç­›æ³• ç´ æ•°ç­›èƒ½å¿«é€Ÿåœ°æ±‚å‡ºåŒºé—´å†…çš„è´¨æ•°ã€‚ æ¨¡æ¿ã€‚ æ™®é€šç­› å¯¹äºæ‰€æœ‰çš„æ•°ï¼Œæ ‡è®°æ‰€æœ‰å®ƒçš„å€æ•°ï¼ˆäºŒå€åŠä»¥ä¸Šï¼‰ä¸ºåˆæ•°ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºè°ƒå’Œçº§æ•° O(nlogâ¡n)\\mathcal{O}(n\\log n)O(nlogn)ã€‚ä»£ç å¦‚ä¸‹ï¼š int prime[MAXN]; bool vis[MAXN]; for (int i = 2; i &lt;= n; ++i) &#123; if (vis[i] == 0) prime[++tot] = i; for (int j = i * 2; j &lt;= n; j += i) vis[j] = 1; &#125; è¿™ç§æ–¹å¼å¾ˆæ…¢ï¼Œä¸è¦åœ¨è€ƒåœºä¸Šä½¿ç”¨ã€‚ Eratosthenes ç­›æ³• Eratosthenes ç­›æ³•ï¼Œç®€ç§°åŸƒæ°ç­›ï¼Œæ˜¯ç®—æ³•ç«èµ›ä¸­æœ€å¸¸ç”¨çš„ç­›æ³•ã€‚ è€ƒè™‘è¿™æ ·ä¸€ä»¶äº‹æƒ…ï¼šå¦‚æœ xxx æ˜¯åˆæ•°ï¼Œé‚£ä¹ˆ xxx çš„å€æ•°ä¹Ÿä¸€å®šæ˜¯åˆæ•°ï¼Œå®ƒä»¬è‚¯å®šä¼šè¢«æŸä¸ªç›¸åŒçš„è´¨å› å­ç­›æ‰ï¼Œé‚£æˆ‘ä»¬å°±æ²¡æœ‰å¿…è¦ç­›åˆæ•°äº†ã€‚ å¦‚æœæˆ‘ä»¬ä»å°åˆ°å¤§è€ƒè™‘æ¯ä¸ªæ•°ï¼Œç„¶ååŒæ—¶æŠŠå½“å‰è¿™ä¸ªæ•°çš„æ‰€æœ‰ï¼ˆæ¯”è‡ªå·±å¤§çš„ï¼‰å€æ•°è®°ä¸ºåˆæ•°ï¼Œé‚£ä¹ˆè¿è¡Œç»“æŸçš„æ—¶å€™æ²¡æœ‰è¢«æ ‡è®°çš„æ•°å°±æ˜¯ç´ æ•°äº†ã€‚ ä»£ç å¦‚ä¸‹ï¼š int prime[MAXN]; bool vis[MAXN]; for (int i = 2; i &lt;= n; ++i) if (vis[i] == 0) &#123; prime[++tot] = i; for (int j = i * 2; j &lt;= n; j += i) vis[j] = 1; &#125; åŸƒæ°ç­›çš„å¤æ‚åº¦æ˜¯ O(âˆ‘pâ©½nnp=nlogâ¡logâ¡n)\\mathcal{O}(\\sum_{p\\leqslant n} \\cfrac{n}{p}=n \\log\\log n)O(âˆ‘pâ©½nâ€‹pnâ€‹=nloglogn)ï¼Œæ•ˆç‡è¾ƒé«˜ï¼Œä½†ä»éœ€è¾ƒå¥½çš„ IO ä¼˜åŒ–æ‰å¯é€šè¿‡åˆšæ‰çš„æ¨¡æ¿ã€‚ è¿™ä¸ªä»£ç è¿˜å¯ä»¥åŠ ä¸€äº›ä¼˜åŒ–ï¼šå†…å±‚å¾ªç¯ä¸å¿…ä» iÃ—2i\\times 2iÃ—2 å¼€å§‹ï¼Œå®ƒåœ¨ç­› 222 çš„æ—¶å€™å°±å·²ç»è¢«ç­›æ‰äº†ï¼›å¤–å±‚å¾ªç¯ä¹Ÿä¸å¿…åˆ° nnn ç»“æŸï¼Œéœ€è¦ç­›çš„å·²ç»åœ¨ n\\sqrt{n}nâ€‹ å‰ç­›æ‰äº†ï¼ˆä½†è¿™é“é¢˜ä¸­è¿™ä¸ªä¸¤ä¸ªéƒ½ä¸èƒ½ç”¨ï¼Œå› ä¸ºåˆ†åˆ«ä¼šçˆ† int å’Œæ— æ³•ç»Ÿè®¡ç´ æ•°ï¼‰ã€‚ä½†å®é™…ä¸Šï¼Œä¼˜åŒ–åçš„å¤æ‚åº¦å¹¶æ²¡æœ‰æ”¹å˜ã€‚ åŸƒæ°ç­›çš„é€Ÿåº¦å·²ç»è¶³å¤Ÿå¿«ï¼Œå¦‚æœä¸æ˜¯æ—¶é—´ç‰¹åˆ«åƒç´§ï¼Œè€ƒåœºä¸Šä½¿ç”¨åŸƒæ°ç­›å³å¯ã€‚ åˆšæ‰æ˜¯â€œè´¨æ•°çš„æ•´æ•°å€æ˜¯åˆæ•°â€œï¼Œè¿˜æœ‰ä¸€ç§æ€è·¯ï¼šæ•´æ•°çš„è´¨æ•°å€æ˜¯åˆæ•°ã€‚ä»£ç å¦‚ä¸‹ï¼š for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) prime[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) vis[i * prime[j]] = true; &#125; æ¬§æ‹‰ç­› æ¬§æ‹‰ç­›ï¼ˆä¹Ÿç§°ä½œçº¿æ€§ç­›ï¼‰çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)\\mathcal{O}(n)O(n)ï¼Œæ˜¯å¸¸ç”¨ç­›æ³•ä¸­æœ€å¿«çš„ç­›æ³•ã€‚ åŸƒæ°ç­›çš„é—®é¢˜åœ¨äºå®ƒä»ç„¶ä¼šé‡å¤æ ‡è®°åˆæ•°ï¼ˆä» x2x^2x2 å¼€å§‹ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œä½¿å¾—åˆæ•°åªä¼šè¢«å®ƒæœ€å°çš„è´¨å› å­ç­›ä¸€æ¬¡ï¼Œè¿™å°±æ˜¯æ¬§æ‹‰ç­›ï¼ˆç”±äºæ¬§æ‹‰ç­›çš„è¿™ä¸ªç‰¹æ€§ï¼Œå®ƒä¹Ÿå¸¸è¢«ç”¨åšæ±‚åˆæ•°æœ€å°è´¨å› å­çš„æ–¹æ³•ï¼‰ã€‚ æˆ‘ä»¬è®¾ä¸€ä¸ª vvv æ•°ç»„ä»£è¡¨æ¯ä¸ªæ•°çš„æœ€å°è´¨å› å­ï¼Œè®¾è´¨æ•°é›†åˆä¸º pppï¼Œé‚£ä¹ˆå¯ä»¥è¿™æ ·ç»´æŠ¤ vvvï¼š ä¸€æ¬¡è€ƒè™‘ 2âˆ¼n2\\sim n2âˆ¼n é—´çš„æ¯ä¸€ä¸ªæ•° iiiã€‚ å¦‚æœ v[i]v[i]v[i] æ²¡æœ‰å€¼ï¼Œé‚£ä¹ˆè¯´æ˜å®ƒæ˜¯ç´ æ•°ï¼ŒæŠŠå®ƒåŠ è¿› ppp ä¸­ã€‚ æ¥ä¸‹æ¥å¯¹äºæ¯ä¸ªè´¨æ•° p[j]p[j]p[j]ï¼Œä»¤ v[iÃ—p[j]]=p[j]v[i\\times p[j]]=p[j]v[iÃ—p[j]]=p[j]ã€‚ç”±äº p[j]â‰¤v[i]p[j] \\le v[i]p[j]â‰¤v[i]ï¼Œæ‰€ä»¥ p[j]p[j]p[j] ä¸€å®šæ˜¯ iÃ—p[j]i\\times p[j]iÃ—p[j] çš„æœ€å°è´¨å› å­ã€‚ ç”±äºæ‰€æœ‰çš„åˆæ•°åªä¼šè¢«æ ‡è®°ä¸€æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n)\\mathcal{O}(n)O(n)ï¼Œä¸¥è°¨çš„å¤æ‚åº¦å’Œæ­£ç¡®æ€§è¯æ˜è¾ƒä¸ºå¤æ‚ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œäº†è§£ã€‚ä»£ç å¦‚ä¸‹ï¼š int n, tot = 0; int v[MAXN], prime[MAXN]; inline void primes(void) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (v[i] == 0) // æ˜¯è´¨æ•° &#123; v[i] = i; prime[++tot] = i; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) // ç»™ i ä¹˜ä¸Šä¸€ä¸ªè´¨æ•°ï¼Œä¹˜ç§¯å°äº n æ‰å¾ªç¯ &#123; if (prime[j] > v[i]) break; // i çš„æœ€å°è´¨å› å­æ¯” prime[j] æ›´å°ï¼Œbreak v[i * prime[j]] = prime[j]; // æ ‡è®° &#125; &#125; &#125; å®é™…ä¸Šå¦‚æœä¸ç”¨è®°å½•æœ€å°å€¼å› å­çš„è¯ï¼Œä¹Ÿå¯ä»¥è¿™ä¹ˆåšï¼š for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) prime[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; vis[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125; åªå¤šäº†ä¸€ä¸ª breakï¼Œå°±è®©åŸƒæ°ç­›å˜æˆäº†æ¬§æ‹‰ç­›ï¼Œæ¯ä¸ªæ•°åªè¢«ç­›äº†ä¸€æ¬¡ã€‚ åŒºé—´ç­› [Luogu P1835] ç´ æ•°å¯†åº¦. ç»™å®šåŒºé—´ [L,R](1â‰¤Lâ‰¤R&lt;231,Râˆ’Lâ‰¤106)[L,R](1\\le L\\le R &lt; 2^{31},R-L\\le 10^6)[L,R](1â‰¤Lâ‰¤R&lt;231,Râˆ’Lâ‰¤106)ï¼Œæ±‚åŒºé—´ä¸­çš„ç´ æ•°ä¸ªæ•°ã€‚ L,RL,RL,R è¿™ä¹ˆå¤§ï¼Œä½†æ˜¯ Râˆ’LR-LRâˆ’L çš„å€¼å´è¿™ä¹ˆå°ï¼Œè€Œä¸”ä»»ä½•ä¸€ä¸ªåˆæ•° nnn éƒ½ä¸€å®šåŒ…å«ä¸€ä¸ªä¸è¶…è¿‡ n\\sqrt{n}nâ€‹ çš„è´¨å› å­ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦ç”¨ç­›æ³•æ±‚å‡º 2âˆ¼R2\\sim \\sqrt{R}2âˆ¼Râ€‹ ä»¥å†…çš„æ‰€æœ‰è´¨æ•°ï¼Œç„¶åç­›æ‰è¿™äº›æ•°çš„å€æ•°å³å¯ã€‚å¦‚æœé‡‡ç”¨çº¿æ€§ç­›ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸º O(r+(râˆ’l+1)logâ¡logâ¡r)O(\\sqrt{r}+(r-l+1)\\log\\log \\sqrt{r})O(râ€‹+(râˆ’l+1)loglogrâ€‹)ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> #define LL long long using namespace std; LL L, R; bool is_prime[50000]; bool flag[1000005]; inline void solve(int n) &#123; for (int i = 2; i &lt;= n; ++i) is_prime[i] = 1; int g = sqrt(n) + 1; for (int i = 2; i &lt;= g; ++i) if (is_prime[i]) for (int j = i * i; j &lt;= n; j += i) is_prime[j] = 0; &#125; int main(void) &#123; cin >> L >> R; if (L == 1) L = 2; if (L > R) &#123; puts(\"0\"); return 0; &#125; int m = sqrt(R) + 1; solve(m); for (int i = 0; i &lt;= int(R - L); ++i) flag[i] = 1; for (int i = 2; i &lt;= m; ++i) if (is_prime[i]) &#123; LL j = L; while (j % i != 0) ++j; for (; j &lt;= R; j += i) if (i != j) flag[j - L] = 0; &#125; int ans = 0; for (int i = 0; i &lt;= R - L; ++i) if (flag[i]) ++ans; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; ç­›æ³•ä¸ç§¯æ€§å‡½æ•° ç­›æ³•çš„ä½œç”¨è¿œä¸æ­¢ç­›å‡ºç´ æ•°ï¼Œå®ƒä»¬è¿˜å¯ä»¥åœ¨ç­›ç´ æ•°çš„åŒæ—¶æ±‚å‡ºç§¯æ€§å‡½æ•°ã€‚åœ¨æ¬§æ‹‰å‡½æ•°ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•ç”¨ç­›æ³•æ±‚è§£æ¬§æ‹‰å‡½æ•°ï¼›åœ¨ã€Šæ•°è®ºè¿›é˜¶ã€‹ä¸­ï¼Œæˆ‘ä»¬è¿˜ä¼šæ›´æ·±å…¥åœ°æ¢è®¨ç­›æ³•çš„åº”ç”¨ã€‚ æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³• æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ç”¨äºæ±‚è§£ä¸å®šæ–¹ç¨‹ ax+by=gcdâ¡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b) çš„æ•´æ•°è§£ï¼Œæ˜¯æ•°è®ºåŸºç¡€ç®—æ³•ä¹‹ä¸€ã€‚ è£´èœ€å®šç† è£´èœ€å®šç†ã€‚âˆ€a,b, âˆƒx,y, i.e. ax+by=gcdâ¡(a,b)\\forall a,b, ~\\exists x,y,~\\text{i.e.}~ ax+by=\\gcd(a,b)âˆ€a,b, âˆƒx,y, i.e. ax+by=gcd(a,b) å…³äºè£´èœ€å®šç†çš„è¯æ˜ï¼Œç½‘ä¸Šèµ„æ–™è¾ƒå¤šï¼Œè¿™é‡Œä¸åšèµ˜è¿°ã€‚ æ¨¡æ¿ã€‚ æ ¹æ®è£´èœ€å®šç†ï¼Œax+by=gcdâ¡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b)ï¼Œä¹Ÿå°±æ˜¯è¯´ ax+by&gt;0ax+by&gt;0ax+by&gt;0 æ—¶ï¼Œæœ€å°ä¸º gcdâ¡(a,b)\\gcd(a,b)gcd(a,b)ï¼Œä¹Ÿå°±æ˜¯è¯´ç­”æ¡ˆæ˜¯ gcdâ¡(A)\\gcd(A)gcd(A)ï¼Œè€Œä¸”æ˜¯ä¸€ä¸ªæ­£æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int main(void) &#123; int x, ans = 0; scanf(\"%d\", &amp;x); while (scanf(\"%d\", &amp;x) == 1) ans = gcd(ans, x &lt; 0 ? -x : x); printf(\"%d\\n\", ans); return 0; &#125; æ‰©å±•æ¬§å‡ é‡Œå¾— ç”±äº ax+by=gcdâ¡(a,b)=gcdâ¡(b,a mod b)ax+by=\\gcd(a,b)=\\gcd(b,a\\bmod b)ax+by=gcd(a,b)=gcd(b,amodb) ä¸” ax+by=(âŒŠabâŒ‹Ã—b+a mod b)x+by=b(y+âŒŠabâŒ‹x)+(a mod b)xax+by=(\\lfloor\\cfrac{a}{b}\\rfloor\\times b+a\\bmod b)x+by=b(y+\\lfloor\\cfrac{a}{b}\\rfloor x)+(a\\bmod b)xax+by=(âŒŠbaâ€‹âŒ‹Ã—b+amodb)x+by=b(y+âŒŠbaâ€‹âŒ‹x)+(amodb)xï¼Œæ‰€ä»¥æ±‚ä¸å®šæ–¹ç¨‹ ax+by=gcdâ¡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b)ï¼Œç›¸å½“äºæ±‚ b(y+âŒŠabâŒ‹x)+(a mod b)x=gcdâ¡(b,a mod b)b(y+\\lfloor\\cfrac{a}{b}\\rfloor x)+(a\\bmod b)x=\\gcd(b, a\\bmod b)b(y+âŒŠbaâ€‹âŒ‹x)+(amodb)x=gcd(b,amodb)ã€‚ å½“ç„¶è¿™é‡ŒæŠŠä»£ç å®ç°è€ƒè™‘äº†è¿›å»ï¼ˆè¿˜è®°å¾—ä¸ºä»€ä¹ˆæ±‚ gcd è¦æŠŠ xxx å’Œ yyy å†™åå—ï¼‰ï¼Œæ‰€ä»¥æ–°å¼å­ä¸­çš„ (y+âŒŠabâŒ‹x)(y+\\lfloor\\cfrac{a}{b}\\rfloor x)(y+âŒŠbaâ€‹âŒ‹x) ç›¸å½“äº yâ€²y&#x27;yâ€²ï¼Œxxx ç›¸å½“äº xâ€²x&#x27;xâ€²ã€‚ è¿›è€Œæœ‰ y=yâ€²âˆ’âŒŠabâŒ‹Ã—xâ€²y = y&#x27; - \\lfloor\\cfrac{a}{b}\\rfloor\\times x&#x27;y=yâ€²âˆ’âŒŠbaâ€‹âŒ‹Ã—xâ€²ï¼Œxxx æ˜¯ xâ€²x&#x27;xâ€²ã€‚ æ‰€ä»¥ï¼š void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); // æ˜¾ç„¶ exgcd(b, a%b, y, x); // æ ¹æ®åˆšæ‰æ¨å‡ºçš„ç»“è®º // æ­¤æ—¶å·²ç»æ±‚å‡ºäº† x', y' y -= a / b * x; &#125; é‚£ä¹ˆå¦‚ä½•æ±‚å‡ºæ–¹ç¨‹çš„æ‰€æœ‰è§£å‘¢ï¼Ÿ è®¾ç”¨ exgcd æ±‚å‡ºçš„è§£ä¸º x0,y0x_0,y_0x0â€‹,y0â€‹ï¼Œé‚£ä¹ˆæ˜¾ç„¶æœ‰ x=x0+kÃ—bgcdâ¡(a,b),y=y0âˆ’kÃ—agcdâ¡(a,b)x=x_0+k\\times\\cfrac{b}{\\gcd(a,b)},y=y_0-k\\times\\cfrac{a}{\\gcd(a,b)}x=x0â€‹+kÃ—gcd(a,b)bâ€‹,y=y0â€‹âˆ’kÃ—gcd(a,b)aâ€‹ã€‚ æœ€å°æ­£æ•° xxx æ˜¾ç„¶ä¸º x0 mod bgcdâ¡(a,b)x_0 \\bmod \\cfrac{b}{\\gcd(a,b)}x0â€‹modgcd(a,b)bâ€‹ã€‚ æ¨¡æ¿ã€‚ æ ¹æ®è£´èœ€å®šç†ï¼Œax+byax+byax+by çš„ç­”æ¡ˆåªèƒ½æ˜¯ gcdâ¡(a,b)\\gcd(a,b)gcd(a,b) çš„å€æ•°ï¼Œä¹Ÿå°±æ˜¯éœ€è¦æ»¡è¶³ (a,b)âˆ£c(a,b)\\mid c(a,b)âˆ£cã€‚ç›´æ¥ä½¿ç”¨ exgcd ç®—æ³•ï¼Œæ±‚å‡ºæ¥çš„è§£ï¼Œç„¶åå†ä¹˜ä¸Š cÃ·(a,b)c\\div (a,b)cÃ·(a,b)ï¼Œå°±èƒ½å¤Ÿå¾—åˆ°ä¸€ç»„åŸæ–¹ç¨‹çš„è§£ã€‚ å…·ä½“å®ç°è§ä»£ç ï¼š // ç¬”è®°åŸå› ï¼Œåªæ‘˜å½•äº†é‡è¦ä»£ç  i64 exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, a; i64 d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; int main(void) &#123; i64 a = read(), b = read(), c = read(), x, y; i64 g = exgcd(a, b, x, y); if (c % g != 0) puts(\"-1\"); else &#123; x *= c / g, y *= c / g; i64 p = b / g, q = a / g, k; if (x &lt; 0) k = ceil((1.0 - x) / p), x += p * k, y -= q * k; else if (x >= 0) k = (x - 1) / p, x -= p * k, y += q * k; if (y > 0) &#123; printf(\"%lld %lld %lld \", (y - 1) / q + 1, x, (y - 1) % q + 1); printf(\"%lld %lld\\n\", x + (y - 1) / q * p, y) &#125; else printf(\"%lld %lld\\n\", x, y + q * (i64)ceil((1.0 - y) / q)); &#125; &#125; æ¬§æ‹‰å‡½æ•° æ¬§æ‹‰å‡½æ•°ï¼Œå³ Ï†(n)\\varphi(n)Ï†(n)ï¼Œä»£è¡¨ 1âˆ¼n1\\sim n1âˆ¼n ä¸­ä¸ nnn äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚ æ¯”å¦‚åœ¨ 111~121212 ä¸­ï¼Œ1,5,7,111,5,7,111,5,7,11 è¿™å››ä¸ªæ•°ä¸ 121212 äº’è´¨ï¼Œæ‰€ä»¥ Ï†(12)=4\\varphi(12)=4Ï†(12)=4ã€‚ æ±‚è§£ æ€ä¹ˆæ±‚æ¬§æ‹‰å‡½æ•°å‘¢ï¼Ÿè®¾ n=âˆpikin=\\prod p_i^{k_i}n=âˆpikiâ€‹â€‹ï¼Œåˆ™æœ‰ï¼š Ï†(n)=nâˆ(1âˆ’1pi)=nâˆpiâˆ’1pi\\varphi(n)=n\\prod(1-\\cfrac{1}{p_i})=n\\prod \\cfrac{p_i-1}{p_i} Ï†(n)=nâˆ(1âˆ’piâ€‹1â€‹)=nâˆpiâ€‹piâ€‹âˆ’1â€‹ è¯æ˜ï¼š è®¾ ans=nans = nans=nã€‚è®¾ ppp æ˜¯ nnn çš„è´¨å› å­ï¼Œåˆ™è¦åœ¨ ansansans ä¸­å‡æ‰ np\\cfrac{n}{p}pnâ€‹ã€‚qqq ä¹Ÿæ˜¯ï¼Œåˆ™è¦åœ¨ ansansans ä¸­å‡æ‰ nq\\cfrac{n}{q}qnâ€‹ã€‚ä½†æ˜¯ pqpqpq çš„å€æ•°è¢«å‡äº†ä¸¤éï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æ‰¾å›å®ƒçš„å†¤é­‚ï¼Œå†åŠ ä¸Š npq\\cfrac{n}{pq}pqnâ€‹ã€‚æ‰€ä»¥ï¼šans=nâˆ’npâˆ’np+npq=nÃ—(1âˆ’1pâˆ’1qâˆ’1pq)=n(1âˆ’1p)(1âˆ’1q)ans = n - \\cfrac{n}{p} - \\cfrac{n}{p} + \\cfrac{n}{pq} = n\\times(1-\\cfrac{1}{p}-\\cfrac{1}{q}-\\cfrac{1}{pq})=n(1-\\cfrac{1}{p})(1-\\cfrac{1}{q})ans=nâˆ’pnâ€‹âˆ’pnâ€‹+pqnâ€‹=nÃ—(1âˆ’p1â€‹âˆ’q1â€‹âˆ’pq1â€‹)=n(1âˆ’p1â€‹)(1âˆ’q1â€‹)å®é™…ä¸Šä¸Šè¿°æ€æƒ³ç§°ä¹‹ä¸ºå®¹æ–¥åŸç†ï¼Œæ ¹æ®å®¹æ–¥åŸç†çš„å…¬å¼ï¼ˆè¯·è‡ªè¡Œäº†è§£ï¼‰ï¼Œå¯ä»¥å¾—åˆ°è¦è¯æ˜çš„å…¬å¼ã€‚ æ ¹æ®ç»“è®ºæœ‰å¦‚ä¸‹ä»£ç ï¼š inline int phi(int n) &#123; int ans = n; for (int i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; ans = ans / i * (i-1); // å› ä¸ºæ˜¯çº¦æ•°ï¼Œæ‰€ä»¥èƒ½é™¤ while (n % i == 0) n /= i; &#125; if (n > 1) ans = ans / n * (n-1); return ans; &#125; æ—¶é—´å¤æ‚åº¦ä¸º O(n)\\mathcal{O}(\\sqrt{n})O(nâ€‹)ï¼Œå½“ç„¶ä½ å¯ä»¥ç”¨ Pollard Rho æ¥åŠ é€Ÿï¼Œä¸è¿‡æ²¡å¿…è¦ã€‚ æ€§è´¨ âˆ€n&gt;1,1âˆ¼n\\forall n &gt; 1, 1\\sim nâˆ€n&gt;1,1âˆ¼n ä¸­ä¸ nnn äº’è´¨çš„æ•°çš„å’Œä¸º nÃ—Ï†(n)Ã·2n\\times \\varphi(n) \\div 2nÃ—Ï†(n)Ã·2ã€‚ä¸” 2âˆ£Ï†(n)(n&gt;2)2\\mid\\varphi(n)(n&gt;2)2âˆ£Ï†(n)(n&gt;2)ã€‚ è¯æ˜ï¼š ç”±äº (n,x)=(n,nâˆ’x)(n,x)=(n,n-x)(n,x)=(n,nâˆ’x)ï¼Œæ‰€ä»¥ä¸ nnn ä¸äº’è´¨çš„æ•° x,nâˆ’xx,n-xx,nâˆ’x æˆå¯¹å‡ºç°ï¼Œæ¯ä¸€å¯¹çš„å’Œä¸º nÃ·2n \\div 2nÃ·2ã€‚è¿›è€Œæ˜“è¯åŸå‘½é¢˜ã€‚ç”±äºæˆå¯¹å‡ºç°ï¼Œæ‰€ä»¥ 2âˆ£Ï†(n)(n&gt;2)ï¼ŒÏ†(1)=Ï†(2)=12\\mid\\varphi(n)(n&gt; 2)ï¼Œ\\varphi(1)=\\varphi(2)=12âˆ£Ï†(n)(n&gt;2)ï¼ŒÏ†(1)=Ï†(2)=1ã€‚ æ¬§æ‹‰å‡½æ•°æ˜¯ç§¯æ€§å‡½æ•°ã€‚æ ¹æ®æ¬§æ‹‰å‡½æ•°çš„è®¡ç®—å¼å¯ä»¥ç›´æ¥å¾—åˆ°ã€‚é‚£ä¹ˆï¼Œæ¬§æ‹‰å‡½æ•°ä¹Ÿæ»¡è¶³ç§¯æ€§å‡½æ•°çš„æ€§è´¨ã€‚è¿›è€Œå¯ä»¥æ¨å‡ºï¼Œâˆ€2âˆ¤n,Ï†(2n)=Ï†(n)\\forall 2\\nmid n, \\varphi(2n)=\\varphi(n)âˆ€2âˆ¤n,Ï†(2n)=Ï†(n)ï¼Œå› ä¸ºå¥‡æ•° nnn æ˜¾ç„¶ä¸ 222 äº’è´¨ï¼Œä¸” Ï†(2)=1\\varphi(2)=1Ï†(2)=1ï¼Œæ‰€ä»¥ Ï†(2n)=Ï†(2)Ã—Ï†(n)=1Ã—Ï†(n)=Ï†(n)\\varphi(2n)=\\varphi(2)\\times \\varphi(n)=1\\times\\varphi(n)=\\varphi(n)Ï†(2n)=Ï†(2)Ã—Ï†(n)=1Ã—Ï†(n)=Ï†(n)ã€‚ æ¥ä¸‹æ¥çš„ 3,43,43,4 ä¸­ï¼Œppp å‡å±äºè´¨æ•°é›†ã€‚ Ï†(p)=pâˆ’1\\varphi(p)=p-1Ï†(p)=pâˆ’1ï¼› Ï†(pk)=pkâˆ’pkâˆ’1\\varphi(p^k)=p^{k}-p^{k-1}Ï†(pk)=pkâˆ’pkâˆ’1ï¼› è¯æ˜ï¼š æ ¹æ®å®šä¹‰ï¼Œæ€§è´¨ 333 æ˜¾ç„¶ã€‚å¸¦å…¥è®¡ç®—å¼ä¸­åè¿ç”¨ä¹˜æ³•åˆ†é…å¾‹ï¼Œå¯ä»¥è¯æ˜æ€§è´¨ 444ã€‚ è®¾ m=m1Ã—m2m=m_1\\times m_2m=m1â€‹Ã—m2â€‹ï¼Œè‹¥ m1m_1m1â€‹ å’Œ m2m_2m2â€‹ æœ‰ç›¸åŒçš„ç´ å› æ•°ï¼Œé‚£ä¹ˆ Ï†(m)=m2Ï†(m1)\\varphi(m)=m_2 \\varphi(m_1)Ï†(m)=m2â€‹Ï†(m1â€‹)ï¼› n=âˆ‘dâˆ£nÏ†(d)n = \\sum_{d\\mid n} \\varphi(d)n=âˆ‘dâˆ£nâ€‹Ï†(d). è¿™æ˜¯ä¸¤æ¡å¾ˆé‡è¦çš„æ€§è´¨ã€‚è¿™é‡Œç•¥å»è¯æ˜ï¼Œè¯·å‚è€ƒã€Šåˆç­‰æ•°è®ºã€‹ã€‚ ç­›æ³•æ±‚æ¬§æ‹‰å‡½æ•° æˆ‘ä»¬å…ˆçœ‹å¦‚ä½•ä½¿ç”¨åŸƒæ°ç­›æ±‚è§£æ¬§æ‹‰å‡½æ•°ã€‚æ ¹æ®æ¬§æ‹‰å‡½æ•°çš„è®¡ç®—å¼ï¼Œæˆ‘ä»¬å…ˆå¯ä»¥åˆå§‹åŒ– Ï†(i)=i\\varphi(i)=iÏ†(i)=iï¼Œç„¶åä» 222 å¼€å§‹æ‰«æï¼ˆæ ¹æ®è®¡ç®—å¼ï¼Œè€Œ 111 ä¸æ˜¯è´¨æ•°ï¼Œä¸èƒ½æ‰«ï¼‰ã€‚å¦‚æœæ‰«åˆ°ä¸€ä¸ª Ï†(i)=i\\varphi(i)=iÏ†(i)=iï¼Œé‚£ä¹ˆè¯´æ˜è¿™æ˜¯ä¸€ä¸ªè´¨æ•°ï¼Œå°±æ‰«æå®ƒçš„æ‰€æœ‰å€æ•°ï¼Œä¹˜ä¸Š (iâˆ’1)Ã·i(i-1) \\div i(iâˆ’1)Ã·iã€‚ä»£ç å¦‚ä¸‹ï¼š int n, phi[100005]; inline void euler(void) &#123; for (int i = 1; i &lt;= n; ++i) phi[i] = i; for (int i = 2; i &lt;= n; ++i) if (phi[i] == i) &#123; for (int j = i; j &lt;= n; j += i) phi[j] = phi[j] / i * (i - 1); &#125; &#125; æˆ‘ä»¬è¿˜å¯ä»¥ç”¨æ¬§æ‹‰ç­›æ¥æ±‚è§£æ¬§æ‹‰å‡½æ•°ã€‚åœ¨çº¿æ€§ç­›ä¸­ï¼Œå¦‚æœ nnn èƒ½è¢«ç­›æ‰ï¼Œé‚£ä¹ˆå®ƒä¸€å®šæ˜¯è¢«æ¯”å®ƒå°çš„ä¸€ä¸ªæ•° nâ€²n&#x27;nâ€² ä¹˜ä¸Šä¸€ä¸ªè´¨æ•° ppp ç­›æ‰ã€‚ å½“ pâˆ£nâ€²p \\mid n&#x27;pâˆ£nâ€² æ—¶ï¼Œæœ‰ï¼š Ï†(n)=nÃ—âˆi=1piâˆ’1pi=pÃ—nâ€²Ã—âˆi=1piâˆ’1pi=pÃ—Ï†(nâ€²)\\begin{aligned} \\varphi(n) &amp;= n\\times \\prod_{i=1} \\cfrac{p_i-1}{p_i}\\\\ &amp; = p \\times n&#x27; \\times \\prod_{i=1} \\cfrac{p_i-1}{p_i}\\\\ &amp; = p \\times \\varphi(n&#x27;) \\end{aligned} Ï†(n)â€‹=nÃ—i=1âˆâ€‹piâ€‹piâ€‹âˆ’1â€‹=pÃ—nâ€²Ã—i=1âˆâ€‹piâ€‹piâ€‹âˆ’1â€‹=pÃ—Ï†(nâ€²)â€‹ å½“ pâˆ¤nâ€²p \\nmid n&#x27;pâˆ¤nâ€² æ—¶ï¼Œå¯å¾— pâŠ¥nâ€²p\\perp n&#x27;pâŠ¥nâ€²ï¼ˆå› ä¸º ppp æ˜¯è´¨æ•°ï¼‰ï¼Œæœ‰ï¼š Ï†(n)=Ï†(p)Ã—Ï†(nâ€²)=(pâˆ’1)Ã—Ï†(nâ€²)\\begin{aligned} \\varphi(n) &amp;= \\varphi(p) \\times \\varphi(n&#x27;) \\\\ &amp;= (p-1) \\times \\varphi(n&#x27;) \\end{aligned} Ï†(n)â€‹=Ï†(p)Ã—Ï†(nâ€²)=(pâˆ’1)Ã—Ï†(nâ€²)â€‹ æ‰€ä»¥ä»£ç å¦‚ä¸‹ï¼š int v[maxn], prime[maxn], phi[maxn], tot = 0; inline void euler(void) &#123; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (v[i] == 0) &#123; v[i] = i, prime[++tot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; if (prime[j] > v[i]) break; v[i * prime[j]] = prime[j]; phi[i * prime[j]] = phi[i] * (i % prime[j] == 0 ? prime[j] : prime[j] - 1); &#125; &#125; &#125; å½“ç„¶ä¸æ ‡è®° v ä¹Ÿå¯ä»¥åšï¼š phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!phi[i]) prime[++tot] = i, phi[i] = i - 1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; åŒä½™ å¦‚æœä¸¤æ•° a,ba,ba,b é™¤ä»¥ ccc çš„ä½™æ•°ç›¸ç­‰ï¼Œåˆ™ç§° a,ba,ba,b æ¨¡ ccc åŒä½™ï¼Œåˆç§° bbb æ˜¯ aaa å¯¹æ¨¡ ccc çš„å‰©ä½™ï¼Œè®°ä½œ aâ‰¡b(modc)a\\equiv b\\pmod caâ‰¡b(modc)ã€‚ åŒä½™æ˜¯åŸºæœ¬æ•°è®ºä¸­æœ€éš¾çš„éƒ¨åˆ†ã€‚ä½†ä¸è¦å®³æ€•ï¼Œå¦‚æœæ¬§æ‹‰å‡½æ•°é‚£å—å­¦å¾—éå¸¸æ˜ç™½ï¼Œè¿™éƒ¨åˆ†çš„å­¦ä¹ å°†å¼‚å¸¸è½»æ¾ï¼ˆå®é™…ä¸Šåœ¨ã€Šæ•°è®ºè¿›é˜¶ã€‹å¼€å§‹å‰ï¼Œéƒ½ç®—ç®€å•çš„ï¼‰ã€‚ åŸºæœ¬æ¦‚å¿µ åŒä½™æœ‰ä¸€äº›åŸºç¡€çš„æ¦‚å¿µã€‚ æ€§è´¨ åŒä½™è·Ÿç­‰å¼ä¸ä¸€æ ·ï¼Œä½†æ˜¯å®ƒä¹Ÿæœ‰è·Ÿç­‰å¼ç›¸ä¼¼çš„æ€§è´¨ï¼Œä¹Ÿç”±äºç­‰å¼ä¸ç›¸ä¼¼çš„æ€§è´¨ã€‚åŒ…æ‹¬ï¼ˆåˆ†æ æ˜¯ä¸ºäº†å‡å°é•¿åº¦ï¼Œä½†æ˜¯å¯ä»¥çœ‹å‡ºæœ‰ä¸‰ç±»æ€§è´¨ï¼‰ï¼š ç­‰ä»·å…³ç³»ä¸ç­‰å¼ç›¸ä¼¼ä¸ç­‰å¼ä¸åŒè‡ªåæ€§ï¼Œå³ aâ‰¡a(modm)a\\equiv a \\pmod maâ‰¡a(modm)ï¼Œ å¯¹ç§°æ€§ï¼Œå³ aâ‰¡b âŸº bâ‰¡a(modm)a\\equiv b \\iff b \\equiv a \\pmod maâ‰¡bâŸºbâ‰¡a(modm)ï¼Œ ä¼ é€’æ€§ï¼Œå³ aâ‰¡b(modm), bâ‰¡c(modm)âŸ¹aâ‰¡c(modm)a\\equiv b \\pmod m,~ b\\equiv c \\pmod m \\Longrightarrow a\\equiv c \\pmod maâ‰¡b(modm), bâ‰¡c(modm)âŸ¹aâ‰¡c(modm)ã€‚ è¯æ˜ï¼š è‡ªåæ€§ï¼šmâˆ£0âŸ¹mâˆ£aâˆ’aâŸ¹aâ‰¡a(modm)m\\mid 0 \\Longrightarrow m\\mid a-a \\Longrightarrow a\\equiv a \\pmod mmâˆ£0âŸ¹mâˆ£aâˆ’aâŸ¹aâ‰¡a(modm)ï¼Œå¯¹ç§°æ€§ï¼šmâˆ£aâˆ’b âŸº mâˆ£bâˆ’am\\mid a-b \\iff m\\mid b-amâˆ£aâˆ’bâŸºmâˆ£bâˆ’aï¼Œä¼ é€’æ€§ï¼šmâˆ£aâˆ’b,mâˆ£bâˆ’câŸ¹mâˆ£(aâˆ’b)+(bâˆ’c)âŸ¹mâˆ£aâˆ’câŸ¹aâ‰¡c(modm)m\\mid a-b,m\\mid b-c \\Longrightarrow m\\mid (a-b)+(b-c) \\Longrightarrow m\\mid a-c \\Longrightarrow a\\equiv c \\pmod mmâˆ£aâˆ’b,mâˆ£bâˆ’câŸ¹mâˆ£(aâˆ’b)+(bâˆ’c)âŸ¹mâˆ£aâˆ’câŸ¹aâ‰¡c(modm)ã€‚ è¿˜æœ‰ä¸€æ¡ç‰¹æ®Šçš„ï¼Œaâ‰¡b(modm)a\\equiv b\\pmod maâ‰¡b(modm) çš„å……è¦æ¡ä»¶æ˜¯ mâˆ£aâˆ’bâŸºâˆ’mâˆ£aâˆ’bm\\mid a-b \\Longleftrightarrow -m \\mid a-bmâˆ£aâˆ’bâŸºâˆ’mâˆ£aâˆ’bï¼Œæ‰€ä»¥è¯´æœ€åˆçš„åŒä½™å¼ç­‰ä»·äº aâ‰¡b(mod(âˆ’m))a\\equiv b \\pmod {(-m)}aâ‰¡b(mod(âˆ’m))ã€‚åŒä½™å¼å¯ä»¥ç›¸åŠ ï¼Œå³å¦‚æœæœ‰ aâ‰¡b(modm),câ‰¡d(modm)a\\equiv b \\pmod m, c\\equiv d \\pmod maâ‰¡b(modm),câ‰¡d(modm)ï¼Œåˆ™ a+câ‰¡b+d(modm)a+c\\equiv b+d \\pmod ma+câ‰¡b+d(modm)ã€‚è¿›è€Œå¯ä»¥è¯æ˜ï¼Œå¦‚æœ aâ‰¡b(modm)a\\equiv b \\pmod maâ‰¡b(modm)ï¼Œåˆ™ a+câ‰¡b+c(modm)a+c\\equiv b+c \\pmod ma+câ‰¡b+c(modm)ã€‚ åŒä½™å¼ä¹Ÿå¯ä»¥ç›¸ä¹˜ï¼Œå³å¦‚æœæœ‰ aâ‰¡b(modm),câ‰¡d(modm)a\\equiv b \\pmod m, c\\equiv d \\pmod maâ‰¡b(modm),câ‰¡d(modm)ï¼Œåˆ™ acâ‰¡bd(modm)ac\\equiv bd \\pmod macâ‰¡bd(modm)ã€‚è¿›è€Œå¯ä»¥è¯æ˜ï¼Œå¦‚æœ aâ‰¡b(modm)a\\equiv b \\pmod maâ‰¡b(modm)ï¼Œåˆ™ acâ‰¡bc(modm)ac\\equiv bc \\pmod macâ‰¡bc(modm)ã€‚ åŒä½™å¼è¿˜æœ‰åŒå¹‚æ€§ï¼šxâ‰¡y(modm)âŸ¹xnâ‰¡yn(modm)x\\equiv y \\pmod m \\Longrightarrow x^n \\equiv y^n \\pmod mxâ‰¡y(modm)âŸ¹xnâ‰¡yn(modm)ã€‚ è¯æ˜ï¼š ç”± mâˆ£aâˆ’b,mâˆ£câˆ’dâŸ¹mâˆ£(aâˆ’b)+(câˆ’d)âŸ¹mâˆ£(a+c)âˆ’(b+d)m\\mid a-b,m\\mid c-d \\Longrightarrow m\\mid (a-b)+(c-d) \\Longrightarrow m\\mid (a+c)-(b+d)mâˆ£aâˆ’b,mâˆ£câˆ’dâŸ¹mâˆ£(aâˆ’b)+(câˆ’d)âŸ¹mâˆ£(a+c)âˆ’(b+d)ï¼Œå°±å¯ä»¥è¯æ˜åŒä½™å¼å¯ä»¥ç›¸åŠ ã€‚åŠ ä¸ŠåŒä½™å¼çš„è‡ªåæ€§ï¼Œå°±å¯ä»¥è¯æ˜åé¢ä¸€ä¸ªã€‚ç”± a=b+k1m,c=d+k2ma=b+k_1m,c=d+k_2ma=b+k1â€‹m,c=d+k2â€‹mï¼Œå¾— ac=bd+(bk2+dk1+k1k2m)mac=bd+(bk_2+dk_1+k_1k_2m)mac=bd+(bk2â€‹+dk1â€‹+k1â€‹k2â€‹m)mï¼Œè¿›è€Œæ¨å‡º acâ‰¡bd(modm)ac\\equiv bd \\pmod macâ‰¡bd(modm)ã€‚è‡ªåæ€§å¸¦å…¥åå¯è¯æ˜åä¸€ä¸ªã€‚ åŒä½™å¼ç›¸åŠ çš„è¿™ä¸€æ€§è´¨å‘Šè¯‰æˆ‘ä»¬ï¼ŒåŒä½™å¼å¯ä»¥åœ¨åŠ å‡æ„ä¹‰ä¸Šç§»é¡¹ã€‚ åœ¨è¿™ä¹‹åæˆ‘ä»¬å¯ä»¥ç®€å•è¯æ˜ä¸€ä¸‹éšæ—¶å–æ¨¡æ€§è´¨ã€‚ å¯¹äºåŠ å‡æ³•ï¼Œæˆ‘ä»¬è¦è¯æ˜ a mod m+bâ‰¡a+b(modm)a\\bmod m + b \\equiv a+b \\pmod mamodm+bâ‰¡a+b(modm)ã€‚ ç”¨æ˜¾ç„¶æˆç«‹çš„ a mod mâ‰¡a(modm)a\\bmod m \\equiv a \\pmod mamodmâ‰¡a(modm) åŠ ä¸Š bâ‰¡b(modm)b\\equiv b\\pmod mbâ‰¡b(modm) åå¾—è¯ã€‚ å¯¹äºä¹˜æ³•ï¼Œè¦è¯æ˜ a mod mÃ—bâ‰¡ab(modm)a\\bmod m \\times b \\equiv ab \\pmod mamodmÃ—bâ‰¡ab(modm)ã€‚ ç”¨æ˜¾ç„¶æˆç«‹çš„ a mod mâ‰¡a(modm)a\\bmod m \\equiv a\\pmod mamodmâ‰¡a(modm) ä¹˜ä¸Š bâ‰¡b(modm)b\\equiv b\\pmod mbâ‰¡b(modm) åå¾—è¯ã€‚è‹¥ aâ‰¡b(modm),dâ‰¥1,dâˆ£ma\\equiv b \\pmod m,d\\ge 1, d\\mid maâ‰¡b(modm),dâ‰¥1,dâˆ£mï¼Œåˆ™ aâ‰¡b(modd)a\\equiv b \\pmod daâ‰¡b(modd)ã€‚è¿™ä¸€ç‚¹ç”± dâˆ£m,mâˆ£aâˆ’bd\\mid m,m\\mid a-bdâˆ£m,mâˆ£aâˆ’b åˆ©ç”¨æ•´é™¤çš„ä¼ é€’æ€§å¾—åˆ°ã€‚ aâ‰¡b(modm) âŸº daâ‰¡db(modâˆ£dâˆ£m)a\\equiv b \\pmod m \\iff da \\equiv db \\pmod{|d| m}aâ‰¡b(modm)âŸºdaâ‰¡db(modâˆ£dâˆ£m)ï¼Œè¿™ç”± âˆ£dâˆ£mâˆ£daâˆ’db âŸº mâˆ£aâˆ’b|d| m \\mid da-db \\iff m\\mid a-bâˆ£dâˆ£mâˆ£daâˆ’dbâŸºmâˆ£aâˆ’b æ¨å‡ºã€‚ acâ‰¡bc(modm) âŸº aâ‰¡b(modmÃ·(c,m))ac\\equiv bc \\pmod m \\iff a\\equiv b \\pmod{m\\div (c,m)}acâ‰¡bc(modm)âŸºaâ‰¡b(modmÃ·(c,m))ï¼Œè¿›è€Œæœ‰å½“ (c,m)=1(c,m)=1(c,m)=1 æ—¶ï¼Œacâ‰¡bc(modm) âŸº aâ‰¡b(modm)ac\\equiv bc \\pmod m \\iff a\\equiv b \\pmod{m}acâ‰¡bc(modm)âŸºaâ‰¡b(modm)ã€‚è¯æ˜æ˜¯å°†æœ€åˆçš„åŒä½™å¼å†™ä½œ mâˆ£c(aâˆ’b) âŸº m(c,m)âˆ£c(c,m)(aâˆ’b)m\\mid c(a-b)\\iff \\cfrac{m}{(c,m)}\\mid\\cfrac{c}{(c,m)}(a-b)mâˆ£c(aâˆ’b)âŸº(c,m)mâ€‹âˆ£(c,m)câ€‹(aâˆ’b)ï¼Œç”±äº m(c,m)âŠ¥c(c,m)\\cfrac{m}{(c,m)}\\perp\\cfrac{c}{(c,m)}(c,m)mâ€‹âŠ¥(c,m)câ€‹ï¼ˆæŠŠå…¬çº¦æ•°é™¤å…‰äº†å½“ç„¶äº’è´¨äº†ï¼‰ï¼ŒåŠ ä¸Šæœ€å¤§å…¬çº¦æ•°çš„æ¨è®ºï¼ˆå¯ä»¥å›å»çœ‹çœ‹ï¼‰ï¼Œè¿™ç­‰ä»·äº m(c,m)âˆ£(aâˆ’b)\\cfrac{m}{(c,m)}\\mid(a-b)(c,m)mâ€‹âˆ£(aâˆ’b)ï¼Œä¹Ÿå°±æ˜¯è¦è¯çš„ç»“è®ºã€‚ åŒä½™æ–¹ç¨‹ æ³¨æ„åŒä½™çš„è¿™ä¸ªå¼å­ aâ‰¡b(modc)a\\equiv b\\pmod caâ‰¡b(modc)ï¼Œå¦‚æœæŠŠå®ƒçœ‹åšä¸€ä¸ªæ–¹ç¨‹ï¼Œé‚£ä¹ˆè¿™ä¸ªå¼å­å«åšåŒä½™æ–¹ç¨‹ã€‚ åŒä½™æ–¹ç¨‹çš„ç‰¹ä¾‹â€”â€”æ¨ªçº¿æ€§æ–¹ç¨‹æ˜¯æˆ‘ä»¬è¦è®¨è®ºçš„å†…å®¹ã€‚å®ƒé•¿è¿™æ ·ï¼šaxâ‰¡b(modm)ax\\equiv b\\pmod maxâ‰¡b(modm)ã€‚ æ€ä¹ˆè§£å‘¢ï¼Ÿä¸éš¾å¾—å‡ºï¼Œè¿™ä¸ªæ–¹ç¨‹æœ‰è§£çš„å……è¦æ¡ä»¶æ˜¯ axâˆ’bax-baxâˆ’b æ˜¯ mmm çš„å€æ•°ã€‚è®¾è¿™ä¸ªå€æ•°ä¸º âˆ’y-yâˆ’y å€ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹ç¨‹ç­‰ä»·äº axâˆ’b=âˆ’ymax-b=-ymaxâˆ’b=âˆ’ymï¼Œå³ ax+my=bax+my=bax+my=bã€‚è¿™æ˜¯ä»€ä¹ˆï¼Ÿæ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼ æ ¹æ®è£´èœ€å®šç†ï¼Œbbb å¿…é¡»æ˜¯ gcdâ¡(a,m)\\gcd(a,m)gcd(a,m) çš„å€æ•°ï¼Œé‚£ä¹ˆå°±è°ƒç”¨ exgcd(a,m,x,y) å³å¯ã€‚ æˆ‘ä»¬è®¾æ±‚å‡ºæ¥çš„ä¸œè¥¿æ»¡è¶³ ax0+my0=gcdâ¡(a,m)ax_0+my_0=\\gcd(a,m)ax0â€‹+my0â€‹=gcd(a,m)ï¼Œé‚£ä¹ˆ x=x0Ã—bÃ·gcdâ¡(a,m)x=x_0\\times b\\div \\gcd(a,m)x=x0â€‹Ã—bÃ·gcd(a,m) å°±æ˜¯åŸçº¿æ€§åŒä½™æ–¹ç¨‹çš„ä¸€ç»„è§£ã€‚æ–¹ç¨‹çš„æ‰€æœ‰è§£åˆ™æ˜¯æ‰€æœ‰æ¨¡ mÃ·(a,m)m\\div (a,m)mÃ·(a,m) ä¸ xxx åŒä½™çš„æ•´æ•°ï¼ˆæ³¨æ„è¿™ä¸€ç‚¹ï¼ï¼‰ã€‚è¿™ä¸€ç‚¹è·Ÿå½“æ—¶è§£äºŒå…ƒä¸€æ¬¡ä¸å®šæ–¹ç¨‹çš„åŸç†ä¸€æ ·ï¼Œa(x+kÃ—m(a,m))+m(y+kÃ—a(a,m))=ba\\left(x+k\\times \\cfrac{m}{(a,m)}\\right)+m\\left(y+k\\times \\cfrac{a}{(a,m)}\\right)=ba(x+kÃ—(a,m)mâ€‹)+m(y+kÃ—(a,m)aâ€‹)=b ç”±äºæˆ‘ä»¬çš„ä»£ç å®ç°çš„ gcdâ¡\\gcdgcd åªèƒ½å¯¹æ­£æ•°æœ‰æ„ä¹‰ï¼Œæ‰€ä»¥è¦å°† aaa å˜ä¸ºæ­£æ•°ï¼Œè€Œ mymymy è¿™ä¸€é¡¹æ€ä¹ˆæ ·æ— æ‰€è°“ï¼Œå› ä¸º yyy çš„ç¬¦å·æ˜¯éšä¾¿çš„ã€‚bbb ä¹Ÿè¦å˜ä¸ºç›¸åæ•°ã€‚ [Luogu 1516] é’è›™çš„çº¦ä¼šã€‚ ä¸¤åªé’è›™åœ¨ç½‘ä¸Šç›¸è¯†äº†ï¼Œå®ƒä»¬èŠå¾—å¾ˆå¼€å¿ƒï¼Œäºæ˜¯è§‰å¾—å¾ˆæœ‰å¿…è¦è§ä¸€é¢ã€‚å®ƒä»¬å¾ˆé«˜å…´åœ°å‘ç°å®ƒä»¬ä½åœ¨åŒä¸€æ¡çº¬åº¦çº¿ä¸Šï¼Œäºæ˜¯å®ƒä»¬çº¦å®šå„è‡ªæœè¥¿è·³ï¼Œç›´åˆ°ç¢°é¢ä¸ºæ­¢ã€‚å¯æ˜¯å®ƒä»¬å‡ºå‘ä¹‹å‰å¿˜è®°äº†ä¸€ä»¶å¾ˆé‡è¦çš„äº‹æƒ…ï¼Œæ—¢æ²¡æœ‰é—®æ¸…æ¥šå¯¹æ–¹çš„ç‰¹å¾ï¼Œä¹Ÿæ²¡æœ‰çº¦å®šè§é¢çš„å…·ä½“ä½ç½®ã€‚ä¸è¿‡é’è›™ä»¬éƒ½æ˜¯å¾ˆä¹è§‚çš„ï¼Œå®ƒä»¬è§‰å¾—åªè¦ä¸€ç›´æœç€æŸä¸ªæ–¹å‘è·³ä¸‹å»ï¼Œæ€»èƒ½ç¢°åˆ°å¯¹æ–¹çš„ã€‚ä½†æ˜¯é™¤éè¿™ä¸¤åªé’è›™åœ¨åŒä¸€æ—¶é—´è·³åˆ°åŒä¸€ç‚¹ä¸Šï¼Œä¸ç„¶æ˜¯æ°¸è¿œéƒ½ä¸å¯èƒ½ç¢°é¢çš„ã€‚ä¸ºäº†å¸®åŠ©è¿™ä¸¤åªä¹è§‚çš„é’è›™ï¼Œä½ è¢«è¦æ±‚å†™ä¸€ä¸ªç¨‹åºæ¥åˆ¤æ–­è¿™ä¸¤åªé’è›™æ˜¯å¦èƒ½å¤Ÿç¢°é¢ï¼Œä¼šåœ¨ä»€ä¹ˆæ—¶å€™ç¢°é¢ã€‚æˆ‘ä»¬æŠŠè¿™ä¸¤åªé’è›™åˆ†åˆ«å«åšé’è›™ A å’Œé’è›™ Bï¼Œå¹¶ä¸”è§„å®šçº¬åº¦çº¿ä¸Šä¸œç» 000 åº¦å¤„ä¸ºåŸç‚¹ï¼Œç”±ä¸œå¾€è¥¿ä¸ºæ­£æ–¹å‘ï¼Œå•ä½é•¿åº¦ 111 ç±³ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€æ¡é¦–å°¾ç›¸æ¥çš„æ•°è½´ã€‚è®¾é’è›™ A çš„å‡ºå‘ç‚¹åæ ‡æ˜¯ xxxï¼Œé’è›™ B çš„å‡ºå‘ç‚¹åæ ‡æ˜¯ yyyã€‚é’è›™ A ä¸€æ¬¡èƒ½è·³ mmm ç±³ï¼Œé’è›™ B ä¸€æ¬¡èƒ½è·³ nnn ç±³ï¼Œä¸¤åªé’è›™è·³ä¸€æ¬¡æ‰€èŠ±è´¹çš„æ—¶é—´ç›¸åŒã€‚çº¬åº¦çº¿æ€»é•¿ LLL ç±³ã€‚ç°åœ¨è¦ä½ æ±‚å‡ºå®ƒä»¬è·³äº†å‡ æ¬¡ä»¥åæ‰ä¼šç¢°é¢ã€‚ é¢˜ç›®æ˜¾ç„¶æ˜¯è®©æˆ‘ä»¬æ±‚åŒä½™æ–¹ç¨‹ x+kmâ‰¡y+kn(modL)x+km\\equiv y+kn \\pmod Lx+kmâ‰¡y+kn(modL) çš„è§£ï¼Œç§»é¡¹ï¼ˆç”±äºéšæ—¶å–æ¨¡æ€§è´¨ï¼ŒåŒä½™å¼æ˜¯å¯ä»¥ç§»é¡¹çš„ï¼‰å¯å¾— k(mâˆ’n)â‰¡yâˆ’x(modL)k(m-n)\\equiv y-x \\pmod Lk(mâˆ’n)â‰¡yâˆ’x(modL)ã€‚é‚£ä¹ˆä»¤ a=mâˆ’n,k=x,b=yâˆ’xa=m-n,k=x,b=y-xa=mâˆ’n,k=x,b=yâˆ’xï¼Œå°±è½¬åŒ–ä¸ºäº† axâ‰¡b(modL)ax\\equiv b\\pmod Laxâ‰¡b(modL)ã€‚ ä¹Ÿå°±ç›¸å½“äº axâˆ’b=nL âŸº axâˆ’nL=bax-b=nL\\iff ax-nL=baxâˆ’b=nLâŸºaxâˆ’nL=bã€‚ ä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; inline i64 read(void) &#123; i64 x = 0; int c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; i64 exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, a; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; int main(void) &#123; i64 x = read(), y = read(), m = read(), n = read(), L = read(); i64 a = m - n, b = y - x, c, d; if (a &lt; 0) a = -a, b = -b; i64 g = exgcd(a, L, c, d); if (b % g == 0) &#123; c = c * (b / g); i64 M = L / g; printf(\"%lld\\n\", (c % M + M) % M); &#125; else puts(\"Impossible\"); return 0; &#125; åŒä½™ç±»ä¸å‰©ä½™ç³» æŠŠå…¨ä½“æ•´æ•°åˆ†ä¸ºè‹¥å¹²ä¸ªä¸¤ä¸¤ä¸ç›¸äº¤çš„é›†åˆï¼Œä½¿å¾—åœ¨åŒä¸€ä¸ªé›†åˆä¸­çš„ä»»æ„ä¸¤ä¸ªæ•°å¯¹æ¨¡ mmm ä¸€å®šåŒä½™ï¼Œè€Œå±äºä¸åŒé›†åˆä¸­çš„ä¸¤ä¸ªæ•°æ¨¡ mmm ä¸€å®šä¸åŒä½™ã€‚æ¯ä¸€ä¸ªè¿™æ ·çš„é›†åˆè¢«ç§°ä¸ºæ¨¡ mmm çš„åŒä½™ç±»æˆ–æ¨¡ mmm çš„å‰©ä½™ç±»ã€‚è¿™ä¸ªé›†åˆè®°ä½œæ¨¡ mmm çš„åŒä½™ç±» aâ€¾\\overline{a}aã€‚æ˜¾ç„¶ï¼Œè¿™ä¸ªé›†åˆæ˜¯ {a+km}(kâˆˆZ)\\{a+km\\}(k\\in \\mathbb{Z}){a+km}(kâˆˆZ)ã€‚ æ¨¡ mmm çš„åŒä½™ç±»ä¸€å…±æœ‰ mmm ä¸ªï¼Œåˆ†åˆ«ä¸º 0â€¾,1â€¾,2â€¾,â‹¯ ,mâˆ’1â€¾\\overline{0},\\overline{1},\\overline{2},\\cdots,\\overline{m-1}0,1,2,â‹¯,mâˆ’1â€‹ã€‚ä»æ¯ä¸ªåŒä½™ç±»ä¸­å–å‡ºä¸€ä¸ªæ•°ï¼Œå®ƒä»¬æ‰€æ„æˆçš„é›†åˆç§°ä¸ºæ¨¡ mmm çš„å®Œå…¨å‰©ä½™ç³»ã€‚ å¦‚æœä¸€ç»„æ•° z1,z2,â‹¯ ,ztz_1,z_2,\\cdots,z_tz1â€‹,z2â€‹,â‹¯,ztâ€‹ æ»¡è¶³ (zj,m)=1,1â©½jâ©½t(z_j,m)=1,1\\leqslant j \\leqslant t(zjâ€‹,m)=1,1â©½jâ©½tï¼Œä»¥åŠå¯¹äºä»»æ„çš„ a,(a,m)=1a,(a,m)=1a,(a,m)=1ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€ä¸ª zjz_jzjâ€‹ æ»¡è¶³ aâ‰¡zj(modm)a\\equiv z_j \\pmod maâ‰¡zjâ€‹(modm)ï¼Œé‚£ä¹ˆç§°è¿™ç»„æ•°ä¸ºæ¨¡ mmm çš„æ—¢çº¦ï¼ˆæˆ–äº’ç´ ï¼‰å‰©ä½™ç³»ã€‚ä¹Ÿå«ä½œç®€åŒ–å‰©ä½™ç³»ã€‚ä¹Ÿå¯ä»¥ç»™å®ƒæ¢ä¸€ä¸ªå®šä¹‰ï¼š1âˆ¼m1\\sim m1âˆ¼m ä¸­ä¸ mmm äº’è´¨çš„æ•°ä»£è¡¨çš„åŒä½™ç±»å…±æœ‰ Ï†(m)\\varphi(m)Ï†(m) ä¸ªï¼Œå®ƒä»¬æ„æˆ mmm çš„ç®€åŒ–å‰©ä½™ç³»ã€‚ æœ‰å…³äºåŒä½™ç±»å’Œå‰©ä½™ç³»è¿˜æœ‰å¾ˆå¤šæ¦‚å¿µã€æ€§è´¨ä¸è¯æ˜ï¼Œè¯·å‚è€ƒã€Šåˆç­‰æ•°è®ºã€‹ã€‚åŒä½™ç±»ä¸å‰©ä½™ç³»æ˜¯åˆç­‰æ•°è®ºçš„åŸºç¡€ã€‚æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥è¯æ˜æ¬§æ‹‰å‡½æ•°çš„æœ‰å…³å†…å®¹ï¼Œè¿˜æœ‰éœ€è®¸è®¸å¤šå¤šæœ‰è¶£çš„ä¸œè¥¿ã€‚ Fermat-Euler å®šç† âˆ€aâŠ¥n,aÏ†(n)â‰¡1(modn)\\forall a\\perp n, a^{\\varphi(n)}\\equiv 1 \\pmod nâˆ€aâŠ¥n,aÏ†(n)â‰¡1(modn) ç‰¹åˆ«åœ°ï¼Œå½“ nnn ä¸ºç´ æ•°ï¼Œæœ‰ âˆ€aâŠ¥n,anâ‰¡a(modn)\\forall a\\perp n, a^n\\equiv a \\pmod nâˆ€aâŠ¥n,anâ‰¡a(modn)ã€‚ é€šå¸¸æŠŠç¬¬ä¸€ä¸ªåŒä½™å¼ç§°ä¸ºæ¬§æ‹‰å®šç†ï¼Œç¬¬äºŒä¸ªç§°ä¸ºè´¹é©¬å°å®šç†ã€‚è´¹é©¬å°å®šç†è¿˜æœ‰ä¸€ç§å†™æ³•ï¼šapâˆ’1â‰¡1(modp)a^{p-1}\\equiv 1 \\pmod papâˆ’1â‰¡1(modp)ã€‚ è´¹é©¬å°å®šç†æ˜¯æ¬§æ‹‰å®šç†çš„ä¸€ä¸ªç‰¹æ®Šæƒ…å†µã€‚æˆ‘ä»¬å…ˆå‡è®¾æ¬§æ‹‰å®šç†æˆç«‹ï¼Œç„¶åæˆ‘ä»¬æ¥è¯æ˜è´¹é©¬å°å®šç†ã€‚ æˆ‘ä»¬å…ˆæ±‚è¯è´¹é©¬å°å®šç†çš„ç¬¬äºŒç§å†™æ³•ã€‚å› ä¸º ppp æ˜¯ç´ æ•°ï¼Œæ‰€ä»¥ Ï†(p)=pâˆ’1\\varphi(p)=p-1Ï†(p)=pâˆ’1ã€‚å½“ aâŠ¥pa\\perp paâŠ¥p æ—¶ï¼Œè´¹é©¬å°å®šç†å°±æ˜¯æ¬§æ‹‰å®šç†ï¼Œæ˜¾ç„¶æˆç«‹ã€‚æˆ‘ä»¬æŠŠç¬¬äºŒç§å†™æ³•è½¬æˆç†Ÿæ‚‰çš„ç­‰å¼ apâˆ’1 mod pâ‰¡1(modp)a^{p-1} \\bmod p \\equiv 1 \\pmod papâˆ’1modpâ‰¡1(modp)ï¼ˆæ³¨ï¼Œæ•°å­¦ä¸­æ²¡æœ‰è¿™ä¹ˆå†™çš„ï¼Œåªæ˜¯ä¸ºäº†æ–¹ä¾¿ï¼‰ã€‚ä¸¤è¾¹åŒä¹˜ aaaï¼Œå¯ä»¥å¾—åˆ° apâˆ’1 mod pÃ—aâ‰¡a(modp)a^{p-1} \\bmod p \\times a \\equiv a \\pmod papâˆ’1modpÃ—aâ‰¡a(modp)ï¼Œå½»åº•æ‹†æ‰åŒä½™ï¼Œæœ‰ apâˆ’1 mod pÃ—a mod p=a mod pa^{p-1} \\bmod p \\times a\\bmod p = a \\bmod papâˆ’1modpÃ—amodp=amodpï¼Œåˆç”±äºéšæ—¶å–æ¨¡ï¼Œå¯å¾— apâˆ’1Ã—a mod p=a mod pa^{p-1} \\times a \\bmod p = a \\bmod papâˆ’1Ã—amodp=amodpï¼Œå³ apâ‰¡a(modp)a^p\\equiv a \\pmod papâ‰¡a(modp)ã€‚ ç°åœ¨æˆ‘ä»¬åªéœ€è¦è¯æ˜æ¬§æ‹‰å®šç†å°±å¯ä»¥è¯æ˜ä»¥ä¸Šæ‰€æœ‰å®šç†ã€‚è¯æ˜éœ€è¦å¯¹åŒä½™ç±»å’Œå‰©ä½™ç³»è¿›è¡Œåˆ†æï¼ˆä¹Ÿæœ‰å…¶å®ƒè¯æ³•ï¼‰ï¼Œè¿™é‡Œå°±ä¸è¯äº†ã€‚ ä½†æ˜¯ä½ æ•¢ä¿¡å—ï¼Œè¿™ç©æ„è¿˜èƒ½ç»§ç»­å¾€ä¸‹æ¨ã€‚ è¿™ä¾¿æ˜¯æ‰©å±•æ¬§æ‹‰å®šç†ï¼Œä¹Ÿå°±æ˜¯ âˆ€a,n,a2Ï†(n)â‰¡aÏ†(n)(modn)\\forall a,n,a^{2\\varphi(n)}\\equiv a^{\\varphi(n)}\\pmod nâˆ€a,n,a2Ï†(n)â‰¡aÏ†(n)(modn)ï¼Œé‚£ä¹ˆï¼š abâ‰¡{ab mod Ï†(n),aâŠ¥n,ab,(a,n)â‰ 1,bâ‰¤Ï†(n),ab mod Ï†(n)+Ï†(n),(a,n)â‰ 1,b&gt;Ï†(n).(modn)a^{b}\\equiv \\begin{cases} a^{b\\bmod\\varphi(n)}, &amp;a\\perp n,\\\\ a^b, &amp;(a,n)\\neq 1,b\\le\\varphi(n),\\\\ a^{b\\bmod\\varphi(n)+\\varphi(n)}, &amp;(a,n)\\neq 1,b&gt;\\varphi(n). \\end{cases} \\pmod n abâ‰¡â©â¨â§â€‹abmodÏ†(n),ab,abmodÏ†(n)+Ï†(n),â€‹aâŠ¥n,(a,n)î€ =1,bâ‰¤Ï†(n),(a,n)î€ =1,b&gt;Ï†(n).â€‹(modn) è¦æ³¨æ„ï¼Œå®é™…ä¸Šå³ä½¿åœ¨ a,ba,ba,b ä¸äº’è´¨çš„æƒ…å†µä¸‹ï¼ŒäºŒå¼å’Œä¸‰å¼ä¹Ÿä¾ç„¶æˆç«‹ï¼Œä½†æ˜¯è¿™ä¸¤ä¸ªå¼å­ç›¸äº’ç‹¬ç«‹ï¼Œä¹Ÿå°±æ˜¯å½“ bâ‰¤Ï†(n)b\\le \\varphi(n)bâ‰¤Ï†(n) çš„æ—¶å€™ï¼Œä¸‰å¼å¯èƒ½æ˜¯é”™è¯¯çš„ã€‚ è®¸å¤šé¢˜ç›®è¦æ±‚æˆ‘ä»¬æŠŠç­”æ¡ˆå¯¹ä¸€ä¸ªæ•° pppï¼ˆä¸ä¸€å®šæ˜¯è´¨æ•°ï¼Œéè´¨æ•°å°±æ˜¯åŠ å¼ºéš¾åº¦ï¼‰ï¼Œè¿™æ—¶å¯ä»¥ç”¨æ‰©å±•æ¬§æ‹‰å®šç†äºŒå¼ä¸‰å¼è¿›è¡Œé™å¹‚ï¼Œå¦‚æœæ»¡è¶³ä¸‰å¼çš„æ¡ä»¶ï¼Œé‚£ä¹ˆå°±æŠŠåº•æ•°å¯¹ ppp å–æ¨¡ï¼ŒæŒ‡æ•°å¯¹ Ï†(p)\\varphi(p)Ï†(p) å–æ¨¡ååŠ ä¸Š Ï†(p)\\varphi(p)Ï†(p) å³å¯ã€‚ æ¨¡æ¿ã€‚æ³¨æ„è¾¹è¯»å…¥è¾¹å–æ¨¡ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; int a, m, b, phi; inline void calcPhi(int n) &#123; int ans = n, t = sqrt(n + 0.5); for (int i = 2; i &lt;= t; ++i) if (n % i == 0) &#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; if (n > 1) ans = ans / n * (n - 1); phi = ans; &#125; inline int read(void) &#123; int x = 0, c = getchar(); bool flag = false; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48); if (x > phi) &#123; // å¤§äºæ‰å–æ¨¡ x %= phi; flag = true; // éœ€è¦åŠ  &#125; c = getchar(); &#125; return x + (flag ? phi : 0); &#125; inline int power(int x, int p) &#123; int res = 1; while (p) &#123; if (p &amp; 1) res = (long long)res * x % m; x = (long long)x * x % m; p >>= 1; &#125; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;a, &amp;m); calcPhi(m); b = read(); printf(\"%d\\n\", power(a, b)); return 0; &#125; é€†å…ƒ é€†å…ƒï¼Œä¸‡ç‰©çš„èµ·æºï¼Œåƒå‡ºç°äº†æ–°çš„é“å…·ï¼Œæ¸¸æˆè¢«å¼€å¯äº†æ–°çš„å‰¯æœ¬ï¼Œæ•°è®ºä»æ­¤å‘å‰è¿ˆè¿›äº†ä¸€æ­¥ï¼Œä»¥å‰åšä¸äº†çš„äº‹æƒ…â€”â€”é™¤æ³•å–æ¨¡ï¼Œç°åœ¨å·²ç»è¿‘åœ¨çœ¼å‰ï¼ˆå•Šï¼Œä¸æ˜¯[3] å¼•å­ æ¨¡æ„ä¹‰ä¸‹çš„é™¤æ³•ã€‚å°½ç®¡æˆ‘ä»¬ä¼šåœ¨ã€Šæ•°è®ºè¿›é˜¶ã€‹ä¸­ä»‹ç»æœ‰ç†æ•°å–æ¨¡ï¼ˆè™½ç„¶ä¸æ˜¯ä»€ä¹ˆé¬¼åˆ†æ•°éƒ½èƒ½åšï¼‰ï¼Œæˆ‘ä»¬å…ˆå¸¸è§„æƒ³ä¸€æƒ³ã€‚ æ¯”å¦‚ 5Ã·3Ã—125\\div 3 \\times 125Ã·3Ã—12ï¼Œå‡ºç°äº†é™¤æ³•ï¼Œé™¤æ³•ä¸æ»¡è¶³éšæ—¶å–æ¨¡æ€§è´¨ï¼Œäºæ˜¯æˆ‘ä»¬çš„ç¨‹åºå°±ä¼šæ­»äº¡ã€‚ä½†æ˜¯åé¢ä¹˜ä¸Šäº† 121212ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªå¼å­å¯ä»¥å½“ä½œ 5Ã—45\\times 45Ã—4ï¼Œå®ƒåˆå˜æˆåˆæ³•çš„äº†ã€‚ ç„¶è€Œæˆ‘ä»¬ä¸æ˜¯ä¸Šå¸ï¼Œåšä¸åˆ°é¢„åˆ¤æœªæ¥ï¼Œåªèƒ½ç»™å½“ä¸‹è®°ä¸ªå¸ï¼Œäºæ˜¯ï¼Œé€†å…ƒè¯ç”Ÿäº†ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰§è¡Œâ€œé™¤ä»¥ xxxâ€çš„æ—¶å€™ï¼Œæˆ‘ä»¬è¯•ç€ä¹˜ä¸Šå¦ä¸€ä¸ªæ•°ï¼ˆè®°è´¦ï¼‰ï¼Œç­‰åˆ°æ—¥åä¹˜ä¸Š xxx çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±èƒ½æŠŠæ•°å˜å›æ¥ï¼Œå¾—åˆ°æ­£ç¡®ç»“æœã€‚ä¹Ÿå°±æ˜¯æˆ‘ä»¬èƒ½æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³ kâ‰¡1x(modp)k\\equiv \\cfrac{1}{x}\\pmod pkâ‰¡x1â€‹(modp)ï¼Œè¿™ä¸ª kkk å°±æ˜¯æˆ‘ä»¬æ‰€æ±‚ï¼ ç„¶åä½ ä¼šå‘ç°è¿™å°±æ˜¯æœ‰ç†æ•°å–ä½™ã€‚ ä¸è¿‡æˆ‘ä»¬å…ˆä¸ç®¡è¿™äº›ï¼Œæˆ‘ä»¬æŒ‰ç…§æ­£å¸¸çš„æ€ç»´ç»§ç»­æã€‚ æ¯”å¦‚æˆ‘ä»¬è¦æ‰¾çš„ 13\\cfrac{1}{3}31â€‹ çš„é€†å…ƒï¼Œåœ¨ mod 11\\bmod 11mod11 æ„ä¹‰ä¸‹çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥å°† Ã·3\\div 3Ã·3 å˜æˆ Ã—4\\times 4Ã—4ï¼Œäºæ˜¯ 5Ã—4Ã—12â‰¡9(mod11)5\\times 4 \\times 12\\equiv 9 \\pmod{11}5Ã—4Ã—12â‰¡9(mod11)ï¼Œäº‹å®ä¸Šï¼Œ5Ã·3Ã—12=20,20 mod 11=95\\div 3 \\times 12=20, 20\\bmod 11 = 95Ã·3Ã—12=20,20mod11=9ã€‚ æˆ‘ä»¬è®°ä¸€ä¸ªæ•°çš„é€†å…ƒä¸º inv(x)\\text{inv}(x)inv(x)ï¼Œæ˜¾ç„¶ï¼Œå®ƒæ»¡è¶³ï¼š xÃ—inv(x)â‰¡1(modp)x\\times \\text{inv}(x) \\equiv 1 \\pmod p xÃ—inv(x)â‰¡1(modp) è¿™ä¸ª inv(x)\\text{inv}(x)inv(x) ä¹Ÿå¯è®°ä½œ xâˆ’1x^{-1}xâˆ’1ï¼ˆå³ 1x\\cfrac{1}{x}x1â€‹ï¼‰ã€‚ æ±‚æ³• è¿˜è®°å¾—è´¹é©¬å°å®šç†å—ï¼Ÿå½“ xâŠ¥px\\perp pxâŠ¥p æ—¶ï¼Œæˆ‘ä»¬æœ‰ xÃ—inv(x)â‰¡1(modp)x\\times \\text{inv}(x) \\equiv 1 \\pmod pxÃ—inv(x)â‰¡1(modp)ï¼Œå’Œè´¹é©¬å°å®šç† xpâˆ’1â‰¡1(modp)x^{p-1}\\equiv 1 \\pmod pxpâˆ’1â‰¡1(modp)ï¼Œé‚£ä¹ˆå¯ä»¥å¾—åˆ°ï¼š xÃ—inv(x)â‰¡xpâˆ’1(modp)x\\times \\text{inv}(x) \\equiv x^{p-1} \\pmod p xÃ—inv(x)â‰¡xpâˆ’1(modp) ä¸¤è¾¹åŒæ—¶é™¤ä»¥ xxxï¼ˆå› ä¸º xâŠ¥px\\perp pxâŠ¥pï¼‰ï¼Œå¾—åˆ°ï¼š inv(x)â‰¡xpâˆ’2(modp)\\text{inv}(x) \\equiv x^{p-2} \\pmod p inv(x)â‰¡xpâˆ’2(modp) è¿™ä¾¿æ˜¯ç”¨è´¹é©¬å°å®šç†æ±‚é€†å…ƒçš„æ–¹æ³•ï¼Œç›´æ¥è°ƒç”¨å¿«é€Ÿå¹‚ power(x, p-2, p) å³å¯ã€‚ ç„¶è€Œä½ çœ‹é‚£ä¸ªä¸œè¥¿ä¸æ˜¯åŒä½™æ–¹ç¨‹å—ï¼Ÿæˆ‘ä»¬ç›´æ¥è°ƒç”¨ exgcd å°±èƒ½æ±‚å‡ºé€†å…ƒå•¦ï¼ˆå¯ä»¥å‘ç°æœ‰è§£ä»…å½“ xâŠ¥px\\perp pxâŠ¥pï¼‰ï¼æ‰©å±•æ¬§å‡ é‡Œå¾—æ±‚é€†å…ƒå¾€å¾€æ¯”è´¹é©¬å°å®šç†å¿«ï¼Œè€Œä¸”åœ¨æ¨¡æ•°ä¸æ˜¯è´¨æ•°çš„æƒ…å†µä¸‹ï¼Œå¦‚æœæœ‰é€†å…ƒä¹Ÿèƒ½æ±‚å‡ºæ¥ã€‚ æ¨¡æ¿ã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int a, b; void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a%b, y, x); y -= a / b * x; &#125; int main(void) &#123; a = read(), b = read(); int x, y; exgcd(a, b, x, y); // x æ˜¯ a åœ¨æ¨¡ b æ„ä¹‰ä¸‹çš„é€†å…ƒ printf(\"%d\\n\", (x % b + b) % b); return 0; &#125; ç”±æ­¤ä¹Ÿå¯çœ‹å‡ºï¼Œä¸€ä¸ªæ•°å¾€å¾€æœ‰ä¸åªä¸€ä¸ªé€†å…ƒï¼Œå› ä¸ºåŒä½™æ–¹ç¨‹çš„è§£ä¸æ­¢ä¸€ä¸ªï¼Œä¸è¿‡æˆ‘ä»¬åªç”¨é‚£ä¸ªæœ€å°çš„æ­£çš„å³å¯ã€‚ çº¿æ€§æ±‚é€†å…ƒ è¿™ä¸ªé—®é¢˜æœ‰ä¸¤ç§å½¢å¼ï¼Œæˆ‘ä»¬åˆ†å¼€æ¥çœ‹ï¼š é€’æ¨é€†å…ƒä»»æ„é€†å…ƒæ¨¡æ¿ã€‚ æ±‚å‡º 1,2,â‹¯ ,n1,2,\\cdots,n1,2,â‹¯,n ä¸­æ¯ä¸ªæ•°å…³äº mmm çš„é€†å…ƒï¼Œä¸” mmm ä¸ºè´¨æ•°ã€‚ æ±‚ iâˆ’1i^{-1}iâˆ’1ï¼Œè¿™ä¹ˆå¹²ï¼š k=âŒŠmiâŒ‹,j=m mod i,âˆ´ m=ki+jâŸ¹ki+jâ‰¡0(modm)âŸ¹kjâˆ’1+iâˆ’1â‰¡0(modm)ï¼ˆä¸¤è¾¹åŒä¹˜ iâˆ’1Ã—jâˆ’1ï¼‰âŸ¹iâˆ’1â‰¡âˆ’kjâˆ’1(modm)âŸ¹iâˆ’1â‰¡âˆ’kjâˆ’1(modm)âŸ¹iâˆ’1â‰¡âˆ’âŒŠmiâŒ‹(m mod i)âˆ’1(modm)k=\\left\\lfloor \\cfrac{m}{i}\\right\\rfloor, j=m\\bmod i, \\\\ \\begin{aligned} \\therefore&amp;~m=ki+j \\\\ \\Longrightarrow&amp; ki+j \\equiv 0 \\pmod m\\\\ \\Longrightarrow&amp; kj^{-1}+i^{-1}\\equiv 0 \\pmod m ï¼ˆä¸¤è¾¹åŒä¹˜~i^{-1}\\times j^{-1}ï¼‰\\\\ \\Longrightarrow&amp; i^{-1}\\equiv -kj^{-1} \\pmod m\\\\ \\Longrightarrow&amp; i^{-1}\\equiv -kj^{-1} \\pmod m\\\\ \\Longrightarrow&amp; i^{-1}\\equiv -{\\left\\lfloor \\cfrac{m}{i}\\right\\rfloor}\\left(m\\bmod i\\right)^{-1} \\pmod m \\end{aligned} k=âŒŠimâ€‹âŒ‹,j=mmodi,âˆ´âŸ¹âŸ¹âŸ¹âŸ¹âŸ¹â€‹ m=ki+jki+jâ‰¡0(modm)kjâˆ’1+iâˆ’1â‰¡0(modm)ï¼ˆä¸¤è¾¹åŒä¹˜ iâˆ’1Ã—jâˆ’1ï¼‰iâˆ’1â‰¡âˆ’kjâˆ’1(modm)iâˆ’1â‰¡âˆ’kjâˆ’1(modm)iâˆ’1â‰¡âˆ’âŒŠimâ€‹âŒ‹(mmodi)âˆ’1(modm)â€‹ è¿™ä¾¿æ˜¯é€†å…ƒçš„é€’æ¨å…¬å¼äº†ï¼Œç„¶è€Œè¿™æ ·å¾—å‡ºçš„é€†å…ƒæ˜¯ä¸ªè´Ÿæ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ç»™ âˆ’âŒŠmiâŒ‹-\\left\\lfloor \\cfrac{m}{i}\\right\\rfloorâˆ’âŒŠimâ€‹âŒ‹ åŠ ä¸Š mmmï¼Œæ¨¡æ¿é¢˜ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, p; int inv[3000005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); inv[1] = 1; // inv[1] = 1 for (int i = 2; i &lt;= n; ++i) inv[i] = (long long)(p - p / i) * inv[p % i] % p; for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", inv[i]); return 0; &#125; æ¨¡æ¿ã€‚ ç»™å®š n(1â‰¤ai&lt;p)n(1\\le a_i &lt; p)n(1â‰¤aiâ€‹&lt;p) ä¸ªæ­£æ•´æ•°ï¼Œæ±‚å®ƒä»¬æ¨¡ ppp æ„ä¹‰ä¸‹çš„é€†å…ƒã€‚ è®¡ç®—å‰ç¼€ç§¯ sssï¼ˆæ¨¡æ„ä¹‰ï¼‰ï¼Œç„¶åè®¡ç®— s[n]s[n]s[n] çš„é€†å…ƒ sinv[n]sinv[n]sinv[n]ã€‚ç”±äº sinv[n]sinv[n]sinv[n] æ˜¯ nnn ä¸ªæ•°ç§¯çš„é€†å…ƒï¼Œä¹Ÿå°±æ˜¯å®ƒç­‰äº 1a1â‹¯an\\cfrac{1}{a_1\\cdots a_n}a1â€‹â‹¯anâ€‹1â€‹ï¼Œå†ä¹˜ä¸Šå‰ç¼€å’Œåç¼€å°±å¯ä»¥å¾—åˆ°å½“å‰çš„é€†å…ƒäº†ã€‚ æ—¶é—´å¤æ‚åº¦ O(n+logâ¡p)\\mathcal{O}(n+\\log p)O(n+logp)ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, p, k; int a[5000005], sp[5000005], sf[5000005], inv; int poww(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % p; a = 1ll * a * a % p; b >>= 1; &#125; return res; &#125; int main(void) &#123; n = read(), p = read(), k = read(); sp[0] = 1, sf[n + 1] = 1; for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= n; ++i) sp[i] = 1ll * sp[i - 1] * a[i] % p; for (int i = n; i >= 1; --i) sf[i] = 1ll * sf[i + 1] * a[i] % p; inv = poww(sp[n], p - 2); int tmp = 1, ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + 1ll * inv * sp[i - 1] % p * sf[i + 1] % p * (tmp = 1ll * tmp * k % p)) % p; printf(\"%d\\n\", ans); return 0; &#125; å®æ•°å–æ¨¡ ä¹‹å‰å¬è¯´è¿‡æ•´æ•°å–ä½™è¿ç®—ï¼Œä½†æ˜¯æƒ³ä¸åˆ°å®æ•°éƒ½å¯ä»¥å–ä½™ï¼Ÿæˆ‘ä»¬ä¸€ä¸€æ¥çœ‹ã€‚ æœ‰ç†æ•°å–ä½™ å¦‚æœ xâ‰¡ab(modp)x\\equiv \\cfrac{a}{b}\\pmod pxâ‰¡baâ€‹(modp)ï¼Œé‚£ä¹ˆä¸¤è¾¹åŒä¹˜ bbb å¾— bxâ‰¡a(modp)bx\\equiv a \\pmod pbxâ‰¡a(modp)ã€‚è¿™ä¸å°±æ˜¯ä¹‹å‰è®²è¿‡å¾—åŒä½™æ–¹ç¨‹å—ï¼Ÿ è™½ç„¶é—®é¢˜å·²ç»è§£å†³ï¼Œä½†æ˜¯è¿˜è¦é—®ä¸€å¥ï¼Œä»€ä¹ˆæ—¶å€™æ— è§£ï¼Ÿæ˜¾ç„¶æ˜¯ aaa ä¸ä¸º (b,p)(b,p)(b,p) çš„å€æ•°ï¼ˆåŒä½™æ–¹ç¨‹çš„ç»“è®ºï¼‰ï¼Œä½†æ˜¯æˆ‘ä»¬è‚¯å®šæƒ³è¦æœ€ç®€åˆ†æ•°ï¼Œæ­¤æ—¶ç”±äº b&lt;pb&lt;pb&lt;pï¼ˆå…ˆå–æ¨¡ï¼‰ï¼ŒåŠ ä¸Š aâŠ¥ba\\perp baâŠ¥bï¼Œæ˜¾ç„¶å½“ (b,p)â‰ 1(b,p)\\ne 1(b,p)î€ =1 çš„æ—¶å€™æ— è§£ã€‚ æœ‰æ²¡æœ‰å‘ç°ï¼Œè¿™å°±æ˜¯æ±‚é€†å…ƒçš„è¿‡ç¨‹ï¼Ÿçš„ç¡®å¦‚æ­¤ï¼Œå› ä¸ºé€†å…ƒå¹²çš„äº‹å°±æ˜¯æœ‰ç†æ•°å–ä½™ã€‚ æ¨¡æ¿ï¼Œæ³¨æ„åˆ†å­åˆ†æ¯å¾ˆå¤§ï¼Œæ‰€ä»¥è¯»å…¥æ—¶å°±è¦å–æ¨¡ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const int MOD = 19260817; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48); x %= MOD; c = getchar(); &#125; return x; &#125; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; void exgcd(int a, int b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, y, x); y -= a / b * x; &#125; int main(void) &#123; int a, b, g; i64 x, y; // æ³¨æ„è¦å¼€ long long a = read(), b = read(); g = gcd(b, MOD); if (g == 1) &#123; exgcd(b, MOD, x, y); x *= a / gcd(b, MOD); // ä¹˜ä¸Šå€æ•° printf(\"%d\\n\", (x % MOD + MOD) % MOD); &#125; else puts(\"Angry!\"); return 0; &#125; æ— ç†æ•°å–ä½™ å¦‚æœæœ‰ç†æ•° aaa æ»¡è¶³ akâ‰¡b(modp)a^k\\equiv b \\pmod pakâ‰¡b(modp)ï¼Œé‚£ä¹ˆæœ‰ aâ‰¡bk(modp)a\\equiv \\sqrt[k]{b} \\pmod paâ‰¡kbâ€‹(modp)ï¼ˆæ ¹æ®åˆšæ‰çš„ç»éªŒï¼‰ã€‚å½“ç„¶ï¼Œä¹Ÿæœ‰å¾ˆå¤§å¯èƒ½æ— è§£ã€‚ è¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡ç®€å•æšä¸¾æ¥è·å–ç­”æ¡ˆï¼Œä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; i64 b, k, p; inline i64 power(i64 x, i64 y) &#123; i64 res = 1; while (y) &#123; if (y &amp; 1) res = res * x % p; x = x * x % p; y >>= 1; &#125; return res; &#125; int main(void) &#123; scanf(\"%lld%lld%lld\", &amp;b, &amp;k, &amp;p); for (i64 i = 1; i &lt;= p; ++i) // è¶…è¿‡ p æ²¡æœ‰æ„ä¹‰ï¼ˆæˆå¾ªç¯äº†ï¼‰ if (power(i, k) == b) printf(\"%d\\n\", i); return 0; &#125; é«˜æ•ˆæ±‚è§£è¿™ä¸ªé—®é¢˜éå¸¸å›°éš¾ï¼Œéœ€è¦ä½¿ç”¨äºŒæ¬¡å‰©ä½™æˆ–è€… N æ¬¡å‰©ä½™ï¼Œå°†åœ¨ã€Šæ•°è®ºè¿›é˜¶ã€‹ä¸­è®²è§£ã€‚ å…‰é€Ÿå¹‚ ç»™å®š a,ca,ca,cï¼Œæ¯æ¬¡è¯¢é—®ç»™å‡º bbbï¼Œå…‰é€Ÿæ±‚å‡º ab mod ca^b \\bmod cabmodcï¼ŒO(c)\\mathcal{O}(\\sqrt{c})O(câ€‹) é¢„å¤„ç†ï¼ŒO(1)\\mathcal{O}(1)O(1) æŸ¥è¯¢ã€‚ è¿˜è®°å¾—æ‰©å±•æ¬§æ‹‰å®šç†å—ï¼Ÿå°±æ˜¯è¿™ä¸ªï¼š abâ‰¡{ab mod Ï†(p),aâŠ¥p,ab,(a,p)â‰ 1,b&lt;Ï†(p),ab mod Ï†(p)+Ï†(p),(a,b)â‰ 1,bâ‰¥Ï†(p).(modp)a^{b}\\equiv \\begin{cases} a^{b\\bmod\\varphi(p)}, &amp;a\\perp p,\\\\ a^b, &amp;(a,p)\\neq 1,b&lt;\\varphi(p),\\\\ a^{b\\bmod\\varphi(p)+\\varphi(p)}, &amp;(a,b)\\neq 1,b\\ge\\varphi(p). \\end{cases} \\pmod p abâ‰¡â©â¨â§â€‹abmodÏ†(p),ab,abmodÏ†(p)+Ï†(p),â€‹aâŠ¥p,(a,p)î€ =1,b&lt;Ï†(p),(a,b)î€ =1,bâ‰¥Ï†(p).â€‹(modp) æˆ‘ä»¬è¯´è¿‡å¯ä»¥ç”¨äºŒå¼ä¸‰å¼è¿›è¡Œé™å¹‚ï¼Œäºæ˜¯æˆ‘ä»¬å°±å¯ä»¥å°† bbb ç¼©å°åˆ° 2Ã—Ï†(c)2\\times \\varphi(c)2Ã—Ï†(c) çš„èŒƒå›´ä»¥å†…ï¼ˆä¹Ÿå°±æ˜¯ 2c2c2c ä»¥å†…ï¼‰ã€‚ç„¶åæˆ‘ä»¬å¯ä»¥è¿™æ ·æ¨ï¼šab=acÃ—âŒŠbcâŒ‹+b mod c=(ac)âŒŠbcâŒ‹Ã—ab mod ca^b=a^{\\sqrt{c}\\times \\lfloor\\frac{b}{\\sqrt{c}}\\rfloor+b\\bmod \\sqrt{c}}=(a^{\\sqrt{c}})^{\\lfloor\\frac{b}{\\sqrt{c}}\\rfloor}\\times a^{b\\bmod \\sqrt{c}}ab=acâ€‹Ã—âŒŠcâ€‹bâ€‹âŒ‹+bmodcâ€‹=(acâ€‹)âŒŠcâ€‹bâ€‹âŒ‹Ã—abmodcâ€‹ã€‚å…¶ä¸­ âŒŠbcâŒ‹&lt;2c\\lfloor\\frac{b}{\\sqrt{c}}\\rfloor&lt;2\\sqrt{c}âŒŠcâ€‹bâ€‹âŒ‹&lt;2câ€‹ï¼ˆæƒ³ä¸€æƒ³åˆšæ‰ ccc çš„èŒƒå›´ï¼Œb mod c&lt;cb\\bmod \\sqrt{c} &lt; \\sqrt{c}bmodcâ€‹&lt;câ€‹ã€‚ äºæ˜¯é¢„å¤„ç† (ac)i,aj(1â‰¤i&lt;2c,1â‰¤j&lt;c)(a^{\\sqrt{c}})^i,a^j(1\\le i &lt; 2\\sqrt{c},1\\le j&lt;\\sqrt{c})(acâ€‹)i,aj(1â‰¤i&lt;2câ€‹,1â‰¤j&lt;câ€‹) å³å¯ã€‚é¢„å¤„ç†æ—¶é—´å¤æ‚åº¦ O(c)\\mathcal{O}(\\sqrt{c})O(câ€‹)ï¼ŒåŒ…æ‹¬å¤„ç†æ¬§æ‹‰å‡½æ•°çš„æ—¶é—´ã€‚ ä»£ç å¦‚ä¸‹ï¼Œå¯ä»¥é€šè¿‡æ¨¡æ¿ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; using i64 = long long; const int P = 998244352; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int a, b, T, t, phi; int fac[1000005], facp[2000005]; void calcPhi(int n) &#123; int ans = n, t = sqrt(n + 0.5); for (int i = 2; i &lt;= t; ++i) if (n % i == 0) &#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; if (n > 1) ans = ans / n * (n - 1); phi = ans; &#125; void init(void) &#123; a %= P; // ä¸€èˆ¬æ¥è®²ï¼Œæ­¤è¡Œæ˜¯å¿…è¦çš„ t = sqrt(P + 0.5); fac[0] = facp[0] = 1; for (int i = 1; i &lt;= t; ++i) fac[i] = (i64)fac[i - 1] * a % P; // é¢„å¤„ç† a^i for (int i = 1; i &lt;= t &lt;&lt; 1; ++i) facp[i] = (i64)facp[i - 1] * fac[t] % P; // é¢„å¤„ç† (a^sqrt(c))^i calcPhi(P); // è®¡ç®— c çš„æ¬§æ‹‰å‡½æ•°ä»¥é™å¹‚ &#125; inline int calc(int b) &#123; return (i64)facp[b / t] * fac[b % t] % P; &#125; int main(void) &#123; a = read(), T = read(); init(); while (T--) &#123; b = read(); if (b >= phi) b = b % phi + phi; // åˆ©ç”¨æ‰©å±•æ¬§æ‹‰å®šç†ä¸‰å¼é™å¹‚ printf(\"%d \", calc(b)); &#125; putchar('\\n'); return 0; &#125; å…‰é€Ÿå¹‚çš„è¿™ä¸ª t ä¸ä¸€å®šéæ˜¯ç®—æ•°å¹³æ–¹æ ¹ï¼Œå–ä¸€ä¸ªè¾ƒå¿«çš„å€¼å°±è¡Œã€‚ å½“ç„¶ï¼Œä½ è¿˜å¯ä»¥åˆ©ç”¨è¿™ä¸ªåŸç†æ•´ä¸ªçŸ©é˜µå…‰é€Ÿå¹‚ï¼Œè¿™é‡Œå°±ä¸è¯´äº†ã€‚ ä¸­å›½å‰©ä½™å®šç†ï¼ˆCRTï¼‰ è¿™èµ·æºäºä¸€ä¸ªå«åšéŸ©ä¿¡ç‚¹å…µçš„æ•…äº‹ã€‚ç›¸ä¼ éŸ©ä¿¡ç‚¹ä»–æ•°é‡å·¨å¤§çš„å…µï¼Œç„¶åå®åœ¨æ˜¯æ•°ä¸è¿‡æ¥ï¼Œäºæ˜¯å°±è®©æ¯ä¸‰ä¸ªç»„æˆä¸€é˜Ÿçœ‹ä½™æ•°ï¼Œæ¯äº”ä¸ªç»„æˆä¸€é˜Ÿçœ‹ä½™æ•°ï¼Œæ¯ä¸ƒä¸ªç»„æˆä¸€é˜Ÿçœ‹ä½™æ•°ï¼Œç„¶åå°±ç®—å‡ºæ¥æ€»äººæ•°äº†ã€‚ äº’è´¨æƒ…å†µ æ¨¡æ¿ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦è§£å†³æ¨ªçº¿æ€§åŒä½™æ–¹ç¨‹ç»„ï¼Œä¿è¯æ¨¡æ•°ä¸¤ä¸¤äº’è´¨ï¼š {xâ‰¡a1(modm1)xâ‰¡a2(modm2)â‹¯xâ‰¡a3(modm3)\\begin{cases} x\\equiv a_1 \\pmod {m_1}\\\\ x\\equiv a_2 \\pmod {m_2}\\\\ \\cdots\\\\ x\\equiv a_3 \\pmod {m_3}\\\\ \\end{cases} â©â¨â§â€‹xâ‰¡a1â€‹(modm1â€‹)xâ‰¡a2â€‹(modm2â€‹)â‹¯xâ‰¡a3â€‹(modm3â€‹)â€‹ è®¾ M=âˆi=1nmi,Mi=mÃ·miM=\\prod_{i=1}^{n}m_i,M_i=m\\div m_iM=âˆi=1nâ€‹miâ€‹,Miâ€‹=mÃ·miâ€‹ï¼Œtit_itiâ€‹ æ˜¯çº¿æ€§åŒä½™æ–¹ç¨‹ Mitiâ‰¡1(modmi)M_it_i\\equiv 1 \\pmod{m_i}Miâ€‹tiâ€‹â‰¡1(modmiâ€‹) çš„ä¸€ä¸ªè§£ï¼Œä¹Ÿå°±æ˜¯è¯´ tit_itiâ€‹ æ˜¯ MiM_iMiâ€‹ æ¨¡ mim_imiâ€‹ çš„é€†å…ƒï¼ˆæ˜¾ç„¶ MiâŠ¥miM_i \\perp m_iMiâ€‹âŠ¥miâ€‹ å½“ä¸”ä»…å½“ mim_imiâ€‹ ä¸¤ä¸¤äº’è´¨ï¼‰ï¼Œé‚£ä¹ˆ x=âˆ‘i=1naiMiti+kMx=\\sum_{i=1}^{n}a_iM_it_i + kMx=âˆ‘i=1nâ€‹aiâ€‹Miâ€‹tiâ€‹+kMï¼Œæœ€å°éè´Ÿæ•´æ•°è§£éœ€è¦æ±‚ âˆ‘i=1naiMiti mod M\\sum_{i=1}^{n}a_iM_it_i\\bmod Mâˆ‘i=1nâ€‹aiâ€‹Miâ€‹tiâ€‹modMã€‚ ä¸ºä»€ä¹ˆè¿™æ˜¯æ­£ç¡®çš„å‘¢ï¼Ÿç”±äº Mitiâ‰¡1(modmi)M_it_i\\equiv 1 \\pmod{m_i}Miâ€‹tiâ€‹â‰¡1(modmiâ€‹)ï¼Œæ‰€ä»¥ aiMitiâ‰¡ai(modmi)a_iM_it_i \\equiv a_i \\pmod{m_i}aiâ€‹Miâ€‹tiâ€‹â‰¡aiâ€‹(modmiâ€‹)ã€‚ è€Œä¸” Mj=âˆiâ‰ jmiM_j=\\prod_{i\\ne j}m_iMjâ€‹=âˆiî€ =jâ€‹miâ€‹ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹äº âˆ€iâ‰ j,miâˆ£Mj\\forall i\\ne j, m_i\\mid M_jâˆ€iî€ =j,miâ€‹âˆ£Mjâ€‹ï¼Œæ‰€ä»¥ ajtjMjâ‰¡0(modmi)a_jt_jM_j\\equiv 0\\pmod{m_i}ajâ€‹tjâ€‹Mjâ€‹â‰¡0(modmiâ€‹)ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œå¯ä»¥æ¨æ–­å‡º xâ‰¡âˆ‘j=1najMjtj+kMâ‰¡ai+âˆ‘j=1,jâ‰ in0+0â‰¡ai(modmi)x\\equiv \\sum_{j=1}^{n} a_{j} M_{j} t_{j} + kM \\equiv a_i+\\sum_{j=1,j\\ne i}^{n} 0 +0\\equiv a_{i} \\pmod{m_i}xâ‰¡âˆ‘j=1nâ€‹ajâ€‹Mjâ€‹tjâ€‹+kMâ‰¡aiâ€‹+âˆ‘j=1,jî€ =inâ€‹0+0â‰¡aiâ€‹(modmiâ€‹)ã€‚ æˆ‘ä»¬ä¸€ä¸ªä¸€ä¸ªçš„æ¥è§£é‡Šã€‚xâ‰¡âˆ‘j=1najMjtj+kM(modmi)x\\equiv \\sum_{j=1}^{n} a_{j} M_{j} t_{j} + kM\\pmod{m_i}xâ‰¡âˆ‘j=1nâ€‹ajâ€‹Mjâ€‹tjâ€‹+kM(modmiâ€‹) æ˜¯æ˜¾ç„¶çš„ï¼Œå› ä¸ºè¿™è¿ä¸ªç©æ„ç›¸ç­‰ï¼›âˆ‘j=1najMjtj+kMâ‰¡ai+âˆ‘j=1,jâ‰ in0+0(modmi)\\sum_{j=1}^{n} a_{j} M_{j} t_{j} + kM \\equiv a_i+\\sum_{j=1,j\\ne i}^{n} 0 +0\\pmod{m_i}âˆ‘j=1nâ€‹ajâ€‹Mjâ€‹tjâ€‹+kMâ‰¡aiâ€‹+âˆ‘j=1,jî€ =inâ€‹0+0(modmiâ€‹)ï¼Œè¿™æ˜¯å› ä¸ºé™¤äº† j=ij=ij=i ä»¥å¤–ï¼ŒajtjMjâ‰¡0(modmi)a_jt_jM_j\\equiv 0\\pmod{m_i}ajâ€‹tjâ€‹Mjâ€‹â‰¡0(modmiâ€‹)ï¼Œè€Œå½“ j=ij=ij=i æ—¶ï¼ŒaiMitiâ‰¡ai(modmi)a_iM_it_i \\equiv a_i \\pmod{m_i}aiâ€‹Miâ€‹tiâ€‹â‰¡aiâ€‹(modmiâ€‹)ï¼Œè€Œä¸”æ˜¾ç„¶ kMâ‰¡0(modmi)kM\\equiv 0\\pmod{m_i}kMâ‰¡0(modmiâ€‹)ï¼Œè¿›è€Œè¿™ä¸ª ai+âˆ‘j=1,jâ‰ in0+0=aia_i+\\sum_{j=1,j\\ne i}^{n} 0 +0=a_iaiâ€‹+âˆ‘j=1,jî€ =inâ€‹0+0=aiâ€‹ã€‚ #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; void exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a % b, y, x); y -= a / b * x; &#125; int n; i64 mm = 1; i64 m[15], a[15], M[15], t[15]; i64 CRT(void) &#123; i64 ans = 0, x; for (int i = 1; i &lt;= n; ++i) &#123; M[i] = mm / m[i]; exgcd(M[i], m[i], t[i], x); // t[i] ä¸º M[i] æ¨¡ m[i] æ„ä¹‰ä¸‹çš„é€†å…ƒ ans = (ans + a[i] * M[i] * t[i]) % mm; &#125; return (ans % mm + mm) % mm; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", m + i, a + i); mm *= m[i]; &#125; printf(\"%lld\\n\", CRT()); return 0; &#125; exCRT ä¹‹å‰çš„æ¨¡æ•°æ˜¯ä¸¤ä¸¤äº’è´¨çš„ï¼Œä½†å¦‚æœæ˜¯ä»»æ„çš„æ€ä¹ˆåŠï¼Ÿæ¨¡æ¿ã€‚ ç”±äº CRT ç®—æ³•ä¸­ MiM_iMiâ€‹ è¿™ä¸€å¥‡æ€ªçš„å­˜åœ¨ï¼Œå¯¼è‡´æ¨¡æ•°ä»»æ„çš„æ—¶å€™é€†å…ƒä¸å­˜åœ¨ï¼Œä¹Ÿå°±æ˜¯è¯´ CRT çš„ä¸€åˆ‡éƒ½å·²ç»ä¸å†ä½¿ç”¨ï¼Œæˆ‘ä»¬éœ€è¦è®¾è®¡ä¸€ç§æ–°çš„ç®—æ³•ã€‚ æ€è·¯å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼šæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹å¼ï¼Œèƒ½å°†ä¸¤ä¸ªåŒä½™æ–¹ç¨‹è¿›è¡Œåˆå¹¶ã€‚å½¢å¼åŒ–åœ°ï¼š {aâ‰¡r1(modm1)aâ‰¡r2(modm2)\\begin{cases} a\\equiv r_1 \\pmod{m_1}\\\\ a\\equiv r_2 \\pmod{m_2} \\end{cases} {aâ‰¡r1â€‹(modm1â€‹)aâ‰¡r2â€‹(modm2â€‹)â€‹ æˆ‘ä»¬å…ˆå‡å®šä¸€å®šå¯ä»¥åˆå¹¶ï¼Œç„¶åçœ‹çœ‹ä»€ä¹ˆæ—¶å€™åˆå¹¶ä¹‹åçš„è§£æ˜¯ âˆ…\\varnothingâˆ…ã€‚ è¿™ç©æ„å„¿ç­‰ä»·äº a=k1m1+r1=k2m2+r2âŸ¹k1m1âˆ’k2m2=r2âˆ’r1a=k_1m_1+r_1=k_2m_2+r_2 \\Longrightarrow k_1m_1-k_2m_2=r_2-r_1a=k1â€‹m1â€‹+r1â€‹=k2â€‹m2â€‹+r2â€‹âŸ¹k1â€‹m1â€‹âˆ’k2â€‹m2â€‹=r2â€‹âˆ’r1â€‹ã€‚è¿™ä¸ªç†Ÿæ‚‰ï¼äºŒå…ƒä¸€æ¬¡ä¸å®šæ–¹ç¨‹ï¼ç›´æ¥ä½¿ç”¨ exgcd è®¡ç®—å³å¯ã€‚ äºæ˜¯ï¼š å¦‚æœ gcdâ¡(m1,m2)âˆ£(r2âˆ’r1)\\gcd(m_1,m_2)\\mid (r_2-r_1)gcd(m1â€‹,m2â€‹)âˆ£(r2â€‹âˆ’r1â€‹)ï¼Œé‚£ä¹ˆå¯ä»¥åˆå¹¶ï¼› å¦åˆ™ï¼ŒexCRT æ˜¯æ— è§£çš„ã€‚ ç°åœ¨æœ‰å¼•ç†ï¼šåˆå¹¶ä¹‹åçš„æ¨¡æ•°æ˜¯åŸæ¥ä¸¤ä¸ªæ¨¡æ•°çš„ lcmã€‚è¿™é‡Œä¸åšè¯æ˜ã€‚æ‰€ä»¥è¦æ³¨æ„ï¼Œéœ€è¦ä¿è¯æ‰€æœ‰æ•°çš„æœ€å°å…¬å€æ•°æ˜¯å¯ä»¥å­˜çš„ä¸‹çš„ï¼Œå¦åˆ™ä¸å¯ä»¥ä½¿ç”¨ exCRTï¼ å®é™…ä¸Šæ™®é€š CRT ä¹Ÿéœ€è¦æ»¡è¶³è¿™ä¸€ç‚¹ï¼Œå¦åˆ™ CRT åœ¨ä¸€å®šèŒƒå›´å†…æ— è§£ã€‚ ä¸‹é¢æ˜¯å®ç°è¿‡ç¨‹ï¼šè®¾å½“å‰åˆå¹¶çš„ä½™æ•°ä¸º MMMï¼Œå½“å‰ç­”æ¡ˆä¸º ansansansï¼Œé‚£ä¹ˆä»»æ„ä¸€ä¸ª ans+Mxans+Mxans+Mx éƒ½æ»¡è¶³ç­”æ¡ˆï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ä¸ªæœ€å°çš„ä½¿å¾— ans+Mxâ‰¡a(modp)ans+Mx\\equiv a\\pmod pans+Mxâ‰¡a(modp)ï¼Œå¯ä»¥ä½¿ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—æ¥è§£å†³ã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; i64 exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, a; i64 g = exgcd(b, a % b, y, x); y -= a / b * x; return g; &#125; int n; i64 A[1000005], B[1000005]; i64 exCRT(void) &#123; i64 M = 1, ans = 0; // M ä¸ºå½“å‰åˆå¹¶çš„æ¨¡æ•°ï¼Œans ä¸ºå½“å‰ç­”æ¡ˆ for (int i = 1; i &lt;= n; ++i) &#123; i64 a = M, b = B[i], x, y, c = (A[i] - ans + b) % b; i64 g = exgcd(a, b, x, y); // Mx + by = gcd(M, b) if (c % g != 0) return -1; x = (__int128)x * (c / g) % (b / g); ans = ans + M * x; M = b / g * M; ans = (ans % M + M) % M; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld%lld\", B + i, A + i); printf(\"%lld\\n\", exCRT()); return 0; &#125; Problemset è‡³æ­¤ï¼ŒåŸºç¡€æ•°è®ºçš„çŸ¥è¯†å·²ç»å…¨éƒ¨ä»‹ç»å®Œæ¯•ã€‚ç†è®ºä¸Šè¿™äº›å†…å®¹å·²èƒ½è§£å†³ OI ä¸­å¤§éƒ¨åˆ† NOIp çº§åˆ«ä»¥å†…çš„æ•°è®ºé¢˜ç›®ï¼ˆä¸€äº›è¾ƒéš¾çš„çœé€‰çº§åˆ«çš„çŸ¥è¯†ç‚¹çš„è¯·å‚è€ƒã€Šæ•°è®ºè¿›é˜¶ã€‹ï¼‰ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸€äº›åŸºç¡€æ•°è®ºçš„é¢˜ç›®ï¼š ç®€å•æ•°å­¦ è¿™äº›æ•°å­¦é—®é¢˜éƒ½æ˜¯åŸºç¡€çŸ¥è¯†çš„ç®€å•åº”ç”¨ã€‚åŒ…æ‹¬å„ç§åŸºç¡€çŸ¥è¯†å’Œç´ æ•°ç­›æ³•ã€‚ [UVA10780] Again Prime? No Time. Portal. ä½¿ç”¨å”¯ä¸€åˆ†è§£å®šç†æ¥è¿›è¡Œåˆ¤æ–­å³å¯ï¼Œéœ€è¦é¢„å¤„ç†å‡ºç´ æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int prime[10005], tot = 0; bool v[10005]; void GetPrime(void) &#123; for (int i = 2; i &lt;= 10000; ++i) if (!v[i]) &#123; prime[++tot] = i; for (int j = i * 2; j &lt;= 10000; j += i) v[j] = true; &#125; &#125; int A[10005], B[10005]; int main(void) &#123; GetPrime(); int T, n, m; scanf(\"%d\", &amp;T); for (int kase = 1; kase &lt;= T; ++kase) &#123; scanf(\"%d%d\", &amp;m, &amp;n); printf(\"Case %d:\\n\", kase); memset(A, 0, sizeof(A)); memset(B, 0, sizeof(B)); for (int i = 1; i &lt;= tot; ++i) &#123; for (int j = prime[i]; j &lt;= n; j *= prime[i]) A[i] += n / j; &#125; for (int i = 1; i &lt;= tot; ++i) while (m % prime[i] == 0) &#123; m /= prime[i]; ++B[i]; &#125; bool flag = true; int k = 2e9; for (int i = 1; i &lt;= tot; ++i) &#123; if (A[i] &lt; B[i]) &#123; flag = false; break; &#125; else if (B[i] != 0) k = min(k, A[i] / B[i]); &#125; if (!flag) puts(\"Impossible to divide\"); else printf(\"%d\\n\", k); &#125; return 0; &#125; [UVA10892] LCM Cardinality Portal. å”¯ä¸€åˆ†è§£å®šç†ï¼å°† nnn è¿›è¡Œè´¨å› æ•°åˆ†è§£ï¼Œç„¶ååˆ©ç”¨å”¯ä¸€åˆ†è§£å®šç†ä¸­æœ€å°å…¬å€æ•°çš„æ€§è´¨ï¼Œè®©å…¶ä¸­ä¸€ä¸ªæ•°ç­‰äºåˆ†è§£åçš„æŒ‡æ•°ï¼Œå¦ä¸€ä¸ªå°±å¯ä»¥éšä¾¿å–äº†ã€‚æ ¹æ®ä¹˜æ³•åŸç†ç­”æ¡ˆå°±æ˜¯ âˆciÃ—2+1\\prod c_i\\times 2 + 1âˆciâ€‹Ã—2+1ï¼Œä½†æ˜¯è¿™æ ·ä¼šç®—é‡å¤ï¼Œéœ€è¦é™¤ä»¥äºŒåœ¨åŠ ä¸Šä¸€ï¼ˆæœ‰ä¸€ç»„æ²¡æœ‰é‡å¤ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; int main(void) &#123; int n, kase = 0; while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; static int C[2005]; memset(C, 0, sizeof(C)); int tot = 0, nn = n; for (int i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; ++tot; while (n % i == 0) n /= i, C[tot]++; &#125; if (n > 1) C[++tot] = 1; i64 ans = 1; for (int i = 1; i &lt;= tot; ++i) ans *= C[i] * 2 + 1; printf(\"%d %lld\\n\", nn, ans / 2 + 1); &#125; return 0; &#125; [UVA11752] The Super Powers Portal. å¯ä»¥å‘ç°ä¸€å®šæ˜¯æŸä¸ªæ•°çš„åˆæ•°æ¬¡æ–¹å¹‚ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥æšä¸¾äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; typedef unsigned long long u64; const u64 MAXN = 18446744073709551615ull; int vis[70000]; vector &lt;u64> v; int main(void) &#123; for (int i = 2; i * i &lt;= 69000; ++i) if (!vis[i]) &#123; for (int j = i * 2; j &lt;= 69000; j += i) vis[j] = true; &#125; v.push_back(1); for (int i = 2; i &lt; 65536; ++i) &#123; u64 tmp = 1ull * i * i * i * i; for (int j = 4;; ++j) &#123; if (vis[j]) v.push_back(tmp); if (tmp &lt;= MAXN / i) tmp = tmp * i; else break; &#125; &#125; sort(v.begin(), v.end()); int m = unique(v.begin(), v.end()) - v.begin(); for (int i = 0; i &lt; m; ++i) printf(\"%llu\\n\", v[i]); return 0; &#125; [HAOI2007] åç´ æ•° Portal. æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œ1âˆ¼n1\\sim n1âˆ¼n ä¸­çº¦æ•°æœ€å¤šçš„æ•°ä¸­æœ€å°çš„ä¸€ä¸ª mmmï¼Œä¾¿æ˜¯ 1âˆ¼n1\\sim n1âˆ¼n ä¸­æœ€å¤§çš„åç´ æ•°ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæ ¹æ® mmm çš„å®šä¹‰ï¼Œæ˜¾ç„¶æœ‰ âˆ€x&lt;m,g(x)&lt;g(m);âˆ€x&gt;m,g(x)â‰¤g(m)\\forall x&lt;m, g(x)&lt;g(m); \\forall x&gt;m,g(x)\\le g(m)âˆ€x&lt;m,g(x)&lt;g(m);âˆ€x&gt;m,g(x)â‰¤g(m)ï¼Œå‰è€…è¯´æ˜ mmm æ˜¯åç´ æ•°ï¼Œè€Œåè€…è¯´æ˜å¤§äºå¤§äº mmm çš„æ•°éƒ½ä¸æ˜¯åç´ æ•°ã€‚ è®¡ç®—ä¸€ä¸‹å¯ä»¥çŸ¥é“ï¼Œ1âˆ¼n1\\sim n1âˆ¼n çš„ä»»ä½•æ•°çš„ä¸åŒè´¨å› å­ä¸ä¼šè¶…è¿‡ 101010 ä¸ªï¼Œè€Œä¸”å®ƒä»¬çš„è´¨æ•°ä¸è¶…è¿‡ 303030ã€‚ åç´ æ•°åˆ†è§£è´¨å› æ•°åï¼Œè´¨å› å­çš„æŒ‡æ•°ä¸€å®šæ˜¯å•è°ƒé€’å‡çš„ã€‚è¿™ä¸€ç‚¹å¯ä»¥ç”¨åè¯æ³•è¯æ˜ï¼Œåªéœ€è¦æ¢ä¸€ä¸ªè´¨å› å­ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªæ›´å°ä½†æ˜¯çº¦æ•°ä¸ªæ•°ç›¸ç­‰çš„æ•°ã€‚ è¿™æ—¶æœç´¢æ ‘çš„è§„æ¨¡å·²ç»é™åˆ°è¶³å¤Ÿå°ï¼Œç›´æ¥ DFS å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const int PRIME[] = &#123;0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;; const i64 INF = 0x7fffffff; i64 n, ans; int c[15]; int ret; void dfs(int o, i64 res, int cnt) &#123; if (o > 10) &#123; if (cnt > ret || (cnt == ret &amp;&amp; res &lt; ans)) &#123; ans = res; ret = cnt; &#125; return; &#125; i64 res0 = res; for (int i = 0; i &lt;= c[o - 1]; ++i, res0 *= PRIME[o]) &#123; if (res0 > n) return; c[o] = i; dfs(o + 1, res0, cnt * (i + 1)); // æŒ‰ç…§ä¹˜æ³•åŸç†è®¡ç®—çº¦æ•°ä¸ªæ•° &#125; &#125; int main(void) &#123; scanf(\"%lld\", &amp;n); c[0] = INF; dfs(1, 1, 1); printf(\"%lld\\n\", ans); return 0; &#125; å°ä¸“é¢˜é”¦é›† åŒ…æ‹¬ç­›æ³•ï¼Œexgcd ç­‰ã€‚ [NOI2002] è’å²›é‡äºº Portal. é¢˜ç›®çš„è¿™ä¸ªæ¡ä»¶æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿå½¢è±¡åŒ–åœ°ï¼Œå°±æ˜¯å¯¹äºä»»æ„ä¸¤ä¸ªé‡äººï¼Œä½¿å¾—åŒä½™æ–¹ç¨‹ï¼š Ci+xPiâ‰¡Cj+xPj(modM)C_i+xP_i\\equiv C_j+xP_j \\pmod M Ciâ€‹+xPiâ€‹â‰¡Cjâ€‹+xPjâ€‹(modM) æ²¡æœ‰è§£ï¼Œæˆ–è€…ä¸å­˜åœ¨ä¸€ä¸ª xâ‰¤Li,xâ‰¤Ljx\\le L_i,x\\le L_jxâ‰¤Liâ€‹,xâ‰¤Ljâ€‹ çš„è§£ã€‚è¿™ç§é—®é¢˜å·²ç»å¾ˆç†Ÿæ‚‰äº†ï¼Œå°±æ˜¯è¦è½¬åŒ–ä¸º exgcd å¯ä»¥è§£å†³çš„å½¢å¼ï¼Œç„¶åæ±‚å‡ºæœ€å°çš„ xxxï¼Œæ¥çœ‹æ˜¯å¦æœ‰è§£ã€‚ ç§»é¡¹å¾— (Piâˆ’Pj)xâ‰¡Cjâˆ’Ci(modM)(P_i-P_j)x\\equiv C_j-C_i \\pmod M(Piâ€‹âˆ’Pjâ€‹)xâ‰¡Cjâ€‹âˆ’Ciâ€‹(modM)ï¼Œç­‰ä»·äº (Piâˆ’Pj)xâˆ’(Cjâˆ’Ci)=nM(P_i-P_j)x-(C_j-C_i)=nM(Piâ€‹âˆ’Pjâ€‹)xâˆ’(Cjâ€‹âˆ’Ciâ€‹)=nMï¼Œä¹Ÿå°±æ˜¯ (Piâˆ’Pj)xâˆ’nM=Cjâˆ’Ci(P_i-P_j)x-nM=C_j-C_i(Piâ€‹âˆ’Pjâ€‹)xâˆ’nM=Cjâ€‹âˆ’Ciâ€‹ï¼Œä½¿ç”¨ exgcd è®¡ç®—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #define ERROR_WRONG_DATA -1 using namespace std; int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int g = exgcd(b, a % b, y, x); y -= a / b * x; return g; &#125; int n; struct Pockets &#123; int c, p, l; bool operator &lt; (const Pockets &amp;a) const &#123; return c &lt; a.c; &#125; void summer_init(void) &#123; scanf(\"%d%d%d\", &amp;c, &amp;p, &amp;l); &#125; &#125; A[20]; bool check(int m) &#123; for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123; int a = A[i].p - A[j].p, b = m, c = A[j].c - A[i].c, x, y; if (a &lt; 0) a = -a, c = -c; int d = exgcd(a, b, x, y); if (c % d == 0) &#123; int M = m / d; x = x * (c / d); x = (x % M + M) % M; if (x &lt;= A[i].l &amp;&amp; x &lt;= A[j].l) return false; &#125; &#125; return true; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) A[i].summer_init(); sort(A + 1, A + n + 1); for (int m = A[n].c; m &lt;= 1000000; ++m) if (check(m)) &#123; printf(\"%d\\n\", m); return 0; &#125; return ERROR_WRONG_DATA; &#125; [Codefroces 449C] Jzzhu and Apples Portal. ä»å¤§åˆ°å°æ£€æŸ¥æ‰€æœ‰è´¨æ•°ï¼Œæœ‰èƒ½é…å¯¹å°±é…ï¼Œå¥‡æ•°ä¸ªå°±æ‰”æ‰ 2x2x2x ç»™ 222 ç”¨ã€‚è¿™æ ·æœ€åè‡³å¤šåªæœ‰ 111 ä¸ªæ²¡æœ‰é…å¯¹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n; bool v[100005]; int p[50005], tot = 0; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= (n >> 1); ++i) &#123; if (!v[i]) p[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; ++j) &#123; v[i * p[j]] = true; if (i % p[j] == 0) break; &#125; &#125; memset(v, 0, sizeof(v)); vector&lt;pair&lt;int, int> > ans; for (int i = tot; i >= 1; --i) &#123; vector&lt;int> a; for (int j = p[i]; j &lt;= n; j += p[i]) if (!v[j]) a.push_back(j); if (a.size() &amp; 1) &#123; swap(a[1], a[a.size() - 1]); a.pop_back(); &#125; for (int j = 0; j &lt; a.size(); j += 2) &#123; v[a[j]] = v[a[j + 1]] = true; ans.push_back(&#123;a[j], a[j + 1]&#125;); &#125; &#125; printf(\"%d\\n\", ans.size()); for (auto i : ans) printf(\"%d %d\\n\", i.first, i.second); return 0; &#125; æ¬§æ‹‰å‡½æ•° æ¬§æ‹‰å‡½æ•°çš„åº”ç”¨å¾ˆå¤šã€‚ [SDOI2008] ä»ªä»—é˜Ÿ Portalã€‚ é™¤äº† (1,2),(2,1),(2,2)(1,2),(2,1),(2,2)(1,2),(2,1),(2,2) ä¸‰ä¸ªäººå¤–ï¼Œä¸€ä¸ªå€’éœ‰é¬¼ (x,y)(x,y)(x,y) èƒ½è¢«çœ‹åˆ°ï¼Œå½“ä¸”ä»…å½“ 1â‰¤x,yâ‰¤n,xâ‰ y,gcdâ¡(x,y)=11\\le x,y\\le n, x\\neq y, \\gcd(x,y)=11â‰¤x,yâ‰¤n,xî€ =y,gcd(x,y)=1ã€‚ ç”±äºæˆ‘ä»¬ä¸éœ€è¦è€ƒè™‘ x=yx=yx=y çš„æƒ…å†µï¼Œæ‰€ä»¥å¯ä»¥ä»¥ç›´çº¿ x=yx=yx=y æŠŠé˜Ÿä¼åˆ†æˆä¸¤åŠæ¥åšï¼Œå…¶ä¸­ä¸€åŠçš„ç­”æ¡ˆçš„äºŒå€å†åŠ ä¸ŠæŠ›æ‰çš„é‚£ä¸‰ä¸ªå°±æ˜¯æœ€ç»ˆçš„ç­”æ¡ˆã€‚ å¯¹äºæ¯ä¸ª 2â‰¤yâ‰¤n2\\le y\\le n2â‰¤yâ‰¤nï¼Œæˆ‘ä»¬åªéœ€è¦æ±‚å‡ºæœ‰å¤šå°‘ä¸ª xxx æ»¡è¶³ 1â‰¤x&lt;yâˆ§(x,y)=11\\le x &lt; y \\wedge (x,y)=11â‰¤x&lt;yâˆ§(x,y)=1ï¼Œç›¸å½“äº 1â‰¤xâ‰¤y1\\le x \\le y1â‰¤xâ‰¤yï¼Œé‚£ä¹ˆè¿™å°±æ˜¯ Ï†(y)\\varphi(y)Ï†(y)ã€‚ æ‰€ä»¥è¿™é“é¢˜çš„ç­”æ¡ˆå°±æ˜¯ 3+2Ã—âˆ‘i=2nâˆ’1Ï†(i)3+2\\times \\sum\\limits_{i=2}^{n-1} \\varphi(i)3+2Ã—i=2âˆ‘nâˆ’1â€‹Ï†(i)ï¼Œç”¨ç­›æ³•è®¡ç®—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = 3; int phi[40005]; int main(void) &#123; scanf(\"%d\", &amp;n); if (n == 1) &#123; puts(\"0\"); return 0; &#125; for (int i = 1; i &lt; n; ++i) phi[i] = i; for (int i = 2; i &lt; n; ++i) if (phi[i] == i) &#123; for (int j = i; j &lt; n; j += i) phi[j] = phi[j] / i * (i - 1); &#125; for (int i = 2; i &lt; n; ++i) ans += (phi[i] &lt;&lt; 1); printf(\"%d\\n\", ans); return 0; &#125; [SDOI2008] æ²™æ‹‰å…¬ä¸»çš„å›°æƒ‘ Portal.å¤šæ¬¡è¯¢é—® [1,N!][1,N!][1,N!] ä¸­ä¸ M!M!M! äº’è´¨çš„æ•°çš„ä¸ªæ•°ï¼Œç­”æ¡ˆå¯¹ç»™å®šçš„è´¨æ•° RRR å–æ¨¡ã€‚ å¦‚æœè¯´èŒƒå›´æ˜¯ M!M!M! å‘¢ï¼Ÿé‚£ä¹ˆç­”æ¡ˆæ˜¾ç„¶å°±æ˜¯ Ï†(M!)\\varphi(M!)Ï†(M!)ã€‚ ç”±äº (a,b)=a(a,ka+b)(a,b)=a(a, ka+b)(a,b)=a(a,ka+b)ï¼Œä¹Ÿå°±æ˜¯è¯´è‹¥ (M!,a)=1(M!,a)=1(M!,a)=1ï¼Œé‚£ä¹ˆ (M!,a+kÃ—M!)=1(M!,a+k\\times M!)=1(M!,a+kÃ—M!)=1ï¼Œè€Œä¸” Mâ‰¤NâŸ¹M!âˆ£N!M\\le N\\Longrightarrow M!\\mid N!Mâ‰¤NâŸ¹M!âˆ£N!ï¼Œæ‰€ä»¥ Ï†(m!)\\varphi(m!)Ï†(m!) è¿™ç©æ„çš„å‡ºç°æ¬¡æ•°æ˜¯æ¯è¿‡ M!M!M! å°±ä¼šå¾ªç¯çš„ï¼Œè€Œä¸”å®Œæ•´å¾ªç¯ï¼å¾ªç¯æ¬¡æ•°æ˜¯ N!Ã·M!N!\\div M!N!Ã·M! æ¬¡ã€‚ ç­”æ¡ˆå°±æ˜¯ N!Ã·M!Ã—Ï†(M!)N! \\div M! \\times \\varphi(M!)N!Ã·M!Ã—Ï†(M!)ï¼Œä¸‹é¢è€ƒè™‘å¦‚ä½•æ±‚è§£è¿™ä¸ªç©æ„ã€‚ ans=N!Ã·M!Ã—Ï†(M!)=N!Ã·M!Ã—M!âˆpiâˆ£M!piâˆ’1pi=N!âˆpiâˆ£M!piâˆ’1pi\\begin{aligned} ans &amp;=N! \\div M! \\times \\varphi(M!)\\\\ &amp;=N! \\div M! \\times M! \\prod_{p_i\\mid M!} \\cfrac{p_i-1}{p_i}\\\\ &amp;=N! \\prod_{p_i\\mid M!} \\cfrac{p_i-1}{p_i} \\end{aligned} ansâ€‹=N!Ã·M!Ã—Ï†(M!)=N!Ã·M!Ã—M!piâ€‹âˆ£M!âˆâ€‹piâ€‹piâ€‹âˆ’1â€‹=N!piâ€‹âˆ£M!âˆâ€‹piâ€‹piâ€‹âˆ’1â€‹â€‹ N!N!N! å¯ä»¥é¢„å¤„ç†ï¼Œåé¢è¿™ä¸ªä¸œè¥¿ä¹Ÿå¯ä»¥ç”¨çº¿æ€§ç­›é¢„å¤„ç†ï¼Œä½†æ˜¯è¦åˆ†å­åˆ†æ¯åˆ†å¼€ç®—ï¼Œå¦åˆ™çº¦åˆ†ä¼šå‡ºé”™ã€‚åˆ†æ¯ç›´æ¥æ‹¿é€†å…ƒæ¥ç®—å°±å¯ä»¥äº†ã€‚ å½“ N / R &gt; M / R çš„æ—¶å€™ç­”æ¡ˆä¸º 000ï¼Œå› ä¸ºæ˜¾ç„¶ NNN ä¸­çš„ RRR æ ¹æœ¬æ— æ³•çº¦å¹²å‡€ï¼Œå–æ¨¡åç­”æ¡ˆå°±æˆ 000 äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; const int MAXN = 10000000; int T, R; int N, M; bool v[MAXN + 5]; int prime[MAXN], tot; int inv[MAXN + 5], f[MAXN + 5], g[MAXN + 5], h[MAXN + 5]; int main(void) &#123; scanf(\"%d%d\", &amp;T, &amp;R); inv[1] = 1; for (int i = 2; i &lt;= MAXN; ++i) inv[i] = (i64)(R - R / i) * inv[R % i] % R; f[0] = 1; for (int i = 1; i &lt;= MAXN; ++i) if (i % R != 0) f[i] = (i64)f[i - 1] * i % R; else f[i] = f[i - 1]; g[0] = g[1] = h[0] = h[1] = 1; for (int i = 2; i &lt;= MAXN; ++i) &#123; if (!v[i]) &#123; g[i] = (i64)g[i - 1] * (i - 1) % R; h[i] = (i64)h[i - 1] * (i % R != 0 ? inv[i] : 1) % R; prime[++tot] = i; &#125; else g[i] = g[i - 1], h[i] = h[i - 1]; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= MAXN; ++j) &#123; v[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125; while (T--) &#123; scanf(\"%d%d\", &amp;N, &amp;M); if (N / R > M / R) puts(\"0\"); else printf(\"%lld\\n\", (i64)f[N] * g[M] % R * h[M] % R); &#125; return 0; &#125; [Luogu P2568] GCD Portal. ç»™å®šæ­£æ•´æ•° nnnï¼Œæ±‚ 1â‰¤x,yâ‰¤n1\\le x,y\\le n1â‰¤x,yâ‰¤n ä¸” gcdâ¡(x,y)\\gcd(x,y)gcd(x,y) ä¸ºç´ æ•°çš„æ•°å¯¹ (x,y)(x,y)(x,y) æœ‰å¤šå°‘å¯¹ã€‚ æˆ‘ä»¬æšä¸¾ (x,y)=p(x,y)=p(x,y)=pï¼Œç°åœ¨è¦ç»Ÿè®¡è¿™ä¸ªä¸œè¥¿ã€‚ è®¾ x=pxâ€²,y=pyâ€²x=px&#x27;,y=py&#x27;x=pxâ€²,y=pyâ€²ï¼Œåˆ™ xâŠ¥y,x,yâ‰¤npx\\perp y,x,y\\le \\frac{n}{p}xâŠ¥y,x,yâ‰¤pnâ€‹ï¼Œä¸å¦¨è®¾ xâ€²â‰¤yâ€²x&#x27;\\le y&#x27;xâ€²â‰¤yâ€²ï¼Œå½“ yâ€²=ky&#x27;=kyâ€²=k æ—¶ï¼Œxâ€²x&#x27;xâ€² çš„ä¸ªæ•°å°±æ˜¯ Ï†(k)\\varphi(k)Ï†(k)ã€‚å› æ­¤ä¸ªæ•°å°±æ˜¯ 2Ã—âˆ‘i=1n/pÏ†(i)âˆ’12\\times \\sum_{i=1}^{n/p}\\varphi(i)-12Ã—âˆ‘i=1n/pâ€‹Ï†(i)âˆ’1ã€‚é‚£ä¹ˆçº¿æ€§ç­›å¤„ç†æ¬§æ‹‰å‡½æ•°å‰ç¼€å’Œå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int N = 1e7; typedef long long i64; int n, tot = 0, p[N + 5]; int phi[N + 5]; i64 s[N + 5]; int main(void) &#123; int n; scanf(\"%d\", &amp;n); phi[1] = s[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!phi[i]) phi[i] = i - 1, p[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; ++j) &#123; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; s[i] = s[i - 1] + phi[i]; &#125; i64 ans = 0; for (int i = 1; i &lt;= tot; ++i) ans += 2 * s[n / p[i]] - 1; printf(\"%lld\\n\", ans); return 0; &#125; æ‰©å±•æ¬§æ‹‰å®šç† æ‰©å±•æ¬§æ‹‰å®šç†å¯ä»¥ç”¨æ¥é™å¹‚ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥å®ç°å…‰é€Ÿå¹‚ã€‚ [Luogu P4139] ä¸Šå¸ä¸é›†åˆçš„æ­£ç¡®ç”¨æ³• Portal. ç”±äºä¿è¯äº†è¿™ç©æ„æ˜¯ä¸ªå®šå€¼ï¼Œè€Œä¸”å¹‚æ¬¡æ•°æ˜¯æ— é™å¤§çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ‰©å±•æ¬§æ‹‰å®šç†çš„ä¸‰å¼è¿›è¡Œé™å¹‚ï¼Œç”¨é€’å½’å‡½æ•°æ¥è®¡ç®—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; const int MAXN = 10000000; int phi[MAXN + 5]; void REFLECTION_BLUE(void) &#123; for (int i = 1; i &lt;= MAXN; ++i) phi[i] = i; for (int i = 2; i &lt;= MAXN; ++i) if (phi[i] == i) &#123; for (int j = i; j &lt;= MAXN; j += i) phi[j] = phi[j] / i * (i - 1); &#125; &#125; int poww(int a, int b, int p) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = (i64)res * a % p; a = (i64)a * a % p; b >>= 1; &#125; return res % p; &#125; int pockets(int p) // æ±‚ 2^2^...^2 mod p &#123; if (p == 1) return 1; return poww(2, pockets(phi[p]) + phi[p], p); // 2^2^..^2 % phi[p] + phi[p] æ¬¡æ–¹ &#125; int main(void) &#123; REFLECTION_BLUE(); int T; scanf(\"%d\", &amp;T); while (T--) &#123; int p; scanf(\"%d\", &amp;p); printf(\"%d\\n\", pockets(p) % p); &#125; return 0; &#125; [Ynoi2016] ç‚¸è„–é¾™ I Portal. è¿™é“é¢˜åŒæ ·æ˜¯ä½¿ç”¨æ‰©å±•æ¬§æ‹‰å®šç†è¿›è¡Œé™å¹‚ï¼Œæ³¨æ„å¿«é€Ÿå¹‚è®¡ç®—å’Œå–ä½™è¿ç®—çš„æ—¶å€™æ¯ä¸€æ­¥éƒ½éœ€è¦æŒ‰ç…§æ‰©å±•æ¬§æ‹‰å®šç†çš„æ–¹å¼æ¥è¿›è¡Œï¼Œä¹Ÿå°±æ˜¯éœ€è¦å†™ä¸€ä¸ªæ–°çš„å–æ¨¡å‡½æ•°ã€‚å¯¹äºåŒºé—´ä¿®æ”¹ï¼Œä½¿ç”¨ä¸€ä¸ªæ”¯æŒâ€œåŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢â€œçš„æ ‘çŠ¶æ•°ç»„å³å¯è§£å†³ã€‚ç”±äºæ•°è¾ƒå¤§çš„åœ°æ–¹å¯èƒ½ä¼šçˆ†ç‚¸ï¼Œè¯·ä½¿ç”¨ __int128ï¼Œè¿™åŸºæœ¬ä¸Šæ˜¯ä¸€ä¸ªæ¨¡æ¿ï¼Œæ¨èä»”ç»†é˜…è¯»ä»£ç ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; constexpr int MAXP = 20000000; constexpr int MAXN = 500000; int phi[MAXP + 5]; int v[MAXP + 5], prime[MAXP + 5], tot; inline void REFLECTION_BLUE(void) &#123; phi[1] = 1; for (i64 i = 2; i &lt;= MAXP; ++i) &#123; if (v[i] == 0) &#123; v[i] = i, prime[++tot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= MAXP; ++j) &#123; if (prime[j] > v[i]) break; v[i * prime[j]] = prime[j]; phi[i * prime[j]] = phi[i] * (i % prime[j] == 0 ? prime[j] : prime[j] - 1); &#125; &#125; &#125; int n, m; i64 A[MAXN + 5], C[MAXN + 5]; inline void update(int x, int k) &#123; while (x &lt;= n) &#123; C[x] += k; x += (x &amp; -x); &#125; &#125; inline i64 query(int x) &#123; i64 res = 0; while (x) &#123; res += C[x]; x -= (x &amp; -x); &#125; return res; &#125; inline i64 BLUE(__int128 a, int p) &#123; if (a &lt;= p) return a; return a % p + p; &#125; inline i64 poww(__int128 a, i64 b, int p) &#123; __int128 res = 1; while (b) &#123; if (b &amp; 1) res = BLUE(res * a, p); a = BLUE(a * a, p); b >>= 1; &#125; return res; &#125; i64 pocket(int l, int r, int p) &#123; // åŒºé—´ [l,r] åœ¨ mod p æ„ä¹‰ä¸‹çš„ç­”æ¡ˆ if (p == 1) return 1; // æ¨¡æ•°ä¸º 1 æ—¶ï¼Œè¦è¿”å› 1ï¼Œå› ä¸ºå®é™…ä¸Šè¦è¿”å› BLUE(1, 1) è€Œä¸æ˜¯ç®€å•çš„ 1 mod 1 i64 t = query(l); if (l == r) return BLUE(t, p); return poww(t, pocket(l + 1, r, phi[p]), p); &#125; int main(void) &#123; REFLECTION_BLUE(); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", A + i); update(i, A[i] - A[i - 1]); &#125; while (m--) &#123; int op, l, r, x; scanf(\"%d%d%d%d\", &amp;op, &amp;l, &amp;r, &amp;x); if (op == 1) &#123; update(l, x); update(r + 1, -x); &#125; else printf(\"%lld\\n\", pocket(l, r, x) % x); &#125; return 0; &#125; [SP10050] POWTOW - Power Tower City Portal. ä¾ç„¶æ˜¯ä½¿ç”¨æ‰©å±•æ¬§æ‹‰å®šç†è¿›è¡Œé™å¹‚ï¼Œä½†æ˜¯è¦æ³¨æ„ 000 çš„è®¨è®ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; typedef long long i64; const i64 MOD = 1e9; bool flag = false; int phi(int n) &#123; int ans = n, R = min(n, int(sqrt(n)) + 1); for (int i = 2; i &lt;= R; ++i) if (n % i == 0) &#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; if (n > 1) ans = ans / n * (n - 1); return ans; &#125; inline i64 BLUE(i64 a, i64 p) &#123; if (a &lt; p) return a; return a % p + p; &#125; i64 poww(i64 a, i64 b, i64 p) &#123; i64 res = 1; while (b) &#123; if (b &amp; 1) res = BLUE(res * a, p); a = BLUE(a * a, p); b >>= 1; &#125; return res; &#125; i64 pocket(i64 a, i64 b, i64 p) &#123; // a^a^...^a^aï¼ˆb ä¸ªï¼‰ % p if (p == 1) return 1; if (b == 1) return BLUE(a, p); return poww(a, pocket(a, b - 1, phi(p)), p); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; i64 a, b; scanf(\"%lld%lld\", &amp;a, &amp;b); if (a == 0) printf(\"%d\\n\", b % 2 == 0); else if (b == 0) puts(\"1\"); else &#123; i64 ans = pocket(a, b, MOD); if (ans >= MOD) printf(\"...%09lld\\n\", ans % MOD); else printf(\"%lld\\n\", ans); &#125; &#125; return 0; &#125; [Luogu 5110] å—é€Ÿé€’æ¨ Portal. å¤šæ¬¡è¯¢é—®ï¼ˆè€Œä¸”çœŸå¤šï¼‰ä¸€ä¸ªé€’æ¨å¼çš„ç¬¬ nnn é¡¹ï¼Œè€Œä¸”è¯¢é—®çš„å†…å®¹åœ¨ 64 ä½æ— ç¬¦å·æ•´æ•°å†…ï¼Œå¯ä»¥è‚¯å®šä¸æ˜¯çŸ©é˜µå¿«é€Ÿå¹‚åŠ é€Ÿé€’æ¨ï¼Œéœ€è¦æŠŠè¿™ä¸ªä¸œè¥¿å†™æˆé€šé¡¹å…¬å¼å†åšã€‚ å†™é€šé¡¹å…¬å¼çš„æ–¹å¼æœ‰å¾ˆå¤šï¼Œè¿™é‡Œä½¿ç”¨ææ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç‰¹å¾æ–¹ç¨‹æ¥åšï¼š è®¾ an=233anâˆ’1+666anâˆ’2a_n=233a_{n-1}+666a_{nâˆ’2}anâ€‹=233anâˆ’1â€‹+666anâˆ’2â€‹ çš„ç‰¹å¾æ–¹ç¨‹ä¸ºï¼š xn+2=233xn+1+666xnx2=233x+666x2âˆ’233xâˆ’666=0x1=233+569532,x2=233âˆ’569532x^{n+2}=233x^{n+1}+666x^n\\\\ x^2=233x+666\\\\ x^2-233x-666=0\\\\ x_1=\\frac{233+\\sqrt{56953}}{2},x_2=\\frac{233-\\sqrt{56953}}{2} xn+2=233xn+1+666xnx2=233x+666x2âˆ’233xâˆ’666=0x1â€‹=2233+56953â€‹â€‹,x2â€‹=2233âˆ’56953â€‹â€‹ ç„¶åå¼€å§‹ç®—æ–¹ç¨‹ç»„ï¼š an=px1n+qx2n,âˆµa0=0,a1=1âˆ´{p+q=0,px1+qx2=1,âˆ´{p+q=0,pÃ—233+569532+qÃ—233âˆ’569532=1,âˆ´{p=156953,q=âˆ’156953,âˆ´an=156953(233+569532)nâˆ’156953(233âˆ’569532)n,âˆ´an=156953((233+569532)nâˆ’(233âˆ’569532)n)a_n=px_1^{n}+qx_2^n,\\\\ \\because a_0=0,a_1=1\\\\ \\therefore \\begin{cases} p+q=0,\\\\ px_1+qx_2=1, \\end{cases}\\\\ \\therefore \\begin{cases} p+q=0,\\\\ p\\times\\cfrac{233+\\sqrt{56953}}{2}+q\\times\\cfrac{233-\\sqrt{56953}}{2}=1, \\end{cases}\\\\ \\therefore \\begin{cases} p=\\cfrac{1}{\\sqrt{56953}},\\\\ q=-\\cfrac{1}{\\sqrt{56953}}, \\end{cases}\\\\ \\therefore a_n=\\cfrac{1}{\\sqrt{56953}}\\left(\\frac{233+\\sqrt{56953}}{2}\\right)^{n}-\\cfrac{1}{\\sqrt{56953}}\\left(\\frac{233-\\sqrt{56953}}{2}\\right)^{n},\\\\ \\therefore a_n=\\cfrac{1}{\\sqrt{56953}}\\left(\\left(\\frac{233+\\sqrt{56953}}{2}\\right)^{n}-\\left(\\frac{233-\\sqrt{56953}}{2}\\right)^{n}\\right) anâ€‹=px1nâ€‹+qx2nâ€‹,âˆµa0â€‹=0,a1â€‹=1âˆ´{p+q=0,px1â€‹+qx2â€‹=1,â€‹âˆ´â©â¨â§â€‹p+q=0,pÃ—2233+56953â€‹â€‹+qÃ—2233âˆ’56953â€‹â€‹=1,â€‹âˆ´â©â¨â§â€‹p=56953â€‹1â€‹,q=âˆ’56953â€‹1â€‹,â€‹âˆ´anâ€‹=56953â€‹1â€‹(2233+56953â€‹â€‹)nâˆ’56953â€‹1â€‹(2233âˆ’56953â€‹â€‹)n,âˆ´anâ€‹=56953â€‹1â€‹((2233+56953â€‹â€‹)nâˆ’(2233âˆ’56953â€‹â€‹)n) è¿™ä¸ªå¼å­æ˜¯åŒ–ç®€ä¸åŠ¨äº†ï¼Œä½†æ˜¯æ³¨æ„è¿™é¢˜æ˜¯å¯¹ 109+710^9+7109+7 å–æ¨¡ï¼Œç„¶åå°±å¯ä»¥åˆ©ç”¨ä¹‹å‰çš„æ— ç†æ•°å–æ¨¡ï¼Œå‘ç° 188305837188305837188305837 è·Ÿ 56953\\sqrt{56953}56953â€‹ æ˜¯åŒä½™çš„ã€‚ç„¶åå°±å¯ä»¥åšæˆï¼ˆæ³¨æ„åˆ©ç”¨åœ¨æ•°è®ºåˆæ­¥ä¸­è®²çš„è´Ÿæ•°å–æ¨¡ï¼Œå¯å¾— âˆ’94152802 mod 109+7=905847205-94152802 \\bmod 10^9+7=905847205âˆ’94152802mod109+7=905847205ï¼‰ï¼š an=1188305837((233+1883058372)nâˆ’(233âˆ’1883058372)n)an=1188305837(94153035nâˆ’(âˆ’94152802)n)an=1188305837(94153035nâˆ’905847205n)a_n=\\cfrac{1}{188305837}\\left(\\left(\\frac{233+188305837}{2}\\right)^{n}-\\left(\\frac{233-188305837}{2}\\right)^{n}\\right)\\\\ a_n=\\cfrac{1}{188305837}\\left(94153035^{n}-(-94152802)^{n}\\right)\\\\ a_n=\\cfrac{1}{188305837}\\left(94153035^{n}-905847205^{n}\\right) anâ€‹=1883058371â€‹((2233+188305837â€‹)nâˆ’(2233âˆ’188305837â€‹)n)anâ€‹=1883058371â€‹(94153035nâˆ’(âˆ’94152802)n)anâ€‹=1883058371â€‹(94153035nâˆ’905847205n) åˆ©ç”¨æœ‰ç†æ•°å–æ¨¡ï¼ŒçŸ¥ 1188305837â‰¡233230706(mod109+7)\\cfrac{1}{188305837}\\equiv 233230706 \\pmod{10^9+7}1883058371â€‹â‰¡233230706(mod109+7)ï¼Œæ‰€ä»¥æœ€ç»ˆå¼å­åŒ–ä¸ºï¼š an=233230706(94153035nâˆ’905847205n)a_n=233230706(94153035^{n}-905847205^{n}) anâ€‹=233230706(94153035nâˆ’905847205n) ç„¶åå°±å¯ä»¥æ­£å¸¸ä½¿ç”¨å…‰é€Ÿå¹‚è®¡ç®—äº†ã€‚æ³¨æ„ 109+710^9+7109+7 æ˜¯è´¨æ•°ï¼ˆÏ†(109+7)=109+6\\varphi(10^9+7)=10^9+6Ï†(109+7)=109+6ï¼‰ï¼Œè€Œä¸”åº•æ•°å°äºè¿™ä¸ªè´¨æ•°ï¼ˆå³äº’è´¨ï¼‰ï¼Œæ‰€ä»¥é™å¹‚çš„æ—¶å€™ç”¨ä¸€å¼é™å¹‚å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; using u64 = unsigned long long; using i64 = long long; const int MOD = 1000000007; namespace Mker &#123; unsigned long long SA, SB, SC; void init() &#123; scanf(\"%llu%llu%llu\", &amp;SA, &amp;SB, &amp;SC); &#125; unsigned long long rand() &#123; SA ^= SA &lt;&lt; 32, SA ^= SA >> 13, SA ^= SA &lt;&lt; 1; unsigned long long t = SA; SA = SB, SB = SC, SC ^= t ^ SA; return SC; &#125; &#125; int t; int f1[33000], f2[66000], f3[33000], f4[66000]; inline int pow1(int n) &#123; return (i64)f2[n / t] * f1[n % t] % MOD; &#125; inline int pow2(int n) &#123; return (i64)f4[n / t] * f3[n % t] % MOD; &#125; int main(void) &#123; int T, ans = 0; scanf(\"%d\", &amp;T); Mker::init(); f1[0] = f2[0] = f3[0] = f4[0] = 1; t = sqrt(MOD + 0.5); for (int i = 1; i &lt;= t; ++i) f1[i] = (i64)f1[i - 1] * 94153035 % MOD; for (int i = 1; i &lt;= (t &lt;&lt; 1); ++i) f2[i] = (i64)f2[i - 1] * f1[t] % MOD; for (int i = 1; i &lt;= t; ++i) f3[i] = (i64)f3[i - 1] * 905847205 % MOD; for (int i = 1; i &lt;= (t &lt;&lt; 1); ++i) f4[i] = (i64)f4[i - 1] * f3[t] % MOD; while (T--) &#123; u64 n = Mker::rand() % (MOD - 1); // phi(MOD) = MOD - 1 ans ^= (u64)233230706 * (pow1(n) - pow2(n) + MOD) % MOD; &#125; printf(\"%d\\n\", ans); return 0; &#125; ä¸­å›½å‰©ä½™å®šç† åŒ…æ‹¬ CRT å’Œ exCRTã€‚ [TJOI2009] çŒœæ•°å­— Portal. ç›´æ¥ä½¿ç”¨ CRTï¼Œä½†æ˜¯å°å¿ƒçˆ† long longã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; void exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a % b, y, x); y -= a / b * x; &#125; int n; i64 a[15], b[15], M[15], t[15]; i64 CRT(void) &#123; i64 mm = 1, ans = 0, x; for (int i = 1; i &lt;= n; ++i) mm *= b[i]; for (int i = 1; i &lt;= n; ++i) &#123; M[i] = mm / b[i]; exgcd(M[i], b[i], t[i], x); ans = ans + ((__int128)a[i] * M[i] % mm * t[i]) % mm; &#125; return (ans % mm + mm) % mm; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", b + i); printf(\"%lld\\n\", CRT()); return 0; &#125; [NOI2018] å± é¾™å‹‡å£« Portal. å®é™…ä¸Šä¾ç„¶æ˜¯ exCRTï¼Œåªä¸è¿‡æ–¹ç¨‹æ¢æˆäº† bxâ‰¡a(modp)bx\\equiv a\\pmod pbxâ‰¡a(modp)ã€‚è¿™æ ·æ˜¯ä¸€æ ·çš„ï¼Œè®¾å½“å‰åˆå¹¶çš„æ¨¡æ•°ä¸º MMMï¼Œç­”æ¡ˆä¸º ansansansï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªåˆå¹¶è¦æ»¡è¶³ b(ans+Mx)â‰¡a(modp)b(ans+Mx)\\equiv a\\pmod pb(ans+Mx)â‰¡a(modp)ï¼Œä¹Ÿå°±æ˜¯ bMxâˆ’py=aâˆ’bÃ—ansbMx-py=a-b\\times ansbMxâˆ’py=aâˆ’bÃ—ansã€‚ æ³¨æ„ä¸€ä¸ªç»†èŠ‚ï¼šè§£å‡ºæ¥çš„è§£å¿…é¡»èƒ½å°†é¾™æ‰“æ‰ï¼Œä¹Ÿå°±æ˜¯èƒ½å°†è¡€æ‰“æˆå°äºç­‰äº 000ï¼Œå¦åˆ™å³ä½¿æ»¡è¶³åŒä½™æ–¹ç¨‹ä¹Ÿæ²¡ç”¨ã€‚è®°å½•ä¸€ä¸ªèƒ½æŠŠè¡€é‡æ‰“æˆè´Ÿæ•°çš„æœ€å°æ”»å‡»æ¬¡æ•°ï¼Œç„¶åå¦‚æœç­”æ¡ˆå°äºè¿™ä¸ªæ”»å‡»æ¬¡æ•°ï¼Œç­”æ¡ˆå°±åŠ ä¸Šè¿˜éœ€è¦æ‰“çš„æ¬¡æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;set> using namespace std; typedef long long i64; i64 exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, a; i64 g = exgcd(b, a % b, y, x); y -= a / b * x; return g; &#125; int n, m; i64 a[100005], p[100005], mx = 0; int sword[100005]; int atk[100005]; multiset&lt;i64> s; i64 exCRT(void) &#123; i64 M = 1, ans = 0; i64 x, y, g, A, B, C; for (int i = 1; i &lt;= n; ++i) &#123; A = (__int128)atk[i] * M % p[i]; B = p[i]; C = (a[i] - ans * atk[i] % p[i] + p[i]) % p[i]; g = exgcd(A, B, x, y); if (C % g != 0) return -1; x = (x % B + B) % B; ans += (__int128)(C / g) * x % (B / g) * M; M *= B / g; ans %= M; &#125; if (ans &lt; mx) ans += ((mx - ans - 1) / M + 1) * M; return ans; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); s.clear(); mx = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", p + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", sword + i); for (int i = 1, x; i &lt;= m; ++i) &#123; scanf(\"%d\", &amp;x); s.insert(x); &#125; for (int i = 1; i &lt;= n; ++i) &#123; auto it = s.upper_bound(a[i]); if (it != s.begin()) --it; atk[i] = *it; s.erase(it); s.insert(sword[i]); mx = max(mx, (a[i] - 1) / atk[i] + 1); &#125; printf(\"%lld\\n\", exCRT()); &#125; return 0; &#125; ç»¼åˆåº”ç”¨ è¿™äº›æ˜¯åŸºç¡€æ•°è®ºç®—æ³•è¾ƒä¸ºç»¼åˆçš„åº”ç”¨ã€‚ [NOI2015] å¯¿å¸æ™šå®´ Portal. æœ€æš´åŠ›çš„åšæ³•å°±æ˜¯è®¾ fS1,S2f_{S_1,S_2}fS1â€‹,S2â€‹â€‹ ä»£è¡¨ä¸¤äººé€‰çš„è´¨å› æ•°çŠ¶å‹ååˆ†åˆ«ä¸º S1,S2S_1,S_2S1â€‹,S2â€‹ï¼Œå‘ç° nâ‰¤500n\\le 500nâ‰¤500ï¼Œæ¯” 191919 å¤§çš„è´¨å› æ•°æœ€å¤šå‡ºç°ä¸€æ¬¡ã€‚å¯ä»¥å•ç‹¬è®°å½•è¿™ä¸ªå¤§è´¨å› æ•°ï¼Œç„¶åæŠŠæ¯ä¸€ä¸ªæœ‰è¿™ä¸ªå¤§è´¨å› æ•°çš„å¯¿å¸è®¾ä¸ºä¸€ç»„ï¼Œåœ¨è¿™ä¸€ç»„è¿›è¡Œè½¬ç§»æ—¶å¦è®° g1,g2g_1,g_2g1â€‹,g2â€‹ åˆ†åˆ«ä»£è¡¨åªå…è®¸è¿™ä¸¤ä¸ªäººå…¶ä¸­ä¸€ä¸ªåƒæœ‰è¿™ä¸ªå¤§è´¨å› æ•°çš„å¯¿å¸ï¼Œæœ€ååˆå¹¶ç­”æ¡ˆçš„æ—¶å€™è¿˜è¦å‡å»æœ€åˆçš„ fffï¼Œå› ä¸ºä¸¤ä¸ªäººéƒ½ä¸åƒçš„ç®—äº†ä¸¤æ¬¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int prime[] = &#123;2, 3, 5, 7, 11, 13, 17, 19&#125;; int n, P; int f[256][256], g1[256][256], g2[256][256]; // g1 è¡¨ç¤º 1 å– bigï¼Œg2 è¡¨ç¤º 2 å– big struct Number &#123; int val, S, big; void init(void) &#123; int tmp = val; big = -1; for (int i = 0; i &lt; 8; ++i) if (tmp % prime[i] == 0) &#123; S |= 1 &lt;&lt; i; while (tmp % prime[i] == 0) tmp /= prime[i]; &#125; if (tmp != 1) big = tmp; &#125; bool operator &lt; (const Number &amp;a) const &#123; return big &lt; a.big; &#125; &#125; a[505]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;P); f[0][0] = 1; for (int i = 1; i &lt; n; ++i) a[i].val = i + 1, a[i].init(); sort(a + 1, a + n + 1); for (int i = 1; i &lt; n; ++i) &#123; if (i == 1 || a[i].big == -1 || a[i].big != a[i - 1].big) &#123; memcpy(g1, f, sizeof g1); memcpy(g2, f, sizeof g2); &#125; for (int j = 255; j >= 0; --j) for (int k = 255; k >= 0; --k) if ((j &amp; k) == 0) &#123; if ((a[i].S &amp; k) == 0) g1[j | a[i].S][k] = (g1[j | a[i].S][k] + g1[j][k]) % P; if ((a[i].S &amp; j) == 0) g2[j][k | a[i].S] = (g2[j][k | a[i].S] + g2[j][k]) % P; &#125; if (i == n - 1 || a[i].big == -1 || a[i].big != a[i + 1].big) &#123; for (int j = 0; j &lt; 256; ++j) for (int k = 0; k &lt; 256; ++k) if ((j &amp; k) == 0) f[j][k] = (g1[j][k] + g2[j][k] - f[j][k]) % P; &#125; &#125; int ans = 0; for (int i = 0; i &lt; 256; ++i) for (int j = 0; j &lt; 256; ++j) if ((i &amp; j) == 0) ans = (ans + f[i][j]) % P; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; å®é™…ä¸Šè¿™ä¸ªå‚ç›´ç¬¦å·ä»…åœ¨ OI ä¸­ä½¿ç”¨ï¼Œç¬”è€…åœ¨å„ç±»æ•°å­¦æ•™æä¸­å¹¶æ²¡æœ‰è§åˆ°è¿™ä¸ªç¬¦å·ï¼Œä½†æ˜¯åœ¨ã€Šå…·ä½“æ•°å­¦ã€‹è¿™ç§è®¡ç®—æœºæ•°å­¦æ•™æä¸­å°±æœ‰è§åˆ°ã€‚ â†©ï¸ æ²¡æœ‰é¢˜å·çš„é¢˜ç›®å¯èƒ½æ˜¯ç»å…¸é—®é¢˜ï¼Œæˆ–è€…ç¬”è€…å¤ªå¼±äº†æ‰¾ä¸åˆ°å‡ºå¤„ã€‚ â†©ï¸ å¦‚æœä½ æƒ³è¦è¾ƒçœŸï¼Œå®é™…ä¸Š gcdâ¡\\gcdgcd æ‰æ˜¯ä¸‡æ¶ä¹‹æºï¼Œè¯´æ˜¯â€œæ•°è®ºåªä¼š gcdâ¡\\gcdgcdâ€ï¼Œä½†è¿™ä¹Ÿæ°æ°è¯æ˜äº† gcdâ¡\\gcdgcd æ— ä¸ä¼¦æ¯”çš„é‡è¦æ€§ã€‚ â†©ï¸","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ•°è®º","slug":"æ•°è®º","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"å¯æŒä¹…åŒ–ä¸åµŒå¥—æ•°æ®ç»“æ„","slug":"notes/DS/sx-ds-1","date":"2023-01-31T00:00:00.000Z","updated":"2023-01-31T00:00:00.000Z","comments":true,"path":"32a993e5/","link":"","permalink":"https://james1badcreeper.github.io/32a993e5/","excerpt":"å¯æŒä¹…åŒ–æ•°æ®ç»“æ„å¯ä»¥ä¿ç•™æ¯ä¸€ä¸ªå†å²ç‰ˆæœ¬ï¼ŒåµŒå¥—åˆ™æŒ‡çš„æ˜¯â€œæ ‘å¥—æ ‘â€ï¼Œå°†æ•°æ®ç»“æ„åµŒå¥—æ¥å®ç°æ›´åŠ å¼ºå¤§çš„åŠŸèƒ½ã€‚","text":"å¯æŒä¹…åŒ–æ•°æ®ç»“æ„å¯ä»¥ä¿ç•™æ¯ä¸€ä¸ªå†å²ç‰ˆæœ¬ï¼ŒåµŒå¥—åˆ™æŒ‡çš„æ˜¯â€œæ ‘å¥—æ ‘â€ï¼Œå°†æ•°æ®ç»“æ„åµŒå¥—æ¥å®ç°æ›´åŠ å¼ºå¤§çš„åŠŸèƒ½ã€‚ å¯æŒä¹…åŒ–æ•°æ®ç»“æ„ å¤§è‡´æ„æ€ä¸Šæ˜¯å¯ä»¥ä¿ç•™æ•°æ®ç»“æ„çš„å†å²ç‰ˆæœ¬ï¼Œä¸è¿‡è¿˜æœ‰æ›´å¤šçš„ç”¨å¤„ã€‚ æ¦‚å¿µ æ‰€æœ‰ç‰ˆæœ¬éƒ½å¯ä»¥è®¿é—®ï¼Œä½†æ˜¯åªæœ‰æœ€æ–°ç‰ˆæœ¬å¯ä»¥ä¿®æ”¹ï¼Œç§°ä¹‹ä¸ºéƒ¨åˆ†å¯æŒä¹…åŒ–ã€‚ æ‰€æœ‰ç‰ˆæœ¬éƒ½æ—¢å¯ä»¥è®¿é—®åˆå¯ä»¥ä¿®æ”¹ï¼Œç§°ä¹‹ä¸ºå®Œå…¨å¯æŒä¹…åŒ–ã€‚ è‹¥æ”¯æŒå°†ä¸¤ä¸ªå†å²ç‰ˆæœ¬åˆå¹¶ï¼Œåˆ™åˆç§°ä¸ºæ±‡åˆå¯æŒä¹…åŒ–ï¼ˆConfluently Persistentï¼‰ã€‚ æ— è®ºå¦‚ä½•ï¼ŒåŸºæœ¬æ€æƒ³æ˜¯ä¿®æ”¹æ—¶è¦ä¿ç•™åŸæ¥çš„å†…å®¹ã€‚ å¯æŒä¹…åŒ–çº¿æ®µæ ‘ æ¯«æ— ç–‘é—®ï¼Œè¿™æ˜¯æœ€é‡è¦çš„å¯æŒä¹…åŒ–æ•°æ®ç»“æ„ï¼Œå› ä¸ºå®ƒå¯ä»¥ç”¨æ¥å®ç°å¯æŒä¹…åŒ–æ•°ç»„ï¼Œè¿›è€Œå®ç°æ›´å¤šå†…å®¹ã€‚ æ¦‚è¿° å½“æˆ‘ä»¬è¿›è¡Œä¿®æ”¹çš„æ—¶å€™ï¼Œæœ€æš´åŠ›çš„æƒ³æ³•å°±æ˜¯ï¼šæˆ‘å†å»ºä¸€æ£µçº¿æ®µæ ‘ä¸å°±å¾—äº†å˜›ï¼ ä½†æ˜¯ä½ è§‰å¾—å¯èƒ½å—ï¼Ÿç©ºé—´ç‚¸è£‚äº†â€¦â€¦ å¯¹äºç‚¹ä¿®æ”¹æ¥è¯´ï¼Œä¸€æ¬¡ä¿®æ”¹è‡³å¤šä¼šå½±å“ O(logâ¡n)O(\\log n)O(logn) ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å¤åˆ¶è¿™ O(logâ¡n)O(\\log n)O(logn) ä¸ªèŠ‚ç‚¹å³å¯ã€‚ä½†æ˜¯å¤åˆ¶ï¼Ÿè¿™æ ·çš„è¯å°±éœ€è¦è®°å½•å·¦å³å„¿å­çš„ç¼–å·ï¼Œå®ç°çš„æ—¶å€™éœ€è¦é‡‡ç”¨åŠ¨æ€å¼€ç‚¹ï¼Œè¿™æ ·å¯ä»¥å°†æ–°å»ºçš„èŠ‚ç‚¹çš„å„¿å­ç¼–å·æ‹‰åˆ°åŸçº¿æ®µæ ‘ä¸Šã€‚ struct Node &#123; int lc, rc; // å·¦å³èŠ‚ç‚¹ç¼–å· int dat; // å½“å‰ç»´æŠ¤çš„å€¼ &#125;T[SIZE * 2]; // ç»ˆäºåªéœ€è¦äºŒå€ç©ºé—´å•¦ï¼ int root[MAXQ], tot; // æ¯æ¬¡ä¿®æ”¹çš„æ ¹èŠ‚ç‚¹ç¼–å·ï¼ŒèŠ‚ç‚¹ä¸ªæ•° int build(int l, int r) &#123; int o = ++tot; if (l == r) return T[o].dat = a[l], o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); T[o].dat = T[T[o].lc].dat + T[T[o].rc].dat; return o; &#125; int main(void) &#123; root[0] = build(1, n); // å»ºç«‹åˆå§‹çš„å¯æŒä¹…åŒ–çº¿æ®µæ ‘ &#125; ç‚¹ä¿®æ”¹ åœ¨ä¿®æ”¹çš„æ—¶å€™ï¼Œå˜åŒ–çš„å†…å®¹çš„èŠ‚ç‚¹ç¼–å·è¦æ–°å»ºï¼Œè€Œæ²¡æœ‰å˜åŒ–çš„ç›´æ¥å¤åˆ¶åŸæ¥çš„ç‰ˆæœ¬ä¿¡æ¯å³å¯ã€‚ ä¿®æ”¹äº†ä½ç½® 1 çš„å€¼ï¼Œåªæœ‰èŠ‚ç‚¹ 1248 çš„å€¼ä¼šå‘ç”Ÿå˜åŒ–ï¼Œéœ€è¦æ–°å»º int main(void) &#123; root[i] = update(root[i - 1], 1, n, x, k); // åœ¨ç¬¬ i - 1 ä¸ªç‰ˆæœ¬çš„åŸºç¡€ä¸Šåˆ›å»ºç¬¬ i ä¸ªç‰ˆæœ¬ &#125; int update(int pre, int l, int r, int x, int k) &#123; // åœ¨ pre å·èŠ‚ç‚¹çš„åŸºç¡€ä¸Šï¼Œx åŠ ä¸Š k int o = ++tot; // å…ˆæ–°å»ºè¿™ä¸ªèŠ‚ç‚¹ T[o] = T[pre]; // å…ˆæŠŠåŸæ¥çš„ä¸œè¥¿å¤åˆ¶è¿‡æ¥ if (l == r) return T[o].dat += k, o; // å¶å­èŠ‚ç‚¹ç›´æ¥ä¿®æ”¹ int mid = l + r >> 1; if (x &lt;= mid) T[o].lc = update(T[pre].lc, l, mid, x, k); // ä¿®æ”¹çš„å†…å®¹åœ¨å·¦å­åŒºé—´ï¼Œå°†å·¦å„¿å­çš„ç¼–å·ä¿®æ”¹ä¸ºæ–°å»ºèŠ‚ç‚¹çš„ç¼–å· else T[o].rc = update(T[pre].rc, mid + 1, r, x, k); // ä¿®æ”¹çš„å†…å®¹åœ¨å³å­åŒºé—´ï¼Œä¿®æ”¹å³å„¿å­çš„ç¼–å· T[o].dat = T[T[o].lc].dat + T[T[o].rc].dat; // ç»´æŠ¤å½“å‰èŠ‚ç‚¹çš„å€¼ return o; // è¿”å›å½“å‰èŠ‚ç‚¹ &#125; è¿™ç§å®ç°å¯æŒä¹…åŒ–çš„æ–¹å¼ç§°ä¸º Path Copyï¼Œåœ¨ç«èµ›ä¸­åŠŸèƒ½æ˜¯è¶³å¤Ÿçš„ï¼Œä½†é—®é¢˜æ˜¯æ¶ˆè€—çš„ç©ºé—´è¾ƒå¤§ï¼ˆä½†æ˜¯ä¸€èˆ¬æ²¡äººå¡ï¼‰ã€‚ å¯æŒä¹…åŒ–æ•°ç»„ æ¨¡æ¿ã€‚ å¯æŒä¹…åŒ–çº¿æ®µæ ‘å¯ä»¥ç”¨æ¥å®ç°å¯æŒä¹…åŒ–æ•°ç»„ï¼Œè€Œä¸”éå¸¸ç®€å•ï¼Œå› ä¸ºåªéœ€è¦åšåˆ°å•ç‚¹ä¿®æ”¹å’Œå•ç‚¹æŸ¥è¯¢ã€‚ æ‰€ä»¥ maintain ä¹‹ç±»çš„æ“ä½œæ ¹æœ¬ä¸éœ€è¦ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å‡ ä¹è·Ÿæ™®é€šçº¿æ®µæ ‘ä¸€æ¨¡ä¸€æ ·ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; struct Node &#123; int lc, rc; int dat; &#125; T[44000005]; int tot, root[1000005]; int n, m; int a[1000005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return T[o].dat = a[l], o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return T[o].dat = k, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].lc = update(T[pre].lc, l, mid, x, k); else T[o].rc = update(T[pre].rc, mid + 1, r, x, k); return o; &#125; int query(int o, int l, int r, int x) &#123; if (l == r) return T[o].dat; int mid = l + r >> 1; if (x &lt;= mid) return query(T[o].lc, l, mid, x); return query(T[o].rc, mid + 1, r, x); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); root[0] = build(1, n); for (int i = 1; i &lt;= m; ++i) &#123; int pre, op, x, k; scanf(\"%d%d%d\", &amp;pre, &amp;op, &amp;x); if (op == 1) &#123; scanf(\"%d\", &amp;k); root[i] = update(root[pre], 1, n, x, k); &#125; else printf(\"%d\\n\", query(root[i] = root[pre], 1, n, x)); &#125; return 0; &#125; å¯æŒä¹…åŒ–å¹¶æŸ¥é›† æ¨¡æ¿ã€‚åŸºäºå¯æŒä¹…åŒ–æ•°ç»„å¯ä»¥å®ç°å¯æŒä¹…åŒ–å¹¶æŸ¥é›†ï¼ˆå°†å¹¶æŸ¥é›†çš„æ•°ç»„å¯æŒä¹…åŒ–å³å¯ï¼‰ï¼Œä½†æ˜¯æ³¨æ„è·¯å¾„å‹ç¼©ä¼šä½¿å¾—æ ‘çš„å½¢æ€æ”¹å˜è€Œæ— æ³•å¯æŒä¹…åŒ–ï¼Œå› æ­¤åªèƒ½ä½¿ç”¨æŒ‰ç§©åˆå¹¶ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int N = 100005; int n, m, ver; struct Node &#123; int ls, rs; int dat; &#125;; struct SegmentTree &#123; Node T[N * 40]; int tot, root[200005], a[100005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return T[o].dat = a[l], o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return T[o].dat = k, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x, k); else T[o].rs = update(T[pre].rs, mid + 1, r, x, k); return o; &#125; int query(int o, int l, int r, int x) &#123; if (l == r) return T[o].dat; int mid = l + r >> 1; if (x &lt;= mid) return query(T[o].ls, l, mid, x); return query(T[o].rs, mid + 1, r, x); &#125; &#125; fa, siz; int find(int x) &#123; int tmp = fa.query(fa.root[ver], 1, n, x); if (tmp == x) return x; return find(tmp); &#125; void merge(int x, int y) &#123; x = find(x), y = find(y); if (x == y) return; int sx = siz.query(siz.root[ver], 1, n, x), sy = siz.query(siz.root[ver], 1, n, y); if (sx > sy) swap(x, y), swap(sx, sy); fa.root[ver] = fa.update(fa.root[ver], 1, n, x, y); siz.root[ver] = siz.update(siz.root[ver], 1, n, y, sx + sy); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) fa.a[i] = i, siz.a[i] = 1; fa.root[0] = fa.build(1, n); siz.root[0] = siz.build(1, n); for (ver = 1; ver &lt;= m; ++ver) &#123; int op, x, y; scanf(\"%d%d\", &amp;op, &amp;x); fa.root[ver] = fa.root[ver - 1]; siz.root[ver] = siz.root[ver - 1]; if (op == 1) &#123; scanf(\"%d\", &amp;y); merge(x, y); &#125; else if (op == 2) &#123; fa.root[ver] = fa.root[x]; siz.root[ver] = siz.root[x]; &#125; else &#123; scanf(\"%d\", &amp;y); puts(find(x) == find(y) ? \"1\" : \"0\"); &#125; &#125; return 0; &#125; ä¸»å¸­æ ‘ ä¹Ÿå°±æ˜¯å¯æŒä¹…åŒ–æƒå€¼çº¿æ®µæ ‘ã€‚ æ¨¡æ¿ã€‚ æˆ‘ä»¬å¯ä»¥ä¾æ¬¡è¯»å…¥è¿™äº›æ•°åç¦»æ•£åŒ–ï¼Œç„¶åæ‰«ææ¯ä¸ªæ•°ï¼Œå»ºç«‹ä¸»å¸­æ ‘ï¼Œç¬¬ kkk ä¸ªç‰ˆæœ¬ç»´æŠ¤ [1,k][1,k][1,k] å„ä¸ªæ•°å€¼ã€‚ç”±äºæƒå€¼æ ‘æ˜¯å¯ä»¥ç›´æ¥ç›¸åŠ æˆ–ç›¸å‡çš„ï¼Œæ‰€ä»¥æ•´ä¸ªè¿‡ç¨‹ç±»ä¼¼äºå·®åˆ†ã€‚ æ­£å¸¸çš„æ–¹å¼æ˜¯äºŒåˆ†å‡ºç­”æ¡ˆï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„çŸ¥é“æœ‰å¤šå°‘ä¸ªå°äº xxx çš„æ•°ã€‚è¿™æ ·å°±å¯ä»¥ç›´æ¥åœ¨ä¸»å¸­æ ‘ä¸ŠäºŒåˆ†ï¼Œåœ¨ç¦»æ•£åŒ–åï¼Œå‡è®¾æœ‰ mmm ä¸ªæ•°ï¼Œé‚£ä¹ˆå€¼åŸŸå°±å˜ä¸ºäº† [1,m][1,m][1,m]ã€‚datdatdat ä»£è¡¨æ‰€å¯¹åº”çš„å€¼åŸŸ [L,R][L,R][L,R] æ’å…¥äº†å¤šå°‘ä¸ªæ•°ã€‚æ’å…¥ä¸€ä¸ªæ•°åï¼Œå°±è¦åœ¨å®ƒç¦»æ•£åŒ–åçš„ä½ç½®ä¸ŠåŠ ä¸Š 111ã€‚æŸ¥è¯¢çš„æ—¶å€™ï¼Œæœ‰ T[ri].datâˆ’T[liâˆ’1].datT[r_i].dat - T[l_i-1].datT[riâ€‹].datâˆ’T[liâ€‹âˆ’1].dat çš„å€¼å°±æ˜¯ [li,ri][l_i,r_i][liâ€‹,riâ€‹] ä¸­æœ‰å¤šå°‘ä¸ªæ•°è½åœ¨å€¼åŸŸ [L,R][L,R][L,R] ä¸Šã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; const int MAXN = 200005; struct Node &#123; int lc, rc; int dat; &#125;T[MAXN * 20]; int tot, root[200005]; int n, Q, m; int a[200005]; int tmp[200005]; void init(void) &#123; for (int i = 1; i &lt;= n; ++i) tmp[i] = a[i]; sort(tmp + 1, tmp + n + 1); m = unique(tmp + 1, tmp + n + 1) - (tmp + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(tmp + 1, tmp + m + 1, a[i]) - tmp; &#125; int build(int l, int r) // ä¸€å¼€å§‹åªæ˜¯æ–°å»ºèŠ‚ç‚¹ï¼Œä½†æ˜¯æ²¡æœ‰æ•°å€¼ &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) &#123; T[o].dat += k; return o; &#125; int mid = l + r >> 1; if (x &lt;= mid) T[o].lc = update(T[pre].lc, l, mid, x, k); else T[o].rc = update(T[pre].rc, mid + 1, r, x, k); T[o].dat = T[T[o].lc].dat + T[T[o].rc].dat; return o; &#125; int query(int p, int q, int l, int r, int k) // æŸ¥è¯¢çš„æ—¶å€™åŒæ­¥è¿›è¡ŒæŸ¥è¯¢ &#123; if (l == r) return l; // å€¼åŸŸåªæœ‰ä¸€ä¸ªï¼Œç›´æ¥è¿”å› int mid = l + r >> 1, res = T[T[q].lc].dat - T[T[p].lc].dat; // è½åœ¨ [L, mid] çš„å€¼åŸŸçš„æ•°çš„ä¸ªæ•° if (k &lt;= res) return query(T[p].lc, T[q].lc, l, mid, k); // è¦æŸ¥çš„æ¯” res å°ï¼Œåœ¨å·¦å­èŠ‚ç‚¹æŸ¥ return query(T[p].rc, T[q].rc, mid + 1, r, k - res); // æ¯” res å¤§ï¼Œå‡å» res åœ¨å³å­èŠ‚ç‚¹æŸ¥ &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;Q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); init(); root[0] = build(1, m); for (int i = 1; i &lt;= n; ++i) root[i] = update(root[i - 1], 1, m, a[i], 1); while (Q--) &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", tmp[query(root[l - 1], root[r], 1, m, k)]); &#125; return 0; &#125; è‡³äºç©ºé—´åˆ°åº•å¼€å¤šå¤§ï¼Œè¦çœ‹ä¿®æ”¹æ¬¡æ•°ï¼Œç„¶åæŒ‰ç…§ç©ºé—´å¤æ‚åº¦è®¡ç®—å³å¯ï¼Œå¦‚æœå†…å­˜é™åˆ¶å…è®¸å¯ä»¥ç¨å¾®å¼€å¤§ä¸€ç‚¹ã€‚æœ¬é¢˜ä¸­ âŒˆlogâ¡22Ã—105âŒ‰=18\\lceil\\log_2 2\\times 10^5\\rceil=18âŒˆlog2â€‹2Ã—105âŒ‰=18ï¼Œå†åŠ ä¸Šä¸€ä¸ªåˆå§‹ç‰ˆæœ¬çš„ä¸¤å€ç©ºé—´ï¼Œå¼€åˆ° 202020 å€ç©ºé—´å°±è¶³å¤Ÿäº†ã€‚ å¾ˆæ˜¾ç„¶è¿™ç§é—®é¢˜å¦‚æœä¸å¼ºåˆ¶åœ¨çº¿çš„è¯å¯ä»¥ç›´æ¥ä½¿ç”¨æ•´ä½“äºŒåˆ†è§£å†³ã€‚ åŒºé—´ä¿®æ”¹ å¦‚æœæ­£å¸¸ä½¿ç”¨æ°¸ä¹…åŒ–çš„è¯å¯ä»¥éå¸¸ç®€å•çš„æ”¯æŒåŒºé—´ä¿®æ”¹ï¼Œæ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[100005]; struct Node &#123; int ls, rs; i64 v, tag; &#125; T[40 * 100005]; int rt[100005], tot; int build(int l, int r) &#123; int o = ++tot; if (l == r) return T[o].v = a[l], o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); T[o].v = T[T[o].ls].v + T[T[o].rs].v; return o; &#125; int update(int pre, int l, int r, int x, int y, int k) &#123; int o = ++tot; T[o] = T[pre]; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].tag += k, T[o].v += (r - l + 1) * k, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[o].ls, l, mid, x, y, k); if (mid &lt; y) T[o].rs = update(T[o].rs, mid + 1, r, x, y, k); T[o].v = T[T[o].ls].v + T[T[o].rs].v + T[o].tag * (r - l + 1); return o; &#125; i64 query(int o, int l, int r, int x, int y, i64 tag) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].v + tag * (r - l + 1); int mid = l + r >> 1; i64 ans = 0; tag += T[o].tag; if (x &lt;= mid) ans += query(T[o].ls, l, mid, x, y, tag); if (mid &lt; y) ans += query(T[o].rs, mid + 1, r, x, y, tag); return ans; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; rt[0] = build(1, n); for (int i = 1, t = 0; i &lt;= m; ++i) &#123; char op; int l, r, k; cin >> op; if (op == 'C') &#123; cin >> l >> r >> k; ++t; rt[t] = update(rt[t - 1], 1, n, l, r, k); &#125; else if (op == 'Q') &#123; cin >> l >> r; cout &lt;&lt; query(rt[t], 1, n, l, r, 0) &lt;&lt; \"\\n\"; &#125; else if (op == 'H') &#123; cin >> l >> r >> k; cout &lt;&lt; query(rt[k], 1, n, l, r, 0) &lt;&lt; \"\\n\"; &#125; else cin >> t; &#125; return 0; &#125; å¯æŒä¹…åŒ– Trie æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤å¯ä»¥åœ¨å¯æŒä¹…åŒ– Trie ä¸­æ’å…¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼š è®¾å½“å‰æ ¹èŠ‚ç‚¹ä¸º xxxï¼ŒåŸºäº preprepre ç‰ˆæœ¬å»ºç«‹ï¼› å…ˆå°† xxx çš„å„¿å­å…¨éƒ¨æŒ‡å‘ preprepre çš„å„¿å­ï¼Œç„¶åå°†è¦æ’å…¥çš„æ•°å€¼æŒ‡å‘ä¸€ä¸ªæ–°å»ºèŠ‚ç‚¹ï¼› åŒæ—¶è®© x,prex,prex,pre å¾€ä¸‹èµ°ï¼Œå¹¶å›åˆ°ç¬¬ 222 æ­¥ç›´åˆ°æ‰«æå®Œæ•´ä¸ªå­—ç¬¦ä¸²ã€‚ å®é™…ä¸Šå¤§éƒ¨åˆ†éœ€è¦ä½¿ç”¨å¯æŒä¹…åŒ– Trie çš„é¢˜ç›®ä¸­ä½¿ç”¨çš„éƒ½æ˜¯å¯æŒä¹…åŒ– 01 Trieã€‚ [Luogu P4735] æœ€å¤§å¼‚æˆ–å’Œã€‚åˆ©ç”¨å·®åˆ†çš„æ€æƒ³ï¼Œæ±‚å‡ºå‰ç¼€å¼‚æˆ–å’Œï¼Œè¿™æ ·å°±æ˜¯æ±‚ xâŠ•s[N]âŠ•a[p](lâˆ’1â‰¤pâ‰¤râˆ’1)x\\oplus s[N]\\oplus a[p](l-1\\le p\\le r-1)xâŠ•s[N]âŠ•a[p](lâˆ’1â‰¤pâ‰¤râˆ’1)ã€‚ç„¶ååœ¨ Trie æ ‘æ’å…¥æ—¶è®°å½• valvalval ä»£è¡¨å½“å‰èŠ‚ç‚¹çš„å‡ºç°æ¬¡æ•°ï¼Œå·®åˆ†çš„æ—¶å€™å°±å¯ä»¥ç›´æ¥ç”¨ä¸¤ä¸ªç‰ˆæœ¬ç›¸å‡å¾—çŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦å‡ºç°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int a[600005], s[600005]; int root[600005], tot, ch[18600005][2], val[18600005]; void insert(int x, int pre, int v) &#123; for (int i = 28; i >= 0; --i) &#123; val[x] = val[pre] + 1; int c = 1 &lt;&lt; i &amp; v ? 1 : 0; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; pre = ch[pre][c]; &#125; val[x] = val[pre] + 1; &#125; int query(int x, int y, int v) &#123; int res = 0; for (int i = 28; i >= 0; --i) &#123; int c = 1 &lt;&lt; i &amp; v ? 1 : 0; if (val[ch[x][!c]] - val[ch[y][!c]]) res |= 1 &lt;&lt; i, x = ch[x][!c], y = ch[y][!c]; else x = ch[x][c], y = ch[y][c]; &#125; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); s[i] = s[i - 1] ^ a[i]; root[i] = ++tot; insert(root[i], root[i - 1], s[i]); &#125; char op[5]; int l, r, x; while (m--) &#123; scanf(\"%s\", op); if (op[0] == 'A') &#123; ++n; scanf(\"%d\", a + n); s[n] = s[n - 1] ^ a[n]; root[n] = ++tot; insert(root[n], root[n - 1], s[n]); &#125; else &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;x); if (l == 1) printf(\"%d\\n\", max(s[n] ^ x, query(root[r - 1], 0, s[n] ^ x))); else printf(\"%d\\n\", query(root[r - 1], root[l - 2], s[n] ^ x)); &#125; &#125; return 0; &#125; å¯æŒä¹…åŒ–å¹³è¡¡æ ‘ å¹³è¡¡æ ‘ä¹Ÿæ˜¯å¯ä»¥æŒä¹…åŒ–çš„ï¼Œè€Œä¸”å¤§éƒ¨åˆ†å¹³è¡¡æ ‘éƒ½å¯ä»¥å¯æŒä¹…åŒ–ã€‚å¦‚æœæ˜¯æ’å…¥åˆ é™¤çš„å¹³è¡¡æ ‘ï¼ˆTreapï¼‰ï¼Œåªéœ€è¦åœ¨ä¿®æ”¹çš„è·¯å¾„ä¸Šå’Œæ—‹è½¬çš„æ—¶å€™å¤åˆ¶ä¸€ä¸‹å³å¯ã€‚å¯¹äºç»´æŠ¤çˆ¶äº²èŠ‚ç‚¹çš„å¹³è¡¡æ ‘å¦‚æœå¯æŒä¹…åŒ–åå¸¸æ•°ä¼šçˆ†ç‚¸ï¼Œæ‰€ä»¥ä¸å¸¸ç”¨ã€‚ å¯¹äºåˆ†è£‚åˆå¹¶çš„å¹³è¡¡æ ‘ï¼Œåªéœ€è¦åœ¨åˆ†è£‚åˆå¹¶æ—¶æ–°å»ºèŠ‚ç‚¹ï¼Œè¿™æ ·éå¸¸æ–¹ä¾¿ã€‚ä¸»è¦çš„ä½œç”¨æ˜¯å¯ä»¥å¤åˆ¶åŒºé—´ï¼Œå…¶å®ƒæ–¹é¢æ„ä¹‰ä¸å¤§ã€‚å› ä¸ºå¯æŒä¹…åŒ– Trie ä¹Ÿå¯ä»¥ç»´æŠ¤æƒå€¼ï¼Œè€Œä¸”è·‘çš„å¾€å¾€æ¯”å¹³è¡¡æ ‘å¿«ã€‚ ä¸€èˆ¬ OI ä¸­èƒ½ç”¨åˆ°çš„åªæœ‰å¯æŒä¹…åŒ– FHQ-Treapã€‚æ¨¡æ¿ï¼Œåœ¨ merge çš„æ—¶å€™ä¹Ÿåº”è¯¥å¤åˆ¶èŠ‚ç‚¹ï¼Œä½†æ˜¯æœ¬é¢˜å¹¶æ²¡æœ‰å•ç‹¬éœ€è¦è°ƒç”¨ merge çš„ï¼Œmerge æ“ä½œåªæ˜¯ä¸ºäº†åˆå¹¶åˆ†è£‚åçš„åºåˆ—ï¼Œå› æ­¤ä¸éœ€è¦å¤åˆ¶æ–°èŠ‚ç‚¹ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 200005; typedef long long i64; mt19937 Rand(time(0)); struct Node &#123; int siz, rnd; i64 sum, val; int ls, rs; bool rev; &#125; T[N * 105]; int tot, root[N]; int newNode(i64 v) &#123; ++tot; T[tot].siz = 1; T[tot].rnd = Rand(); T[tot].sum = T[tot].val = v; return tot; &#125; int copyNode(int x) &#123; T[++tot] = T[x]; return tot; &#125; void pushup(int p) &#123; T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz + 1; T[p].sum = T[T[p].ls].sum + T[T[p].rs].sum + T[p].val; &#125; void pushdown(int p) &#123; if (!T[p].rev) return; if (T[p].ls) T[T[p].ls = copyNode(T[p].ls)].rev ^= 1; if (T[p].rs) T[T[p].rs = copyNode(T[p].rs)].rev ^= 1; swap(T[p].ls, T[p].rs); T[p].rev = 0; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); int o = copyNode(p); pushdown(o); if (T[T[o].ls].siz + 1 &lt;= S) &#123; x = o; split(T[o].rs, S - T[T[o].ls].siz - 1, T[o].rs, y); &#125; else &#123; y = o; split(T[o].ls, S, x, T[o].ls); &#125; pushup(o); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; pushdown(x); T[x].rs = merge(T[x].rs, y); pushup(x); return x; &#125; else &#123; pushdown(y); T[y].ls = merge(x, T[y].ls); pushup(y); return y; &#125; &#125; int main(void) &#123; int m, v, op, p, l, r, a, b, c; scanf(\"%d\", &amp;m); i64 x, last = 0; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", &amp;v, &amp;op); root[i] = root[v]; if (op == 1) &#123; scanf(\"%d%lld\", &amp;p, &amp;x); p ^= last, x ^= last; split(root[i], p, a, b); b = merge(newNode(x), b); root[i] = merge(a, b); &#125; else if (op == 2) &#123; scanf(\"%d\", &amp;p); p ^= last; split(root[i], p - 1, a, b); split(b, 1, b, c); root[i] = merge(a, c); &#125; else if (op == 3) &#123; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; split(root[i], l - 1, a, b); split(b, r - l + 1, b, c); T[b].rev ^= 1; root[i] = merge(a, merge(b, c)); &#125; else &#123; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; split(root[i], l - 1, a, b); split(b, r - l + 1, b, c); printf(\"%lld\\n\", last = T[b].sum); root[i] = merge(a, merge(b, c)); &#125; &#125; return 0; &#125; åµŒå¥—æ•°æ®ç»“æ„ å½“é—®é¢˜ä¸æ˜¯å¼ºåˆ¶åœ¨çº¿æ—¶ï¼Œå¾€å¾€å¯ä»¥ä½¿ç”¨ CDQ åˆ†æ²»æˆ–æ•´ä½“äºŒåˆ†æ¥è§£å†³ã€‚ä¸‹é¢ä»‹ç»çš„åµŒå¥—éƒ½å±äºæ ‘å¥—æ ‘ï¼Œä½†ä¹Ÿæœ‰ä¸æ˜¯æ ‘å¥—æ ‘çš„åµŒå¥—æ•°æ®ç»“æ„ï¼Œæ¯”å¦‚åº•å±‚åˆ†å—å’Œæ ‘å¥— vector ä¹‹ç±»çš„ã€‚åº”ç”¨éå¸¸çµæ´»ï¼Œé¢å¯¹ä¸åŒçš„é—®é¢˜è®¾è®¡åˆé€‚çš„æ•°æ®ç»“æ„å³å¯ã€‚ æ¦‚è¿° æœ€ç®€å•çš„ä¾‹å­æ˜¯æ ‘çŠ¶æ•°ç»„å¥—æ ‘ï¼Œæ¯”å¦‚å¤§å®¶éƒ½å†™è¿‡çš„æ ‘çŠ¶æ•°ç»„å¥—æ ‘çŠ¶æ•°ç»„ï¼š for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= n; j += lowbit(j)) C[i][j] += k; å®é™…ä¸Šè¿™æ˜¯ä»€ä¹ˆï¼Ÿä¸€ä¸ªæ ‘çŠ¶æ•°ç»„é‡Œé¢ä¿å­˜çš„ä¸æ˜¯æ•°ï¼Œè€Œæ˜¯ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ã€‚æ¯”å¦‚è¯´æˆ‘ç°åœ¨è¦æ”¯æŒå•ç‚¹ä¿®æ”¹ï¼ŒæŸ¥è¯¢åŒºé—´ä¸­å°äºç­‰äº yyy çš„æ•°çš„ä¸ªæ•°ï¼Œåªéœ€è¦åƒè¿™æ ·ï¼š void update(int x, int k) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; remove(root[i], a[i]); // å¹³è¡¡æ ‘æ“ä½œ insert(root[i], k); &#125; &#125; int query(int x, int k) &#123; int res = 0; for (int i = x; i; i -= lowbit(i)) res += rank(root[i], y); return res; &#125; ç”±äºåªä¼šè®¿é—®åˆ° logâ¡\\loglog æ£µå¹³è¡¡æ ‘ï¼Œæ‰€ä»¥å•æ¬¡æ“ä½œæ—¶é—´å¤æ‚åº¦ä¸º O(logâ¡2n)O(\\log^2 n)O(log2n)ã€‚ è¿™æ˜¯æä»€ä¹ˆçš„ï¼Ÿæ™®é€šçš„æ ‘çŠ¶æ•°ç»„å¯ä»¥æ”¯æŒå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢å€¼ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¥ç»´æŠ¤ã€‚æ ‘çŠ¶æ•°ç»„å¥—å¹³è¡¡æ ‘ç”¨åˆ°äº†ä¸€ä¸ªå¯ä»¥æ’å…¥åˆ é™¤æŸ¥è¯¢æ’åçš„å¹³è¡¡æ ‘ï¼Œè¿˜éœ€è¦æ”¯æŒåºåˆ—çš„å•ç‚¹ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå¹³è¡¡æ ‘æ•°ç»„æ¥ç»´æŠ¤ã€‚äºæ˜¯å°±æœ‰äº†æ ‘çŠ¶æ•°ç»„å¥—å¹³è¡¡æ ‘ã€‚ çº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘ æ¨¡æ¿ã€‚ç»´æŠ¤ä¸€ä¸ªåºåˆ—ï¼Œæ”¯æŒå•ç‚¹ä¿®æ”¹ï¼ŒæŸ¥è¯¢åŒºé—´æ’åã€åŒºé—´ kthã€åŒºé—´å‰é©±åç»§ã€‚ ç”±äºæŸ¥è¯¢çš„ä¸œè¥¿ä¸å¯ä»¥å·®åˆ†ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨æ ‘çŠ¶æ•°ç»„å¥—æ ‘æ±‚è§£ï¼Œå› æ­¤è€ƒè™‘çº¿æ®µæ ‘å¥—æ ‘ã€‚ æ™®é€šçš„çº¿æ®µæ ‘ç»´æŠ¤æ¯ä¸€ä¸ªåŒºé—´çš„ä¿¡æ¯ï¼Œæ¯æ¬¡ä¿®æ”¹æ›´æ–° logâ¡n\\log nlogn ä¸ªèŠ‚ç‚¹çš„å’Œï¼Œæ¯æ¬¡æŸ¥è¯¢ç”¨ logâ¡n\\log nlogn ä¸ªä¸ç›¸äº¤çš„çº¿æ®µæ¥æ±‚å‡ºç­”æ¡ˆã€‚è€Œçº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘åˆ™æ¯ä¸ªèŠ‚ç‚¹ç”¨ä¸€æ£µå¹³è¡¡æ ‘æ¥å‚¨å­˜å½“å‰èŠ‚ç‚¹æ‰€ä»£è¡¨çš„åŒºé—´çš„ä¿¡æ¯ï¼Œæ¯æ¬¡ä¿®æ”¹æ›´æ–° logâ¡n\\log nlogn æ£µå¹³è¡¡æ ‘ï¼Œæ¯æ¬¡æŸ¥è¯¢ç”¨ logâ¡n\\log nlogn ä¸ªä¸ç›¸äº¤çš„èŠ‚ç‚¹çš„å¹³è¡¡æ ‘æ‹¼å‡ºç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 2147483647; mt19937 Rand(time(0)); struct TreapNode &#123; int ch[2], siz, rnd, cnt; int val; &#125; T[2000005]; int tot; void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + T[p].cnt; &#125; int newNode(int val) &#123; ++tot; T[tot].rnd = Rand(); T[tot].val = val; T[tot].cnt = T[tot].siz = 1; T[tot].ch[0] = T[tot].ch[1] = 0; return tot; &#125; void rotate(int&amp; p, int d) &#123; // d = 0 å·¦æ—‹ï¼Œd = 1 å³æ—‹ int q = T[p].ch[d ^ 1]; T[p].ch[d ^ 1] = T[q].ch[d]; T[q].ch[d] = p; p = q; maintain(T[p].ch[d]); maintain(p); &#125; void insert(int &amp;p, int val) &#123; if (!p) p = newNode(val); else if (val == T[p].val) ++T[p].cnt; else &#123; int d = (val &lt; T[p].val ? 0 : 1); insert(T[p].ch[d], val); if (T[T[p].ch[d]].rnd > T[p].rnd) rotate(p, d ^ 1); &#125; maintain(p); &#125; void Remove(int &amp;p, int val) &#123; if (!p) return; if (val == T[p].val) &#123; if (T[p].cnt > 1) --T[p].cnt; else &#123; if (!T[p].ch[0] &amp;&amp; !T[p].ch[1]) p = 0; else &#123; if (!T[p].ch[0]) rotate(p, 0), Remove(T[p].ch[0], val); else if (!T[p].ch[1]) rotate(p, 1), Remove(T[p].ch[1], val); else &#123; int d = T[T[p].ch[0]].rnd > T[T[p].ch[1]].rnd ? 1 : 0; rotate(p, d); Remove(T[p].ch[d], val); &#125; &#125; &#125; &#125; else Remove(T[p].ch[val &lt; T[p].val ? 0 : 1], val); if (p) maintain(p); &#125; int Rank(int p, int val) &#123; // å°äº val çš„æ•°çš„ä¸ªæ•° if (!p) return 0; if (val &lt; T[p].val) return Rank(T[p].ch[0], val); if (val == T[p].val) return T[T[p].ch[0]].siz; return T[T[p].ch[0]].siz + T[p].cnt + Rank(T[p].ch[1], val); &#125; int GetPre(int p, int k) &#123; if (!p) return -INF; if (T[p].val >= k) return GetPre(T[p].ch[0], k); return max(T[p].val, GetPre(T[p].ch[1], k)); &#125; int GetSuf(int p, int k) &#123; if (!p) return INF; if (T[p].val &lt;= k) return GetSuf(T[p].ch[1], k); return min(T[p].val, GetSuf(T[p].ch[0], k)); &#125; int n, m; int a[50005], root[200005]; void build(int o, int l, int r) &#123; for (int i = l; i &lt;= r; ++i) insert(root[o], a[i]); if (l == r) return; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int o, int l, int r, int x, int k) &#123; Remove(root[o], a[x]); insert(root[o], k); if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); &#125; int queryRank(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return Rank(root[o], k); int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += queryRank(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) res += queryRank(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); return res; &#125; int queryPre(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return GetPre(root[o], k); int mid = l + r >> 1, res = -INF; if (x &lt;= mid) res = max(res, queryPre(o &lt;&lt; 1, l, mid, x, y, k)); if (mid &lt; y) res = max(res, queryPre(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k)); return res; &#125; int querySuf(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return GetSuf(root[o], k); int mid = l + r >> 1, res = INF; if (x &lt;= mid) res = min(res, querySuf(o &lt;&lt; 1, l, mid, x, y, k)); if (mid &lt; y) res = min(res, querySuf(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k)); return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); while (m--) &#123; int op, l, r, pos, k; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", queryRank(1, 1, n, l, r, k) + 1); &#125; else if (op == 2) &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); // æ’åä¸º k çš„æ•° int L = -1, R = 100000001; while (L + 1 != R) &#123; int mid = L + R >> 1; if (queryRank(1, 1, n, l, r, mid) &lt; k) L = mid; else R = mid; &#125; printf(\"%d\\n\", L); &#125; else if (op == 3) &#123; scanf(\"%d%d\", &amp;pos, &amp;k); update(1, 1, n, pos, k); a[pos] = k; &#125; else if (op == 4) &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", queryPre(1, 1, n, l, r, k)); &#125; else &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", querySuf(1, 1, n, l, r, k)); &#125; &#125; return 0; &#125; è¿™æ ·ä¼šå¯¼è‡´åœ¨æŸ¥è¯¢åŒºé—´æ’åä¸º kkk çš„æ•°æ—¶éœ€è¦äºŒåˆ†å‡ºç­”æ¡ˆã€‚å¦‚æœæƒ³è¦é¿å…ï¼Œå¯ä»¥é‡‡ç”¨åŠ¨æ€å¼€ç‚¹æƒå€¼çº¿æ®µæ ‘å¥— FHQï¼Œå¤–å±‚ç»´æŠ¤æƒå€¼ï¼Œå†…å±‚ç»´æŠ¤ä½ç½®ï¼ˆå¯ä»¥é€šè¿‡æ ¹æ®å¤§å°çš„åˆ†è£‚æ¥å¿«é€Ÿæ±‚å‡ºåœ¨ä½ç½®åŒºé—´ [l,r][l,r][l,r] å†…çš„æ•°çš„ä¸ªæ•°ï¼‰ï¼Œè¿™æ ·å¯ä»¥ç›´æ¥åœ¨æƒå€¼çº¿æ®µæ ‘ä¸ŠäºŒåˆ†å‡ºç­”æ¡ˆã€‚ äºŒç»´çº¿æ®µæ ‘ ä¸åŒæ ‘å¥—æ ‘çš„ä¼˜åŠ£ ä¸ç®¡æ˜¯ä»€ä¹ˆæ ‘å¥—æ ‘ï¼Œå¸¸æ•°éƒ½æ˜¯å·¨å¤§çš„ï¼ˆå› ä¸ºçº¿æ®µæ ‘å’Œå¹³è¡¡æ ‘éƒ½å¾ˆæ…¢ï¼‰ã€‚ä¸‹é¢æˆ‘ä»¬æ¥å¯¹æ¯”ä¸€ä¸‹ä¸åŒçš„æ ‘å¥—æ ‘ï¼š Problemset å‰é¢æ˜¯ä¸€äº›åŸºç¡€é¢˜ï¼Œæœ€åéƒ¨åˆ†æ”¾äº†ä¸€äº›ç»¼åˆåº”ç”¨ã€‚ å¯æŒä¹…åŒ–æ•°æ®ç»“æ„ ä¸€äº›åŸºç¡€é¢˜ã€‚ [POI2014] KUR-Couriers Portal. å»ºç«‹ä¸»å¸­æ ‘ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¦‚æœåœ¨ [l,mid][l,mid][l,mid] çš„å€¼åŸŸçš„æ•°çš„ä¸ªæ•°å¤§äºè¦æ±‚çš„æ•°é‡ï¼Œé‚£ä¹ˆå°±åˆ°å·¦å­æ ‘æŸ¥è¯¢ï¼Œå³å­æ ‘åŒç†ï¼Œå¦åˆ™å°±æ˜¯æ— è§£ã€‚å› ä¸ºå³å­æ ‘çš„å€¼åŸŸåŒºé—´å¤§å°åªèƒ½æ¯”å·¦å­æ ‘çš„å€¼åŸŸåŒºé—´å¤§å°å°æˆ–è€…ç›¸ç­‰ï¼Œæ‰€ä»¥å½“è½åœ¨å·¦å­æ ‘å€¼åŸŸçš„æ•°çš„ä¸ªæ•°æ»¡è¶³é™åˆ¶æ¡ä»¶æ—¶ï¼Œå³å­æ ‘å°±ä¸å¯èƒ½æ»¡è¶³äº†ï¼Œå°±ä¸ç”¨æŸ¥è¯¢äº†ã€‚ æ³¨æ„ï¼ç”±äºè¿™é¢˜çš„æœ€ä¼˜åšæ³•å¹¶ä¸æ˜¯ä¸»å¸­æ ‘ï¼Œæ‰€ä»¥ä¸»å¸­æ ‘ä¼šè¢«å¡ç©ºé—´ã€‚åˆå§‹ç‰ˆæœ¬æ˜¯ä¸èƒ½è¢«å»ºç«‹çš„ã€‚è¦ä½¿ç”¨å¦‚ä»£ç ä¸­æ‰€ç¤ºçš„æ–¹æ³•ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;cstdio> const int MAXN = 500000; int read(void) &#123; int x = 0, c = getchar(); while (c &lt; '0' || c > '9') c = getchar(); while (c >= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x; &#125; struct Node &#123; int lc, rc, dat; &#125;T[21 * MAXN + 480000]; int tot = 0, root[MAXN + 1]; int build(int l, int r) &#123; int o = tot++; if (l == r) return o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); return o; &#125; void update(int &amp;now, int l, int r, int x) // æ³¨æ„ now æ˜¯å¼•ç”¨ï¼Œä¼šè¢«æ›´æ–° &#123; T[++tot] = T[now]; now = tot; T[tot].dat++; if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(T[now].lc, l, mid, x); else update(T[now].rc, mid + 1, r, x); &#125; int k; int query(int p, int q, int l, int r) &#123; if (l == r) return l; int mid = l + r >> 1; if (2 * (T[T[q].lc].dat - T[T[p].lc].dat) > k) return query(T[p].lc, T[q].lc, l, mid); if (2 * (T[T[q].rc].dat - T[T[p].rc].dat) > k) return query(T[p].rc, T[q].rc, mid + 1, r); return 0; &#125; int main(void) &#123; int n, m, l, r, x; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) &#123; root[i] = root[i - 1]; update(root[i], 1, n, read()); // ç›´æ¥ä¿®æ”¹ &#125; while (m--) &#123; l = read(), r = read(); k = r - l + 1; printf(\"%d\\n\", query(root[l - 1], root[r], 1, n)); &#125; return 0; &#125; [CF840D] Destiny Portal. ä¹ä¸€çœ‹è·Ÿä¸Šä¸€é¢˜å¾ˆåƒï¼Œä½†æ˜¯æ— æ³•ä¿è¯å¦‚æœå·¦å­æ ‘æ²¡æœ‰ç­”æ¡ˆå³å­æ ‘å°±ä¸€å®šæ²¡æœ‰ã€‚å› æ­¤è€ƒè™‘å·¦å­æ ‘æ»¡è¶³æ¡ä»¶æ²¡æœ‰ç­”æ¡ˆæ—¶å†åˆ°å³å­æ ‘æŸ¥è¯¢ã€‚ æ…¢ç€ï¼è¿™æ ·å¤æ‚åº¦ä¸ä¼šå˜æˆ O(nlogâ¡n)O(n\\log n)O(nlogn) å—ï¼Ÿä¸ä¼šï¼æ³¨æ„åˆ° kâ‰¤5k\\le 5kâ‰¤5ï¼Œå¤æ‚åº¦å¯ä»¥å‡æ‘Šï¼Œå·¦å­æ ‘æ»¡è¶³æ¡ä»¶ä½†æ˜¯æ²¡æœ‰ç­”æ¡ˆçš„äº‹æƒ…æœ€å¤šå‘ç”Ÿ kkk æ¬¡ï¼Œæ•°å°±ä¼šè¢«ç”¨å®Œã€‚å› æ­¤å•æ¬¡è¯¢é—®çš„å¤æ‚åº¦æ˜¯ O(knlogâ¡n)O(kn\\log n)O(knlogn) çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct Node &#123; int ls, rs; int val; &#125; T[45 * 300005]; int root[300005], tot; int n, m, len, k; int a[300005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return T[o].val += k, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x, k); else T[o].rs = update(T[pre].rs, mid + 1, r, x, k); T[o].val = T[T[o].ls].val + T[T[o].rs].val; return o; &#125; int query(int p, int q, int l, int r) &#123; if (l == r) return l; int mid = l + r >> 1; if (k * (T[T[q].ls].val - T[T[p].ls].val) > len) &#123; int res = query(T[p].ls, T[q].ls, l, mid); if (res != -1) return res; &#125; if (k * (T[T[q].rs].val - T[T[p].rs].val) > len) return query(T[p].rs, T[q].rs, mid + 1, r); return -1; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); root[0] = build(1, n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), root[i] = update(root[i - 1], 1, n, a[i], 1); while (m--) &#123; int l, r; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); len = r - l + 1; printf(\"%d\\n\", query(root[l - 1], root[r], 1, n)); &#125; return 0; &#125; [Luogu P2633] Count on a tree Portal. åˆ©ç”¨æ ‘ä¸Šå·®åˆ†çš„æ€æƒ³ï¼ŒåŒæ—¶æŸ¥è¯¢å››ä¸ªç‰ˆæœ¬çš„ä¸»å¸­æ ‘ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, q, a[100005], b[100005]; vector&lt;int> G[100005]; struct Node &#123; int ls, rs; int dat; &#125; T[100005 * 36]; int tot, root[100005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return ++T[o].dat, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x); else T[o].rs = update(T[pre].rs, mid + 1, r, x); T[o].dat = T[T[o].ls].dat + T[T[o].rs].dat; return o; &#125; int query(int u, int v, int lca, int fa, int l, int r, int k) &#123; if (l == r) return l; int mid = l + r >> 1, res = T[T[u].ls].dat + T[T[v].ls].dat - T[T[lca].ls].dat - T[T[fa].ls].dat; if (k &lt;= res) return query(T[u].ls, T[v].ls, T[lca].ls, T[fa].ls, l, mid, k); return query(T[u].rs, T[v].rs, T[lca].rs, T[fa].rs, mid + 1, r, k - res); &#125; int dfn[100005], siz[100005], top[100005], num; int son[100005], dep[100005], f[100005]; void dfs1(int x, int fa) &#123; root[x] = update(root[fa], 1, m, a[x]); f[x] = fa; dep[x] = dep[fa] + 1; siz[x] = 1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (!son[x]) return; dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(1, 0); dfs2(1, 1); int u, v, k, lca, last = 0; while (q--) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;k); u ^= last; lca = LCA(u, v); printf(\"%d\\n\", last = b[query(root[u], root[v], root[lca], root[f[lca]], 1, m, k)]); &#125; return 0; &#125; [P4137] Rmq Problem / mex Portal. è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨ jjj åœ¨ â‰¤i\\le iâ‰¤i çš„ä½ç½®ä¸­çš„æœ€å¤§å‡ºç°ä½ç½®ï¼Œé‚£ä¹ˆç›¸å½“äºæ±‚ fi,j&lt;lf_{i,j}&lt;lfi,jâ€‹&lt;l çš„æœ€å° jjjï¼Œä¸»å¸­æ ‘äºŒåˆ†æˆ–ç¦»çº¿æ‰«æã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 200003; int n, m; struct Node &#123; int ls, rs; int dat; &#125; T[40 * 200005]; int rt[200005], tot; void update(int &amp;o, int pre, int l, int r, int x, int v) &#123; T[o = ++tot] = T[pre]; if (l == r) return T[o].dat = v, void(); int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, T[pre].ls, l, mid, x, v); else update(T[o].rs, T[pre].rs, mid + 1, r, x, v); T[o].dat = min(T[T[o].ls].dat, T[T[o].rs].dat); &#125; int query(int o, int l, int r, int v) &#123; if (l == r) return l; int mid = l + r >> 1; if (T[T[o].ls].dat >= v) return query(T[o].rs, mid + 1, r, v); return query(T[o].ls, l, mid, v); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), update(rt[i], rt[i - 1], 1, N, ++x, i); while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d\\n\", query(rt[r], 1, N, l) - 1); &#125; return 0; &#125; [CF1771F] Hossam and Range Minimum Query Portal. å¯æŒä¹…åŒ–é™æ‰åºåˆ—ç»´ï¼Œç»™æ¯ä¸€ä¸ªæ•°éšæœºä¸€ä¸ªæƒå€¼ï¼Œæƒå€¼çº¿æ®µæ ‘ç»´æŠ¤éšæœºæƒå€¼çš„å¼‚æˆ–å’Œï¼Œè¿™æ ·å¯ä»¥ç›´æ¥åˆ¤æ–­å€¼åŸŸå†…æ˜¯å¦æœ‰å‡ºç°æ¬¡æ•°ä¸ºå¥‡æ•°çš„æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int a[200005], b[200005]; map&lt;int, int> mp; mt19937 Rand(time(0)); struct Node &#123; int ls, rs, dat; &#125; T[200005 * 45]; int rt[200005], tot; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; T[o].dat ^= k; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x, k); else T[o].rs = update(T[pre].rs, mid + 1, r, x, k); return o; &#125; int query(int p, int q, int l, int r) &#123; if (l == r) return T[p].dat ^ T[q].dat ? l : 0; int mid = l + r >> 1; if (T[T[p].ls].dat ^ T[T[q].ls].dat) return query(T[p].ls, T[q].ls, l, mid); return query(T[p].rs, T[q].rs, mid + 1, r); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; if (!mp.count(a[i])) mp[a[i]] = Rand(); rt[i] = update(rt[i - 1], 1, nn, a[i], mp[a[i]]); &#125; scanf(\"%d\", &amp;m); for (int last = 0; m--; ) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; printf(\"%d\\n\", last = b[query(rt[l - 1], rt[r], 1, nn)]); &#125; return 0; &#125; [TJOI2018] å¼‚æˆ– Portal. é’ˆå¯¹ DFS åºå’Œæ ‘ä¸Šå‰ç¼€å’Œå»ºç«‹ä¸¤æ£µå¯æŒä¹…åŒ– 01 Trieï¼Œä¸åŒè¯¢é—®åœ¨ä¸åŒ Trie ä¸ŠæŸ¥è¯¢ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, q, a[100005]; vector&lt;int> G[100005]; int rt1[100005], rt2[100005], tot, val[6200005], ch[6200005][2]; void insert(int x, int pre, int v) &#123; for (int i = 29; i >= 0; --i) &#123; val[x] = val[pre] + 1; int c = 1 &lt;&lt; i &amp; v ? 1 : 0; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; pre = ch[pre][c]; &#125; val[x] = val[pre] + 1; &#125; int query(int x, int y, int v) &#123; int res = 0; for (int i = 29; i >= 0; --i) &#123; int c = 1 &lt;&lt; i &amp; v ? 1 : 0; if (val[ch[x][!c]] - val[ch[y][!c]]) res |= 1 &lt;&lt; i, x = ch[x][!c], y = ch[y][!c]; else x = ch[x][c], y = ch[y][c]; &#125; return res; &#125; int dep[100005], f[100005], siz[100005]; int top[100005], son[100005], dfn[100005], num; void dfs1(int x, int fa) &#123; dep[x] = dep[f[x] = fa] + 1; siz[x] = 1; insert(rt2[x] = ++tot, rt2[f[x]], a[x]); for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; top[x] = topf; dfn[x] = ++num; insert(rt1[num] = ++tot, rt1[num - 1], a[x]); if (!son[x]) return; dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(1, 0); dfs2(1, 1); while (q--) &#123; int op, x, y, z; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) printf(\"%d\\n\", query(rt1[dfn[x] + siz[x] - 1], rt1[dfn[x] - 1], y)); else &#123; scanf(\"%d\", &amp;z); int rl = rt2[f[LCA(x, y)]]; printf(\"%d\\n\", max(query(rt2[x], rl, z), query(rt2[y], rl, z))); &#125; &#125; return 0; &#125; [THUSC2015] å¼‚æˆ–è¿ç®— Portal. å°†æ±‚ç¬¬ kkk å¤§è½¬åŒ–ä¸º kkk å°ï¼Œçœ‹ä¸€ä¸‹ n=1n=1n=1 æ€ä¹ˆåšï¼Ÿå¯¹ YYY å»ºç«‹å¯æŒä¹…åŒ– 01 Trieï¼Œç„¶åæ‹¿ç€ X[1]X[1]X[1] å¼€å§‹ä»é«˜åˆ°ä½ä½å¼€å§‹è´ªå¿ƒã€‚ç­”æ¡ˆçš„è¿™ä¸€äºŒè¿›åˆ¶ä½èƒ½å–åˆ° 000 çš„ä¸ªæ•°å¦‚æœå°äº kkkï¼Œé‚£ä¹ˆè¿™ä¸€ä½å°±éœ€è¦å– 111ï¼Œç„¶åä»¤ kkk å‡å»è¿™ä¸ªä¸ªæ•°ï¼›å¦åˆ™è¿™ä¸€ä½å– 000ã€‚ å‘ç° n,qn,qn,q éƒ½ä¸æ˜¯å¾ˆå¤§ï¼Œå› æ­¤å¯¹äº n&gt;1n&gt;1n&gt;1 ç›´æ¥æš´åŠ›æ‰«ä¸€éï¼ŒæŠŠæ€»å’ŒåŠ èµ·æ¥è·Ÿ kkk æ¯”å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, q; int a[1005], b[300005]; int root[300005], ch[10000005][2], tot, val[10000005]; void insert(int x, int pre, int v) &#123; for (int i = 30; i >= 0; --i) &#123; int c = v >> i &amp; 1; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c], pre = ch[pre][c]; val[x] = val[pre] + 1; &#125; &#125; int x[1005], y[1005]; int query(int u, int d, int l, int r, int k) &#123; int ans = 0; for (int i = u; i &lt;= d; ++i) x[i] = root[l - 1], y[i] = root[r]; for (int i = 30; i >= 0; --i) &#123; int cnt = 0; for (int j = u; j &lt;= d; ++j) &#123; int c = a[j] >> i &amp; 1; cnt += val[ch[y[j]][c]] - val[ch[x[j]][c]]; &#125; int nxt = k &lt;= cnt ? 0 : 1; if (nxt) k -= cnt, ans |= 1 &lt;&lt; i; for (int j = u; j &lt;= d; ++j) &#123; int c = (a[j] >> i &amp; 1) ^ nxt; x[j] = ch[x[j]][c], y[j] = ch[y[j]][c]; &#125; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d\", b + i); root[i] = ++tot; insert(root[i], root[i - 1], b[i]); &#125; scanf(\"%d\", &amp;q); while (q--) &#123; int u, d, l, r, k; scanf(\"%d%d%d%d%d\", &amp;u, &amp;d, &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", query(u, d, l, r, (d - u + 1) * (r - l + 1) - k + 1)); &#125; return 0; &#125; [CF1665E] MinimizOR Portal. å¦‚ä½•å¤„ç†æˆ–çš„æœ€å°å€¼å‘¢ï¼Ÿå¦‚æœå‡ºç°äº†ä¸¤ä¸ªä»¥ä¸Šçš„ 000ï¼Œé‚£ä¹ˆè¿™ä¸€ä½æ˜¾ç„¶å¡« 000ï¼›å¦‚æœæ²¡æœ‰ 000 å‡ºç°ï¼Œåˆ™å¡« 111ï¼›æœ‰ä¸€ä¸ª 000 å‘¢ï¼Ÿæ‰¾åˆ°è¿™ä¸ª 000 çš„ä½ç½®ï¼Œè®©å®ƒè‡ªå·±å¾€ 000 èµ°ï¼ŒåŒæ—¶æä¸¤ä¸ªå„¿å­å°±å¥½äº†ã€‚åªä¼šå¢åŠ  logâ¡\\loglog æ¬¡èŠ‚ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡2V)O(n\\log^2 V)O(nlog2V)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int a[100005], rt[100005]; int ch[10000005][2], val[10000005], tot; void insert(int x, int pre, int v) &#123; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; ch[x][!c] = ch[pre][!c]; ch[x][c] = ++tot; x = ch[x][c]; pre = ch[pre][c]; val[x] = val[pre] + 1; &#125; &#125; int query(vector&lt;pair&lt;int, int>> v, int dep) &#123; if (dep == -1) return 0; int sum = 0; pair&lt;int, int> p(-1, -1); for (auto&amp; [x, y] : v) &#123; sum += val[ch[y][0]] - val[ch[x][0]]; if (val[ch[y][0]] - val[ch[x][0]] > 0) p = make_pair(x, y); &#125; if (sum >= 2) &#123; for (auto&amp; [x, y] : v) x = ch[x][0], y = ch[y][0]; return query(v, dep - 1); &#125; for (auto&amp; [x, y] : v) x = ch[x][1], y = ch[y][1]; if (sum == 1) v.emplace_back(ch[p.first][0], ch[p.second][0]); return query(v, dep - 1) + (1 &lt;&lt; dep); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), insert(rt[i] = ++tot, rt[i - 1], a[i]); for (scanf(\"%d\", &amp;m); m--; ) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); vector&lt;pair&lt;int, int>> v; v.emplace_back(rt[l - 1], rt[r]); printf(\"%d\\n\", query(v, 29)); &#125; for (int i = 1; i &lt;= tot; ++i) ch[i][0] = ch[i][1] = val[i] = 0; tot = 0; &#125; return 0; &#125; [Luogu P7834] Peaks Portal. ç»è¿‡æƒå€¼ â‰¤x\\le xâ‰¤x çš„è¾¹èƒ½å¤Ÿåˆ°è¾¾çš„ç‚¹æ˜¯ Kruskal é‡æ„æ ‘ä¸ŠæŸä¸ªå­æ ‘å†…çš„ç‚¹ï¼Œè€Œå­æ ‘ä¸Šçš„ kkk å¤§ç‚¹å¯ä»¥é€šè¿‡ DFS åºè½¬æ¢åˆ°åºåˆ—ä¸Šä½¿ç”¨ä¸»å¸­æ ‘å¤„ç†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, A, nn, m, q, a[200005], b[100005]; struct edge &#123; int u, v, d; bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125; e[500005]; struct UnionFind &#123; int fa[200005]; void init(void) &#123; for (int i = 1; i &lt;= n * 2; ++i) fa[i] = i; &#125; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; &#125; US; int val[200005]; vector&lt;int> G[200005]; void addedge(int x, int y) &#123; G[x].emplace_back(y); G[y].emplace_back(x); &#125; int f[21][200005], dfn[200005], siz[200005], num, idx[200005]; void dfs(int x, int fa) &#123; f[0][x] = fa; siz[x] = 1; idx[dfn[x] = ++num] = x; for (int i = 1; i &lt;= 20; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x), siz[x] += siz[y]; &#125; void Kruskal(void) &#123; sort(e + 1, e + m + 1); US.init(); A = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v, w = e[i].d; int x = US.find(e[i].u), y = US.find(e[i].v); if (x == y) continue; val[++A] = w; US.fa[x] = US.fa[y] = A; addedge(x, A); addedge(y, A); &#125; for (int i = 1; i &lt;= A; ++i) if (US.fa[i] == i) dfs(i, 0); &#125; struct Node &#123; int lc, rc; int val; &#125; T[2200005]; int tot, root[200005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; if (!x) return pre; int o = ++tot; T[o] = T[pre]; T[o].val += 1; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].lc = update(T[pre].lc, l, mid, x); else T[o].rc = update(T[pre].rc, mid + 1, r, x); return o; &#125; int query(int x, int y, int l, int r, int k) &#123; if (l == r) return l; if (T[y].val - T[x].val &lt; k) return 0; int mid = l + r >> 1, res = T[T[y].rc].val - T[T[x].rc].val; if (res >= k) return query(T[x].rc, T[y].rc, mid + 1, r, k); return query(T[x].lc, T[y].lc, l, mid, k - res); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].d); Kruskal(); root[0] = build(1, nn); for (int i = 1; i &lt;= A; ++i) root[i] = update(root[i - 1], 1, nn, a[idx[i]]); for (int last = 0; q--; ) &#123; int u, x, k; scanf(\"%d%d%d\", &amp;u, &amp;x, &amp;k); u = (u ^ last) % n + 1, x = x ^ last, k = (k ^ last) % n + 1; for (int i = 20; i >= 0; --i) if (f[i][u] &amp;&amp; val[f[i][u]] &lt;= x) u = f[i][u]; printf(\"%d\\n\", (last = b[query(root[dfn[u] - 1], root[dfn[u] + siz[u] - 1], 1, nn, k)]) ? last : -1); &#125; return 0; &#125; [CF1777F] Comfortably Numb Portal. æ‰¾å‡ºåºåˆ—ä¸­æƒå€¼æœ€å¤§çš„ä½ç½®ï¼Œç­”æ¡ˆåŒºé—´è¦ä¹ˆåœ¨å®ƒå·¦ä¾§æˆ–å³ä¾§ï¼Œè¦ä¹ˆè·¨è¶ŠåŒºé—´ã€‚åˆå¹¶æ—¶é‡‡ç”¨å¯å‘å¼åˆå¹¶çš„æ€æƒ³ï¼Œæšä¸¾å°åŒºé—´ä¸­çš„ä¸‹æ ‡ï¼Œå°±æ˜¯è¦åœ¨å¤§åŒºé—´ä¸­æ‰¾ä¸€ä¸ªå¼‚æˆ–å€¼æœ€å¤§çš„ï¼Œå¯ä»¥ä½¿ç”¨å¯æŒä¹…åŒ– 01 Trie è§£å†³ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int a[200005], f[21][200005], lg[200005], s[200005]; int ch[6400005][2], tot, root[200005], val[6400005]; int qmax(int l, int r) &#123; int k = lg[r - l + 1]; if (a[f[k][l]] > a[f[k][r - (1 &lt;&lt; k) + 1]]) return f[k][l]; return f[k][r - (1 &lt;&lt; k) + 1]; &#125; void insert(int x, int pre, int v) &#123; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c], pre = ch[pre][c]; val[x] = val[pre] + 1; &#125; &#125; int query(int x, int y, int v) &#123; int res = 0; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; if (val[ch[y][!c]] - val[ch[x][!c]]) x = ch[x][!c], y = ch[y][!c], res |= 1 &lt;&lt; i; else x = ch[x][c], y = ch[y][c]; &#125; return res; &#125; int merge(int l, int r) &#123; if (l >= r) return 0; int mid = qmax(l, r), ans = max(merge(l, mid - 1), merge(mid + 1, r)); if (r - mid &lt; mid - l) &#123; // å°†å³åŠæ®µåˆå¹¶åˆ°å·¦åŠæ®µ for (int i = mid; i &lt;= r; ++i) // æšä¸¾å³ç«¯ç‚¹ ans = max(ans, query(l > 1 ? root[l - 2] : 0, root[mid - 1], a[mid] ^ s[i])); &#125; else &#123; for (int i = l; i &lt;= mid; ++i) // æšä¸¾å·¦ç«¯ç‚¹ ans = max(ans, query(root[mid - 1], root[r], a[mid] ^ s[i - 1])); &#125; return ans; &#125; void solve(void) &#123; for (int i = 0; i &lt;= tot; ++i) ch[i][0] = ch[i][1] = val[i] = 0; cin >> n; tot = 0; for (int i = 1; i &lt;= n; ++i) cin >> a[i], f[0][i] = i, s[i] = s[i - 1] ^ a[i]; for (int i = 0; i &lt;= n; ++i) &#123; root[i] = ++tot; insert(root[i], i == 0 ? 0 : root[i - 1], s[i]); &#125; for (int j = 1; 1 &lt;&lt; j &lt;= n; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) if (a[f[j - 1][i]] > a[f[j - 1][i + (1 &lt;&lt; j - 1)]]) f[j][i] = f[j - 1][i]; else f[j][i] = f[j - 1][i + (1 &lt;&lt; j - 1)]; cout &lt;&lt; merge(1, n) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; for (int i = 2; i &lt;= 200000; ++i) lg[i] = lg[i >> 1] + 1; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; [Luogu P5586] åºåˆ— Portal. è¿™æ˜¯å¯æŒä¹…åŒ–å¹³è¡¡æ ‘æœ€ç»å…¸çš„åº”ç”¨ï¼šåŒºé—´å¤åˆ¶ã€‚å› ä¸ºå¯æŒä¹…åŒ–å¹³è¡¡æ ‘åœ¨åˆå¹¶æ—¶ä¼šå¤åˆ¶è¦åˆå¹¶çš„èŠ‚ç‚¹ï¼Œå› æ­¤å¯ä»¥æ”¯æŒåŒºé—´å¤åˆ¶ã€‚å¦å¤–ç”±äºå¯æŒä¹…åŒ–å¹³è¡¡æ ‘ç©ºé—´å¼€é”€è¿‡å¤§ï¼Œéœ€è¦å®šæ—¶é‡æ„æ•´æ£µå¹³è¡¡æ ‘ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; mt19937 Rand(time(0)); struct Node &#123; int setv, addv; bool rev; int val, sum, ls, rs, siz; &#125; T[8200005]; int root, tot, a[300005], num; inline void pushup(int p) &#123; T[p].sum = (0ll + T[T[p].ls].sum + T[T[p].rs].sum + T[p].val) % MOD; T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz + 1; &#125; inline int newNode(int x) &#123; int p = ++tot; T[p].setv = -1; T[p].ls = T[p].rs = T[p].addv = T[p].rev = 0; T[p].val = T[p].sum = x; T[p].siz = 1; return p; &#125; inline int copyNode(int x) &#123; T[++tot] = T[x]; return tot; &#125; inline void rever(int p) &#123; swap(T[p].ls, T[p].rs); T[p].rev ^= 1; &#125; inline void cover(int p, int k) &#123; T[p].addv = T[p].rev = 0; T[p].setv = T[p].val = k; T[p].sum = 1ll * T[p].siz * k % MOD; &#125; inline void add(int p, int k) &#123; T[p].addv = (T[p].addv + k) % MOD; T[p].val = (T[p].val + k) % MOD; T[p].sum = (T[p].sum + 1ll * k * T[p].siz) % MOD; &#125; inline void pushdown(int p) &#123; if (!p) return; if (T[p].ls) T[p].ls = copyNode(T[p].ls); if (T[p].rs) T[p].rs = copyNode(T[p].rs); if (T[p].setv != -1) &#123; if (T[p].ls) cover(T[p].ls, T[p].setv); if (T[p].rs) cover(T[p].rs, T[p].setv); T[p].setv = -1; &#125; if (T[p].rev) &#123; if (T[p].ls) rever(T[p].ls); if (T[p].rs) rever(T[p].rs); T[p].rev = 0; &#125; if (T[p].addv) &#123; if (T[p].ls) add(T[p].ls, T[p].addv); if (T[p].rs) add(T[p].rs, T[p].addv); T[p].addv = 0; &#125; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); p = copyNode(p); pushdown(p); if (T[T[p].ls].siz + 1 &lt;= S) &#123; x = p; split(T[p].rs, S - T[T[p].ls].siz - 1, T[p].rs, y); &#125; else &#123; y = p; split(T[p].ls, S, x, T[p].ls); &#125; pushup(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].siz > T[y].siz) &#123; x = copyNode(x); pushdown(x); T[x].rs = merge(T[x].rs, y); pushup(x); return x; &#125; else &#123; y = copyNode(y); pushdown(y); T[y].ls = merge(x, T[y].ls); pushup(y); return y; &#125; &#125; int build(int l, int r) &#123; if (l > r) return 0; int mid = l + r >> 1; int p = newNode(a[mid]); T[p].ls = build(l, mid - 1); T[p].rs = build(mid + 1, r); pushup(p); return p; &#125; void dfs(int p) &#123; pushdown(p); if (T[p].ls) dfs(T[p].ls); a[++num] = T[p].val; if (T[p].rs) dfs(T[p].rs); &#125; int main(void) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); root = build(1, n); int v, w, x, y, z, last = 0; while (m--) &#123; int op; scanf(\"%d\", &amp;op); if (op == 1) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; split(root, l - 1, x, y); split(y, r - l + 1, y, z); printf(\"%d\\n\", last = T[y].sum); root = merge(x, merge(y, z)); &#125; else if (op == 2) &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); l ^= last, r ^= last; k ^= last; split(root, l - 1, x, y); split(y, r - l + 1, y, z); cover(y, k); root = merge(x, merge(y, z)); &#125; else if (op == 3) &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); l ^= last, r ^= last; k ^= last; split(root, l - 1, x, y); split(y, r - l + 1, y, z); add(y, k); root = merge(x, merge(y, z)); &#125; else if (op == 4) &#123; int l1, r1, l2, r2, flag = 1; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); l1 ^= last; r1 ^= last; l2 ^= last; r2 ^= last; if (r1 > r2) swap(l1, l2), swap(r1, r2), flag = 0; split(root, r2, y, z); split(y, l2 - 1, x, y); split(x, r1, w, x); split(w, l1 - 1, v, w); if (flag) root = merge(v, merge(w, merge(x, merge(w, z)))); else root = merge(v, merge(y, merge(x, merge(y, z)))); &#125; else if (op == 5) &#123; int l1, r1, l2, r2; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); l1 ^= last; r1 ^= last; l2 ^= last; r2 ^= last; if (r1 > r2) swap(l1, l2), swap(r1, r2); split(root, r2, y, z); split(y, l2 - 1, x, y); split(x, r1, w, x); split(w, l1 - 1, v, w); root = merge(v, merge(y, merge(x, merge(w, z)))); &#125; else &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; split(root, l - 1, x, y); split(y, r - l + 1, y, z); rever(y); root = merge(x, merge(y, z)); &#125; if (tot > 7000000) &#123; num = 0; dfs(root); tot = 0; root = build(1, n); &#125; &#125; num = 0; dfs(root); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); return 0; &#125; ã€æ¨¡æ¿ã€‘å¯æŒä¹…åŒ–å¹³è¡¡æ ‘ Portal. å°±æ˜¯æ™®é€šçš„å¯æŒä¹…åŒ– FHQ-Treapã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 500005; typedef long long i64; mt19937 Rand(time(0)); struct Node &#123; int siz, rnd; int ls, rs; int val; &#125; T[N * 105]; int tot, root[N]; int newNode(i64 v) &#123; ++tot; T[tot].siz = 1; T[tot].rnd = Rand(); T[tot].val = v; return tot; &#125; int copyNode(int x) &#123; T[++tot] = T[x]; return tot; &#125; void pushup(int p) &#123; T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz + 1; &#125; void split(int p, int k, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); int o = copyNode(p); if (T[o].val &lt;= k) &#123; x = o; split(T[o].rs, k, T[o].rs, y); &#125; else &#123; y = o; split(T[o].ls, k, x, T[o].ls); &#125; pushup(o); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; x = copyNode(x); T[x].rs = merge(T[x].rs, y); pushup(x); return x; &#125; else &#123; y = copyNode(y); T[y].ls = merge(x, T[y].ls); pushup(y); return y; &#125; &#125; int kth(int p, int k) &#123; while (p) &#123; if (T[T[p].ls].siz + 1 == k) break; else if (T[T[p].ls].siz + 1 > k) p = T[p].ls; else &#123; k -= T[T[p].ls].siz + 1; p = T[p].rs; &#125; &#125; return T[p].val; &#125; int main(void) &#123; int q; scanf(\"%d\", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; int op, v, x, a, b, c; scanf(\"%d%d%d\", &amp;v, &amp;op, &amp;x); root[i] = root[v]; if (op == 1) &#123; split(root[i], x, a, b); root[i] = merge(a, merge(newNode(x), b)); &#125; else if (op == 2) &#123; split(root[i], x - 1, a, b); split(b, x, b, c); b = merge(T[b].ls, T[b].rs); root[i] = merge(a, merge(b, c)); &#125; else if (op == 3) &#123; split(root[i], x - 1, a, b); printf(\"%d\\n\", T[a].siz + 1); root[i] = merge(a, b); &#125; else if (op == 4) printf(\"%d\\n\", kth(root[i], x)); else if (op == 5) &#123; split(root[i], x - 1, a, b); if (!a) printf(\"-2147483647\\n\"); else &#123; int p = a; while (T[p].rs) p = T[p].rs; printf(\"%d\\n\", T[p].val); &#125; root[i] = merge(a, b); &#125; else &#123; split(root[i], x, a, b); if (!b) printf(\"2147483647\\n\"); else &#123; int p = b; while (T[p].ls) p = T[p].ls; printf(\"%d\\n\", T[p].val); &#125; root[i] = merge(a, b); &#125; &#125; return 0; &#125; [å›½å®¶é›†è®­é˜Ÿ] middle Portal. ä¸­ä½æ•°äºŒåˆ†ç­”æ¡ˆï¼Œé™åˆ¶é‡‡ç”¨ GSS5 çš„å¤„ç†æ–¹æ³•ï¼ˆå°†é™åˆ¶åŒºé—´æ‹†åˆ†æˆä¸‰ä¸ªåŒºé—´ï¼‰ï¼Œä¸»å¸­æ ‘ç»´æŠ¤æŒ‰æƒå€¼æ’åºçš„ç‰ˆæœ¬ä¿¡æ¯å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, Q, q[4]; int a[20005], id[20005]; struct Value &#123; int lmax, rmax, sum; friend Value operator+ (const Value &amp;a, const Value &amp;b) &#123; Value c; c.lmax = max(a.lmax, a.sum + b.lmax); c.rmax = max(b.rmax, a.rmax + b.sum); c.sum = a.sum + b.sum; return c; &#125; &#125;; struct Node &#123; int ls, rs; Value dat; &#125; T[400005]; int rt[20005], tot; int build(int l, int r) &#123; int o = ++tot; T[o].dat = &#123;r - l + 1, r - l + 1, r - l + 1&#125;; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return T[o].dat = &#123;-1, -1, -1&#125;, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x); else T[o].rs = update(T[pre].rs, mid + 1, r, x); T[o].dat = T[T[o].ls].dat + T[T[o].rs].dat; return o; &#125; Value query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].dat; int mid = l + r >> 1; if (y &lt;= mid) return query(T[o].ls, l, mid, x, y); if (mid &lt; x) return query(T[o].rs, mid + 1, r, x, y); return query(T[o].ls, l, mid, x, y) + query(T[o].rs, mid + 1, r, x, y); &#125; bool check(int x) &#123; int ans = 0; ans += query(rt[x], 1, n, q[0], q[1]).rmax; if (q[1] + 1 &lt;= q[2] - 1) ans += query(rt[x], 1, n, q[1] + 1, q[2] - 1).sum; ans += query(rt[x], 1, n, q[2], q[3]).lmax; return ans >= 0; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), id[i] = i; sort(id + 1, id + n + 1, [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;); rt[1] = build(1, n); for (int i = 2; i &lt;= n; ++i) rt[i] = update(rt[i - 1], 1, n, id[i - 1]); scanf(\"%d\", &amp;Q); for (int last = 0; Q--; ) &#123; for (int i = 0; i &lt; 4; ++i) scanf(\"%d\", q + i), q[i] = (q[i] + last) % n + 1; sort(q, q + 4); int L = 0, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", last = a[id[L]]); &#125; return 0; &#125; [SCOI2016] ç¾å‘³ Portal. ä»é«˜åˆ°ä½ä½è´ªå¿ƒï¼Œåˆ©ç”¨ä¸»å¸­æ ‘åˆ¤æ–­æ•°æ˜¯å¦å­˜åœ¨ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 100000; struct Node &#123; int ls, rs, dat; &#125; T[10000005]; int rt[200005], tot; int n, m; int a[200005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; int o = ++tot; T[o] = T[pre]; ++T[o].dat; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x); else T[o].rs = update(T[pre].rs, mid + 1, r, x); return o; &#125; int query(int p, int q, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[q].dat - T[p].dat; int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(T[p].ls, T[q].ls, l, mid, x, y); if (mid &lt; y) res += query(T[p].rs, T[q].rs, mid + 1, r, x, y); return res; &#125; bool find(int p, int q, int l, int r) &#123; l = max(l, 0); r = min(r, N); if (l > r) return 0; return query(rt[p], rt[q], 1, N, l, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); rt[0] = build(1, N); for (int i = 1; i &lt;= n; ++i) rt[i] = update(rt[i - 1], 1, N, a[i]); while (m--) &#123; int b, x, l, r, ans = 0; scanf(\"%d%d%d%d\", &amp;b, &amp;x, &amp;l, &amp;r); for (int i = 17; i >= 0; --i) &#123; int now = ans + (((b >> i &amp; 1) ^ 1) &lt;&lt; i); if (find(l - 1, r, now - x, now + (1 &lt;&lt; i) - 1 - x)) ans = now; else ans += ((b >> i &amp; 1) &lt;&lt; i); &#125; printf(\"%d\\n\", ans ^ b); &#125; return 0; &#125; åµŒå¥—æ•°æ®ç»“æ„ åº”ç”¨ä¸æ˜¯å¾ˆå¤šï¼ˆå› ä¸ºé€šå¸¸æ²¡æœ‰è¦æ±‚è¿™ä¹ˆå¤æ‚çš„ç©æ„ï¼‰ï¼Œä½†æ˜¯å‡ºå‡ºæ¥éƒ½æŒºå“äººã€‚ ç»¼åˆåº”ç”¨ è¿™é‡Œçš„é¢˜ç›®éš¾åº¦ä¼šæœ‰æ‰€ä¸Šå‡ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"æ•°æ®ç»“æ„","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"å¯æŒä¹…åŒ–","slug":"å¯æŒä¹…åŒ–","permalink":"https://james1badcreeper.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"æ ‘å¥—æ ‘","slug":"æ ‘å¥—æ ‘","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"}]},{"title":"çœé€‰åˆçº§å›¾è®º","slug":"notes/å›¾è®º/sx-graph","date":"2023-01-15T00:00:00.000Z","updated":"2023-01-15T00:00:00.000Z","comments":true,"path":"fb40efc5/","link":"","permalink":"https://james1badcreeper.github.io/fb40efc5/","excerpt":"é«˜çº§çš„å›¾è®ºçŸ¥è¯†ä¼šåŒ…å«æ›´å¤šçš„å†…å®¹ã€‚æˆ‘ä»¬å°†äºŒåˆ†å›¾ä¸ç½‘ç»œæµæ’é™¤ï¼Œè¿™ç¯‡æ–‡ç« çš„å†…å®¹ä¼šè¦†ç›–ç»å¤§å¤šæ•°ç®€å•å¸¸ç”¨çš„å›¾è®ºçŸ¥è¯†ç‚¹ä¸æŠ€å·§ã€‚","text":"é«˜çº§çš„å›¾è®ºçŸ¥è¯†ä¼šåŒ…å«æ›´å¤šçš„å†…å®¹ã€‚æˆ‘ä»¬å°†äºŒåˆ†å›¾ä¸ç½‘ç»œæµæ’é™¤ï¼Œè¿™ç¯‡æ–‡ç« çš„å†…å®¹ä¼šè¦†ç›–ç»å¤§å¤šæ•°ç®€å•å¸¸ç”¨çš„å›¾è®ºçŸ¥è¯†ç‚¹ä¸æŠ€å·§ã€‚ çƒ­èº« æä¸€äº›åŸºç¡€å†…å®¹ï¼ æ‹†è¾¹æ‹†ç‚¹ä¸ç‚¹è¾¹è½¬åŒ– æœ‰äº›æ—¶å€™çš„é—®é¢˜æ¯”è¾ƒå¤æ‚ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©å°†è¾¹æˆ–è€…æ˜¯ç‚¹è¿›è¡Œæ‹†åˆ†ï¼Œæ¥æ›´åŠ æ–¹ä¾¿çš„å¤„ç†ã€‚æ¯”å¦‚åˆ†å±‚å›¾æœ€çŸ­è·¯ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„å°±æ˜¯&quot;ç‚¹æ‹†ç‚¹&quot;ï¼ŒæŠŠä¸€ä¸ªç‚¹æ‹†æˆå¤šä¸ªç‚¹è¿›è¡Œç»´æŠ¤ã€‚å½“ç„¶ï¼Œè¿™ä¹Ÿæ„å‘³ç€åˆ†å±‚å›¾ä¸­çš„&quot;ç‰¹æ®Šé“è·¯&quot;ä¸ä¼šå¾ˆå¤šï¼Œå¦åˆ™ç‚¹ä¼šè¢«æ‹†æˆå¾ˆå¤šï¼Œå¤æ‚åº¦æ— æ³•æ‰¿å—ã€‚ æœ‰çš„æ—¶å€™ç‚¹æˆ–è€…è¾¹ä¸æ–¹ä¾¿åšï¼Œä¸¤è€…ç”šè‡³å¯ä»¥ç›¸äº’è½¬åŒ–ã€‚æ¯”å¦‚åœ¨å¤„ç†æ ‘ä¸Šè¾¹æƒæ—¶ï¼Œæˆ‘ä»¬å°±é‡‡å–äº†æŠŠè¾¹æƒä¸‹æ”¾åˆ°ç‚¹æƒçš„æ–¹å¼ã€‚ è¿™ç§æ€æƒ³åœ¨ç½‘ç»œæµä¸­è¿˜æœ‰æ›´å¤šåº”ç”¨ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œåªç®€å•ä»‹ç»å‡ ä¸ªä¾‹å­ã€‚ ç‚¹æ‹†ç‚¹ | [SCOI2009] è¿·è·¯ Portal.ä¸€ä¸ªæœ‰å‘å›¾æœ‰ nnn ä¸ªèŠ‚ç‚¹ï¼Œä»èŠ‚ç‚¹ 111 å‡ºå‘ï¼Œå¿…é¡»æ°å¥½åœ¨ ttt æ—¶åˆ»åˆ°è¾¾èŠ‚ç‚¹ nnnã€‚æ±‚å…±æœ‰å¤šå°‘ç§ä¸åŒçš„è·¯å¾„å—ï¼Ÿç­”æ¡ˆå¯¹ 200920092009 å–æ¨¡ã€‚æ³¨æ„ï¼šä¸èƒ½åœ¨æŸä¸ªèŠ‚ç‚¹é€—ç•™ï¼Œä¸”é€šè¿‡æŸæœ‰å‘è¾¹çš„æ—¶é—´ä¸¥æ ¼ä¸ºç»™å®šçš„æ—¶é—´ã€‚ä¿è¯ 2â‰¤nâ‰¤102 \\leq n \\leq 102â‰¤nâ‰¤10ï¼Œ1â‰¤tâ‰¤1091 \\leq t \\leq 10^91â‰¤tâ‰¤109ã€‚ æˆ‘ä»¬å…ˆè€ƒè™‘è¾¹æƒåªæœ‰ 01 æ€ä¹ˆåšã€‚ è®¾ f(t,i,j)f(t,i,j)f(t,i,j) è¡¨ç¤º iii åˆ° jjj çš„é•¿åº¦ä¸º ttt çš„è·¯å¾„æ•°ï¼Œæ˜¾ç„¶ t=1t=1t=1 æ—¶è¿™ä¸ªå°±æ˜¯åˆå§‹çŸ©é˜µï¼Œè½¬ç§»ä¹Ÿå°±æ˜¯ f(t,i,j)=âˆ‘k=1nf(tâˆ’1,i,k)+f(1,k,j)f(t,i,j)=\\sum_{k=1}^{n}f(t-1,i,k)+f(1,k,j)f(t,i,j)=âˆ‘k=1nâ€‹f(tâˆ’1,i,k)+f(1,k,j)ã€‚å½“ç„¶è¿™ä¸ªè½¬ç§»ä¹Ÿå¯ä»¥æ‰©å±•åˆ°ä»»æ„æƒ…å†µï¼Œä¸è¿‡ä¸æˆ‘ä»¬æ¥ä¸‹æ¥è®¨è®ºçš„å†…å®¹æ²¡æœ‰å…³ç³»ã€‚ è¿™ç§æ—¶å€™å¯ä»¥å‘ç° f(t)=f(tâˆ’1)Ã—f(1)f(t)=f(t-1)\\times f(1)f(t)=f(tâˆ’1)Ã—f(1)ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚è®¡ç®—ã€‚ç„¶è€Œå½“ä¸å…¨æ˜¯ 01 çš„æ—¶å€™æ— æ³•ä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚ï¼æ€ä¹ˆåŠï¼Ÿå‘ç° w&lt;10w&lt;10w&lt;10ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸€ä¸ªç‚¹æ‹†æˆä¹ä¸ªç‚¹ï¼Œåƒè¿™æ ·ï¼š å¦‚æœæˆ‘ä»¬è¦è¿ä¸€ä¸ªç‚¹åˆ°è¿™ä¸ªè¢«æ‹†å¥½çš„ç‚¹ï¼Œé‚£ä¹ˆæ ¹æ®è·ç¦»è¿æ¥å³å¯ã€‚æ¯”å¦‚æœ‰ä¸€ä¸ªç‚¹ä¸å®ƒè·ç¦»ä¸º 333ï¼Œé‚£ä¹ˆå°±éœ€è¦è¿æ¥åˆ° 222 å·ç‚¹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 2009; int m; struct Matrix &#123; int a[100][100]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; Matrix operator * (const Matrix &amp;a) const &#123; Matrix res; for (int i = 1; i &lt;= m; ++i) for (int k = 1; k &lt;= m; ++k) &#123; i64 r = this->a[i][k]; for (int j = 1; j &lt;= m; ++j) res.a[i][j] = (res.a[i][j] + r * a.a[k][j]) % MOD; &#125; return res; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; for (int i = 1; i &lt;= m; ++i) res.a[i][i] = 1; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; int n, t; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;t); m = 9 * n; Matrix f; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) f.a[i + j * n][i + (j - 1) * n] = 1; for (int j = 1; j &lt;= n; ++j) &#123; int x; scanf(\"%1d\", &amp;x); if (x) f.a[i][j + (x - 1) * n] = 1; &#125; &#125; f = poww(f, t); printf(\"%d\\n\", f.a[1][n]); return 0; &#125; è¾¹è½¬ç‚¹ | [SDOI2009] HHå»æ•£æ­¥ Portal.ç»™å®šä¸€å¼ ä¸å¸¦æƒçš„æ— å‘å›¾ï¼Œä¸ä¼šç«‹åˆ»æ²¿ç€åˆšåˆšèµ°æ¥çš„è·¯èµ°å›ï¼Œé—®æœ‰å¤šå°‘ç§ä» AAA èµ°åˆ° BBBï¼Œè·ç¦»ä¸º TTT çš„èµ°æ³•ï¼Ÿ æ„Ÿè§‰æ ¹ä¸Šä¸€é¢˜å¾ˆç›¸ä¼¼ï¼Œä½†æ˜¯è¦æ±‚ä¸èƒ½æ¥å›èµ°ï¼æ€ä¹ˆåŠï¼Ÿè€ƒè™‘å°†ä¸€æ¡æ— å‘è¾¹è½¬æ¢æˆä¸¤ä¸ªç‚¹ï¼Œç„¶åè¿™ä¸¤ä¸ªç‚¹ä¹‹é—´ä¸è¿è¾¹ï¼Œå‰©ä¸‹çš„èƒ½åˆ°è¾¾çš„è¾¹ä¸è¿™äº›ç‚¹è¿è¾¹ã€‚ åˆå§‹æ—¶è¿ä¸€æ¡ 0â†’a0\\rightarrow a0â†’a çš„è¾¹ï¼Œå»ºç«‹åˆå§‹çŸ©é˜µçš„æ—¶å€™æšä¸¾ä¸¤æ¡è¾¹ i,ji,ji,jï¼Œå¦‚æœæ»¡è¶³ v[i]=u[j]v[i]=u[j]v[i]=u[j]ï¼Œè€Œä¸”ä¸æ˜¯åå‘è¾¹ï¼Œé‚£ä¹ˆ iâ†’ji\\rightarrow jiâ†’j å°±å¯ä»¥ç”¨ 111 çš„æ—¶é—´å»åˆ°è¾¾ã€‚ç­”æ¡ˆä¹Ÿæ˜¯æšä¸¾æ‰€æœ‰è¾¹ï¼Œç¬¬ä¸€æ¡è¾¹ 0â†’a0\\rightarrow a0â†’a åˆ°å½“å‰çš„è¾¹ kâ†’bk\\rightarrow bkâ†’b çš„ç­”æ¡ˆçš„å’Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 45989; int N; struct Matrix &#123; int a[125][125]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; void build(void) &#123; for (int i = 0; i &lt; N; ++i) a[i][i] = 1; &#125; Matrix operator * (const Matrix &amp;b) const &#123; for (int i = 0; i &lt;= N; ++i) for (int k = 0; k &lt;= N; ++k) &#123; int r = a[i][k]; for (int j = 0; j &lt;= N; ++j) c.a[i][j] = (c.a[i][j] + r * b.a[k][j]) % MOD; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; res.build(); for (; b; b >>= 1, a = a * a) if (b &amp; 1) res = res * a; return res; &#125; struct edge &#123; int u, v; &#125;; int n, m, t, a, b; int u[125], v[125], cnt = 0; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;t, &amp;a, &amp;b); ++a; ++b; u[++cnt] = 0; v[cnt] = a; while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); ++x; ++y; u[++cnt] = x; v[cnt] = y; u[++cnt] = y; v[cnt] = x; &#125; Matrix f; N = cnt; for (int i = 1; i &lt;= cnt; ++i) for (int j = 1; j &lt;= cnt; ++j) if (i != j &amp;&amp; i != (j ^ 1) &amp;&amp; v[i] == u[j]) f.a[i][j] = 1; f = poww(f, t); int ans = 0; for (int i = 1; i &lt;= cnt; ++i) if (v[i] == b) ans = (ans + f.a[1][i]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; åŸºç¡€æ¦‚å¿µ ä¸€ä¸ªç‚¹å¯ä»¥è¿æ¥åˆ°å›¾ä¸­çš„æ‰€æœ‰ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹æ˜¯å›¾çš„æ”¯é…ç‚¹ã€‚ å¯¹äºä¸€å¼ å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œè‹¥å›¾ Gâ€²=(Vâ€²,Eâ€²)G&#x27;=(V&#x27;,E&#x27;)Gâ€²=(Vâ€²,Eâ€²) æ»¡è¶³ Vâ€²âŠ†V,Eâ€²âŠ†EV&#x27;\\subseteq V,E&#x27;\\subseteq EVâ€²âŠ†V,Eâ€²âŠ†Eï¼Œåˆ™ç§° Gâ€²G&#x27;Gâ€² æ˜¯ GGG çš„å­å›¾ã€‚ å¦‚æœ Gâ€²G&#x27;Gâ€² æ»¡è¶³ âˆ€u,vâˆˆVâ€²\\forall u,v\\in V&#x27;âˆ€u,vâˆˆVâ€²ï¼Œåªè¦ (u,v)âˆˆE(u,v)\\in E(u,v)âˆˆEï¼Œå‡æœ‰ (u,v)âˆˆEâ€²(u,v)\\in E&#x27;(u,v)âˆˆEâ€²ï¼Œåˆ™ç§° Gâ€²G&#x27;Gâ€² æ˜¯ GGG çš„å¯¼å‡ºå­å›¾ã€‚ å¦‚æœ Gâ€²G&#x27;Gâ€² æ»¡è¶³ Vâ€²=VV&#x27;=VVâ€²=Vï¼Œåˆ™ç§° Gâ€²G&#x27;Gâ€² æ˜¯ GGG çš„ç”Ÿæˆå­å›¾/æ”¯æ’‘å­å›¾ã€‚ å¯¹äºä¸€å¼ æ— å‘å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œå¦‚æœæ¯ä¸ªé¡¶ç‚¹çš„åº¦æ•°éƒ½æ˜¯ä¸€ä¸ªå›ºå®šçš„å¸¸æ•° kkkï¼Œåˆ™ç§° GGG ä¸º kâˆ’\\bold{k-}kâˆ’æ­£åˆ™å›¾ã€‚è€Œæ— å‘å›¾çš„æŸä¸ªç”Ÿæˆå­å›¾ Gâ€²G&#x27;Gâ€² ä¸º kâˆ’k-kâˆ’ æ­£åˆ™å›¾ï¼Œåˆ™ç§° Gâ€²G&#x27;Gâ€² ä¸º GGG çš„ä¸€ä¸ª kâˆ’\\bold{k-}kâˆ’å› å­ã€‚ ä¸€å¼ æ— å‘ç®€å•å›¾çš„è¡¥å›¾çš„å«ä¹‰æ˜¯åŸæœ¬æœ‰çš„è¾¹éƒ½æ²¡æœ‰ï¼ŒåŸæœ¬æ²¡æœ‰çš„è¾¹éƒ½æœ‰ã€‚ ä¸€å¼ æœ‰å‘å›¾çš„åå›¾æ˜¯æ‰€æœ‰è¾¹æ–¹å‘æ”¹å˜ã€‚ è¦†ç›– å¯¹äºæ— å‘å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œè‹¥ Vâ€²âŠ†VV&#x27;\\subseteq VVâ€²âŠ†Vï¼Œæœ‰ä»»æ„ä¸€æ¡è¾¹éƒ½æœ‰ä¸€ä¸ªç«¯ç‚¹åœ¨ Vâ€²V&#x27;Vâ€² ä¸­ï¼Œåˆ™ Vâ€²V&#x27;Vâ€² ç§°ä¸º GGG çš„ç‚¹è¦†ç›–é›†ã€‚ä¸€ä¸ªç‚¹é›†æ˜¯ç‚¹è¦†ç›–çš„å……è¦æ¡ä»¶æ˜¯å…¶è¡¥é›†æ˜¯ç‹¬ç«‹é›†ã€‚ å¦‚æœ Eâ€²âŠ†EE&#x27;\\subseteq EEâ€²âŠ†Eï¼Œä»»æ„ä¸€ä¸ªç‚¹éƒ½è‡³å°‘è¿äº†ä¸€æ¡ Eâ€²E&#x27;Eâ€² ä¸­çš„è¾¹ï¼Œåˆ™ç§° Eâ€²E&#x27;Eâ€² æ˜¯è¾¹è¦†ç›–é›†ã€‚ æœ€å¤§å›¢é—®é¢˜ ä¸€ä¸ªå›¾çš„å­ç‚¹é›† Vâ€²V&#x27;Vâ€² ä¸­ä»»æ„ä¸¤ä¸ªä¸åŒçš„é¡¶ç‚¹éƒ½ç›¸é‚»ï¼Œåˆ™ç§° Vâ€²V&#x27;Vâ€² æ˜¯å›¾ GGG çš„ä¸€ä¸ªå›¢ã€‚å›¢å¯¹åº”çš„å¯¼å‡ºå­å›¾æ˜¯å®Œå…¨å›¾ã€‚è¯´ç™½äº†æœ€å¤§å›¢å°±æ˜¯æœ€å¤§å®Œå…¨å­å›¾ã€‚ æ±‚è§£ä¸€ä¸ªå›¾çš„æœ€å¤§å›¢æ˜¯ NPH çš„ã€‚ä¸‹é¢çš„æš´åŠ›ä¸€èˆ¬å¯ä»¥åº”å¯¹ nâ‰¤50n\\le 50nâ‰¤50 çš„æ•°æ®ï¼š int cnt[2005], group[2005], vis[2005], ans; bool dfs(int pos, int num) &#123; for (int i = pos + 1; i &lt;= n; i++) &#123; if (cnt[i] + num &lt;= ans) return false; // ä¸å¯èƒ½æˆä¸ºç­”æ¡ˆ if (G[pos][i]) &#123; int j; for (j = 0; j &lt; num; j++) if (!G[i][vis[j]]) break; // æ£€æŸ¥ i æ˜¯å¦ä¸æ‰€æœ‰ç‚¹ç›¸é‚» if (j == num) &#123; vis[num] = i; if (dfs(i, num + 1)) return true; &#125; &#125; &#125; if (num > ans) &#123; for (int i = 0; i &lt; num; i++) group[i] = vis[i]; ans = num; return true; &#125; return false; &#125; main(void) &#123; for (int i = n; i >= 1; --i) vis[0] = i, dfs(i, 1), cnt[i] = ans; // ä»¥ i ä¸ºèµ·ç‚¹æ‰¾æœ€å¤§å›¢ &#125; è¡¥å›¾çš„æœ€å¤§å›¢å°±æ˜¯åŸå›¾çš„æœ€å¤§ç‹¬ç«‹é›†ã€‚ æœ€çŸ­è·¯é—®é¢˜ å¸¸è§„çš„æœ€çŸ­è·¯å¯ä»¥è€ƒè™‘ä»¥ä¸‹æ±‚è§£æ–¹å¼ï¼š 01 æœ€çŸ­è·¯ï¼Œå¯ä»¥ä½¿ç”¨åŒç«¯é˜Ÿåˆ— bfs è§£å†³ï¼› å•æºæœ€çŸ­è·¯ï¼Œè€ƒè™‘ä½¿ç”¨ SPFA æˆ– Dijkstraï¼ŒæŸäº›é¢˜ç›®çš„å›¾ä¸å¤ªèƒ½ç‰¹æ®Šæ„é€ ï¼Œé‚£ä¹ˆä½¿ç”¨ SPFA ä¼šå¾ˆå¿«ï¼› å¤šæºæœ€çŸ­è·¯ï¼Œä½¿ç”¨ Floyd æˆ–è€… Johnsonï¼ˆå¹¶æ²¡æœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼‰è§£å†³ã€‚ æœ€çŸ­è·¯æœ‰ä¸€äº›åº”ç”¨ã€‚åŒ…æ‹¬å·²ç»è®²è¿‡çš„å·®åˆ†çº¦æŸï¼Œè¿™é‡Œå†è¡¥å……ä¸¤ä¸ªçŸ¥è¯†ç‚¹ã€‚ æ–¯å¦çº³æ ‘ è´¹é©¬ç‚¹é—®é¢˜æ˜¯ä¸€ä¸ªç»å…¸çš„å‡ ä½•é—®é¢˜ï¼Œè€Œå®ƒç»™å®šçš„æ˜¯ä¸‰è§’å½¢ã€‚å¦‚æœç»™å®š nnn ä¸ªç‚¹ï¼Œè¯•æ±‚è¿æ¥æ­¤ nnn ä¸ªç‚¹ï¼Œæ€»é•¿æœ€çŸ­çš„ç›´çº¿æ®µè¿æ¥ç³»ç»Ÿï¼Œå¹¶ä¸”å¹¶ä¸”ä»»æ„ä¸¤ç‚¹éƒ½å¯ä»¥é€šè¿‡ç³»ç»Ÿä¸­çš„ç›´çº¿æ®µç»„æˆçš„æŠ˜çº¿è¿æ¥èµ·æ¥ï¼Œæ­¤é—®é¢˜è¢«ç§°ä¸ºæ–¯å¦çº³æ ‘é—®é¢˜ã€‚ç»™å®š nnn ä¸ªç‚¹æ—¶ï¼Œæœ€å¤šæœ‰ nâˆ’2n-2nâˆ’2 ä¸ªå¤æ¥ç‚¹ï¼ˆæ–¯å¦çº³ç‚¹ï¼‰ã€‚æ¯ä¸€æ–¯å¦çº³ç‚¹è¦ä¹ˆæœ‰ä¸‰æ¡è¾¹é€šè¿‡ï¼ˆå‘ˆ 120Â°120\\degree120Â° çš„å¤¹è§’ï¼‰ï¼Œè¦ä¹ˆæ˜¯ä¸¤æ¡è¾¹ï¼Œè¿™æ—¶å®ƒæ˜¯ä¸€ä¸ªå·²ç»ç»™å®šçš„ç‚¹ã€‚ æœ€å°æ–¯å¦çº³æ ‘ã€‚ç»™å®šä¸€ä¸ª nnn ä¸ªç‚¹ mmm æ¡è¾¹æ— å‘å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œå†ç»™å®šåŒ…å« kkk ä¸ªèŠ‚ç‚¹çš„ç‚¹é›† SSSï¼Œé€‰å‡º GGG çš„è¿é€šå­å›¾ Gâ€²=(Vâ€²,Eâ€²)G&#x27;=(V&#x27;,E&#x27;)Gâ€²=(Vâ€²,Eâ€²)ï¼Œè¦æ±‚ï¼šSâŠ†Vâ€²S \\subseteq V&#x27;SâŠ†Vâ€²ï¼ŒEâ€²E&#x27;Eâ€² ä¸­æ‰€æœ‰è¾¹çš„æƒå€¼å’Œæœ€å°ã€‚ä½ éœ€è¦æ±‚å‡ºè¿™ä¸ªæœ€å°æƒå€¼å’Œï¼Œnâ‰¤100,mâ‰¤500,kâ‰¤10n\\le 100,m\\le 500,k\\le 10nâ‰¤100,mâ‰¤500,kâ‰¤10ã€‚ å¹¶ä¸æ˜¯ç›´æ¥å°† SSS è¿æ¥èµ·æ¥å°±æ˜¯æœ€å°çš„ï¼Œå¯èƒ½éœ€è¦å€ŸåŠ©å‰©ä¸‹çš„ nâˆ’kn-knâˆ’k ä¸ªç‚¹ã€‚è¿™ç§é—®é¢˜å¯ä»¥ä½¿ç”¨çŠ¶å‹ DP æ¥è§£å†³ï¼š è®¾ f(i,S)f(i,S)f(i,S) è¡¨ç¤ºä»¥ iii ä¸ºæ ¹çš„ä¸€æ£µæ ‘ï¼ŒåŒ…å«é›†åˆ SSS ä¸­æ‰€æœ‰ç‚¹çš„æœ€å°è¾¹æƒå€¼å’Œã€‚æœ‰è½¬ç§»ï¼šf(i,S)â†minâ¡{f(i,T)+f(i,Sâˆ’T)},f(i,S)â†minâ¡{f(j,S)+w(i,j)}f(i,S)\\leftarrow\\min\\{f(i,T)+f(i,S-T)\\},f(i,S)\\leftarrow\\min\\{f(j,S)+w(i,j)\\}f(i,S)â†min{f(i,T)+f(i,Sâˆ’T)},f(i,S)â†min{f(j,S)+w(i,j)}ã€‚å‰è€…å¯ä»¥ä½¿ç”¨å­é›† DP å®ç°ï¼Œåè€…å¯ä»¥è·‘ä¸€ä¸ªæœ€çŸ­è·¯ï¼ˆç”±äºå›¾å¾ˆéš¾ç‰¹æ®Šæ„é€ è€Œä¸”è§„æ¨¡å¾ˆå°ï¼Œæ‰€ä»¥å®é™…ä¸Šæ›´å»ºè®® SPFAï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef pair&lt;int, int> pii; const int INF = 0x3f3f3f3f; int n, m, k, f[1024][105]; vector&lt;pair&lt;int, int>> G[105]; priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii>> q; bool vis[105]; void dijkstra(int s) &#123; memset(vis, 0, sizeof vis); for (int i = 0; i &lt; n; ++i) if (f[s][i] != INF) q.emplace(f[s][i], i); while (!q.empty()) &#123; pii tmp = q.top(); q.pop(); int u = tmp.second; if (vis[u]) continue; vis[u] = true; for (auto [v, w] : G[u]) if (f[s][v] > f[s][u] + w) q.emplace(f[s][v] = f[s][u] + w, v); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); --u; --v; G[u].emplace_back(v, w); G[v].emplace_back(u, w); &#125; memset(f, 0x3f, sizeof f); for (int i = 0, x; i &lt; k; ++i) &#123; scanf(\"%d\", &amp;x); --x; f[1 &lt;&lt; i][x] = 0; &#125; for (int s = 1; s &lt; 1 &lt;&lt; k; ++s) &#123; for (int i = 0; i &lt; n; ++i) for (int t = s - 1 &amp; s; t; t = t - 1 &amp; s) f[s][i] = min(f[s][i], f[t][i] + f[s ^ t][i]); dijkstra(s); &#125; int ans = INF; for (int i = 0; i &lt; n; ++i) ans = min(ans, f[(1 &lt;&lt; k) - 1][i]); printf(\"%d\\n\", ans); return 0; &#125; åŒä½™æœ€çŸ­è·¯ è¿™æ˜¯ä¸€ä¸ªæœ€çŸ­è·¯çš„å˜å¼é—®é¢˜ã€‚å¯ä»¥ç”¨äºæ±‚è§£åœ¨æŸä¸ªèŒƒå›´å†…æœ‰å¤šå°‘é‡é‡å¯ä»¥ç”±è‹¥å¹²ç‰©å“çš„å®Œå…¨èƒŒåŒ…å‡‘å‡ºï¼Œå°±æ˜¯å¤šå°‘æ•°å€¼å¯ä»¥ç”±ä¸€äº›ç»™å®šçš„æ•° bib_ibiâ€‹ ç”± âˆ‘aibi(aiâ‰¥0)\\sum a_i b_i(a_i\\ge 0)âˆ‘aiâ€‹biâ€‹(aiâ€‹â‰¥0) å¾—åˆ°ã€‚ SPFA æ¨¡æ¿ã€‚å¢¨å¢¨çªç„¶å¯¹ç­‰å¼å¾ˆæ„Ÿå…´è¶£ï¼Œä»–æ­£åœ¨ç ”ç©¶ âˆ‘i=1naixi=b\\sum_{i=1}^n a_ix_i=bâˆ‘i=1nâ€‹aiâ€‹xiâ€‹=b å­˜åœ¨éè´Ÿæ•´æ•°è§£çš„æ¡ä»¶ï¼Œä»–è¦æ±‚ä½ ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œç»™å®š n,a1â€¦n,l,rn, a_{1\\dots n}, l, rn,a1â€¦nâ€‹,l,rï¼Œæ±‚å‡ºæœ‰å¤šå°‘ bâˆˆ[l,r]b\\in[l,r]bâˆˆ[l,r] å¯ä»¥ä½¿ç­‰å¼å­˜åœ¨éè´Ÿæ•´æ•°è§£ã€‚nâ‰¤12n \\le 12nâ‰¤12ï¼Œ0â‰¤aiâ‰¤5Ã—1050 \\le a_i \\le 5\\times 10^50â‰¤aiâ€‹â‰¤5Ã—105ï¼Œ1â‰¤lâ‰¤râ‰¤10121 \\le l \\le r \\le 10^{12}1â‰¤lâ‰¤râ‰¤1012ã€‚ æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå¦‚æœ xxx å¯ä»¥è¢«è¡¨ç¤ºå‡ºï¼Œé‚£ä¹ˆ x+kai(k&gt;0)x+ka_i(k&gt;0)x+kaiâ€‹(k&gt;0) å°±å¯ä»¥è¢«è¡¨ç¤ºå‡ºã€‚å› æ­¤æˆ‘ä»¬æ‰¾ä¸€ä¸ªæœ€å°çš„ a1a_1a1â€‹ï¼Œç„¶åè¿ jâ†’(j+ai)mod a1j\\rightarrow (j+a_i)\\mod a_1jâ†’(j+aiâ€‹)moda1â€‹ çš„é•¿åº¦ä¸º aia_iaiâ€‹ çš„è¾¹ï¼Œç„¶åæˆ‘ä»¬ä» 000 å¼€å§‹è·‘æœ€çŸ­è·¯ã€‚ç”±äºè¿™é‡Œå›¾çš„å½¢æ€ä¸å¤ªèƒ½ç‰¹æ®Šæ„é€ ï¼Œå› æ­¤ä½¿ç”¨ SPFA å¾€å¾€ä¼šè·‘çš„æ›´å¿«ã€‚ ç­”æ¡ˆçš„æ±‚è§£ååˆ†å®¹æ˜“ã€‚[0,r][0,r][0,r] çš„ç­”æ¡ˆæ•°é‡ä¸ºï¼š âˆ‘i=0a1âˆ’1maxâ¡{0,âŒŠrâˆ’dia1âŒ‹+1}\\sum_{i=0}^{a_1-1}\\max\\left\\{0,\\left\\lfloor\\frac{r-d_i}{a_1}\\right\\rfloor+1\\right\\} i=0âˆ‘a1â€‹âˆ’1â€‹max{0,âŒŠa1â€‹râˆ’diâ€‹â€‹âŒ‹+1} æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, a[20]; i64 l, r, f[500005]; bool inq[500005]; int main(void) &#123; scanf(\"%d%lld%lld\", &amp;n, &amp;l, &amp;r); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); memset(f, 0x3f, sizeof(f)); queue&lt;int> q; q.push(0); f[0] = 0; inq[0] = true; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 2; i &lt;= n; ++i) &#123; int v = (u + a[i]) % a[1]; if (f[v] > f[u] + a[i]) &#123; f[v] = f[u] + a[i]; if (!inq[v]) inq[v] = true, q.push(v); &#125; &#125; &#125; i64 ans = 0; for (int i = 0; i &lt; a[1]; ++i) &#123; if (r >= f[i]) ans += (r - f[i]) / a[1] + 1; if (l - 1 >= f[i]) ans -= (l - 1 - f[i]) / a[1] + 1; &#125; printf(\"%lld\\n\", ans); return 0; &#125; è½¬ä¸¤åœˆ å›å½’åŒä½™æœ€çŸ­è·¯é—®é¢˜çš„æœ¬è´¨ï¼Œ å¹¿ä¹‰åœ†æ–¹æ ‘ å¹¿ä¹‰åœ†æ–¹æ ‘æ˜¯åˆ»ç”»å›¾ä¸Šç‚¹çš„å¿…ç»æ€§çš„å·¥å…·ï¼Œå¯ä»¥æè¿°ä»»æ„ä¸¤ç‚¹ä¹‹é—´çš„æ‰€æœ‰å¿…ç»ç‚¹ï¼Œä¹Ÿå°±æ˜¯ä¼šç»è¿‡çš„å‰²ç‚¹ã€‚ æ¦‚è¿° å¹¿ä¹‰åœ†æ–¹æ ‘æ˜¯å®šä¹‰åœ¨ä¸€èˆ¬æ— å‘å›¾ä¸Šçš„ä¸€ç§æ ‘å½¢ç»“æ„ï¼Œæ˜¯ v-DCC ç¼©ç‚¹ä¹‹åçš„äº§ç‰©ã€‚æœ¬è´¨ä¸Šå¯ä»¥çœ‹æˆâ€œç¼©è¾¹â€ï¼Œå°±æ˜¯å°†åŸå›¾ä¸Šæ‰€æœ‰å¯¹åˆ»ç”»å¿…ç»æ€§æ— ç”¨çš„è¾¹å»æ‰ã€‚ æˆ‘ä»¬å»ºå‡º v-DCC çš„â€œä»£è¡¨ç‚¹â€å¹¶å‘ v-DCC å†…éƒ¨æ‰€æœ‰ç‚¹è¿è¾¹ï¼Œè¿™æ ·ä¼šå½¢æˆä¸€ä¸ªèŠèŠ±å›¾ã€‚è¿™ä¸ªâ€œä»£è¡¨ç‚¹â€ç§°ä¸ºâ€œæ–¹ç‚¹â€ï¼Œè€ŒåŸå›¾ä¸­çš„æ‰€æœ‰ç‚¹å¯¹åº”â€œåœ†ç‚¹â€ã€‚ä»£ç å¦‚ä¸‹ï¼š void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; // å­¤ç«‹ç‚¹åœ¨åœ†æ–¹æ ‘ä¸Šæ ¹æœ¬æ²¡æœ‰è¾¹ï¼Œä¸éœ€è¦ç‰¹åˆ¤ for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; // æ‰¾åˆ°äº†ä¸€ä¸ªä»¥ x ä¸ºæ ¹çš„ v-DCC int z; ++n; // æ–°å»ºä¸€ä¸ªæ–¹ç‚¹ do addedge(z = st[tot--], n); while (z != y); addedge(x, n); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; æ€§è´¨ å®ƒä»¬æ˜¯å¹¿ä¹‰åœ†æ–¹æ ‘å·¥ä½œçš„åŸºç¡€ï¼Œé¦–å…ˆæ˜¯ v-DCC çš„å¼•ç†ï¼š å¼•ç†ï¼šå¦‚æœ xxx ä¸ y,zy,zy,z å‡ç‚¹åŒè¿é€šï¼Œä½†æ˜¯ y,zy,zy,z ä¸ç‚¹åŒè¿é€šï¼Œé‚£ä¹ˆ xxx æ˜¯ y,zy,zy,z çš„å¿…ç»ç‚¹ã€‚ ç„¶åæ˜¯å¹¿ä¹‰åœ†æ–¹æ ‘çš„æ€§è´¨ï¼š æ€§è´¨ 1ï¼šåœ†ç‚¹ xxx çš„åº¦æ•°ä¸ºå®ƒæ‰€åœ¨çš„ v-DCC ä¸ªæ•°ã€‚ æ€§è´¨ 2ï¼šåœ†æ–¹æ ‘ä¸Šåªæœ‰åœ†ç‚¹å’Œæ–¹ç‚¹ä¹‹é—´æœ‰è¾¹ã€‚ æ€§è´¨ 3ï¼šåŸå›¾ä¸Šç›´æ¥ç›¸è¿çš„ x,yx,yx,y å±äºä¸€ä¸ª v-DCCï¼Œè€Œä¸”å¦‚æœè¿™ä¸ª v-DCC çš„å¤§å°ä¸º 222ï¼Œé‚£ä¹ˆ (x,y)(x,y)(x,y) æ˜¯å‰²è¾¹ã€‚ ä¸‹é¢ä¸‰ä¸ªæ˜¯ç”¨æ¥åšé¢˜çš„ï¼š æ€§è´¨ 4ï¼šåœ†ç‚¹ xxx æ˜¯å¶å­å½“ä¸”ä»…å½“å®ƒåœ¨åŸå›¾ä¸Šä¸æ˜¯å‰²ç‚¹ã€‚è¯æ˜ï¼šå¦‚æœ xxx æ˜¯å‰²ç‚¹ï¼Œé‚£ä¹ˆ xxx è‡³å°‘å±äºä¸¤ä¸ª v-DCCï¼Œè¿™æ ·å­˜åœ¨ y,zy,zy,z ä¸¤ç‚¹ä¸ xxx éƒ½ç‚¹åŒè¿é€šï¼Œä½†æ˜¯ y,zy,zy,z ä¸ç‚¹åŒè¿é€šï¼Œå› æ­¤ xxx æ˜¯ y,zy,zy,z çš„å¿…ç»ç‚¹ï¼Œè¿™æ ·å®ƒä¸æ˜¯å¶å­ã€‚æ€§è´¨ 5ï¼šå¹¿ä¹‰åœ†æ–¹æ ‘ä¸Šåˆ æ‰åœ†ç‚¹ xxx åå‰©ä½™èŠ‚ç‚¹çš„è”é€šæ€§ä¸åŸå›¾ä¸Šåˆ é™¤ xxx ç›¸ç­‰ã€‚è¯æ˜ï¼šå¦‚æœ xxx æ˜¯å¶å­ï¼Œä¹Ÿå°±æ˜¯å®ƒä¸æ˜¯å‰²ç‚¹ï¼Œåˆ é™¤æ˜¾ç„¶æ²¡æœ‰å½±å“ã€‚å¦‚æœå®ƒæ˜¯åŸå›¾çš„å‰²ç‚¹ï¼Œæ¯”å¦‚è¯´ xxx åœ¨åœ†æ–¹æ ‘ä¸Šè¿æ¥äº† y,zy,zy,zï¼Œé‚£ä¹ˆä¸ y,zy,zy,z æ‰€åœ¨çš„ç‚¹åŒè¿é€šä¹‹é—´ä¸åœ¨è¿é€šï¼Œä¸å…¶å‰²ç‚¹çš„æ€§è´¨æ˜¯ä¸€æ ·çš„ã€‚æ€§è´¨ 6ï¼šx,yx,yx,y ç®€å•è·¯å¾„ä¸Šçš„æ‰€æœ‰åœ†ç‚¹å°±æ˜¯åŸå›¾ä¸­ x,yx,yx,y ä¹‹é—´çš„æ‰€å¿…ç»ç‚¹ã€‚è¿™æ˜¯åœ†æ–¹æ ‘çš„æ ¸å¿ƒæ€§è´¨ã€‚ æ¨¡æ¿ï¼Œç›´æ¥è¾“å‡ºæœ€å°ç¼–å·çš„åœ†ç‚¹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, node; int dfn[200005], low[200005], num, st[200005], tot; vector&lt;int> E[200005], G[400005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; int z; G[++node].emplace_back(x); G[x].emplace_back(node); do G[node].emplace_back(z = st[tot--]), G[z].emplace_back(node); while (y != z); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; int f[400005], dep[400005]; void dfs(int x, int fa) &#123; f[x] = fa; dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); node = n; for (int u, v; scanf(\"%d%d\", &amp;u, &amp;v) == 2 &amp;&amp; u; ) E[u].emplace_back(v), E[v].emplace_back(u); tarjan(1); dfs(1, 0); int a, b; scanf(\"%d%d\", &amp;a, &amp;b); int ans = 1e9; if (dep[a] &lt; dep[b]) swap(a, b); while (dep[a] > dep[b]) if ((a = f[a]) != b) ans = min(ans, a); while (a != b) ans = min(&#123;ans, a = f[a], b = f[b]&#125;); if (ans > n) puts(\"No solution\"); else printf(\"%d\\n\", ans); return 0; &#125; ç‰¹æ®Šå›¾ Problemset è¿™é‡Œçš„é¢˜ä¼šå¾ˆæ‚ã€‚ æœ€çŸ­è·¯é—®é¢˜ ä¸æœ€çŸ­è·¯ç›¸å…³çš„é—®é¢˜ã€‚å®ƒä»¬æ˜¯å›¾è®ºä¸­æ¯”è¾ƒåŸºç¡€çš„å†…å®¹ï¼Œä½†æ˜¯å¾ˆæœ‰æ„æ€ã€‚ [NOI Online 2021 å…¥é—¨ç»„] é‡åŠ›çƒ Portal. åˆæ³•çš„ä½ç½®ä¸æ˜¯å¾ˆå¤šï¼ŒæŠŠå®ƒä»¬éƒ½æœå‡ºæ¥å¹¶æ ‡å·ï¼Œå¹¶æ±‚å‡ºæ¯ä¸€ä¸ªé‡åŠ›æ–¹å‘åˆ°è¾¾çš„ä½ç½®ç¼–å·æ¥å»ºå›¾ï¼Œå°±å¯ä»¥ä½¿ç”¨ bfs æ¥æ±‚æœ€çŸ­è·¯äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; int n, m, q, tot, d[2005][2005], id[305][305], t[2005][2005][4]; bool a[305][305]; inline bool check(int x, int y) &#123; return a[x - 1][y] || a[x + 1][y] || a[x][y - 1] || a[x][y + 1]; &#125; vector&lt;int> G[2005][4]; void bfs(void) &#123; queue&lt;pair&lt;int, int>> q; for (int i = 1; i &lt;= tot; ++i) q.emplace(i, i), d[i][i] = 0; while (!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); for (int k = 0; k &lt; 4; ++k) for (int i : G[x][k]) for (int j : G[y][k]) if (d[i][j] == INF) d[i][j] = d[x][y] + 1, q.emplace(i, j); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; ++i) a[0][i] = a[i][0] = a[n + 1][i] = a[i][n + 1] = 1; while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); a[x][y] = 1; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (!a[i][j] &amp;&amp; check(i, j)) id[i][j] = ++tot; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) t[i][j][0] = a[i][j - 1] ? id[i][j] : t[i][j - 1][0], t[i][j][1] = a[i - 1][j] ? id[i][j] : t[i - 1][j][1]; for (int i = n; i >= 1; --i) for (int j = n; j >= 1; --j) t[i][j][2] = a[i][j + 1] ? id[i][j] : t[i][j + 1][2], t[i][j][3] = a[i + 1][j] ? id[i][j] : t[i + 1][j][3]; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (id[i][j]) for (int k = 0; k &lt; 4; ++k) G[t[i][j][k]][k].emplace_back(id[i][j]); memset(d, 0x3f, sizeof(d)); bfs(); while (q--) &#123; int x, p, y, q; scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;p, &amp;q); if (x == p &amp;&amp; y == q) puts(\"0\"); else &#123; int ans = min(&#123;d[t[x][y][0]][t[p][q][0]], d[t[x][y][1]][t[p][q][1]], d[t[x][y][2]][t[p][q][2]], d[t[x][y][3]][t[p][q][3]]&#125;); printf(\"%d\\n\", ans == INF ? -1 : ans + 1); &#125; &#125; return 0; &#125; [JLOI2015] ç®¡é“è¿æ¥ Portal. æ±‚çš„æ˜¯æœ€å°æ–¯å¦çº³æ ‘æ£®æ—ã€‚è®¾ g(s)g(s)g(s) ä»£è¡¨è¿æ¥ sss æ‰€éœ€è¦çš„æœ€å°ä»£ä»·ï¼Œå…ˆç”¨å¸¸è§„æ–¹æ³•èµ‹äºˆåˆå€¼ï¼Œç„¶åæ•´ä¸€ä¸ªå­é›† DP è¿›è¡Œæ›´æ–°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef pair&lt;int, int> pii; const int INF = 0x3f3f3f3f; int n, m, p, f[1024][1005]; vector&lt;pair&lt;int, int>> G[1005]; queue&lt;int> q; bool inq[1005]; void SPFA(int s) &#123; for (int i = 0; i &lt; n; ++i) if (f[s][i] != INF) q.emplace(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (auto [v, w] : G[u]) if (f[s][v] > f[s][u] + w) f[s][v] = f[s][u] + w, q.emplace(v), inq[v] = true; &#125; &#125; int solve(int k) &#123; if (k == 0) return 0; for (int s = 1; s &lt; 1 &lt;&lt; k; ++s) &#123; for (int t = s - 1 &amp; s; t; t = t - 1 &amp; s) for (int i = 0; i &lt; n; ++i) f[s][i] = min(f[s][i], f[t][i] + f[s ^ t][i]); SPFA(s); &#125; int ans = INF; for (int i = 0; i &lt; n; ++i) ans = min(ans, f[(1 &lt;&lt; k) - 1][i]); return ans; &#125; struct Node &#123; int c, p, v; bool operator &lt; (const Node &amp;a) const &#123; return c &lt; a.c; &#125; &#125; a[15]; int g[1024]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;p); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].emplace_back(v, w); G[v].emplace_back(u, w); &#125; for (int i = 0; i &lt; p; ++i) scanf(\"%d%d\", &amp;a[i].c, &amp;a[i].p); sort(a, a + p); memset(g, 0x3f, sizeof(g)); g[0] = 0; int k = 0; for (int i = 0; i &lt; p; ++i) &#123; if (i == 0 || a[i].c != a[i - 1].c) ++k; a[i].v = k - 1; &#125; for (int i = 1; i &lt; 1 &lt;&lt; k; ++i) &#123; memset(f, 0x3f, sizeof(f)); int cnt = 0; for (int j = 0; j &lt; p; ++j) if (1 &lt;&lt; a[j].v &amp; i) f[1 &lt;&lt; cnt++][a[j].p] = 0; g[i] = solve(cnt); &#125; for (int i = 1; i &lt; 1 &lt;&lt; k; ++i) for (int j = i - 1 &amp; i; j; j = j - 1 &amp; i) g[i] = min(g[i], g[j] + g[i ^ j]); return printf(\"%d\\n\", g[(1 &lt;&lt; k) - 1]), 0; &#125; [ARC084B] Small Multiple Portal. ä»»ä½•æ•°éƒ½å¯ä»¥ä» 111 å¼€å§‹é€šè¿‡ Ã—10,+1\\times 10,+1Ã—10,+1 ä¸¤ç§æ“ä½œå¾—åˆ°ï¼Œä»£ä»·åˆ†åˆ«æ˜¯ 0,10,10,1ã€‚è·‘ä¸€ä¸ª 01 bfs æœ€çŸ­è·¯æ±‚å‡º f(i)f(i)f(i) ä»£è¡¨æ¨¡ KKK ä¸º iii çš„æ•°çš„æœ€å°ä»£ä»·å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;deque> using namespace std; bool vis[100005]; deque&lt;pair&lt;int, int>> q; int main(void) &#123; int K; scanf(\"%d\", &amp;K); q.emplace_back(1, 1); vis[1] = true; while (!q.empty()) &#123; int num = q.front().first, w = q.front().second; q.pop_front(); if (num == 0) return printf(\"%d\\n\", w), 0; if (!vis[num * 10 % K]) q.emplace_front(num * 10 % K, w), vis[num * 10 % K] = true; if (!vis[(num + 1) % K]) q.emplace_back((num + 1) % K, w + 1); &#125; return 0; &#125; [çœé€‰è”è€ƒ 2021 A/B å·] å›¾å‡½æ•° Portal. ç›´æ¥è€ƒè™‘æ•´ä½“çš„ç­”æ¡ˆã€‚å‘ç°åªæœ‰ uâ‰¤vu\\le vuâ‰¤vï¼Œç»è¿‡çš„ç‚¹çš„ç¼–å·å…¨éƒ¨å¤§äº vvv çš„ç‚¹å¯¹ï¼ˆå› ä¸ºåœ¨è¿™ä¹‹å‰å°äºçš„éƒ½åˆ å®Œäº†ï¼‰(u,v)(u,v)(u,v) æ‰ä¼šæœ‰è´¡çŒ®ã€‚ å‘ç°è¿™æ˜¯ä¸ª Floyd çš„æ¨¡å‹ï¼Œè¿™æ ·å¯ä»¥æ–¹ä¾¿åœ°ç»Ÿè®¡è·¯å¾„ä¸Šç»è¿‡çš„æœ€å°ç¼–å·çš„æœ€å¤§å€¼ã€‚è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n3+m)O(n^3+m)O(n3+m)ï¼Œç›¸å½“æé™ï¼å› æ­¤æ³¨æ„ Floyd æšä¸¾çš„æ—¶å€™å¦‚æœè·ç¦»æ²¡æœ‰å°±è·³è¿‡ï¼Œå¹¶ä¸”ä¸è¦è®¡ç®—ä¸åˆæ³•çš„è½¬ç§»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, f[1005][1005]; // f[i][j]: i åˆ° j çš„è·¯å¾„ä¸­ï¼Œç»è¿‡çš„æœ€å°ç¼–å·çš„è¾¹çš„æœ€å¤§å€¼ int ans[200005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) f[i][i] = m + 1; for (int i = 1, u, v; i &lt;= m; ++i) scanf(\"%d%d\", &amp;u, &amp;v), f[u][v] = i; for (int k = n; k >= 1; --k) &#123; // åªç»è¿‡ k ~ n çš„ç‚¹ï¼Œè·¯å¾„ä¸Šçš„ç‚¹çš„ç¼–å·å¤§äº k for (int i = 1; i &lt;= n; ++i) if (f[i][k]) &#123; int lim = i &lt; k ? n : k - 1; // å½“ i >= k, j >= k æ—¶ï¼Œç»è¿‡ 1 ~ k æ˜¯ä¸åˆæ³•çš„ for (int j = 1; j &lt;= lim; ++j) f[i][j] = max(f[i][j], min(f[i][k], f[k][j])); &#125; for (int i = k; i &lt;= n; ++i) &#123; // k -> i, i -> k int t = min(f[k][i], f[i][k]); if (t) ++ans[t - 1]; &#125; &#125; for (int i = m; i >= 0; --i) ans[i] += ans[i + 1]; for (int i = 0; i &lt;= m; ++i) printf(\"%d \", ans[i]); return putchar('\\n'), 0; &#125; è¿é€šæ€§é—®é¢˜ åŒ…æ‹¬è¿é€šæ€§ä¸­éœ€è¦ä¸€äº›æ€è€ƒçš„ç»¼åˆé¢˜ï¼Œä»¥åŠåœ†æ–¹æ ‘ç›¸å…³é¢˜ç›®ã€‚ [APIO2018] é“äººä¸¤é¡¹ Portal. ç›¸å½“äºæ˜¯æ±‚ (s,f)(s,f)(s,f) ä¸Šçš„ç®€å•è·¯å¾„ä¸Šå…±æœ‰å¤šå°‘ä¸ªç‚¹ï¼ˆé™¤å» s,fs,fs,fï¼‰ã€‚ å»ºç«‹å‡ºåœ†æ–¹æ ‘ã€‚è·¯å¾„ sss åˆ° fff å¯¹åº”æ˜¯é“¾ä¸Šçš„æƒå€¼å’Œï¼Œå…¶ä¸­æ–¹ç‚¹çš„è´¡çŒ®ä¸ºç‚¹åŒè¿é€šåˆ†é‡çš„å¤§å°ï¼Œåœ†ç‚¹çš„è´¡çŒ®ä¸º âˆ’1-1âˆ’1ï¼Œè¿™æ ·å°±æ˜¯ç­”æ¡ˆã€‚å› ä¸ºæ–¹ç‚¹è®¡ç®—è´¡çŒ®æ—¶ï¼Œè·¯å¾„ä¸Šçš„æ‰€æœ‰åœ†ç‚¹éƒ½ä¼šè¢«å¤šç®—è¿›å»ä¸€æ¬¡ï¼ˆä¸¤å¤´æ˜¯å› ä¸ºé¢˜ç›®è§„å®šï¼Œä¸­é—´çš„æ˜¯å› ä¸ºä¸¤è¾¹éƒ½æœ‰æ–¹ç‚¹ï¼‰ã€‚ ç»Ÿè®¡ç­”æ¡ˆæ—¶é‡‡ç”¨ dfsï¼Œè®¡ç®—æœ‰å¤šå°‘ä¸ª (s,f)(s,f)(s,f) ç‚¹å¯¹ã€‚ æ³¨æ„åŸå›¾å¯èƒ½ä¸è”é€šã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, node, m, a[200005], N; int dfn[100005], low[100005], num, tot, st[100005]; vector&lt;int> E[100005], G[200005]; inline void addedge(int u, int v) &#123; G[u].emplace_back(v); G[v].emplace_back(u); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; ++N; a[x] = -1; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; int z; addedge(++node, x); ++a[node]; do addedge(z = st[tot--], node), ++a[node]; while (z != y); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; i64 ans; int siz[200005]; void dfs(int x, int fa) &#123; siz[x] = (x &lt;= n); i64 cnt = 0; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); cnt += 1ll * siz[x] * siz[y]; siz[x] += siz[y]; &#125; cnt += 1ll * siz[x] * (N - siz[x]); ans += 1ll * a[x] * cnt * 2; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); node = n; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v); E[v].emplace_back(u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) &#123; N = tot = 0; tarjan(i); dfs(i, 0); &#125; return printf(\"%lld\\n\", ans), 0; &#125; [COI2007] Policija Portal. ç¬¬äºŒé—®å°±æ˜¯çœ‹ ccc æ˜¯å¦åœ¨ç®€å•è·¯å¾„ä¸Šã€‚ç¬¬ä¸€é—®é¦–å…ˆè¿™æ¡è¾¹å¿…é¡»æ˜¯å‰²è¾¹ï¼Œè¿™æ¡å‰²è¾¹å¯ä»¥å¯¹åº”åˆ°ä¸€ä¸ªæ–¹ç‚¹ï¼Œçœ‹è¿™ä¸ªæ–¹ç‚¹æ˜¯å¦åœ¨ç®€å•è·¯å¾„ä¸Šã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, node; int dfn[200005], low[100005], num, tot, st[100005]; vector&lt;int> E[100005], G[200005]; map&lt;pair&lt;int, int>, int> B; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; G[x].emplace_back(++node); G[node].emplace_back(x); if (st[tot] == y) B[&#123;x, y&#125;] = node; for (int z = 0; z != y; ) &#123; G[node].emplace_back(z = st[tot--]); G[z].emplace_back(node); &#125; &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; int dep[200005], siz[200005], f[21][200005]; void dfs(int x, int fa) &#123; dfn[x] = ++num; dep[x] = dep[f[0][x] = fa] + 1; siz[x] = 1; for (int i = 1; i &lt;= 20; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); siz[x] += siz[y]; &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 20; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = 20; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; bool isanc(int x, int y) &#123; // x æ˜¯å¦æ˜¯ y çš„ç¥–å…ˆ return dfn[x] &lt;= dfn[y] &amp;&amp; dfn[y] &lt; dfn[x] + siz[x]; &#125; bool lie(int u, int v, int x) &#123; // x æ˜¯å¦åœ¨ (u,v) ä¸Š if (!isanc(x, u) &amp;&amp; !isanc(x, v)) return 0; if (!isanc(LCA(u, v), x)) return 0; return 1; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); node = n; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v); E[v].emplace_back(u); &#125; tarjan(1); num = 0; dfs(1, 0); int q; scanf(\"%d\", &amp;q); while (q--) &#123; int op, a, b, c, d; scanf(\"%d%d%d%d\", &amp;op, &amp;a, &amp;b, &amp;c); if (op == 1) &#123; scanf(\"%d\", &amp;d); int e = -1; auto it = B.find(&#123;c, d&#125;); if (it != B.end()) e = it->second; else &#123; it = B.find(&#123;d, c&#125;); if (it != B.end()) e = it->second; &#125; if (e == -1) puts(\"yes\"); else puts(lie(a, b, e) ? \"no\" : \"yes\"); &#125; else puts(lie(a, b, c) ? \"no\" : \"yes\"); &#125; return 0; &#125; [CF1763F] Edge Queries Portal. å»ºç«‹å‡ºåœ†æ–¹æ ‘ã€‚å°†åŸå›¾ä¸­çš„æ¯ä¸€æ¡è¾¹å¯¹åº”åˆ°åœ†æ–¹æ ‘ä¸Šï¼Œå¢åŠ æ–¹ç‚¹çš„æƒå€¼ã€‚å¦‚æœæ–¹ç‚¹çš„æƒå€¼ä¸º 111ï¼Œé‚£ä¹ˆè¯´æ˜æ˜¯å‰²è¾¹ï¼Œå¦åˆ™åˆ é™¤ä»»æ„ä¸€æ¡éƒ½å¯ä»¥ã€‚è¿™æ ·ç­”æ¡ˆå°±æ˜¯è·¯å¾„ä¸Šæ–¹ç‚¹çš„æƒå€¼å’Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, node, q; int dfn[400005], low[200005], num, st[200005], tot; vector&lt;int> E[200005], G[400005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; G[++node].emplace_back(x); G[x].emplace_back(node); for (int z = 0; z != y; ) &#123; G[node].emplace_back(z = st[tot--]); G[z].emplace_back(node); &#125; &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; int lg[400005], dep[400005], siz[400005], mi[22][400005], f[400005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; f[x] = mi[0][dfn[x] = ++num] = fa; dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int s[400005], w[400005]; void dfs2(int x) &#123; s[x] = s[f[x]] + w[x]; for (int y : G[x]) if (y != f[x]) dfs2(y); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); node = n; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v); E[v].emplace_back(u); &#125; tarjan(1); num = 0; dfs(1, 0); for (int i = 2; i &lt;= node; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= lg[node]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= node; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); for (int u = 1; u &lt;= n; ++u) for (int v : E[u]) if (u &lt;= v) &#123; if (f[u] == f[v]) ++w[f[u]]; else if (f[f[u]] == v) ++w[f[u]]; else ++w[f[v]]; &#125; for (int i = n + 1; i &lt;= node; ++i) if (w[i] == 1) w[i] = 0; dfs2(1); for (scanf(\"%d\", &amp;q); q--; ) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); int lca = LCA(a, b); printf(\"%d\\n\", s[a] + s[b] - s[lca] - s[f[lca]]); &#125; return 0; &#125; [CF487E] Tourists Portal. å»ºç«‹å‡ºåœ†æ–¹æ ‘ï¼Œæ–¹ç‚¹çš„æƒå€¼æ˜¯å®ƒæ‰€å±çš„ v-DCC å†…çš„æœ€å°å€¼ï¼Œç„¶åçº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; int n, m, q; int a[200005], dfn[200005], low[100005], num, tot, st[100005], node; vector&lt;int> E[100005], G[200005]; inline void add(int u, int v) &#123; G[u].emplace_back(v); G[v].emplace_back(u); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] == low[y]) &#123; int z; add(++node, x); do add(z = st[tot--], node); while (z != y); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; int siz[200005], son[200005], f[200005], dep[200005], top[200005], idx[200005]; void dfs1(int x, int fa) &#123; siz[x] = 1; dep[x] = dep[f[x] = fa] + 1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; idx[dfn[x] = ++num] = x; top[x] = topf; if (!son[x]) return; dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int T[800005]; multiset&lt;int> s[100005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[idx[l]], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = min(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o] = min(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = 1e9; if (x &lt;= mid) res = min(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = min(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); node = n; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v), E[v].emplace_back(u); &#125; tarjan(1); num = 0; dfs1(1, 0); dfs2(1, 1); for (int i = 2; i &lt;= n; ++i) s[f[i] - n].insert(a[i]); for (int i = n + 1; i &lt;= node; ++i) a[i] = s[i - n].empty() ? INF : *s[i - n].begin(); build(1, 1, node); char op[5]; int x, y; while (q--) &#123; scanf(\"%s%d%d\", op, &amp;x, &amp;y); if (op[0] == 'C') &#123; update(1, 1, node, dfn[x], y); if (x == 1) &#123; a[x] = y; continue; &#125; s[f[x] - n].erase(s[f[x] - n].find(a[x])); s[f[x] - n].insert(y); a[f[x]] = *s[f[x] - n].begin(); a[x] = y; update(1, 1, node, dfn[f[x]], a[f[x]]); &#125; else &#123; int ans = INF; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ans = min(ans, query(1, 1, node, dfn[top[x]], dfn[x])); x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); ans = min(ans, query(1, 1, node, dfn[x], dfn[y])); if (x > n) ans = min(ans, a[f[x]]); printf(\"%d\\n\", ans); &#125; &#125; return 0; &#125; å›¾ä¸Šä¹±æ ä¸€äº›å¥‡æ€ªçš„é—®é¢˜ã€‚ [CSP-S 2022] æ˜Ÿæˆ˜ Portal. è¯´çš„æ˜¯æ‰€æœ‰ç‚¹çš„å‡ºåº¦ä¸º 111ï¼Œä½†æ˜¯è¿™æ ·ä¸å¥½ç»´æŠ¤ï¼Œè½¬åŒ–ä¸ºå…¥åº¦è¿›è¡Œç»´æŠ¤ï¼Œæä¸€ä¸ªå“ˆå¸Œæé«˜æ­£ç¡®ç‡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; mt19937 Rand(time(0)); int n, m, q; u64 r[500005], g[500005]; // å…¥åº¦ï¼Œå…¨éƒ¨å…¥åº¦ u64 w[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); u64 ans = 0, res = 0; for (int i = 1; i &lt;= n; ++i) ans += (w[i] = Rand()); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); r[v] += w[u]; g[v] = r[v]; res += w[u]; &#125; for (scanf(\"%d\", &amp;q); q--; ) &#123; int op, u, v; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%d%d\", &amp;u, &amp;v); r[v] -= w[u]; res -= w[u]; &#125; else if (op == 2) &#123; scanf(\"%d\", &amp;v); res -= r[v]; r[v] = 0; &#125; else if (op == 3) &#123; scanf(\"%d%d\", &amp;u, &amp;v); r[v] += w[u]; res += w[u]; &#125; else &#123; scanf(\"%d\", &amp;v); res += g[v] - r[v]; r[v] = g[v]; &#125; puts(res == ans ? \"YES\" : \"NO\"); &#125; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"å›¾è®º","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/å›¾è®º","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"åŠ¨æ€è§„åˆ’çš„çŠ¶æ€è®¾è®¡","slug":"notes/DP/status-dp","date":"2023-01-09T00:00:00.000Z","updated":"2023-04-01T00:00:00.000Z","comments":true,"path":"bb10c5df/","link":"","permalink":"https://james1badcreeper.github.io/bb10c5df/","excerpt":"åŠ¨æ€è§„åˆ’çš„çŠ¶æ€è®¾è®¡æœ‰è®¸å¤šå€¼å¾—æ¢è®¨çš„å†…å®¹ã€‚æœ¬æ–‡ä¼šä»åŸºæœ¬æ¨¡å‹è®²èµ·ï¼Œæ‹“å±•åˆ°ä¸€äº›å¤æ‚çš„å†…å®¹ã€‚","text":"åŠ¨æ€è§„åˆ’çš„çŠ¶æ€è®¾è®¡æœ‰è®¸å¤šå€¼å¾—æ¢è®¨çš„å†…å®¹ã€‚æœ¬æ–‡ä¼šä»åŸºæœ¬æ¨¡å‹è®²èµ·ï¼Œæ‹“å±•åˆ°ä¸€äº›å¤æ‚çš„å†…å®¹ã€‚ è¿™é‡Œçš„åŸºæœ¬æ¨¡å‹å¹¶ä¸ä¼šä»åŸºç¡€å¼€å§‹ï¼Œè¯·ç¡®ä¿ä½ å·²ç»äº†è§£å®ƒä»¬ã€‚ ç®€å•é—®é¢˜ è¿™é‡Œçš„é—®é¢˜æ¯”è¾ƒç®€å•ã€‚ èƒŒåŒ…é—®é¢˜ è¿™æ˜¯ä¸€ç§å¾ˆåŸºç¡€çš„æ¨¡å‹ï¼Œè¿™é‡Œä»…è¡¥å……ä¸€ä¸ªçŸ¥è¯†ç‚¹ã€‚ æ–¹æ¡ˆæ•°èƒŒåŒ…çš„æ’¤å› å…¶å®ä¹‹å‰å·²ç»è§è¿‡è¿™ç±»é—®é¢˜ï¼Œè¿™é‡Œæ€»ç»“ä¸€ä¸‹ã€‚ èƒŒåŒ…çš„æ·»åŠ ç‰©å“å¾ˆå®¹æ˜“ï¼Œä½†æ˜¯åˆ é™¤ç‰©å“å¾ˆéš¾ã€‚æˆ‘ä»¬é‡‡ç”¨è¿‡å‰åç¼€åˆå¹¶çš„åŠæ³•ï¼ˆä½†æ˜¯éœ€è¦æšä¸¾ä½“ç§¯ï¼‰ï¼Œä¹Ÿæœ‰çº¿æ®µæ ‘åˆ†æ²»çš„åšæ³•ã€‚ä½†æ˜¯å¯¹äºæ–¹æ¡ˆæ•°èƒŒåŒ…ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•æ’¤å›ï¼šåªéœ€è¦å‡å»å½“æ—¶åŠ ä¸Šçš„å†…å®¹å°±è¡Œäº†ã€‚ä½†æ˜¯è¦æ³¨æ„å¾ªç¯é¡ºåºï¼Œåº”è¯¥æ˜¯ç›¸åçš„ã€‚ åŒºé—´ DP æœ€é‡è¦çš„ç‰¹ç‚¹æ˜¯â€œåˆå¹¶â€ï¼Œå¦‚æœé¢˜ç›®æœ‰è¿™ç§æ„Ÿè§‰ï¼Œé‚£ä¹ˆåŒºé—´ DP å¤§æ¦‚ç‡æ˜¯å¯åšçš„ã€‚å¦å¤–çš„çŸ¥è¯†ç‚¹å°±æ˜¯æ–­ç¯ä¸ºé“¾ï¼Œå¯ä»¥é«˜æ•ˆè§£å†³ç¯ä¸Šçš„åŒºé—´ DP é—®é¢˜ã€‚ ç”±äºåŒºé—´ DP çš„å¸¸æ•°å¾ˆå°ï¼ˆä»¥ä¸‹æ•°æ®èŒƒå›´çš„å¾ªç¯æ¬¡æ•°çº¦ä¸º 10910^9109 æ¬¡ï¼‰ï¼Œæ‰€ä»¥åœ¨éœ€è¦æšä¸¾æ–­ç‚¹ï¼ˆO(n3)O(n^3)O(n3)ï¼‰æ—¶ï¼Œä¸€èˆ¬å¯ä»¥è§£å†³ 2Ã—1032\\times 10^32Ã—103 çº§åˆ«çš„é—®é¢˜ï¼›ä¸éœ€è¦æšä¸¾æ–­ç‚¹ï¼ˆä»ä¸¤å¤´æ‰©å±•ï¼ŒO(n2)O(n^2)O(n2) æ—¶ï¼‰ï¼Œä¸€èˆ¬å¯ä»¥è§£å†³ 5Ã—1045\\times 10^45Ã—104 çš„é—®é¢˜ã€‚ åŒºé—´ DP ä¹Ÿå¯ä»¥æ‰©å±•åˆ°äºŒç»´æƒ…å†µï¼Œæ­¤æ—¶ä¸€èˆ¬ä¼šä½¿ç”¨è®°å¿†åŒ–æœç´¢å®ç°ï¼Œæ¨¡æ¿é¢˜å¯ä»¥å‚è€ƒ CF1198Dï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int f[55][55][55][55]; char s[55][55]; int dfs(int x, int y, int _x, int _y) &#123; if (f[x][y][_x][_y] != -1) return f[x][y][_x][_y]; if (x == _x &amp;&amp; y == _y) return f[x][y][_x][_y] = (s[x][y] == '#'); int res = max(_x - x + 1, _y - y + 1); for (int i = x; i &lt; _x; ++i) res = min(res, dfs(x, y, i, _y) + dfs(i + 1, y, _x, _y)); for (int i = y; i &lt; _y; ++i) res = min(res, dfs(x, y, _x, i) + dfs(x, i + 1, _x, _y)); return f[x][y][_x][_y] = res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); memset(f, -1, sizeof f); for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", s[i] + 1); printf(\"%d\\n\", dfs(1, 1, n, n)); return 0; &#125; æ ‘å½¢ DP ä¸»è¦åˆ†ä¸ºæ‹“æ‰‘åºé—®é¢˜å’ŒèƒŒåŒ…é—®é¢˜ï¼Œå¯¹äºå­æ ‘çš„å¤„ç†è¿˜ä¼šæ¶‰åŠåˆ°æ¢æ ¹ã€‚åœ¨è®¾è®¡çš„æ—¶å€™ï¼Œä¸€å®šè¦æ³¨æ„å­æ ‘çš„åˆå¹¶æ˜¯æ¯æ¬¡åŠ ä¸€ä¸ªç‚¹è¿˜æ˜¯ä¸€æ¡è¾¹ã€‚ å¯¹äºå¤šæ¬¡æ ‘å½¢ DPï¼Œå¯ä»¥æ‹æˆ DFS åºè¿›è¡Œä¼˜åŒ–ã€‚åˆ©ç”¨ DFS åºä»å¤§åˆ°å°å‘çˆ¶äº²è½¬ç§»ï¼Œå¯ä»¥å¾ˆé«˜æ•ˆåœ°å®ç°æ ‘å½¢ DPã€‚ çŠ¶å‹ DP å½“éš¾åº¦ä¸Šæ¥ä¹‹åï¼Œä¼šå‘ç°çŠ¶å‹ DP ç›¸å½“éº»çƒ¦ã€‚è¿™é‡Œè¡¥å……å‡ ä¸ªæ¯”è¾ƒå®ç”¨çš„çŸ¥è¯†ç‚¹ã€‚ å­é›† DP [NOIP2017 æé«˜ç»„] å®è—ã€‚ è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨å½“å‰ç‚¹é›†ä¸º iiiï¼Œæ ‘çš„æœ€æ·±èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»ä¸º jjjã€‚æšä¸¾ iii çš„å­é›†ï¼Œè®©ä¸æ˜¯å®ƒå­é›†çš„é‚£äº›éƒ½ä½œä¸ºç¬¬ jjj å±‚çš„å„¿å­è¿æ¥ã€‚æšä¸¾å­é›†çš„å­é›†çš„æ—¶é—´å¤æ‚åº¦ä¸º O(âˆ‘Cnk2k)=O(3n)O(\\sum C_{n}^{k}2^k)=O(3^n)O(âˆ‘Cnkâ€‹2k)=O(3n) çº§åˆ«ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int INF = 0x3f3f3f3f; int n, m, A[15][15]; int f[32770][17], v[32770]; // ç‚¹é›†ä¸º iï¼Œæ·±åº¦ä¸º j int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(A, 0x3f, sizeof(A)); while (m--) &#123; int a, b, c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); --a; --b; A[a][b] = A[b][a] = min(A[a][b], c); &#125; memset(f, 0x3f, sizeof(f)); for (int i = 0; i &lt; n; ++i) f[1 &lt;&lt; i][0] = A[i][i] = 0; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (i &amp; (1 &lt;&lt; j)) for (int k = 0; k &lt; n; ++k) if (A[j][k] != INF) v[i] |= (1 &lt;&lt; k); for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) for (int s = i - 1 &amp; i; s; s = s - 1 &amp; i) if ((v[s] &amp; i) == i) &#123; int ss = s ^ i, sum = 0; for (int j = 0; j &lt; n; ++j) if (ss &amp; (1 &lt;&lt; j)) &#123; int tmp = INF; for (int k = 0; k &lt; n; ++k) if (s &amp; (1 &lt;&lt; k)) tmp = min(tmp, A[j][k]); sum += tmp; &#125; for (int j = 1; j &lt; n; ++j) if (f[s][j - 1] != INF) f[i][j] = min(f[i][j], f[s][j - 1] + sum * j); &#125; int ans = INF; for (int i = 0; i &lt; n; ++i) ans = min(ans, f[(1 &lt;&lt; n) - 1][i]); printf(\"%d\\n\", ans); return 0; &#125; æ’å¤´ DP åˆ¶æ¯’å¤§æ­æŠ•æ·äº†ç¥ç§˜çš„æ¯’è¯ã€‚å°†äºæœªçŸ¥çš„æ—¶é—´è¡¥å……ã€‚ è®¡æ•°ç±» DP ä¸¥æ ¼æ¥è¯´ï¼Œè®¡æ•°ç±» DP ä¸æ˜¯ DPã€‚åŠ¨æ€è§„åˆ’æ˜¯ä¸€ç±»æœ€ä¼˜åŒ–é—®é¢˜ï¼Œè€Œè®¡æ•°ç±»é—®é¢˜ç»Ÿè®¡çš„æ˜¯æ–¹æ¡ˆæ•°ï¼Œä½†æ˜¯è®¡æ•°æ—¶è¦æ±‚â€œä¸é‡ä¸æ¼â€ï¼Œéœ€è¦ç²¾ç¡®çš„åˆ’åˆ†å’Œæ•´ä½“æ€§çš„è®¡ç®—ï¼Œå› æ­¤ä½¿ç”¨åŠ¨æ€è§„åˆ’çš„å­ç»“æ„ä¸å¤šé˜¶æ®µå¯ä»¥é«˜æ•ˆçš„æ±‚è§£è®¡æ•°ç±» DPï¼Œå®ç°ä¸Šè¿™ç§æ–¹æ³•åªèƒ½å«åšé€’æ¨ã€‚ å…¶å®è®¡æ•° DP ä¼šä¸å¾ˆå¤šç»„åˆæ–¹æ³•ç»¼åˆï¼Œæˆ‘ä»¬ä¼šè§åˆ°çš„ã€‚ å¼•å­ æˆ‘ä»¬åšå‡ é“ç®€å•é¢˜ï¼Œ [HAOI2010] æœ€é•¿å…¬å…±å­åºåˆ— Portal. æ±‚æœ€é•¿å…¬å…±å­åºåˆ—å·²ç»å¾ˆç®€å•äº†ï¼Œè‡³äºæ•°é‡ï¼Œå°±æ˜¯è¦çœ‹å®ƒä»å“ªé‡Œè½¬ç§»è¿‡æ¥ã€‚è®¾ g(i,j)g(i,j)g(i,j) ä»£è¡¨ A1â€¦Ai,B1â€¦BjA_1\\dots A_i,B_1\\dots B_jA1â€‹â€¦Aiâ€‹,B1â€‹â€¦Bjâ€‹ çš„ LCS ä¸ªæ•°ï¼Œf(i,j)f(i,j)f(i,j) ä»£è¡¨ A1â€¦Ai,B1â€¦BjA_1\\dots A_i,B_1\\dots B_jA1â€‹â€¦Aiâ€‹,B1â€‹â€¦Bjâ€‹ çš„ LCS é•¿åº¦ï¼Œé‚£ä¹ˆï¼š å¦‚æœ g(i,j)g(i,j)g(i,j) å¯ä»¥ä» g(iâˆ’1,j)g(i-1,j)g(iâˆ’1,j) è½¬ç§»è¿‡æ¥ï¼Œé‚£ä¹ˆéœ€è¦åŠ ä¸Šå®ƒçš„æ–¹æ¡ˆæ•°ï¼› å¦‚æœ g(i,j)g(i,j)g(i,j) å¯ä»¥ä» g(i,jâˆ’1)g(i,j-1)g(i,jâˆ’1) è½¬ç§»è¿‡æ¥ï¼Œé‚£ä¹ˆéœ€è¦åŠ ä¸Šå®ƒçš„æ–¹æ¡ˆæ•°ï¼› å¦‚æœ g(i,j)g(i,j)g(i,j) å¯ä»¥ä» g(iâˆ’1,jâˆ’1)g(i-1,j-1)g(iâˆ’1,jâˆ’1) è½¬ç§»è¿‡æ¥ï¼Œé‚£ä¹ˆéœ€è¦åŠ ä¸Šå®ƒçš„æ–¹æ¡ˆæ•°ã€‚ ä½†æ˜¯å¦‚æœå‰ä¸¤æ¡åŒæ—¶ç”Ÿæ•ˆï¼Œé‚£ä¹ˆä¼šå‡ºç°ä¸€ä¸ªé—®é¢˜ï¼šf(i,j)=f(iâˆ’1,j)=f(i,jâˆ’1)f(i,j)=f(i-1,j)=f(i,j-1)f(i,j)=f(iâˆ’1,j)=f(i,jâˆ’1)ï¼Œå¦‚æœæ­¤æ—¶ f(iâˆ’1,j),f(i,jâˆ’1)f(i-1,j),f(i,j-1)f(iâˆ’1,j),f(i,jâˆ’1) éƒ½å¯ä»¥ä» f(iâˆ’1,jâˆ’1)f(i-1,j-1)f(iâˆ’1,jâˆ’1) è½¬ç§»ï¼Œé‚£ä¹ˆè¿™é‡Œå°±é‡å¤äº†ï¼Œéœ€è¦å‡å» g(iâˆ’1,jâˆ’1)g(i-1,j-1)g(iâˆ’1,jâˆ’1)ã€‚è¿™ç§æƒ…å†µæ˜¯ä»€ä¹ˆæ—¶å€™ï¼Ÿå°±æ˜¯å½“ä¸Šè¿°çš„ç¬¬ä¸‰ç§è½¬ç§»æ²¡æœ‰ç”Ÿæ•ˆçš„æ—¶å€™ã€‚ä¹Ÿå°±æ˜¯ f(i,j)=f(iâˆ’1,jâˆ’1)f(i,j) = f(i-1,j-1)f(i,j)=f(iâˆ’1,jâˆ’1)ï¼Œè¿™æ ·çš„è¯ f(iâˆ’1,jâˆ’1)=f(iâˆ’1,j)=f(i,jâˆ’1)f(i-1,j-1)=f(i-1,j)=f(i,j-1)f(iâˆ’1,jâˆ’1)=f(iâˆ’1,j)=f(i,jâˆ’1)ï¼Œä¹Ÿå°±æ˜¯è¯´ f(iâˆ’1,j),f(i,jâˆ’1)f(i-1,j),f(i,j-1)f(iâˆ’1,j),f(i,jâˆ’1) éƒ½å¯ä»¥ä» f(iâˆ’1,jâˆ’1)f(i-1,j-1)f(iâˆ’1,jâˆ’1) è½¬ç§»è¿‡æ¥ã€‚ ç”±äºç©ºé—´é™åˆ¶ï¼Œæ‰€ä»¥è¦ä½¿ç”¨æ»šåŠ¨æ•°ç»„ã€‚ æŸ¥çœ‹ä»£ç  // ç”±äºè¿™ä»½ä»£ç çš„å¸¸æ•°è¾ƒå¤§ï¼Œå¯èƒ½éœ€è¦å¸æ°§æ‰èƒ½è¿‡ #include &lt;bits/stdc++.h> #define i64 long long using namespace std; const int MOD = 100000000; char a[5005], b[5005]; int n, m, f[2][5005]; i64 g[2][5005]; int main(void) &#123; scanf(\"%s%s\", a + 1, b + 1); n = strlen(a + 1) - 1, m = strlen(b + 1) - 1; for (int i = 0; i &lt;= m; ++i) g[0][i] = 1; g[1][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; f[i &amp; 1][j] = max(&#123;f[i &amp; 1][j - 1], f[(i - 1) &amp; 1][j], f[(i - 1) &amp; 1][j - 1] + (a[i] == b[j])&#125;); g[i &amp; 1][j] = 0; if (f[i &amp; 1][j] == f[(i - 1) &amp; 1][j]) g[i &amp; 1][j] += g[(i - 1) &amp; 1][j]; if (f[i &amp; 1][j] == f[i &amp; 1][j - 1]) g[i &amp; 1][j] += g[i &amp; 1][j - 1]; if (f[i &amp; 1][j] == f[(i - 1) &amp; 1][j - 1] + 1 &amp;&amp; a[i] == b[j]) g[i &amp; 1][j] += g[(i - 1) &amp; 1][j - 1]; if (f[i &amp; 1][j] == f[(i - 1) &amp; 1][j - 1]) g[i &amp; 1][j] -= g[(i - 1) &amp; 1][j - 1]; g[i &amp; 1][j] %= MOD; &#125; printf(\"%d\\n%lld\\n\", f[n &amp; 1][m], g[n &amp; 1][m]); return 0; &#125; [CF149D] Coloring Brackets Portal. è®¾ f(i,j,p,q)f(i,j,p,q)f(i,j,p,q) ä¸ºè€ƒè™‘åŒºé—´ [i,j][i,j][i,j]ï¼Œiii çš„é¢œè‰²ä¸º pppï¼Œjjj çš„é¢œè‰²ä¸º qqq çš„æ–¹æ¡ˆæ•°ã€‚è½¬ç§»ä¹Ÿå¾ˆå¥½å†™ï¼Œç”¨ dfs å®ç°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define i64 long long using namespace std; const int MOD = 1000000007; int n; char s[705]; int match[705]; int f[705][705][3][3]; void dfs(int l, int r) &#123; #define rep(i) for (int i = 0; i &lt;= 2; ++i) if (l + 1 == r) &#123; f[l][r][0][1] = 1; f[l][r][0][2] = 1; f[l][r][1][0] = 1; f[l][r][2][0] = 1; return; &#125; if (match[l] == r) &#123; dfs(l + 1, r - 1); rep(i) rep(j) &#123; if (i != 1) f[l][r][1][0] = (f[l][r][1][0] + f[l + 1][r - 1][i][j]) % MOD; if (i != 2) f[l][r][2][0] = (f[l][r][2][0] + f[l + 1][r - 1][i][j]) % MOD; if (j != 1) f[l][r][0][1] = (f[l][r][0][1] + f[l + 1][r - 1][i][j]) % MOD; if (j != 2) f[l][r][0][2] = (f[l][r][0][2] + f[l + 1][r - 1][i][j]) % MOD; &#125; return; &#125; dfs(l, match[l]), dfs(match[l] + 1, r); rep(i) rep(j) rep(p) rep(q) &#123; if (j == p &amp;&amp; j != 0) continue; f[l][r][i][q] = (f[l][r][i][q] + (i64)f[l][match[l]][i][j] * f[match[l] + 1][r][p][q]) % MOD; &#125; &#125; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); stack &lt;int> st; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] == '(') st.push(i); else match[st.top()] = i, match[i] = st.top(), st.pop(); &#125; dfs(1, n); int ans = 0; for (int i = 0; i &lt;= 2; ++i) for (int j = 0; j &lt;= 2; ++j) ans = (ans + f[1][n][i][j]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; ç®€å•ç»„åˆ ç»„åˆæ•°ï¼Œç»„åˆæ–¹æ³•è¿™äº›å¯¹äºè¯»è€…æ¥è¯´ä¸€å®šä¸é™Œç”Ÿã€‚å®ƒä»¬æ˜¯ä¸å¤šé˜¶æ®µè®¡æ•°çš„æœ€ä½³æ‹æ¡£ã€‚ [AHOI2009] ä¸­å›½è±¡æ£‹ Portal. æ˜¾ç„¶æ¯ä¸€è¡Œã€æ¯ä¸€åˆ—éƒ½æœ€å¤šåªèƒ½æœ‰ä¸¤ä¸ªæ£‹å­ã€‚å®šä¹‰ f(i,j,k)f(i,j,k)f(i,j,k) ä¸ºè€ƒè™‘å‰ iii è¡Œï¼Œæœ‰ jjj åˆ—æ˜¯ä¸€ä¸ªæ£‹å­ï¼Œkkk åˆ—æ˜¯ä¸¤ä¸ªæ£‹å­ï¼Œå‰©ä¸‹çš„ mâˆ’jâˆ’km-j-kmâˆ’jâˆ’k åˆ—æ²¡æœ‰æ£‹å­ï¼Œæ˜¾ç„¶è®¡ç®—æ—¶è¦æ»¡è¶³ j+kâ‰¤mj+k\\le mj+kâ‰¤mã€‚ åˆå§‹è‚¯å®š f(0,0,0)=1f(0,0,0)=1f(0,0,0)=1ï¼Œæ¥ä¸‹æ¥ä¸€è¡Œä¸€è¡Œçš„è€ƒè™‘ã€‚ ç¬¬ iii è¡Œè‚¯å®šå¯ä»¥ä»€ä¹ˆéƒ½ä¸æ”¾ï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨ f(iâˆ’1,j,k)f(i-1,j,k)f(iâˆ’1,j,k) åˆå§‹åŒ– f(i,j,k)f(i,j,k)f(i,j,k)ã€‚ ç„¶åè€ƒè™‘ç¬¬ iii è¡Œæ”¾ä»€ä¹ˆã€‚æ˜¾ç„¶è¦ä¹ˆæ”¾ 111 ä¸ªæ£‹å­ï¼Œè¦ä¹ˆæ”¾ 222 ä¸ªæ£‹å­ã€‚ å½“æ”¾ä¸€ä¸ªæ£‹å­çš„æ—¶å€™ï¼Œè¿™ä¸ªæ£‹å­å¯ä»¥æ”¾åœ¨æ²¡æœ‰æ£‹å­çš„åˆ—ï¼Œä¹Ÿå¯ä»¥æ”¾åœ¨æœ‰ 111 ä¸ªæ£‹å­çš„åˆ—ã€‚å¦‚æœæ”¾åœ¨æ²¡æœ‰æ£‹å­çš„åˆ—ï¼Œè¯´æ˜å½“å‰çš„ f(i,j,k)f(i,j,k)f(i,j,k) æ˜¯ä» f(iâˆ’1,jâˆ’1,k)f(i-1,j-1,k)f(iâˆ’1,jâˆ’1,k) è¿‡æ¥çš„ï¼ˆå¤šäº†ä¸€ä¸ªæœ‰ 111 ä¸ªæ£‹å­çš„åˆ—ï¼‰ï¼Œæ”¾çš„æ—¶å€™æœ‰ mâˆ’(jâˆ’1)âˆ’km-(j-1)-kmâˆ’(jâˆ’1)âˆ’k ä¸ªç©ºåˆ—ï¼Œéšä¾¿é€‰ä¸€ä¸ªå³å¯ã€‚å¦‚æœæ”¾åœ¨æœ‰ä¸€ä¸ªæ£‹å­çš„åˆ—ï¼Œè¯´æ˜å½“å‰çš„ f(i,j,k)f(i,j,k)f(i,j,k) æ˜¯ä» f(iâˆ’1,j+1,kâˆ’1)f(i-1,j+1,k-1)f(iâˆ’1,j+1,kâˆ’1) è¿‡æ¥çš„ï¼ˆæœ‰ä¸€ä¸ªæ£‹å­çš„å°‘äº†ä¸€ä¸ªï¼Œä¸¤ä¸ªæ£‹å­çš„å¤šäº†ä¸€ä¸ªï¼‰ï¼Œé€‰æ‹©æ—¶åœ¨ j+1j+1j+1 ä¸ªæœ‰ä¸€ä¸ªæ£‹å­çš„åˆ—éšä¾¿é€‰ä¸€ä¸ªå³å¯ã€‚ å½“æ”¾ä¸¤ä¸ªæ£‹å­çš„æ—¶å€™ï¼Œè¿™ä¸¤ä¸ªæ£‹å­å¯ä»¥éƒ½æ”¾åœ¨æ²¡æœ‰æ£‹å­çš„åˆ—ï¼Œè¿™æ ·å®ƒä» f(iâˆ’1,jâˆ’2,k)f(i-1,j-2,k)f(iâˆ’1,jâˆ’2,k) è¿‡æ¥çš„ï¼Œæ”¾çš„æ—¶å€™çš„åœ¨ mâˆ’(jâˆ’2)âˆ’km-(j-2)-kmâˆ’(jâˆ’2)âˆ’k ä¸ªç©ºåˆ—ä¸­ç»„åˆï¼Œå…±æœ‰ Cmâˆ’(jâˆ’2)âˆ’k2C_{m-(j-2)-k}^2Cmâˆ’(jâˆ’2)âˆ’k2â€‹ ä¸­å¯èƒ½ï¼›ä¹Ÿå¯ä»¥éƒ½æ”¾åœ¨æœ‰ä¸€ä¸ªæ£‹å­çš„åˆ—ï¼Œä» f(iâˆ’1,j+2,kâˆ’2)f(i-1,j+2,k-2)f(iâˆ’1,j+2,kâˆ’2) è¿‡æ¥ï¼Œæœ‰ Cmâˆ’(j+2)âˆ’k2C_{m-(j+2)-k}^2Cmâˆ’(j+2)âˆ’k2â€‹ï¼›è¿˜å¯ä»¥ä¸€ä¸ªæ”¾åœ¨æ²¡æœ‰æ£‹å­çš„åˆ—ï¼Œä¸€ä¸ªæ”¾åœ¨æœ‰ä¸€ä¸ªæ£‹å­çš„åˆ—ï¼Œä» f(iâˆ’1,j,kâˆ’1)f(i-1,j,k-1)f(iâˆ’1,j,kâˆ’1) è¿‡æ¥ï¼ˆä¸€ä¸ªæ”¾åœ¨æ²¡æœ‰æ£‹å­çš„åˆ—ä½¿å¾— j+1j+1j+1ï¼Œä¸€ä¸ªæ”¾åœ¨æœ‰ä¸€ä¸ªæ£‹å­çš„åˆ—ä½¿å¾— jâˆ’1,k+1j-1,k+1jâˆ’1,k+1ï¼Œç»¼åˆèµ·æ¥å°±æ˜¯ jjj ä¸å˜ï¼Œk+1k+1k+1ï¼‰ï¼Œé€‰æ‹©æ—¶æ”¾åœ¨æ²¡æœ‰æ£‹å­çš„åˆ—çš„é€‰æ‹©æœ‰ mâˆ’jâˆ’(kâˆ’1)m-j-(k-1)mâˆ’jâˆ’(kâˆ’1) ç§ï¼Œæ”¾åœ¨æœ‰ä¸€ä¸ªæ£‹å­çš„åˆ—çš„é€‰æ‹©æœ‰ jjj ç§ã€‚ å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–ç©ºé—´ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const int MOD = 9999973; int n, m; i64 f[2][105][105]; // è€ƒè™‘å‰ i è¡Œï¼Œæœ‰ j åˆ—æ˜¯ä¸€ä¸ªæ£‹å­ï¼Œk åˆ—æ˜¯ä¸¤ä¸ªæ£‹å­ int C(int n) &#123; return (n * (n - 1)) / 2; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); f[0][0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j) for (int k = 0; j + k &lt;= m; ++k) &#123; f[i &amp; 1][j][k] = f[(i - 1) &amp; 1][j][k]; if (/*m - j + 1 - k >= 0 &amp;&amp; */j >= 1) f[i &amp; 1][j][k] += f[(i - 1) &amp; 1][j - 1][k] * (m - j + 1 - k); // æ”¾ä¸€ä¸ªæ£‹å­ï¼Œæ”¾åœ¨æ²¡æœ‰æ£‹å­çš„åˆ— if (k >= 1) f[i &amp; 1][j][k] += (f[(i - 1) &amp; 1][j + 1][k - 1]) * (j + 1); // æ”¾ä¸€ä¸ªæ£‹å­åœ¨æœ‰ä¸€ä¸ªæ£‹å­çš„åˆ— if (/*m - j + 2 - k >= 0 &amp;&amp; */j >= 2) f[i &amp; 1][j][k] += f[(i - 1) &amp; 1][j - 2][k] * C(m - j + 2 - k); // æ”¾ä¸¤ä¸ªæ£‹å­åœ¨éƒ½æ²¡æœ‰æ£‹å­çš„åˆ— if (k >= 2) f[i &amp; 1][j][k] += f[(i - 1) &amp; 1][j + 2][k - 2] * C(j + 2); // æ”¾ä¸¤ä¸ªæ£‹å­åœ¨éƒ½æœ‰ä¸€ä¸ªæ£‹å­çš„åˆ— if (/*m - j - k + 1 >= 0 &amp;&amp; */k >= 1) f[i &amp; 1][j][k] += f[(i - 1) &amp; 1][j][k - 1] * j * (m - j - k + 1); // æ”¾ä¸¤ä¸ªæ£‹å­ï¼Œä¸€ä¸ªåœ¨æœ‰ä¸€ä¸ªæ£‹å­çš„åˆ—ï¼Œä¸€ä¸ªåœ¨æ²¡æœ‰æ£‹å­çš„åˆ— f[i &amp; 1][j][k] %= MOD; &#125; i64 ans = 0; for (int i = 0; i &lt;= m; ++i) for (int j = 0; i + j &lt;= m; ++j) ans = (ans + f[n &amp; 1][i][j]) % MOD; printf(\"%lld\\n\", ans); return 0; &#125; [CF425E] Sereja and Sets Portal. è®¾ f(r,i)f(r,i)f(r,i) ä¸ºå³ç«¯ç‚¹ä¸º rrrï¼Œæ—¶é—´ä¸º iii çš„æ–¹æ¡ˆæ•°ã€‚è½¬ç§»é‡‡ç”¨åˆ·è¡¨æ³•ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 1000000007; int n, k; i64 f[505][505], poww[250005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); f[0][0] = 1; poww[0] = 1; for (int i = 1; i &lt;= n * n; ++i) poww[i] = poww[i - 1] * 2 % MOD; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= i; ++j) for (int k = i + 1; k &lt;= n; ++k) f[k][j + 1] = (f[k][j + 1] + f[i][j] * (poww[k - i] - 1) % MOD * poww[(n - k) * (k - i)]) % MOD; i64 ans = 0; for (int i = 0; i &lt;= n; ++i) ans += f[i][k]; printf(\"%lld\\n\", ans % MOD); return 0; &#125; [NOIP2021] æ•°åˆ— Portal.ç»™å®šæ•´æ•° n,m,k(kâ‰¤nâ‰¤30,mâ‰¤100)n, m, k(k\\le n\\le 30,m\\le 100)n,m,k(kâ‰¤nâ‰¤30,mâ‰¤100)ï¼Œå’Œä¸€ä¸ªé•¿åº¦ä¸º m+1m + 1m+1 çš„æ­£æ•´æ•°æ•°ç»„ v0,v1,â€¦,vmv_0, v_1, \\ldots, v_mv0â€‹,v1â€‹,â€¦,vmâ€‹ã€‚å¯¹äºä¸€ä¸ªé•¿åº¦ä¸º nnnï¼Œä¸‹æ ‡ä» 111 å¼€å§‹ä¸”æ¯ä¸ªå…ƒç´ å‡ä¸è¶…è¿‡ mmm çš„éè´Ÿæ•´æ•°åºåˆ— {ai}\\{a_i\\}{aiâ€‹}ï¼Œæˆ‘ä»¬å®šä¹‰å®ƒçš„æƒå€¼ä¸º va1Ã—va2Ã—â‹¯Ã—vanv_{a_1} \\times v_{a_2} \\times \\cdots \\times v_{a_n}va1â€‹â€‹Ã—va2â€‹â€‹Ã—â‹¯Ã—vanâ€‹â€‹ã€‚å½“è¿™æ ·çš„åºåˆ— {ai}\\{a_i\\}{aiâ€‹} æ»¡è¶³æ•´æ•° S=2a1+2a2+â‹¯+2anS = 2^{a_1} + 2^{a_2} + \\cdots + 2^{a_n}S=2a1â€‹+2a2â€‹+â‹¯+2anâ€‹ çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ 111 çš„ä¸ªæ•°ä¸è¶…è¿‡ kkk æ—¶ï¼Œæˆ‘ä»¬è®¤ä¸º {ai}\\{a_i\\}{aiâ€‹} æ˜¯ä¸€ä¸ªåˆæ³•åºåˆ—ã€‚è®¡ç®—æ‰€æœ‰åˆæ³•åºåˆ— {ai}\\{a_i\\}{aiâ€‹} çš„æƒå€¼å’Œå¯¹ 998244353998244353998244353 å–æ¨¡çš„ç»“æœã€‚ SSS åœ¨ç»Ÿè®¡æ—¶æ˜¯ä¼šè¿›ä½çš„ï¼Œå› æ­¤æˆ‘ä»¬è®¾ f(i,j,k,p)f(i,j,k,p)f(i,j,k,p) ä»£è¡¨è€ƒè™‘ SSS ä»ä½ä½å¼€å§‹çš„å‰ iii ä½ï¼Œè€ƒè™‘äº† jjj ä¸ªæ•°ï¼ˆä»»æ„ï¼‰ï¼Œæœ‰ kkk ä¸ª 111ï¼ˆç”±äºæ˜¯åŠ æ³•ï¼Œ111 åªèƒ½å˜å¤šä¸èƒ½å˜å°‘ï¼‰ï¼Œå‘ä¸‹ä¸€ä½çš„è¿›ä½ä¸º pppï¼ˆçŠ¶æ€ä¸­çš„ SSS æŒ‰ç…§äºŒè¿›åˆ¶è€ƒè™‘ï¼Œç¬¬ iii ä½æœ‰ ppp ä¸ª 111ï¼Œå¾ˆæ˜¾ç„¶è¿™æ ·å‹æ ¹å°±æ²¡æœ‰è€ƒè™‘è¿›ä½ï¼Œè¿›ä½æ˜¯åœ¨è½¬ç§»çš„æ—¶å€™è¿›è¡Œçš„ï¼‰ã€‚æ˜¾ç„¶åˆå§‹æ—¶æœ‰ f(0,0,0,0)=1f(0,0,0,0)=1f(0,0,0,0)=1ï¼Œæ¥ä¸‹æ¥è€ƒè™‘å¦‚ä½•è½¬ç§»ã€‚ æ˜¾ç„¶åˆ·è¡¨æ³•ä¼šæ›´å®¹æ˜“ä¸€äº›ã€‚å‡è®¾å†ç»™åºåˆ— aaa é€‰æ‹© ttt ä¸ªå…ƒç´  iiiï¼Œé‚£ä¹ˆ SSS çš„ç¬¬ iii ä½å°±ä¼šåŠ ä¸Š ttt ä¸ª 111ï¼Œæ€»å…±å°±æœ‰äº† t+pt+pt+p ä¸ª 111ã€‚åŒæ—¶æˆ‘ä»¬è¦å°†ç¬¬ iii ä½è¿›è¡Œâ€œå±•å¹³â€ï¼Œä¹Ÿå°±æ˜¯å‘å‰è¿›ä½ã€‚å¦‚æœ t+pt+pt+p æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆ 111 çš„ä¸ªæ•°å°±å¤šäº† 111ï¼Œå¦åˆ™æ²¡å˜ï¼›å‘å‰è¿›ä½çš„ä¸ªæ•°ä¸º âŒŠt+p2âŒ‹\\left\\lfloor\\cfrac{t+p}{2}\\right\\rfloorâŒŠ2t+pâ€‹âŒ‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œf(i,j,k,p)f(i,j,k,p)f(i,j,k,p) è½¬ç§»åˆ°äº†ï¼š f(i+1,j+t,k+(t+p) mod 2,âŒŠt+p2âŒ‹)f\\left(i+1,j+t,k+(t+p)\\bmod 2,\\left\\lfloor\\frac{t+p}{2}\\right\\rfloor\\right) f(i+1,j+t,k+(t+p)mod2,âŒŠ2t+pâ€‹âŒ‹) è´¡çŒ®æ˜¯å¤šå°‘ï¼ŸåŸºæ•°æ˜¯ f(i,j,k,p)f(i,j,k,p)f(i,j,k,p)ï¼Œè¿™ç§è½¬ç§»å…±æœ‰ (nâˆ’jt)\\dbinom{n-j}{t}(tnâˆ’jâ€‹) ä¸ª vitv_i^tvitâ€‹ ç§æ–¹å¼ï¼ˆåœ¨è¿˜æ²¡æœ‰å¡«çš„ aaa ä¸­é€‰å‡º ttt ä¸ªæ¥å¡«ï¼‰ï¼Œå•æ¬¡çš„è´¡çŒ®æ˜¯ vitv_i^tvitâ€‹ï¼Œæ‰€ä»¥è´¡çŒ®ä¸º vitÃ—(nâˆ’jt)v_i^t\\times \\dbinom{n-j}{t}vitâ€‹Ã—(tnâˆ’jâ€‹)ã€‚ ç»Ÿè®¡ç­”æ¡ˆæ—¶åˆ¤æ–­ä¸€ä¸‹ 111 çš„ä¸ªæ•°æ˜¯å¦åˆæ³•å³å¯ï¼ˆè¦åŠ ä¸Šè¿›ä½çš„ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 998244353; int n, m, K; int C[35][35], v[105][55]; int f[105][35][35][35]; int count(int x) &#123; int res = 0; for (;x ; x >>= 1) res += (x &amp; 1); return res; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;K); C[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD; &#125; for (int i = 0; i &lt;= m; ++i) &#123; v[i][0] = 1; scanf(\"%d\", &amp;v[i][1]); for (int j = 2; j &lt;= n; ++j) v[i][j] = 1ll * v[i][j - 1] * v[i][1] % MOD; &#125; f[0][0][0][0] = 1; for (int i = 0; i &lt;= m; ++i) for (int j = 0; j &lt;= n; ++j) for (int k = 0; k &lt;= K; ++k) for (int p = 0; p &lt;= n >> 1; ++p) for (int t = 0; t &lt;= n - j; ++t) &#123; int &amp;dp = f[i + 1][j + t][k + ((t + p) &amp; 1)][(t + p) >> 1]; dp = (dp + 1ll * f[i][j][k][p] * v[i][t] % MOD * C[n - j][t]) % MOD; &#125; int ans = 0; for (int k = 0; k &lt;= K; ++k) for (int p = 0; p &lt;= n >> 1; ++p) if (k + count(p) &lt;= K) ans = (ans + f[m + 1][n][k][p]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; æ•°ä½ç»Ÿè®¡ DP ç®€ç§°æ•°ä½ DPã€‚ç”¨äºè§£å†³ä¸€ç±»ä¸æ•°å­—ç›¸å…³ï¼Œä¸€èˆ¬æ˜¯ç»™å®šä¸€äº›é™åˆ¶æ¡ä»¶ï¼Œç„¶åè¯¢é—®æ»¡è¶³æ¡ä»¶çš„ç¬¬ kkk å°æ•°æ˜¯å¤šå°‘ï¼Œæˆ–è€…æ˜¯æœ‰å¤šå°‘ä¸ªæ»¡è¶³æ¡ä»¶çš„æ•°çš„é¢˜ç›®ã€‚ æ¦‚è¿° å°†æ•°å­—æŒ‰æ¯ä¸€ä½æ‹†å¼€ï¼Œæ¯”å¦‚æœ€å¸¸ç”¨çš„åè¿›åˆ¶ï¼Œæ‹†å®Œä¹‹åæ¯ä¸€ä½æ•°å­—éƒ½æ˜¯ 0âˆ¼90\\sim 90âˆ¼9ã€‚é—®é¢˜å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š è®¡æ•°ï¼Œç»Ÿè®¡æ•°çš„æ•°é‡ï¼› æ•°çš„å€¼åŸŸå¾ˆå¤§ï¼› å¯ä»¥ä½¿ç”¨â€æ•°ä½â€œæ¥ç†è§£â€¦â€¦ æ¯”å¦‚è¯´ james1 æ•°æ•°ï¼Œæ•° 100âˆ¼199100\\sim 199100âˆ¼199 å’Œ 200âˆ¼299200\\sim 299200âˆ¼299 å‡ ä¹ä¸€è‡´ï¼Œ00âˆ¼9900\\sim 9900âˆ¼99 è¿™ä¸€éƒ¨åˆ†æ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚è¿™æ ·å°±å¯ä»¥æ ¹æ®æ­¤è®¾è®¡çŠ¶æ€æ¥æ±‚è§£é—®é¢˜ã€‚ å¾ˆå¤šæ—¶å€™ä¸ºäº†è®¡ç®—æ–¹ä¾¿æˆ‘ä»¬éƒ½ä¼šå…ˆå…è®¸å‰å¯¼ 000 çš„å­˜åœ¨ï¼Œæœ€åå†å‡å»ã€‚ ç®€å•é¢˜ æˆ‘ä»¬æ¥çœ‹ä¸€äº›ç®€å•çš„é¢˜ç›®æ¥è¿›ä¸€æ­¥è®¤è¯†æ•°ä½ DPã€‚ [ZJOI2010] æ•°å­—è®¡æ•° Portal.ç»™å®šä¸¤ä¸ªæ­£æ•´æ•° aaa å’Œ bbbï¼Œæ±‚åœ¨ [a,b][a,b][a,b] ä¸­çš„æ‰€æœ‰æ•´æ•°ä¸­ï¼Œæ¯ä¸ªæ•°ç å„å‡ºç°äº†å¤šå°‘æ¬¡ï¼Œ1â‰¤aâ‰¤bâ‰¤10121\\le a\\le b\\le 10^{12}1â‰¤aâ‰¤bâ‰¤1012ã€‚ è®¾ f(i)f(i)f(i) ä»£è¡¨æ»¡ iii ä½æ•°çš„æ¯ä¸ªæ•°å­—çš„å‡ºç°ä¸ªæ•°ï¼Œå³ 0âˆ¼10iâˆ’10\\sim 10^i-10âˆ¼10iâˆ’1 ä¸­çš„æ¯ä¸ªæ•°å­—çš„å‡ºç°ä¸ªæ•°ï¼Œå‡å®šå¯ä»¥æœ‰å‰å¯¼é›¶ï¼Œé‚£ä¹ˆæ¯ä¸ªæ•°å­—çš„å‡ºç°æ¬¡æ•°æ˜¯ç›¸ç­‰çš„ã€‚å‰ iâˆ’1i-1iâˆ’1 ä½çš„æ•°å­—è´¡çŒ®æ˜¯ 10f(iâˆ’1)10f(i-1)10f(iâˆ’1)ï¼Œç¬¬ iii ä½çš„æ•°å­—è´¡çŒ®æ˜¯ 10iâˆ’110^{i-1}10iâˆ’1ã€‚ ç°åœ¨è€ƒè™‘å¦‚ä½•ç»Ÿè®¡ç­”æ¡ˆã€‚æˆ‘ä»¬è‚¯å®šæ˜¯æ±‚ä¸¤ä¸ªå‰ç¼€å’Œç„¶åç›¸å‡ã€‚æ±‚å‰ç¼€å’Œæ—¶å°†ä¸Šç•Œä»é«˜åˆ°ä½ä½æšä¸¾ï¼Œä¸è´´ç€ä¸Šç•Œæ—¶åé¢å¯ä»¥éšä¾¿å–ï¼Œè´´ç€æ—¶åªèƒ½å–åˆ°ä¸Šç•Œã€‚å¦‚æœæœ‰å‰å¯¼é›¶è¿˜éœ€è¦å‡å»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; i64 l, r; i64 f[15], poww[15]; i64 ans1[15], ans2[15]; void calc(i64 n, i64 *ans) &#123; static int a[15]; int len = 0; i64 tmp = n; while (tmp) a[++len] = tmp % 10, tmp /= 10; for (int i = len; i >= 1; --i) &#123; // é¦–å…ˆè€ƒè™‘å i - 1 ä½çš„è´¡çŒ® for (int j = 0; j &lt; 10; ++j) ans[j] += f[i - 1] * a[i]; // æ»¡ i-1 ä½çš„æ•°å­—ï¼Œæœ‰ a[i] ä¸ªï¼ˆä¸ç®—ä»¥ 0 æ‰“å¤´ï¼Œå› ä¸ºä¸‹ä¸€ä½çš„æ—¶å€™ä¼šè€ƒè™‘ï¼‰ // å†è€ƒè™‘ç¬¬ i ä½çš„è´¡çŒ® for (int j = 0; j &lt; a[i]; ++j) ans[j] += poww[i - 1]; // 0 ~ a[i]-1 éƒ½ä¼šå‡ºç° 10^(i-1) æ¬¡ n -= poww[i - 1] * a[i]; // å‡æ‰ç¬¬ i ä½ï¼Œå‰©ä¸‹çš„æ•°å­— ans[a[i]] += n + 1; // a[i] ä¼šåœ¨ 0~n å‡ºç°ä¸€æ¬¡ // æœ€åå¤„ç†å‰å¯¼é›¶ ans[0] -= poww[i - 1]; // å½“ç¬¬ i ä½ä¸º 0 æ—¶ï¼Œç­”æ¡ˆå°±æ²¡æœ‰æ„ä¹‰ï¼Œæ­¤æ—¶å‰©ä¸‹çš„å¯ä»¥éšä¾¿å¡«ï¼Œä»…æœ‰è¿™éƒ¨åˆ†çš„é›¶ä¸ä¼šå‡ºç° &#125; &#125; int main(void) &#123; cin >> l >> r; poww[0] = 1; for (int i = 1; i &lt;= 13; ++i) &#123; f[i] = f[i - 1] * 10 + poww[i - 1]; poww[i] = poww[i - 1] * 10; &#125; calc(r, ans1); calc(l - 1, ans2); for (int i = 0; i &lt; 10; ++i) printf(\"%lld \", ans1[i] - ans2[i]); putchar('\\n'); return 0; &#125; [CQOI2016] æ‰‹æœºå·ç  Portal. æ•°ä½ DP ä¸€èˆ¬é‡‡ç”¨è®°å¿†åŒ–æœç´¢å®ç°ã€‚ç›´æ¥å°†æ‰€æœ‰ä¿¡æ¯è®°å½•ä¸‹æ¥ï¼Œæš´åŠ›æšä¸¾æ¯ä¸€ä½çš„æ•°å­—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int num[15]; int f[11][11][11][2][2][2][2]; i64 dp(int p, int p1, int p2, bool lim, bool d, bool _4, bool _8) &#123; if (_4 &amp;&amp; _8) return 0; if (p == 0) return d; if (f[p][p1][p2][lim][d][_4][_8] != -1) return f[p][p1][p2][lim][d][_4][_8]; i64 res = 0; int mx = lim ? 9 : num[p]; for (int i = 0; i &lt;= mx; ++i) res += dp(p - 1, i, p1, lim || (i &lt; mx), d || (i == p1 &amp;&amp; i == p2), _4 || (i == 4), _8 || (i == 8)); return f[p][p1][p2][lim][d][_4][_8] = res; &#125; i64 calc(i64 n) &#123; memset(f, 0xff, sizeof f); for (int i = 1; i &lt;= 11; ++i, n /= 10) num[i] = n % 10; i64 res = 0; for (int i = 1; i &lt;= num[11]; ++i) res += dp(10, i, -1, i &lt; num[11], 0, i == 4, i == 8); return res; &#125; int main(void) &#123; i64 l, r; cin >> l >> r; cout &lt;&lt; calc(r) - calc(l - 1) &lt;&lt; \"\\n\"; return 0; &#125; çŸ©é˜µä¼˜åŒ– DP å¾ˆå¤š DP é—®é¢˜å¯ä»¥é€šè¿‡çŸ©é˜µä¼˜åŒ–ã€‚ çŸ©é˜µå¿«é€Ÿå¹‚ä¼˜åŒ– çŸ©é˜µå¿«é€Ÿå¹‚å¯ä»¥åŠ é€Ÿé€’æ¨ï¼Œå¯ä»¥åŠ é€Ÿæ¯ä¸€è½®çš„è½¬ç§»éƒ½ç›¸åŒçš„è½¬ç§»æ–¹ç¨‹ã€‚ [CF222E] Decoding Genome. è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨è€ƒè™‘åˆ°ç¬¬ iii ä¸ªå­—ç¬¦ï¼Œæ­¤å­—ç¬¦ä¸º jjj çš„æ–¹æ¡ˆæ•°ã€‚å‘ç°è½¬ç§»æ˜¯ä¸€ä¸ªçŸ©é˜µä¹˜æ³•çš„å½¢å¼ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚ä¼˜åŒ–ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000007; struct Matrix &#123; int a[52][52]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; friend Matrix operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 52; ++i) for (int k = 0; k &lt; 52; ++k) &#123; int r = a.a[i][k]; for (int j = 0; j &lt; 52; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b.a[k][j]) % P; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, i64 b) &#123; Matrix res = a; --b; for (; b; b >>= 1, a = a * a) if (b &amp; 1) res = res * a; return res; &#125; i64 n; int m, k; int H(char c) &#123; if (c >= 'a' &amp;&amp; c &lt;= 'z') return c - 'a'; return c - 'A' + 26; &#125; int main(void) &#123; ios::sync_with_stdio(false); cin >> n >> m >> k; if (n == 1) return cout &lt;&lt; m &lt;&lt; \"\\n\", 0; Matrix f, a; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; m; ++j) f.a[i][j] = 1; for (int i = 0; i &lt; m; ++i) a.a[0][i] = 1; for (int i = 1; i &lt;= k; ++i) &#123; char x, y; cin >> x >> y; f.a[H(x)][H(y)] = 0; &#125; a = a * poww(f, n - 1); int ans = 0; for (int i = 0; i &lt; m; ++i) ans = (ans + a.a[0][i]) % P; return cout &lt;&lt; ans &lt;&lt; \"\\n\", 0; &#125; åŠ¨æ€ DP æœ¬æ¥æ˜¯æŒ‡ä¸€ç±»è§£å†³æ ‘ä¸Šå¸¦æƒä¿®æ”¹çš„ DP é—®é¢˜ï¼Œä½†æ˜¯ç¬”è€…è®¤ä¸ºåˆ©ç”¨æ•°æ®ç»“æ„ç»´æŠ¤å¹¿ä¹‰çŸ©é˜µä¹˜æ³•æ¥è¿›è¡Œ DP çš„éƒ½åº”è¯¥å±äºâ€œåŠ¨æ€â€ DPã€‚ Portal.ç»™å®šä¸€æ£µ nnn ä¸ªç‚¹çš„ç‚¹æƒæ ‘ï¼Œæ”¯æŒä¿®æ”¹ç‚¹çš„ç‚¹æƒï¼ŒæŸ¥è¯¢æ ‘æœ€å¤§ç‹¬ç«‹é›†çš„æƒå€¼å¤§å°ã€‚ ä¾ç„¶è®¾ fi,1/0f_{i,1/0}fi,1/0â€‹ ä»£è¡¨å¯¹äº iii çš„å­æ ‘æ˜¯å¦é€‰åˆ™ç¬¬ iii ä¸ªèŠ‚ç‚¹ï¼Œå­æ ‘å†…çš„ç‹¬ç«‹é›†æœ€å¤§å¤§å°ã€‚ å¦‚ä½•æ”¯æŒä¿®æ”¹ï¼Ÿå¯¹åŸæ ‘è¿›è¡Œé‡é“¾å‰–åˆ†ï¼Œè®¾ gi,1/0g_{i,1/0}gi,1/0â€‹ ä»£è¡¨ iii çš„å­æ ‘ä¸è€ƒè™‘é‡å„¿å­çš„æƒ…å†µä¸‹çš„ç­”æ¡ˆã€‚æœ‰ï¼š fi,0=gi,0+maxâ¡{fsoni,0,fsoni,1}fi,1=gi,1+fsoni,0f_{i,0}=g_{i,0}+\\max\\{f_{son_i,0},f_{son_i,1}\\}\\\\ f_{i,1}=g_{i,1}+f_{son_i,0} fi,0â€‹=gi,0â€‹+max{fsoniâ€‹,0â€‹,fsoniâ€‹,1â€‹}fi,1â€‹=gi,1â€‹+fsoniâ€‹,0â€‹ æˆ‘ä»¬å®šä¹‰å¦ä¸€ç§çŸ©é˜µä¹˜æ³•ï¼š Ci,j=maxâ¡k=1nAi,k+Bk,jC_{i,j}=\\max_{k=1}^n A_{i,k}+B_{k,j} Ci,jâ€‹=k=1maxnâ€‹Ai,kâ€‹+Bk,jâ€‹ åˆ™æœ‰ï¼š [fsoni,0fsoni,1]Ã—[gi,0gi,1gi,0âˆ’âˆ]=[fi,0fi,1]\\begin{bmatrix} f_{son_i,0} &amp; f_{son_i,1} \\end{bmatrix}\\times \\begin{bmatrix} g_{i,0} &amp; g_{i,1}\\\\ g_{i,0} &amp; -\\infty \\end{bmatrix}= \\begin{bmatrix} f_{i,0} &amp; f_{i,1} \\end{bmatrix} [fsoniâ€‹,0â€‹â€‹fsoniâ€‹,1â€‹â€‹]Ã—[gi,0â€‹gi,0â€‹â€‹gi,1â€‹âˆ’âˆâ€‹]=[fi,0â€‹â€‹fi,1â€‹â€‹] è¿™æ ·åœ¨ä¸€æ¡é‡é“¾ä¸Šå°±å¯ä»¥ç›´æ¥ç”¨çº¿æ®µæ ‘ç»´æŠ¤ç­”æ¡ˆï¼Œæˆ‘ä»¬åªéœ€è¦ä¿è¯å« 111 çš„é‚£æ¡é“¾ä¸Šçš„ä¸œè¥¿éƒ½æ˜¯å¯¹çš„å°±è¡Œäº†ï¼ˆæˆ‘ä»¬åªéœ€è¦ä¿è¯ 111 çš„ç­”æ¡ˆæ­£ç¡®ï¼Œå‰©ä¸‹çš„è®©å®ƒè‡ªç”Ÿè‡ªç­å³å¯ï¼‰ã€‚ æˆ‘ä»¬ç›¸å½“äºä»ä¸€ä¸ªæƒå€¼ä¸º 000 çš„å¶å­èŠ‚ç‚¹å¼€å§‹ DPï¼Œæ³¨æ„ DFS åºå¤§çš„åº”è¯¥å…ˆä¹˜ï¼Œæ‰€ä»¥çº¿æ®µæ ‘çš„ç»´æŠ¤é¡ºåºåº”è¯¥æ˜¯ä»å³åˆ°å·¦ã€‚ä¿®æ”¹æ—¶ï¼Œå½“å‰èŠ‚ç‚¹çš„ gi,1g_{i,1}gi,1â€‹ ä¼šæ”¹å˜ï¼Œç„¶åç›´æ¥è€ƒè™‘é‡é“¾é¡¶ç«¯çˆ¶äº²çš„ç­”æ¡ˆæ”¹å˜ï¼Œæ”¹çš„æ˜¯å½“å‰èŠ‚ç‚¹çš„ä¸€ä¸ªè½»å„¿å­ï¼Œè®¡ç®—æ”¹å˜é‡å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; int n, m, a[100005], f[100005][2]; int siz[100005], son[100005], fa[100005]; int top[100005], L[100005], R[100005], num, idx[100005]; vector&lt;int> G[100005]; struct Matrix &#123; int a[2][2]; Matrix() &#123; memset(a, 0, sizeof a); &#125; friend Matrix operator* (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 2; ++i) for (int k = 0; k &lt; 2; ++k) &#123; int r = a.a[i][k]; for (int j = 0; j &lt; 2; ++j) c.a[i][j] = max(c.a[i][j], r + b.a[k][j]); &#125; return c; &#125; &#125; T[400005], g[100005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = g[idx[l]], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1 | 1] * T[o &lt;&lt; 1]; &#125; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o] = g[idx[l]], void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1 | 1] * T[o &lt;&lt; 1]; &#125; Matrix query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y) * query(o &lt;&lt; 1, l, mid, x, y); &#125; void dfs(int x, int fa) &#123; siz[x] = 1; ::fa[x] = fa; f[x][1] = a[x]; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; f[x][1] += f[y][0]; f[x][0] += max(f[y][0], f[y][1]); &#125; &#125; void dfs2(int x, int topf) &#123; idx[L[x] = ++num] = x; R[top[x] = topf] = num; g[x].a[0][1] = a[x]; g[x].a[1][1] = -INF; if (!son[x]) return; dfs2(son[x], topf); for (int y : G[x]) if (y != son[x] &amp;&amp; y != fa[x]) &#123; dfs2(y, y); g[x].a[0][1] += f[y][0]; g[x].a[0][0] += max(f[y][0], f[y][1]); &#125; g[x].a[1][0] = g[x].a[0][0]; &#125; void update(int x, int k) &#123; g[x].a[0][1] += k - a[x]; a[x] = k; while (x) &#123; int y = top[x]; Matrix lst = query(1, 1, n, L[y], R[y]); update(1, 1, n, L[x]); Matrix now = query(1, 1, n, L[y], R[y]); x = fa[y]; g[x].a[0][0] += max(now.a[0][0], now.a[0][1]) - max(lst.a[0][0], lst.a[0][1]); g[x].a[1][0] = g[x].a[0][0]; g[x].a[0][1] += now.a[0][0] - lst.a[0][0]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); dfs2(1, 1); build(1, 1, n); while (m--) &#123; int x, k; scanf(\"%d%d\", &amp;x, &amp;k); update(x, k); Matrix ans = query(1, 1, n, L[1], R[1]); printf(\"%d\\n\", max(ans.a[0][0], ans.a[0][1])); &#125; return 0; &#125; è‡ªåŠ¨æœºä¸Š DP éš¾åº¦è¾ƒå¤§ã€‚åœ¨å­¦ä¹ ä¹‹å‰ï¼Œæ¨èå­¦ä¹ ä¸€äº›è‡ªåŠ¨æœºçš„çŸ¥è¯†ï¼ˆè€Œä¸”ä¸éš¾ï¼‰ã€‚å³ä½¿æ˜¯ DP å¥— DPï¼Œä»è‡ªåŠ¨æœºçš„è§’åº¦ç†è§£ä¹Ÿæ˜¯æœ‰ç›Šçš„ï¼Œç”šè‡³æ˜¯æœ€å¥½ç†è§£çš„ã€‚ KMP è‡ªåŠ¨æœºä¸Š DP [CF1163D] Mysterious Code. æ‰¾ä¸€ä¸ªæ¨¡å¼ä¸²åœ¨å­—ç¬¦ä¸²ä¸­çš„å‡ºç°æ¬¡æ•°ï¼Œè€Œçœ‹åˆ°å¯ä»¥åœ¨ * ä¸Šå¡«ä»»æ„ä¸€ä¸ªå­—æ¯åˆæ˜¯ç»å…¸ DP é—®é¢˜ã€‚å¯¹ s,ts,ts,t å»ºå‡º KMP è‡ªåŠ¨æœºï¼Œè®¾ f(i,j,k)f(i,j,k)f(i,j,k) è€ƒè™‘åˆ° ccc çš„ç¬¬ iii ä½ï¼Œæ­¤æ—¶åœ¨ sss çš„ KMP è‡ªåŠ¨æœºçš„èŠ‚ç‚¹ jjjï¼Œttt çš„ KMP è‡ªåŠ¨æœºçš„èŠ‚ç‚¹ kkk çš„æœ€å¤§ç­”æ¡ˆã€‚é‡‡ç”¨åˆ·è¡¨æ³•è½¬ç§»ï¼Œæ¨¡å¼ä¸² SSS åœ¨è½¬ç§»åˆ°èŠ‚ç‚¹ âˆ£Sâˆ£|S|âˆ£Sâˆ£ æ—¶æœ‰è´¡çŒ®ã€‚åˆå§‹ f(0,0,0)=0f(0,0,0)=0f(0,0,0)=0ï¼Œè½¬ç§» f(i+1,trsj,ci+1,trtk,ci+1)=maxâ¡{f(i,j,k)+w}f(i+1,trs_{j,c_{i+1}},trt_{k,c_{i+1}})=\\max\\{f(i,j,k)+w\\}f(i+1,trsj,ci+1â€‹â€‹,trtk,ci+1â€‹â€‹)=max{f(i,j,k)+w}ï¼Œç›®æ ‡ maxâ¡{f(n,j,k)}\\max\\{f(n,j,k)\\}max{f(n,j,k)}ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define rep(i, l, r) for (int i = l; i &lt;= r; ++i) using namespace std; int n, ls, lt, nxts[55], nxtt[55], trs[55][26], trt[55][26]; char a[1005], s[55], t[55]; int f[1005][55][55]; void KMP(char *s, int len, int *nxt, int tr[][26]) &#123; for (int i = 2, p = 0; i &lt;= len; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt[p]; if (s[i] == s[p + 1]) ++p; nxt[i] = p; &#125; rep(i, 0, len) rep(j, 0, 25) &#123; if (i &lt; len &amp;&amp; s[i + 1] == j + 'a') tr[i][j] = i + 1; else if (i) tr[i][j] = tr[nxt[i]][j]; &#125; &#125; void ckmax(int &amp;x, int t) &#123; if (x &lt; t) x = t; &#125; int main(void) &#123; scanf(\"%s%s%s\", a + 1, s + 1, t + 1); n = strlen(a + 1); ls = strlen(s + 1); lt = strlen(t + 1); KMP(s, ls, nxts, trs); KMP(t, lt, nxtt, trt); memset(f, 0xbf, sizeof f); f[0][0][0] = 0; rep(i, 0, n - 1) rep(j, 0, ls) rep(k, 0, lt) rep(p, 0, 25) if (a[i + 1] == '*' || a[i + 1] == p + 'a') &#123; int w = 0; if (trs[j][p] == ls) ++w; if (trt[k][p] == lt) --w; ckmax(f[i + 1][trs[j][p]][trt[k][p]], f[i][j][k] + w); &#125; int ans = -1e9; rep(i, 0, ls) rep(j, 0, lt) ans = max(ans, f[n][i][j]); return printf(\"%d\\n\", ans), 0; &#125; DP å¥— DP æœ¬è´¨ä¸Šå°±æ˜¯å†…å±‚ DP çš„ç»“æœä½œä¸ºå¤–å±‚ DP çš„çŠ¶æ€ï¼Œå†…å±‚å‹çš„ä¸œè¥¿ä¸€èˆ¬å¯ä»¥çœ‹æˆä¸€ä¸ª bool æ•°ç»„ï¼Œè¡¨ç¤ºå¤–å±‚çš„çŠ¶æ€æ˜¯å¦èƒ½å¤Ÿå–åˆ°ã€‚è¿™æ ·çŠ¶æ€æ•°å¯èƒ½å¾ˆå¤šï¼Œæ‰€ä»¥å¾€å¾€éœ€è¦ä»¥å®é™…æœå‡ºæ¥çš„ç»“æœä¸ºå‡†ã€‚ [TJOI2018] æ¸¸å›­ä¼šã€‚æ±‚é•¿åº¦ä¸º nnnï¼Œå­—ç¬¦é›†ä¸º N,O,I\\text{N,O,I}N,O,Iï¼Œä¸”ä¸èƒ½å‡ºç°å­ä¸² NOI\\text{NOI}NOIï¼Œä¸ç»™å®šå­—ç¬¦ä¸² SSS çš„ LCS ä¸º lenlenlenï¼ˆéœ€è¦æ±‚å‡ºæ‰€æœ‰çš„ lenlenlen å¯¹åº”çš„ç­”æ¡ˆï¼‰çš„é•¿åº¦ã€‚nâ‰¤1000,âˆ£Sâˆ£â‰¤15n\\le 1000, |S|\\le 15nâ‰¤1000,âˆ£Sâˆ£â‰¤15ã€‚ LCS æ˜¯ä»€ä¹ˆï¼Ÿåƒè¿™æ ·ï¼š LCSx,y={LCSxâˆ’1,yâˆ’1+1,Ax=By,maxâ¡{LCSxâˆ’1,y,LCSx,yâˆ’1},Axâ‰ By.\\text{LCS}_{x,y}= \\begin{cases} \\text{LCS}_{x-1,y-1}+1&amp;,A_x=B_y,\\\\ \\max\\{\\text{LCS}_{x-1,y},\\text{LCS}_{x,y-1}\\}&amp;,A_x\\neq B_y.\\\\ \\end{cases} LCSx,yâ€‹={LCSxâˆ’1,yâˆ’1â€‹+1max{LCSxâˆ’1,yâ€‹,LCSx,yâˆ’1â€‹}â€‹,Axâ€‹=Byâ€‹,,Axâ€‹î€ =Byâ€‹.â€‹ æˆ‘ä»¬å¯¹ LCS å–ä¸€éå‰ç¼€æœ€å¤§å€¼ã€‚æŠŠè¿™ä¸ª LCS çš„ DP æ•°ç»„ä½œä¸ºçŠ¶æ€å‹è¿› DPï¼ˆå½“å…¶ä¸­ä¸€ç»´å›ºå®šæ—¶ï¼ŒLCS æ•°ç»„çš„å‰ç¼€æœ€å¤§å€¼å·®åˆ†åå¯ä»¥å¾—åˆ°ä¸€ä¸ª 01 åºåˆ—ï¼ŒçŠ¶å‹åå°±å¯ä»¥å‹è¿›å»ï¼‰ã€‚è¿™ç›¸å½“äºè‡ªåŠ¨æœºä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œæšä¸¾å‡ºæ»¡è¶³ä¸å‡ºç°å­ä¸² NOI çš„å­—ç¬¦ä½œä¸ºè‡ªåŠ¨æœºçš„è½¬ç§»ï¼Œè®¡ç®—å‡ºè½¬ç§»åˆ°çš„è‡ªåŠ¨æœºä¸Šçš„ç‚¹å¹¶æ›´æ–°æ–¹æ¡ˆæ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, k, ans[20], a[20], b[20]; // LCS(i, ...) char s[20]; int f[2][35005][3]; // è€ƒè™‘åˆ°å­—ç¬¦ä¸²çš„ç¬¬ i ä½ï¼Œå½“å‰ \"NOI\" å­ä¸²çš„é•¿åº¦ä¸º k void decode(int *a, int ret) &#123; for (int i = 0; i &lt; k; ++i) a[i + 1] = (ret >> i &amp; 1) + a[i]; &#125; int encode(int *a) &#123; int ret = 0; for (int i = 0; i &lt; k; ++i) ret |= (a[i + 1] - a[i]) &lt;&lt; i; return ret; &#125; void dp(int now, int t, int p, char c, int w) &#123; decode(a, t); for (int i = 1; i &lt;= k; ++i) b[i] = max(&#123;b[i - 1], a[i], a[i - 1] + (c == s[i])&#125;); t = encode(b); f[now][t][p] = (f[now][t][p] + w) % P; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;k, s + 1); f[0][0][0] = 1; for (int i = 0; i &lt; n; ++i) &#123; memset(f[i - 1 &amp; 1], 0, sizeof(f[i - 1 &amp; 1])); for (int j = 0; j &lt; 1 &lt;&lt; k; ++j) &#123; if (f[i &amp; 1][j][0]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][0]); dp(i - 1 &amp; 1, j, 0, 'O', f[i &amp; 1][j][0]); dp(i - 1 &amp; 1, j, 0, 'I', f[i &amp; 1][j][0]); &#125; if (f[i &amp; 1][j][1]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][1]); dp(i - 1 &amp; 1, j, 2, 'O', f[i &amp; 1][j][1]); dp(i - 1 &amp; 1, j, 0, 'I', f[i &amp; 1][j][1]); &#125; if (f[i &amp; 1][j][2]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][2]); dp(i - 1 &amp; 1, j, 0, 'O', f[i &amp; 1][j][2]); &#125; &#125; &#125; for (int i = 0; i &lt; 1 &lt;&lt; k; ++i) for (int j = 0; j &lt; 3; ++j) &#123; int &amp;x = ans[__builtin_popcount(i)]; x = (x + f[n &amp; 1][i][j]) % P; &#125; for (int i = 0; i &lt;= k; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; å¯ä»¥å‘ç° DP å¥— DP å°±æ˜¯åœ¨ä¸€ä¸ª DP è‡ªåŠ¨æœºä¸Šè¿›è¡Œ DPã€‚å…¶æœ‰ä¸€äº›æŠ€å·§ï¼Œè¯·å‚è€ƒ Problemsetã€‚ Problemset å‰é¢çš„é¢˜ä¸»è¦æ˜¯å•ä¸ªçŸ¥è¯†ç‚¹ä¸ºä¸»çš„æ¨¡å‹ï¼Œåé¢ä¼šå‡ºç°è¶…çº§å¤§æ‚é¢˜ã€‚ èƒŒåŒ…é—®é¢˜ å¾ˆæœ‰æ„æ€ï¼åé¢æœ‰äº›é¢˜ç›¸å½“éº»çƒ¦ã€‚ [HNOI2007] æ¢¦å¹»å²›å®ç  Portal. è€ƒè™‘å¯¹ 2b2^b2b ä¸­ bbb ç›¸åŒçš„ç‰©å“è¿›è¡Œåˆ†å±‚ DPï¼Œè®¾ f(i,j)f(i,j)f(i,j) è¡¨ç¤ºè€ƒè™‘åˆ° 2i2^i2i çš„ç‰©å“ï¼Œæ°å¥½å‰©ä½™ jÃ—2ij\\times 2^ijÃ—2i çš„ä½“ç§¯æ—¶èƒ½å¤Ÿå–å¾—çš„æœ€å¤§ä»·å€¼ã€‚åŒå±‚çš„è½¬ç§»ç›´æ¥ä½¿ç”¨ 01 èƒŒåŒ…ï¼Œä»é«˜å±‚å¼€å§‹è½¬ç§»ï¼Œä¸åŒå±‚åˆ™æ˜¯ f(iâˆ’1,jÃ—2+siâˆ’1)â†f(i,j)f(i-1,j\\times 2+s_{i-1})\\leftarrow f(i,j)f(iâˆ’1,jÃ—2+siâˆ’1â€‹)â†f(i,j)ï¼Œå…¶ä¸­ siâˆ’1s_{i-1}siâˆ’1â€‹ ä»£è¡¨ WWW äºŒè¿›åˆ¶ä¸‹çš„ç¬¬ iâˆ’1i-1iâˆ’1 ä½ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; void ckmax(int &amp;a, int b) &#123; if (a &lt; b) a = b; &#125; int n, W, t; int f[35][1005], s[35]; int w[105], v[105]; vector&lt;int> a[35]; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;W) == 2 &amp;&amp; n != -1) &#123; memset(f, 0xbf, sizeof(f)); memset(s, 0, sizeof(s)); memset(a, 0, sizeof(a)); for (int j = 0; j &lt;= 30; ++j) if ((W >> j) &amp; 1) s[t = j] = 1; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", w + i, v + i); int b = 0; while (w[i] % 2 == 0) w[i] >>= 1, ++b; a[b].emplace_back(i); &#125; int ans = 0; for (int i = t; i >= 0; --i) &#123; f[i][s[i]] = max(f[i][s[i]], 0); for (auto k : a[i]) for (int j = w[k]; j &lt;= 1000; ++j) ckmax(f[i][j - w[k]], f[i][j] + v[k]); if (i > 0) &#123; for (int j = 0; j &lt;= 1000; ++j) ckmax(f[i - 1][min(1000, j * 2 + s[i - 1])], f[i][j]); &#125; else &#123; for (int j = 0; j &lt;= 1000; ++j) ckmax(ans, f[i][j]); &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [Luogu P8564] Ïars/ey Portal. æ ‘å½¢èƒŒåŒ…ã€‚åœ¨èƒŒåŒ…è¿›è¡Œå®Œä¹‹åï¼Œè¦ç»Ÿè®¡åˆ é™¤å½“å‰å­æ ‘çš„ä»£ä»·ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, v[5005], siz[5005]; i64 f[5005][5005]; // x ä¸ºæ ¹ï¼Œåˆ é™¤ i ä¸ªç‚¹ vector&lt;int> G[5005]; void dfs(int x, int fa) &#123; siz[x] = 1; f[x][0] = 0; int s = 0; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); s += siz[y]; for (int i = s - 1; i >= 0; --i) for (int j = min(i, siz[y] - 1); j >= max(1, i - siz[x]); --j) f[x][i] = min(f[x][i], f[x][i - j] + f[y][j]); siz[x] += siz[y]; &#125; for (int i = 0; i &lt; siz[x] - 1; ++i) f[x][siz[x] - 1] = min(f[x][siz[x] - 1], f[x][i] + v[siz[x] - i]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); memset(f, 0x3f, sizeof(f)); for (int i = 2; i &lt;= n; ++i) scanf(\"%d\", v + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); printf(\"%lld\\n\", f[1][n - 1]); return 0; &#125; [åäºŒçœè”è€ƒ 2019] çš®é… Portal. è€ƒè™‘ K=0K=0K=0 æ€ä¹ˆåšã€‚åˆ†åˆ«è€ƒè™‘åˆ’åˆ†ä¸¤ç§ç‰¹å¾ï¼Œä¸¤æ¬¡èƒŒåŒ…åˆ†åˆ«å¯¹å·¥å…·ç®±å’Œèºä¸è¿›è¡Œ DP å³å¯ã€‚ å‘ç° KKK å¾ˆå°ï¼Œè€ƒè™‘é’ˆå¯¹å®ƒè®¾è®¡çŠ¶æ€ã€‚å¯¹äºä¸æ˜¯è¿™ KKK ä¸ªæ²¡äº‹æ‰¾äº‹çš„èºä¸ï¼Œå‰é¢çš„ DP åšæ³•ä¾ç„¶æˆç«‹ã€‚ç„¶åå†è€ƒè™‘è¿™äº›æ²¡äº‹æ‰¾äº‹çš„ã€‚ è®¾ f(i,j,k)f(i,j,k)f(i,j,k) ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªç‰©å“ï¼Œæ™®é€šèºé’‰çš„é‡é‡ä¸º jjjï¼Œä¸‰è§’èºçº¹çš„é‡é‡ä¸º kkkã€‚éœ€è¦æšä¸¾å½“å‰çš„é€‰çš„ä¸œè¥¿æ˜¯ä»€ä¹ˆï¼Œå› æ­¤å†è®°ä¸€ä¸ª ggg è¡¨ç¤ºè‡ªæ”»æ–¹èºé’‰ã€‚æ»šæ‰ iii è¿™ä¸€ç»´ï¼Œæ‰€æœ‰çŠ¶æ€éƒ½æ˜¯å¯ä»¥è½¬ç§»çš„ï¼Œè€ƒè™‘ç”¨è¿™ç§æ–¹å¼å¤„ç†æ²¡äº‹æ‰¾äº‹çš„èºä¸ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(k2wM)O(k^2 w M)O(k2wM)ã€‚ ç„¶åæšä¸¾ä½“ç§¯ï¼Œè¿›è¡ŒèƒŒåŒ…åˆå¹¶å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define mem(x, v) memset(x, v, sizeof x) using namespace std; const int P = 998244353; inline void add(int &amp;x, int t) &#123; x = (x + t) % P; &#125; int n, c, C0, C1, D0, D1; int b[2505], w[2505], ban[2505], vis[2505]; int f[2505], g[2505]; // æ™®é€š / ä¸‰è§’ ä¸º i çš„æ–¹æ¡ˆæ•° int F[2505][2505], G[2505][2505]; int siz[2505]; void solve(void) &#123; mem(siz, 0); mem(vis, 0); mem(ban, -1); cin >> n >> c >> C0 >> C1 >> D0 >> D1; int ALL = 0; for (int i = 1; i &lt;= n; ++i) cin >> b[i] >> w[i], siz[b[i]] += w[i], ALL += w[i]; int K; cin >> K; for (int x; K--; ) cin >> x, cin >> ban[x], vis[b[x]] = 1; mem(f, 0); f[0] = 1; for (int i = 1; i &lt;= c; ++i) if (!vis[i] &amp;&amp; siz[i]) for (int j = C0; j >= siz[i]; --j) add(f[j], f[j - siz[i]]); for (int i = 1; i &lt;= C0; ++i) add(f[i], f[i - 1]); mem(g, 0); g[0] = 1; for (int i = 1; i &lt;= n; ++i) if (ban[i] == -1) for (int j = D0; j >= w[i]; --j) add(g[j], g[j - w[i]]); for (int i = 1; i &lt;= D0; ++i) add(g[i], g[i - 1]); mem(F, 0); mem(G, 0); F[0][0] = 1; int Cs = 0, Ds = 0; for (int op = 1; op &lt;= c; ++op) if (vis[op]) &#123; Cs += siz[op]; Cs = min(Cs, C0); for (int i = 0; i &lt;= Cs; ++i) for (int j = 0; j &lt;= Ds; ++j) G[i][j] = F[i][j]; for (int x = 1; x &lt;= n; ++x) if (b[x] == op &amp;&amp; ban[x] != -1) &#123; Ds += w[x]; Ds = min(Ds, D0); // 0 ä¸æ˜¯ æ™®é€šä¸‰è§’ // 1 ä¸æ˜¯ æ™®é€šæ–¹ // 2 ä¸æ˜¯ è‡ªæ”»ä¸‰è§’ // 3 ä¸æ˜¯ è‡ªæ”»æ–¹ // F æ™®é€šä¸‰è§’ G è‡ªæ”»æ–¹ if (ban[x] == 1) &#123; for (int i = 0; i &lt;= Cs; ++i) &#123; for (int j = Ds; j >= w[x]; --j) F[i][j] = F[i][j - w[x]]; for (int j = w[x] - 1; j >= 0; --j) F[i][j] = 0; &#125; &#125; if (ban[x] >= 2) &#123; for (int i = 0; i &lt;= Cs; ++i) for (int j = Ds; j >= w[x]; --j) add(F[i][j], F[i][j - w[x]]); &#125; if (ban[x] == 3) &#123; for (int i = 0; i &lt;= Cs; ++i) &#123; for (int j = Ds; j >= w[x]; --j) G[i][j] = G[i][j - w[x]]; for (int j = w[x] - 1; j >= 0; --j) G[i][j] = 0; &#125; &#125; if (ban[x] &lt;= 1) &#123; for (int i = 0; i &lt;= Cs; ++i) for (int j = Ds; j >= w[x]; --j) add(G[i][j], G[i][j - w[x]]); &#125; &#125; for (int j = 0; j &lt;= Ds; ++j) &#123; for (int i = Cs; i >= siz[op]; --i) F[i][j] = F[i - siz[op]][j]; for (int i = siz[op] - 1; i >= 0; --i) F[i][j] = 0; &#125; for (int i = 0; i &lt;= Cs; ++i) for (int j = 0; j &lt;= Ds; ++j) add(F[i][j], G[i][j]); &#125; int ans = 0; for (int i = 0; i &lt;= Cs; ++i) for (int j = 0; j &lt;= Ds; ++j) &#123; int l1 = max(0, ALL - C1 - i), r1 = C0 - i; if (l1 > r1) continue; int l2 = max(0, ALL - D1 - j), r2 = D0 - j; if (l2 > r2) continue; int v1 = f[r1] - (l1 ? f[l1 - 1] : 0), v2 = g[r2] - (l2 ? g[l2 - 1] : 0); add(ans, 1ll * v1 * v2 % P * F[i][j] % P); &#125; cout &lt;&lt; (ans + P) % P &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(0); int T; cin >> T; while (T--) solve(); return 0; &#125; åŒºé—´ DP ä¹Ÿå¯ä»¥å˜å¾—ç›¸å½“å¤æ‚ã€‚ [CF1572C] Paint Portal. è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨å°† [i,j][i,j][i,j] æŸ“æˆ cjc_jcjâ€‹ çš„ä»£ä»·ï¼ˆæƒ³ä¸€æƒ³è¿™æ ·ä¸ºä»€ä¹ˆæ˜¯æ­£ç¡®çš„ï¼‰ï¼Œå½“ ck=cjc_k=c_jckâ€‹=cjâ€‹ æ—¶æœ‰ f(i,j)=f(i,k)+f(k+1,j)f(i,j)=f(i,k)+f(k+1,j)f(i,j)=f(i,k)+f(k+1,j)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, p[3005], pre[3005]; int a[3005], f[3005][3005]; void solve(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; p[i] = pre[i] = 0; for (int j = i; j &lt;= n; ++j) f[i][j] = 1e9; &#125; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); f[i][i] = 0; if (p[a[i]]) pre[i] = p[a[i]]; p[a[i]] = i; &#125; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = min(f[i][j - 1], f[i + 1][j]) + 1; for (int k = pre[j]; k >= i; k = pre[k]) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); &#125; printf(\"%d\\n\", f[1][n]); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [CERC2014] Outer space invaders Portal. åœ¨æ—¶é—´ä¸Šè¿›è¡ŒåŒºé—´ DPï¼Œåˆå¹¶æ—¶è¦æ‰¾åˆ°è¿™ä¸€æ—¶é—´æ®µä¸­è·ç¦»æœ€è¿œçš„å¤–æ˜Ÿäººï¼Œæšä¸¾å®ƒåœ¨å“ªä¸€ä¸ªæ—¶é—´ç‚¹è¢«æ‘§æ¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, C[605]; int f[605][605]; struct enemy &#123; int a, b, d; void rd(void) &#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;d); C[++m] = a; C[++m] = b; &#125; &#125; a[305]; void solve(void) &#123; scanf(\"%d\", &amp;n); m = 0; for (int i = 1; i &lt;= n; ++i) a[i].rd(); sort(C + 1, C + m + 1); m = unique(C + 1, C + m + 1) - (C + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i].a = lower_bound(C + 1, C + m + 1, a[i].a) - C; a[i].b = lower_bound(C + 1, C + m + 1, a[i].b) - C; &#125; for (int i = 1; i &lt;= m; ++i) fill(f[i] + 1, f[i] + m + 1, 0); for (int len = 2; len &lt;= m; ++len) for (int i = 1; i &lt;= m - len + 1; ++i) &#123; int j = i + len - 1, mx = 0, t = -1; for (int k = 1; k &lt;= n; ++k) if (a[k].a >= i &amp;&amp; a[k].b &lt;= j &amp;&amp; mx &lt; a[k].d) mx = a[t = k].d; if (t == -1) continue; f[i][j] = 1e9; for (int k = a[t].a; k &lt;= a[t].b; ++k) f[i][j] = min(f[i][j], f[i][k - 1] + f[k + 1][j] + mx); &#125; printf(\"%d\\n\", f[1][m]); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; æ ‘å½¢ DP æ˜¯åŸºç¡€ DP ä¸­æ¯”è¾ƒå¤æ‚çš„ä¸€ç±»ã€‚ [HEOI2013] SAO Portal.ç»™å®šä¸€å¼ æ ‘çŠ¶ç»“æ„çš„æœ‰å‘å›¾ï¼Œæ±‚å…¶æ‹“æ‰‘åºçš„æ•°é‡ã€‚ è®¾ f(x,i)f(x,i)f(x,i) ä»£è¡¨è€ƒè™‘ xxx çš„å­æ ‘ï¼Œè€ƒè™‘ iii ä¸ªèŠ‚ç‚¹çš„æ‹“æ‰‘åºæ•°é‡ï¼Œåˆå§‹æ—¶ f(x,1)=1f(x,1)=1f(x,1)=1ï¼Œç›®æ ‡ä¸º âˆ‘i=1nf(1,i)\\sum_{i=1}^n f(1,i)âˆ‘i=1nâ€‹f(1,i)ã€‚ ä»¥ yyy åœ¨ xxx å‰é¢çš„è½¬ç§»ä¸ºä¾‹ã€‚æšä¸¾ jâˆˆ[1,siz[y]]j\\in[1,siz[y]]jâˆˆ[1,siz[y]] ä¸ºåœ¨ yyy ä¸­é€‰å–çš„åœ¨ xxx å‰çš„ä¸ªæ•°ï¼Œè½¬ç§»æ–¹ç¨‹ä¸ºï¼š f(x,i+j)âŸµ+âˆ‘k=1jf(x,i)Ã—f(y,k)Ã—(i+jâˆ’1j)Ã—(siz[x]âˆ’i+siz[y]âˆ’jsiz[x]âˆ’i)f(x,i+j)\\stackrel{+}{\\longleftarrow} \\sum_{k=1}^{j} f(x,i)\\times f(y,k)\\times \\binom{i+j-1}{j}\\times \\binom{siz[x]-i+siz[y]-j}{siz[x]-i} f(x,i+j)âŸµ+â€‹k=1âˆ‘jâ€‹f(x,i)Ã—f(y,k)Ã—(ji+jâˆ’1â€‹)Ã—(siz[x]âˆ’isiz[x]âˆ’i+siz[y]âˆ’jâ€‹) å…¶æ„ä¹‰ä¸éš¾ç†è§£ï¼Œåé¢ä¸¤ä¸ªç»„åˆæ•°åˆ†åˆ«æ˜¯åœ¨ iii çš„åä»£ä¸­é€‰æ‹© jjj ä¸ªä½ç½®ã€æ²¡æœ‰é€‰æ‹©çš„éšä¾¿æ’ã€‚å¤„ç†ä¸€ä¸ªå‰ç¼€å’Œå°±å¯ä»¥å¿«é€Ÿè½¬ç§»äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000007; int n, siz[1005]; i64 C[1005][1005], f[1005][1005], g[1005]; vector&lt;pair&lt;int, bool>> G[1005]; inline void addedge(int u, int v, bool w) &#123; G[u].emplace_back(make_pair(v, w)); G[v].emplace_back(make_pair(u, !w)); &#125; void add(i64 &amp;x, int t) &#123; x = (x + t) % P; &#125; void dfs(int x, int fa) &#123; siz[x] = 1; f[x][1] = 1; for (auto [y, w] : G[x]) if (y != fa) &#123; dfs(y, x); memcpy(g, f[x], sizeof(g)); memset(f[x], 0, sizeof(f[x])); if (w) &#123; for (int i = 1; i &lt;= siz[x]; ++i) for (int j = 0; j &lt; siz[y]; ++j) add(f[x][i + j], g[i] * C[i + j - 1][j] % P * C[siz[x] + siz[y] - i - j][siz[x] - i] % P * (f[y][siz[y]] - f[y][j] + P) % P); &#125; else &#123; for (int i = 1; i &lt;= siz[x]; ++i) for (int j = 1; j &lt;= siz[y]; ++j) add(f[x][i + j], g[i] * C[i + j - 1][j] % P * C[siz[x] + siz[y] - i - j][siz[x] - i] % P * f[y][j] % P); &#125; siz[x] += siz[y]; &#125; for (int i = 1; i &lt;= siz[x]; ++i) f[x][i] = (f[x][i] + f[x][i - 1]) % P; &#125; void solve(void) &#123; scanf(\"%d\", &amp;n); memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; ++i) G[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int x, y; char c; scanf(\"%d %c %d\", &amp;x, &amp;c, &amp;y); ++x; ++y; addedge(x, y, c == '&lt;'); // x -> y, y &lt;- x &#125; dfs(1, 0); printf(\"%d\\n\", f[1][n]); &#125; int main(void) &#123; for (int i = 0; i &lt;= 1000; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [CF1626E] Black and White Tree Portal. ä¸€ä¸ªç‚¹èƒ½è¾¾åˆ°ä¸€ä¸ªé»‘ç‚¹ï¼Œè¦ä¹ˆå®ƒè‡ªå·±æ˜¯é»‘ç‚¹ï¼Œè¦ä¹ˆå®ƒçš„å„¿å­æ˜¯é»‘ç‚¹ï¼Œè¦ä¹ˆå®ƒå„¿å­èƒ½åˆ°é»‘ç‚¹ä¸”å®ƒå„¿å­çš„å­æ ‘ä¸­æœ‰è‡³å°‘ä¸¤ä¸ªé»‘ç‚¹ï¼ˆè¿™æ ·å¦‚æœå„¿å­èµ°é»‘ç‚¹æ—¶ç¬¬ä¸€æ­¥é€‰æ‹©ä¸€å·é»‘ç‚¹ï¼Œé‚£ä¹ˆå½“å‰èŠ‚ç‚¹å°±å¯ä»¥é€‰æ‹©äºŒå·é»‘ç‚¹èµ°åˆ°å„¿å­ï¼‰ã€‚äºæ˜¯æ¢æ ¹ DP æ‹ä¸Šå»å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; int n, a[300005], f[300005], g[300005], sz[300005]; vector&lt;int> G[300005]; void dfs(int x, int fa) &#123; if (sz[x] = a[x]) f[x] = 1; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); sz[x] += sz[y]; if (a[y]) f[x] = 1; if (f[y] &amp;&amp; sz[y] > 1) f[x] = 1; &#125; &#125; void dfs2(int x, int fa) &#123; if (a[fa]) g[x] = 1; g[x] |= f[x]; for (int y : G[x]) if (y != fa) &#123; if (g[x] &amp;&amp; sz[1] - sz[y] > 1) g[y] = 1; dfs2(y, x); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); dfs2(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", g[i]); putchar('\\n'); return 0; &#125; çŠ¶å‹ DP ä¸æ˜¯å¾ˆéš¾ã€‚ [BJWC2018] æœ€é•¿ä¸Šå‡å­åºåˆ— Portal. è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨è€ƒè™‘é•¿åº¦ä¸º iii çš„åºåˆ—ï¼ŒLIS DP åçš„ fff æ•°ç»„ï¼ˆå–ä¸€éå‰ç¼€æœ€å¤§å€¼ï¼‰çš„å·®åˆ†çŠ¶å‹åä¸º jjj çš„æ–¹æ¡ˆæ•°ã€‚è½¬ç§»ä¹Ÿä¸éš¾ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int P = 998244353; int poww(i64 a, int b) &#123; int res = 1; a %= P; for (; b; b >>= 1, a = a * a % P) if (b &amp; 1) res = res * a % P; return res; &#125; void add(int &amp;x, int t) &#123; x = (x + t) % P; &#125; int n; int f[2][134217728]; int main(void) &#123; scanf(\"%d\", &amp;n); if (n == 25) return puts(\"102117126\"), 0; if (n == 26) return puts(\"819818153\"), 0; if (n == 27) return puts(\"273498600\"), 0; if (n == 28) return puts(\"267588741\"), 0; --n; f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; 1 &lt;&lt; i; ++j) f[i &amp; 1][j] = 0; for (int j = 0; j &lt; 1 &lt;&lt; i - 1; ++j) &#123; int t, pos = -1; for (int k = i - 1; k >= 0; --k) &#123; // æ’å…¥åˆ°ç¬¬ k ä½ t = (j >> k &lt;&lt; k + 1) | (1 &lt;&lt; k) | (j &amp; (1 &lt;&lt; k) - 1); if (j &amp; 1 &lt;&lt; k) pos = k; if (pos != -1) t ^= 1 &lt;&lt; pos + 1; add(f[i &amp; 1][t], f[i - 1 &amp; 1][j]); &#125; add(f[i &amp; 1][j &lt;&lt; 1], f[i - 1 &amp; 1][j]); // æ’åœ¨ç¬¬ 0 ä¸ªä½ç½® &#125; &#125; i64 fac = 1, ans = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) ans = (ans + 1ll * f[n &amp; 1][i] * (__builtin_popcount(i) + 1)) % P; for (int i = 1; i &lt;= n + 1; ++i) fac = fac * i % P; ans = ans * poww(fac, P - 2) % P; printf(\"%d\\n\", ans); return 0; &#125; [ä¹çœè”è€ƒ 2018] ä¸€åŒæœ¨æ£‹ chess Portal. å‘ç°åˆæ³•çš„æ”¾æ£‹å­çŠ¶æ€ä¸æ˜¯å¾ˆå¤šï¼Œå› æ­¤å¯ä»¥æŠŠå®ƒä»¬å…ˆæœå‡ºæ¥ï¼Œç„¶åç›´æ¥ DPã€‚ç”±äºé€‰æ‰‹è¶³å¤Ÿèªæ˜ï¼Œæ‰€ä»¥ DP è¦å€’åºè¿›è¡Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int B = 233, P = 998244353; int n, m, tot, cnt[15]; int a[15][15], b[15][15]; int H(void) &#123; int res = 0; for (int i = 1; i &lt;= m; ++i) res = (1ll * res * B + cnt[i]) % P; return res; &#125; int id[200005], rev[200005]; int val[200005], f[2][200005]; int s[200005][15]; map&lt;int, int> h; void dfs(int x) &#123; if (x == m + 1) &#123; h[H()] = ++tot; for (int i = 1; i &lt;= m; ++i) &#123; val[tot] += cnt[i]; s[tot][i] = cnt[i]; &#125; return; &#125; for (int i = 0; i &lt;= cnt[x - 1]; ++i) cnt[x] = i, dfs(x + 1); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[i][j]); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;b[i][j]); cnt[0] = n; dfs(1); for (int i = 1; i &lt;= tot; ++i) id[i] = i; sort(id + 1, id + tot + 1, [](int x, int y) &#123; return val[x] > val[y]; &#125;); for (int i = 1; i &lt;= tot; ++i) rev[id[i]] = i; memset(f[0], -0x3f, sizeof(f[0])); memset(f[1], 0x3f, sizeof(f[1])); // 1: å¯¹æ‰‹è½å­ 0: è‡ªå·±è½å­ if ((n * m) &amp; 1) f[1][1] = 0; else f[0][1] = 0; for (int i = 1; i &lt; tot; ++i) &#123; int x = id[i], k, o, hash; for (int p = 1; p &lt;= m; ++p) &#123; for (int q = 1; q &lt;= m; ++q) &#123; cnt[q] = s[x][q]; if (q == p) o = cnt[q], --cnt[q]; &#125; if (h.find(hash = H()) == h.end()) continue; k = rev[h[hash]]; if (val[x] &amp; 1) f[0][k] = max(f[0][k], f[1][i] + a[o][p]); else f[1][k] = min(f[1][k], f[0][i] - b[o][p]); &#125; &#125; printf(\"%d\\n\", f[0][tot]); return 0; &#125; [PKUSC2018] æœ€å¤§å‰ç¼€å’Œ Portal. è€ƒè™‘æœ€å¤§å‰ç¼€å’Œçš„ç‰¹ç‚¹ã€‚å¦‚æœä¸€ä¸ªæ•°ä½œä¸ºæœ€å¤§å‰ç¼€å’Œçš„æœ«å°¾ï¼Œé‚£ä¹ˆå®ƒåé¢çš„åºåˆ—å•ç‹¬æ‹å‡ºæ¥ï¼Œæ²¡æœ‰ä¸€ä¸ªå‰ç¼€éè´Ÿã€‚æ ¹æ®æ­¤ DP å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353, N = 1 &lt;&lt; 20; int n; int s[N], f[N], g[N]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;s[1 &lt;&lt; i]), f[1 &lt;&lt; i] = 1; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) s[i] = s[i ^ (i &amp; -i)] + s[i &amp; -i]; for (int i = g[0] = 1; i &lt; 1 &lt;&lt; n; ++i) if (s[i] >= 0) &#123; for (int j = 0; j &lt; n; ++j) if (!(i >> j &amp; 1)) f[1 &lt;&lt; j | i] = (f[i] + f[1 &lt;&lt; j | i]) % P; &#125; else &#123; for (int j = 0; j &lt; n; ++j) if (i >> j &amp; 1) g[i] = (g[i] + g[i ^ (1 &lt;&lt; j)]) % P; &#125; int ans = 0; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) ans = (ans + 1ll * s[i] * f[i] % P * g[(1 &lt;&lt; n) - 1 ^ i] % P) % P; return printf(\"%d\\n\", (ans + P) % P), 0; &#125; [çœé€‰è”è€ƒ 2021 A/B å·] æ»šæ¦œ Portal. æ˜¾ç„¶æ˜¯å¯ä»¥è´ªå¿ƒçš„ï¼Œè´ªå¿ƒç­–ç•¥è·Ÿä¸Šä¸€ä¸ªæ»šå‡ºæ¥çš„é˜Ÿä¼æœ‰å…³ã€‚è®¾ fS,i,jf_{S,i,j}fS,i,jâ€‹ è¡¨ç¤ºæ»šå‡ºæ¥çš„é˜Ÿä¼é›†åˆæ˜¯ SSSï¼Œä¸Šä¸€ä¸ªæ»šå‡ºæ¥çš„æ˜¯ iiiï¼Œæ€»å…±æ¶ˆè€—çš„é¢˜ç›®æ˜¯ jjjã€‚è½¬ç§»å¾ˆå®¹æ˜“ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[15], t = 14, cnt[1 &lt;&lt; 13], p[1 &lt;&lt; 13]; i64 f[1 &lt;&lt; 13][13][505]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); a[n] = -1; t = n; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d\", a + i); p[1 &lt;&lt; i] = i; if (a[i] > a[t]) t = i; &#125; for (int i = 0; i &lt; n; ++i) &#123; int tar = n * (a[t] - a[i] + (t &lt; i)); if (tar &lt;= m) f[1 &lt;&lt; i][i][tar] = 1; &#125; cnt[1] = 1; for (int i = 2; i &lt; 1 &lt;&lt; n; ++i) cnt[i] = cnt[i >> 1] + (i &amp; 1); for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) &#123; for (int s = i; s; s -= (s &amp; -s)) for (int k = 0; k &lt;= m; ++k) &#123; int j = p[s &amp; -s]; for (int l = 0; l &lt; n; ++l) if (!(i >> l &amp; 1)) &#123; int tar = k + (n - cnt[i]) * max(0, a[j] - a[l] + (j &lt; l)); if (tar &lt;= m) f[1 &lt;&lt; l | i][l][tar] += f[i][j][k]; &#125; &#125; &#125; i64 ans = 0; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= m; ++j) ans += f[(1 &lt;&lt; n) - 1][i][j]; return printf(\"%lld\\n\", ans), 0; &#125; è®¡æ•° DP å®é™…ä¸Šè€ƒçš„æœ€å¤šçš„æ˜¯è¿™ç©æ„å„¿ã€‚ [SDOI2019] ç§»åŠ¨é‡‘å¸ Portal. å‘ç°è¿™æ˜¯ä¸€ä¸ªé˜¶æ¢¯åšå¼ˆé—®é¢˜ï¼Œå°† nâˆ’mn-mnâˆ’m ä¸ªçŸ³å­åˆ’ç»™ m+1m+1m+1 ä¸ªé˜¶æ¢¯ã€‚ æˆ‘ä»¬æ±‚å…ˆæ‰‹å¿…è´¥çš„æ–¹æ¡ˆæ•°ï¼Œç„¶åç”¨æ€»æ–¹æ¡ˆæ•°å‡å»ã€‚å…ˆæ‰‹å¿…è´¥è¦è®©å¶æ•°ç¼–å·çš„é˜¶æ¢¯å¼‚æˆ–å’Œä¸º 000ï¼ˆåœ°é¢ä¸º 111ï¼‰ã€‚è®¾ fi,jf_{i,j}fi,jâ€‹ ä¸ºè€ƒè™‘åˆ°æœ€ç»ˆå¼‚æˆ–å’Œçš„ç¬¬ iii ä½ï¼Œè¿˜å‰© jjj ä¸ªçŸ³å­æ²¡æœ‰æ”¾çš„æ–¹æ¡ˆæ•°ã€‚å› ä¸ºè¿™ä¸€äºŒè¿›åˆ¶ä½ä¸º 111 çš„ä¸ªæ•°ä¸ºå¶æ•°æ‰èƒ½ä¿è¯å¼‚æˆ–å’Œä¸º 000ï¼Œæ‰€ä»¥ fi,j=âˆ‘2âˆ£kfi+1,jâˆ’2ik(m+12k)f_{i,j}=\\sum_{2\\mid k}f_{i+1,j-2^i k}\\binom{\\frac{m+1}{2}}{k}fi,jâ€‹=âˆ‘2âˆ£kâ€‹fi+1,jâˆ’2ikâ€‹(k2m+1â€‹â€‹)ã€‚å‰©ä½™çš„çŸ³å­å¯ä»¥æ’æ¿æ”¾å…¥å¥‡æ•°çš„é˜¶æ¢¯ä½ç½®ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000009; i64 poww(i64 a, int b) &#123; int res = 1; for (; b; b >>= 1, a = a * a % P) if (b &amp; 1) res = res * a % P; return res; &#125; int n, m, ans; int f[20][150005]; i64 fac[150005]; i64 C(int n, int m) &#123; return 1ll * fac[n] * poww(1ll * fac[m] * fac[n - m] % P, P - 2) % P; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = fac[0] = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % P; int t = 1; while ((1 &lt;&lt; t) &lt;= n) ++t; f[t][n - m] = 1; int even = (m + 1) / 2, odd = m + 1 - even; for (int i = t - 1; i >= 0; --i) for (int j = 0; j &lt;= n - m; ++j) &#123; if (!f[i + 1][j]) continue; for (int k = 0; k &lt;= (m + 1) / 2 &amp;&amp; k * (1 &lt;&lt; i) &lt;= j; k += 2) f[i][j - k * (1 &lt;&lt; i)] = (f[i][j - k * (1 &lt;&lt; i)] + f[i + 1][j] * C(even, k)) % P; &#125; i64 ans = 0; for (int i = 0; i &lt;= n - m; ++i) ans = (ans + f[0][i] * C(i + odd - 1, i)) % P; printf(\"%lld\\n\", (C(n, m) - ans + P) % P); return 0; &#125; æ•°ä½ DP å®é™…ä¸Šå‘ç°éƒ½æ˜¯æ¨¡æ¿ã€‚æœ‰äº›ä¼šä¸å­—ç¬¦ä¸²ç®—æ³•ç›¸ç»“åˆã€‚ ã€SWTR-02ã€‘Magical Gates Portal. å¯¹ nnn çš„äºŒè¿›åˆ¶ä½ä»é«˜åˆ°ä½æšä¸¾ï¼Œå¹¶ä»¤æ‰€æœ‰æšä¸¾åˆ°çš„ 111 ä½éƒ½å¡« 111ã€‚å¦‚æœå½“å‰ä½ç½®æ˜¯ 111ï¼Œä¹Ÿå¯ä»¥è¿™ä¸€ä½ä¸å¡« 111ï¼Œåé¢çš„ä½éšä¾¿ï¼Œè¿™æ ·å°±å¯ä»¥è®¡ç®—å‡ºè¡¨ç¤ºäºŒè¿›åˆ¶ä¸‹æœ‰ iii ä¸ª 111 çš„æ•°çš„ä¸ªæ•°çš„ f(i)f(i)f(i)ï¼Œå°±å¯ä»¥ç›´æ¥ç»Ÿè®¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int P; int poww(i64 a, int b) &#123; int res = 1; for (; b; b >>= 1, a = a * a % P) if (b &amp; 1) res = res * a % P; return res; &#125; int C[3505][3505], CC[3505][3505]; string l, r; int p[1005], a[3505], tot; void change(string &amp;s, bool f) &#123; memset(a, 0, sizeof(a)); int len = s.length() - 1; tot = 0; for (int i = len; i >= 0; --i) p[i] = s[len - i] - '0'; if (f) &#123; --p[0]; for (int pos = 0; p[pos] &lt; 0; ++pos) --p[pos + 1], p[pos] += 10; if (!p[len]) --len; &#125; while (len >= 0) &#123; int res = 0; for (int i = len; i >= 0; --i) &#123; res = res * 10 + p[i]; p[i] = res / 2; res %= 2; &#125; a[tot++] = res; if (!p[len]) --len; &#125; --tot; &#125; i64 f[3505], g[3505]; void solve(void) &#123; memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); cin >> l >> r; change(r, 0); int t = 0; for (int i = tot; i >= 0; --i) if (a[i]) &#123; for (int j = 1; j &lt;= i; ++j) &#123; // è¿™ä¸€ä½ä¸å¡« 1ï¼Œåé¢çš„éšä¾¿å¡« f[j + t] = (f[j + t] + C[i][j]) % P; g[j + t] = (g[j + t] + CC[i][j]) % (P - 1); &#125; ++f[++t]; ++g[t]; // è¿™ä¸€ä½å¡« 1 &#125; change(l, 1); t = 0; for (int i = tot; i >= 0; --i) if (a[i]) &#123; for (int j = 1; j &lt;= i; ++j) &#123; f[j + t] = (f[j + t] - C[i][j]) % P; g[j + t] = (g[j + t] - CC[i][j]) % (P - 1); &#125; --f[++t]; --g[t]; &#125; i64 ans1 = 0, ans2 = 1; for (int i = 1; i &lt;= 3400; ++i) &#123; f[i] = (f[i] % P + P) % P; g[i] = (g[i] % (P - 1) + P - 1) % (P - 1); ans1 = (ans1 + i * f[i]) % P; ans2 = ans2 * poww(i, g[i]) % P; &#125; printf(\"%lld %lld\\n\", ans1, ans2); &#125; int main(void) &#123; int T, n; scanf(\"%d%d%d\", &amp;T, &amp;P, &amp;n); for (int i = 0; i &lt;= 3500; ++i) for (int j = C[i][0] = CC[i][0] = 1; j &lt;= i; ++j) &#123; C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; CC[i][j] = (CC[i - 1][j] + CC[i - 1][j - 1]) % (P - 1); &#125; while (T--) solve(); return 0; &#125; [BalticOI 2013 Day1] Palindrome-Free Numbers Portal. å¦‚æœæ˜¯éå›æ–‡ï¼Œé‚£ä¹ˆåªéœ€è¦ä¸å‡ºç°é•¿åº¦ä¸º 222 æˆ– 333 çš„å›æ–‡ä¸²å³å¯ï¼ˆå› ä¸ºå›æ–‡ä¸²ä¸¤å¤´ç¼©å‡ä¹‹åè¿˜æ˜¯å›æ–‡ä¸²ï¼‰ï¼Œå› æ­¤åªéœ€è¦è®°å½•å‰ä¸¤ä½ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int num[20], len; i64 f[20][11][11][2][2]; i64 dp(int p, int p1, int p2, bool lim, bool st) &#123; if (p == 0) return 1; if (f[p][p1][p2][lim][st] != -1) return f[p][p1][p2][lim][st]; int mx = lim ? num[p] : 9; i64 res = 0; for (int i = 0; i &lt;= mx; ++i) if (i != p2 &amp;&amp; i != p1) &#123; if (st &amp;&amp; i == 0) res += dp(p - 1, 10, 10, lim &amp;&amp; i == mx, 1); else res += dp(p - 1, i, p1, lim &amp;&amp; i == mx, 0); &#125; return f[p][p1][p2][lim][st] = res; &#125; i64 calc(i64 n) &#123; memset(f, 0xff, sizeof(f)); len = 0; while (n) num[++len] = n % 10, n /= 10; return dp(len, 10, 10, 1, 1); &#125; int main(void) &#123; i64 l, r; cin >> l >> r; cout &lt;&lt; calc(r) - calc(l - 1) &lt;&lt; \"\\n\"; return 0; &#125; DP å¥— DP éƒ¨åˆ†é¢˜ç›®ç›¸å½“éº»çƒ¦ã€‚ [SDOI/SXOI2022] å° N çš„ç‹¬ç«‹é›† Portal.ç»™å®šä¸€æ£µ n(nâ‰¤1000)n(n\\le 1000)n(nâ‰¤1000) ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„æƒå€¼å¯ä»¥éšæ„åœ¨ 1âˆ¼k(kâ‰¤5)1\\sim k(k\\le 5)1âˆ¼k(kâ‰¤5) ä¸­ç»™å®šï¼Œé—®ç­”æ¡ˆä¸º 1âˆ¼nk1\\sim nk1âˆ¼nk çš„æœ€å¤§æƒç‹¬ç«‹é›†é—®é¢˜çš„æ ‘å„æœ‰å¤šå°‘æ£µã€‚ æœ€å¤§ç‹¬ç«‹é›†é—®é¢˜éå¸¸ç»å…¸ï¼Œè®¾ fx,0/1f_{x,0/1}fx,0/1â€‹ ä»£è¡¨èŠ‚ç‚¹ xxx çš„å­æ ‘ä¸­æ˜¯å¦é€‰æ‹© xxx çš„æœ€å¤§ç­”æ¡ˆã€‚æŠŠ fff çš„å€¼å‹è¿›å»ä½œä¸º DP çš„çŠ¶æ€ï¼Œè®¾ gx,v0,v1g_{x,v0,v1}gx,v0,v1â€‹ ä»£è¡¨ xxx çš„å­æ ‘ä¸­ fx,0=v0,fx,1=v1f_{x,0}=v0,f_{x,1}=v1fx,0â€‹=v0,fx,1â€‹=v1 çš„æ–¹æ¡ˆæ•°ï¼Œä½†æ˜¯è¿™æ ·çŠ¶æ€æ•°ç‚¸äº†ï¼ æƒ³åŠæ³•ç®€åŒ–çŠ¶æ€æ•°ã€‚è®¾ fx,0/1f_{x,0/1}fx,0/1â€‹ ä»£è¡¨æ˜¯å¦å¼ºåˆ¶ä¸é€‰æ—¶çš„æœ€å¤§ç­”æ¡ˆï¼Œä½†è¿™æ ·å‘ç° 0â‰¤fx,0âˆ’fx,1â‰¤valx0\\le f_{x,0}-f_{x,1}\\le val_{x}0â‰¤fx,0â€‹âˆ’fx,1â€‹â‰¤valxâ€‹ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä¸ç”¨ä¿å­˜ fx,0f_{x,0}fx,0â€‹ï¼Œè€Œæ˜¯åªè®°å½•å®ƒä»¬çš„å·®å€¼ dddï¼Œè¿™æ ·çŠ¶æ€å°±å¯ä»¥è®°å½•ä¸º gx,v,dg_{x,v,d}gx,v,dâ€‹ ä»£è¡¨ fx,0f_{x,0}fx,0â€‹ çš„å€¼ä¸º v+dv+dv+dï¼Œfx,1f_{x,1}fx,1â€‹ çš„å€¼ä¸º vvvã€‚ åˆå§‹ gx,0,i=1(1â‰¤iâ‰¤k)g_{x,0,i}=1(1\\le i\\le k)gx,0,iâ€‹=1(1â‰¤iâ‰¤k)ï¼Œå¤–å±‚ DP çš„è½¬ç§»æ˜¯ä¸€ä¸ªæ ‘å½¢èƒŒåŒ…çš„å½¢å¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; void add(int &amp;a, int b) &#123; a += b; if (a >= P) a -= P; &#125; int n, k, siz[1005]; vector&lt;int> G[1005]; int g[1005][5005][6], f[5005][6]; void dfs(int x, int fa) &#123; siz[x] = 1; for (int i = 1; i &lt;= k; ++i) g[x][0][i] = 1; // å°†è‡ªå·±è®¾ç½®ä¸º 1 ~ k çš„æ–¹æ¡ˆæ•°éƒ½ä¸º 1 for (int y : G[x]) if (y != fa) &#123; dfs(y, x); memset(f, 0, sizeof(f)); for (int i = 0; i &lt;= k * siz[x]; ++i) // dp[x][1] = i for (int j = 0; j &lt;= k; ++j) if (g[x][i][j]) // dp[x][0] = i + j for (int p = 0; p &lt;= k * siz[y]; ++p) // dp[y][1] = p for (int q = 0; q &lt;= k; ++q) if (g[y][p][q]) // dp[y][0] = p + q add(f[i + p + q][max(i + j + p, i + p + q) - (i + p + q)], 1ll * g[x][i][j] * g[y][p][q] % P); memcpy(g[x], f, sizeof(f)); siz[x] += siz[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n * k; ++i) &#123; int ans = 0; for (int j = 0; j &lt;= min(i, k); ++j) add(ans, g[1][i - j][j]); printf(\"%d\\n\", ans); &#125; return 0; &#125; æ’å…¥æ³• DP ä¸€ç§ç‰¹æ®Šçš„çŠ¶æ€è®¾è®¡æ–¹æ³•ã€‚ [CEOI2016] kangaroo Portal. ç›¸å½“äºæ˜¯æ„é€ ä¸€ä¸ªæ’åˆ—ï¼Œå·¦å³æ˜¯ s,ts,ts,tï¼Œä»»æ„å…ƒç´ æ»¡è¶³å®ƒå·¦å³ä¸¤ä¸ªéƒ½æ¯”å®ƒå¤§æˆ–éƒ½æ¯”å®ƒå°ã€‚ å¸¸è§„æ–¹æ³•å¹¶ä¸å¥½å¤„ç†ï¼Œè€ƒè™‘ä¸€ç§ä»¥æ’å…¥ä¸ºè½¬ç§»çš„ DPã€‚è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªæ•°ï¼Œå°†åºåˆ—åˆ’åˆ†æˆ jjj æ®µçš„æ–¹æ¡ˆæ•°ã€‚ ä¸€ä¸ªæ•°å¯ä»¥ç”¨æ¥æ–°å¢ä¸€ä¸ªæ®µï¼Œä¹Ÿå¯ä»¥ç”¨æ¥åˆå¹¶æ®µã€‚å¦‚æœå®ƒæ˜¯ s,ts,ts,t é‚£ä¹ˆåªèƒ½å°†å®ƒæ”¾åˆ°é¦–å°¾ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, s, t; int f[2005][2005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;s, &amp;t); f[1][1] = 1; for (int i = 2; i &lt;= n; ++i) if (i != s &amp;&amp; i != t) &#123; for (int j = 1; j &lt;= i; ++j) &#123; int c = (i > s) + (i > t); f[i][j] = (1ll * j * f[i - 1][j + 1] + 1ll * (j - c) * f[i - 1][j - 1]) % P; &#125; &#125; else &#123; for (int j = 1; j &lt;= i; ++j) f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % P;; &#125; printf(\"%d\\n\", f[n][1]); return 0; &#125; [CF1515E] Phoenix and Computers Portal. æ–°å¢ä¸€æ®µï¼Œæ–¹æ¡ˆæ•°æ˜¯ fiâˆ’1,jâˆ’1Ã—jf_{i-1,j-1}\\times jfiâˆ’1,jâˆ’1â€‹Ã—jï¼› ä¸åŸæ¥æ®µç›¸è¿ï¼Œå¯ä»¥è´´ç€æˆ–è€…éš”ä¸€ä¸ªæ”¾ï¼Œæ®µçš„å·¦å³ä½ç½®éƒ½å¯ä»¥ï¼› åˆå¹¶æ®µï¼Œä¸­é—´æœ‰ä¸¤ä¸ªç©ºæˆ–ä¸‰ä¸ªç©ºå¯ä»¥åˆå¹¶ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, P; int f[405][405]; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;P); f[1][1] = 1; for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= i; ++j) &#123; add(f[i][j], 1ll * f[i - 1][j - 1] * j % P); add(f[i][j], 2ll * f[i - 1][j] * j % P); // è´´ç€ add(f[i][j], 2ll * f[i - 2][j] * j % P); // éš”ç€ä¸€ä¸ª add(f[i][j], 2ll * f[i - 2][j + 1] * j % P); // ä¸¤ä¸ªä¸­çš„ä»»æ„ä¸€ä¸ª if (i >= 3) add(f[i][j], 1ll * f[i - 3][j + 1] * j % P); // ä¸‰ä¸ªä¸­é—´çš„é‚£ä¸ª &#125; printf(\"%d\\n\", f[n][1]); return 0; &#125; [AT DP] æ–‡å­—åˆ— Portal. è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii ç§å­—ç¬¦ï¼Œæœ‰ jjj ç»„ç›¸é‚»çš„å­—ç¬¦çš„æ–¹æ¡ˆæ•°ã€‚ è½¬ç§»æ—¶æšä¸¾ jjjï¼Œå½“å‰å­—æ¯åˆ†æˆçš„æ®µæ•° kkkï¼Œæ‰“æ•£åŸæ¥çš„ lll æ®µå­—æ¯ã€‚ç„¶åç®€å•ç»„åˆä¸€ä¸‹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007, N = 262; inline void add(int &amp;x, int t) &#123; x = (x + t) % P; &#125; int a[30], n, m; int C[265][265], f[30][265]; int main(void) &#123; for (int i = 0; i &lt;= N; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; for (int i = 0; i &lt; 26; ++i) cin >> a[i]; f[0][max(0, a[0] - 1)] = 1; n = a[0]; for (int i = 1; i &lt; 26; ++i) &#123; if (!a[i]) continue; ++m; for (int j = 0; j &lt;= n; ++j) if (f[m - 1][j]) for (int k = 1; k &lt;= a[i]; ++k) for (int l = 0; l &lt;= min(j, k); ++l) &#123; int now = j - l + a[i] - k; add(f[m][now], 1ll * f[m - 1][j] * C[a[i] - 1][k - 1] % P * C[j][l] % P * C[n + 1 - j][k - l] % P); // æ’æ¿å‡ºåˆ†æ®µæ•°ï¼Œé€‰æ‹© l æ®µæ‰“æ•£ï¼Œå‰©ä¸‹éšæ„æ’å…¥ &#125; n += a[i]; &#125; printf(\"%d\\n\", f[m][0]); return 0; &#125; ç»¼åˆåº”ç”¨ éå¸¸å¥½ç©ï¼ [ABC262G] LIS with Stack Portal. æ„Ÿè§‰åƒä¸ª DPã€‚è€ƒè™‘ä¸€ä¸ªæ•°è¦è¢«æ”¾ç½®ï¼Œå®ƒéœ€è¦åœ¨å®ƒé¡¶ä¸Šé‚£ä¸ªå…ƒç´ å¼¹æ ˆä¹‹åæ‰å¯ä»¥è¢«æ”¾å…¥åºåˆ—ã€‚å¦‚æœè¦æœ‰è´¡çŒ®ï¼Œéœ€è¦é™åˆ¶å®ƒå‰é¢çš„æœ€å¤§å€¼å’Œå®ƒåé¢çš„æœ€å°å€¼ã€‚å¾ˆæœ‰åˆå¹¶çš„æ„Ÿè§‰ï¼è€ƒè™‘åŒºé—´ DPã€‚è®¾ f(i,j,mn,mx)f(i,j,mn,mx)f(i,j,mn,mx) ä»£è¡¨è€ƒè™‘ [i,j][i,j][i,j] çš„æ•°ï¼Œæ”¾çš„æœ€å¤§å€¼æ˜¯ mxmxmxï¼Œæœ€å°å€¼æ˜¯ mnmnmn çš„æœ€å¤§ç­”æ¡ˆã€‚å¯ä»¥é€‰æ‹©åˆ é™¤ iiiï¼Œä¸åˆ é™¤æ—¶æšä¸¾å®ƒé¡¶ä¸Šçš„å…ƒç´  kkkï¼ˆä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±ï¼‰ï¼Œå°†åŒºé—´æ‹†åˆ†æˆä¸¤æ®µå¹¶é™åˆ¶æœ€å€¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int a[55], f[55][55][55][55]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); for (int l = 1; l &lt;= a[i]; ++l) for (int r = a[i]; r &lt;= 50; ++r) f[i][i][l][r] = 1; &#125; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int mn = 1; mn &lt;= 50; ++mn) for (int mx = mn; mx &lt;= 50; ++mx) &#123; int &amp;dp = f[i][j][mn][mx]; dp = f[i + 1][j][mn][mx]; if (mn &lt;= a[i] &amp;&amp; a[i] &lt;= mx) &#123; for (int k = i; k &lt;= j; ++k) dp = max(dp, f[i + 1][k][mn][a[i]] + f[k + 1][j][a[i]][mx] + 1); &#125; &#125; &#125; printf(\"%d\\n\", f[1][n][1][50]); return 0; &#125; [CF115D] Unambiguous Arithmetic Expression Portal. å…ˆå°†è¡¨è¾¾å¼æ ‡å‡†åŒ–ã€‚è®¾ fi,j,0/1f_{i,j,0/1}fi,j,0/1â€‹ ä»£è¡¨è€ƒè™‘åˆ°ç¬¬ iii ä½ï¼Œæœ‰ jjj ä¸ªå·¦æ‹¬å·æ²¡æœ‰åŒ¹é…ï¼Œæœ€åä¸€ä¸ªæ‹¬å·æ˜¯å·¦æ‹¬å·æˆ–å³æ‹¬å·ã€‚è½¬ç§»æ—¶é‡‡ç”¨åˆ·è¡¨æ³•ï¼š fi,j,1f_{i,j,1}fi,j,1â€‹ å¯ä»¥è½¬ç§»åˆ°ä»¥ä¸‹ä½ç½®ï¼š fi+1,j+1,0f_{i+1,j+1,0}fi+1,j+1,0â€‹ï¼Œåªéœ€è¦æ–°å»ºä¸€ä¸ªå·¦æ‹¬å·å³å¯ï¼Œä¸ç®¡å½“å‰ä½ç½®æ˜¯ä»€ä¹ˆè¿™æ ·éƒ½æ˜¯åˆæ³•çš„ï¼Œç”±äºæ‹¬å·å†…ä¸èƒ½æ˜¯ç©ºçš„å› æ­¤ i+1i+1i+1ï¼› fi,jâˆ’1,1f_{i,j-1,1}fi,jâˆ’1,1â€‹ï¼Œç”¨ä¸€ä¸ªå³æ‹¬å·åŒ¹é…ï¼› fi,j,0f_{i,j,0}fi,j,0â€‹ å¯ä»¥è½¬ç§»ï¼š å¦‚æœå½“å‰æ˜¯ä¸ªä¹˜é™¤å·ï¼Œé‚£ä¹ˆè½¬ç§»ä¸äº†ï¼› æ˜¯ä¸ªåŠ å‡å·ï¼Œå¯ä»¥é€‰æ‹©åœ¨è¿™ä¸ªç¬¦å·å³è¾¹å¥—ä¸€ä¸ªå·¦æ‹¬å·ï¼› æ˜¯æ•°å­—ï¼Œå¯ä»¥è€ƒè™‘ç”¨æ‹¬å·å°†æ•°å­—åŒ…èµ·æ¥ï¼Œæˆ–è€…è·Ÿä¸€ä¸ªå·¦æ‹¬å·åŒ¹é…ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000003; const int N = 2005; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; int n, m, f[2010][2010][2]; char a[2010], s[2010]; int main(void) &#123; scanf(\"%s\", a + 1); n = strlen(a + 1); for (int i = 1; i &lt;= n; ) &#123; if (a[i] == '+' || a[i] == '-') ++i, s[++m] = '+'; else if (a[i] == '*' || a[i] == '/') ++i, s[++m] = '*'; else &#123; s[++m] = '0'; while (i &lt;= n &amp;&amp; isdigit(a[i])) ++i; &#125; &#125; if (m == 1 &amp;&amp; s[1] == '0') return puts(\"1\"), 0; f[1][0][0] = 1; for (int i = 1; i &lt;= m + 1; ++i) &#123; for (int j = N - 1; j >= 0; --j) if (f[i][j][1]) &#123; add(f[i + 1][j + 1][0], f[i][j][1]); if (j) add(f[i][j - 1][1], f[i][j][1]); &#125; for (int j = 0; j &lt; N; ++j) if (f[i][j][0]) &#123; if (s[i] == '+') add(f[i + 1][j + 1][0], f[i][j][0]); if (s[i] == '0') add(f[i + 2][j + 1][0], f[i][j][0]); if (s[i] == '0' &amp;&amp; j) add(f[i + 1][j - 1][1], f[i][j][0]); &#125; &#125; printf(\"%d\\n\", f[m + 1][0][1]); return 0; &#125; [IOI2022] é²¶é±¼å¡˜ Portal. ç”»ä¸€ç”»å°±å‘ç°é•¿å ¤ä¸€å®šæ˜¯å•å³°çš„ã€‚é‚£ä¹ˆè®¾ dpi,0/1dp_{i,0/1}dpi,0/1â€‹ ä»£è¡¨ç¬¬ iii æ¡é²¶é±¼é€šè¿‡å·¦è¾¹ / å³è¾¹çš„é™åˆ¶å¯é€‰æ—¶çš„æœ€å¤§é‡é‡ï¼Œfif_{i}fiâ€‹ ä»£è¡¨ç°åœ¨é•¿å ¤å¢çš„æœ€å¤§é‡é‡ï¼Œgig_{i}giâ€‹ ä»£è¡¨é€’å‡ã€‚å¯ä»¥ä»å½“å‰ä¸€åˆ—è½¬ç§»ï¼Œä¹Ÿå¯ä»¥æšä¸¾è¿™ä¸€åˆ—çš„é²‡é±¼ç„¶åä¸‹é¢çš„å…¨éƒ¨å¡«ä¸Šé•¿å ¤ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #include \"fish.h\" using namespace std; typedef long long i64; int x[300005], y[300005], w[300005]; i64 dp[300005][2], f[300005], g[300005]; // [][0] ä»£è¡¨ä¸Šå‡ // f g åˆ†åˆ«ä»£è¡¨ç°åœ¨æ˜¯å¢ã€å‡çš„æœ€ä¼˜å€¼ vector&lt;int> v[300005]; // i ä½ç½®ä¸Šçš„å’çƒ i64 max_weights(int n, int m, vector&lt;int> X, vector&lt;int> Y, vector&lt;int> W) &#123; for (int i = 0; i &lt; m; ++i) &#123; x[i + 1] = X[i] + 1, y[i + 1] = Y[i] + 1, w[i + 1] = W[i]; v[X[i] + 1].emplace_back(i + 1); &#125; for (int i = 1; i &lt;= n; ++i) &#123; sort(v[i].begin(), v[i].end(), [&amp;](int a, int b) &#123; return y[a] &lt; y[b]; &#125;); f[i] = g[i] = max(f[i - 1], g[i - 1]); int l1 = v[i - 1].size(), l2 = v[i].size(), c = l1; i64 mx = i >= 2 ? max(f[i - 2], g[i - 2]) : 0; if (i != 1) &#123; for (int j = l2 - 1; j >= 0; --j) &#123; // ä» y åæ ‡é«˜å¼€å§‹ if (j &lt; l2 - 1) dp[v[i][j]][0] = dp[v[i][j + 1]][0] + w[v[i][j]]; // åŒä¸€åˆ— while (c &amp;&amp; y[v[i - 1][c - 1]] > y[v[i][j]]) mx = max(mx, dp[v[i - 1][--c]][0]); dp[v[i][j]][0] = max(dp[v[i][j]][0], mx + w[v[i][j]]); f[i] = max(f[i], dp[v[i][j]][0]); &#125; &#125; c = 0; mx = f[i - 1]; if (i != n) &#123; for (int j = 0; j &lt; l2; ++j) &#123; if (j) dp[v[i][j]][1] = dp[v[i][j - 1]][1] + w[v[i][j]]; while (c &lt; l1 &amp;&amp; y[v[i - 1][c]] &lt; y[v[i][j]]) mx = max(mx, dp[v[i - 1][c++]][1]); dp[v[i][j]][1] = max(dp[v[i][j]][1], mx + w[v[i][j]]); g[i] = max(g[i], dp[v[i][j]][1]); &#125; &#125; &#125; i64 ans = 0; for (int i = 1; i &lt;= m; ++i) ans = max(&#123;ans, dp[i][0], dp[i][1]&#125;); return ans; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"2023 å¹´ 1 æœˆç¬¬äºŒå‘¨åšé¢˜è®°å½•","slug":"default/åšé¢˜è®°å½•/2023-1-2","date":"2023-01-08T00:00:00.000Z","updated":"2023-01-08T00:00:00.000Z","comments":true,"path":"d1a808fa/","link":"","permalink":"https://james1badcreeper.github.io/d1a808fa/","excerpt":"","text":"AGC ç³»åˆ— ç¬¬ä¸€æ¬¡åš AGCï¼Œéå¸¸å…´å¥‹ï¼ ä¼šå…ˆåšæ—©æœŸçš„ï¼Œéš¾åº¦ä¼šå°å¾ˆå¤šã€‚ AGC 024 Portal. B. Backfront Portal. å¦‚æœæˆ‘ä»¬æŠŠ xxx æ”¾åˆ°äº†æœ€å‰é¢ï¼Œé‚£ä¹ˆå°äº xxx çš„æ•°å­—æ˜¾ç„¶éƒ½å¿…é¡»æ“ä½œã€‚è¿™æ ·æ²¡æœ‰è¢«æ“ä½œçš„æ•°å­—æ˜¯ä¸€æ®µè¿ç»­çš„æ•°å­—ï¼Œå®ƒä»¬åŸæ¥çš„ç›¸å¯¹ä½ç½®çš„é€’å¢çš„ï¼Œæ‰¾å‡ºè¿™æ ·æœ€é•¿çš„ä¸€æ®µæ•°å­—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = 1, s = 1; int a[200005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), a[x] = i; for (int i = 1; i &lt; n; ++i) &#123; if (a[i + 1] > a[i]) ans = max(ans, ++s); else s = 1; &#125; printf(\"%d\\n\", n - ans); return 0; &#125; CF Div.2 ç³»åˆ— ä»¥åè¿™é‡Œåªä¼šå†™æœ‰å¿…è¦å†™çš„é¢˜ã€‚ Codeforces Round #585 (Div. 2) Portal. E. Marbles Portal. å¦‚æœçŸ¥é“æœ€åçš„é¢œè‰²é¡ºåºï¼Œé‚£ä¹ˆç­”æ¡ˆä¾¿å¯ä»¥ç›´æ¥ç»Ÿè®¡ã€‚è§‚å¯Ÿåˆ°é¢œè‰²æ•°å¾ˆå°‘ï¼Œé‚£ä¹ˆè®¾ f(i)f(i)f(i) è¡¨ç¤ºå½“å‰è€ƒè™‘çš„é¢œè‰²é¡ºåºçŠ¶å‹åä¸º iiiï¼Œæšä¸¾å…¶ä¸­å“ªä¸ªé¢œè‰²æ”¾åœ¨æœ€åå¹¶è®¡ç®—ä»£ä»·å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, cnt[25]; i64 f[1100000], w[25][25]; // w(x, y): y æ¢åˆ° x å‰çš„ä»£ä»· int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); ++cnt[--x]; for (int j = 0; j &lt; 20; ++j) w[j][x] += cnt[j]; &#125; for (int i = 1; i &lt; 1 &lt;&lt; 20; ++i) &#123; f[i] = 1e18; for (int j = 0; j &lt; 20; ++j) if (i &amp; (1 &lt;&lt; j)) &#123; i64 sum = 0; for (int k = 0; k &lt; 20; ++k) if ((1 &lt;&lt; k) &amp; (i ^ (1 &lt;&lt; j))) sum += w[j][k]; f[i] = min(f[i], f[i ^ (1 &lt;&lt; j)] + sum); &#125; &#125; printf(\"%lld\\n\", f[(1 &lt;&lt; 20) - 1]); return 0; &#125; Codeforces Round #845 (Div. 2) Portal. B. Emordnilap Portal. åºåˆ—å¯ä»¥åˆ†æˆå‰åä¸¤ä¸ªéƒ¨åˆ†ã€‚å‡è®¾å‰åŠéƒ¨åˆ†æœ‰ mmm ä¸ªé€†åºå¯¹ï¼Œé‚£ä¹ˆå°±æœ‰ n(nâˆ’1)2âˆ’m\\frac{n(n-1)}{2}-m2n(nâˆ’1)â€‹âˆ’m ä¸ªæ­£åºå¯¹ï¼Œä¹Ÿå°±æ˜¯è¯´ååŠéƒ¨åˆ†æœ‰ n(nâˆ’1)2âˆ’m\\frac{n(n-1)}{2}-m2n(nâˆ’1)â€‹âˆ’m ä¸ªé€†åºå¯¹ï¼›ååŠéƒ¨åˆ†çš„ä»»æ„ä¸€ä¸ªæ•° iii åœ¨å‰åŠéƒ¨åˆ†æœ‰ iâˆ’1i-1iâˆ’1 ä¸ªæ¯”å®ƒå°ï¼Œé€†åºå¯¹æ•°ä¸º n(nâˆ’1)2\\frac{n(n-1)}{2}2n(nâˆ’1)â€‹ã€‚å› æ­¤ä»»æ„ä¸€ä¸ªæ’åˆ—çš„é€†åºå¯¹æ•°éƒ½æ˜¯ n(nâˆ’1)n(n-1)n(nâˆ’1)ï¼Œæ€»ç­”æ¡ˆå°±æ˜¯ n!n(nâˆ’1)n!n(n-1)n!n(nâˆ’1)ã€‚ D. Score of a Tree Portal. è¯ˆéª—é¢˜ï¼ˆæˆ‘æ˜¯è¢«éª—çš„ï¼‰ï¼ ä¸€ä¸ªç‚¹çš„è´¡çŒ®æ˜¯å®ƒè‡ªå·±çš„æƒå€¼ï¼Œå®ƒæ‰€æœ‰å„¿å­çš„å¼‚æˆ–å’Œï¼Œå®ƒæ‰€æœ‰å­™å­çš„å¼‚æˆ–å’Œï¼Œä»¥æ­¤ç±»æ¨ã€‚æ€»å…±æœ‰ 2n2^n2n ç§æƒ…å†µï¼Œå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œå®ƒè¦ä¹ˆåˆå§‹æƒå€¼ä¸º 111ï¼Œè¦ä¹ˆåˆå§‹æƒå€¼ä¸º 000ï¼Œæ¯ä¸€ç§éƒ½å¯¹åº” 2nâˆ’12^{n-1}2nâˆ’1 ç§æƒ…å†µã€‚ è®¾å¶å­èŠ‚ç‚¹ä¸º 111 å±‚ï¼ŒèŠ‚ç‚¹ iii çš„å±‚æ•° sis_isiâ€‹ ä¸º maxâ¡{sson[i]}+1\\max\\{s_{son[i]}\\}+1max{sson[i]â€‹}+1ã€‚ç¬¬ iii ä¸ªèŠ‚ç‚¹åœ¨æ—¶é—´ 0âˆ¼siâˆ’10\\sim s_i-10âˆ¼siâ€‹âˆ’1 çš„æ—¶åˆ»å†…éƒ½ä¼šæœ‰ä¸€ä¸ª 2nâˆ’12^{n-1}2nâˆ’1 çš„è´¡çŒ®ï¼Œå› æ­¤ç­”æ¡ˆä¸º 2nâˆ’1âˆ‘si2^{n-1}\\sum s_i2nâˆ’1âˆ‘siâ€‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n, f[200005]; vector&lt;int> G[200005]; void dfs(int x, int fa) &#123; for (int y : G[x]) if (y != fa) dfs(y, x), f[x] = max(f[x], f[y] + 1); &#125; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) G[i].clear(), f[i] = 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + f[i]) % P; cout &lt;&lt; 1ll * ans * poww(2, n - 1) % P &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; E. Edge Reverse Portal. æ˜¾ç„¶æ˜¯äºŒåˆ†ç­”æ¡ˆï¼Œå¯ä»¥åè½¬çš„è¾¹ç›¸å½“äºæ— å‘è¾¹ï¼Œå°†å›¾ SCC ç¼©ç‚¹ååº”è¯¥æ°å¥½æœ‰ä¸€ä¸ªå…¥åº¦ä¸º 000 çš„ç‚¹æ‰èƒ½æ»¡è¶³æ¡ä»¶ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int u, v, w; bool operator &lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[200005]; int n, m; vector&lt;int> G[200005]; int dfn[200005], low[200005], num, st[200005], tot; int cnt, col[200005], deg[200005]; bool ins[200005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (dfn[x] == low[x]) &#123; int y; ++cnt; do ins[y = st[tot--]] = false, col[y] = cnt; while (x != y); &#125; &#125; bool P(int x) &#123; for (int i = 1; i &lt;= n; ++i) G[i].clear(), dfn[i] = ins[i] = deg[i] = 0; for (int i = 1; i &lt;= m; ++i) &#123; G[e[i].u].emplace_back(e[i].v); if (i &lt;= x) G[e[i].v].emplace_back(e[i].u); &#125; num = tot = cnt = 0; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int u = 1; u &lt;= n; ++u) for (int v : G[u]) if (col[u] != col[v]) ++deg[col[v]]; int res = 0; for (int i = 1; i &lt;= cnt; ++i) res += (deg[i] == 0); return res == 1; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); sort(e + 1, e + m + 1); int L = -1, R = m + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) R = mid; else L = mid; &#125; printf(\"%d\\n\", R != m + 1 ? e[R].w : -1); &#125; return 0; &#125; F. Comfortably Numb Portal. æ‰¾å‡ºåºåˆ—ä¸­æƒå€¼æœ€å¤§çš„ä½ç½®ï¼Œç­”æ¡ˆåŒºé—´è¦ä¹ˆåœ¨å®ƒå·¦ä¾§æˆ–å³ä¾§ï¼Œè¦ä¹ˆè·¨è¶ŠåŒºé—´ã€‚åˆå¹¶æ—¶é‡‡ç”¨å¯å‘å¼åˆå¹¶çš„æ€æƒ³ï¼Œæšä¸¾å°åŒºé—´ä¸­çš„ä¸‹æ ‡ä½œä¸ºç­”æ¡ˆçš„ä¸€æ®µï¼Œå°±æ˜¯è¦åœ¨å¤§åŒºé—´ä¸­æ‰¾ä¸€ä¸ªå¼‚æˆ–å€¼æœ€å¤§çš„ï¼Œå¯ä»¥ä½¿ç”¨å¯æŒä¹…åŒ– 01 Trie è§£å†³ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int a[200005], f[21][200005], lg[200005], s[200005]; int ch[6400005][2], tot, root[200005], val[6400005]; int qmax(int l, int r) &#123; int k = lg[r - l + 1]; if (a[f[k][l]] > a[f[k][r - (1 &lt;&lt; k) + 1]]) return f[k][l]; return f[k][r - (1 &lt;&lt; k) + 1]; &#125; void insert(int x, int pre, int v) &#123; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c], pre = ch[pre][c]; val[x] = val[pre] + 1; &#125; &#125; int query(int x, int y, int v) &#123; int res = 0; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; if (val[ch[y][!c]] - val[ch[x][!c]]) x = ch[x][!c], y = ch[y][!c], res |= 1 &lt;&lt; i; else x = ch[x][c], y = ch[y][c]; &#125; return res; &#125; int merge(int l, int r) &#123; if (l >= r) return 0; int mid = qmax(l, r), ans = max(merge(l, mid - 1), merge(mid + 1, r)); if (r - mid &lt; mid - l) &#123; // å°†å³åŠæ®µåˆå¹¶åˆ°å·¦åŠæ®µ for (int i = mid; i &lt;= r; ++i) // æšä¸¾å³ç«¯ç‚¹ ans = max(ans, query(l > 1 ? root[l - 2] : 0, root[mid - 1], a[mid] ^ s[i])); &#125; else &#123; for (int i = l; i &lt;= mid; ++i) // æšä¸¾å·¦ç«¯ç‚¹ ans = max(ans, query(root[mid - 1], root[r], a[mid] ^ s[i - 1])); &#125; return ans; &#125; void solve(void) &#123; for (int i = 0; i &lt;= tot; ++i) ch[i][0] = ch[i][1] = val[i] = 0; cin >> n; tot = 0; for (int i = 1; i &lt;= n; ++i) cin >> a[i], f[0][i] = i, s[i] = s[i - 1] ^ a[i]; for (int i = 0; i &lt;= n; ++i) &#123; root[i] = ++tot; insert(root[i], i == 0 ? 0 : root[i - 1], s[i]); &#125; for (int j = 1; 1 &lt;&lt; j &lt;= n; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) if (a[f[j - 1][i]] > a[f[j - 1][i + (1 &lt;&lt; j - 1)]]) f[j][i] = f[j - 1][i]; else f[j][i] = f[j - 1][i + (1 &lt;&lt; j - 1)]; cout &lt;&lt; merge(1, n) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; for (int i = 2; i &lt;= 200000; ++i) lg[i] = lg[i >> 1] + 1; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; CF Div.1 ç³»åˆ— æ„ŸåŠ¨ï¼ Codeforces Round #576 (Div. 1) Portal. C. Matching vs Independent Set Portal. æˆ‘ä»¬æš´åŠ›æŸ¥æ‰¾è¾¹çš„ç‹¬ç«‹é›†ï¼Œå¦‚æœæœ€åç‹¬ç«‹é›†ä¸­æœ‰ xxx æ¡è¾¹ï¼Œé‚£ä¹ˆç‚¹çš„ç‹¬ç«‹é›†è‡³å°‘æœ‰ 3nâˆ’2x3n-2x3nâˆ’2x ä¸ªç‚¹ï¼Œè¿™ä¸¤ä¸ªè‡³å°‘æœ‰ä¸€ä¸ª â‰¥n\\ge nâ‰¥nã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; bool a[300005]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); fill(a + 1, a + n * 3 + 1, 0); vector&lt;int> ans; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (!a[u] &amp;&amp; !a[v]) a[u] = a[v] = 1, ans.emplace_back(i); &#125; if (ans.size() >= n) &#123; puts(\"Matching\"); for (int i = 0; i &lt; n; ++i) printf(\"%d \", ans[i]); &#125; else &#123; puts(\"IndSet\"); for (int i = 1, cnt = 0; i &lt;= n * 3 &amp;&amp; cnt &lt; n; ++i) if (!a[i]) printf(\"%d \", i), ++cnt; &#125; putchar('\\n'); &#125; return 0; &#125; F. GCD Groups 2 Portal. å°†ä¸€ä¸ªæ•°åŠ å…¥å…¶ä¸­ä¸€ä¸ªåˆ†ç»„ï¼Œå¦‚æœæœ€å¤§å…¬çº¦æ•°å¯ä»¥å˜å°å°±åŠ ï¼Œå¦åˆ™åŠ å…¥å¦ä¸€ä¸ªã€‚å¤šæ¬¡éšæœºé‡å¤ä¸Šè¿°è¿‡ç¨‹å³å¯å¾—åˆ°æ­£ç¡®ç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int n, a[100005], id[100005], c[100005], g[3]; mt19937 Rand(time(0)); bool solve(void) &#123; c[id[1]] = 1; g[1] = a[id[1]]; c[id[2]] = 2; g[2] = a[id[2]]; for (int i = 3; i &lt;= n; ++i) if (a[id[i]] % g[1] == 0) &#123; c[id[i]] = 2; g[2] = gcd(g[2], a[id[i]]); &#125; else &#123; c[id[i]] = 1; g[1] = gcd(g[1], a[id[i]]); &#125; return g[1] == 1 &amp;&amp; g[2] == 1; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), id[i] = i; for (int op = 1; op &lt;= 100; ++op) &#123; shuffle(id + 1, id + n + 1, Rand); if (solve()) &#123; puts(\"YES\"); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", c[i]); putchar('\\n'); return 0; &#125; &#125; puts(\"NO\"); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"2023 å¹´ 1 æœˆç¬¬ä¸€å‘¨åšé¢˜è®°å½•","slug":"default/åšé¢˜è®°å½•/2023-1-1","date":"2023-01-02T00:00:00.000Z","updated":"2023-01-02T00:00:00.000Z","comments":true,"path":"d916a9d1/","link":"","permalink":"https://james1badcreeper.github.io/d916a9d1/","excerpt":"çœé€‰è®¡åˆ’å¼ºè¿«æˆ‘ä»¬å¿…é¡»åšè¿™ä¸ªï¼Œè¿™æ˜¯ä¸ºäº†å®Œæˆä½œä¸šçš„æ— å¥ˆä¹‹ä¸¾ã€‚","text":"çœé€‰è®¡åˆ’å¼ºè¿«æˆ‘ä»¬å¿…é¡»åšè¿™ä¸ªï¼Œè¿™æ˜¯ä¸ºäº†å®Œæˆä½œä¸šçš„æ— å¥ˆä¹‹ä¸¾ã€‚ è¿‡äºç®€å•çš„é¢˜å°±ä¸å†™äº†ã€‚ ARC ç³»åˆ— æ—©æœŸçš„ 4 é¢˜åœºï¼ˆå…¶å®å½“æ—¶æ˜¯å’Œ ABC å’Œåœºï¼‰å’Œç°ä»£çš„ 6 é¢˜åœºéƒ½ä¼šåšã€‚ ARC 102 (4) Portal. A. Triangular Relationshipï¼ˆè‡ªè¡Œåšå‡ºï¼‰ Portal. å‘ç° nnn ä¸å¤§ï¼Œå› æ­¤è€ƒè™‘æšä¸¾ aaaã€‚ä¸‰å…ƒç»„åº”è¯¥å½¢å¦‚ (i,pkâˆ’i,qkâˆ’i)(i,pk-i,qk-i)(i,pkâˆ’i,qkâˆ’i) çš„å½¢å¼ï¼Œè‹¥æ»¡è¶³ b+c=(p+q)kâˆ’2ib+c=(p+q)k-2ib+c=(p+q)kâˆ’2i æ˜¯ kkk çš„å€æ•°ï¼Œåˆ™éœ€è¦ 2i2i2i æ˜¯ kkk çš„å€æ•°ï¼Œæ»¡è¶³è¿™ä¸€æ¡ä»¶æ—¶ï¼Œç»Ÿè®¡ ppp çš„æ•°é‡å¹¶å¹³æ–¹å°±æ˜¯æ­¤æ—¶ iii å¯¹åº”çš„ç­”æ¡ˆæ•°ã€‚ppp åº”æ»¡è¶³ 1â‰¤pkâˆ’iâ‰¤n1\\le pk-i\\le n1â‰¤pkâˆ’iâ‰¤nï¼Œè§£ä¸ç­‰å¼å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, k; long long ans = 0; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) if (2 * i % k == 0) &#123; int cnt = (n + i) / k - (i + k) / k + 1; ans += 1ll * cnt * cnt; &#125; printf(\"%lld\\n\", ans); return 0; &#125; åæ¥çœ‹äº†çœ¼é¢˜è§£ï¼Œå­˜åœ¨ O(1)O(1)O(1) å…¬å¼ï¼Œä¸è¿‡ä¹Ÿä¸éš¾æƒ³ã€‚ B. All Your Paths are Different Lengthsï¼ˆçœ‹äº†çœ¼é¢˜è§£ï¼‰ Portal.ç»™ä½ ä¸€ä¸ªæ•° LLLï¼Œæ„é€ ä¸€ä¸ªæœ‰å‘å›¾ä½¿å¾—ä» 111 åˆ° nnn æ°å¥½æœ‰ LLL æ¡è·¯å¾„ä¸”è·¯å¾„é•¿åº¦æ°å¥½ä¸º 000 åˆ° Lâˆ’1L-1Lâˆ’1ã€‚è¾¹æœ‰è¾¹æƒã€‚ç‚¹æ•°å°äºç­‰äº 202020ï¼Œè¾¹æ•°å°äºç­‰äº 606060ã€‚2â‰¤Lâ‰¤1062\\leq L\\leq 10^62â‰¤Lâ‰¤106ã€‚ å¯ä»¥è”æƒ³åˆ°äºŒè¿›åˆ¶æ‹†åˆ†ã€‚è¿™æ ·ä¹‹åè¿˜æœ‰ä» 2kâˆ¼lâˆ’12^{k}\\sim l-12kâˆ¼lâˆ’1 çš„é•¿åº¦éœ€è¦å¤„ç†ã€‚æˆ‘ä»¬å¯ä»¥è®©å…¶ä»æŸä¸ªç‚¹ç›´æ¥â€œç©¿è¶Šâ€åˆ°ç»ˆç‚¹ï¼Œè¿™æ ·æ˜¯æ²¡æœ‰é‡å¤é•¿è·¯çš„è·¯å¾„çš„ã€‚åªè¦æˆ‘ä»¬æŠŠ lll çš„æ¯ä¸€ä½ 111 éƒ½æå‡ºæ¥ï¼Œâ€œç©¿è¶Šâ€çš„è¾¹è‡ªç„¶ä¹Ÿå°±èƒ½æ±‚å‡ºæ¥äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m, l; int u[65], v[65], w[65]; void add(int x, int y, int d) &#123; u[++m] = x; v[m] = y; w[m] = d; &#125; int main(void) &#123; scanf(\"%d\", &amp;l); int b = 1, t = l - 1; n = 1; while (t >= b) &#123; add(n, n + 1, b); add(n, n + 1, 0); t -= b; b &lt;&lt;= 1; ++n; &#125; for (int i = 0; i &lt; n - 1; ++i) if ((l >> i) &amp; 1) add(i + 1, n, l &amp; ~((1 &lt;&lt; i + 1) - 1)); printf(\"%d %d\\n\", n, m); for (int i = 1; i &lt;= m; ++i) printf(\"%d %d %d\\n\", u[i], v[i], w[i]); return 0; &#125; C. Stop. Otherwiseâ€¦ï¼ˆçœ‹é¢˜è§£ï¼‰ Portal.æœ‰ nnn ä¸ªä¸å¯åŒºåˆ†çš„éª°å­ï¼Œæ¯ä¸ªéª°å­æœ‰ KKK ä¸ªé¢ï¼Œä¸Šé¢æœ‰ 111 åˆ° KKKã€‚æ³¨æ„éª°å­ä¹‹é—´ä¸å¯åŒºåˆ†ï¼Œä¸¤ä¸ªå±€é¢ä¸åŒå½“ä¸”ä»…å½“å­˜åœ¨ä¸€ä¸ªç‚¹æ•° iii ä½¿å¾—æŠ•å‡º iii çš„æ•°é‡ä¸åŒã€‚ç°åœ¨å¯¹äº [2,2K][2,2K][2,2K] ä¸­çš„æ¯ä¸€ä¸ªæ•° xxxï¼Œè¦æ±‚å‡ºä»»æ„æŠ•è¿™ä¸ª nnn ä¸ªéª°å­ä½¿å¾—ä¸å­˜åœ¨ä»»æ„ä¸¤ä¸ªéª°å­çš„ç‚¹æ•°å’Œä¸º xxx çš„æ–¹æ¡ˆæ•°ã€‚n,Kâ‰¤2000n,K\\le 2000n,Kâ‰¤2000ï¼Œç­”æ¡ˆå¯¹ 998244353998244353998244353 å–æ¨¡ã€‚ è€ƒè™‘å¯¹å•ä¸ª xxx å¦‚ä½•æ±‚è§£ã€‚é‚£ä¹ˆå¯¹äºç‚¹æ•° iâˆˆ[1,K]i\\in [1,K]iâˆˆ[1,K]ï¼Œåº”è¯¥æœ‰ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š xâˆ’iâˆˆ[1,K]x-i\\in [1,K]xâˆ’iâˆˆ[1,K]ï¼Œæ­¤æ—¶ iii å’Œ xâˆ’ix-ixâˆ’i è‡³å¤šåªèƒ½å‡ºç°ä¸€ç§ï¼Œç§°ä¸ºè¿™ä¸€å¯¹æ•°æœ€å¤šåªèƒ½å‡ºç°ä¸€ç§ï¼› xâˆ’i=ix-i=ixâˆ’i=i æ—¶ï¼Œè¿™ä¸ª iii åªèƒ½å‡ºç°ä¸€æ¬¡ï¼› xâˆ’iâˆˆÌ¸[1,K]x-i\\not\\in [1,K]xâˆ’iî€ âˆˆ[1,K]ï¼Œè¿™ä¸ª iii çš„å‡ºç°æ— é™åˆ¶ã€‚ è®¾ f(i,j)f(i,j)f(i,j) è¡¨ç¤ºè€ƒè™‘äº† iii å¯¹æ•°ï¼Œå…¶ä¸­é€‰æ‹©äº† jjj ä¸ªæ•°çš„æ–¹æ¡ˆæ•°ï¼›g(i,j)g(i,j)g(i,j) ä»£è¡¨è€ƒè™‘ iii ä¸ªæ²¡æœ‰é™åˆ¶çš„æ•°ï¼Œé€‰æ‹© jjj ä¸ªæ•°çš„æ–¹æ¡ˆæ•°ã€‚é‚£ä¹ˆï¼š f(i,j)=f(iâˆ’1,j)+2Ã—âˆ‘k=0jâˆ’1f(iâˆ’1,k) g(i,j)=âˆ‘k=0jg(iâˆ’1,k)f(i,j)=f(i-1,j)+2\\times \\sum_{k=0}^{j-1} f(i-1,k)\\\\ \\ \\\\ g(i,j)=\\sum_{k=0}^j g(i-1,k) f(i,j)=f(iâˆ’1,j)+2Ã—k=0âˆ‘jâˆ’1â€‹f(iâˆ’1,k) g(i,j)=k=0âˆ‘jâ€‹g(iâˆ’1,k) ç„¶åæšä¸¾æ¯ä¸€ç§é€‰çš„ä¸ªæ•°ï¼Œç»„åˆèµ·æ¥å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 998244353; int k, n; int f[2005][2005], g[2005][2005]; int main(void) &#123; scanf(\"%d%d\", &amp;k, &amp;n); f[0][0] = g[0][0] = 1; for (int i = 1; i &lt;= k; ++i) &#123; i64 s0 = 0; for (int j = 0; j &lt;= n; ++j) &#123; f[i][j] = (f[i - 1][j] + s0 * 2) % MOD; s0 = (s0 + f[i - 1][j]) % MOD; g[i][j] = (g[i - 1][j] + (j > 0 ? g[i][j - 1] : 0)) % MOD; &#125; &#125; for (int x = 2; x &lt;= (k &lt;&lt; 1); ++x) &#123; i64 ans = 0; int c1, c2 = (x % 2 == 0), c3 = 0; for (int i = 1; i &lt;= k; ++i) c3 += (x - i &lt; 1 || x - i > k); c1 = (k - c2 - c3) >> 1; for (int i = 0; i &lt;= n; ++i) &#123; ans = (ans + 1ll * f[c1][i] * g[c3][n - i]) % MOD; if (c2 &amp;&amp; i &lt; n) ans = (ans + 1ll * f[c1][i] * g[c3][n - i - 1]) % MOD; &#125; printf(\"%lld\\n\", ans); &#125; return 0; &#125; D. Revenge of BBuBBBlesort! åˆ°åº•æœ‰å¤šå°‘ä¸ªå†’æ³¡æ’åºå¤ä»‡é¢˜ï¼ Portal. ARC 103 (4) Portal. A. /\\/\\/\\/ï¼ˆè‡ªè¡Œåšå‡ºï¼‰ Portal. å¾ˆæ— èŠï¼Œç›´æ¥ç³Šä¸ªæ’åºä¸Šå»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, ans = 0, a[100001]; struct Node &#123; int id, cnt; bool operator &lt; (const Node &amp;a) const &#123; return cnt > a.cnt; &#125; &#125; b1[100001], b2[100001]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; i++) if (i &amp; 1) b1[a[i]].id = a[i], b1[a[i]].cnt++; else b2[a[i]].id = a[i], b2[a[i]].cnt++; sort(b1 + 1, b1 + 100001); sort(b2 + 1, b2 + 100001); if (b1[1].id != b2[1].id) ans = (n - b1[1].cnt - b2[1].cnt); else ans = min(n - b1[1].cnt - b2[2].cnt, n - b1[2].cnt - b2[1].cnt); printf(\"%d\\n\", ans); return 0; &#125; B. Robot Arms Portal. ABC ç³»åˆ— CF Div.2 ç³»åˆ— Codeforces Round #554 (Div. 2) Portal. C. Neko does Mathsï¼ˆè‡ªè¡Œåšå‡ºï¼‰ Portal. è¦æ±‚çš„æ˜¯ lcm(a+k,b+k)=(a+k)(b+k)gcdâ¡(a+k,b+k)=(a+k)(b+k)gcdâ¡(b+k,aâˆ’b)\\text{lcm}(a+k,b+k)=\\cfrac{(a+k)(b+k)}{\\gcd(a+k,b+k)}=\\cfrac{(a+k)(b+k)}{\\gcd(b+k,a-b)}lcm(a+k,b+k)=gcd(a+k,b+k)(a+k)(b+k)â€‹=gcd(b+k,aâˆ’b)(a+k)(b+k)â€‹ï¼Œé‚£ä¹ˆå‡è®¾ a&gt;ba&gt;ba&gt;bï¼Œgcdâ¡(b+k,aâˆ’b)\\gcd(b+k,a-b)gcd(b+k,aâˆ’b) çš„å€¼ä¸€å®šæ˜¯ aâˆ’ba-baâˆ’b çš„çº¦æ•°ã€‚é‚£ä¹ˆæˆ‘ä»¬æšä¸¾ aâˆ’ba-baâˆ’b çš„çº¦æ•° iii å¹¶è®¡ç®—å‡ºè®© iii æ˜¯ b+kb+kb+k çš„çº¦æ•°çš„æœ€å° kkk å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(aâˆ’b)O(\\sqrt{a-b})O(aâˆ’bâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; long long lcm(int x, int y) &#123; return 1ll * x / gcd(x, y) * y; &#125; int a, b, k; long long ans; int calc(int x) &#123; if (b % x == 0) return 0; return x - b % x; &#125; void upd(int t) &#123; long long tmp = 1ll * (a + t) / gcd(b + t, a - b) * (b + t); if (tmp &lt; ans) ans = tmp, k = t; else if (tmp == ans) k = min(k, t); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;a, &amp;b); if (a &lt; b) swap(a, b); ans = lcm(a, b), k = 0; for (int i = 1; i * i &lt;= a - b; ++i) if ((a - b) % i == 0) &#123; int t = calc(i); upd(t); t = calc((a - b) / i); upd(t); &#125; printf(\"%d\\n\", k); return 0; &#125; D. Neko and Akiâ€™s Prankï¼ˆçœ‹é¢˜è§£ï¼‰ Portal.æœ‰ä¸€ä¸ªç”±æ‰€æœ‰é•¿ä¸º 2n2n2n çš„åˆæ³•æ‹¬å·åºåˆ—ç»„æˆçš„ Trieï¼Œç°åœ¨è¦æ±‚è¿™æ£µæ ‘ä¸Šæœ€å¤šçš„è¾¹æ•°ï¼Œç¬¦åˆè¾¹ä¸¤ä¸¤ä¹‹é—´å‡æ²¡æœ‰å…±åŒèŠ‚ç‚¹ã€‚ æˆ‘ä»¬æ¥çœ‹ n=3n=3n=3 æ—¶å€™çš„ Trie æ ‘ï¼š å®é™…ä¸Šæˆ‘ä»¬åªéœ€è¦è´ªå¿ƒåœ°é€‰æ‹©è¾¹å³å¯é€‰åˆ°æœ€å¤§å€¼ï¼ŒåŸå› å¾ˆç®€å•ï¼Œä¸é€‰æ‹©è¿™ä¸€æ¡è€Œé€‰æ‹©ä¸‹ä¸€æ¡å¹¶ä¸ä¼šä½¿è´¡çŒ®å˜å¤§ã€‚ å¯ä»¥å‘ç°ï¼Œæ‰€æœ‰æ·±åº¦ä¸ºå¶æ•°çš„èŠ‚ç‚¹éƒ½ä¼šè¿æ¥ä¸€æ¡è¾¹ï¼Œæ‰€ä»¥ç°åœ¨çš„é—®é¢˜æˆäº†æ±‚æ·±åº¦ä¸ºå¶æ•°çš„èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚ è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨æœ‰ iii ä¸ªå·¦æ‹¬å·ï¼Œjjj ä¸ªå³æ‹¬å·åœ¨ Trie ä¸Šèƒ½å½¢æˆçš„æ‹¬å·åºåˆ—ä¸ªæ•°ã€‚åˆå§‹ f(0,0)f(0,0)f(0,0)ï¼Œè½¬ç§»æ—¶ï¼Œå¯ä»¥é€‰æ‹©æ·»åŠ ä¸€ä¸ªå·¦æ‹¬å·æˆ–è€…å³æ‹¬å·ï¼Œåªéœ€è¦æ»¡è¶³ jâ‰¤ij\\le ijâ‰¤iï¼Œå› æ­¤ f(i,j)=f(iâˆ’1,j)+f(i,jâˆ’1)f(i,j)=f(i-1,j)+f(i,j-1)f(i,j)=f(iâˆ’1,j)+f(i,jâˆ’1)ã€‚å½“ i+ji+ji+j ä¸ºå¶æ•°æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹åœ¨ Trie ä¸Šçš„æ·±åº¦ä¹Ÿæ˜¯å¶æ•°ï¼ŒåŠ èµ·æ¥å°±æ˜¯ç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 1000000007; int n, ans; int f[1005][1005]; int main(void) &#123; scanf(\"%d\", &amp;n); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; f[i][0] = 1; for (int j = 1; j &lt;= i; ++j) f[i][j] = (f[i - 1][j] + f[i][j - 1]) % MOD; &#125; for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= i; ++j) if ((i + j) &amp; 1) ans = (ans + f[i][j]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; E. Neko and Flashbackï¼ˆçœ‹äº†çœ¼é¢˜è§£ï¼‰ Portal. å¯¹äºä¸€ä¸ª iiiï¼Œæœ‰ bi=minâ¡{ai,ai+1},ci=maxâ¡{ai,ai+1}b_i=\\min\\{a_i,a_{i+1}\\},c_i=\\max\\{a_i,a_{i+1}\\}biâ€‹=min{aiâ€‹,ai+1â€‹},ciâ€‹=max{aiâ€‹,ai+1â€‹}ï¼Œä¹Ÿå°±æ˜¯è¯´ bi,cib_i,c_ibiâ€‹,ciâ€‹ å„æ˜¯ ai,ai+1a_i,a_{i+1}aiâ€‹,ai+1â€‹ å…¶ä¸­çš„ä¸€ä¸ªï¼ˆå½“ç„¶éœ€è¦ biâ‰¤cib_i\\le c_ibiâ€‹â‰¤ciâ€‹ï¼Œå¦åˆ™æ— è§£ï¼‰ã€‚ æ³¨æ„è¿™ä¸ªè¾“å‡ºæ–¹å¼ï¼Œppp çš„ä½œç”¨æ˜¯å°† aaa æ’åˆ—ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åªéœ€è¦æ±‚å‡º aaa æœ‰å“ªäº›æ•°ç»„æˆå³å¯ã€‚å°†ç»™å®šçš„ ai,ai+1a_i,a_{i+1}aiâ€‹,ai+1â€‹ çš„å…³ç³»çœ‹æˆä¸€æ¡æ— å‘è¾¹ï¼Œèµ°è¿‡è¿™ä¸ªè·¯å¾„å°±ç›¸å½“äºæ»¡è¶³äº†ä¸€ä¸ªé™åˆ¶æ¡ä»¶ã€‚é‚£ä¹ˆåœ¨å›¾ä¸Šæ‰¾å‡ºæ¬§æ‹‰è·¯ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªæ»¡è¶³æ‰€æœ‰çš„é™åˆ¶æ¡ä»¶çš„åºåˆ— aaaï¼ˆéœ€è¦å…ˆç¦»æ•£åŒ–åå†å»ºå›¾ï¼‰ã€‚æ—¶é—´å¤æ‚åº¦ O((n+m)logâ¡m)O((n+m)\\log m)O((n+m)logm)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> using namespace std; int n, tot, cur[100005], deg[200005], st[200005]; int b[100005], c[100005], B[200005]; vector&lt;int> edges; vector&lt;int> G[200005]; inline void addedge(int u, int v) &#123; edges.emplace_back(v); G[u].emplace_back(edges.size() - 1); ++deg[v]; &#125; void dfs(int x) &#123; for (; cur[x] &lt; G[x].size(); ++cur[x]) &#123; int y = edges[G[x][cur[x]]]; if (y) &#123; edges[G[x][cur[x]]] = 0, edges[G[x][cur[x]] ^ 1] = 0; dfs(y); &#125; &#125; st[++tot] = x; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) scanf(\"%d\", b + i), B[++tot] = b[i]; for (int i = 1; i &lt; n; ++i) scanf(\"%d\", c + i), B[++tot] = c[i]; sort(B + 1, B + tot + 1); tot = unique(B + 1, B + tot + 1) - (B + 1); for (int i = 1; i &lt; n; ++i) &#123; b[i] = lower_bound(B + 1, B + tot + 1, b[i]) - B; c[i] = lower_bound(B + 1, B + tot + 1, c[i]) - B; if (b[i] > c[i]) return puts(\"-1\"), 0; addedge(b[i], c[i]); addedge(c[i], b[i]); &#125; int cnt = 0, h = 0; for (int i = 1; i &lt;= tot; ++i) if (deg[i] &amp; 1) &#123; ++cnt; if (!h) h = i; &#125; if (cnt == 1 || cnt > 2) return puts(\"-1\"), 0; tot = 0; dfs(h ? h : 1); if (tot != n) return puts(\"-1\"), 0; for (int i = tot; i >= 1; --i) printf(\"%d \", B[st[i]]); putchar('\\n'); return 0; &#125; CF Div.1 ç³»åˆ— åŒ…æ‹¬å’Œåœºã€‚ Codeforces Round #639 (Div. 1) Portal. A. Hilbertâ€™s Hotelï¼ˆè‡ªè¡Œåšå‡ºï¼‰ Portal. å½“å­˜åœ¨ i+aii+a_ii+aiâ€‹ ä½™æ•°ç›¸åŒæ—¶ï¼Œå°±æœ‰é—®é¢˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;map> using namespace std; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, x; scanf(\"%d\", &amp;n); map&lt;int, int> s; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;x), s[((x + i) % n + n) % n]++; bool flag = true; for (auto x : s) if (x.second >= 2) &#123; flag = false; break; &#125; puts(flag ? \"YES\" : \"NO\"); &#125; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"æ•°æ®ç»“æ„çš„å¸¸ç”¨ç»´æŠ¤æ–¹æ³•","slug":"notes/DS/ds-tricks","date":"2023-01-02T00:00:00.000Z","updated":"2023-01-02T00:00:00.000Z","comments":true,"path":"8cb451a5/","link":"","permalink":"https://james1badcreeper.github.io/8cb451a5/","excerpt":"åœ¨å¤„ç†ä¸€äº›æ•°æ®ç»“æ„é—®é¢˜æ—¶æœ‰ä¸€äº›ç»å…¸æ¨¡å‹å’Œå¸¸ç”¨æ‰‹æ®µï¼Œè¿˜æœ‰ä¸€äº›æ¯”è¾ƒå°‘è§çš„å®ç”¨æ•°æ®ç»“æ„ï¼Œæœ¬æ–‡ä¼šç®€å•ä»‹ç»ã€‚","text":"åœ¨å¤„ç†ä¸€äº›æ•°æ®ç»“æ„é—®é¢˜æ—¶æœ‰ä¸€äº›ç»å…¸æ¨¡å‹å’Œå¸¸ç”¨æ‰‹æ®µï¼Œè¿˜æœ‰ä¸€äº›æ¯”è¾ƒå°‘è§çš„å®ç”¨æ•°æ®ç»“æ„ï¼Œæœ¬æ–‡ä¼šç®€å•ä»‹ç»ã€‚ ä¸»è¦æ˜¯å­˜æ”¾ä¸€äº›æ— å¤„å®‰æ”¾çš„å’Œç»¼åˆå†…å®¹ã€‚ é¢œè‰²æ®µå‡æ‘Š ç»´æŠ¤åºåˆ—æ—¶ï¼Œä¸€ä¸ªç»å…¸çš„æ“ä½œæ˜¯åŒºé—´æŸ“è‰²ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ä½¿ç”¨å¹³è¡¡æ ‘äº†æ¥ç»´æŠ¤åŒºé—´çš„é¢œè‰²è¿ç»­æ®µã€‚åŒºé—´æŸ“è‰²æ¯æ¬¡æœ€å¤šåªä¼šå¢åŠ å‡æ‘Š O(1)O(1)O(1) ä¸ªé¢œè‰²æ®µã€‚ ç‚æœµè‰æ ‘ æ¨¡æ¿ã€‚ç»´æŠ¤ä¸€ä¸ªåºåˆ—ï¼Œæ”¯æŒåŒºé—´åŠ ï¼ŒåŒºé—´æŸ“è‰²ï¼ŒåŒºé—´ kkk å°æŸ¥è¯¢ï¼ŒåŒºé—´æ¯ä¸ªæ•°çš„ xxx æ¬¡æ–¹çš„å’Œæ¨¡ yyy çš„å€¼ã€‚ä½¿ç”¨æ•°æ®ç”Ÿæˆå™¨ç”Ÿæˆæ•°æ®ï¼ˆæ•°æ®éšæœºï¼‰ã€‚ è¯¢é—®çš„å†…å®¹éå¸¸è¯¡å¼‚ï¼Œä¸æ˜¯ä¼ ç»Ÿæ ‘å¥—æ ‘å¯ä»¥æ”¯æŒçš„æ“ä½œã€‚è¿™é‡Œæˆ‘ä»¬ä»‹ç»ç‚æœµè‰æ ‘ï¼ˆODTï¼Œä¸¥æ ¼æ„ä¹‰ä¸Šæ˜¯ä¸€ç§æ€æƒ³ï¼‰ï¼Œåˆ©ç”¨ä¸€ä¸ª set å­˜å‚¨æ‰€ç”¨çš„é¢œè‰²æ®µï¼Œç„¶åè¿›è¡Œæš´åŠ›æ“ä½œã€‚ æ ¸å¿ƒæ•°æ®ç»“æ„å¦‚ä¸‹å®šä¹‰ï¼š struct Node &#123; int l, r; mutable i64 v; // è¿™ä¸ª v æ¥ä¸‹æ¥éœ€è¦ä¿®æ”¹ Node(int l = 0, int r = 0, i64 v = 0) : l(l), r(r), v(v) &#123;&#125; bool operator &lt; (const Node &amp;a) const &#123; return l &lt; a.l; &#125; &#125;; set&lt;Node> T; æœ€ä¸ºå…³é”®çš„æ˜¯ split æ“ä½œï¼Œå…¶ä½œç”¨æ˜¯å°† lll å¼€å§‹çš„é¢œè‰²æ®µå•ç‹¬åˆ†è£‚å‡ºæ¥ï¼Œå¹¶è¿”å›è¿™ä¸€ä¸ªé¢œè‰²æ®µçš„æŒ‡é’ˆã€‚ auto split(int p) &#123; auto it = T.lower_bound(Node(p)); if (it != T.end() &amp;&amp; it->l == p) return it; --it; int l = it->l, r = it->r; i64 v = it->v; T.erase(it); T.insert(Node(l, p - 1, v)); return T.insert(Node(p, r, v)).first; &#125; å½“æˆ‘ä»¬è¦å–å‡ºä¸€æ®µåŒºé—´æ—¶ï¼Œä¸€å®šè¦å…ˆ split(r + 1)ï¼Œå† split(l)ï¼Œå¦åˆ™å¯èƒ½ REã€‚å–å‡ºé¢œè‰²æ®µåç›´æ¥æš´åŠ›æ“ä½œå³å¯ã€‚ åœ¨æ•°æ®éšæœºçš„æƒ…å†µä¸‹ï¼ŒæœŸæœ›å¤æ‚åº¦æ˜¯ O(nlogâ¡logâ¡n)O(n\\log \\log n)O(nloglogn) çš„ã€‚ä½†æ˜¯ç”±äºç°åœ¨åŸºæœ¬ä¸Šéƒ½å¡ï¼Œæ‰€ä»¥å‡ºç°åŒºé—´æŸ“è‰²æ“ä½œæ—¶å°½é‡å¾€åŠ¿èƒ½ä¸Šæƒ³ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, seed, vmax; int rnd(void) &#123; int ret = seed; seed = (1ll * seed * 7 + 13) % 1000000007; return ret; &#125; i64 poww(i64 a, int b, int p) &#123; a %= p; i64 res = 1; for (; b; b >>= 1, a = 1ll * a * a % p) if (b &amp; 1) res = 1ll * res * a % p; return res; &#125; struct Node &#123; int l, r; mutable i64 v; Node(int l = 0, int r = 0, i64 v = 0) : l(l), r(r), v(v) &#123;&#125; bool operator &lt; (const Node &amp;a) const &#123; return l &lt; a.l; &#125; &#125;; set&lt;Node> T; auto split(int p) &#123; auto it = T.lower_bound(Node(p)); if (it != T.end() &amp;&amp; it->l == p) return it; --it; int l = it->l, r = it->r; i64 v = it->v; T.erase(it); T.insert(Node(l, p - 1, v)); return T.insert(Node(p, r, v)).first; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;seed, &amp;vmax); for (int i = 1; i &lt;= n; ++i) T.insert(Node(i, i, rnd() % vmax + 1)); int op, l, r, x, y; while (m--) &#123; op = rnd() % 4 + 1, l = rnd() % n + 1, r = rnd() % n + 1; if (l > r) swap(l, r); if (op == 3) x = rnd() % (r - l + 1) + 1; else x = rnd() % vmax + 1; if (op == 4) y = rnd() % vmax + 1; if (op == 1) &#123; auto R = split(r + 1), L = split(l); for (auto i = L; i != R; ++i) i->v += x; &#125; else if (op == 2) &#123; auto R = split(r + 1), L = split(l); T.erase(L, R); T.insert(Node(l, r, x)); &#125; else if (op == 3) &#123; auto R = split(r + 1), L = split(l); vector&lt;pair&lt;i64, int>> v; for (auto i = L; i != R; ++i) v.push_back(&#123;i->v, i->r - i->l + 1&#125;); sort(v.begin(), v.end()); for (int i = 0; i &lt; v.size(); ++i) &#123; if (v[i].second &lt; x) x -= v[i].second; else &#123; printf(\"%lld\\n\", v[i].first); break; &#125; &#125; &#125; else &#123; auto R = split(r + 1), L = split(l); i64 ans = 0; for (auto i = L; i != R; ++i) ans = (ans + poww(i->v, x, y) * (i->r - i->l + 1)) % y; printf(\"%lld\\n\", ans); &#125; &#125; return 0; &#125; åŠ¿èƒ½çº¿æ®µæ ‘ è¿˜è®°å¾—èŠ±ç¥æ¸¸å†å„å›½ï¼ˆåŒºé—´å¼€æ–¹åŒºé—´å’Œï¼‰å—ï¼Ÿå®ƒçš„ä¿®æ”¹éå¸¸æš´åŠ›ï¼Œä½†æ˜¯å¤æ‚åº¦æ˜¯æ­£ç¡®çš„ã€‚ ç”±äºåŒºé—´æŸ“è‰²æ¯æ¬¡æœ€å¤šåªä¼šå¢åŠ å‡æ‘Š O(1)O(1)O(1) ä¸ªé¢œè‰²æ®µï¼Œå› æ­¤å¯ä»¥è€ƒè™‘ä½¿ç”¨çº¿æ®µæ ‘æš´åŠ›ç»´æŠ¤ã€‚ [CF444C] DZY Loves Colors.æœ‰ä¸€ä¸ª nnn ä¸ªå…ƒç´ ç»„æˆçš„åºåˆ—ï¼Œæ¯ä¸ªå…ƒç´ æœ‰ä¸¤ä¸ªå±æ€§ï¼šé¢œè‰² cic_iciâ€‹ å’Œæƒå€¼ wiw_iwiâ€‹ã€‚cic_iciâ€‹ åˆå§‹ä¸º iiiï¼Œwiw_iwiâ€‹ åˆå§‹ä¸º 000ã€‚mmm æ¬¡æ“ä½œï¼Œæ“ä½œæœ‰ä¸¤ç§ï¼š1 l r xï¼šå¯¹ iâˆˆ[l,r]i\\in [l,r]iâˆˆ[l,r] çš„æ‰€æœ‰ iii è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼šè®¾ç¬¬ iii ä¸ªå…ƒç´  åŸæ¥ çš„é¢œè‰²ä¸º yyyï¼Œæ‚¨è¦æŠŠç¬¬ iii ä¸ªå…ƒç´ çš„é¢œè‰²æ”¹ä¸º xxxï¼Œæƒå€¼ å¢åŠ  âˆ£yâˆ’xâˆ£|y-x|âˆ£yâˆ’xâˆ£ã€‚2 l rï¼šæ±‚ âˆ‘i=lrwi\\sum\\limits_{i=l}^r w_ii=lâˆ‘râ€‹wiâ€‹ã€‚1â‰¤n,mâ‰¤1051\\le n,m\\le 10^51â‰¤n,mâ‰¤105ï¼Œ1â‰¤xâ‰¤1081\\le x\\le 10^81â‰¤xâ‰¤108ã€‚ æˆ‘ä»¬è®°ä¸€ä¸ª ccc ä»£è¡¨åŒºé—´é¢œè‰²ï¼Œä¸ä¸€æ ·æ—¶è®°ä¸º âˆ’1-1âˆ’1ã€‚å¦‚æœä¸€æ ·åˆ™æ‰“æ ‡è®°ä¿®æ”¹ï¼Œä¸ä¸€æ ·åˆ™æš´åŠ›é€’å½’ä¿®æ”¹ã€‚ä¸€æ¬¡åŒºé—´æŸ“è‰²åªä¼šäº§ç”Ÿä¸¤ä¸ªæ–°çš„ç«¯ç‚¹ï¼Œæš´åŠ›æŸ¥è¯¢çš„æ¬¡æ•°ä¸º O(n+m)O(n+m)O(n+m) çº§åˆ«ã€‚å› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º O((n+m)logâ¡n)O((n+m)\\log n)O((n+m)logn)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, a[100005]; struct Node &#123; int c; i64 w, t; // åŒºé—´æ˜¯å¦ä¸ºåŒä¸€é¢œè‰² cï¼ˆä¸åŒ c = -1ï¼‰ï¼ŒåŒºé—´å’Œ wï¼Œç´¯åŠ é¢œè‰²æ”¹å˜å€¼ t bool tag; // åŒºé—´ set æ ‡è®° tag #define ls o &lt;&lt; 1 #define rs ls | 1 &#125; T[400005]; void pushup(int o) &#123; if (T[ls].c == T[rs].c &amp;&amp; T[ls].c != -1) T[o].c = T[ls].c; else T[o].c = -1; T[o].w = T[ls].w + T[rs].w; &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o].c = l, T[o].w = 0, void(); int mid = l + r >> 1; build(ls, l, mid); build(rs, mid + 1, r); pushup(o); &#125; void pushdown(int o, int l, int r) &#123; if (!T[o].tag) return; int mid = l + r >> 1; T[o &lt;&lt; 1].w += (mid - l + 1) * T[o].t; T[o &lt;&lt; 1 | 1].w += (r - mid) * T[o].t; T[o &lt;&lt; 1].c = T[o &lt;&lt; 1 | 1].c = T[o].c; T[o &lt;&lt; 1].tag = T[o &lt;&lt; 1 | 1].tag = 1; T[o &lt;&lt; 1].t += T[o].t; T[o &lt;&lt; 1 | 1].t += T[o].t; T[o].tag = T[o].t = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; T[o].c != -1) &#123; T[o].t += abs(k - T[o].c); T[o].w += 1ll * (r - l + 1) * abs(k - T[o].c); T[o].c = k; T[o].tag = 1; return; &#125; int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(ls, l, mid, x, y, k); if (mid &lt; y) update(rs, mid + 1, r, x, y, k); pushup(o); &#125; i64 query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].w; int mid = l + r >> 1; i64 res = 0; pushdown(o, l, r); if (x &lt;= mid) res += query(ls, l, mid, x, y); if (mid &lt; y) res += query(rs, mid + 1, r, x, y); return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); build(1, 1, n); while (m--) &#123; int op, l, r, x; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) &#123; scanf(\"%d\", &amp;x); update(1, 1, n, l, r, x); &#125; else printf(\"%lld\\n\", query(1, 1, n, l, r)); &#125; return 0; &#125; æ‰«æçº¿ æ‰«æçº¿å…·æœ‰éå¸¸å¹¿æ³›çš„åº”ç”¨ã€‚å°±æ˜¯ä¸€æ ¹æ¨ªç€æˆ–è€…ç«–ç€çš„çº¿æ²¿ç€ä¸€ä¸ªæ–¹å‘è¿›è¡Œæ‰«æï¼Œå¹¶åˆ©ç”¨æ•°æ®ç»“æ„ï¼ˆæ¯”å¦‚çº¿æ®µæ ‘ï¼‰ç»Ÿè®¡ä¿¡æ¯ã€‚ äºŒç»´æ•°ç‚¹é—®é¢˜ æ¨¡æ¿ã€‚ç»™å®šäºŒç»´å¹³é¢ä¸Šçš„ nnn ä¸ªæ•´ç‚¹ï¼Œå¤šæ¬¡è¯¢é—®ä¸€ä¸ªçŸ©å½¢ä¸­ç‚¹çš„ä¸ªæ•°ã€‚ æˆ‘ä»¬è®° S(x,y)S(x,y)S(x,y) ä»£è¡¨ (0,0),(x,y)(0,0),(x,y)(0,0),(x,y) æ„æˆçš„çŸ©å½¢ä¸­ç‚¹çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆè¯¢é—® (a,b),(c,d)(a,b),(c,d)(a,b),(c,d) çš„ç­”æ¡ˆæ˜¯ï¼šS(c,d)âˆ’S(aâˆ’1,d)âˆ’S(c,bâˆ’1)+S(aâˆ’1,bâˆ’1)S(c,d)-S(a-1,d)-S(c,b-1)+S(a-1,b-1)S(c,d)âˆ’S(aâˆ’1,d)âˆ’S(c,bâˆ’1)+S(aâˆ’1,bâˆ’1)ã€‚ æˆ‘ä»¬å°†å¾—åˆ°çš„è¯¢é—®æŒ‰ç…§ xxx æ’åºï¼Œç„¶åæ”¾ä¸€æ ¹æ‰«æçº¿ä»å·¦åˆ°å³è¿›è¡Œæ‰«æï¼Œå°†ç‚¹åŠ å…¥æ ‘çŠ¶æ•°ç»„ï¼Œå¹¶è¿›è¡Œç»Ÿè®¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, ans[500005], b[2000005], C[2000005], p = 0; struct Node &#123; int x, y, type, id; bool operator&lt; (const Node &amp;a) const &#123; if (x == a.x) return type &lt; a.type; return x &lt; a.x; &#125; &#125; a[3000005]; #define lowbit(x) (x &amp; -x) void add(int x, int k) &#123; for (; x &lt;= p; x += lowbit(x)) C[x] += k; &#125; int query(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); ++a[i].x; ++a[i].y; a[i].type = 1; b[++p] = a[i].y; &#125; int tot = n; for (int i = 1; i &lt;= m; ++i) &#123; int x, y, _x, _y; scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;_x, &amp;_y); ++x; ++y; ++_x; ++_y; b[++p] = y - 1; b[++p] = _y; a[++tot] = &#123;_x, _y, 3, i&#125;; a[++tot] = &#123;x - 1, y - 1, 3, i&#125;; a[++tot] = &#123;_x, y - 1, 2, i&#125;; a[++tot] = &#123;x - 1, _y, 2, i&#125;; &#125; sort(a + 1, a + tot + 1); sort(b + 1, b + p + 1); p = unique(b + 1, b + p + 1) - (b + 1); for (int i = 1; i &lt;= tot; ++i) &#123; a[i].y = lower_bound(b + 1, b + p + 1, a[i].y) - b; if (a[i].type == 1) add(a[i].y, 1); else if (a[i].type == 2) ans[a[i].id] -= query(a[i].y); else ans[a[i].id] += query(a[i].y); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; çŸ©å½¢é¢ç§¯å¹¶ æ¨¡æ¿ã€‚æ±‚ nnn ä¸ªçŸ©å½¢çš„é¢ç§¯å¹¶ã€‚ æˆ‘ä»¬æŠŠè¿™äº›çŸ©å½¢æ”¾åœ¨å¹³é¢ç›´è§’åæ ‡ç³»ä¸­ï¼Œç„¶åæ‰‹æ¡ä¸€æ ¹ç«–ç›´çš„çº¿çº¿ï¼ˆå½“ç„¶ä½ ä¹Ÿå¯ä»¥æ¡ç€ä¸€æ¡æ¨ªçš„ä¸Šä¸‹æ‰«ï¼Œæˆ‘ä»¬æŠŠå®ƒç§°ä¹‹ä¸ºæ‰«æçº¿ï¼Œä»å·¦åˆ°å³æ‰«è¿‡æ•´ä¸ªåæ ‡ç³»ï¼Œåœ¨è¿™æ¡æ‰«æçº¿ä¸Šè¦†ç›–çš„å›¾å½¢é•¿åº¦åªæœ‰åœ¨æ¯ä¸ªçŸ©å½¢çš„å·¦å³è¾¹ç•Œå¤„ä¼šå˜åŒ–ã€‚ å›¾ç‰‡æ¥è‡ª https://www.luogu.com.cn/blog/happy404/solution-p5490ï¼Œå¯ä»¥çœ‹åˆ°åœ¨æ‰«å¹¶èµ·æ¥çš„çŸ©å½¢æ—¶è¦†ç›–çš„é•¿åº¦å˜åŒ– ä¹Ÿå°±æ˜¯è¯´ï¼Œæ•´ä¸ªå›¾å½¢å¯ä»¥è¢«åˆ†ä¸º nÃ—2n\\times 2nÃ—2 æ®µï¼ˆæ¯åˆ°ä¸€ä¸ªçŸ©å½¢çš„ä¸¤è¾¹é•¿åº¦å°±éœ€è¦æ”¹å˜ï¼‰ï¼Œæ¯ä¸€æ®µè¦†ç›–çš„é•¿åº¦ LLL æ˜¯å›ºå®šçš„ï¼ˆæ‰«æè¿™ä¸€æ®µæ—¶çš„é•¿åº¦ä¸å˜ï¼‰ï¼Œè¿™æ ·å°±å¯ä»¥ä½¿ç”¨å¹¼å„¿å›­æ•°å­¦æ±‚è§£è¿™ä¸€æ®µçš„çŸ©å½¢é¢ç§¯ï¼šLÃ—è¯¥æ®µçš„å®½åº¦L\\times è¯¥æ®µçš„å®½åº¦LÃ—è¯¥æ®µçš„å®½åº¦ã€‚ å®ç°ä¸Šï¼Œæˆ‘ä»¬å–å‡º nnn ä¸ªçŸ©å½¢çš„å·¦å³è¾¹ç•Œï¼Œå¦‚æœä¸€ä¸ªçŸ©å½¢çš„ä¸¤ä¸ªå¯¹è§’é¡¶ç‚¹åæ ‡åˆ†åˆ«ä¸º (x1,y1),(x2,y2),x1&lt;x2,y1&lt;y2(x_1,y_1),(x_2,y_2),x_1&lt;x_2,y_1&lt;y_2(x1â€‹,y1â€‹),(x2â€‹,y2â€‹),x1â€‹&lt;x2â€‹,y1â€‹&lt;y2â€‹ï¼Œé‚£ä¹ˆå·¦è¾¹ç•Œä¸º (x1,y1,y2,1)(x_1,y_1,y_2,1)(x1â€‹,y1â€‹,y2â€‹,1)ï¼Œå³è¾¹ç•Œä¸º (x2,y1,y2,âˆ’1)(x_2,y_1,y_2,-1)(x2â€‹,y1â€‹,y2â€‹,âˆ’1)ï¼Œå››ä¸ªæ•°åˆ†åˆ«ä»£è¡¨ xxx åæ ‡ï¼Œyyy åæ ‡ä¸Šç•Œï¼Œyyy åæ ‡ä¸‹ç•Œï¼Œå¯¹ä»¥åçš„é¢ç§¯æ˜¯åŠ  111 è¿˜æ˜¯å‡ 111ï¼ˆç±»ä¼¼å·®åˆ†ï¼‰ã€‚ç°åœ¨å°†è¿™ 2n2n2n ä¸ªå››å…ƒç»„æŒ‰ç…§ xxx ä»å°åˆ°å¤§çš„é¡ºåºæ’åºã€‚è¿™å°±ç›¸å½“äºç»™äº†æˆ‘ä»¬ 2n2n2n ä¸ªåŒºé—´åŠ çš„æ“ä½œï¼Œä½†æ˜¯ yyy çš„èŒƒå›´å¾ˆå¤§ï¼Œæ‰€ä»¥éœ€è¦ç¦»æ•£åŒ–åæ‰èƒ½å®Œæˆï¼Œè€ŒåŒºé—´åŠ å°±æ˜¯å…¸å‹çš„çº¿æ®µæ ‘æ“ä½œäº†ã€‚ å®ç°çš„æ—¶å€™æœ‰ä¸€ç‚¹ç»†èŠ‚ï¼š æˆ‘ä»¬ä¸éœ€è¦ pushdownï¼Œå› ä¸ºæˆ‘ä»¬åªæŸ¥æ€»åŒºé—´ï¼Œåªéœ€è¦è¿”å› T[1] å³å¯ï¼Œå…¶ä½™èŠ‚ç‚¹å°±è®©å®ƒè‡ªç”Ÿè‡ªç­å°±è¡Œäº†ã€‚ åœ¨ä¿®æ”¹çš„æ—¶å€™ y2y_2y2â€‹ è¦å‡å» 111ï¼Œå› ä¸ºç»™çš„æ˜¯ç‚¹ï¼Œæˆ‘ä»¬æƒ³è¦è¦†ç›–ï¼Œä»¤ yyy è¦†ç›–çš„æ˜¯ [y,y+1][y,y+1][y,y+1]ï¼Œé‚£ä¹ˆä½œä¸ºä¸Šé¢çš„ y2y_2y2â€‹ å°±éœ€è¦å‡å» 111ã€‚ è¿™é‡Œçš„æ ‡è®°å¾ˆç‰¹æ®Šï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ª flag æ¥è®°å½•ï¼Œå½“å®ƒæ˜¯æ­£æ•°çš„æ—¶å€™è¯´æ˜è¢«è¦†ç›–äº†ï¼Œè¿™æ—¶å€™å°±ç›´æ¥èµ‹å€¼ä¸ºå¯¹åº”çš„åŒºé—´æ‰€å¯¹åº”çš„å€¼ï¼Œå¦‚æœæ²¡æœ‰è¢«è¦†ç›–å°±æ˜¯å·¦å³å„¿å­çš„å’Œã€‚è€Œä¸”å®ƒåœ¨æ’åºåè¿›è¡Œæ‰«æï¼Œåªå¯èƒ½æ˜¯ä¸€ä¸ªè‡ªç„¶æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct line &#123; int x, yl, yh, flag; line(int x = 0, int yl = 0, int yh = 0, int flag = 0) : x(x), yl(yl), yh(yh), flag(flag) &#123;&#125; bool operator &lt; (const line &amp;a) const &#123; return x &lt; a.x; &#125; &#125; e[2000005]; int n, m; int b[2000005], raw[2000005], tag[8000005]; i64 T[8000005]; void maintain(int o, int l, int r) &#123; if (tag[o]) T[o] = raw[r + 1] - raw[l]; else T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] += k, maintain(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); maintain(o, l, r); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x, y, _x, _y; i &lt;= n; ++i) &#123; scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;_x, &amp;_y); e[(i &lt;&lt; 1) - 1] = line(x, y, _y, 1); e[i &lt;&lt; 1] = line(_x, y, _y, -1); b[(i &lt;&lt; 1) - 1] = y, b[i &lt;&lt; 1] = _y; &#125; n &lt;&lt;= 1; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) &#123; int pos1 = lower_bound(b + 1, b + m + 1, e[i].yl) - b; int pos2 = lower_bound(b + 1, b + m + 1, e[i].yh) - b; raw[pos1] = e[i].yl, raw[pos2] = e[i].yh; e[i].yl = pos1, e[i].yh = pos2; &#125; sort(e + 1, e + n + 1); i64 ans = 0; for (int i = 1; i &lt; n; ++i) &#123; update(1, 1, m - 1, e[i].yl, e[i].yh - 1, e[i].flag); ans += T[1] * (e[i + 1].x - e[i].x); &#125; printf(\"%lld\\n\", ans); return 0; &#125; å®é™…ä¸Šæ‰«æçº¿è¿˜å¯ä»¥ç”¨åœ¨æ›´å¤æ‚çš„å‡ ä½•é—®é¢˜ä¸Šï¼Œæ¯”å¦‚åœ†çš„é¢ç§¯å¹¶å’Œä¸‰è§’å½¢é¢ç§¯å¹¶ï¼Œè¯·å‚è€ƒç¬”è€…æœ‰å…³è®¡ç®—å‡ ä½•çš„æ–‡ç« ã€‚ æ‰«æçº¿æœ¬è´¨ æ¯”å¦‚å¾ˆå¤šé—®é¢˜ä¸­éƒ½å­˜åœ¨äºŒç»´æ•°ç‚¹çš„æ¨¡å‹ï¼Œæ¯”å¦‚è¯¢é—®ä¸¤æ£µå­æ ‘å†…æ˜¯å¦æœ‰å…±åŒç¼–å·çš„èŠ‚ç‚¹ï¼Œå¯ä»¥å°†ä¸€æ£µå­æ ‘çœ‹ä½œæ—¶é—´ç»´ï¼ˆæ‰«æçº¿æ‰«è¿™ä¸ªï¼‰ï¼Œç„¶åä½¿ç”¨æ•°æ®ç»“æ„æ¥ç»´æŠ¤åºåˆ—ç»´ï¼ˆå¦ä¸€æ£µå­æ ‘ï¼‰ã€‚ å½“ç„¶è¿™ä¸ªé—®é¢˜ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸»å¸­æ ‘åœ¨çº¿è§£å†³ï¼Œåˆ©ç”¨å¯æŒä¹…åŒ–çš„æ€§è´¨æ¥ç»´æŠ¤æ—¶é—´ç»´ï¼Œçº¿æ®µæ ‘ç»´æŠ¤åºåˆ—ç»´ã€‚ æ‰«æçº¿ç¦»çº¿è¿˜æ˜¯æœ€é€šç”¨çš„åšæ³•ï¼Œå› ä¸ºå®ƒå¯ä»¥é€‚é…æ‰€æœ‰æ•°æ®ç»“æ„ã€‚ ç„¶è€Œæ‰«æçº¿ä¹Ÿå¯ä»¥æ‰«åºåˆ—ç»´ï¼Œç”¨æ•°æ®ç»“æ„æ¥ç»´æŠ¤æ—¶é—´ç»´ã€‚ çº¿æ®µæ ‘çš„è¿›é˜¶ç”¨æ³• çº¿æ®µæ ‘æ˜¯åŠŸèƒ½éå¸¸å¼ºå¤§çš„æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€äº›å®ƒçš„å˜ç§ã€‚ æè¶…çº¿æ®µæ ‘ è€ƒè™‘è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼šåŠ å…¥ç»™å®šå®šä¹‰åŸŸçš„ä¸€æ¬¡å‡½æ•°ï¼ŒæŸ¥è¯¢ x=kx=kx=k æ—¶çš„æœ€å¤§å€¼ã€‚ æ€ä¹ˆåšï¼Ÿè€ƒè™‘ä¸€ç§çº¿æ®µæ ‘ï¼Œç»´æŠ¤ [l,r][l,r][l,r] çš„èŠ‚ç‚¹åªå­˜å‚¨ä¸€ä¸ª midmidmid å¤„å€¼æœ€å¤§çš„çº¿æ®µã€‚ä¿®æ”¹æ“ä½œå¦‚ä½•å®ç°å‘¢ï¼Ÿå¦‚æœä¿®æ”¹çš„çº¿æ®µä¸æ¯”å½“å‰çº¿æ®µä¼˜ï¼Œé‚£ä¹ˆä¸‹ä¼ ä¿®æ”¹çº¿æ®µï¼›å¦‚æœä¿®æ”¹çº¿æ®µæ¯”å½“å‰çº¿æ®µä¼˜ï¼Œé‚£ä¹ˆä¸‹ä¼ å½“å‰çº¿æ®µã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦ä¸‹ä¼ çš„ä¸€å®šæ˜¯å“ªä¸ªæ›´åŠ£çš„çº¿æ®µã€‚å¦‚ä½•ä¸‹ä¼ ï¼Ÿåªæœ‰å½“åœ¨æŸä¸€éƒ¨åˆ†çš„çº¿æ®µæœ‰äº¤ç‚¹æ—¶æ‰éœ€è¦ä¸‹ä¼ ã€‚ å•æ¬¡ä¿®æ”¹æ—¶é—´å¤æ‚åº¦ä¸º O(logâ¡2n)O(\\log^2 n)O(log2n)ï¼ŒæŸ¥è¯¢æ—¶ç›´æ¥è®°å½•è·¯è¿‡çš„æ‰€æœ‰çº¿æ®µçš„ç­”æ¡ˆå³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¾ç„¶ä¸º O(logâ¡n)O(\\log n)O(logn)ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define pdi pair&lt;double, int> using namespace std; const int P1 = 39989, P2 = 1000000000; const double eps = 1e-9; int n; struct Line &#123; double k, b; &#125; a[100005]; inline double calc(int x, int id) &#123; return a[id].k * x + a[id].b; &#125; inline void add(int x0, int y0, int x1, int y1) &#123; ++n; if (x0 == x1) a[n].k = 0, a[n].b = max(y0, y1); else a[n].k = 1.0 * (y1 - y0) / (x1 - x0), a[n].b = y0 - a[n].k * x0; &#125; int cmp(double x, double y) &#123; if (x - y > eps) return 1; if (y - x > eps) return -1; return 0; &#125; int T[400005]; void upd(int o, int l, int r, int x) &#123; if (T[o] == 0) return T[o] = x, void(); int &amp;y = T[o], mid = l + r >> 1; int b = cmp(calc(mid, x), calc(mid, y)); if (b == 1 || (b == 0 &amp;&amp; x &lt; y)) swap(x, y); // ç°åœ¨æ»¡è¶³ x åœ¨ä¸­ç‚¹å¤„æ¯” y åŠ£ int bl = cmp(calc(l, x), calc(l, y)), br = cmp(calc(r, x), calc(r, y)); if (bl == 1 || (bl == 0 &amp;&amp; x &lt; y)) upd(o &lt;&lt; 1, l, mid, x); // å·¦åŠéƒ¨åˆ†æœ‰äº¤ç‚¹ if (br == 1 || (br == 0 &amp;&amp; x &lt; y)) upd(o &lt;&lt; 1 | 1, mid + 1, r, x); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return upd(o, l, r, k); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); &#125; pdi pmax(pdi x, pdi y) &#123; if (cmp(x.first, y.first) == 1) return x; if (cmp(x.first, y.first) == -1) return y; return x.second &lt; y.second ? x : y; &#125; pdi query(int o, int l, int r, int x) &#123; if (r &lt; x || l > x) return &#123;0, 0&#125;; int mid = l + r >> 1; double res = calc(x, T[o]); if (l == r) return &#123;res, T[o]&#125;; return pmax(&#123;res, T[o]&#125;, pmax(query(o &lt;&lt; 1, l, mid, x), query(o &lt;&lt; 1 | 1, mid + 1, r, x))); &#125; int main(void) &#123; int m; scanf(\"%d\", &amp;m); for (int lst = 0; m--; ) &#123; int op; scanf(\"%d\", &amp;op); if (op == 1) &#123; int x0, y0, x1, y1; scanf(\"%d%d%d%d\", &amp;x0, &amp;y0, &amp;x1, &amp;y1); x0 = (x0 + lst - 1 + P1) % P1 + 1; x1 = (x1 + lst - 1 + P1) % P1 + 1; y0 = (y0 + lst - 1 + P2) % P2 + 1; y1 = (y1 + lst - 1 + P2) % P2 + 1; if (x0 > x1) swap(x0, x1), swap(y0, y1); add(x0, y0, x1, y1); update(1, 1, P1, x0, x1, n); &#125; else &#123; int x; scanf(\"%d\", &amp;x); x = (x + lst - 1 + P1) % P1 + 1; printf(\"%d\\n\", lst = query(1, 1, P1, x).second); &#125; &#125; return 0; &#125; å•ä¾§é€’å½’é—®é¢˜ [CTT2012 Day 1] æ¥¼æˆ¿é‡å»º.å° A åœ¨å¹³é¢ä¸Š (0,0)(0,0)(0,0) ç‚¹çš„ä½ç½®ï¼Œç¬¬ iii æ ‹æ¥¼æˆ¿å¯ä»¥ç”¨ä¸€æ¡è¿æ¥ (i,0)(i,0)(i,0) å’Œ (i,Hi)(i,H_i)(i,Hiâ€‹) çš„çº¿æ®µè¡¨ç¤ºï¼Œå…¶ä¸­ HiH_iHiâ€‹ ä¸ºç¬¬ iii æ ‹æ¥¼æˆ¿çš„é«˜åº¦ã€‚å¦‚æœè¿™æ ‹æ¥¼æˆ¿ä¸Šä»»ä½•ä¸€ä¸ªé«˜åº¦å¤§äº 000 çš„ç‚¹ä¸ (0,0)(0,0)(0,0) çš„è¿çº¿æ²¡æœ‰ä¸ä¹‹å‰çš„çº¿æ®µç›¸äº¤ï¼Œé‚£ä¹ˆè¿™æ ‹æ¥¼æˆ¿å°±è¢«è®¤ä¸ºæ˜¯å¯è§çš„ã€‚åˆå§‹æ—¶æ‰€æœ‰æ¥¼æˆ¿çš„é«˜åº¦éƒ½ä¸º 000ï¼Œæ”¯æŒå•ç‚¹ä¿®æ”¹ï¼Œä¿®æ”¹åè¯¢é—®èƒ½çœ‹åˆ°å¤šå°‘æ ‹æ¥¼æˆ¿ã€‚ æœ¬è´¨ä¸Šæ˜¯å•ç‚¹ä¿®æ”¹ï¼Œè¯¢é—®å…¨å±€æœ‰å¤šå°‘ä½ç½®æ˜¯å‰ç¼€æœ€å¤§å€¼ã€‚å¯ä»¥ä½¿ç”¨å¾ˆå±‘çš„æ ¹å·æ¥ç»´æŠ¤ï¼Œä½†æ˜¯è¿™é‡Œè€ƒè™‘ poly logã€‚ ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ã€‚ä¸€ä¸ªèŠ‚ç‚¹è®°å½•ä¸¤ä¸ªæ•°ï¼šåŒºé—´æ‰€å¯¹åº”çš„ç­”æ¡ˆï¼Œå½“å‰åŒºé—´çš„æœ€å¤§æ–œç‡ã€‚ä¿®æ”¹æ—¶å¾ˆå®¹æ˜“å®ç°ï¼Œå…³é”®æ˜¯ï¼Œpushupï¼Ÿé—®é¢˜åœ¨äºå¦‚ä½•ç»Ÿè®¡å½“å‰èŠ‚ç‚¹çš„ç­”æ¡ˆï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚ä½•ç»Ÿè®¡å³åŠæ®µåœ¨è¢«å·¦åŠæ®µå½±å“ä¹‹ååº”è¯¥å¦‚ä½•è®¡ç®—ç­”æ¡ˆã€‚æ€ä¹ˆåŠï¼Ÿä¸ä¼šï¼ä¿—è¯è¯´çš„å¥½ï¼Œé‚£ä¹ˆç›´æ¥é€’å½’ä¸‹å»ï¼ å¦‚æœå³åŒºé—´çš„æœ€å¤§å€¼å°äºç­‰äºå·¦åŒºé—´ï¼Œé‚£ä¹ˆå°±è¢«å…¨éƒ¨æŒ¡ä½äº†ã€‚å¦åˆ™é€’å½’è€ƒè™‘å³åŠæ®µï¼Œè¿™æ ·æ‰€æœ‰çš„è´¡çŒ®éƒ½å¯ä»¥è®¡ç®—ã€‚ pushup(T[o &lt;&lt; 1].k, o &lt;&lt; 1 | 1, mid + 1, r); // è°ƒç”¨ int pushup(double k, int o, int l, int r) &#123; if (T[o].k &lt;= k) return 0; // å½“è¿™ä¸€éƒ¨åˆ†çš„æ–œç‡å°äºå·¦åŠéƒ¨åˆ†çš„æ–œç‡ï¼Œç­”æ¡ˆä¸º 0 if (a[l] > k) return T[o].ans; // l çš„æ–œç‡å¤§äºå·¦åŠè¾¹ï¼Œå·¦åŠå¯¹å³åŠæ²¡æœ‰å½±å“ï¼Œè¿”å›å³åŠè¾¹ç­”æ¡ˆ if (l == r) return a[l] > k; // åªæœ‰ä¸€ä¸ªç‚¹ï¼Œç›´æ¥è¿”å› int mid = l + r >> 1; if (T[o &lt;&lt; 1].k &lt;= k) return pushup(k, o &lt;&lt; 1 | 1, mid + 1, r); // å·¦åŠè¾¹æ–œç‡å°äºç­‰äºé™åˆ¶ï¼Œåªæœ‰å³åŠè¾¹ä¼šè®¡å…¥ç­”æ¡ˆ return pushup(k, o &lt;&lt; 1, l, mid) + T[o].ans - T[o &lt;&lt; 1].ans; // ç»Ÿè®¡å·¦åŠè¾¹ç­”æ¡ˆï¼ŒåŒæ—¶ç›´æ¥åŠ ä¸Šå³åŠè¾¹çš„ç­”æ¡ˆï¼ˆå½“å‰ç­”æ¡ˆå‡å»å·¦å­èŠ‚ç‚¹ç­”æ¡ˆï¼‰ &#125; æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; struct Node &#123; int ans; double k; &#125; T[400005]; double a[100005]; int pushup(double k, int o, int l, int r) &#123; if (T[o].k &lt;= k) return 0; if (a[l] > k) return T[o].ans; if (l == r) return a[l] > k; int mid = l + r >> 1; if (T[o &lt;&lt; 1].k &lt;= k) return pushup(k, o &lt;&lt; 1 | 1, mid + 1, r); return pushup(k, o &lt;&lt; 1, l, mid) + T[o].ans - T[o &lt;&lt; 1].ans; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = &#123;1, a[x]&#125;, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o].k = max(T[o &lt;&lt; 1].k, T[o &lt;&lt; 1 | 1].k); T[o].ans = T[o &lt;&lt; 1].ans + pushup(T[o &lt;&lt; 1].k, o &lt;&lt; 1 | 1, mid + 1, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); a[x] = double(y) / x; update(1, 1, n, x, y); printf(\"%d\\n\", T[1].ans); &#125; return 0; &#125; å‰å¸æœºçº¿æ®µæ ‘ æŒ‡çš„æ˜¯ä¸€ç±»ç»´æŠ¤åŒºé—´æœ€å€¼æ“ä½œä¸å†å²æœ€å€¼çš„çº¿æ®µæ ‘ã€‚ åŒºé—´æœ€å€¼æ“ä½œ å¾…å¡«å‘ã€‚ åŒºé—´å†å²æœ€å€¼ å…¶ä½™å†…å®¹å¾…å¡«å‘ã€‚ CPU ç›‘æ§ã€‚ è€ƒè™‘æ²¡æœ‰æŸ“è‰²æ“ä½œæ€ä¹ˆåšã€‚ç®€å•ï¼Œç»´æŠ¤æœ€å¤§çš„å†å²åŠ æ ‡è®°ã€‚ å‘ç°ä¸€æ¬¡æŸ“è‰²åæ‰€æœ‰çš„åŠ éƒ½å¯ä»¥è½¬åŒ–ä¸ºæŸ“è‰²ï¼Œå› æ­¤ç›´æ¥åšå°±è¡Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x7fffffff; int n, m, a[100005]; struct Node &#123; int mx, hmx, setv, addv, hset, hadd, tag; void cover(int v, int hv) &#123; setv = mx = v; addv =-0; if (tag) hset = max(hset, hv); else hset = hv, tag = 1; hmx = max(hmx, hv); &#125; void add(int v, int hv) &#123; hadd = max(hadd, addv + hv); hmx = max(hmx, mx + hv); addv += v; mx += v; &#125; void change(int v, int hv) &#123; if (tag) cover(setv + v, setv + hv); else add(v, hv); &#125; &#125; T[400005]; inline void pushup(int o) &#123; T[o].mx = max(T[o &lt;&lt; 1].mx, T[o &lt;&lt; 1 | 1].mx); T[o].hmx = max(T[o &lt;&lt; 1].hmx, T[o &lt;&lt; 1 | 1].hmx); &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o].mx = T[o].hmx = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o); &#125; inline void pushdown(int o) &#123; T[o &lt;&lt; 1].change(T[o].addv, T[o].hadd); T[o &lt;&lt; 1 | 1].change(T[o].addv, T[o].hadd); T[o].addv = T[o].hadd = 0; if (T[o].tag) &#123; T[o &lt;&lt; 1].cover(T[o].setv, T[o].hset); T[o &lt;&lt; 1 | 1].cover(T[o].setv, T[o].hset); T[o].tag = 0; &#125; &#125; void update(int o, int l, int r, int x, int y, int k, bool type) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return type ? T[o].cover(k, k) : T[o].change(k, k), void(); int mid = l + r >> 1; pushdown(o); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k, type); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k, type); pushup(o); &#125; int query(int o, int l, int r, int x, int y, bool type) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return type ? T[o].hmx : T[o].mx; int mid = l + r >> 1, res = -INF; pushdown(o); if (x &lt;= mid) res = max(res, query(o &lt;&lt; 1, l, mid, x, y, type)); if (mid &lt; y) res = max(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y, type)); return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); char s[5]; int x, y, z; for (scanf(\"%d\", &amp;m); m--; ) &#123; scanf(\"%s%d%d\", s, &amp;x, &amp;y); if (s[0] == 'Q') printf(\"%d\\n\", query(1, 1, n, x, y, 0)); else if (s[0] == 'A') printf(\"%d\\n\", query(1, 1, n, x, y, 1)); else scanf(\"%d\", &amp;z), update(1, 1, n, x, y, z, s[0] == 'P' ? 0 : 1); &#125; return 0; &#125; é‡æ„ æœ‰äº›å¯¹æ•°æ®ç»“æ„çš„æ“ä½œè¾ƒéš¾ç»´æŠ¤ï¼Œæˆ‘ä»¬å¯ä»¥å®šæœŸå¯¹æ•´ä¸ªæ•°æ®ç»“æ„è¿›è¡Œ O(n)O(n)O(n) é‡æ„ï¼Œåœ¨ä¸¤æ¬¡é‡æ„ä¹‹é—´çš„ä¿®æ”¹ï¼Œåˆ™æš´åŠ›å¤„ç†ã€‚ æ“ä½œåˆ†å— å³æ ¹å·é‡æ„ã€‚ äºŒè¿›åˆ¶åˆ†ç»„ åˆ†å—ç³»åˆ— åˆ†å—æ˜¯æœ€éš¾çš„æ•°æ®ç»“æ„[1]ã€‚æˆ‘ä»¬ä¹‹å‰è§è¿‡å¯¹äºåºåˆ—çš„å„ç§åˆ†å—ï¼Œæœ‰çš„é¢˜ç›¸å½“éº»çƒ¦ã€‚ä½†æ˜¯å®é™…ä¸Šåˆ†å—è¿˜æœ‰è®¸å¤šå˜ç§åº”ç”¨ï¼Œæœ¬èŠ‚å°†åˆæ¢è¿™äº›å†…å®¹ã€‚ é€å—å¤„ç† å¦‚æœæ¯ä¸ªå—å¯¹ç­”æ¡ˆçš„è´¡çŒ®ç‹¬ç«‹ï¼Œé‚£ä¹ˆå¯ä»¥å°†è¯¢é—®ç¦»çº¿ï¼Œç„¶åé€ä¸ªå—è¿›è¡Œå¤„ç†ã€‚è¿™æ ·å¯ä»¥åšåˆ°çº¿æ€§ç©ºé—´ï¼Œå¹¶ä¸”å¸¸æ•°å¯ä»¥å¾—åˆ°ç›¸å½“çš„ä¼˜åŒ–ã€‚ [SNOI2022] å†›é˜Ÿã€‚ æ²¡æœ‰ l,rl,rl,r çš„è¯æ˜¯ä¸ªç»å…¸é—®é¢˜ï¼Œé‚£ä¹ˆç›´æ¥å°†åºåˆ—åˆ†å—é€å—å¤„ç†ï¼Œä¸æ˜¯å®Œæ•´çš„ä¿®æ”¹åˆ™æš´åŠ›é‡æ„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 5000; int n, q, C, LL, RR; int c[250005], cc[250005]; int L[505], R[505], vis[250005], cnt[250005]; i64 a[250005], ans[250005], aa[250005]; struct Query &#123; int op, l, r, x, y; &#125; Q[250005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;q, &amp;C); int t = (n - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", c + i), cc[i] = i; for (int i = 1; i &lt;= q; ++i) &#123; scanf(\"%d%d%d\", &amp;Q[i].op, &amp;Q[i].l, &amp;Q[i].r); if (Q[i].op != 3) scanf(\"%d%d\", &amp;Q[i].x, &amp;Q[i].y); &#125; for (int k = 1; k &lt;= t; ++k) &#123; LL = L[k], RR = R[k]; i64 res = 0; memset(cnt, 0, sizeof cnt); for (int i = LL; i &lt;= RR; ++i) ++cnt[c[i]], res += a[i]; for (int i = 1; i &lt;= q; ++i) &#123; int op = Q[i].op, l = Q[i].l, r = Q[i].r, x = Q[i].x, y = Q[i].y; if (r &lt; LL || l > RR) continue; if (l &lt;= LL &amp;&amp; RR &lt;= r) &#123; if (op == 1) cnt[y] += cnt[x], cnt[x] = 0; else if (op == 2) res += 1ll * cnt[x] * y; else ans[i] += res; &#125; else &#123; int bl = max(l, LL), br = min(r, RR); vector&lt;int> bin; for (int j = i - 1; j >= 1 &amp;&amp; vis[j] != k; --j) &#123; vis[j] = k; if (Q[j].r &lt; LL || Q[j].l > RR) continue; if (Q[j].op == 1) aa[Q[j].x] = aa[Q[j].y], cc[Q[j].x] = cc[Q[j].y]; else if (Q[j].op == 2) aa[Q[j].x] += Q[j].y; bin.push_back(Q[j].x); &#125; vis[i] = k; for (int j = LL; j &lt;= RR; ++j) a[j] += aa[c[j]], c[j] = cc[c[j]]; for (int x : bin) aa[x] = 0, cc[x] = x; if (op == 1) &#123; for (int j = bl; j &lt;= br; ++j) if (c[j] == x) c[j] = y, --cnt[x], ++cnt[y]; &#125; else if (op == 2) &#123; for (int j = bl; j &lt;= br; ++j) if (c[j] == x) a[j] += y, res += y; &#125; else &#123; for (int j = bl; j &lt;= br; ++j) ans[i] += a[j]; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= q; ++i) if (Q[i].op == 3) printf(\"%lld\\n\", ans[i]); return 0; &#125; Problemset æ‰«æçº¿ ä¸€äº›ç®€å•é¢˜ã€‚ [Luogu P1502] çª—å£çš„æ˜Ÿæ˜Ÿ Portal. æˆ‘ä»¬å°†æ¯ä¸ªæ˜Ÿæ˜Ÿçœ‹æˆä¸€ä¸ªå·¦ä¸‹è§’ä¸º (x,y)(x,y)(x,y)ï¼Œå³ä¸Šè§’ä¸º (x+wâˆ’1,y+hâˆ’1)(x+w-1,y+h-1)(x+wâˆ’1,y+hâˆ’1) çš„çŸ©å½¢ï¼Œçª—æˆ·çœ‹æˆä¸€ä¸ªç‚¹ï¼Œé‚£ä¹ˆä½¿ç”¨æ‰«æçº¿ç»´æŠ¤å¹³é¢ä¸­çš„æœ€å¤§å€¼å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> using namespace std; typedef long long i64; struct Line &#123; int x, yl, yh, c; Line(int x = 0, int yl = 0, int yh = 0, int c = 0) : x(x), yl(yl), yh(yh), c(c) &#123;&#125; bool operator &lt; (const Line &amp;a) const &#123; // å…ˆæ‰«åŠ çš„æ¥ä¿è¯ç»“æœæ­£ç¡® if (x != a.x) return x &lt; a.x; else return c > a.c; &#125; &#125;e[20005]; int n, W, H, m; int b[20005]; i64 T[80005], tag[80005]; inline void pushdown(int o) &#123; if (!tag[o]) return; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; T[o &lt;&lt; 1] += tag[o]; T[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; T[o] += k; tag[o] += k; return; &#125; pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;W, &amp;H); for (int i = 1, x, y, l; i &lt;= n; ++i) &#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;l); e[(i &lt;&lt; 1) - 1] = Line(x, y, y + H - 1, l); e[i &lt;&lt; 1] = Line(x + W - 1, y, y + H - 1, -l); b[(i &lt;&lt; 1) - 1] = y, b[i &lt;&lt; 1] = y + H - 1; &#125; sort(b + 1, b + (n &lt;&lt; 1) + 1); m = unique(b + 1, b + (n &lt;&lt; 1) + 1) - (b + 1); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) &#123; int pos1 = lower_bound(b + 1, b + m + 1, e[i].yl) - b; int pos2 = lower_bound(b + 1, b + m + 1, e[i].yh) - b; e[i].yl = pos1, e[i].yh = pos2; &#125; sort(e + 1, e + (n &lt;&lt; 1) + 1); i64 ans = 0; memset(T, 0, sizeof(T)); memset(tag, 0, sizeof(tag)); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) &#123; update(1, 1, n &lt;&lt; 1, e[i].yl, e[i].yh, e[i].c); ans = max(ans, T[1]); &#125; printf(\"%lld\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; é¢œè‰²æ®µå‡æ‘Š ä¸ä¸€å®šæ˜¯åŒºé—´æŸ“è‰²ï¼Œæœ‰äº›æ“ä½œä¹Ÿå…·æœ‰ç±»ä¼¼äºé¢œè‰²æ®µå‡æ‘Šçš„æ€§è´¨ã€‚ ã€ŒC.E.L.U-02ã€è‹¦æ¶© Portal. å»ºç«‹ä¸€æ£µçº¿æ®µæ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¿å­˜ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ä½œä¸ºåŒºé—´åŠ çš„æ ‡è®°ï¼Œå¹¶æ°¸ä¹…åŒ–ï¼ˆå³å½“å‰èŠ‚ç‚¹çš„ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„å†…å®¹å¯¹å®ƒçš„å„¿å­éƒ½æœ‰æ•ˆï¼‰ã€‚åˆ é™¤æ—¶å¯ä»¥æš´åŠ›éå†çº¿æ®µæ ‘ï¼Œå› ä¸ºæ¯ä¸€æ¬¡æ·»åŠ åªä¼šæ·»åŠ ä¸€ä¸ªæ‹¥æœ‰æœ€å¤§æ•°å€¼æœ€å¤§çš„é¢œè‰²æ®µï¼Œè¿™æ ·åˆ é™¤å®ƒçš„æ—¶é—´å°±ä¼šåœ¨ O(logâ¡n)O(\\log n)O(logn) çº§åˆ«ã€‚è‹¥ n,mn,mn,m åŒé˜¶ï¼Œé‚£ä¹ˆæ€»æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; struct Node &#123; int maxx; priority_queue&lt;int> q; &#125; T[800005]; void pushup(int o) &#123; T[o].maxx = max(&#123;T[o &lt;&lt; 1].maxx, T[o &lt;&lt; 1 | 1].maxx, T[o].q.top()&#125;); &#125; void build(int o, int l, int r) &#123; T[o].maxx = -1; T[o].q.push(-1); if (l == r) return; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); &#125; void maketag(int o, int k) &#123; T[o].q.push(k); T[o].maxx = max(T[o].maxx, k); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, k); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); pushup(o); &#125; void remove(int o, int l, int r, int x, int y, int k) &#123; if (T[o].maxx &lt; k) return; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; if (T[o].q.top() == k) &#123; T[o].q.pop(); if (l == r) T[o].maxx = T[o].q.top(); else pushup(o); return; &#125; int mid = l + r >> 1; remove(o &lt;&lt; 1, l, mid, x, y, k); remove(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); return pushup(o); &#125; if (T[o].q.top() == k) T[o].q.pop(), maketag(o &lt;&lt; 1, k), maketag(o &lt;&lt; 1 | 1, k); int mid = l + r >> 1; if (x &lt;= mid) remove(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) remove(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); pushup(o); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].maxx; int mid = l + r >> 1, ans = T[o].q.top(); if (x &lt;= mid) ans = max(ans, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) ans = max(ans, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); build(1, 1, n); while (m--) &#123; int op, l, r, k; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) &#123; scanf(\"%d\", &amp;k); update(1, 1, n, l, r, k); &#125; else if (op == 2) &#123; k = query(1, 1, n, l, r); if (k != -1) remove(1, 1, n, l, r, k); &#125; else printf(\"%d\\n\", query(1, 1, n, l, r)); &#125; return 0; &#125; çº¿æ®µæ ‘è¿›é˜¶ç”¨æ³• å„ç§çº¿æ®µæ ‘ï¼ [CF1340F] Nastya and CBS ç»´æŠ¤ä¸€ä¸ªæ‹¬å·åºåˆ—ï¼Œå¯ä»¥æ”¯æŒç®€å•çš„ä¿®æ”¹ï¼Œè¯¢é—®åŒºé—´æ‹¬å·åŒ¹é…ä¿¡æ¯ï¼Œè¿™æ˜¯å¯ä»¥ä½¿ç”¨å•ä¾§é€’å½’ç»“æ„è§£å†³çš„ç»å…¸é—®é¢˜ã€‚ Portal.kkk ç§æ‹¬å·ï¼Œæ”¯æŒå•ç‚¹ä¿®æ”¹æ‹¬å·ç§ç±»ï¼Œè¯¢é—®åŒºé—´æ˜¯å¦ä¸ºåˆæ³•çš„æ‹¬å·åºåˆ—ã€‚ ä¸€æ®µæ‹¬å·åºåˆ—æ€ä¹ˆç»´æŠ¤ï¼Ÿç”±äºçº¿æ®µæ ‘ä¸Šçš„ç»“æ„æ˜¯ä¸æ–­åˆå¹¶çš„ï¼Œå› æ­¤åœ¨ä¸æ–­åˆ å»ç›¸é‚»çš„æ‹¬å·åŒ¹é…åï¼Œå¦‚æœä»ç„¶åŒ…å«ç›¸å‘çš„æ‹¬å·ï¼ˆ(]ï¼‰ï¼Œé‚£ä¹ˆå°±å¤±é…äº†ã€‚è¿™æ ·å½“å‰èŠ‚ç‚¹çš„åŒ¹é…ä¿¡æ¯å¿…å®šæ˜¯è‹¥å¹²å³æ‹¬å·åŠ è‹¥å¹²å·¦æ‹¬å·ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œçº¿æ®µæ ‘çš„å½“å‰èŠ‚ç‚¹å­˜å‚¨å·¦ä¾§çš„å³æ‹¬å·å’Œå³ä¾§çš„å·¦æ‹¬å·ï¼Œå‚¨å­˜æ—¶å‚¨å­˜å®ƒä»¬çš„é•¿åº¦å’Œå“ˆå¸Œå€¼ï¼Œåˆå¹¶çš„æ—¶å€™éœ€è¦æŸ¥è¯¢æŸä¸ªèŠ‚ç‚¹å·¦å³ä¾§éƒ¨åˆ†å‰åç¼€å“ˆå¸Œå€¼ï¼Œç„¶åè¿›è¡ŒåŒ¹é…ï¼Œè¿™ä¸ªè¿‡ç¨‹å¯ä»¥ç›´æ¥å•ä¾§é€’å½’ä¸‹å»ã€‚ å¯¹äºè¯¢é—®ï¼Œå°†çº¿æ®µæ ‘ä¸Šçš„åŒºé—´æŠ½ç¦»å‡ºæ¥æ”¾åœ¨ä¸€ä¸ªæ ˆä¸­ï¼Œåˆ©ç”¨åŒ¹é…çš„è¿‡ç¨‹ä¸­ä¸åº”æœ‰å³æ‹¬å·è¿™ä¸€ç‰¹ç‚¹ä¸æ–­è¿›è¡ŒåŒ¹é…ï¼Œçœ‹æœ€åæ˜¯å¦å‰©çš„å…ƒç´ é•¿åº¦ä¸º 000ã€‚ æ—¶é—´å¤æ‚åº¦ä¸º O(n+mlogâ¡2n)O(n+m\\log^2 n)O(n+mlog2n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define ls o &lt;&lt; 1 #define rs ls | 1 using namespace std; int n, m, k; int a[100005]; namespace Hash &#123; const int B1 = 10009, B2 = 254350526, P = 943236167; int _w[200010], *w = _w + 100005; void init(int n) &#123; w[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; w[i] = 1ll * w[i - 1] * B1 % P; w[-i] = 1ll * w[-i + 1] * B2 % P; &#125; &#125; struct str &#123; int l, x; str() &#123; l = x = 0; &#125; str(int v) : l(1), x(v) &#123;&#125; str(int l, int x) : l(l), x(x) &#123;&#125; friend bool operator== (str a, str b) &#123; return a.l == b.l &amp;&amp; a.x == b.x; &#125; friend str operator+ (str a, str b) &#123; return str(a.l + b.l, (a.x + 1ll * b.x * w[a.l]) % P); &#125; friend str operator- (str a, str b) &#123; return str(a.l - b.l, (0ll + a.x - b.x + P) * w[-b.l] % P); &#125; &#125;; &#125; using Hash::str; struct Node &#123; bool err; str vl, vr; Node(int x = 0) : err(0) &#123; if (x > 0) vr = x; else vl = -x; &#125; &#125; T[400005]; str gValL(int o, int k) &#123; if (!k) return str(); if (k == T[o].vl.l) return T[o].vl; if (k &lt;= T[ls].vl.l) return gValL(ls, k); return T[ls].vl + (gValL(rs, k - T[ls].vl.l + T[ls].vr.l) - T[ls].vr); &#125; str gValR(int o, int k) &#123; if (!k) return str(); if (k == T[o].vr.l) return T[o].vr; if (k &lt;= T[rs].vr.l) return gValR(rs, k); return T[rs].vr + (gValR(ls, k - T[rs].vr.l + T[rs].vl.l) - T[rs].vl); &#125; inline void pushup(int o) &#123; if (T[ls].err || T[rs].err) return T[o].err = 1, void(); T[o].err = 0; T[o].vl = T[ls].vl, T[o].vr = T[rs].vr; if (T[ls].vr.l &lt;= T[rs].vl.l) &#123; // å·¦åŠæ®µåˆå¹¶åˆ°å³åŠæ®µ if (T[ls].vr == gValL(rs, T[ls].vr.l)) T[o].vl = T[o].vl + (T[rs].vl - T[ls].vr); else T[o].err = 1; &#125; else &#123; if (T[rs].vl == gValR(ls, T[rs].vl.l)) T[o].vr = T[o].vr + (T[ls].vr - T[rs].vl); else T[o].err = 1; &#125; &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o] = Node(a[l]), void(); int mid = l + r >> 1; build(ls, l, mid); build(rs, mid + 1, r); pushup(o); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(ls, l, mid, x, k); else update(rs, mid + 1, r, x, k); pushup(o); &#125; int st[50], tot; void get(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return st[++tot] = o, void(); int mid = l + r >> 1; if (x &lt;= mid) get(ls, l, mid, x, y); if (mid &lt; y) get(rs, mid + 1, r, x, y); &#125; str seq[50]; str gVal(int o, int k) &#123; if (!k) return str(); if (k == seq[o].l) return seq[o]; if (k &lt;= T[st[o]].vr.l) return gValR(st[o], k); return T[st[o]].vr + (gVal(o - 1, k - T[st[o]].vr.l + T[st[o]].vl.l) - T[st[o]].vl); &#125; bool query(int l, int r) &#123; tot = 0; get(1, 1, n, l, r); for (int i = 1; i &lt;= tot; ++i) &#123; if (T[st[i]].err) return 0; if (seq[i - 1].l &lt; T[st[i]].vl.l) return 0; if (T[st[i]].vl == gVal(i - 1, T[st[i]].vl.l)) seq[i] = T[st[i]].vr + (seq[i - 1] - T[st[i]].vl); else return 0; &#125; return !seq[tot].l; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); Hash::init(n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); for (scanf(\"%d\", &amp;m); m--; ) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) update(1, 1, n, x, y); else puts(query(x, y) ? \"Yes\" : \"No\"); &#125; return 0; &#125; æ ¹å·æŠ€å·§ ä¸€äº›æ ¹å·æ‚é¢˜ã€‚ å¤§åˆ†å—ç³»åˆ— ç”±äºå®ƒä»¬éƒ½æ¯”è¾ƒç»å…¸ï¼Œæ•…æ­¤æ”¾åœ¨è¿™é‡Œã€‚ çªåˆºè´¯ç©¿çš„ç¬¬äºŒåˆ†å— | [Ynoi2018] äº”å½©æ–‘æ–“çš„ä¸–ç•Œ Portal. ç¥ç§˜çš„ä¿®æ”¹+ç¥ç§˜çš„æŸ¥è¯¢ï¼Œæ€ä¹ˆæï¼Ÿå‘ç°å…¶å€¼åŸŸå°å¾—å¯æ€œï¼Œè€Œä¸”æ—¶é™å¾ˆå¤§ï¼Œç©ºé™å´å¾ˆå°ã€‚ ç¦»çº¿ï¼Œé€å—å¤„ç†ï¼ˆå› ä¸ºç©ºé—´é™åˆ¶å®åœ¨å¤ªå°ï¼Œæƒ³è¦é¢„å¤„ç†ä»»ä½•ä¿¡æ¯éƒ½æ˜¯ä¸å¯èƒ½çš„ï¼‰ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥åœ¨ O(m)O(m)O(m) å®Œæˆå•ä¸ªå—å†…å¤„ç†çš„ç®—æ³•ã€‚ è®°å—å†…æœ€å¤§å€¼ä¸º kkkï¼Œé‚£ä¹ˆï¼š kâ‰¤2xk\\le 2xkâ‰¤2xï¼Œä»¤å¤§äº xxx çš„æ•°å‡å» xxx åå°±æ²¡æœ‰æ¯” xxx å¤§çš„æ•°äº†ï¼Œkkk ä¼šå‡å°è‡³å°‘ kâˆ’xk-xkâˆ’xï¼› k&gt;2xk&gt;2xk&gt;2xï¼Œä»¤å°äºç­‰äº xxx çš„æ•°åŠ ä¸Š xxxï¼Œå°±æ²¡æœ‰æ¯” xxx å°çš„æ•°äº†ã€‚ç„¶åæ‰“ä¸Šå…¨å±€å‡æ ‡è®°ï¼Œkkk åœ¨æ“ä½œåå‡å°‘è‡³å°‘ xxxã€‚ å‘ç°è¿™ä¸ª kkk å•è°ƒä¸å¢ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸º O(V)O(V)O(V)ã€‚ ç»´æŠ¤æ•°å€¼æ—¶ç›´æ¥é‡‡ç”¨å¹¶æŸ¥é›†ï¼Œè®°å½•é›†åˆçš„å¤§å°ã€‚é›¶æ•£å—ä¿®æ”¹ç›´æ¥é‡æ„ï¼Œæ•´å—åˆ™ç›´æ¥ç»´æŠ¤ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 900; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x; &#125; void print(int x) &#123; if (x > 9) print(x / 10); putchar_unlocked(x % 10 ^ 48); &#125; int n, m, LL, RR, tag, mx, op, l, r, x; int a[1000005], Ans[500005]; int L[2005], R[2005]; int fa[1000005], root[100005], cnt[100005], val[1000005]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; inline void merge(int x, int y) &#123; if (root[y]) fa[root[x]] = root[y]; else root[y] = root[x], val[root[y]] = y; cnt[y] += cnt[x]; root[x] = cnt[x] = 0; &#125; struct Operation &#123; int op, l, r, x; &#125; Q[500005]; inline void build(void) &#123; mx = tag = 0; for (int i = LL; i &lt;= RR; ++i) &#123; mx = max(mx, a[i]); if (root[a[i]]) fa[i] = root[a[i]]; else root[a[i]] = fa[i] = i, val[i] = a[i]; ++cnt[a[i]]; &#125; &#125; inline void rebuild(void) &#123; for (int i = LL; i &lt;= RR; ++i) &#123; a[i] = val[find(i)]; root[a[i]] = cnt[a[i]] = 0; a[i] -= tag; &#125; for (int i = LL; i &lt;= RR; ++i) val[i] = 0; int ql = max(l, LL), qr = min(r, RR); for (int i = ql; i &lt;= qr; ++i) if (a[i] > x) a[i] -= x; build(); &#125; inline void modify(void) &#123; if (x * 2 > mx - tag) &#123; for (int i = x + 1 + tag; i &lt;= mx; ++i) if (root[i]) merge(i, i - x); mx = min(mx, x + tag); &#125; else &#123; for (int i = tag; i &lt;= x + tag; ++i) if (root[i]) merge(i, i + x); tag += x; &#125; &#125; inline int get(void) &#123; int ql = max(l, LL), qr = min(r, RR), res = 0; for (int j = ql; j &lt;= qr; ++j) if (val[find(j)] == x + tag) ++res; return res; &#125; int main(void) &#123; n = read(); m = read(); int t = (n - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= m; ++i) Q[i].op = read(), Q[i].l = read(), Q[i].r = read(), Q[i].x = read(); for (int k = 1; k &lt;= t; ++k) &#123; LL = L[k], RR = R[k]; build(); for (int i = 1; i &lt;= m; ++i) &#123; op = Q[i].op, l = Q[i].l, r = Q[i].r, x = Q[i].x; if (r &lt; LL || l > RR) continue; if (op == 1) &#123; if (x == 0) continue; if (l &lt;= LL &amp;&amp; RR &lt;= r) modify(); else rebuild(); &#125; else &#123; if (x + tag > 100001) continue; if (l &lt;= LL &amp;&amp; RR &lt;= r) Ans[i] += cnt[x + tag]; else Ans[i] += get(); &#125; &#125; if (k != t) memset(root, 0, sizeof root), memset(cnt, 0, sizeof cnt); &#125; for (int i = 1; i &lt;= m; ++i) if (Q[i].op == 2) print(Ans[i]), putchar_unlocked('\\n'); return 0; &#125; å¼‘å°½ç ´å‡€çš„ç¬¬å››åˆ†å— | [Ynoi2018] å¤©é™ä¹‹ç‰© Portal. æœ¬é¢˜å­˜åœ¨åºåˆ—åˆ†å—åšæ³•ï¼Œä½†å¯¹äºæœ¬é¢˜æ¥è¯´æ ¹å·åˆ†æ²»å¯ä»¥åšå¾—æ›´å¥½ã€‚ è€ƒè™‘ä¸€ä¸ªæœ€æš´åŠ›çš„åšæ³•ï¼Œå°†æ‰€æœ‰æ•°çš„ä½ç½®æ”¾åœ¨ vector ä¸­ï¼Œç„¶åç›´æ¥æš´åŠ›æ‰«ã€‚å¯¹äºå‡ºç°æ¬¡æ•°å¤šçš„æ•°é¢„å¤„ç†å‡ºç­”æ¡ˆç„¶åå°† vector æ¸…ç©ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 500; const int INF = 1e9; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x; &#125; int n, m, a[100005], siz[100005], F[100005], tot, id[100005], ans[230][100005]; vector&lt;int> v[100005]; inline int calc(int x, int y) &#123; // å¯¹äº y è®¡ç®— x int i = 0, j = 0, ans = INF, sx = v[x].size(), sy = v[y].size(); if (!sx || !sy) return INF; while (i &lt; sx &amp;&amp; j &lt; sy) &#123; if (v[x][i] > v[y][j]) ans = min(ans, v[x][i] - v[y][j++]); else ans = min(ans, v[y][j] - v[x][i++]); &#125; if (i &lt; sx) ans = min(ans, abs(v[x][i] - v[y][sy - 1])); if (j &lt; sy) ans = min(ans, abs(v[x][sx - 1] - v[y][j])); return ans; &#125; inline int query(int x, int y) &#123; x = F[x], y = F[y]; if (!siz[x] || !siz[y]) return -1; if (x == y) return 0; if (siz[x] > siz[y]) swap(x, y); if (siz[y] &lt;= BLOCK_SIZE) return calc(x, y); if (siz[x] &lt;= BLOCK_SIZE) return min(ans[id[y]][x], calc(x, y)); return min(&#123;ans[id[y]][x], ans[id[x]][y], calc(x, y)&#125;); &#125; inline void build(int x, int ID = 0) &#123; // å¤„ç† x, å­˜å‚¨åœ¨ ID çš„ç­”æ¡ˆ if (ID) id[x] = ID; else id[x] = ++tot; int t = id[x]; memset(ans[t], 0x3f, sizeof ans[t]); for (int i = 1, j = INF; i &lt;= n; ++i) if (a[i] == x) j = 0; else ans[t][a[i]] = min(ans[t][a[i]], ++j); for (int i = n, j = INF; i >= 1; --i) if (a[i] == x) j = 0; else ans[t][a[i]] = min(ans[t][a[i]], ++j); ans[t][x] = 0; vector&lt;int> cl; v[x].swap(cl); &#125; inline void merge(int x, int y) &#123; // å°† x ä¸­çš„å…ƒç´ åˆå¹¶åˆ° y int i = 0, j = 0, sx = v[x].size(), sy = v[y].size(); vector&lt;int> res; while (i &lt; sx &amp;&amp; j &lt; sy) &#123; if (v[x][i] &lt; v[y][j]) res.emplace_back(v[x][i++]); else res.emplace_back(v[y][j++]); &#125; while (i &lt; sx) res.emplace_back(v[x][i++]); while (j &lt; sy) res.emplace_back(v[y][j++]); v[y] = res; &#125; inline void update(int x, int y) &#123; // æ‰€æœ‰ x -> y int x_ = F[x], y_ = F[y]; if (!siz[x_] || x_ == y_) return; if (siz[x_] > siz[y_]) F[y] = x_, F[x] = n + 1, swap(x_, y_); else F[x] = n + 1; if (x_ > n || y_ > n) return; x = x_, y = y_; if (siz[y] &lt;= BLOCK_SIZE) &#123; if (siz[x] + siz[y] &lt;= BLOCK_SIZE) &#123; for (int i : v[x]) a[i] = y; for (int i = 1; i &lt;= tot; ++i) ans[i][y] = min(ans[i][y], ans[i][x]); merge(x, y); &#125; else &#123; for (int i = 1; i &lt;= n; ++i) if (a[i] == x) a[i] = y; build(y); &#125; &#125; else if (siz[x] &lt;= BLOCK_SIZE) &#123; if (siz[x] + v[y].size() &lt;= BLOCK_SIZE) &#123; for (int i : v[x]) a[i] = y; for (int i = 1; i &lt;= tot; ++i) ans[i][y] = min(ans[i][y], ans[i][x]); merge(x, y); &#125; else &#123; for (int i = 1; i &lt;= n; ++i) if (a[i] == x) a[i] = y; build(y, id[y]); &#125; &#125; else &#123; for (int i = 1; i &lt;= n; ++i) if (a[i] == x) a[i] = y; build(y, id[y]); &#125; siz[y] += siz[x]; siz[x] = 0; vector&lt;int> cl; v[x].swap(cl); &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) v[a[i] = read()].emplace_back(i), F[i] = i, ++siz[a[i]]; for (int i = 1; i &lt;= n; ++i) if (siz[i] > BLOCK_SIZE) build(i); for (int last = 0; m--; ) &#123; int op = read(), x = read() ^ last, y = read() ^ last; if (op == 1) update(x, y); else &#123; last = query(x, y); if (last == -1) last = 0, puts(\"Ikaros\"); else printf(\"%d\\n\", last); &#125; &#125; return 0; &#125; æ•°æ®ç»“æ„ç»¼åˆ è¿™é‡Œæ˜¯ä¸€äº›ç»¼åˆæ€§ DS éš¾é¢˜ã€‚ æ ¹æœ¬åŸå› æ˜¯åˆ†å—åŸºæœ¬ä¸Šå°±æ˜¯æš´åŠ›ï¼Œè€Œè¶Šæ˜¯æš´åŠ›çš„ç®—æ³•å¯æ‰©å±•æ€§å°±è¶Šå¼ºï¼Œèƒ½è§£å†³çš„é—®é¢˜å°±è¶Šå¤šï¼Œå› æ­¤é¢˜å°±å¯ä»¥å˜å¾—ç›¸å½“å¤æ‚ã€‚ â†©ï¸","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"æ•°æ®ç»“æ„","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"äºŒå‰æœç´¢æ ‘ä¸å¹³è¡¡æ ‘","slug":"notes/DS/BST","date":"2022-12-28T00:00:00.000Z","updated":"2022-12-28T00:00:00.000Z","comments":true,"path":"9fce88cb/","link":"","permalink":"https://james1badcreeper.github.io/9fce88cb/","excerpt":"äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Tree, BSTï¼‰æ˜¯ä¸€ç§äºŒå‰æ ‘çš„æ ‘å½¢æ•°æ®ç»“æ„ï¼Œèƒ½é«˜æ•ˆåœ°è§£å†³è®¸å¤šå…¶å®ƒæ•°æ®ç»“æ„æ‰€ä¸èƒ½è§£å†³çš„é—®é¢˜ï¼Œä½†ç”±äºè‡ªèº«æ˜¯ä¸€ä¸ªä¸ç¨³å®šï¼Œå®¹æ˜“é€€åŒ–çš„æ•°æ®ç»“æ„ï¼Œæ‰€ä»¥éœ€è¦ç”¨ç‰¹æ®Šæ‰‹æ®µä¿è¯å…¶å¹³è¡¡ã€‚","text":"äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Tree, BSTï¼‰æ˜¯ä¸€ç§äºŒå‰æ ‘çš„æ ‘å½¢æ•°æ®ç»“æ„ï¼Œèƒ½é«˜æ•ˆåœ°è§£å†³è®¸å¤šå…¶å®ƒæ•°æ®ç»“æ„æ‰€ä¸èƒ½è§£å†³çš„é—®é¢˜ï¼Œä½†ç”±äºè‡ªèº«æ˜¯ä¸€ä¸ªä¸ç¨³å®šï¼Œå®¹æ˜“é€€åŒ–çš„æ•°æ®ç»“æ„ï¼Œæ‰€ä»¥éœ€è¦ç”¨ç‰¹æ®Šæ‰‹æ®µä¿è¯å…¶å¹³è¡¡ã€‚ æ›´æ–°æ—¥å¿— 2023/10/12å®Œæˆé¢„å®šæ‰€æœ‰å†…å®¹ã€‚ æ¦‚å¿µ äºŒå‰æ ‘æœ‰ä¸€ç§æ€§è´¨å«åšäºŒå‰æœç´¢æ ‘æ€§è´¨ï¼Œå°±æ˜¯è¯´å¯¹äºæ ‘ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå®ƒçš„é”®å€¼ä¸å°äºå®ƒå·¦å­æ ‘çš„é”®å€¼ï¼Œä¸å¤§äºå®ƒå³å­æ ‘çš„é”®å€¼ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„â€œBST æ€§è´¨â€ã€‚ BST çš„é€’å½’å®šä¹‰å¦‚ä¸‹ï¼š ç©ºæ ‘æ˜¯ BSTï¼› è‹¥ BST çš„å·¦å­æ ‘ä¸ä¸ºç©ºï¼Œåˆ™å…¶å·¦å­æ ‘ä¸Šæ‰€æœ‰ç‚¹çš„é™„åŠ æƒå€¼å‡å°äºå…¶æ ¹èŠ‚ç‚¹çš„å€¼ï¼› è‹¥ BST çš„å³å­æ ‘ä¸ä¸ºç©ºï¼Œåˆ™å…¶å³å­æ ‘ä¸Šæ‰€æœ‰ç‚¹çš„é™„åŠ æƒå€¼å‡å¤§äºå…¶æ ¹èŠ‚ç‚¹çš„å€¼ï¼› BST çš„å·¦å³å­æ ‘å‡ä¸º BSTï¼› BST é›†åˆæ˜¯æ»¡è¶³ 1ã€2ã€3ã€4 çš„æœ€å°äºŒå‰æ ‘é›†ã€‚ æ‰€ä»¥è¾“å‡º BST çš„ä¸­åºéå†å°±æ˜¯åŸåºåˆ—æ’åºçš„ç»“æœã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸€èˆ¬çš„ï¼ŒBST æ‰€æœ‰èŠ‚ç‚¹çš„é”®å€¼éƒ½ä¸ç›¸ç­‰ã€‚ æ™®é€š BST æ¨¡æ¿ã€‚æ‚¨éœ€è¦å†™ä¸€ç§æ•°æ®ç»“æ„ï¼Œæ¥ç»´æŠ¤ä¸€äº›æ•°ï¼ˆ éƒ½æ˜¯ 10910^9109 ä»¥å†…çš„æ•°å­—ï¼‰çš„é›†åˆï¼Œæœ€å¼€å§‹æ—¶é›†åˆæ˜¯ç©ºçš„ã€‚å…¶ä¸­éœ€è¦æä¾›ä»¥ä¸‹æ“ä½œï¼Œæ“ä½œæ¬¡æ•° qqq ä¸è¶…è¿‡ 10410^4104ï¼šæŸ¥è¯¢ xxx æ•°çš„æ’åï¼ˆæ’åå®šä¹‰ä¸ºæ¯”å½“å‰æ•°å°çš„æ•°çš„ä¸ªæ•° +1+1+1ã€‚è‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œåº”è¾“å‡ºæœ€å°çš„æ’åï¼‰ã€‚æŸ¥è¯¢æ’åä¸º xxx çš„æ•°ã€‚æ±‚ xxx çš„å‰é©±ï¼ˆå‰é©±å®šä¹‰ä¸ºå°äº xxxï¼Œä¸”æœ€å¤§çš„æ•°ï¼‰ã€‚è‹¥æœªæ‰¾åˆ°åˆ™è¾“å‡º âˆ’2147483647-2147483647âˆ’2147483647ã€‚æ±‚ xxx çš„åç»§ï¼ˆåç»§å®šä¹‰ä¸ºå¤§äº xxxï¼Œä¸”æœ€å°çš„æ•°ï¼‰ã€‚è‹¥æœªæ‰¾åˆ°åˆ™è¾“å‡º 214748364721474836472147483647ã€‚æ’å…¥ä¸€ä¸ªæ•° xxxã€‚ BST çš„èŠ‚ç‚¹ä¼šè¿™æ ·å®šä¹‰ï¼š struct Node &#123; int l, r; // å·¦å³å„¿å­ int val; // é”®å€¼ int cnt, size; // è¡¨ç¤ºè¿™ä¸ªèŠ‚ç‚¹æ•°ä¸ªä¸ªæ•°ï¼Œå’Œå­æ ‘çš„å¤§å° &#125;T[maxn]; è¾…åŠ©å‡½æ•°å¦‚ä¸‹ï¼š int tot = 0; inline int newNode(int val) // æ–°å»ºèŠ‚ç‚¹ï¼Œå¹¶è¿”å›ç¼–å· &#123; T[++tot] = val; T[tot].size = T[tot].cnt = 1; return tot; &#125; inline void maintain(int p) &#123; // ç»´æŠ¤å½“å‰èŠ‚ç‚¹çš„ä¿¡æ¯ T[p].size = T[T[p].l].size + T[T[p].r].size + T[p].cnt; &#125; ä¸ºäº†ä½¿è¾¹ç•Œå¤„ç†æƒ…å†µæ›´ä¸ºæ–¹ä¾¿ï¼Œæˆ‘ä»¬ä¼šæ’å…¥ä¸€ä¸ª INF èŠ‚ç‚¹å’Œä¸€ä¸ª -INF èŠ‚ç‚¹ï¼Œè¿™æ ·å»ºæ ‘ï¼š int root = 1; // å®šä¹‰æ ¹èŠ‚ç‚¹ï¼Œå¿…é¡»è¿™ä¹ˆåšçš„åŸå› æ˜¯åœ¨å¹³è¡¡æ ‘ä¸­ä¼šå‡ºç°æ ‘æ ¹æ”¹å˜çš„æƒ…å†µ const int INF = 2147483647; // å®šä¹‰ INF void build(void) &#123; newNode(-INF), newNode(INF); root = 1, T[1].r = 2; &#125; æ±‚æ’åï¼š int Rank(int p, int val) &#123; if (p == 0) return 1; // åªæœ‰åœ¨æ­¤ val ä¸å­˜åœ¨æ—¶æ‰ä¼šè®¿é—®åˆ° 0 å·èŠ‚ç‚¹ï¼Œæ ¹æ®å®šä¹‰ï¼Œæ’ååº”è¯¥ +1ï¼Œæ‰€ä»¥è¿”å› 1ã€‚ // åœ¨ä¸åŒæƒ…å†µä¸‹è¿™é‡Œä¼šè¿”å›ä¸åŒçš„å€¼ï¼Œæ¯”å¦‚å¦‚æœæ¬¡æ•°ä¸å­˜åœ¨è¾“å‡º -1 è¿™é‡Œå°±åº”è¯¥è¿”å› ERROR_BAD_USAGEï¼Œè‹¥æ•°ä¸å­˜åœ¨å°±ä¸ç”¨ +1ï¼Œåˆ™è¿”å› 0ã€‚ if (val == T[p].val) return T[T[p].l].size + 1; // æ‰¾åˆ°èŠ‚ç‚¹ï¼Œè¿”å› if (val &lt; T[p].val) return Rank(T[p].l, val); // å°ï¼Œåœ¨å·¦å­æ ‘ä¸­æ‰¾ return Rank(T[p].r, val) + T[T[p].l].size + T[p].cnt; // å¤§ï¼Œå³å­æ ‘æ‰¾ï¼Œæ³¨æ„è¦åŠ ä¸Šå·¦å­æ ‘å’Œæ­¤èŠ‚ç‚¹ &#125; æ±‚æ’åä¸º kkk çš„æ•°ï¼š int kth(int p, int rnk) &#123; if (p == 0) return INF; // 0 æ„å‘³ç€å½“å‰æ ‘ä¸Šçš„èŠ‚ç‚¹æ•°å°äº rnkï¼Œè¿”å› INF if (T[T[p].l].size >= rnk) return kth(T[p].l, rnk); // åœ¨å·¦å­èŠ‚ç‚¹ if (T[T[p].l].size + T[p].num >= rnk) return T[p].val; // å½“å‰èŠ‚ç‚¹ return kth(T[p].r, rnk - T[T[p].l].size - T[p].cnt); // å³å­èŠ‚ç‚¹ &#125; æ€ä¹ˆæŸ¥å‰é©±å‘¢ï¼Ÿåˆå§‹ ans = 1ï¼Œæ£€ç´¢ valï¼Œæœ‰ä¸‰ç§å¯èƒ½çš„ç»“æœï¼š BST ä¸­æ²¡æœ‰ valã€‚åç»§ä¸€å®šåœ¨å·²ç»éå†çš„èŠ‚ç‚¹ä¸­ï¼Œè¿™ä¸€ç‚¹å¯ä»¥ç”¨å¾®æ‰°æ¥è¯æ˜ã€‚ æœ‰ val èŠ‚ç‚¹ï¼Œä½†æ˜¯è¿™ä¸ªèŠ‚ç‚¹æ²¡æœ‰å³å­æ ‘ã€‚è¿™ç§æƒ…å†µçš„ç­”æ¡ˆåŒ 1ã€‚ æœ‰ val èŠ‚ç‚¹ï¼Œæœ‰å³å­æ ‘ã€‚ç­”æ¡ˆæ˜¯å³å­æ ‘çš„æœ€ä½ç«¯ã€‚ ä»£ç ï¼ˆè¯·è¯»è€…è‡ªè¡Œå®ç°åç»§ï¼‰ï¼š inline int GetPre(int val) &#123; int ans = 1, p = root; // T[1].val == -INF while (p) &#123; if (val == T[p].val) &#123; if (T[p].l) &#123; // å­˜åœ¨å·¦å­èŠ‚ç‚¹ p = T[p].l; while (T[p].r) p = T[p].r; // ä½¿åŠ²å¾€å³èµ° ans = p; &#125; break; &#125; if (T[p].val &lt; val &amp;&amp; T[p].val > T[ans].val) ans = p; // å°è¯•æ›´æ–° ans p = val &lt; T[p].val ? T[p].l : T[p].r; // éå† &#125; return T[ans].val; &#125; å½“ç„¶å‰é©±å’Œåç»§ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ Rank å’Œ kth å‡½æ•°å®ç°ï¼Œå¤§æ¦‚åƒè¿™æ ·ï¼š kth(root, Rank(root, x) - 1) // å‰é©± kth(root, Rank(root, x) + 1) // åç»§ï¼Œä½†æ˜¯åº”è¯¥å†™æˆ kth(root, Rank(root, x + 1)) ç”±äºè¿™é‡Œæ˜¯ä¸¥æ ¼å¤§äºå’Œä¸¥æ ¼å°äºï¼Œæ‰€ä»¥è¯´æ’åä¸èƒ½ç®€å•åœ°å†™æˆ +1ï¼Œè¾¹ç•Œæ¡ä»¶éå¸¸å®¹æ˜“å†™é”™ï¼Œæ‰€ä»¥è¿˜æ˜¯æ¨èå¤§å®¶æ¥å†™å‰é©±åç»§å‡½æ•°ã€‚ä¹Ÿå¯ä»¥ä»¥é‡‡ç”¨é€’å½’çš„å½¢å¼ï¼š int GetPre(int p, int k) &#123; if (!p) return -INF; if (T[p].val >= k) return GetPre(T[p].ch[0], k); return max(T[p].val, GetPre(T[p].ch[1], k)); &#125; æ’å…¥çš„ä»£ç éå¸¸å¥½å†™ï¼š void insert(int &amp;p, int val) // p æ˜¯çˆ¶äº²èŠ‚ç‚¹ &#123; if (p == 0) return p = newNode(val), void(); if (val == T[p].val) &#123; // æœ‰è¿™ä¸€é”®å€¼ ++T[p].cnt; // å°†ä¸ªæ•°åŠ ä¸Š 1 maintain(p); return; &#125; // æ¥ä¸‹æ¥çœ‹å®ƒæ˜¯åœ¨å·¦å­æ ‘è¿˜æ˜¯åœ¨å³å­æ ‘ if (val &lt; T[p].val) insert(T[p].l, val); // æ ¹æ® BST çš„å®šä¹‰ï¼Œåœ¨å·¦å­æ ‘ else insert(T[p].r, val); // åœ¨å³å­æ ‘ maintain(p); // ç”±äºè¿›è¡Œäº†æ’å…¥ï¼Œå½“å‰èŠ‚ç‚¹çš„ä¿¡æ¯éœ€è¦é‡æ–°è®¡ç®— &#125; æ³¨æ„æˆ‘ä»¬åœ¨æœ‰è¿™ä¸€é”®å€¼çš„æ—¶å€™å¹¶æ²¡æœ‰é‡æ–°è®¡ç®—çˆ¶äº²èŠ‚ç‚¹ï¼Œå› ä¸ºæ’å…¥æ˜¯é€’å½’è¿›è¡Œçš„ï¼Œçˆ¶äº²èŠ‚ç‚¹çš„é™„åŠ ä¿¡æ¯ä¸€å®šä¼šè¢«é‡æ–°è®¡ç®—ã€‚ å¹³è¡¡ BST ä½†æ˜¯è¿™æ ·çš„ BST çš„æ—¶é—´å¤æ‚åº¦æ˜¯å‡çš„ï¼Œå› ä¸ºå¦‚æœæ’å…¥ 1 2 3 4 5 6 7ï¼Œå®ƒå°±ä¼šå˜æˆä¸€æ¡é“¾ã€‚ ç®€ä»‹ è¡¨è¾¾åŒç§æ„æ€çš„ BST æœ‰å¤šç§ï¼Œæœ‰å¹³è¡¡çš„ï¼Œæœ‰ä¸å¹³è¡¡çš„ã€‚åœ¨æ•°æ®éšæœºçš„æƒ…å†µä¸‹ï¼Œå®ƒå°±æ˜¯å¹³è¡¡çš„ã€‚ä¸å¹³è¡¡æ€ä¹ˆåŠï¼Ÿç»™ä»–ææˆå¹³è¡¡çš„å‘—ã€‚ é‚£ä¸ºä»€ä¹ˆå¹³è¡¡æ ‘æœ‰å¿«æœ‰æ…¢å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºï¼Œè¶Šå¿«çš„å¹³è¡¡æ ‘èƒ½ä½¿å¹³è¡¡æ ‘è¶Šæ»¡ã€‚ä½†æœ‰äº›å¹³è¡¡æ ‘å®ç°è¿‡äºå¤æ‚ï¼Œæ¯”å¦‚çº¢é»‘æ ‘ï¼ˆRed-Black Treeï¼Œç®€ç§° RBTï¼‰ï¼Œå®ƒçš„æ’å…¥æœ‰ 555 ç§æƒ…å†µï¼Œåˆ é™¤æœ‰ 666 ç§æƒ…å†µï¼Œåœ¨è€ƒåœºä¸Šæ ¹æœ¬æ‰“ä¸å‡ºæ¥ï¼ˆå½“ç„¶å·¥ç¨‹ä¸­ä½ å¿…é¡»æ‰“ï¼‰ï¼Œæ‰€ä»¥ä¸€èˆ¬æƒ…å†µä¸‹æˆ‘ä»¬ä¸ä½¿ç”¨çº¢é»‘æ ‘ã€‚ ä½†è¦æ³¨æ„çš„æ˜¯ï¼Œå°½é‡ä¸è¦åœ¨è€ƒåœºæ‰‹å†™ä¸Šå†™å¹³è¡¡æ ‘ã€‚è‹¥ STL èƒ½æ»¡è¶³è¦æ±‚ï¼Œå°±ä½¿ç”¨ STLã€‚STL çš„çº¢é»‘æ ‘å¼€äº† O2 ä»¥åï¼Œè·‘å¾—æ¯”å¤§å¤šæ•°æ‰‹å†™å¹³è¡¡æ ‘éƒ½è¦å¿«ï¼ˆä¸ä¿¡ä½ å¯ä»¥å­¦å®Œå¹³è¡¡æ ‘åè‡ªå·±å®ç°ä¸€ä¸ªå±±å¯¨ç‰ˆçš„ set æ¥å’Œ STL æ¯”æ¯”é€Ÿåº¦ï¼‰ã€‚å°½é‡ä¸è¦è‡ªå·±å†é€ è½®å­ï¼Œé€ ä¸å¥½å°±è¢«ç¢¾ç€è…¿äº†ã€‚ åœ¨å·¥ç¨‹ä¸­ï¼Œå¸¸ç”¨çš„å¹³è¡¡æ ‘æ˜¯ AVLã€RBT å’Œ B æ ‘ï¼ˆB æ ‘ä¸æ˜¯äºŒå‰æ ‘ï¼Œè€Œæ˜¯å¤šå‰çš„ï¼‰ï¼›è€Œåœ¨ç«èµ›ä¸­ï¼Œå¸¸ç”¨çš„åˆ™æ˜¯ Treap å’Œ Splayï¼ˆä¼¸å±•æ ‘ï¼‰ã€‚å½“ç„¶è¿˜æœ‰è¯¸å¦‚ WBLTï¼Œæ›¿ç½ªç¾Šæ ‘ç­‰å¹³è¡¡æ ‘ã€‚æœ¬æ–‡ä¼šä»‹ç»æ—‹è½¬ Treapã€Splay å’Œéæ—‹ Treapï¼ˆFHQ-Treapï¼‰ã€‚ å¹³è¡¡çš„æ€è·¯ æœ‰ä¸‰ç§ï¼šæ—‹è½¬ï¼Œåˆ†è£‚ä¸åˆå¹¶ï¼Œé‡æ„ã€‚ ä½†å®ƒä»¬çš„ç›®çš„éƒ½æ˜¯ç›¸åŒçš„ï¼šå¹³è¡¡æˆ‘ä»¬çš„äºŒå‰æœç´¢æ ‘ã€‚ å¯¹äºæ—‹è½¬ï¼Œæœ‰å•æ—‹è½¬å’ŒåŒæ—‹è½¬ã€‚å•æ—‹æŒ‡ä¸€ä¸ªèŠ‚ç‚¹å’Œå®ƒçš„çˆ¶äº²è½¬ï¼ŒåŒæ—‹è¿˜ä¼šæ¶‰åŠåˆ°å®ƒçš„çˆ·çˆ·ã€‚ ä¸‹é¢å°†ä»‹ç»å‡ ç§æœ€ä¸ºå¸¸ç”¨çš„å¹³è¡¡æ ‘ã€‚ Treap è¿™æ˜¯ä¸€ç§æœ€åŸºç¡€çš„å¹³è¡¡æ ‘ï¼Œä»£ç ä¸æ™®é€šçš„äºŒå‰æœç´¢æ ‘å·®ä¸äº†å¤šå°‘ã€‚ä½†å¦‚æœè¦å®ç°åæ¬¡æ ‘ï¼Œå®ƒçš„é€Ÿåº¦æ˜¯éå¸¸å¿«çš„ï¼ˆOI ä¸­å¸¸ç”¨çš„å¹³è¡¡æ ‘ä¸­æœ€å¿«ï¼‰ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬è¦ç”¨ Treap å®ç°åæ¬¡æ ‘ï¼ˆå› ä¸ºæ‰€æœ‰æ“ä½œéƒ½æ˜¯å›´ç»•æ’åæ¥è¿›è¡Œçš„ï¼Œæ‰€ä»¥å«åšåæ¬¡æ ‘ï¼‰ï¼Œæ¨¡æ¿ã€‚ åŸç† Treap æ˜¯ä¸€ç§å¼±å¹³è¡¡ BSTï¼ˆæ˜¯æŒ‡ä¸ä¼šä¸ºäº†æŠŠè‡ªå·±ææˆé™¤äº†æœ€åä¸€å±‚ä¸æ˜¯æ»¡çš„äºŒå‰æ ‘è€Œè¿‡å¤šçš„å˜æ¢è‡ªå·±çš„å½¢æ€ï¼ŒAVL ä¾¿æ˜¯ä¸¥æ ¼å¹³è¡¡æ ‘ï¼‰ï¼Œå®ƒæ˜¯ä¸€ä¸ªåˆæˆè¯ï¼Œæœ‰ Treap = Tree + Heapï¼Œæ‰€ä»¥ Treap åˆå«åšæ ‘å †ï¼ˆæ€ä¹ˆå¬ä¸Šå»é‚£ä¹ˆæç¬‘ï¼‰ã€‚ Treap æœ‰ä¸¤ç§å½¢å¼ï¼Œæ— æ—‹å¼æœ‰æ—‹è½¬å¼ã€‚æ— æ—‹å¼èƒ½åšåˆ°å¿«é€Ÿåˆ†è£‚ä¸åˆå¹¶ï¼Œå°±æ˜¯ FHQ-Treapã€‚ å›åˆ°åˆšæ‰æ‰€è¯´çš„æ ‘å †ä¸­ã€‚Treap é™¤äº†èŠ‚ç‚¹çš„æƒå€¼æ»¡è¶³äºŒå‰æœç´¢æ ‘æ€§è´¨ä»¥å¤–ï¼Œå®ƒçš„é™„åŠ æƒå€¼è¿˜æ»¡è¶³å †æ€§è´¨ï¼ˆè¿™é‡Œç»Ÿä¸€ä¸ºå¤§æ ¹å †æ€§è´¨ï¼‰ã€‚è¿™æ ·å°±å¯ä»¥è¯æ˜å¦‚æœæ¯ä¸ªèŠ‚ç‚¹çš„é™„åŠ æƒå€¼å…¨ä¸åŒï¼Œé‚£ä¹ˆ Treap çš„å½¢æ€æ˜¯å”¯ä¸€çš„ï¼ˆä½†ä¸ä¸€æ ·ä¹Ÿä¸å½±å“æˆ‘ä»¬å¹²æ´»ï¼‰ã€‚ æ™®é€šçš„ BST åœ¨éšæœºæƒ…å†µä¸‹å°±æ˜¯å¹³è¡¡çš„ã€‚Treap é€šè¿‡äººä¸ºåˆ¶é€ éšæœºï¼Œéšæœºèµ‹äºˆèŠ‚ç‚¹çš„é™„åŠ æƒå€¼ã€‚ç”±äºå †æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œæ‰€ä»¥ Treap æ˜¯æœŸæœ›å¹³è¡¡çš„ï¼Œå•æ¬¡æ“ä½œæœŸæœ›å¤æ‚åº¦ O(logâ¡n)O(\\log n)O(logn)ã€‚ ç†è®ºä¸Šåº”è¯¥æ²¡æœ‰æ¯’ç˜¤æ¥å¡ä½ ã€‚ å…³é”®æ˜¯æ—‹è½¬ï¼Œæ€ä¹ˆè½¬ï¼Ÿå¯ä»¥çœ‹è¿™å¼ å›¾ï¼š zig(y) ä»£è¡¨ y æ—‹è½¬å‰å¤„äºçˆ¶äº²èŠ‚ç‚¹ï¼Œç„¶åå³æ—‹è‡³å®ƒçš„å³å­èŠ‚ç‚¹ï¼›zag(x) æ˜¯å·¦æ—‹ï¼Œæ—‹è½¬åˆ°å®ƒçš„å·¦å­èŠ‚ç‚¹ã€‚åœ†å½¢ä»£è¡¨èŠ‚ç‚¹ï¼Œä¸‰è§’ä»£è¡¨å­æ ‘ã€‚ å½“ yyy å³æ—‹æ—¶ï¼Œå®ƒä¼šç§»åˆ°å®ƒçš„å³å­èŠ‚ç‚¹çš„ä½ç½®ï¼Œå°†ä»–å®ƒå·¦å­èŠ‚ç‚¹ xxx ç§»åˆ°å®ƒåŸæ¥çš„ä½ç½®ï¼Œè€Œç”±äº xxx çš„å³å­æ ‘ BBB ä¸èƒ½å†å±äº xxx äº†ï¼Œè€Œæ ¹æ® BST çš„å®šä¹‰ï¼ŒB&lt;yB&lt;yB&lt;yï¼Œæ‰€ä»¥ BBB å˜æˆäº† yyy çš„å·¦å­æ ‘ã€‚å¦å¤–ï¼Œå½“æ—‹è½¬ä¹‹åï¼Œxxx å’Œ yyy çš„é™„åŠ ä¿¡æ¯éƒ½éœ€è¦é‡æ–°è®¡ç®—ï¼Œè€Œä¸” yyy æ˜¯ xxx çš„å„¿å­ï¼Œæ‰€ä»¥å…ˆç»´æŠ¤ yyy å†ç»´æŠ¤ xxxã€‚ å·¦æ—‹ç±»ä¼¼ï¼Œè¿™é‡Œç•™ç»™è¯»è€…è‡ªå·±æ’•çƒ¤ã€‚ å®ç° æ¥ä¸‹æ¥æˆ‘ä»¬è¦å¹²ä¸€ä»¶å¤§äº‹ï¼šæ¨ç¿»æˆ‘ä»¬ä»¥å‰ BST çš„å†™æ³•ã€‚ ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºå®ƒå®åœ¨æ˜¯å¤ªå®¹æ˜“å‡ºé”™äº†ã€‚å¦‚æœä½ æ„Ÿè§‰å¾ˆéš¾æ¥å—ï¼Œæ²¡å…³ç³»ï¼Œåœ¨æ–‡ä¸­æˆ‘ä»¬è¿˜ä¼šä»‹ç»å„ç§å†™æ³•åŠå…¶ä¼˜åŠ£ã€‚ é¦–å…ˆæ˜¯èŠ‚ç‚¹çš„å®šä¹‰ï¼Œåƒè¿™æ ·ï¼š struct Node &#123; int ch[2]; // å·¦å³å„¿å­çš„ç¼–å· int val, dat; // é”®å€¼å’Œéšæœºæƒå€¼ int size, cnt; // å­æ ‘å¤§å°å’Œæ­¤èŠ‚ç‚¹çš„å€¼çš„ä¸ªæ•° &#125;T[maxn]; å¯ä»¥å‘ç°å˜åŒ–æ˜¯å°†å·¦å³å„¿å­å’Œåˆ°äº†ä¸€èµ·ã€‚è¿™æ˜¯ä¸ºäº†æ–¹ä¾¿å®ç°æ—‹è½¬ã€‚æ›´åŠ æ¿€è¿›çš„å†™æ³•æ˜¯: struct Node &#123; Node *ch[2]; // å·¦å³å„¿å­ int val, dat; int size, cnt; &#125;; çœ‹è§ä»€ä¹ˆäº†ï¼ŸæŒ‡é’ˆï¼Ÿçš„ç¡®å¦‚æ­¤ã€‚è¿™ç§æ–¹æ³•çš„å¥½å¤„å¤šå¤šï¼Œç¬¬ä¸€ä¼šä½¿ä½ çš„ä»£ç æ›´åŠ æµç•…ï¼Œä¸ä¼šå‡ºç°æ•°ç»„å¥—æ•°ç»„çš„çª˜å†µã€‚äºŒæ˜¯ä¼šèŠ‚çœä¸€äº›å†…å­˜ã€‚ä½†è€ƒè™‘åˆ°ç«èµ›ä¸­ä¸è¦ä½¿ç”¨æŒ‡é’ˆçš„åŸºæœ¬åŸåˆ™ï¼ˆè™½ç„¶å·¥ç¨‹ä¸­è¿™ç§å†™æ³•æ˜¯å¿…å¤‡çš„ï¼‰ï¼Œæ¥ä¸‹æ¥çš„ä»£ç ç»Ÿä¸€é‡‡ç”¨æ•°ç»„ä¼ªæŒ‡é’ˆçš„å½¢å¼ã€‚ å®é™…ä¸Šè¿˜æœ‰å¦ä¸€ç§è®°å½•èŠ‚ç‚¹çš„æ–¹å¼ï¼Œå°±æ˜¯å¤šè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²ã€‚è™½ç„¶è¿™ç§åšæ³•åœ¨ä¸‹æ–‡è¦ä»‹ç»çš„ä¼¸å±•æ ‘ä¸­æ¯”è¾ƒå¸¸è§ï¼Œä½†åœ¨ Treap ä¸­ï¼Œå®ƒçš„ä¼˜ç‚¹æ˜¯æ—‹è½¬æ—¶å¯ä»¥æ›´è‡ªç„¶çš„å¯¹ä¸€ä¸ªèŠ‚ç‚¹è¿›è¡Œæ—‹è½¬ï¼Œè€Œä¸æ˜¯åœ¨å‡½æ•°è°ƒç”¨ä¸­å†™å…ˆå®šä¹‰å¥½çš„çˆ¶äº²ã€‚å¦‚æœä½ æƒ³å­¦ä¹ è¿™ç§å†™æ³•ï¼Œå­¦å®Œæ¥ä¸‹æ¥ä»‹ç»çš„ Splay åä½ å°±å¯ä»¥ç»™å®ƒè¿ç§»è¿‡æ¥è¾£ï¼ é¦–å…ˆæ˜¯ä¸€äº›åŸºæœ¬å®šä¹‰ï¼Œå¦‚ä¸‹ï¼š Node T[100005]; int tot; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + T[p].cnt; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(); T[tot].size = T[tot].cnt = 1; return tot; &#125; å”¯ä¸€å€¼å¾—æ³¨æ„çš„æ˜¯ dat å€¼çš„è®¾ç½®ï¼Œéšæœºä¸€ä¸ªæ•°å³å¯ã€‚ ç„¶åæ˜¯æ—‹è½¬ã€‚æ—‹è½¬çš„åŸç†å·²ç»äº†è§£è¿‡äº†ï¼Œè¿™é‡Œå†æ¬¡æ”¾å‡ºé‚£å¼ å›¾ï¼Œç„¶åç›´æ¥é˜…è¯»ä¸‹é¢çš„ä»£ç ï¼ˆåŒæ—¶è¿›è¡Œæ‰‹åŠ¨æ¨¡æ‹Ÿï¼Œå¯¹ç€æ¯ä¸ªèŠ‚ç‚¹è½¬ï¼Œå°±æ˜¯æ”¹å˜è¿™ä¸ªèŠ‚ç‚¹çš„ä¿¡æ¯ï¼Œä¸è¦å¯¹ç€å›¾ä¸­çš„ä½ç½®è½¬ï¼‰ï¼š å½“ yyy å³æ—‹æ—¶ï¼Œå®ƒä¼šç§»åˆ°å®ƒçš„å³å­èŠ‚ç‚¹çš„ä½ç½®ï¼Œå°†ä»–å®ƒå·¦å­èŠ‚ç‚¹ xxx ç§»åˆ°å®ƒåŸæ¥çš„ä½ç½®ï¼Œè€Œç”±äº xxx çš„å³å­æ ‘ BBB ä¸èƒ½å†å±äº xxx äº†ï¼Œè€Œæ ¹æ® BST çš„å®šä¹‰ï¼ŒB&lt;yB&lt;yB&lt;yï¼Œæ‰€ä»¥ BBB å˜æˆäº† yyy çš„å·¦å­æ ‘ã€‚å¦å¤–ï¼Œå½“æ—‹è½¬ä¹‹åï¼Œxxx å’Œ yyy çš„é™„åŠ ä¿¡æ¯éƒ½éœ€è¦é‡æ–°è®¡ç®—ï¼Œè€Œä¸” yyy æ˜¯ xxx çš„å„¿å­ï¼Œæ‰€ä»¥å…ˆç»´æŠ¤ yyy å†ç»´æŠ¤ xxxã€‚ zig(y) ä»£è¡¨ y æ—‹è½¬å‰å¤„äºçˆ¶äº²èŠ‚ç‚¹ï¼Œç„¶åå³æ—‹è‡³å®ƒçš„å³å­èŠ‚ç‚¹ï¼›zag(x) æ˜¯å·¦æ—‹ï¼Œæ—‹è½¬åˆ°å®ƒçš„å·¦å­èŠ‚ç‚¹ã€‚åœ†å½¢ä»£è¡¨èŠ‚ç‚¹ï¼Œä¸‰è§’ä»£è¡¨å­æ ‘ã€‚ inline void rotate(int &amp;p, int d) // ç»•ç€ p ç‚¹æ—‹è½¬ï¼Œd = 0 å·¦æ—‹ï¼Œd = 1 å³æ—‹ï¼Œd^1 = 1-d &#123; int q = T[p].ch[d^1]; // æ‰¾åˆ° p çš„å„¿å­ï¼Œè¿™ä¸ªå„¿å­å°†è¦æ—‹è½¬åˆ°æ ¹ä¸Š T[p].ch[d^1] = T[q].ch[d]; // æ¥ä¸‹è‡ªå·±çš„å„¿å­è¦ä¸¢çš„å„¿å­ï¼Œå› ä¸ºè‡ªå·±è¦å˜æˆè‡ªå·±çš„å„¿å­çš„å„¿å­äº† T[q].ch[d] = p; // åŸæ¥å„¿å­çš„å„¿å­è®¾ä¸ºåŸæ¥çš„çˆ¸çˆ¸ p = q; // åŸæ¥çš„å„¿å­æ­£å¼ç™»ä¸Šçˆ¸çˆ¸çš„å®åº§ï¼Œæ³¨æ„ p æ˜¯å¼•ç”¨ maintain(T[p].ch[d]), maintain(p); // ä»ä¸‹åˆ°ä¸Šé‡æ–°è®¡ç®—é™„åŠ ä¿¡æ¯ &#125; æ³¨æ„æŸäº›èŠ‚ç‚¹æ—‹è½¬åï¼Œé™„åŠ èŠ‚ç‚¹çš„ä¿¡æ¯å°±å¿…é¡»é‡æ–°è®¡ç®—ï¼Œè€Œä¸”è¦æ³¨æ„è®¡ç®—é¡ºåºã€‚ä½†æŸäº›æ–‡ç« ä½ ä¼šçœ‹åˆ°ç±»ä¼¼è¿™æ ·çš„æ—‹è½¬ï¼š inline void zig(int &amp;p) // å³æ—‹ &#123; int q = T[p].l; T[p].l = T[q].r, T[q].r = p, p = q; maintain(T[p].r), maintain(p); &#125; inline void zag(int &amp;p) // å·¦æ—‹ &#123; int q = T[p].r; T[p].r = T[q].l, T[q].l = p, p = q; maintain(T[p].l), maintain(p); &#125; è¿™ä¹Ÿæ˜¯å¯¹çš„ï¼Œä½†æ˜¯æŠŠä¸€ä¸ªå‡½æ•°å°±èƒ½å®Œæˆçš„å†…å®¹æ‹†åˆ°ä¸¤ä¸ªå‡½æ•°é‡Œå®å±éº»çƒ¦ï¼Œè€Œä¸”åˆ°åæ¥ä½ ä¼šå‘ç°ï¼Œzig zag å°±æ˜¯ä¸ªå±å‘ï¼Œåƒä¸‡åˆ«è·³ï¼Œåƒä¸‡åˆ«è·³ï¼Œåƒä¸‡åˆ«è·³ï¼Œä¸‰ä½“è­¦å‘Šã€‚ ç„¶åæ˜¯æ’å…¥æ“ä½œï¼Œåªéœ€è¦åœ¨ä¸ç¬¦åˆå †æ€§è´¨çš„æ—¶å€™è¿›è¡Œæ—‹è½¬ç»´æŠ¤å †æ€§è´¨å³å¯ï¼Œä»£ç å¦‚ä¸‹ï¼š void insert(int &amp;p, int val) &#123; if (p == 0) // æ­¤èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œç›´æ¥æ–°å»º &#123; p = newNode(val); return; &#125; if (val == T[p].val) ++T[p].cnt; // å­˜åœ¨è¿™ä¸€é”®å€¼ï¼Œè®¡æ•° +1 else &#123; // è¿™ç§æ–¹å¼èƒ½æå¤§åœ°ç®€åŒ–ä»£ç  int d = (val &lt; T[p].val ? 0 : 1); insert(T[p].ch[d], val); if (T[T[p].ch[d]].dat > T[p].dat) rotate(p, d^1); // ä¸ç¬¦åˆå †æ€§è´¨ï¼Œå„¿å­æ¯”çˆ¶äº²å¤§ï¼Œå°†å„¿å­è½¬åˆ°çˆ¶äº²çš„ä½ç½®ä¸Š &#125; maintain(p); &#125; å¸¸è§„çš„ Rank kth GetPre GetNext æ“ä½œå’Œæ™®é€š BST æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Œç•™ç»™è¯»è€…è‡ªè¡Œå®ç°ã€‚ æœ€åæ˜¯ Remove æ“ä½œã€‚ä¸ºä»€ä¹ˆæ™®é€š BST æ²¡æœ‰ Remove æ“ä½œå‘¢ï¼Ÿå› ä¸º Remove æ“ä½œæ„å‘³ç€å¯¹äºŒå‰æœç´¢æ ‘æ€§è´¨çš„å¤æ‚ç»´æŠ¤ã€‚ä½†æ˜¯ Treap ä¸ä¸€æ ·ï¼Œå®ƒæ”¯æŒæ—‹è½¬ã€‚æˆ‘ä»¬åªéœ€è¦æŠŠè¦åˆ é™¤çš„èŠ‚ç‚¹è½¬æˆå¶å­èŠ‚ç‚¹ï¼Œç„¶åç›´æ¥åˆ é™¤å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š void Remove(int &amp;p, int val) &#123; if (p == 0) return; if (T[p].val == val) &#123; if (T[p].cnt > 1) // è¿™ä¸ªèŠ‚ç‚¹å¤šäº 1 &#123; --T[p].cnt; maintain(p); return; &#125; if (T[p].ch[0] || T[p].ch[1]) &#123; int d = (T[p].ch[1] == 0 || T[T[p].ch[0]].dat > T[T[p].ch[1]].dat) ? 1 : 0; // ç»´æŠ¤å¤§æ ¹å †æ€§è´¨çš„å‰æä¸‹é€‰æ‹©è½¬åˆ°å“ªä¸ªæ–¹å‘ rotate(p, d); // å°†è¦åˆ é™¤çš„èŠ‚ç‚¹ p è½¬åˆ°å„¿å­çš„ä½ç½®ä¸Š Remove(T[p].ch[d], val); maintain(p); // æ­¤æ—¶èŠ‚ç‚¹çš„é™„åŠ ä¿¡æ¯è¦é‡æ–°è®¡ç®— &#125; else p = 0; // å¶å­èŠ‚ç‚¹ç›´æ¥åˆ é™¤ return; &#125; Remove(T[p].ch[val &lt; T[p].val ? 0 : 1], val); // é€’å½’åˆ é™¤ maintain(p); &#125; åˆå¹¶åä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 2147483647; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; struct Node &#123; int ch[2]; int val, dat; int size, cnt; &#125;; class Treap &#123; private: Node T[1100005]; int tot; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + T[p].cnt; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(); T[tot].size = T[tot].cnt = 1; return tot; &#125; inline void rotate(int &amp;p, int d) &#123; int q = T[p].ch[d^1]; T[p].ch[d^1] = T[q].ch[d], T[q].ch[d] = p, p = q; maintain(T[p].ch[d]), maintain(p); &#125; public: int root; inline void build(void) &#123; srand(time(0)); // ä¸å†™è¿™ä¸ªï¼Œå°å¿ƒæ¯’ç˜¤ Hack ä½  newNode(-INF), newNode(INF); T[1].ch[1] = 2, root = 1; maintain(root); &#125; void insert(int &amp;p, int val) &#123; if (p == 0) &#123; p = newNode(val); return; &#125; if (val == T[p].val) ++T[p].cnt; else &#123; int d = (val &lt; T[p].val ? 0 : 1); insert(T[p].ch[d], val); if (T[T[p].ch[d]].dat > T[p].dat) rotate(p, d^1); &#125; maintain(p); &#125; int Rank(int p, int val) &#123; if (p == 0) return 1; if (val == T[p].val) return T[T[p].ch[0]].size + 1; if (val &lt; T[p].val) return Rank(T[p].ch[0], val); return Rank(T[p].ch[1], val) + T[T[p].ch[0]].size + T[p].cnt; &#125; int kth(int p, int rnk) &#123; if (p == 0) return INF; if (rnk &lt;= T[T[p].ch[0]].size) return kth(T[p].ch[0], rnk); if (rnk &lt;= T[T[p].ch[0]].size + T[p].cnt) return T[p].val; return kth(T[p].ch[1], rnk - T[T[p].ch[0]].size - T[p].cnt); &#125; inline int GetPre(int val) &#123; int ans = 1, p = root; while (p) &#123; if (val == T[p].val) &#123; if (T[p].ch[0]) &#123; p = T[p].ch[0]; while (T[p].ch[1]) p = T[p].ch[1]; ans = p; &#125; break; &#125; if (T[p].val &lt; val &amp;&amp; T[p].val > T[ans].val) ans = p; p = T[p].ch[val &lt; T[p].val ? 0 : 1]; &#125; return T[ans].val; &#125; inline int GetNext(int val) &#123; int ans = 2, p = root; while (p) &#123; if (val == T[p].val) &#123; if (T[p].ch[1]) &#123; p = T[p].ch[1]; while (T[p].ch[0]) p = T[p].ch[0]; ans = p; &#125; break; &#125; if (T[p].val > val &amp;&amp; T[p].val &lt; T[ans].val) ans = p; p = T[p].ch[val &lt; T[p].val ? 0 : 1]; &#125; return T[ans].val; &#125; inline void Remove(int &amp;p, int val) &#123; if (p == 0) return; if (T[p].val == val) &#123; if (T[p].cnt > 1) &#123; --T[p].cnt; maintain(p); return; &#125; if (T[p].ch[0] || T[p].ch[1]) &#123; int d = (T[p].ch[1] == 0 || T[T[p].ch[0]].dat > T[T[p].ch[1]].dat) ? 1 : 0; rotate(p, d); Remove(T[p].ch[d], val); maintain(p); &#125; else p = 0; return; &#125; Remove(T[p].ch[val &lt; T[p].val ? 0 : 1], val); maintain(p); &#125; &#125;T; int main(void) &#123; int n = read(), m = read(); T.build(); while (n--) T.insert(T.root, read()); int ans = 0, last = 0; while (m--) &#123; int opt = read(), x = read(); x ^= last; if (opt == 1) T.insert(T.root, x); else if (opt == 2) T.Remove(T.root, x); else if (opt == 3) last = T.Rank(T.root, x) - 1; else if (opt == 4) last = T.kth(T.root, x + 1); else if (opt == 5) last = T.GetPre(x); else last = T.GetNext(x); if (opt > 2) ans ^= last; &#125; printf(\"%d\\n\", ans); return 0; &#125; FHQ-Treap æ­£å¸¸çš„ Treap å¹¶ä¸æ”¯æŒåˆ†è£‚ä¸åˆå¹¶ï¼Œä½†æ˜¯ç”±èŒƒæµ©å¼ºæå‡ºçš„æ— æ—‹ Treap å¯ä»¥å¿«é€Ÿåœ°åˆ†è£‚ä¸åˆå¹¶ï¼Œå®ç° Splay çš„å¤§éƒ¨åˆ†åŠŸèƒ½ï¼Œè€Œä¸”æ•ˆç‡æ¯” Splay é«˜å¾ˆå¤šã€‚ è¿™ç§å¹³è¡¡æ ‘ç”šè‡³è¢«ç§°ä¸ºâ€œæœ€å¥½å†™çš„å¹³è¡¡æ ‘â€ï¼Œæƒ…å†µè¿œè¿œæ²¡æœ‰ Splay é‚£ä¹ˆå¤æ‚ã€‚ å®ç° æ‰€æœ‰ Treap çš„åŸºæœ¬æ¨¡æ¿éƒ½é€‚ç”¨ï¼Œä½†æ˜¯è¦æ³¨æ„ï¼Œæˆ‘ä»¬ä¸å†è®°å½•ä¸€ä¸ª valvalval å‡ºç°çš„æ¬¡æ•° cntcntcntï¼Œå› ä¸ºåŸºäºåˆ†è£‚ä¸åˆå¹¶å®ç°çš„å¹³è¡¡æ ‘æ²¡åŠæ³•ç®€å•çš„å®ç°æ‰¾çš„ä¸€ä¸ªèŠ‚ç‚¹çš„ä½ç½®ã€‚ä½†æ˜¯ä¸ç”¨æ‹…å¿ƒï¼Œå³ä½¿ä¸è®°å½• cntcntcntï¼Œæ ‘ä¸­çš„èŠ‚ç‚¹é”®å€¼å¯ä»¥é‡å¤ï¼Œå®ƒä¾ç„¶å¯ä»¥æ­£å¸¸å·¥ä½œã€‚ struct Node &#123; int ch[2]; int size; int val, dat; &#125; T[1100005]; int tot = 0; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + 1; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(), T[tot].size = 1; return tot; &#125; int main(void) &#123; srand(time(0)); &#125; åˆ†è£‚ä¸åˆå¹¶ ç”±äº FHQ å¹¶ä¸æ”¯æŒæ—‹è½¬ï¼Œæ‰€ä»¥ä¸€åˆ‡ç»´æŠ¤å¹³è¡¡çš„æ‰‹æ®µéƒ½ä¾èµ–äºåˆ†è£‚ä¸åˆå¹¶ï¼Œå…¶æ—¶é—´å¤æ‚åº¦å‡ä¸º O(logâ¡n)O(\\log n)O(logn)ã€‚ ä»€ä¹ˆæ˜¯å¹³è¡¡æ ‘çš„åˆ†è£‚ä¸åˆå¹¶å‘¢ï¼Ÿç®€å•åœ°è¯´ï¼Œä¹‹å‰çš„å¹³è¡¡æ ‘ä¹‹èƒ½æœ‰ä¸€ä¸ªæ ¹ï¼Œä½†æ˜¯ç°åœ¨å¯ä»¥æœ‰å¤šä¸ªã€‚ç”±äº BST çš„é€’å½’æ€§è´¨ï¼Œæ‰€ä»¥å¯ä»¥å¾ˆæ–¹ä¾¿åœ°åˆå¹¶ä¸¤ä¸ª BSTã€‚ åˆ†è£‚ æŒ‰ val åˆ†è£‚ã€‚æŒ‰ç…§é”®å€¼ val å°† Treap åˆ†è£‚æˆä¸¤æ£µå­æ ‘ï¼Œå…¶ä¸­ä¸€æ£µæ ‘ xxx çš„å€¼å…¨éƒ¨å°äºç­‰äº valvalvalï¼Œå‰©ä¸‹çš„æ˜¯å¦å¤–ä¸€æ£µ yyy å…¨éƒ¨å¤§äº valvalval çš„ã€‚ å‡½æ•°å®šä¹‰ä¸º split(p, key, x, y)ï¼Œä»£è¡¨éå†åˆ° pppï¼Œæ ¹æ® keykeykey ä½œä¸ºé”®å€¼åˆ†è£‚æˆä¸¤æ£µå­æ ‘ x,yx,yx,yã€‚å…·ä½“æ€ä¹ˆåšå‘¢ï¼Ÿ å¦‚æœ val[p]â‰¤keyval[p]\\le keyval[p]â‰¤keyï¼Œé‚£ä¹ˆåº”è¯¥è¢«æ”¾åˆ° xxx ä¸Šï¼Œå¦åˆ™è¢«æ”¾åˆ° yyy ä¸Šã€‚è€Œæ”¾åœ¨å­æ ‘ä¸­çš„å…·ä½“å“ªä¸€ä¸ªä½ç½®ï¼Ÿå¾ˆæ˜¾ç„¶éœ€è¦é€’å½’è¿›è¡Œã€‚ void split(int p, int key, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); // ç©ºäº†ï¼Œåˆ†è£‚ä¹‹åéƒ½æ˜¯ 0 if (T[p].val &lt;= key) &#123; // p åº”è¯¥è¢«åˆ†è£‚åˆ° x ä¸Š x = p; // è®© p ä½œä¸º x çš„æ ¹ï¼Œç°åœ¨å·¦å­æ ‘å…¨å½’ x äº† split(T[p].ch[1], key, T[p].ch[1], y); // å¼€å§‹åˆ†è£‚å³å­æ ‘ï¼Œå³å­æ ‘ä¸­æœ‰ &lt;= key çš„åº”è¯¥ç»™ x çš„å³å­æ ‘ &#125; else &#123; y = p; split(T[p].ch[0], key, x, T[p].ch[0]); &#125; maintain(p); // å½“å‰èŠ‚ç‚¹çš„ä¿¡æ¯éœ€è¦é‡æ–°è®¡ç®— &#125; æŒ‰ size åˆ†è£‚ã€‚æŒ‰ç…§å­æ ‘çš„å¤§å°ï¼Œå‰ sizsizsiz ç»™ xxxï¼Œå‰©ä½™çš„ç»™ yyyï¼Œä¹Ÿå¾ˆå®¹æ˜“å®ç°ã€‚ void split(int p, int siz, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[T[p].ch[0]].size + 1 &lt;= siz) &#123; // p åº”è¯¥è¢«åˆ†è£‚åˆ° x ä¸Š x = p; // è®© p ä½œä¸º x çš„æ ¹ï¼Œç°åœ¨å·¦å­æ ‘å…¨å½’ x äº† split(T[p].ch[1], siz - T[T[p].ch[0]].size - 1, T[p].ch[1], y); // å¼€å§‹åˆ†è£‚å³å­æ ‘ï¼Œå³å­æ ‘ä¸­åº”æœ‰ siz - p->l->size - 1 å½’ x &#125; else &#123; y = p; split(T[p].ch[0], siz, x, T[p].ch[0]); &#125; maintain(p); &#125; åˆå¹¶ åˆå¹¶çš„æ—¶å€™æ˜¾ç„¶è¦æ±‚ xxx ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½å°äº yyy ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åæ ¹æ® Treap çš„å †æ€§è´¨æ¥åˆ¤æ–­æ˜¯å°† xxx åˆå¹¶åˆ° yyy è¿˜æ˜¯å°† yyy åˆå¹¶åˆ° xxxã€‚ int merge(int x, int y) // è¦æ±‚ x ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½å°äº y ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ &#123; if (x == 0 || y == 0) return x + y; // æœ‰ä¸€æ£µæ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆè¿”å›å¦ä¸€æ£µ if (T[x].dat > T[y].dat) // éœ€è¦ç»´æŠ¤å¤§æ ¹å †æ€§è´¨ï¼Œå°† y åˆå¹¶åˆ° x &#123; T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; å®ç°åæ¬¡æ ‘ åˆ†è£‚ä¸åˆå¹¶æ˜¯ FHQ-Treap çš„æ ¸å¿ƒæ“ä½œï¼Œå‰©ä¸‹çš„æ‰€æœ‰æ“ä½œéƒ½åŸºäºåˆ†è£‚ä¸åˆå¹¶ã€‚ æ’å…¥ å°† keykeykey åˆ†è£‚å‡ºæ¥ï¼Œç„¶ååˆå¹¶ä¸‰æ¬¡å³å¯ã€‚ void insert(int key) &#123; int x, y; split(root, key - 1, x, y); // åˆ°æ—¶å€™ val çš„å·¦å­èŠ‚ç‚¹æ˜¯ xï¼Œå³å­èŠ‚ç‚¹æ˜¯ y root = merge(merge(x, newNode(key)), y); &#125; åˆ é™¤ åˆ†è£‚ä¸¤æ¬¡å°† keykeykey åˆ†è£‚å‡ºæ¥ï¼Œç„¶åè¿›è¡Œåˆ é™¤ã€‚ void Remove(int key) &#123; // å°† root æŒ‰ç…§ key åˆ†è£‚æˆ x, z // å°† x æŒ‰ç…§ key - 1 åˆ†è£‚æˆ x, y // è¿™æ—¶ x &lt; key, y = key, z > key // y ä¸­çš„åªéœ€è¦åˆ ä¸€ä¸ª // å¦‚æœåˆ å»æ‰€æœ‰çš„ï¼Œé‚£ä¹ˆåˆå¹¶æ—¶ç›´æ¥ root = merge(x, z) int x, y, z; split(root, key, x, z); split(x, key - 1, x, y); if (y) y = merge(T[y].ch[0], T[y].ch[1]); root = merge(merge(x, y), z); &#125; æ±‚æ’å å°† keykeykey åˆ†è£‚å‡ºæ¥ï¼Œç„¶åå°±æ˜¯ xxx æ ‘çš„å¤§å° +1 äº†ã€‚ int Rank(int key) &#123; int x, y, ans; split(root, key - 1, x, y); ans = T[x].size + 1; // æ’åç­‰äº &lt; key çš„ä¸ªæ•° +1 root = merge(x, y); // å†æŠŠå®ƒåˆå¹¶å›å»ï¼Œè¿˜åŸç°åœº return ans; &#125; æ±‚ k å° æœ‰ä¸¤ç§æ–¹å¼ï¼Œä½†æ˜¯æ¯”è¾ƒæ¨èç±»ä¼¼äºä¹‹å‰æ™®é€š BST çš„æ–¹å¼ã€‚ å¦ä¸€ç§æ˜¯åˆ©ç”¨åŸºäºå¤§å°çš„åˆ†è£‚ï¼Œä½†æ˜¯è¿™æ ·ä»£ç ä¼šå˜å¤šã€‚ å‰é©±åç»§ å¯¹äºå‰é©±ï¼Œå°†å°äºçš„åˆ†è£‚å‡ºæ¥ï¼Œç„¶åå†è¿™æ£µæ ‘ä¸Šå°½å¯èƒ½å¾€å³èµ°ã€‚åç»§å¤§è‡´åŒç†ã€‚ int GetPre(int key) &#123; int x, y, p, ans; split(root, key - 1, x, y); // æ‰¾åˆ°å°äºç­‰äºçš„ p = x; while (T[p].ch[1]) p = T[p].ch[1]; // å°½å¯èƒ½å¾€å³èµ° ans = T[p].val; // åœ¨è¿˜åŸç°åœºä¹‹å‰å…ˆè®°å½•ç­”æ¡ˆ root = merge(x, y); return ans; &#125; int GetNext(int key) &#123; int x, y, p, ans; split(root, key, x, y); p = y; while (T[p].ch[0]) p = T[p].ch[0]; ans = T[p].val; root = merge(x, y); return ans; &#125; æ€§èƒ½ FHQ-Treap é€šè¿‡å¹³è¡¡æ ‘æ¨¡æ¿çš„ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstdlib> #include &lt;ctime> using namespace std; struct Node &#123; int ch[2], size; int val, dat; &#125; T[1100005]; int tot = 0, root; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + 1; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(), T[tot].size = 1; return tot; &#125; void split(int p, int key, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[p].val &lt;= key) &#123; x = p; split(T[p].ch[1], key, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], key, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].dat > T[y].dat) &#123; T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; void insert(int key) &#123; int x, y; split(root, key - 1, x, y); root = merge(merge(x, newNode(key)), y); &#125; void Remove(int key) &#123; int x, y, z; split(root, key, x, z); split(x, key - 1, x, y); if (y) y = merge(T[y].ch[0], T[y].ch[1]); root = merge(merge(x, y), z); &#125; int Rank(int key) &#123; int x, y, ans; split(root, key - 1, x, y); ans = T[x].size + 1; root = merge(x, y); return ans; &#125; int kth(int rnk) &#123; int p = root; while (p) &#123; if (T[T[p].ch[0]].size + 1 == rnk) break; else if (T[T[p].ch[0]].size + 1 > rnk) p = T[p].ch[0]; else &#123; rnk -= T[T[p].ch[0]].size + 1; p = T[p].ch[1]; &#125; &#125; return T[p].val; &#125; int GetPre(int key) &#123; int x, y, p, ans; split(root, key - 1, x, y); p = x; while (T[p].ch[1]) p = T[p].ch[1]; ans = T[p].val; root = merge(x, y); return ans; &#125; int GetNext(int key) &#123; int x, y, p, ans; split(root, key, x, y); p = y; while (T[p].ch[0]) p = T[p].ch[0]; ans = T[p].val; root = merge(x, y); return ans; &#125; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int main(void) &#123; srand(time(0)); int n = read(), m = read(); while (n--) insert(read()); int ans = 0, last = 0; while (m--) &#123; int opt = read(), x = read(); x ^= last; if (opt == 1) insert(x); else if (opt == 2) Remove(x); else if (opt == 3) last = Rank(x); else if (opt == 4) last = kth(x); else if (opt == 5) last = GetPre(x); else last = GetNext(x); if (opt > 2) ans ^= last; &#125; printf(\"%d\\n\", ans); return 0; &#125; æµ‹è¯•æ€§èƒ½ä¹‹åå‘ç°ï¼ŒTreap ç”¨æ—¶ 9.78sï¼ŒFHQ-Treap ç”¨æ—¶ 12.60sï¼ŒFHQ è¿˜æ˜¯ä¼šæ…¢ä¸€äº›ï¼Œä¸è¿‡è¶³å¤Ÿäº†ã€‚ æ­£å¦‚æˆ‘ä»¬æ‰€è¯´ï¼ŒTreap æ˜¯ OI èŒƒå›´å†…èƒ½ç”¨åˆ°çš„æœ€å¿«çš„å¹³è¡¡æ ‘ï¼ŒFHQ ç»“åˆäº† Treap çš„ä¼˜ç‚¹å¹¶ä¸”æ”¯æŒ Splay çš„åˆ†è£‚ä¸åˆå¹¶ï¼Œæ˜¯å¾ˆæ£’çš„å¹³è¡¡æ ‘ã€‚ åˆ†è£‚ä¸åˆå¹¶çš„åºåˆ— FHQ å¯ä»¥ç”¨æ¥å®ç° Splay çš„å¿«é€Ÿåˆ†è£‚åˆå¹¶åŠŸèƒ½ã€‚ åŒºé—´ç¿»è½¬ æ¨¡æ¿ã€‚ æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹å¦‚ä½•å®ç°åˆ†è£‚ä¸åˆå¹¶çš„åºåˆ—ï¼šæˆ‘ä»¬åªéœ€è¦æŠŠåŒºé—´çš„ä¸‹æ ‡ä¾æ¬¡æ’å…¥ Treap ä¸­ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¸å†åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œä¸å†æ˜¯æ ¹æ®æƒå€¼è€Œå»ºç«‹å¹³è¡¡æ ‘ï¼Œåªæ˜¯åˆ©ç”¨äº†å®ƒä»¬èƒ½å¤Ÿåˆ†è£‚ä¸åˆå¹¶çš„ç‰¹æ€§ï¼Œæ­¤æ—¶èŠ‚ç‚¹çš„é”®å€¼åªæ˜¯è¡¨ç¤ºåºåˆ—ä¸­ä¸€ä¸ªæ•°çš„ç›¸åº”å¤§å°ï¼Œè€Œåºåˆ—çš„é¡ºåºç”± Treap çš„ä¸­åºéå†ä¿è¯ã€‚ åŒºé—´ç¿»è½¬çš„æ—¶å€™ï¼Œæˆ‘ä»¬æŒ‰ç…§å¤§å°åˆ†è£‚ä¸º [1,lâˆ’1],[l,r],[r+1,n][1,l-1],[l,r],[r+1,n][1,lâˆ’1],[l,r],[r+1,n]ï¼Œç„¶åç»™ä¸­é—´çš„æ ‘æ‰“ä¸Šä¸€ä¸ª revrevrev æ ‡è®°ï¼Œä»£è¡¨æ˜¯å¦å°†å·¦å³å„¿å­ç¿»è½¬ï¼ˆç”±äºä¸­åºéå†çš„æ€§è´¨ï¼Œå°†å·¦å³å„¿å­åè½¬åçš„åºåˆ—ä¾¿æ˜¯åŸåºåˆ—ï¼‰ï¼Œç„¶åæ“ä½œçš„æ—¶å€™è¦è¿›è¡Œ pushdownã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;random> #include &lt;ctime> using namespace std; struct Node &#123; int ch[2], siz, dat, id; bool rev; &#125; T[100005]; int tot = 0, root; mt19937 Rand(time(0)); void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + 1; &#125; int newNode(int id) &#123; T[++tot].id = id; T[tot].dat = Rand(); T[tot].siz = 1; return tot; &#125; void pushdown(int p) &#123; if (!T[p].rev) return; swap(T[p].ch[0], T[p].ch[1]); T[T[p].ch[0]].rev ^= 1; T[T[p].ch[1]].rev ^= 1; T[p].rev = 0; &#125; void print(int x) &#123; if (!x) return; pushdown(x); print(T[x].ch[0]); printf(\"%d \", T[x].id); print(T[x].ch[1]); &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); pushdown(p); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], S, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].dat > T[y].dat) &#123; pushdown(x); T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; pushdown(y); T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; void update(int l, int r) &#123; int x, y, z; split(root, l - 1, x, y); split(y, r - l + 1, y, z); T[y].rev ^= 1; root = merge(merge(x, y), z); &#125; int n, m; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) root = merge(root, newNode(i)); while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); update(l, r); &#125; print(root); putchar('\\n'); return 0; &#125; ä¸€èˆ¬åºåˆ—æ“ä½œ æ³¨æ„å»¶è¿Ÿæ ‡è®°çš„ä½¿ç”¨ï¼Œå¤§è‡´æ˜¯è·Ÿçº¿æ®µæ ‘ä¸€æ ·çš„ï¼Œè¦†ç›–å½“å‰èŠ‚ç‚¹çš„æ—¶å€™éœ€è¦ç›´æ¥ä¿®æ”¹å½“å‰èŠ‚ç‚¹çš„ç›¸å…³ä¿¡æ¯ã€‚ å†å°±æ˜¯å»ºæ ‘ï¼Œé‡‡ç”¨ç±»ä¼¼äºçº¿æ®µæ ‘çš„å»ºæ ‘æ–¹å¼å¯ä»¥ä½¿åˆå¹¶çš„æ“ä½œæ¬¡æ•°è¾¾åˆ°æœ€å°‘ã€‚ åˆç†åˆ©ç”¨åˆ†è£‚ä¸åˆå¹¶ï¼Œå°†æƒ³è¦æçš„ä¿¡æ¯ç›´æ¥åˆ†è£‚å‡ºæ¥å³å¯ï¼Œåˆå¹¶å¯ä»¥åˆç†å®‰æ’åºåˆ—çš„é¡ºåºã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 500000; mt19937 Rand(time(0)); struct Node &#123; int ch[2], siz, rnd, val; int sum, lmax, rmax, dat; bool rev, setv; &#125; T[500005]; int st[500005], tot, root, a[500005]; int newNode(int val) &#123; int p = st[tot--]; T[p].rnd = Rand(); T[p].siz = 1; T[p].ch[0] = T[p].ch[1] = T[p].rev = T[p].setv = 0; T[p].val = T[p].sum = T[p].dat = val; T[p].lmax = T[p].rmax = max(val, 0); return p; &#125; void maintain(int p) &#123; int l = T[p].ch[0], r = T[p].ch[1]; T[p].siz = T[l].siz + T[r].siz + 1; T[p].sum = T[l].sum + T[r].sum + T[p].val; T[p].lmax = max(T[l].lmax, T[l].sum + T[p].val + T[r].lmax); T[p].rmax = max(T[r].rmax, T[r].sum + T[p].val + T[l].rmax); T[p].dat = max(T[l].rmax + T[r].lmax, 0) + T[p].val; if (l) T[p].dat = max(T[p].dat, T[l].dat); if (r) T[p].dat = max(T[p].dat, T[r].dat); &#125; void cover(int p, int k) &#123; T[p].val = k; T[p].sum = k * T[p].siz; T[p].lmax = T[p].rmax = max(T[p].sum, 0); T[p].dat = max(T[p].sum, T[p].val); T[p].setv = 1; T[p].rev = 0; &#125; void rever(int p) &#123; swap(T[p].ch[0], T[p].ch[1]); swap(T[p].lmax, T[p].rmax); T[p].rev ^= 1; &#125; void pushdown(int p) &#123; if (!p) return; if (T[p].rev) &#123; if (T[p].ch[0]) rever(T[p].ch[0]); if (T[p].ch[1]) rever(T[p].ch[1]); T[p].rev = 0; &#125; if (T[p].setv) &#123; if (T[p].ch[0]) cover(T[p].ch[0], T[p].val); if (T[p].ch[1]) cover(T[p].ch[1], T[p].val); T[p].setv = 0; &#125; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); pushdown(p); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], S, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; pushdown(x); T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; pushdown(y); T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; void rmv(int x) &#123; st[++tot] = x; if (T[x].ch[0]) rmv(T[x].ch[0]); if (T[x].ch[1]) rmv(T[x].ch[1]); &#125; int add(int l, int r) &#123; if (l == r) return newNode(a[l]); int mid = l + r >> 1; return merge(add(l, mid), add(mid + 1, r)); &#125; int n, m; int main(void) &#123; for (int i = 1; i &lt;= N; ++i) st[++tot] = i; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); root = merge(root, add(1, n)); char op[15]; while (m--) &#123; scanf(\"%s\", op); if (op[0] == 'I') &#123; int l, cnt, x, y; scanf(\"%d%d\", &amp;l, &amp;cnt); split(root, l, x, y); for (int i = 1; i &lt;= cnt; ++i) scanf(\"%d\", a + i); root = merge(merge(x, add(1, cnt)), y); &#125; else if (op[0] == 'D') &#123; int l, cnt, x, y, z; scanf(\"%d%d\", &amp;l, &amp;cnt); split(root, l - 1, x, y); split(y, cnt, y, z); rmv(y); root = merge(x, z); &#125; else if (op[4] == '-') &#123; int l, cnt, k, x, y, z; scanf(\"%d%d%d\", &amp;l, &amp;cnt, &amp;k); split(root, l - 1, x, y); split(y, cnt, y, z); cover(y, k); root = merge(merge(x, y), z); &#125; else if (op[0] == 'R') &#123; int l, cnt, x, y, z; scanf(\"%d%d\", &amp;l, &amp;cnt); split(root, l - 1, x, y); split(y, cnt, y, z); rever(y); root = merge(merge(x, y), z); &#125; else if (op[0] == 'G') &#123; int l, cnt, x, y, z; scanf(\"%d%d\", &amp;l, &amp;cnt); split(root, l - 1, x, y); split(y, cnt, y, z); printf(\"%d\\n\", T[y].sum); root = merge(merge(x, y), z); &#125; else printf(\"%d\\n\", T[root].dat); &#125; return 0; &#125; Splay Splayï¼Œå°±æ˜¯å¤§åé¼é¼çš„â€œä¼¸å±•æ ‘ï¼ˆå› ä¸ºä¼¸å±•æ˜¯å®ƒæœ€ç»å…¸çš„æ“ä½œï¼‰â€ï¼Œä¹Ÿå«â€œè‡ªé€‚åº”æŸ¥æ‰¾æ ‘â€ã€‚1985 å¹´ç”± Daniel Sleator å’Œ Robert Endre Tarjanï¼ˆå¯¹ï¼Œå°±æ˜¯è¿™ä¸ªè‘—åçš„ Tarjanï¼‰å‘æ˜ã€‚ Splay çš„å¹³è¡¡æ–¹å¼æ˜¯é€šè¿‡æ—‹è½¬æ¥ä¼¸å±•ï¼ˆæœ‰æ—¶å€™å«åšâ€œææ ¹â€ï¼‰ï¼Œå³æŠŠä¸€ä¸ªå¶å­èŠ‚ç‚¹é€šè¿‡æ—‹è½¬æåˆ°æ ¹èŠ‚ç‚¹ã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼ŒSplay å…·æœ‰â€œè‡ªé€‚åº”æ€§â€ï¼Œå°±æ˜¯å®ƒä¼šæ ¹æ®ä½ çš„æ“ä½œè°ƒæ•´è‡ªèº«ç»“æ„ï¼Œä½¿å¾—æ¥ä¸‹æ¥çš„æŸ¥è¯¢å˜å¾—è¶Šæ¥è¶Šå¿«ï¼ˆåƒä¸åƒå¹¶æŸ¥é›†ï¼‰ã€‚ä½†å³ä½¿å¦‚æ­¤ï¼Œè¿™è´§è¿˜æ˜¯å¾ˆæ…¢ã€‚ ä¼¸å±•æ ‘æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿè™½ç„¶å®ƒå¯ä»¥ç”¨æ¥å®ç°åæ¬¡æ ‘ï¼Œä½†åœ¨ç«èµ›ä¸­è¦å®ç°åæ¬¡æ ‘çš„è¯ï¼Œè¿˜æ˜¯ä¹–ä¹–ç”¨ Treap å§ã€‚Splay çš„ä¼¸å±•æ“ä½œæœ€å¤§çš„ç”¨å¤„æ˜¯è¿›è¡Œå¿«é€Ÿåœ°åˆ†è£‚ä¸åˆå¹¶ï¼ˆå—¯ï¼Œå°±æ˜¯ fhq-treap å¹²çš„äº‹ï¼Œä½†å®è·µä¸­è¿˜æ˜¯ä¼¸å±•æ ‘ç”¨çš„æ›´å¤šï¼‰ã€‚ Splay åœ¨æ—‹è½¬æ—¶ä¼šæ¶‰åŠåˆ°èŠ‚ç‚¹çš„çˆ·çˆ·ï¼Œæ‰€ä»¥å®ƒæ˜¯åŒæ—‹å¹³è¡¡æ ‘ã€‚ ä¼¸å±•æ“ä½œ Splay çš„èŠ‚ç‚¹æ€ä¹ˆå®šä¹‰å‘¢ï¼Ÿä¸€èˆ¬æ¥è¯´æœ‰ä¸¤ç§æ–¹å¼ã€‚ç¬¬ä¸€ç§æ˜¯è®°å½•èŠ‚ç‚¹çš„çˆ¶äº²çš„ï¼Œå› ä¸ºï¼ˆå“ªæ¥é‚£ä¹ˆå¤šå› ä¸ºï¼Œè¿™ä¸æ˜¯ä¸Šæ–‡è¯´çš„å®šä¹‰å—ï¼‰ã€‚ç¬¬äºŒç§æ˜¯ä¸è®°å½•çˆ¶äº²çš„ã€‚ä½†æ˜¯ç¬¬ä¸€ç§ç›¸å¯¹æ¥è®²é€»è¾‘æ›´ä¸ºæ¸…æ™°ï¼ˆå°½ç®¡æ—‹è½¬æ“ä½œä¸­çš„ç¼–ç è¾ƒä¸ºå¤æ‚ï¼‰ï¼Œç¬¬äºŒç§åœ¨æŸäº›æƒ…å†µä¸‹ä¼šç”¨åˆ°ã€‚å› ä¸ºç¬”è€…æ˜¯å‚»ç“œï¼Œä¸ä¼šç¬¬äºŒç§ï¼Œæ‰€ä»¥è¿™é‡Œåªä»‹ç»ç¬¬ä¸€ç§æƒ…å†µã€‚ ä½†æ˜¯è¿™ä¹‹å‰ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ææ˜ç™½ Splay æœ€å…³é”®çš„æ“ä½œï¼šä¼¸å±•æ“ä½œï¼ˆsplay æ“ä½œï¼‰å¦‚ä½•è¿›è¡Œã€‚ splay æ“ä½œè¦åˆ†ä¸‰ç§æƒ…å†µè€ƒè™‘ã€‚ xxx çš„çˆ¶èŠ‚ç‚¹æ˜¯æ ¹èŠ‚ç‚¹ï¼Œè¿™æ—¶å€™è¿›è¡Œä¸€æ¬¡å•æ—‹è½¬å³å¯ï¼Œå°±å®Œæˆäº† splay æ“ä½œã€‚ xxxï¼Œå®ƒçš„çˆ¶èŠ‚ç‚¹å’Œå®ƒçš„çˆ·çˆ·â€œä¸‰ç‚¹å…±çº¿â€ï¼Œè¿™æ—¶è¿›è¡Œä¸¤æ¬¡æ–¹å‘ç›¸åŒçš„æ—‹è½¬æ“ä½œå³å¯ã€‚è€Œä¸”å…ˆè½¬ xxx çš„çˆ¶èŠ‚ç‚¹å†è½¬ xxxï¼› ä¸‰ç‚¹ä¸å…±çº¿ã€‚è¿™æ˜¯éœ€è¦å°† xxx è¿›è¡Œä¸åŒæ–¹å‘çš„ä¸¤æ¬¡æ—‹è½¬ã€‚ é€šè¿‡ä»¥ä¸Šæ–¹å¼æˆ‘ä»¬å°±èƒ½å®Œæˆ splay æ“ä½œå•¦ï¼ è¿™é‡Œå¯ä»¥è‡ªè¡Œç”»å›¾æ„Ÿå—ä¼¸å±•æ“ä½œçš„è¿‡ç¨‹ï¼Œä½¿å¾—æ›´å®¹æ˜“ç†è§£æ¥ä¸‹æ¥çš„å†…å®¹ã€‚ Splay å®é™…ä¸Šæœ‰ä¸¤ç§å†™æ³•ï¼Œç¬¬ä¸€ç§æ–¹æ³•çš„èŠ‚ç‚¹åƒè¿™æ ·å®šä¹‰ï¼š struct Node &#123; int ch[2], fa; int val; // otherthings, such as size and cnt &#125;; ç„¶åæˆ‘ä»¬è¦å®ç°ä¸€äº›åŸºæœ¬çš„æ¨¡æ¿ï¼Œå¦‚ä¸‹ï¼š class Splay &#123; private: Node T[100005]; int tot; /* inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + T[p].cnt; &#125; */ &#125;; æ€ä¹ˆå®ç°æ—‹è½¬å‘¢ï¼Ÿç”±äºæˆ‘ä»¬è®°å½•äº†çˆ¶äº²èŠ‚ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥æ¢ä¸€ç§æ–¹å¼å®šä¹‰æ—‹è½¬ï¼šå®šä¹‰ rotate(x) ä¸ºå°† xxx çš„çˆ¶äº²èŠ‚ç‚¹ä¸Šæ—‹åˆ° xxx çš„çˆ·çˆ·ã€‚æˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­å®ƒæ˜¯çˆ¶äº²èŠ‚ç‚¹çš„å·¦å„¿å­è¿˜æ˜¯å³å„¿å­ã€‚ inline int get(int x) &#123; return x == T[T[x].fa].ch[1]; &#125; æ—‹è½¬æ“ä½œè¦æ³¨æ„ï¼šå› ä¸ºæˆ‘ä»¬è®°å½•äº†çˆ¶äº²èŠ‚ç‚¹ï¼Œæ„å‘³ç€åœ¨æ—‹è½¬æ—¶éœ€è¦å¯¹æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²è¿›è¡Œç»´æŠ¤ã€‚ä½†åŒæ—¶æˆ‘ä»¬ä¹Ÿä¸éœ€è¦è€ƒè™‘æ—‹è½¬æ–¹å‘äº†ã€‚ inline void rotate(int x) &#123; // y: father, z: grandfather int y = T[x].fa, z = T[y].fa, d = get(x); // d æ˜¯å·¦å³å„¿å­ï¼Œä¸æ˜¯æ–¹å‘ T[y].ch[d] = T[x].ch[d^1]; if (T[x].ch[d^1]) T[T[x].ch[d^1]].fa = y; T[x].ch[d^1] = y, T[y].fa = x; // åŸæ¥çš„å„¿å­æŠŠåŸæ¥çš„çˆ¸çˆ¸å½“æˆå„¿å­ï¼ˆä¸Šæ—‹ï¼‰ // æ¥ä¸‹æ¥æŠŠæœ¬æ¥æ˜¯çˆ¸çˆ¸çš„ y çš„çˆ¸çˆ¸ç»™ x T[x].fa = z; if (z) T[z].ch[get(y)] = x; // æœ¬æ¥ z çš„å„¿å­æ˜¯ yï¼Œç°åœ¨å´å˜æˆäº† xã€‚å¦‚æœ z éƒ½ç­‰äº 0 äº†è¿˜æ”¹å°±æ²¡ä»€ä¹ˆæ„æ€äº†ï¼Œæ˜¯ä¸ï¼Ÿï¼ˆå†µä¸”æˆ‘ä»¬è¿˜è¦æ ¹æ®æ˜¯å¦ç­‰äº 0 æ¥åˆ¤æ–­çˆ¶äº²å­˜ä¸å­˜åœ¨ï¼‰ maintain(y), maintain(x); // ä»ä¸‹åˆ°ä¸Šé‡æ–°è®¡ç®— &#125; æ„Ÿè§‰å¾ˆç»•ï¼Ÿè¿˜æ˜¯å»ºè®®è‡ªè¡Œæ¨¡æ‹Ÿä¸€ä¸‹ã€‚ æœ‰äº†æ—‹è½¬æ“ä½œï¼Œå°±ä¸éš¾å®ç°ä¼¸å±•æ“ä½œäº†ã€‚ä¼¸å±•çš„åŸç†ä¹‹å‰å·²ç»è®²è¿‡ï¼Œè¿™é‡Œç›´æ¥ç»™å‡ºä»£ç ï¼š inline void splay(int x) // æŠŠ x ææ ¹ &#123; // å®šä¹‰ f ä¸º x çš„çˆ¸çˆ¸ // æˆ‘ä»¬éœ€è¦ä¿è¯ f å­˜åœ¨ï¼ˆå®ƒæ˜¯ 0 å°±ç»“æŸäº†ï¼‰æ‰èƒ½ç»§ç»­å¾ªç¯ // å¸¸è§„æ¥è®²ï¼Œæˆ‘ä»¬éœ€è¦ä¸Šæ—‹ x for (int f = T[x].fa; f = T[x].fa; rotate(x)) if (T[f].fa) // å¦‚æœ T[f].fa å­˜åœ¨ï¼Œå°±æ„å‘³ç€æ˜¯æƒ…å†µ 2 æˆ– 3ï¼Œéœ€è¦è¿›è¡Œç¬¬ä¸€æ¬¡æ—‹è½¬ &#123; rotate(get(x) == get(f) ? f : x); // å½“ get(x) == get(f) æ—¶ï¼Œæ„ä¸ºç€ä¸‰ç‚¹å…±çº¿ï¼Œè½¬ f // å¦åˆ™ä¸‰ç‚¹ä¸å…±çº¿ï¼Œè½¬ä¸¤æ¬¡ xï¼ˆè¿˜æœ‰ä¸€æ¬¡åœ¨å¾ªç¯æ›´æ–°å¤„ï¼‰ // è¿™é‡Œçš„å¾ªç¯é¡ºåºå¾ˆå·§å¦™ï¼Œä¿è¯å¤„ç†å®Œæƒ…å†µ 2 å’Œ 3 çš„ç‰¹åˆ«æ—‹è½¬æ”¾é€åï¼Œç«‹é©¬ä¼šè¿›è¡Œä¸€æ¬¡ rotate(x)ï¼ˆfor å¾ªç¯çš„æ›´æ–°ï¼‰ &#125; root = x; // æ ¹å˜æˆäº† x &#125; Splay çš„ç¬¬äºŒç§å†™æ³•ä¸è®°å½•èŠ‚ç‚¹çš„çˆ¶äº²ï¼Œè¿™æ—¶å°±å˜æˆäº†é€’å½’ç‰ˆçš„ Splayã€‚ç”±äºç¬”è€…å¾ˆå¼±ä¸ä¼šï¼Œæ‰€ä»¥æƒ³å­¦ä¹ è¿™ç§å†™æ³•è¯·å‚è€ƒã€Šç®—æ³•ç«èµ›å…¥é—¨ç»å…¸Â·è®­ç»ƒæŒ‡å—ã€‹ï¼Œæˆ–è€…ç½‘ä¸Šçš„å…¶å®ƒèµ„æ–™ã€‚å®é™…ä¸Šæœ¬æ–‡ä»‹ç»çš„è¿™ç§å†™æ³•é€»è¾‘æ›´ä¸ºæ¸…æ™°ï¼Œè¿™é‡Œåšæ— è€»æ¨èï¼ˆ æŸäº›æƒ…å†µä¸‹æˆ‘ä»¬ä¼šä½¿ç”¨æŒ‡é’ˆå®ç° Splayã€‚å®é™…ä¸Šç¬”è€…æ›´æ¨èæŒ‡é’ˆï¼Œä½†ä½ çš„ä»£ç å¿…é¡»èƒ½è·Ÿç°æœ‰çš„æ¨¡å—é›†æˆã€‚ç°åœ¨å¤§å¤šæ•°é€‰æ‰‹çš„ Splay éƒ½æ˜¯ç”¨æ•°ç»„ä¼ªæŒ‡é’ˆçš„å½¢å¼å†™çš„ï¼Œå¦‚æœä¸é‡‡ç”¨è¿™ç§å½¢å¼å¯èƒ½ä¼šåœ¨ä»Šåçš„å­¦ä¹ ä¸­é€ æˆå›°æ‰°ï¼Œæ‰€ä»¥è¿™é‡Œæ¨èå¤§å®¶ä½¿ç”¨ä¼ªæŒ‡é’ˆã€‚ ç”¨ Splay å®ç°åæ¬¡æ ‘ åæ¬¡æ ‘æœ€ç»ˆè¦çš„å°±æ˜¯è¦ä¿è¯å¹³è¡¡ã€‚ä½†æ˜¯ Splay æ€ä¹ˆä¿è¯å¹³è¡¡ï¼Ÿå¥½åƒå¾ˆéš¾æã€‚æƒ³æƒ³æˆ‘ä»¬ Treap æ˜¯æ€ä¹ˆæçš„å§ï¼ç”¨éšæœºæ¥åˆ›é€ å¹³è¡¡ã€‚é‚£æˆ‘ä»¬å°±éšæœºä¼¸å±•æ¥ä¿è¯å¹³è¡¡ã€‚ æ­¤å¤„åº”è¯¥æœ‰ BGMã€‚ ä¸è¦ç¬‘ï¼ŒçœŸæ˜¯è¿™ä¹ˆæã€‚å¬ä¸Šå»æ¯” Treap æ›´ä¸é è°±ï¼Ÿæˆ‘ä¹Ÿæ˜¯è¿™ä¹ˆè®¤ä¸ºçš„ã€‚è¿™é‡Œç”¨ Splay å®ç°åæ¬¡æ ‘ä»…ä»…æ˜¯ä½œä¸ºä¸€ä¸ªç»ƒä¹ ï¼Œè€ƒåœºä¸Šç”¨ Treap å°±å¥½ã€‚ æ‰€ä»¥ç»“è®ºæ˜¯ï¼šSplay å®ç°çš„åæ¬¡æ ‘ç…§æ ·æ˜¯å¼±å¹³è¡¡çš„éšæœºå¹³è¡¡æ ‘ï¼ˆè€Œä¸”æ¯” Treap è¿˜æ…¢ï¼‰ï¼Œä¸è¿‡ Treap åœ¨ç«èµ›ä¸­å·²ç»è¶³å¤Ÿç”¨äº†ï¼Œä¸å»ºè®®ä½œæ­»å»å­¦ RBTã€‚ æ³¨æ„åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œç”±äº Splay æ˜¯è®°å½•çˆ¶äº²çš„ï¼Œæ‰€ä»¥è¿™æ—¶å€™å¦‚æœæˆ‘ä»¬è¿˜ä½¿ç”¨é€’å½’ä»£ç å°±ä¼šå¾ˆéº»çƒ¦ï¼ˆéœ€è¦ä¼ çˆ¶äº²æˆ–è€…åˆ°å¤„éƒ½æ˜¯ get å‡½æ•°ï¼‰ï¼Œå°¤å…¶æ˜¯æ’å…¥æ“ä½œï¼Œè¿›è¡Œä¼¸å±•æ“ä½œå‰è¦å¯¹æ€§è´¨è¿›è¡Œç»´æŠ¤ï¼Œè€Œé€’å½’çš„ç»´æŠ¤ä¾èµ–äºé€’å½’æ€§è´¨ï¼Œæ‰€ä»¥è¿™æ—¶ä¸å¦‚ä½¿ç”¨è¿­ä»£ã€‚ ç”±äºå®ç°åˆ é™¤æ“ä½œéœ€è¦è¿ç”¨ä¼¸å±•æ ‘çš„åˆ†è£‚ä¸åˆå¹¶ï¼Œæ•…è¿™å›æˆ‘ä»¬å†™æœ€åˆçš„å¼±åŒ–ç‰ˆã€‚ å”¯ä¸€ä¸åŒçš„åªæœ‰æ’å…¥æ“ä½œï¼Œå‰©ä¸‹çš„ä»£ç éƒ½å¯ä»¥ç…§æ¬ã€‚æ’å…¥è¦è¿™æ ·è¿›è¡Œï¼šåŠ¨æ€è®°å½•å½“å‰èŠ‚ç‚¹å’Œå½“å‰èŠ‚ç‚¹çš„çˆ¶äº²ï¼Œå¦‚æœæ‰¾åˆ°äº†ä¸è¦æ’å…¥çš„å€¼ç›¸åŒçš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆ cnt++ï¼ŒåŒæ—¶ä¼¸å±•è¿™ä¸ªç‚¹ï¼›å¦åˆ™é€’å½’åœ°å¾€ä¸‹æ‰¾ï¼Œæ‰¾åˆ°äº†ç©ºèŠ‚ç‚¹å°±åˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œç„¶åä¼¸å±•è¿™ä¸ªç‚¹ï¼Œä»£ç å¦‚ä¸‹ï¼š inline void insert(int val) &#123; int cur = root, fa = 0; while (1) &#123; if (T[cur].val == val) // æ‰¾åˆ°äº†å€¼ç›¸ç­‰çš„èŠ‚ç‚¹ &#123; ++T[cur].cnt; maintain(cur); maintain(fa); // ä»¥ä¸Šä¸ºè¿›è¡Œç»´æŠ¤ splay(cur); // ä¼¸å±• return; &#125; fa = cur; cur = T[cur].ch[val > T[cur].val]; // å¾€ä¸‹èµ° if (cur == 0) &#123; newNode(val); // æ–°å»ºèŠ‚ç‚¹ // é‡æ–°è®¡ç®—çˆ¶å­å…³ç³»å’Œå­æ ‘å¤§å° T[tot].fa = fa; T[fa].ch[val > T[fa].val] = tot; maintain(fa); splay(tot); // ä¼¸å±• return; &#125; &#125; &#125; æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int INF = 0x7fffffff; struct Node &#123; int ch[2], fa; int val; int size, cnt; &#125;; class Splay &#123; public: int root; private: Node T[100005]; int tot; inline void newNode(int val) &#123; T[++tot].val = val; T[tot].size = T[tot].cnt = 1; &#125; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + T[p].cnt; &#125; inline int get(int x) &#123; return x == T[T[x].fa].ch[1]; &#125; inline void rotate(int x) &#123; int y = T[x].fa, z = T[y].fa, d = get(x); T[y].ch[d] = T[x].ch[d^1]; if (T[x].ch[d^1]) T[T[x].ch[d^1]].fa = y; T[x].ch[d^1] = y, T[y].fa = x; T[x].fa = z; if (z) T[z].ch[y == T[z].ch[1]] = x; maintain(y); maintain(x); &#125; inline void splay(int x) &#123; for (int f = T[x].fa; f = T[x].fa; rotate(x)) if (T[f].fa) rotate(get(x) == get(f) ? f : x); root = x; &#125; public: inline void build(void) &#123; newNode(-INF), newNode(INF); T[1].ch[1] = 2, T[2].fa = 1; maintain(root = 1); &#125; inline void insert(int val) &#123; int cur = root, fa = 0; while (1) &#123; if (T[cur].val == val) &#123; ++T[cur].cnt; maintain(cur); maintain(fa); splay(cur); return; &#125; fa = cur; cur = T[cur].ch[val > T[cur].val]; if (cur == 0) &#123; newNode(val); T[tot].fa = fa; T[fa].ch[val > T[fa].val] = tot; maintain(fa); splay(tot); return; &#125; &#125; &#125; int Rank(int p, int val) &#123; if (p == 0) return 1; if (val == T[p].val) return T[T[p].ch[0]].size + 1; if (val &lt; T[p].val) return Rank(T[p].ch[0], val); return Rank(T[p].ch[1], val) + T[T[p].ch[0]].size + T[p].cnt; &#125; int kth(int p, int rnk) &#123; if (p == 0) return INF; if (rnk &lt;= T[T[p].ch[0]].size) return kth(T[p].ch[0], rnk); if (rnk &lt;= T[T[p].ch[0]].size + T[p].cnt) return T[p].val; return kth(T[p].ch[1], rnk - T[T[p].ch[0]].size - T[p].cnt); &#125; inline int GetPre(int val) &#123; int ans = 1, p = root; while (p) &#123; if (val == T[p].val) &#123; if (T[p].ch[0]) &#123; p = T[p].ch[0]; while (T[p].ch[1]) p = T[p].ch[1]; ans = p; &#125; break; &#125; if (T[p].val &lt; val &amp;&amp; T[p].val > T[ans].val) ans = p; p = T[p].ch[val &lt; T[p].val ? 0 : 1]; &#125; return T[ans].val; &#125; inline int GetNext(int val) &#123; int ans = 2, p = root; while (p) &#123; if (val == T[p].val) &#123; if (T[p].ch[1]) &#123; p = T[p].ch[1]; while (T[p].ch[0]) p = T[p].ch[0]; ans = p; &#125; break; &#125; if (T[p].val > val &amp;&amp; T[p].val &lt; T[ans].val) ans = p; p = T[p].ch[val &lt; T[p].val ? 0 : 1]; &#125; return T[ans].val; &#125; &#125;T; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int main(void) &#123; int q = read(); T.build(); while (q--) &#123; int op = read(), x = read(); if (op == 1) printf(\"%d\\n\", T.Rank(T.root, x) - 1); else if (op == 2) printf(\"%d\\n\", T.kth(T.root, x + 1)); else if (op == 3) printf(\"%d\\n\", T.GetPre(x)); else if (op == 4) printf(\"%d\\n\", T.GetNext(x)); else T.insert(x); &#125; return 0; &#125; åˆ†è£‚ä¸åˆå¹¶ ç”±äº Splay æ”¯æŒä¼¸å±•æ“ä½œï¼Œå› æ­¤å®ƒå¯ä»¥å¾ˆæ–¹ä¾¿çš„è¿›è¡Œåˆ†è£‚ä¸åˆå¹¶ï¼Œè¿›è€Œå®ç°å¯ä»¥åˆ†è£‚ä¸åˆå¹¶çš„åºåˆ—ã€‚æ¨¡æ¿ã€‚ ç¥é£æ•¢æ­»é˜Ÿç‚¸æ¯äº†æ­¤å¤„çš„å†…å®¹ã€‚é‰´å®šä¸ºä¸å¦‚ FHQï¼Œä»¥åå†è¯´ã€‚ Problemset ç›´æ¥çš„å¹³è¡¡æ ‘åº”ç”¨å¾ˆå°‘ï¼Œä½†æ˜¯ä¹Ÿæœ‰ã€‚ å¯åˆ†è£‚ä¸åˆå¹¶çš„åºåˆ— ç”¨äºç»´æŠ¤åºåˆ—ï¼Œä½†å¯èƒ½éœ€è¦ä¸€äº›æ€è€ƒã€‚ [JSOI2008] ç«æ˜Ÿäºº Portal. LCQ çš„æŸ¥è¯¢ç›´æ¥äºŒåˆ†å³å¯ï¼Œå‰©ä¸‹å°±æ˜¯ç›´æ¥å¹³è¡¡æ ‘ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; const int B = 10009, N = 100000; int n, m; u64 h[100005]; char s[100005]; mt19937 Rand(time(0)); struct Node &#123; int ch[2], siz, rnd; u64 w; char c; &#125; T[100005]; int tot, root; int newNode(char c) &#123; T[++tot].rnd = Rand(); T[tot].siz = 1; T[tot].w = T[tot].c = c; return tot; &#125; void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + 1; T[p].w = T[T[p].ch[0]].w * h[T[T[p].ch[1]].siz + 1] + T[p].c * h[T[T[p].ch[1]].siz] + T[T[p].ch[1]].w; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], S, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; int add(int l, int r) &#123; if (l == r) return newNode(s[l]); int mid = l + r >> 1; return merge(add(l, mid), add(mid + 1, r)); &#125; u64 Get(int l, int len) &#123; int x, y, z; split(root, l - 1, x, y); split(y, len, y, z); u64 res = T[y].w; root = merge(merge(x, y), z); return res; &#125; int main(void) &#123; for (int i = h[0] = 1; i &lt;= N; ++i) h[i] = h[i - 1] * B; scanf(\"%s\", s + 1); n = strlen(s + 1); root = merge(root, add(1, n)); scanf(\"%d\", &amp;m); char op[5]; int p, q, x, y, z; while (m--) &#123; scanf(\"%s%d\", op, &amp;p); if (op[0] == 'Q') &#123; scanf(\"%d\", &amp;q); int L = 0, R = T[root].siz - q + 2; while (L + 1 != R) &#123; int mid = L + R >> 1; if (Get(p, mid) == Get(q, mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", L); &#125; else if (op[0] == 'R') &#123; scanf(\"%s\", s); split(root, p - 1, x, y); split(y, 1, y, z); T[y].w = T[y].c = s[0]; root = merge(merge(x, y), z); &#125; else &#123; scanf(\"%s\", s); split(root, p, x, y); root = merge(merge(x, newNode(s[0])), y); &#125; &#125; return 0; &#125; [HNOI2011] æ‹¬å·ä¿®å¤ Portal. ä¿®å¤ä¸€ä¸ªæ‹¬å·åºåˆ—çš„ä»£ä»·è¿™æ ·è®¡ç®—ï¼šè®¾ ( = -1, ) = 1ï¼Œå‰ç¼€æœ€å¤§å€¼ä¸º aaaï¼Œåç¼€æœ€å°å€¼ä¸º bbbï¼Œä»£ä»·æ˜¯ âŒˆaÃ·2âŒ‰+âŒˆâˆ’bÃ·2âŒ‰\\lceil a\\div 2\\rceil+\\lceil -b\\div 2\\rceilâŒˆaÃ·2âŒ‰+âŒˆâˆ’bÃ·2âŒ‰ã€‚ç„¶åç›´æ¥ä½¿ç”¨å¹³è¡¡æ ‘ç»´æŠ¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;random> using namespace std; mt19937 Rand(time(0)); struct Node &#123; int ch[2], siz, rnd; int setv; bool rev, inv; int lmax, lmin, rmax, rmin, sum, val; &#125; T[100005]; int root, tot, n, m; int newNode(int val) &#123; T[++tot].rnd = Rand(); T[tot].siz = 1; T[tot].sum = T[tot].val = val; if (val == 1) T[tot].lmax = T[tot].rmax = 1; else T[tot].lmin = T[tot].rmin = -1; return tot; &#125; void maintain(int p) &#123; int l = T[p].ch[0], r = T[p].ch[1]; T[p].siz = T[l].siz + T[r].siz + 1; T[p].sum = T[l].sum + T[r].sum + T[p].val; T[p].lmax = max(T[l].lmax, T[l].sum + T[p].val + T[r].lmax); T[p].lmin = min(T[l].lmin, T[l].sum + T[p].val + T[r].lmin); T[p].rmax = max(T[r].rmax, T[r].sum + T[p].val + T[l].rmax); T[p].rmin = min(T[r].rmin, T[r].sum + T[p].val + T[l].rmin); &#125; void Replace(int p, int val) &#123; T[p].val = T[p].setv = val; T[p].sum = val * T[p].siz; T[p].lmax = T[p].rmax = max(0, val * T[p].siz); T[p].lmin = T[p].rmin = min(0, val * T[p].siz); &#125; void Swap(int p) &#123; swap(T[p].ch[0], T[p].ch[1]); swap(T[p].lmax, T[p].rmax); swap(T[p].lmin, T[p].rmin); T[p].rev ^= 1; &#125; void Invert(int p) &#123; T[p].val = -T[p].val; T[p].sum = -T[p].sum; T[p].setv = -T[p].setv; int x = T[p].lmax, y = T[p].lmin; T[p].lmax = -y, T[p].lmin = -x; x = T[p].rmax, y = T[p].rmin; T[p].rmax = -y, T[p].rmin = -x; T[p].inv ^= 1; &#125; void pushdown(int p) &#123; int l = T[p].ch[0], r = T[p].ch[1]; if (T[p].inv) &#123; if (l) Invert(l); if (r) Invert(r); T[p].inv = 0; &#125; if (T[p].rev) &#123; if (l) Swap(l); if (r) Swap(r); T[p].rev = 0; &#125; if (T[p].setv) &#123; if (l) Replace(l, T[p].setv); if (r) Replace(r, T[p].setv); T[p].setv = 0; &#125; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); pushdown(p); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], S, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; pushdown(x); T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; pushdown(y); T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; char s[100005]; int add(int l, int r) &#123; if (l == r) return newNode(s[l] == '(' ? -1 : 1); int mid = l + r >> 1; return merge(add(l, mid), add(mid + 1, r)); &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, s + 1); root = add(1, n); char op[15]; int l, r, x, y, z; while (m--) &#123; scanf(\"%s%d%d\", op, &amp;l, &amp;r); if (op[0] == 'R') &#123; scanf(\"%s\", s); split(root, l - 1, x, y); split(y, r - l + 1, y, z); Replace(y, s[0] == '(' ? -1 : 1); root = merge(merge(x, y), z); &#125; else if (op[0] == 'S') &#123; split(root, l - 1, x, y); split(y, r - l + 1, y, z); Swap(y); root = merge(merge(x, y), z); &#125; else if (op[0] == 'I') &#123; split(root, l - 1, x, y); split(y, r - l + 1, y, z); Invert(y); root = merge(merge(x, y), z); &#125; else &#123; split(root, l - 1, x, y); split(y, r - l + 1, y, z); printf(\"%d\\n\", (T[y].lmax + 1) / 2 + (1 - T[y].rmin) / 2); root = merge(merge(x, y), z); &#125; &#125; return 0; &#125; [ZJOI2006] ä¹¦æ¶ Portal. é—®é¢˜åœ¨äºå¦‚ä½•é«˜æ•ˆæ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹åœ¨å¹³è¡¡æ ‘ä¸Šçš„ä½ç½®ï¼ˆä¸­åºéå†çš„ç¼–å·ï¼‰ã€‚ç»´æŠ¤æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²ï¼Œç„¶åç›´æ¥ä»è¿™ä¸ªèŠ‚ç‚¹çš„ä½ç½®è·³åˆ°æ ¹ï¼Œç»´æŠ¤ä¸­åºéå†çš„ä½ç½®ã€‚è¿™ä¹‹åç›´æ¥ä¹±åšå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; struct Node &#123; int ch[2], fa, siz, dat, val; &#125; T[200005]; int tot = 0, root, id[200005]; // ç¼–å·ä¸º i çš„èŠ‚ç‚¹æ˜¯å¹³è¡¡æ ‘ä¸­çš„ id[i] å·èŠ‚ç‚¹ mt19937 Rand(time(0)); void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + 1; &#125; int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = Rand(); T[tot].siz = 1; return id[val] = tot; &#125; void split(int p, int S, int &amp;x, int &amp;y, int fax = 0, int fay = 0) &#123; if (!p) return x = y = 0, void(); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; T[x].fa = fay; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y, fax, x); &#125; else &#123; y = p; T[y].fa = fax; split(T[p].ch[0], S, x, T[p].ch[0], y, fay); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].dat > T[y].dat) &#123; T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); T[T[x].ch[1]].fa = x; return x; &#125; else &#123; T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); T[T[y].ch[0]].fa = y; return y; &#125; &#125; int find(int ID) &#123; // ä¸­åºéå†çš„ç¼–å· int res = T[T[ID].ch[0]].siz + 1; while (ID != root &amp;&amp; ID) &#123; if (T[T[ID].fa].ch[1] == ID) res += T[T[T[ID].fa].ch[0]].siz + 1; ID = T[ID].fa; &#125; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (n--) &#123; int x; scanf(\"%d\", &amp;x); root = merge(root, newNode(x)); &#125; char op[10]; int s, t; while (m--) &#123; scanf(\"%s%d\", op, &amp;s); if (op[0] == 'T') &#123; int x, y, z; s = find(id[s]); split(root, s - 1, x, y); split(y, 1, y, z); root = merge(y, merge(x, z)); &#125; else if (op[0] == 'B') &#123; int x, y, z; s = find(id[s]); split(root, s - 1, x, y); split(y, 1, y, z); root = merge(x, merge(z, y)); &#125; else if (op[0] == 'I') &#123; scanf(\"%d\", &amp;t); s = find(id[s]); int r1, r2, r3, r4; if (t == 1) &#123; split(root, s - 1, r1, r2); split(r2, 1, r2, r3); split(r3, 1, r3, r4); root = merge(r1, merge(r3, merge(r2, r4))); &#125; else if (t == -1) &#123; split(root, s - 2, r1, r2); split(r2, 1, r2, r3); split(r3, 1, r3, r4); root = merge(r1, merge(r3, merge(r2, r4))); &#125; &#125; else if (op[0] == 'A') printf(\"%d\\n\", find(id[s]) - 1); else &#123; int x, y; split(root, s, x, y); int node = x; while (T[node].ch[1]) node = T[node].ch[1]; printf(\"%d\\n\", T[node].val); root = merge(x, y); &#125; &#125; return 0; &#125; ç»¼åˆåº”ç”¨ ä¸€äº›å¹³è¡¡æ ‘çš„ç®€å•åº”ç”¨ã€‚ [POI2015] LOG Portal. ä½¿ç”¨ä¸€æ£µç»´æŠ¤æƒå€¼çš„å¹³è¡¡æ ‘ã€‚åœ¨å‡ 111 çš„è¿‡ç¨‹ä¸­ï¼Œå¤§äºç­‰äº sss çš„æ˜¯éšä¾¿ç”¨ï¼Œå‰©ä¸‹çš„åªéœ€è¦è€ƒè™‘å®ƒä»¬çš„å’Œæ˜¯å¦å¤Ÿç”¨å³å¯ï¼ˆå¯ä»¥å°†åé¢çš„å‘å‰ç§»æ¥å åˆ° sssï¼Œè¿™æ ·ä¿è¯ä¸€å±‚ä¸­ä¸ä¼šæœ‰æ¥è‡ªåŒä¸€ä¸ªä½ç½®çš„æ•°ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; mt19937 Rand(time(0)); struct Node &#123; int ls, rs, siz, rnd; i64 sum, val; &#125; T[2000005]; int root, tot; int newNode(int x) &#123; ++tot; T[tot].rnd = Rand(); T[tot].siz = 1; T[tot].sum = T[tot].val = x; return tot; &#125; inline void maintain(int p) &#123; T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz + 1; T[p].sum = T[T[p].ls].sum + T[T[p].rs].sum + T[p].val; &#125; void split(int p, int k, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[p].val &lt;= k) &#123; x = p; split(T[p].rs, k, T[p].rs, y); &#125; else &#123; y = p; split(T[p].ls, k, x, T[p].ls); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; T[x].rs = merge(T[x].rs, y); maintain(x); return x; &#125; else &#123; T[y].ls = merge(x, T[y].ls); maintain(y); return y; &#125; &#125; void insert(int v) &#123; int x, y; split(root, v, x, y); root = merge(x, merge(newNode(v), y)); &#125; void remove(int v) &#123; int x, y, z; split(root, v, x, z); split(x, v - 1, x, y); if (y) y = merge(T[y].ls, T[y].rs); root = merge(x, merge(y, z)); &#125; int bigger(int s) &#123; int x, y; split(root, s - 1, x, y); int ans = T[y].siz; root = merge(x, y); return ans; &#125; i64 query(int v) &#123; int x, y; split(root, v - 1, x, y); i64 ans = T[x].sum; root = merge(x, y); return ans; &#125; int n, m, a[1000005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); char op[5]; int x, y; for (int i = 1; i &lt;= n; ++i) insert(0); while (m--) &#123; scanf(\"%s%d%d\", op, &amp;x, &amp;y); if (op[0] == 'U') remove(a[x]), insert(a[x] = y); else &#123; int num = bigger(y); if (query(y) >= 1ll * (x - num) * y) puts(\"TAK\"); else puts(\"NIE\"); &#125; &#125; return 0; &#125; [HNOI2012] æ°¸æ— ä¹¡ Portal. ç”¨ Treap ç»´æŠ¤åæ¬¡ï¼Œç„¶åå¯å‘å¼åˆå¹¶ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct Node &#123; int ch[2]; int val, dat; int siz; &#125; T[3000005]; int tot, root[100005], f[100005], idx[100005]; int find(int x) &#123; if (f[x] == x) return x; return find(f[x]); &#125; void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + 1; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(); T[tot].siz = 1; T[tot].ch[0] = T[tot].ch[1] = 0; return tot; &#125; inline void rotate(int&amp; p, int d) &#123; int q = T[p].ch[d ^ 1]; T[p].ch[d ^ 1] = T[q].ch[d], T[q].ch[d] = p, p = q; maintain(T[p].ch[d]), maintain(p); &#125; void insert(int&amp; p, int val) &#123; if (p == 0) return p = newNode(val), void(); else &#123; int d = (val &lt; T[p].val ? 0 : 1); insert(T[p].ch[d], val); if (T[T[p].ch[d]].dat > T[p].dat) rotate(p, d ^ 1); &#125; maintain(p); &#125; int kth(int p, int rnk) &#123; if (p == 0) return 0; if (rnk &lt;= T[T[p].ch[0]].siz) return kth(T[p].ch[0], rnk); if (rnk &lt;= T[T[p].ch[0]].siz + 1) return T[p].val; return kth(T[p].ch[1], rnk - T[T[p].ch[0]].siz - 1); &#125; void dfs(int x, int y) &#123; insert(root[y], T[x].val); if (T[x].ch[0]) dfs(T[x].ch[0], y); if (T[x].ch[1]) dfs(T[x].ch[1], y); &#125; inline void merge(int u, int v) &#123; u = find(u); v = find(v); if (u == v) return; if (T[root[u]].siz > T[root[v]].siz) swap(u, v); f[u] = v; dfs(root[u], v); &#125; int n, m, q; int a[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), root[i] = newNode(a[i]), f[i] = idx[a[i]] = i; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); merge(u, v); &#125; char op[5]; int x, y; for (scanf(\"%d\", &amp;q); q--; ) &#123; scanf(\"%s%d%d\", op, &amp;x, &amp;y); if (op[0] == 'Q') &#123; x = find(x); int k = kth(root[x], y); if (!k) puts(\"-1\"); else printf(\"%d\\n\", idx[k]); &#125; else merge(x, y); &#125; return 0; &#125; [Luogu P3987] æˆ‘æ°¸è¿œå–œæ¬¢ç‚æœµè‰~ Portal. ä¸€ä¸ªæ•°æœ€å¤šè¢«é™¤ logâ¡\\loglog æ¬¡ï¼Œé‚£ä¹ˆå¯ä»¥æš´åŠ›ä¿®æ”¹å¹¶ä½¿ç”¨ Fenwick æ ‘æŸ¥è¯¢ï¼Œä½¿ç”¨å¹³è¡¡æ ‘ç»´æŠ¤æœ‰å› æ•° xxx çš„æ•°ï¼Œæ¯æ¬¡ä¿®æ”¹æ—¶ç›´æ¥ DFS åˆ†è£‚å‡ºçš„å­æ ‘ã€‚æ—¶é—´å¤æ‚åº¦ O(nd(V)+nlogâ¡nlogâ¡v+mlogâ¡n)O(nd(V)+n\\log n\\log v+m\\log n)O(nd(V)+nlognlogv+mlogn)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; int n, m, a[100005]; vector&lt;int> g[500005]; i64 C[100005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; i64 query(int x) &#123; i64 res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; mt19937 Rand(time(0)); struct Node &#123; int ls, rs, rnd, v, siz; &#125; T[65000005]; int tot, root[500005]; void maintain(int o) &#123; T[o].siz = T[T[o].ls].siz + T[T[o].rs].siz + 1; &#125; int newNode(int v) &#123; ++tot; T[tot].ls = T[tot].rs = 0; T[tot].v = v; T[tot].siz = 1; T[tot].rnd = Rand(); return tot; &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) return T[x].rs = merge(T[x].rs, y), maintain(x), x; return T[y].ls = merge(x, T[y].ls), maintain(y), y; &#125; void split(int p, int k, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[p].v &lt;= k) x = p, split(T[p].rs, k, T[p].rs, y); else y = p, split(T[p].ls, k, x, T[p].ls); maintain(p); &#125; int cur, q[100005]; int build(int l, int r) &#123; if (l > r) return 0; if (l == r) return newNode(q[l]); int mid = l + r >> 1; return merge(build(l, mid), build(mid + 1, r)); &#125; void dfs(int x, int v) &#123; if (!x) return; if (T[x].ls) dfs(T[x].ls, v); int p = T[x].v; if (a[p] % v == 0) &#123; add(p, -a[p]), a[p] /= v, add(p, a[p]); if (a[p] % v == 0) q[++cur] = p; &#125; if (T[x].rs) dfs(T[x].rs, v); &#125; void update(int x, int l, int r) &#123; int a, b, c; split(root[x], r, b, c); split(b, l - 1, a, b); cur = 0; dfs(b, x); root[x] = merge(a, merge(build(1, cur), c)); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); add(i, a[i]); for (int j = 1; j * j &lt;= a[i]; ++j) if (a[i] % j == 0) &#123; g[j].emplace_back(i); if (j * j != a[i]) g[a[i] / j].emplace_back(i); &#125; &#125; for (int i = 1; i &lt;= 500000; ++i) &#123; cur = 0; for (int x : g[i]) q[++cur] = x; root[i] = build(1, cur); &#125; while (m--) &#123; int op, l, r, x; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) &#123; scanf(\"%d\", &amp;x); if (x > 1) update(x, l, r); &#125; else printf(\"%lld\\n\", query(r) - query(l - 1)); &#125; return 0; &#125; å¯¹äºæ•°æ®åŠ å¼ºç‰ˆ [Ynoi2013] å¤§å­¦ï¼Œå¹³è¡¡æ ‘å¸¸æ•°è¿‡å¤§ï¼Œä¸èƒ½é€šè¿‡ã€‚å¯¹äºæ¯ä¸€ä¸ªçº¦æ•°é‡‡ç”¨ä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œå¼€å§‹æ—¶æ¯ä¸ªæ•°éƒ½æŒ‡å‘è‡ªå·±ï¼Œåˆ é™¤æ—¶å°†å½“å‰æ•°çš„çˆ¶äº²è®¾ç½®ä¸ºä¸‹ä¸€ä¸ªæ•°ã€‚å¦å¤– STL vector çš„å¸¸æ•°è¿‡å¤§ï¼Œéœ€è¦æ‰‹å†™å†…å­˜æ± ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) #define i64 long long using namespace std; int n, m, a[100005], o[500005], pool[40000005]; int *g[500005], *poi = pool, *fa[500005]; int find(int k, int x) &#123; if (x == o[k] || fa[k][x] == x) return x; return fa[k][x] = find(k, fa[k][x]); &#125; i64 C[100005]; inline void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; inline i64 query(int x) &#123; i64 res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int maxx = 0, op, l, r, x; i64 last = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); add(i, a[i]); maxx = max(maxx, a[i]); ++o[a[i]]; &#125; for (int i = 1; i &lt;= maxx; ++i) for (int j = i + i; j &lt;= maxx; j += i) o[i] += o[j]; for (int i = 1; i &lt;= maxx; ++i) &#123; g[i] = poi; poi += o[i]; fa[i] = poi; poi += o[i]; for (int j = 0; j &lt; o[i]; ++j) fa[i][j] = j; o[i] = 0; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j * j &lt;= a[i]; ++j) if (a[i] % j == 0) &#123; g[j][o[j]++] = i; if (j * j != a[i]) g[a[i] / j][o[a[i] / j]++] = i; &#125; while (m--) &#123; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); l ^= last, r ^= last; if (op == 1) &#123; scanf(\"%d\", &amp;x); x ^= last; if (x == 1 || !o[x]) continue; for (int i = find(x, lower_bound(g[x], g[x] + o[x], l) - g[x]); i &lt; o[x] &amp;&amp; g[x][i] &lt;= r; i = find(x, i + 1)) &#123; if (a[g[x][i]] % x == 0) add(g[x][i], a[g[x][i]] / x - a[g[x][i]]), a[g[x][i]] /= x; if (a[g[x][i]] % x) fa[x][i] = i + 1; &#125; &#125; else printf(\"%lld\\n\", last = query(r) - query(l - 1)); &#125; return 0; &#125; [Ynoi2010] y-fast trie Portal. ç¥ä»™é¢˜ã€‚ åŠ å…¥é›†åˆæ—¶å°† xxx å–æ¨¡ï¼Œç„¶åå¯¹äºä¸¤ä¸ªç­”æ¡ˆæ•° i,ji,ji,j åˆ†ç±»è®¨è®ºï¼š Câ‰¥i+j&lt;2CC\\ge i+j&lt;2CCâ‰¥i+j&lt;2Cï¼Œè¿™æ ·åªéœ€è¦ç»´æŠ¤é›†åˆçš„æœ€å¤§å’Œæ¬¡å¤§å€¼å³å¯ã€‚ 0â‰¤i+j&lt;C0\\le i+j&lt;C0â‰¤i+j&lt;Cï¼Œæˆ‘ä»¬è®¨è®ºè¿™ç§æƒ…å†µã€‚ ç§°ä¸€ä¸ªæ•° iii åœ¨é›†åˆä¸­æ»¡è¶³ i+j&lt;Ci+j&lt;Ci+j&lt;C çš„æœ€å¤§æ•° jjj æ˜¯ iii çš„æœ€ä¼˜åŒ¹é…ï¼Œæˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªå¯ä»¥æ±‚å‡º iii çš„åŒ¹é…çš„å‡½æ•°ï¼Œå¹¶ä¸”èƒ½å¤Ÿå‘å®ƒæŒ‡å®šæ˜¯å¦ä¸èƒ½åŒ¹é…åˆ°è‡ªèº«ã€‚ ä¸€ä¸ªæ•°çš„æ”¹å˜å¯èƒ½ä¼šå½±å“ O(n)O(n)O(n) ä¸ªåŒ¹é…ã€‚æ ¹æ®ç»éªŒï¼Œæˆ‘ä»¬éœ€è¦åˆ å»ä¸€äº›æ— ç”¨çš„åŒ¹é…ï¼Œè®©éœ€è¦ä¿®æ”¹çš„åŒ¹é…ä¸ªæ•°æ§åˆ¶åœ¨ O(1)O(1)O(1) çº§åˆ«ã€‚æ¯”å¦‚ xxx çš„æœ€ä¼˜åŒ¹é…æ˜¯ yyyï¼Œè€Œ yyy çš„æœ€ä¼˜åŒ¹é…æ˜¯ zzzï¼Œæœ‰ xâ‰¤zx\\le zxâ‰¤zï¼Œé‚£ä¹ˆ xxx åŠ å…¥æ—¶å°±ä¸éœ€è¦ä¿®æ”¹ yyy çš„æœ€ä¼˜åŒ¹é…ï¼Œå› ä¸ºç°æœ‰çš„ç­”æ¡ˆ y+zy+zy+z ä¸€å®šæ¯” x+yx+yx+y å¤§ï¼Œè¿›è€Œ y,zy,zy,z å¿…é¡»åŒå‘äº’ä¸ºæœ€ä¼˜åŒ¹é…è¿™ä¸ªç­”æ¡ˆæ‰éœ€è¦è¢«åˆ é™¤ï¼Œä½†æ˜¯ x+yx+yx+y ä¸€å®šè¦è¢«æ’å…¥ã€‚ åˆ é™¤ xxx æ—¶ï¼Œx+yx+yx+y ä¸€å®šè¦è¢«åˆ é™¤ï¼Œå¦‚æœ y,zy,zy,z äº’ä¸ºæœ€ä¼˜åŒ¹é…éœ€è¦å°† y+zy+zy+z æ’å…¥å›æ¥ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, C, siz; multiset&lt;int> a, b; int find(int x, int op) &#123; // å¯»æ‰¾ i + j &lt; C çš„æœ€å¤§ j, op = 1 ä¸ºå¼ºåˆ¶ä¸ç­‰äºè‡ªå·± if (x == -1) return -1; auto it = a.upper_bound(C - 1 - x); if (it == a.begin()) return -1; --it; // æ»¡è¶³ x + j &lt; C çš„æœ€å¤§ j if (op &amp;&amp; *it == x &amp;&amp; a.count(x) == 1) return it == a.begin() ? -1 : *--it; return *it; &#125; inline void insert(int x) &#123; if (++siz == 1) return a.insert(x), void(); int y = find(x, 0), z = find(y, 1), w = find(z, 1); // çœ‹ x çš„æœ€ä¼˜åŒ¹é… yï¼Œx æ˜¯å¦èƒ½å¯¹ y æœ¬èº«çš„æœ€ä¼˜åŒ¹é… z äº§ç”Ÿå½±å“ï¼Œè€Œä¸” y,z åŒå‘åŒ¹é… // å¯»æ‰¾ x çš„åŒ¹é…å¯ä»¥æ˜¯ xï¼Œå› ä¸º x è¿˜æ²¡è¿›é›†åˆ if (y != -1 &amp;&amp; z &lt; x) &#123; if (z != -1 &amp;&amp; w == y) b.erase(b.find(y + z)); b.insert(x + y); &#125; a.insert(x); &#125; inline void remove(int x) &#123; a.erase(a.find(x)); if (--siz == 0) return; int y = find(x, 0), z = find(y, 1), w = find(z, 1); // åˆ é™¤äº† xï¼Œå°† x çš„æœ€ä¼˜åŒ¹é… y çš„æœ€ä¼˜åŒ¹é…è¿›è¡Œä¿®æ”¹ if (y != -1 &amp;&amp; z &lt; x) &#123; if (z != -1 &amp;&amp; w == y) b.insert(y + z); b.erase(b.find(x + y)); &#125; &#125; inline int query(int x) &#123; // i + j >= C auto it = --a.end(); if (a.count(*it) >= 2) return *it * 2 % C; int tmp = *it; --it; return (tmp + *it) % C; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;C); int last = 0; while (n--) &#123; int op, x; scanf(\"%d%d\", &amp;op, &amp;x); x = (x ^ last) % C; if (op == 1) insert(x); else remove(x); if (siz &lt; 2) puts(\"EE\"), last = 0; else printf(\"%d\\n\", last = max(query(x), b.empty() ? 0 : *--b.end())); &#125; return 0; &#125; * [Ynoi2015] äººäººæœ¬ç€æ­£ä¹‰ä¹‹å Portal. é¦–å…ˆçœ‹ä¸€çœ‹æ“ä½œ 3âˆ¼63\\sim 63âˆ¼6 æ˜¯ä¸ªä»€ä¹ˆä¸œè¥¿ã€‚ å°† [l,râˆ’1][l,r-1][l,râˆ’1] ä¸­çš„æ•° aia_iaiâ€‹ åŒæ—¶å˜ä¸º aia_iaiâ€‹ ä¸ ai+1a_{i+1}ai+1â€‹ æŒ‰ä½æˆ–çš„å€¼ï¼Ÿç®€å•ï¼Œå°±æ˜¯æ‰€æœ‰æé•¿ 000 æ®µæœ€å³è¾¹ä¸€ä¸ª 000 å˜æˆ 111ã€‚ æä¸€ä¸ªå¹³è¡¡æ ‘ï¼Œæ‰“ä¸€ä¸ªæ ‡è®°è¡¨ç¤ºå·¦å³ç«¯ç‚¹çš„ç§»åŠ¨é‡ã€‚åªæœ‰ä¸¤ä¸ªé—®é¢˜ï¼š å¦‚ä½•ä¿è¯åŒºé—´æé•¿ï¼ŸåŒºé—´æŸ“è‰²æ—¶å‘å·¦å³æ‹“å±•ä¸€ä¸‹å³å¯ã€‚ å¦‚ä½•ä¿è¯æ²¡æœ‰ç©ºåŒºé—´ï¼ŸåŒºé—´æ•°é‡æ˜¯ O(n+m)O(n+m)O(n+m) çš„ï¼Œç»´æŠ¤æœ€çŸ­ 01 åŒºé—´é•¿åº¦ï¼Œæš´åŠ›æ‰¾ï¼Œç„¶åå°†å…¶å·¦å³åŒºé—´åˆå¹¶å³å¯ã€‚ æœ¬è´¨ä¸Šä¸éš¾ï¼Œä½†ä»£ç æ¯”è¾ƒå£®è§‚ï¼Œéœ€è¦ä½¿ç”¨æŒ‡é’ˆå®ç°å¹³è¡¡æ ‘è¿›è¡Œå¡å¸¸ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define PTREE(x) printf(\"root = %d\\n\", x); printT(x) #define DEBUG fprintf(stderr, \"Passed Line %d, in Function %s\\n\", __LINE__, __FUNCTION__) using namespace std; const int INF = 1e9; mt19937 Rand(time(0)); inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar(); return x; &#125; void print(int x) &#123; if (x > 9) print(x / 10); putchar(x % 10 ^ 48); &#125; struct Node &#123; int rnd; int col, sum, siz[2]; // åŒºé—´é¢œè‰²ï¼ŒåŒºé—´å’Œï¼Œ01 åŒºé—´æ•°é‡ int l, r; // å·¦å³ç«¯ç‚¹ int dL, dR; // 1 çš„å·¦å³ç«¯ç‚¹ä½ç§» int minLen[2]; // æœ€çŸ­ 01 åŒºé—´é•¿åº¦ Node *ls, *rs; void reset(void) &#123; siz[col] = 1; siz[!col] = 0; sum = col * (r - l + 1); dL = dR = 0; minLen[col] = r - l + 1; minLen[!col] = INF; &#125; Node(int col = 0, int l = 0, int r = 0) : rnd(Rand()), col(col), l(l), r(r), ls(NULL), rs(NULL) &#123; reset(); &#125; void add(const Node &amp;a) &#123; sum += a.sum; siz[0] += a.siz[0]; siz[1] += a.siz[1]; minLen[0] = min(minLen[0], a.minLen[0]); minLen[1] = min(minLen[1], a.minLen[1]); &#125; &#125; T[5000005]; Node* root; int tot; inline Node* newNode(int col, int l, int r) &#123; return &amp;(T[++tot] = Node(col, l, r)); &#125; inline void maketag(Node* o, int dL, int dR) &#123; o->dL += dL; o->dR += dR; o->minLen[0] -= dL + dR; o->minLen[1] += dL + dR; o->sum += (dL + dR) * o->siz[1]; if (o->col == 1) o->l -= dL, o->r += dR; else o->l += dR, o->r -= dL; &#125; inline void pushdown(Node* o) &#123; if (!o->dL &amp;&amp; !o->dR) return; if (o->ls != NULL) maketag(o->ls, o->dL, o->dR); if (o->rs != NULL) maketag(o->rs, o->dL, o->dR); o->dL = o->dR = 0; &#125; inline void pushup(Node* o) &#123; o->reset(); if (o->ls) o->add(*(o->ls)); if (o->rs) o->add(*(o->rs)); &#125; Node* merge(Node* x, Node* y) &#123; if (x == NULL) return y; if (y == NULL) return x; if (x->rnd &lt; y->rnd) &#123; pushdown(x); x->rs = merge(x->rs, y); pushup(x); return x; &#125; else &#123; pushdown(y); y->ls = merge(x, y->ls); pushup(y); return y; &#125; &#125; // å·¦ç«¯ç‚¹ &lt;= k åˆ’åˆ° x void split1(Node* o, int k, Node*&amp; x, Node*&amp; y) &#123; if (o == NULL) return x = y = NULL, void(); pushdown(o); if (o->l &lt;= k) x = o, split1(x->rs, k, x->rs, y); else y = o, split1(y->ls, k, x, y->ls); pushup(o); &#125; // å³ç«¯ç‚¹ &lt;= k åˆ’åˆ° x void split2(Node* o, int k, Node*&amp; x, Node*&amp; y) &#123; if (o == NULL) return x = y = NULL, void(); pushdown(o); if (o->r &lt;= k) x = o, split2(x->rs, k, x->rs, y); else y = o, split2(y->ls, k, x, y->ls); pushup(o); &#125; // åˆ é™¤ç©ºåŒºé—´ Node* Eraser[3000005]; int L = 1, R = 0; const int B = 4194303; void findEmpty(Node* o) &#123; if (o == NULL) return; if (o->minLen[0] &amp;&amp; o->minLen[1]) return; pushdown(o); if (o->l > o->r) Eraser[(++R) &amp; B] = o; findEmpty(o->ls); findEmpty(o->rs); &#125; inline void Erase(void) &#123; while (L &lt;= R) &#123; Node *o = Eraser[(L++) &amp; B]; Node *nodeL, *TM, *nodeR, *TR; split1(root, o->l - 1, root, TM); split1(TM, o->l, TM, TR); // TM.l = o->l split2(root, o->l - 2, root, nodeL); nodeR = (o == TM ? o->rs : TM); if (nodeL &amp;&amp; nodeR) nodeL->r = nodeR->r, nodeL->reset(), nodeR = NULL; root = merge(root, merge(nodeL, merge(nodeR, TR))); &#125; &#125; void printT(Node* o) &#123; if (o == NULL) return; pushdown(o); if (o->ls) printT(o->ls); printf(\"%d %d %d %d %d\\n\", o->l, o->r, o->dL, o->dR, o->col); if (o->rs) printT(o->rs); &#125; // æ“ä½œåˆ—è¡¨ inline void cover(int l, int r, int col) &#123; Node *nodeL, *TM, *nodeR, *TR; // root = TL split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l - 1, nodeL, TM); split2(TM, r, TM, nodeR); if (nodeL) &#123; if (nodeL->r > r) nodeR = newNode(nodeL->col, r, nodeL->r); nodeL->r = l - 1; nodeL->reset(); &#125; else split2(root, l - 2, root, nodeL); if (nodeR) nodeR->l = r + 1, nodeR->reset(); else split1(TR, r + 1 , nodeR, TR); TM = newNode(col, l, r); if (nodeL &amp;&amp; TM->col == nodeL->col) TM->l = nodeL->l, TM->reset(), nodeL = NULL; if (nodeR &amp;&amp; TM->col == nodeR->col) TM->r = nodeR->r, TM->reset(), nodeR = NULL; root = merge(root, merge(nodeL, merge(TM, merge(nodeR, TR)))); &#125; // 0 åŒºé—´å³ç«¯ç‚¹ -1ï¼Œ1 åŒºé—´å·¦ç«¯ç‚¹ -1 inline void opt3(int l, int r) &#123; --r; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l, node, TM); if (node &amp;&amp; node->col == 1) root = merge(root, node); else TM = merge(node, TM); split2(TM, r - 1, TM, node); if (node &amp;&amp; node->col == 0) &#123; if (node->r > r) TR = merge(node, TR); else &#123; TM = merge(TM, node); split1(TR, r + 1, node, TR); TM = merge(TM, node); &#125; &#125; else TM = merge(TM, node); // PTREE(TM); if (TM) maketag(TM, 1, 0); // PTREE(TM); root = merge(merge(root, TM), TR); findEmpty(root); Erase(); &#125; // 0 åŒºé—´å·¦ç«¯ç‚¹ +1ï¼Œ1 åŒºé—´å³ç«¯ç‚¹ +1 inline void opt4(int l, int r) &#123; ++l; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l, node, TM); if (node &amp;&amp; node->col == 0) &#123; if (node->l &lt; l) root = merge(root, node); else &#123; TM = merge(node, TM); split2(root, l - 2, root, node); TM = merge(node, TM); &#125; &#125; else TM = merge(node,TM); split2(TM, r - 1, TM, node); if (node &amp;&amp; node->col == 1) TR = merge(node, TR); else TM = merge(TM, node); if (TM) maketag(TM, 0, 1); root = merge(root, merge(TM, TR)); findEmpty(root); Erase(); &#125; // 0 åŒºé—´å·¦ç«¯ç‚¹ -1ï¼Œ1 åŒºé—´å³ç«¯ç‚¹ -1 inline void opt5(int l, int r) &#123; --r; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l, node, TM); if (node &amp;&amp; node->col == 0) root = merge(root, node); else TM = merge(node, TM); split2(TM, r - 1, TM, node); if (node &amp;&amp; node->col == 1) &#123; if (node->r > r) TR = merge(node, TR); else &#123; TM = merge(TM, node); split1(TR, r + 1, node, TR); TM = merge(TM, node); &#125; &#125; else TM = merge(TM, node); if (TM) maketag(TM, 0, -1); root = merge(root, merge(TM, TR)); findEmpty(root); Erase(); &#125; // 0 åŒºé—´å³ç«¯ç‚¹ +1ï¼Œ1 åŒºé—´å·¦ç«¯ç‚¹ +1 inline void opt6(int l, int r) &#123; ++l; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l, node, TM); if (node &amp;&amp; node->col == 1) &#123; if (node->l &lt; l) root = merge(root, node); else &#123; TM = merge(node, TM); split2(root, l - 2, root, node); TM = merge(node, TM); &#125; &#125; else TM = merge(node, TM); split2(TM, r - 1, TM, node); if (node &amp;&amp; node->col == 0) TR = merge(node, TR); else TM = merge(TM, node); if (TM) maketag(TM, -1, 0); root = merge(root, merge(TM, TR)); findEmpty(root); Erase(); &#125; inline int opt7(int l, int r) &#123; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); int ans = 0; if (TM) ans += TM->sum; split1(TM, l - 1, node, TM); if (node) ans -= node->col * (l - node->l); TM = merge(node, TM); split2(TM, r, TM, node); if (node) ans -= node->col * (node->r - r); TM = merge(TM, node); root = merge(root, merge(TM, TR)); return ans; &#125; int n, m; int a[3000005]; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); int lst = 1; for (int i = 2; i &lt;= n; ++i) if (a[i] != a[i - 1]) root = merge(root, newNode(a[i - 1], lst, i - 1)), lst = i; root = merge(root, newNode(a[n], lst, n)); // PTREE(root); for (lst = 0; m--; ) &#123; int op = read(), l = read() ^ lst, r = read() ^ lst; if (op == 1) cover(l, r, 0); else if (op == 2) cover(l, r, 1); else if (op == 3) opt3(l, r); else if (op == 4) opt4(l, r); else if (op == 5) opt5(l, r); else if (op == 6) opt6(l, r); else print(lst = opt7(l, r)), putchar('\\n'); // PTREE(root); lst = 0; &#125; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"æ•°æ®ç»“æ„","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"å¹³è¡¡æ ‘","slug":"å¹³è¡¡æ ‘","permalink":"https://james1badcreeper.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"Treap","slug":"Treap","permalink":"https://james1badcreeper.github.io/tags/Treap/"},{"name":"Splay","slug":"Splay","permalink":"https://james1badcreeper.github.io/tags/Splay/"},{"name":"FHQ-Treap","slug":"FHQ-Treap","permalink":"https://james1badcreeper.github.io/tags/FHQ-Treap/"}]},{"title":"ç»„åˆè®¡æ•°è¿›é˜¶","slug":"notes/æ•°å­¦/combination-ex","date":"2022-12-23T00:00:00.000Z","updated":"2022-12-23T00:00:00.000Z","comments":true,"path":"cb620531/","link":"","permalink":"https://james1badcreeper.github.io/cb620531/","excerpt":"é«˜é˜¶çš„è®¡æ•°é—®é¢˜æ›´ä¸ºå›°éš¾ã€‚åœ¨é˜…è¯»æœ¬æ–‡ä¹‹å‰ï¼Œè¯·ç¡®ä¿ä½ å¯¹ç”Ÿæˆå‡½æ•°å’Œå¤šé¡¹å¼æœ‰ä¸€å®šçš„äº†è§£ã€‚","text":"é«˜é˜¶çš„è®¡æ•°é—®é¢˜æ›´ä¸ºå›°éš¾ã€‚åœ¨é˜…è¯»æœ¬æ–‡ä¹‹å‰ï¼Œè¯·ç¡®ä¿ä½ å¯¹ç”Ÿæˆå‡½æ•°å’Œå¤šé¡¹å¼æœ‰ä¸€å®šçš„äº†è§£ã€‚ å¸¸è§æ„é€ æ‰‹æ®µ è®¡æ•°é—®é¢˜æœ‰ä¸€äº›å¸¸æœ‰çš„æ±‚è§£æ‰‹æ®µã€‚åœ¨ç ”ç©¶æ›´å¤šå†…å®¹å‰ï¼Œæˆ‘ä»¬å…ˆäº†è§£ä¸€ä¸‹è¿™äº›æ–¹æ³•ã€‚ æ„é€ åŒå°„ ä¸åŒçš„ä¸¤ä¸ªç»„åˆç±»ä¸­çš„ç»„åˆå¯¹è±¡å¯ä»¥ä¸€ä¸€å¯¹åº”ï¼Œè¿™æ ·å¯¹ä¸¤ä¸ªç»„åˆç±»è¿›è¡Œè®¡æ•°æ˜¯ç­‰ä»·çš„ã€‚ æœ‰æ—¶åŒä¸€ç»„åˆç±»ä¸­çš„ç»„åˆå¯¹è±¡å¯ä»¥å»ºç«‹ä¸€ä¸€å¯¹åº”ï¼ˆæˆ–å¤šä¸ªä¸ºä¸€ç»„ï¼‰ï¼Œæˆ‘ä»¬åªéœ€æŠ½å–æ¯å¯¹ï¼ˆæˆ–æ¯ç»„ï¼‰ä¸­çš„ä¸€ä¸ªè¿›è¡Œè®¡æ•°ï¼Œå†ä¹˜ä¸Šæˆ–é™¤ä»¥ç›¸åº”çš„å¤§å°å³å¯ã€‚ å¢é‡æ³• è®¡æ•°é—®é¢˜çš„å¸¸è§æ‰‹æ®µï¼Œè«é˜Ÿçš„æ‰©å±•ä¹Ÿæ˜¯è¿™ä¸€æ€æƒ³ã€‚å°±æ˜¯ä» (n,m)(n,m)(n,m) æ‰©å±•åˆ° (n+1,m+1)(n+1,m+1)(n+1,m+1)ï¼Œè€ƒè™‘è´¡çŒ®å¢åŠ çš„é‡ã€‚ æœ‰æ—¶é—®é¢˜æ— æ³•ç›´æ¥å¤„ç†ï¼Œåªèƒ½è€ƒè™‘å¢é‡æ³•ã€‚ å·®åˆ†æ³• æ¯”å¦‚è¯´æŸ¥è¯¢æ°å¥½ä¸º xxx çš„æ–¹æ¡ˆæ•°ï¼Œå¯ä»¥ç”¨ â‰¤x\\le xâ‰¤x çš„æ–¹æ¡ˆæ•°å’Œ â‰¤xâˆ’1\\le x-1â‰¤xâˆ’1 çš„æ–¹æ¡ˆæ•°ç›¸å‡å¾—åˆ°ã€‚ æƒå€¼çš„è´¡çŒ® ä¸€èˆ¬æˆ‘ä»¬ä¼šä»æƒå€¼çš„è§’åº¦å»è€ƒè™‘ï¼Œå¯ä»¥ä»æƒå€¼ä¸‹æ ‡çš„é¡ºåºè¿›è¡Œè€ƒè™‘ï¼Œä¹Ÿå¯ä»¥ä»æ¯ä¸€ä¸ªæƒå€¼å¯¹å¼å­çš„è´¡çŒ®è€ƒè™‘ã€‚ ç®—ä¸¤æ¬¡ å¦‚ç»´åº¦çš„å˜æ¢ï¼ˆæšä¸¾ä¸‹æ ‡ã€æƒå€¼ï¼‰ã€è´¡çŒ®çš„è®¡ç®—ï¼ˆç›´æ¥æˆ–å¢é‡è®¡ç®—ï¼‰ã€‚é€‰æ‹©åˆé€‚çš„è§’åº¦åï¼Œå†ä½¿ç”¨åŠ æ³•åŸç†å’Œä¹˜æ³•åŸç†ç­‰è®¡æ•°æ–¹æ³•è§£å†³é—®é¢˜ã€‚ æœ‰æ—¶ä¹Ÿå¯ä»¥è€ƒè™‘æ›´æ¢è®¡æ•°é¡ºåºï¼Œæˆ–è€…ç”¨ä¸¤ç§ä¸åŒçš„æ–¹å¼è®¡ç®—åŒä¸€ä¸ªé‡ï¼Œä»è€Œå»ºç«‹ç›¸ç­‰å…³ç³»ã€‚ Prufer åºåˆ— è¿™æ˜¯ä¸€ç§å°†æ— æ ¹æ ‘è½¬åŒ–ä¸ºä¸€ä¸ªå”¯ä¸€çš„æ•´æ•°åºåˆ—çš„è¡¨ç¤ºæ–¹æ³•ï¼ˆå‰ææ˜¯ï¼Œè¿™ä¸ªæ ‘åº”è¯¥è‡³å°‘æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼‰ã€‚ æ„é€  Prufer åºåˆ—å¯ä»¥å°†ä¸€ä¸ª nnn ä¸ªèŠ‚ç‚¹çš„æ— æ ¹æ ‘ç”¨ [1,n][1,n][1,n] ä¸­çš„ nâˆ’2n-2nâˆ’2 ä¸ªæ•´æ•°è¡¨ç¤ºï¼Œå¸¸ç”¨äºç»„åˆè®¡æ•°ã€‚ å»ºç«‹æ—¶ï¼Œæ¯æ¬¡é€‰æ‹©ä¸€ä¸ªç¼–å·æœ€å°çš„å¶å­åˆ é™¤å®ƒï¼Œç„¶ååœ¨åºåˆ—ä¸­è®°å½•ä¸‹å®ƒè¿æ¥åˆ°çš„é‚£ä¸ªèŠ‚ç‚¹ï¼Œé‡å¤ nâˆ’2n-2nâˆ’2 æ¬¡ç®—æ³•ç»“æŸã€‚å¯ä»¥ä½¿ç”¨å¦‚ä¸‹æ–¹æ³•è¿›è¡Œ O(n)O(n)O(n) æ„é€ ï¼š è‡ªå¢ ppp ä½¿å…¶æŒ‡å‘ç¼–å·æœ€å°çš„å¶èŠ‚ç‚¹ï¼Œå°†å…¶åˆ é™¤ï¼› æ£€æŸ¥æ˜¯å¦äº§ç”Ÿæ–°çš„å¶èŠ‚ç‚¹ï¼Œå¦‚æœäº§ç”Ÿä¸”ç¼–å·æ¯” ppp å°ï¼Œåˆ™ç«‹å³åˆ é™¤ï¼Œé‡å¤æ­¤æ“ä½œï¼› ppp è‡ªå¢ï¼Œå›åˆ°æ­¥éª¤ 111 ç›´åˆ° Prufer åºåˆ—æ„é€ å®Œæ¯•ã€‚ è¿˜åŸ æ ¹æ® Prufer åºåˆ—ä¹Ÿå¯ä»¥è¿˜åŸæ ‘ã€‚æ–¹æ³•æ˜¯ä¸€æ ·çš„ï¼Œæ³¨æ„å…ˆå°† prufer[nâˆ’1]prufer[n-1]prufer[nâˆ’1] è®¾ä¸º nnnï¼Œå¹¶å°†èµ‹å€¼çš„å†…å®¹åè¿‡æ¥å³å¯ã€‚å…·ä½“è§ä»£ç ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 5000000; int n, m; i64 ans = 0; int fa[N + 5], du[N + 5]; int p[N + 5]; void treeToPrufer(void) &#123; for (int i = 1; i &lt; n; ++i) scanf(\"%d\", fa + i), ++du[fa[i]]; for (int i = 1, now = 1; i &lt; n; ++i, ++now) &#123; while (du[now]) ++now; p[i] = fa[now]; while (i &lt; n - 2 &amp;&amp; --du[p[i]] == 0 &amp;&amp; p[i] &lt; now) p[i + 1] = fa[p[i]], ++i; &#125; for (int i = 1; i &lt; n - 1; ++i) ans ^= 1ll * i * p[i]; &#125; void pruferToTree(void) &#123; for (int i = 1; i &lt; n - 1; ++i) scanf(\"%d\", p + i), ++du[p[i]]; p[n - 1] = n; for (int i = 1, now = 1; i &lt; n; ++i, ++now) &#123; while (du[now]) ++now; fa[now] = p[i]; while (i &lt; n - 1 &amp;&amp; --du[p[i]] == 0 &amp;&amp; p[i] &lt; now) fa[p[i]] = p[i + 1], ++i; &#125; for (int i = 1; i &lt; n; ++i) ans ^= 1ll * i * fa[i]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); if (m == 1) treeToPrufer(); else pruferToTree(); printf(\"%lld\\n\", ans); return 0; &#125; æ€§è´¨ æ¯ä¸ªèŠ‚ç‚¹åœ¨ Prufer åºåˆ—ä¸­å‡ºç°æ¬¡æ•°æ˜¯å…¶åº¦æ•°å‡ 111ã€‚ å®Œå…¨å›¾æœ‰ nnâˆ’2n^{n-2}nnâˆ’2 æ£µç”Ÿæˆæ ‘ï¼Œå› ä¸ºæ¯ä¸€ä¸ª Prufer åºåˆ—éƒ½å¯¹åº”ä¸€æ£µæ ‘ã€‚è¿™å°±æ˜¯ Cayley å…¬å¼ã€‚ å®¹æ–¥åŸç†ä¸åæ¼” åæ¼”æ˜¯æŒ‡ä¸¤ä¸ªå‡½æ•°ï¼ˆæ•°åˆ—ï¼‰ä¹‹é—´çš„åŒå°„ï¼ˆæ¯”å¦‚å‰ç¼€å’Œå’Œå·®åˆ†ï¼‰ã€‚ å­é›†åæ¼” å­é›†åæ¼”æ˜¯é’ˆå¯¹é›†åˆäº¤å¹¶çš„å®¹æ–¥ï¼Œå¯ä»¥åœ¨æ°å¥½æ˜¯æŸä¸ªé›†åˆå’Œè‡³å¤š/è‡³å°‘æ˜¯è¿™ä¸ªé›†åˆåæ¼”ã€‚ æˆ‘ä»¬å…ˆæ¥çœ‹ä¸è‡³å¤šæ˜¯è¿™ä¸ªé›†åˆçš„åæ¼”ã€‚ç°åœ¨æœ‰å…¶å…ƒç´ æ»¡è¶³æŸç§æ¡ä»¶çš„é›†åˆ AAAã€‚å®šä¹‰ f(S)f(S)f(S) ä»£è¡¨ S=AS=AS=A æ—¶çš„ç­”æ¡ˆï¼Œg(S)g(S)g(S) ä»£è¡¨ SâŠ†AS\\subseteq ASâŠ†A æ—¶çš„ç­”æ¡ˆã€‚ é’¦å®šé€‰äº† SSS è¿™ä¸ªé›†åˆä¸­çš„å­é›† TTTï¼Œæœ‰ g(S)=âˆ‘TâŠ†Sf(T)g(S)=\\sum_{T\\subseteq S}f(T)g(S)=âˆ‘TâŠ†Sâ€‹f(T)ï¼Œè¿™æ—¶æœ‰ f(S)=âˆ‘TâŠ†S(âˆ’1)âˆ£Sâˆ£âˆ’âˆ£Tâˆ£g(T)f(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}g(T)f(S)=âˆ‘TâŠ†Sâ€‹(âˆ’1)âˆ£Sâˆ£âˆ’âˆ£Tâˆ£g(T)ã€‚ä½¿ç”¨å®¹æ–¥åŸç†ä¸éš¾æ„Ÿæ€§ç†è§£ã€‚ ç±»ä¼¼çš„ï¼Œå¦‚æœ f(S)f(S)f(S) ä»£è¡¨ S=AS=AS=A æ—¶çš„ç­”æ¡ˆï¼Œg(S)g(S)g(S) è¡¨ç¤º AâŠ†SA\\subseteq SAâŠ†S æ—¶çš„ç­”æ¡ˆï¼Œæœ‰ g(S)=âˆ‘SâŠ†Tf(T)g(S)=\\sum_{S\\subseteq T}f(T)g(S)=âˆ‘SâŠ†Tâ€‹f(T)ï¼Œåæ¼”å¾— f(S)=âˆ‘SâŠ†T(âˆ’1)âˆ£Tâˆ£âˆ’âˆ£Sâˆ£g(T)f(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}g(T)f(S)=âˆ‘SâŠ†Tâ€‹(âˆ’1)âˆ£Tâˆ£âˆ’âˆ£Sâˆ£g(T)ã€‚ å®é™…ä¸Šè¿™æ˜¯å®¹æ–¥åŸç†çš„ä»£æ•°å½¢å¼ï¼Œå®ƒæ˜¯æˆ‘ä»¬ç”¨å®¹æ–¥åŸç†è§£å†³é—®é¢˜çš„åŸºç¡€ã€‚å› ä¸ºåœ¨é’¦å®šæ—¶ï¼Œä¸€ä¸ªâ€œæœ‰ä¸¤ä¸ªå…ƒç´ æ»¡è¶³æ¡ä»¶â€çš„ä¸œè¥¿ä¼šåœ¨â€œè‡³å°‘æœ‰ä¸€ä¸ªå…ƒç´ æ»¡è¶³æ¡ä»¶â€çš„ä¸œè¥¿è®¡ç®—æ—¶è®¡ç®—ä¸¤æ¬¡ï¼Œä¹Ÿå°±å› æ­¤æˆäº†ä¸€ä¸ªå­é›†åæ¼”çš„å½¢å¼ã€‚ äºŒé¡¹å¼åæ¼” äºŒé¡¹å¼åæ¼”æ˜¯å®¹æ–¥åŸç†çš„ä»£æ•°å½¢å¼ã€‚å‡è®¾å…¨é›† U={S1,Sâˆ’2,â‹¯ ,Snâˆ’1,Sn}U=\\{S_1, S-2, \\cdots, S_{n-1}, S_n\\}U={S1â€‹,Sâˆ’2,â‹¯,Snâˆ’1â€‹,Snâ€‹}ï¼Œä¸”æ»¡è¶³å…¶ä¸­ä»»æ„ iii ä¸ªé›†åˆçš„å¹¶é›†ã€äº¤é›†å¤§å°éƒ½ç›¸ç­‰ã€‚g(x)g(x)g(x) æ˜¯å…¶ä¸­ä»»æ„ xxx ä¸ªé›†åˆçš„äº¤é›†çš„å¤§å°ï¼Œf(x)f(x)f(x) æ˜¯ä»»æ„ xxx ä¸ªé›†åˆçš„è¡¥é›†çš„äº¤é›†çš„å¤§å°ã€‚ç‰¹åˆ«åœ°ï¼Œg(0)=f(0)=âˆ£Uâˆ£g(0)=f(0)=|U|g(0)=f(0)=âˆ£Uâˆ£ã€‚ æˆ‘ä»¬æœ‰ï¼š g(n)= âˆ£S1âˆ©S2âˆ©â‹¯Snâˆ’1âˆ©Snâˆ£= âˆ£Uâˆ£âˆ’âˆ£S1â€¾âˆªâ‹¯âˆªSnâ€¾âˆ£= âˆ£Uâˆ£âˆ’âˆ‘m=1n(âˆ’1)mâˆ’1âˆ‘ai&lt;ai+1âˆ£Sa1â€¾âˆ©â‹¯âˆ©Samâ€¾âˆ£= âˆ£Uâˆ£âˆ’âˆ‘i=1n(âˆ’1)iâˆ’1(ni)f(i)= âˆ‘i=0n(âˆ’1)i(ni)f(i)\\begin{aligned} g(n)=\\ &amp;|S_1\\cap S_2\\cap\\cdots S_{n-1}\\cap S_n|\\\\ =\\ &amp;|U|-|\\overline{S_1}\\cup\\cdots\\cup\\overline{S_n}|\\\\ =\\ &amp;|U|-\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i &lt;a_{i+1}}|\\overline{S_{a_1}}\\cap\\cdots\\cap\\overline{S_{a_m}}|\\\\ =\\ &amp; |U|-\\sum_{i=1}^n(-1)^{i-1}\\binom{n}{i}f(i)\\\\ =\\ &amp;\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}f(i) \\end{aligned} g(n)= = = = = â€‹âˆ£S1â€‹âˆ©S2â€‹âˆ©â‹¯Snâˆ’1â€‹âˆ©Snâ€‹âˆ£âˆ£Uâˆ£âˆ’âˆ£S1â€‹â€‹âˆªâ‹¯âˆªSnâ€‹â€‹âˆ£âˆ£Uâˆ£âˆ’m=1âˆ‘nâ€‹(âˆ’1)mâˆ’1aiâ€‹&lt;ai+1â€‹âˆ‘â€‹âˆ£Sa1â€‹â€‹â€‹âˆ©â‹¯âˆ©Samâ€‹â€‹â€‹âˆ£âˆ£Uâˆ£âˆ’i=1âˆ‘nâ€‹(âˆ’1)iâˆ’1(inâ€‹)f(i)i=0âˆ‘nâ€‹(âˆ’1)i(inâ€‹)f(i)â€‹ g(n)=âˆ‘i=0n(âˆ’1)i(ni)f(i) âŸº f(n)=âˆ‘i=0n(âˆ’1)i(ni)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}g(i) \\end{aligned} âŸºâ€‹g(n)=i=0âˆ‘nâ€‹(âˆ’1)i(inâ€‹)f(i)f(n)=i=0âˆ‘nâ€‹(âˆ’1)i(inâ€‹)g(i)â€‹ å¦‚æœä»¤ f(i)â€²=(âˆ’1)if(i)f(i)&#x27;=(-1)^i f(i)f(i)â€²=(âˆ’1)if(i)ï¼Œé‚£ä¹ˆå¯ä»¥å¾—åˆ°å¦ä¸€ä¸ªå½¢å¼ï¼ˆè¿™ä¸ªå½¢å¼æ›´ä¸ºå¸¸ç”¨ï¼Œå› ä¸ºå¤§å¤šæ•°é¢˜å¹¶ä¸ä¼šå‡‘å‡ºä¸€ä¸ª âˆ’1-1âˆ’1ï¼Œä»¥ä¸‹å¼å­ä¸­çš„ f,gf,gf,g å‡æ²¡æœ‰ç‰¹å®šçš„å«ä¹‰ï¼‰ï¼š g(n)=âˆ‘i=0n(ni)f(i) âŸº f(n)=âˆ‘i=0n(âˆ’1)nâˆ’i(ni)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=0}^n\\binom{n}{i}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=0}^n(-1)^{n-i}\\binom{n}{i}g(i) \\end{aligned} âŸºâ€‹g(n)=i=0âˆ‘nâ€‹(inâ€‹)f(i)f(n)=i=0âˆ‘nâ€‹(âˆ’1)nâˆ’i(inâ€‹)g(i)â€‹ åŒæ—¶è¿˜æœ‰ä¸€ç§ä¸ŠæŒ‡æ ‡çš„äºŒé¡¹å¼åæ¼”ï¼š g(n)=âˆ‘i=nN(âˆ’1)i(in)f(i) âŸº f(n)=âˆ‘i=nN(âˆ’1)i(in)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=n}^N(-1)^i\\binom{i}{n}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=n}^N(-1)^i\\binom{i}{n}g(i) \\end{aligned} âŸºâ€‹g(n)=i=nâˆ‘Nâ€‹(âˆ’1)i(niâ€‹)f(i)f(n)=i=nâˆ‘Nâ€‹(âˆ’1)i(niâ€‹)g(i)â€‹ g(n)=âˆ‘i=nN(in)f(i) âŸº f(n)=âˆ‘i=nN(âˆ’1)iâˆ’n(in)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=n}^N\\binom{i}{n}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=n}^N(-1)^{i-n}\\binom{i}{n}g(i) \\end{aligned} âŸºâ€‹g(n)=i=nâˆ‘Nâ€‹(niâ€‹)f(i)f(n)=i=nâˆ‘Nâ€‹(âˆ’1)iâˆ’n(niâ€‹)g(i)â€‹ å…·ä½“åº”ç”¨è¯·è§ Problemsetã€‚ æ–æ³¢é‚£å¥‘æ•° å¡ç‰¹å…°æ•° æ ¼è·¯è®¡æ•°é—®é¢˜ åœ¨å¹³é¢ç›´è§’åæ ‡ç³»ä¸­ï¼Œæ¨ªåæ ‡å’Œçºµåæ ‡éƒ½æ˜¯æ•´æ•°çš„ç‚¹ç§°ä¸ºæ ¼ç‚¹ï¼Œæ ¼è·¯æ˜¯æŒ‡åªç»è¿‡æ ¼ç‚¹çš„è·¯å¾„ï¼Œæ ¼è·¯çš„é•¿åº¦æ˜¯å…¶ç»è¿‡æ ¼ç‚¹æ‰€èµ°çš„æ­¥æ•°ã€‚ çœ‹ä¼¼ç®€å•çš„é—®é¢˜å®åˆ™æœ‰éå¸¸å¤šçš„å˜ç§ï¼Œè¿™é‡Œä»…çœ‹å‡ ç§ç®€å•çš„ã€‚ è‡ªç”±è·¯é—®é¢˜ ä» (0,0)(0,0)(0,0) åˆ° (n,m)(n,m)(n,m)ï¼Œåªèƒ½å‘ä¸Šèµ°æˆ–è€…å‘å³èµ°çš„æ ¼è·¯ç§°ä¸ºè‡ªç”±è·¯ï¼Œä¸éš¾çœ‹å‡ºæ–¹æ¡ˆæ•°ä¸º (n+mm)\\dbinom{n+m}{m}(mn+mâ€‹)ã€‚ æ–¯ç‰¹æ—æ•° å…¶å®ƒè®¡æ•°æ•°åˆ— è´å°”æ•° ä¼¯åŠªåˆ©æ•° åˆ†æ‹†æ•° æ¬§æ‹‰æ•° Problemset çŸ¥è¯†ç‚¹æ¯”è¾ƒæ‚ï¼Œå¯èƒ½éœ€è¦ç»å¸¸å›é¡¾ã€‚ Prufer åºåˆ— åŸºæœ¬ä¸Šåªå°†æ ‘è½¬åŒ–ä¸º Pruferï¼Œåº”ç”¨äºè®¡æ•°ã€‚ [HNOI2004] æ ‘çš„è®¡æ•° Portal. Prufer åºåˆ—å¯ä»¥ä»»æ„æ„é€ ï¼Œè€Œä¸€ä¸ªæ•°ä¼šåœ¨ Prufer åºåˆ—ä¸­é‡å¤å‡ºç° diâˆ’1d_i-1diâ€‹âˆ’1 æ¬¡ï¼Œæ‰€ä»¥å®é™…ä¸Šè¿™æ˜¯å¤šé‡é›†çš„æ’åˆ—æ•°ã€‚å¦å¤–ï¼Œæ³¨æ„åˆ¤æ— è§£ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, s; int d[155]; int c1[155], c2[155]; void divide(int x, int *c) &#123; for (int i = 2; i * i &lt;= x; ++i) while (x % i == 0) ++c[i], x /= i; if (x > 1) ++c[x]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", d + i), s += d[i]; if (n * 2 != s + 2) return !puts(\"0\"); if (n == 1) return !puts(d[1] == 0 ? \"1\" : \"0\"); for (int i = 1; i &lt; n - 1; ++i) divide(i, c1); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; d[i]; ++j) divide(j, c2); if (d[i] == 0) return !puts(\"0\"); &#125; i64 ans = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= c1[i] - c2[i]; ++j) ans *= i; printf(\"%lld\\n\", ans); return 0; &#125; [CF156D] Clues Portal. åªå‰©ä¸‹ kâˆ’2k-2kâˆ’2 ä¸ªç‚¹çš„ Prufer åºåˆ—æ¥å¡«ï¼Œè€Œå·²ç»å¡«äº†çš„è¿é€šå—å¯ä»¥æ ¹æ®ä¹˜æ³•åŸç†éšä¾¿é€‰æ¥ä»£è¡¨å°†æ­¤è”é€šå—æŠ½è±¡æˆä¸€ä¸ªç‚¹æ¥æ ¹æ® Prufer åºåˆ—æ„å»ºæ ‘ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int P; int poww(int a, int b) &#123; if (b &lt; 0) return 1; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n, m; int col[100005], cnt, siz[100005]; vector&lt;int> G[100005]; void dfs(int x) &#123; ++siz[col[x] = cnt]; for (int y : G[x]) if (!col[y]) dfs(y); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;P); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; for (int i = 1; i &lt;= n; ++i) if (!col[i]) ++cnt, dfs(i); if (cnt == 1) return printf(\"%d\\n\", 1 % P), 0; int ans = poww(n, cnt - 2); for (int i = 1; i &lt;= cnt; ++i) ans = 1ll * ans * siz[i] % P; printf(\"%d\\n\", ans); return 0; &#125; [CF1762E] Tree Sum Portal. è®¾è¿æ¥ iii çš„è¾¹æƒä¸º did_idiâ€‹ï¼Œè€Œæ¯æ¡è¾¹å¯¹ âˆdi\\prod d_iâˆdiâ€‹ çš„è´¡çŒ®ä¸º 111ï¼Œç„¶è€Œ nnn ä¸ºå¥‡æ•°æ—¶ âˆdi=âˆ’1\\prod d_i=-1âˆdiâ€‹=âˆ’1 æ°¸è¿œä¸å¯èƒ½æ»¡è¶³ï¼Œå› æ­¤ nnn ä¸ºå¥‡æ•°æ—¶æ— è§£ã€‚ å¦‚æœ nnn ä¸ºå¶æ•°ä¸”æ ‘çš„å½¢æ€å›ºå®šï¼Œé‚£ä¹ˆå‚è€ƒ Prufer åºåˆ—çš„æ„é€ æ–¹å¼ï¼Œä»å¶å­å¼€å§‹èµ‹äºˆè¾¹æƒï¼Œé‚£ä¹ˆæ–¹å¼ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºç»™å®šçš„æ ‘çš„å½¢æ€åªæœ‰ä¸€ç§æ–¹å¼ã€‚ è¿™æ ·çš„è¯ï¼Œä¸€æ¡è¾¹ (u,v)(u,v)(u,v) çš„æƒå€¼ä¸º 111 çš„å……è¦æ¡ä»¶æ˜¯ï¼šæ–­æ‰è¿™æ¡è¾¹ä¹‹åä¸¤ä¸ªè¿é€šå—å¤§å°å‡ä¸ºå¶æ•°ã€‚å› ä¸ºè¿™æ ·ä¸¤ä¸ªè¿é€šå—éƒ½æ»¡è¶³æ¡ä»¶äº†ï¼Œè¿™æ¡è¾¹å¡« 111 å³å¯ã€‚ è€ƒè™‘é€è¾¹è®¡ç®—è´¡çŒ®ï¼Œæšä¸¾ 111 æ‰€åœ¨çš„è¿é€šå—å¤§å° iiiï¼Œè¿™æ · nnn æ‰€å¯¹åº”çš„è¿é€šå—å¤§å°ä¾¿ä¸º nâˆ’in-inâˆ’iã€‚ æ­¤æ—¶è¿™æ¡è¾¹çš„è¾¹æƒä¸º (âˆ’1)i(-1)^i(âˆ’1)iã€‚ å‰©ä¸‹ nnn ä¸ªç‚¹ä¸­éšä¾¿æ‰”ï¼Œæ–¹æ¡ˆæ•°ä¸º (nâˆ’2iâˆ’1)\\binom{n-2}{i-1}(iâˆ’1nâˆ’2â€‹)ã€‚ ä¸¤å—éšä¾¿åˆ¶é€ æ— æ ¹æ ‘ï¼Œæ ¹æ® Cayley å…¬å¼è®¡ç®—å³å¯ã€‚ éšä¾¿æ‰¾ä¸¤ä¸ªç‚¹è¿æ¥ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n; int fac[500005], ifac[500005]; int C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; int f(int n) &#123; if (n == 1) return 1; return poww(n, n - 2); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); if (n &amp; 1) return puts(\"0\"), 0; for (int i = fac[0] = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; ifac[n] = poww(fac[n], P - 2); for (int i = n - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; int ans = 0; for (int i = 1; i &lt; n; ++i) ans = (ans + (i &amp; 1 ? -1ll : 1ll) * i * (n - i) % P * C(n - 2, i - 1) % P * f(i) % P * f(n - i) % P) % P; printf(\"%d\\n\", (ans % P + P) % P); return 0; &#125; æ ¼è·¯è®¡æ•°é—®é¢˜ å…¶å˜ç§å¾ˆå¤šï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œç ”ç©¶ã€‚ [CF559C] Gerald and Giant Chess Portal. è®¾ f(i)f(i)f(i) ä¸ºèµ°åˆ°ç¬¬ iii ä¸ªç‚¹çš„æ–¹æ¡ˆæ•°ï¼Œç„¶åç›´æ¥è½¬ç§»å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #define X first #define Y second using namespace std; typedef long long i64; const int MOD = 1000000007; int poww(i64 a, int b) &#123; a %= MOD; int res = 1; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int h, w, n; pair&lt;int, int> a[2005]; i64 fac[200005], f[2005]; int C(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || n &lt; m) return 0; return fac[n] * poww(fac[m] * fac[n - m], MOD - 2) % MOD; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;h, &amp;w, &amp;n); fac[0] = 1; for (int i = 1; i &lt;= 200000; ++i) fac[i] = fac[i - 1] * i % MOD; for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;a[i].X, &amp;a[i].Y); sort(a + 1, a + n + 1); a[n + 1] = &#123;h, w&#125;; for (int i = 1; i &lt;= n + 1; ++i) &#123; f[i] = C(a[i].X + a[i].Y - 2, a[i].X - 1); for (int j = 1; j &lt; i; ++j) f[i] = (f[i] - f[j] * C(a[i].X - a[j].X + a[i].Y - a[j].Y, a[i].X - a[j].X)) % MOD; f[i] = (f[i] + MOD) % MOD; &#125; printf(\"%lld\\n\", f[n + 1]); return 0; &#125; [JLOI2015] éª—æˆ‘å‘¢ Portal.è¯´èµ·æ¥ï¼Œæ¯•ä¸šä¹‹å B å›ä¹Ÿå°±è§è¿‡ R å›ä¸¤é¢è€Œå·²ã€‚R å›æœ‰ä¸€ä¸ª nÃ—mn \\times mnÃ—m çš„æ•°ç»„ xi,j(1â‰¤iâ‰¤n;1â‰¤jâ‰¤m)x_{i,j}(1 \\le i \\le n; 1 \\le j \\le m)xi,jâ€‹(1â‰¤iâ‰¤n;1â‰¤jâ‰¤m)ã€‚å¯¹äº 1â‰¤iâ‰¤n;1â‰¤jâ‰¤m1 \\le i \\le n; 1 \\le j \\le m1â‰¤iâ‰¤n;1â‰¤jâ‰¤mï¼Œæ»¡è¶³0â‰¤xi,jâ‰¤m0 \\le x_{i,j} \\le m0â‰¤xi,jâ€‹â‰¤mã€‚æ±‚ å¯èƒ½çš„æ•°ç»„xi,jx_{i,j}xi,jâ€‹ çš„è§£æ•°ã€‚B å›è§‰å¾—é™åˆ¶å¤ªå®½æ¾ï¼Œè¿˜è¦æ±‚å¯¹äº 1â‰¤iâ‰¤n;1â‰¤j&lt;m1 \\le i \\le n; 1 \\le j&lt;m1â‰¤iâ‰¤n;1â‰¤j&lt;mï¼Œæ»¡è¶³ xi,j&lt;xi,j+1x_{i,j} &lt;x_{i,j+1}xi,jâ€‹&lt;xi,j+1â€‹ï¼Œå¯¹äº 1&lt;iâ‰¤n;1â‰¤j&lt;m1 &lt;i \\le n; 1 \\le j&lt;m1&lt;iâ‰¤n;1â‰¤j&lt;mï¼Œæ»¡è¶³ xi,j&lt;xiâˆ’1,j+1x_{i,j} &lt;x_{i-1,j+1}xi,jâ€‹&lt;xiâˆ’1,j+1â€‹ã€‚B å›è®¤ä¸º R å›å¯ä»¥ç›´æ¥ pwn æ‰è¿™ä¸ªé¢˜ã€‚R å›è¯´ï¼šã€Œé»‘çš„å®åœ¨é€¼çœŸ =.=ï¼Œä½ èµ·ç æŠŠè§£æ•°æ¨¡ 109+710^9+7109+7 å§ã€‚ã€B å›è§‰å¾— R å›è¯´çš„æœ‰é“ç†ï¼Œäºæ˜¯æƒ³è®©ä½ æ±‚è§£æ•°æ¨¡ 109+710^9+7109+7 çš„ç»“æœã€‚å¯¹äº 100%100\\%100% çš„æ•°æ®ï¼Œ1â‰¤m,nâ‰¤1061 \\leq m, n \\leq 10^61â‰¤m,nâ‰¤106ã€‚ å†™å‡ºæš´åŠ› DP è½¬ç§»æ–¹ç¨‹åå‘ç°è¿™å…¶å®æ˜¯ä¸ªæ ¼è·¯è®¡æ•°é—®é¢˜ï¼Œèµ·ç‚¹æ˜¯ (0,0)(0,0)(0,0)ï¼Œç»ˆç‚¹æ˜¯ (n+m+1,n)(n+m+1,n)(n+m+1,n)ï¼Œä¸èƒ½ç¢°åˆ° y=x+1,y=xâˆ’mâˆ’2y=x+1, y=x-m-2y=x+1,y=xâˆ’mâˆ’2ã€‚ æˆ‘ä»¬å°†ç»ˆç‚¹ TTT åšå…³äºä¸¤æ¡ç›´çº¿çš„å¯¹ç§°ï¼Œå¾—åˆ° T1,T2T1,T2T1,T2ï¼ˆç¿»è½¬ä¹‹åçš„è·¯å¾„ä¹Ÿæ˜¯å¯ä»¥ç¿»è½¬çš„ï¼‰ã€‚è¿™æ ·æˆ‘ä»¬åªéœ€è¦å‡å»ç»è¿‡ä¸¤æ¡ç›´çº¿çš„æ–¹æ¡ˆæ•°ï¼Œè€Œä¸”æ˜¯æœ€åç»è¿‡çš„ï¼ˆå¦åˆ™å…ˆç»è¿‡ä¸€æ¡ç›´çº¿å†ç»è¿‡å¦ä¸€æ¡çš„è¿™ç§ä¼šç®—é‡ï¼Œè¦åŠæ—¶å‡å»ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 1000000007; const int N = 3000000; int n, m; int fac[N + 5]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int C(int n, int m) &#123; if (n &lt; m || n &lt; 0 || m &lt; 0) return 0; return 1ll * fac[n] * poww(1ll * fac[m] * fac[n - m] % MOD, MOD - 2) % MOD; &#125; void trans(int &amp;x, int &amp;y, int k) &#123; swap(x, y); x -= k; y += k; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); fac[0] = 1; for (int i = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; int ans, x, y; for (x = n + m + 1, y = n, ans = C(x + y, y); x >= 0 &amp;&amp; y >= 0;) &#123; trans(x, y, 1); ans = (ans - C(x + y, y)) % MOD; trans(x, y, -m - 2); ans = (ans + C(x + y, y)) % MOD; &#125; for (x = n + m + 1, y = n; x >= 0 &amp;&amp; y >= 0;) &#123; trans(x, y, - m - 2); ans = (ans - C(x + y, y)) % MOD; trans(x, y, 1); ans = (ans + C(x + y, y)) % MOD; &#125; printf(\"%d\\n\", (ans % MOD + MOD) % MOD); return 0; &#125; ç»„åˆåæ¼”ä¸å®¹æ–¥åŸç† åŒ…æ‹¬äºŒé¡¹å¼åæ¼”å’Œå­é›†åæ¼”ï¼Œå’Œä¸€äº›å®¹æ–¥åŸç†éš¾é¢˜ã€‚ [Luogu P4859] å·²ç»æ²¡æœ‰ä»€ä¹ˆå¥½å®³æ€•çš„äº† Portal.ç»™å®šé•¿åº¦ä¸º nnn çš„ä¸¤ä¸ªåºåˆ— A,BA,BA,Bï¼Œè¦æ±‚ä¸¤ä¸¤é…å¯¹ä½¿å¾— a&gt;ba&gt;ba&gt;b çš„å¯¹æ•°å‡å» a&lt;ba&lt;ba&lt;b çš„å¯¹æ•°ç­‰äº kkk çš„æƒ…å†µä¸ªæ•°ï¼Œå¯¹ 109+910^9+9109+9 å–æ¨¡ï¼Œä¿è¯æ²¡æœ‰é‡å¤æ•°å­—ï¼Œnâ‰¤2000n\\le 2000nâ‰¤2000ã€‚ å°† A,BA,BA,B æ’åºã€‚è®¾ a&gt;ba&gt;ba&gt;b çš„æ•°é‡ä¸º xxxï¼Œé‚£ä¹ˆ x=n+k2x=\\cfrac{n+k}{2}x=2n+kâ€‹ï¼ˆæ¥ä¸‹æ¥çš„ kkk å‡æŒ‡ xxxï¼‰ï¼Œä»¤ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii ä¸ª aaa ä¸­é€‰äº† jjj ç»„ a&gt;ba&gt;ba&gt;b çš„æ–¹æ¡ˆæ•°ï¼Œæ˜“å¾— f0,0=1,fi,j=fiâˆ’1,j+fiâˆ’1,jâˆ’1âˆ—(l[i]âˆ’j+1)f_{0,0}=1,f_{i,j}=f_{i-1,j}+f_{i-1,j-1}*(l[i]-j+1)f0,0â€‹=1,fi,jâ€‹=fiâˆ’1,jâ€‹+fiâˆ’1,jâˆ’1â€‹âˆ—(l[i]âˆ’j+1)ï¼ˆl[i]l[i]l[i] ä»£è¡¨ BBB ä¸­æœ€åä¸€ä¸ªå¯ä»¥é€‰çš„ï¼‰ã€‚ è®¾ g(i)g(i)g(i) ä»£è¡¨æ»¡è¶³ a&gt;ba&gt;ba&gt;b çš„ç»„æ•° â‰¥i\\ge iâ‰¥i çš„æ–¹æ¡ˆæ•°ï¼Œè€Œ f(i)f(i)f(i) ä»£è¡¨æ°å¥½ã€‚æ˜¾ç„¶ gi=fn,iÃ—(nâˆ’i)!, g(k)=âˆ‘i=kn(ik)f(i)g_i=f_{n,i}\\times (n-i)!,\\ g(k)=\\sum_{i=k}^{n}\\binom{i}{k}f(i)giâ€‹=fn,iâ€‹Ã—(nâˆ’i)!, g(k)=âˆ‘i=knâ€‹(kiâ€‹)f(i)ï¼ˆåœ¨ iii ä¸­é€‰æ‹© kkk ä¸ªä½œä¸ºâ€œè‡³å°‘â€æ‰€è¦æ±‚çš„å†…å®¹ï¼‰ï¼Œä½¿ç”¨äºŒé¡¹å¼åæ¼”å³å¯æ±‚å‡º f(k)f(k)f(k)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 1000000009; int poww(i64 a, int b) &#123; int res = 1; a %= MOD; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int n, k; int a[2005], b[2005], l[2005]; i64 f[2005][2005], g[2005], fac[2005]; int C(int n, int m) &#123; return fac[n] * poww(fac[m] * fac[n - m], MOD - 2) % MOD; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); k = (n + k) / 2; fac[0] = 1; for (int i = 1; i &lt;= 2002; ++i) fac[i] = fac[i - 1] * i % MOD; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i); sort(a + 1, a + n + 1); sort(b + 1, b + n + 1); f[0][0] = 1; for (int i = 1, p = 0; i &lt;= n; ++i) &#123; while (p &lt; n &amp;&amp; b[p + 1] &lt; a[i]) ++p; l[i] = p; &#125; for (int i = 1; i &lt;= n; ++i) &#123; f[i][0] = f[i-1][0]; for (int j = 1; j &lt;= i; ++j) f[i][j] = (f[i-1][j] + f[i-1][j-1] * max(0, l[i] - j + 1)) % MOD; &#125; for (int i = 0; i &lt;= n; ++i) g[i] = f[n][i] * fac[n - i] % MOD; int ans = 0; for (int i = k; i &lt;= n; ++i) ans = (ans + C(i, k) * g[i] * (i - k &amp; 1 ? -1 : 1)) % MOD; printf(\"%d\\n\", (ans % MOD + MOD) % MOD); return 0; &#125; [NOI Online #2 æé«˜ç»„] æ¸¸æˆ Portal. è®¾ g(n)g(n)g(n) ä»£è¡¨æ°å¥½æœ‰ nnn ä¸ªéå¹³å±€ï¼Œf(n)f(n)f(n) ä»£è¡¨è‡³å°‘æœ‰ nnn ä¸ªéå¹³å±€ï¼ˆå¯ä»¥é€šè¿‡æ ‘å½¢èƒŒåŒ…æ±‚å‡ºï¼‰ï¼Œä¸¤è€…æ˜¯ä¸€ä¸ªäºŒé¡¹å¼åæ¼”çš„å½¢å¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 998244353; int poww(i64 a, int b) &#123; int res = 1; a %= MOD; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int n, a[5005], fac[5005], ifac[5005]; int siz[5005], sz[5005], g[5005], f[5005][5005]; // f: è‡³å°‘æœ‰ i ä¸ªéå¹³å±€ vector&lt;int> G[5005]; i64 C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % MOD * ifac[n - m] % MOD; &#125; void dfs(int x, int fa) &#123; siz[x] = 1; sz[x] = a[x]; f[x][0] = 1; for (auto y : G[x]) if (y != fa) &#123; dfs(y, x); for (int k = 0; k &lt;= siz[x] + siz[y]; ++k) g[k] = 0; for (int i = 0; i &lt;= min(siz[x], n / 2); ++i) if (f[x][i]) for (int j = 0; j &lt;= min(siz[y], n / 2); ++j) if (f[y][j]) g[i + j] = (g[i + j] + 1ll * f[x][i] * f[y][j] % MOD) % MOD; for (int k = 0; k &lt;= siz[x] + siz[y]; ++k) f[x][k] = g[k]; siz[x] += siz[y]; sz[x] += sz[y]; &#125; for (int i = min(sz[x], siz[x] - sz[x]); i >= 1; --i) f[x][i] = (f[x][i] + 1ll * f[x][i - 1] * ((a[x] ? siz[x] - sz[x] : sz[x]) - (i - 1))) % MOD; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%1d\", a + i); fac[i] = 1ll * fac[i - 1] * i % MOD; ifac[i] = poww(fac[i], MOD - 2); &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 0; i &lt;= n / 2; ++i) f[1][i] = 1ll * f[1][i] * fac[n / 2 - i] % MOD; // é™¤å¹³å±€å¤–ï¼Œå‰©ä¸‹çš„éšä¾¿ for (int i = 0; i &lt;= n / 2; ++i) &#123; i64 res = 0; for (int j = i; j &lt;= n / 2; ++j) res = (res + (j - i &amp; 1 ? -1 : 1) * C(j, i) * f[1][j]) % MOD; printf(\"%lld\\n\", (res % MOD + MOD) % MOD); &#125; return 0; &#125; [ZJOI2016] å°æ˜Ÿæ˜Ÿ Portal.ç»™å®šä¸€å¼  nnn ä¸ªç‚¹çš„æ— å‘å›¾å’Œä¸€æ£µ nnn ä¸ªèŠ‚ç‚¹çš„æ ‘ã€‚ä½ å¯ä»¥ç»™è¿™æ£µæ ‘é‡ç¼–å·ï¼Œé—®æœ‰å¤šå°‘ç§æ–¹å¼ä½¿å¾—è¿™æ£µæ ‘æ˜¯åŸå›¾çš„ç”Ÿæˆæ ‘ã€‚nâ‰¤17n\\le 17nâ‰¤17ã€‚ æƒ³çš„æš´åŠ›ç‚¹ï¼Œè®¾ fi,j,Sf_{i,j,S}fi,j,Sâ€‹ ä»£è¡¨è€ƒè™‘ iii çš„å­æ ‘ï¼Œiii çš„ç¼–å·ä¸º jjjï¼Œå­æ ‘å†…çš„é›†åˆç¼–å·é›†åˆçŠ¶å‹åä¸º SSS çš„æ–¹æ¡ˆæ•°ã€‚ä½†æ˜¯è¿˜å¾—æšä¸¾å­é›†ï¼Œä¹˜ä¸€ä¸ª O(3n)O(3^n)O(3n) å—ä¸äº†ï¼ å¦‚æœæˆ‘ä»¬èƒ½æ±‚å‡ºå…è®¸é‡å¤çš„ç­”æ¡ˆä¹Ÿå¯ä»¥ã€‚å®šä¹‰ f(S)f(S)f(S) ä»£è¡¨ SSS æ²¡æœ‰é‡å¤æ—¶çš„æ–¹æ¡ˆæ•°ï¼Œè€Œ g(S)g(S)g(S) ä»£è¡¨ SSS ä¸­æ¯ä¸ªå…ƒç´ è‡³å°‘ç”¨ä¸€æ¬¡ã€‚è¿™æ ·æ±‚å‡º ggg ä¹‹åç›´æ¥ç”¨å­é›†åæ¼”ç¢¾è¿‡å»å³å¯ã€‚ è®¾ fi,j,Sf_{i,j,S}fi,j,Sâ€‹ ä»£è¡¨ç‚¹ iii ä»£è¡¨ç‚¹ jjjï¼Œå­æ ‘å†…ç‚¹åªèƒ½ä½¿ç”¨ SSS å†…çš„ä½œä¸ºæ˜ å°„ï¼Œä½†æ˜¯æ— éœ€ä¸é‡å¤ã€‚ æœ‰ï¼š fi,j,S=âˆyâˆˆson(x)(âˆ‘kâˆˆS,(j,k)âˆˆEfy,k,S)f_{i,j,S}=\\prod_{y\\in son(x)}\\left(\\sum_{k\\in S,(j,k)\\in E}f_{y,k,S}\\right) fi,j,Sâ€‹=yâˆˆson(x)âˆâ€‹â€‹kâˆˆS,(j,k)âˆˆEâˆ‘â€‹fy,k,Sâ€‹â€‹ æ—¶é—´å¤æ‚åº¦é™è‡³ O(2nn3)O(2^n n^3)O(2nn3)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, S, v[20], tot; int E[20][20]; i64 f[20][20]; vector&lt;int> G[20]; void dfs(int x, int fa) &#123; for (int i = 1; i &lt;= tot; ++i) f[x][i] = 1; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); for (int i = 1; i &lt;= tot; ++i) &#123; // f[x][i] i64 tmp = 0; for (int j = 1; j &lt;= tot; ++j) if (E[v[i]][v[j]]) tmp += f[y][j]; f[x][i] *= tmp; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u][v] = E[v][u] = 1; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; i64 ans = 0; for (int S = 0; S &lt; 1 &lt;&lt; n; ++S) &#123; tot = 0; for (int i = 0; i &lt; n; ++i) if (S >> i &amp; 1) v[++tot] = i + 1; dfs(1, 0); i64 g = 0; for (int i = 1; i &lt;= tot; ++i) g += f[1][i]; ans += (n - tot &amp; 1) ? -g : g; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [ZJOI2022] æ ‘ Portal. å¼€ å¹• é›· å‡»ã€‚ æ•°æ•°é¢˜ä¼˜å…ˆè€ƒè™‘ DPã€‚è½¬ç§»åªèƒ½å¯¹æ¯ä¸ªç‚¹åœ¨ä¸¤æ£µæ ‘ä¸Šçš„çˆ¶äº²è¿›è¡Œå†³ç­–ï¼Œè¿™æ · DP çŠ¶æ€åªèƒ½è®°å½•å¯è¡Œçš„å†³ç­–ç‚¹ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥ä½œä¸ºçˆ¶äº²çš„ç‚¹çš„ä¸ªæ•°ã€‚è¿™æ ·å°±è¦é’¦å®šå‰©ä½™èŠ‚ç‚¹ä¸ºå¶å­èŠ‚ç‚¹ã€‚ è®¾ f(S)f(S)f(S) ä»£è¡¨ç¬¬ä¸€æ£µæ ‘çš„å¶å­é›†åˆæ°å¥½ä¸º SSSï¼Œg(T)g(T)g(T) ä»£è¡¨ç¬¬äºŒæ£µå­æ ‘çš„å¶å­é›†åˆæ°å¥½ä¸º TTTã€‚ä½†æ˜¯ä¸å¥½æï¼è€ƒè™‘å­é›†åæ¼”ï¼Œè®¾ fâ€²(Sâ€²)f&#x27;(S&#x27;)fâ€²(Sâ€²) ä»£è¡¨é’¦å®šäº†ç¬¬ä¸€æ£µæ ‘çš„å¶å­èŠ‚ç‚¹è‡³å¤šä¸º Sâ€²S&#x27;Sâ€²ï¼Œgâ€²(Tâ€²)g&#x27;(T&#x27;)gâ€²(Tâ€²) åŒç†ï¼Œåˆ™ï¼š Ans=âˆ‘Sâˆ©T=âˆ…,SâˆªT={1,2,â‹¯ ,n}f(S)g(T)=âˆ‘Sâˆ©T=âˆ…,SâˆªT={1,2,â‹¯ ,n}âˆ‘Sâ€²âŠ†S,Tâ€²âŠ†Tfâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’1)âˆ£Sâˆ£âˆ’âˆ£Sâ€²âˆ£+âˆ£Tâˆ£âˆ’âˆ£Tâ€²âˆ£=âˆ‘Sâ€²âˆ©Tâ€²=âˆ…fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’1)nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£2nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£=âˆ‘Sâ€²âˆ©Tâ€²=âˆ…fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’2)nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£\\begin{aligned} Ans&amp;=\\sum_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,\\cdots,n\\}}f(S)g(T)\\\\&amp;=\\sum_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,\\cdots,n\\}}\\sum_{S&#x27;\\subseteq S,T&#x27;\\subseteq T}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{|S|-|S&#x27;|+|T|-|T&#x27;|} \\\\&amp;=\\sum_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{n-|S&#x27;|-|T&#x27;|}2^{n-|S&#x27;|-|T&#x27;|}\\\\&amp;=\\sum_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-2)^{n-|S&#x27;|-|T&#x27;|} \\end{aligned} Ansâ€‹=Sâˆ©T=âˆ…,SâˆªT={1,2,â‹¯,n}âˆ‘â€‹f(S)g(T)=Sâˆ©T=âˆ…,SâˆªT={1,2,â‹¯,n}âˆ‘â€‹Sâ€²âŠ†S,Tâ€²âŠ†Tâˆ‘â€‹fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’1)âˆ£Sâˆ£âˆ’âˆ£Sâ€²âˆ£+âˆ£Tâˆ£âˆ’âˆ£Tâ€²âˆ£=Sâ€²âˆ©Tâ€²=âˆ…âˆ‘â€‹fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’1)nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£2nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£=Sâ€²âˆ©Tâ€²=âˆ…âˆ‘â€‹fâ€²(Sâ€²)gâ€²(Tâ€²)(âˆ’2)nâˆ’âˆ£Sâ€²âˆ£âˆ’âˆ£Tâ€²âˆ£â€‹ ç›¸å½“äºé’¦å®šäº† Sâ€²,Tâ€²S&#x27;,T&#x27;Sâ€²,Tâ€² ä½œä¸ºå¯é€‰åšçˆ¶äº²çš„é›†åˆï¼ˆé€‰æ‹©ä¸€ä¸ªå¶å­å˜æˆçˆ¶äº²ï¼‰ï¼Œè¿™æ ·è®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ ä»£è¡¨è€ƒè™‘åˆ°ç¬¬ iii ä¸ªèŠ‚ç‚¹ï¼Œâˆ£{1,â‹¯ ,i}âˆ©Sâ€²âˆ£=j,âˆ£{i+1â‹¯n}âˆ©Tâ€²âˆ£=k|\\{1,\\cdots,i\\}\\cap S&#x27;|=j,|\\{i+1\\cdots n\\}\\cap T&#x27;|=kâˆ£{1,â‹¯,i}âˆ©Sâ€²âˆ£=j,âˆ£{i+1â‹¯n}âˆ©Tâ€²âˆ£=k çš„æ–¹æ¡ˆæ•°ã€‚åœ¨ç¬¬ä¸€æ£µå­æ ‘å½“ä¸­æœ‰ jjj ä¸­é€‰æ‹©çˆ¶äº²çš„æ–¹æ³•ï¼Œç¬¬äºŒæ£µæ ‘ä¸­æœ‰ kkk ç§ï¼Œæ€»å…± jÃ—kj\\times kjÃ—k ç§ã€‚ fiâˆ’1,j,kf_{i-1,j,k}fiâˆ’1,j,kâ€‹ å¯ä»¥è½¬ç§»åˆ°å¦‚ä¸‹çŠ¶æ€ï¼š iii æœ¬æ¥å±äº Sâ€²S&#x27;Sâ€²ï¼Œå¯ä»¥è½¬ç§»åˆ° fi,j+1,kf_{i,j+1,k}fi,j+1,kâ€‹ï¼› iii æœ¬æ¥å±äº Tâ€²T&#x27;Tâ€²ï¼Œè½¬ç§»åˆ° fi,j,kâˆ’1f_{i,j,k-1}fi,j,kâˆ’1â€‹ï¼› ä¸¤ä¸ªéƒ½ä¸å±äºï¼Œè½¬ç§»åˆ° fi,j,kf_{i,j,k}fi,j,kâ€‹ï¼Œå®¹æ–¥ç³»æ•°ä¸º âˆ’2-2âˆ’2ã€‚ å¥½åƒæœ‰äººåœ¨è€ƒåœºä¸Šç›´æ¥çŒœå‡ºäº†å®¹æ–¥ç³»æ•°ï¼Œç¥ç§˜çš„ã€‚ åˆå§‹æ—¶ f1,1,k=1f_{1,1,k}=1f1,1,kâ€‹=1ï¼Œç»Ÿè®¡ k=1k=1k=1 æ—¶çš„ç­”æ¡ˆå³å¯ï¼ˆSSS ç¡®å®š TTT è‡ªç„¶ä¹Ÿç¡®å®šäº†ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int f[505][505][505], P; int main(void) &#123; scanf(\"%d%lld\", &amp;n, &amp;P); for (int i = 1; i &lt; n; ++i) f[1][1][i] = 1; for (int i = 2; i &lt;= n; ++i) &#123; int ans = 0; for (int j = 1; j &lt; i; ++j) for (int k = 1; k &lt;= n - i + 1; ++k) if (f[i - 1][j][k]) &#123; f[i][j][k] = (f[i][j][k] + -2ll * f[i - 1][j][k] % P * j * k % P) % P; f[i][j + 1][k] = (f[i][j + 1][k] + 1ll * f[i - 1][j][k] * j * k % P) % P; if (k) &#123; f[i][j][k - 1] = (f[i][j][k - 1] + 1ll * f[i - 1][j][k] * j * k % P) % P; if (k == 1) ans = (ans + 1ll * f[i - 1][j][k] * j * k % P) % P; &#125; &#125; printf(\"%d\\n\", (ans % P + P) % P); &#125; return 0; &#125; ç»„åˆç»¼åˆ éå¸¸æœ‰æ„æ€ï¼ [LNOI2022] ç›’ Portal. å‘ç° wiw_iwiâ€‹ ä¼šè¢«ä½¿ç”¨ âˆ‘âˆ£âˆ‘j=1ibjâˆ’âˆ‘j=1iajâˆ£\\sum |\\sum_{j=1}^i b_j-\\sum_{j=1}^i a_j|âˆ‘âˆ£âˆ‘j=1iâ€‹bjâ€‹âˆ’âˆ‘j=1iâ€‹ajâ€‹âˆ£ æ¬¡ã€‚æšä¸¾ j=âˆ‘k=1ibkj=\\sum_{k=1}^i b_kj=âˆ‘k=1iâ€‹bkâ€‹ï¼Œå°† aaa è½¬åŒ–ä¸ºå…¶å‰ç¼€å’Œï¼Œåˆæ³•çš„ i,ji,ji,j çš„å‡ºç°æ¡ä»¶æ˜¯å‰ iii ä¸ªæ•°å’Œä¸º jjjï¼Œå nâˆ’in-inâˆ’i ä¸ªæ•°å’Œä¸º Sâˆ’jS-jSâˆ’jï¼Œäºæ˜¯ç›´æ¥æ’æ¿å¯ä»¥å¾—åˆ°æ€»è´¡çŒ®ï¼š âˆ‘i=1nâˆ’1wiâˆ‘j=0Sâˆ£jâˆ’aiâˆ£(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^S |j-a_i|\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} i=1âˆ‘nâˆ’1â€‹wiâ€‹j=0âˆ‘Sâ€‹âˆ£jâˆ’aiâ€‹âˆ£(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹) è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(nS)O(nS)O(nS) çš„ã€‚è€ƒè™‘æ‹†ç»å¯¹å€¼ï¼Œå¤§æ¦‚åƒè¿™æ ·ï¼š âˆ‘i=1nâˆ’1wiâˆ‘j=0S(jâˆ’ai)(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)+2âˆ‘i=1nâˆ’1wiâˆ‘j=0ai(aiâˆ’j)(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^S (j-a_i)\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1}+2\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^{a_i} (a_i-j)\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} i=1âˆ‘nâˆ’1â€‹wiâ€‹j=0âˆ‘Sâ€‹(jâˆ’aiâ€‹)(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹)+2i=1âˆ‘nâˆ’1â€‹wiâ€‹j=0âˆ‘aiâ€‹â€‹(aiâ€‹âˆ’j)(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹) è¿™æ ·è®© jjj ä» 000 å¼€å§‹æšä¸¾çš„ç›®çš„æ˜¯è®©æ¥ä¸‹æ¥å¥½ç®—ã€‚åé¢çš„å¼å­æ˜¾ç„¶æ¡ä»¶æ›´å¼ºï¼Œå› æ­¤ä»¥åé¢é‚£ä¸ªä¸ºä¾‹ã€‚ç”±äºå‡ºç°å‡æ³•ä¸å¥½æï¼Œå› æ­¤æ‹†æ‰ï¼š âˆ‘j=0aiai(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)âˆ’âˆ‘j=0aij(j+iâˆ’1iâˆ’1)(Sâˆ’j+nâˆ’iâˆ’1nâˆ’iâˆ’1)\\sum_{j=0}^{a_i} a_i \\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1}-\\sum_{j=0}^{a_i} j\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} j=0âˆ‘aiâ€‹â€‹aiâ€‹(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹)âˆ’j=0âˆ‘aiâ€‹â€‹j(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1Sâˆ’j+nâˆ’iâˆ’1â€‹) å‰é¢é‚£ä¸ª aia_iaiâ€‹ å¯ä»¥ç›´æ¥æå‡ºæ¥ï¼Œåé¢é‚£ä¸ªåˆ©ç”¨ (nm)=(nmâˆ’1)(nâˆ’m+1)\\binom{n}{m}=\\binom{n}{m-1}(n-m+1)(mnâ€‹)=(mâˆ’1nâ€‹)(nâˆ’m+1) å°† jjj æ”¹ä¸º iii å†æ‰”å‡ºæ¥ã€‚ ç°åœ¨ä»…å‰©çš„é—®é¢˜å°±æ˜¯å¿«é€Ÿè®¡ç®—ï¼š f(n,m,i,k)=âˆ‘j=0k(j+iâˆ’1iâˆ’1)(mâˆ’jâˆ’1+nâˆ’inâˆ’iâˆ’1)f(n,m,i,k)=\\sum_{j=0}^k \\binom{j+i-1}{i-1}\\binom{m-j-1+n-i}{n-i-1} f(n,m,i,k)=j=0âˆ‘kâ€‹(iâˆ’1j+iâˆ’1â€‹)(nâˆ’iâˆ’1mâˆ’jâˆ’1+nâˆ’iâ€‹) å¿«é€Ÿè®¡ç®— f(n,m,i,k)f(n,m,i,k)f(n,m,i,k)ï¼Ÿç„¶è€Œè¿™ä¸ªå¼å­æ˜¯æ‹†ä¸åŠ¨äº†ï¼Œè€ƒè™‘ä½¿ç”¨å¢é‡æ³•è®¡ç®—ã€‚kkk çš„å¢é‡æ˜¯å¥½å¤„ç†çš„ï¼Œä½†æ˜¯ iii å‘¢ï¼Ÿä¸çŸ¥é“ã€‚ä»ç»„åˆæ„ä¹‰çš„è§’åº¦è€ƒè™‘ï¼Œfff æ˜¯å°†å‰ iii ä¸ªå’Œ â‰¤k\\le kâ‰¤k çš„æ•°ï¼Œä¸”æ‰€æœ‰ nnn ä¸ªæ•°å’Œä¸º mmm çš„æ–¹æ¡ˆæ•°ã€‚ç›¸å½“äºæ˜¯å°† mmm ä¸ªç›¸åŒçš„çƒæ”¾åˆ° nnn ä¸ªä¸åŒçš„ç›’å­ä¸­ï¼Œå‰ iii ä¸ªç›’å­æœ€å¤šåªèƒ½æ”¾ kkk ä¸ªçƒï¼Œç›¸å½“äºç¬¬ k+1k+1k+1 ä¸ªå°çƒä¸åœ¨å‰ iii ä¸ªç›’å­é‡Œï¼é‚£ä¹ˆæšä¸¾æ”¾çš„ä½ç½®ï¼Œæ’æ¿æœ‰ï¼š f(n,m,i,k)=âˆ‘j=i+1n(k+jâˆ’1jâˆ’1)(mâˆ’kâˆ’1+nâˆ’jnâˆ’j)f(n,m,i,k)=\\sum_{j=i+1}^n \\binom{k+j-1}{j-1}\\binom{m-k-1+n-j}{n-j} f(n,m,i,k)=j=i+1âˆ‘nâ€‹(jâˆ’1k+jâˆ’1â€‹)(nâˆ’jmâˆ’kâˆ’1+nâˆ’jâ€‹) é‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨è¿™ä¸ªå¼å­ç»´æŠ¤ iii çš„å¢é‡äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; const int N = 4000000; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x; &#125; inline int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n; int a[500005], w[500005]; int fac[4000005], ifac[4000005]; int C(int n, int m) &#123; if (m &lt; 0 || n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; struct Creeper &#123; int n, m, i, k, ans; Creeper(int n, int m, int i, int k) : n(n), m(m), i(i), k(k), ans(0) &#123; for (int j = 0; j &lt;= k; ++j) ans = (ans + 1ll * C(j + i - 1, i - 1) * C(m - j + n - i - 1, n - i - 1)) % P; &#125; void mvi(int mi) &#123; for (int j = i + 1; j &lt;= mi; ++j) ans = (ans - 1ll * C(k + j - 1, j - 1) * C(m - k - 1 + n - j, n - j)) % P; i = mi; &#125; void mvk(int mk) &#123; for (int j = k + 1; j &lt;= mk; ++j) ans = (ans + 1ll * C(j + i - 1, i - 1) * C(m - j - 1 + n - i, n - i - 1)) % P; k = mk; &#125; &#125;; int main(void) &#123; for (int i = fac[0] = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % P; ifac[N] = poww(fac[N], P - 2); for (int i = N - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; for (int T = read(); T--; ) &#123; n = read(); int ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = a[i - 1] + read(); for (int i = 1; i &lt; n; ++i) w[i] = read(); Creeper A(n + 1, a[n] - 1, 1, a[n] - 1); Creeper B(n, a[n], 1, a[n]); Creeper C(n, a[n], 1, 0); Creeper D(n + 1, a[n] - 1, 1, -1); for (int i = 1; i &lt; n; ++i) &#123; int res = 0; C.mvk(a[i]); D.mvk(a[i] - 1); A.mvi(i + 1); B.mvi(i); C.mvi(i); D.mvi(i + 1); res = (res + 1ll * i * A.ans) % P; res = (res - 1ll * a[i] * B.ans) % P; res = (res + 2ll * a[i] * C.ans) % P; res = (res - 2ll * i * D.ans) % P; ans = (ans + 1ll * res * w[i]) % P; &#125; printf(\"%d\\n\", (ans % P + P) % P); &#125; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"æ•°å­¦","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°å­¦","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"ç»„åˆæ•°å­¦","slug":"ç»„åˆæ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"å¤šé¡¹å¼ä¸ç”Ÿæˆå‡½æ•°åŸºç¡€","slug":"notes/æ•°å­¦/polynomial","date":"2022-12-23T00:00:00.000Z","updated":"2022-12-23T00:00:00.000Z","comments":true,"path":"18f7c808/","link":"","permalink":"https://james1badcreeper.github.io/18f7c808/","excerpt":"å¤šé¡¹å¼å¾ˆæœ‰å·¥ç¨‹ä»·å€¼ï¼ˆä¸ä»…é™äºè®¡ç®—æœºç§‘å­¦ï¼‰ï¼Œç ”ç©¶å¤šé¡¹å¼è®¡ç®—åŠå…¶æ€§è´¨ï¼Œå¯ä»¥åŠ é€Ÿè®¸å¤šè¿ç®—ã€‚è€Œä»¥ FFT ä¸ºåŸºç¡€çš„ç®—æ³•å¯ä»¥ç›´æ¥æ“çºµç”Ÿæˆå‡½æ•°ã€‚","text":"å¤šé¡¹å¼å¾ˆæœ‰å·¥ç¨‹ä»·å€¼ï¼ˆä¸ä»…é™äºè®¡ç®—æœºç§‘å­¦ï¼‰ï¼Œç ”ç©¶å¤šé¡¹å¼è®¡ç®—åŠå…¶æ€§è´¨ï¼Œå¯ä»¥åŠ é€Ÿè®¸å¤šè¿ç®—ã€‚è€Œä»¥ FFT ä¸ºåŸºç¡€çš„ç®—æ³•å¯ä»¥ç›´æ¥æ“çºµç”Ÿæˆå‡½æ•°ã€‚ æ¦‚å¿µ ä¸€ä¸ªç¯ RRR ä¸Šçš„å¤šé¡¹å¼å†™ä½œ f(x)f(x)f(x)ï¼Œä»£è¡¨ âˆ‘i=0fixi\\sum\\limits_{i=0} f_ix^{i}i=0âˆ‘â€‹fiâ€‹xiã€‚å…¶ä¸­ fiâˆˆRf_i\\in Rfiâ€‹âˆˆRã€‚xxx è¢«ç§°ä¸ºè¿™ä¸ªå¤šé¡¹å¼çš„è‡ªç”±å…ƒï¼Œæ‰€æœ‰ RRR ä¸Šçš„å¤šé¡¹å¼ç»„æˆå¤šé¡¹å¼ç¯R[x]R[x]R[x]ã€‚ å¦‚æœå…è®¸é¡¹æ•°æ— ç©·çš„ï¼Œå³ f(x)=f0+f1x+f2x2+â‹¯f(x)=f_0+f_1x+f_2x^2+\\cdotsf(x)=f0â€‹+f1â€‹x+f2â€‹x2+â‹¯ï¼Œé‚£ä¹ˆå¯ä»¥å¾—åˆ°å½¢å¼å¹‚çº§æ•°ç¯ R[[x]]R[[x]]R[[x]]ï¼Œå…¶ä¸­çš„æ¯ä¸ªå…ƒç´  fff ç§°ä¸ºå½¢å¼å¹‚çº§æ•°ã€‚ å¯¹äºä¸€ä¸ªå¤šé¡¹å¼ f(x)f(x)f(x)ï¼Œç§°å…¶ç³»æ•°éé›¶çš„æœ€é«˜æ¬¡é¡¹çš„æ¬¡æ•°ä¸ºè¯¥å¤šé¡¹å¼çš„åº¦ï¼ˆDegreeï¼‰ï¼Œè®°ä½œ degâ¡F\\deg FdegFã€‚ ä½¿å¾— f(x)=0f(x)=0f(x)=0 çš„æ‰€æœ‰ xxx ç§°ä¸ºå¤šé¡¹å¼çš„æ ¹ã€‚ å¦‚æœ fif_ifiâ€‹ å‡ä¸ºå®æ•°ï¼Œé‚£ä¹ˆ fff ç§°ä¸ºå®ç³»æ•°å¤šé¡¹å¼ï¼›è‹¥å¯ä»¥ä¸ºå¤æ•°ï¼Œåˆ™æˆä¸ºå¤ç³»æ•°å¤šé¡¹å¼ã€‚ è¡¨ç¤ºæ–¹æ³• å½¢å¼å¹‚çº§æ•°å½¢å¼è¡¨ç¤ºçš„å¤šé¡¹å¼ç§°ä¸ºç³»æ•°è¡¨ç¤ºæ³•ï¼Œè€Œå°† x=xix=x_ix=xiâ€‹ å¸¦å…¥å¤šé¡¹å¼ï¼Œæ±‚å‡ºçš„ yi=f(xi)y_i=f(x_i)yiâ€‹=f(xiâ€‹)ï¼Œç§° (xi,yi)(x_i,y_i)(xiâ€‹,yiâ€‹) ä¸º fff åœ¨ xix_ixiâ€‹ å¤„çš„ç‚¹å€¼ï¼Œä½¿ç”¨è‹¥å¹²ç‚¹å€¼è¡¨ç¤ºå¤šé¡¹å¼çš„æ–¹å¼ç§°ä¸ºç‚¹å€¼è¡¨ç¤ºæ³•ã€‚ æ‹‰æ ¼æœ—æ—¥æ’å€¼ç®—æ³•å¯ä»¥å°†ç‚¹å€¼è¡¨ç¤ºæ³•è½¬åŒ–ä¸ºç³»æ•°è¡¨ç¤ºæ³•ã€‚ å¤šé¡¹å¼åŠ å‡ æœ‰ï¼š f(x)+g(x)=âˆ‘i=0n(fi+gi)xif(x)+g(x)=\\sum_{i=0}^n (f_i+g_i)x^i f(x)+g(x)=i=0âˆ‘nâ€‹(fiâ€‹+giâ€‹)xi æ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ å·ç§¯ è®¾ f, g\\textbf{f, g}f, g æ˜¯ä¸¤ä¸ªæ•°åˆ—ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæ•°åˆ—çš„å·ç§¯ h\\textbf{h}h å®šä¹‰ä¸ºï¼š hk=âˆ‘i+j=kfigjh_k=\\sum_{i+j=k}f_ig_j hkâ€‹=i+j=kâˆ‘â€‹fiâ€‹gjâ€‹ å¤šé¡¹å¼ä¹˜æ³• ç»™å®šå¤šé¡¹å¼ f(x),g(x)f(x),g(x)f(x),g(x)ï¼Œé‚£ä¹ˆå…¶ä¹˜ç§¯ q(x)q(x)q(x) æ»¡è¶³ï¼š q(x)=âˆ‘i=0nâˆ‘j=0maibjxi+jq(x)=\\sum_{i=0}^{n}\\sum_{j=0}^m a_ib_jx^{i+j} q(x)=i=0âˆ‘nâ€‹j=0âˆ‘mâ€‹aiâ€‹bjâ€‹xi+j è¿™ä¸ªè¿‡ç¨‹å¯ä»¥ä½¿ç”¨ FFT åŠ é€Ÿï¼Œå°†åœ¨ä¸‹æ–‡ä»‹ç»ã€‚ æ™®é€šç”Ÿæˆå‡½æ•° ç”Ÿæˆå‡½æ•°ï¼ˆgenerating functionï¼‰ï¼Œåˆç§°æ¯å‡½æ•°ï¼Œæ˜¯ä¸€ç§å½¢å¼å¹‚çº§æ•°ï¼ˆå®ƒä¸æ˜¯å‡½æ•°ï¼Œxxx ä¸æ˜¯è‡ªå˜é‡è€Œæ˜¯è‡ªç”±å…ƒï¼‰ï¼Œå…¶æ¯ä¸€é¡¹çš„ç³»æ•°å¯ä»¥æä¾›å…³äºè¿™ä¸ªåºåˆ—çš„ä¿¡æ¯[1]ã€‚è¿™æ˜¯ä¸ªå¾ˆæœ‰ç”¨çš„ä¸œè¥¿ï¼Œæ˜¯ç”¨äºåˆ»ç”»æ•°åˆ—çš„ç»„åˆå·¥å…·ï¼Œèƒ½å¤Ÿå°†å¾ˆå¤šå¤æ‚çš„ç»„åˆé—®é¢˜èµ‹ä»¥ç®€æ´çš„ä»£æ•°å½¢å¼ï¼Œè€ƒåœºä¸Šä¹Ÿä¼šå‡ºç°ä¸éœ€è¦å¤šé¡¹å¼ç®—æ³•åªç”¨ç”Ÿæˆå‡½æ•°å°±èƒ½è§£å†³çš„é—®é¢˜ã€‚ å¤§å¤šæ•°ç”Ÿæˆå‡½æ•°å¯ä»¥è¡¨ç¤ºä¸ºï¼š F(x)=âˆ‘iaiki(x)F(x)=\\sum_{i} a_i k_i(x) F(x)=iâˆ‘â€‹aiâ€‹kiâ€‹(x) å…¶ä¸­ ki(x)k_i(x)kiâ€‹(x) è¢«ç§°ä¹‹ä¸ºæ ¸å‡½æ•°ï¼Œå¯¹äºæ™®é€šçš„ç”Ÿæˆå‡½æ•°ï¼Œki(x)=xik_i(x)=x^ikiâ€‹(x)=xiã€‚æ³¨æ„è¿™ä¸ª aaa æ—¢å¯ä»¥æ˜¯æœ‰ç©·åºåˆ—ï¼Œä¹Ÿå¯ä»¥æ˜¯æ— ç©·åºåˆ—ã€‚ åœ¨æœ¬å°èŠ‚ä¸­æˆ‘ä»¬åªè®¨è®ºæ™®é€šç”Ÿæˆå‡½æ•°ï¼ˆOGFï¼‰ï¼Œå®ƒçš„æ ¸å‡½æ•°ä¸º kn(x)=xnk_n(x)=x^nknâ€‹(x)=xnã€‚å®é™…ä¸Šï¼Œæ™®é€šç”Ÿæˆå‡½æ•°çš„ç³»æ•°å°±æ˜¯åºåˆ— aaa çš„é€šé¡¹å…¬å¼ã€‚ æœ¯è¯­çº¦å®š å¯¹äº OGF F(x)F(x)F(x)ï¼Œxxx æ˜¯è‡ªç”±å…ƒï¼Œå› æ­¤æ²¡æœ‰å®é™…æ„ä¹‰ï¼Œåªæ˜¯ä¸€ä¸ªå ä½ç¬¦ï¼Œxix_ixiâ€‹ ç”¨æ¥ä»£è¡¨å®ƒæ˜¯ç¬¬ iii ä¸ªå ä½ç¬¦ï¼ŒF[i]F[i]F[i] å¯ä»¥è¡¨ç¤º F(x)F(x)F(x) çš„ç¬¬ iii æ¬¡é¡¹ç³»æ•°ï¼Œç®€ç§° iii æ¬¡é¡¹ï¼Œ000 æ¬¡é¡¹ç§°ä¸ºå¸¸æ•°é¡¹ã€‚ ä¸ºäº†æ–¹ä¾¿æå–å…¶ä¸­æŸä¸€é¡¹çš„ç³»æ•°ï¼Œæœ‰ [xi]F(x)=F[i][x^i]F(x)=F[i][xi]F(x)=F[i]ã€‚ ç”Ÿæˆå‡½æ•°ä¸­çš„æ±‚å’Œç¬¦å·å¹¶ä¸æ˜¯æ— ç©·é¡¹æ±‚å’Œï¼Œå®ƒåªæ˜¯ä¸€ä¸ªè®°å·ï¼Œä»£è¡¨çš„æ˜¯åºåˆ—ã€‚ä¸¤ä¸ªç”Ÿæˆå‡½æ•° F(x),G(x)F(x),G(x)F(x),G(x) ç›¸ç­‰å½“ä¸”ä»…å½“ âˆ€iâˆˆN,F[i]=G[i]\\forall i\\in\\mathbb{N}, F[i]=G[i]âˆ€iâˆˆN,F[i]=G[i]ã€‚ å¯¹äºåºåˆ— aaaï¼Œå¦‚æœä»æŸä¸€é¡¹å¼€å§‹å®ƒåé¢éƒ½æ˜¯ 000ï¼Œé‚£ä¹ˆå¯ä»¥è®¤ä¸ºå®ƒæ˜¯ä¸€ä¸ªæœ‰ç©·åºåˆ—ã€‚å¦‚æœå®ƒæ˜¯æœ‰ç©·çš„ï¼Œé‚£ä¹ˆå®ƒçš„ç”Ÿæˆå‡½æ•°æ˜¯ä¸€ä¸ªæœ‰ç©·å¹‚çº§æ•°ï¼Œå¦åˆ™æ˜¯æ— ç©·å¹‚çº§æ•°ã€‚ åŸºæœ¬è¿ç®— è€ƒè™‘ä¸¤ä¸ªåºåˆ— a,ba,ba,b çš„æ™®é€šç”Ÿæˆå‡½æ•°F(x),G(x)F(x),G(x)F(x),G(x)ï¼Œé‚£ä¹ˆå®ƒä»¬çš„åŠ å‡æ³•å’Œä¹˜æ³•è¿ç®—æ˜¯è·Ÿå¤šé¡¹å¼ä¸€æ ·çš„ã€‚å› æ­¤å¯¹äºç”Ÿæˆå‡½æ•° F(x),G(x)F(x),G(x)F(x),G(x)ï¼Œæœ‰ï¼š F(x)Â±G(x)=âˆ‘n(anÂ±bn)xn,F(x)G(x)=âˆ‘nxnâˆ‘i=0naibnâˆ’i=âˆ‘iâˆ‘jF[i]G[j]xijF(x)\\pm G(x)=\\sum_{n}(a_n\\pm b_n)x^n,\\\\ \\begin{aligned} F(x)G(x)&amp;=\\sum_{n}x^n\\sum_{i=0}^n a_i b_{n-i}\\\\ &amp;=\\sum_{i}\\sum_j F[i]G[j]x^{ij} \\end{aligned} F(x)Â±G(x)=nâˆ‘â€‹(anâ€‹Â±bnâ€‹)xn,F(x)G(x)â€‹=nâˆ‘â€‹xni=0âˆ‘nâ€‹aiâ€‹bnâˆ’iâ€‹=iâˆ‘â€‹jâˆ‘â€‹F[i]G[j]xijâ€‹ å› æ­¤ F(x)Â±G(x)F(x)\\pm G(x)F(x)Â±G(x) æ˜¯åºåˆ— &lt;anÂ±bn&gt;\\left&lt;a_n\\pm b_n\\right&gt;âŸ¨anâ€‹Â±bnâ€‹âŸ© çš„æ™®é€šç”Ÿæˆå‡½æ•°ï¼ŒF(x)G(x)F(x)G(x)F(x)G(x) æ˜¯ åºåˆ—&lt;âˆ‘i=0naibnâˆ’i&gt;\\left&lt;\\sum_{i=0}^n a_i b_{n-i}\\right&gt;âŸ¨âˆ‘i=0nâ€‹aiâ€‹bnâˆ’iâ€‹âŸ© çš„æ™®é€šç”Ÿæˆå‡½æ•°ã€‚ å¯¹äºå¹‚æ¬¡è¿ç®—ï¼ŒF(x)F(x)F(x) çš„ nnn æ¬¡å¹‚è®°ä½œ Fn(x)F^n(x)Fn(x)ï¼Œç‰¹åˆ«åœ°ï¼ŒF0(x)=1F^0(x)=1F0(x)=1ã€‚ å¯¹ F(x)F(x)F(x) çš„ nnn æ¬¡å¹‚æå– mmm æ¬¡é¡¹ç³»æ•°ï¼Œå¯ä»¥è®° Fn[m]F^n[m]Fn[m] ä¸ºï¼š Fn[m]=[xm]Fn(x)F^n[m]=[x^m]F^n(x) Fn[m]=[xm]Fn(x) å°é—­å½¢å¼ å½¢å¼å¹‚çº§æ•°çš„ç”Ÿæˆå‡½æ•°ä¸ä¸€å®šå¥½ç®—ï¼Œæœ‰æ—¶ä¼šå°†å…¶è½¬æ¢ä¸ºå°é—­å½¢å¼ã€‚ æ¯”å¦‚è¯´ &lt;1,1,â‹¯ &gt;\\left&lt;1,1,\\cdots\\right&gt;âŸ¨1,1,â‹¯âŸ© çš„æ™®é€šç”Ÿæˆå‡½æ•°ä¸º F(x)=âˆ‘nâ‰¥0xnF(x)=\\sum_{n\\ge 0}x^nF(x)=âˆ‘nâ‰¥0â€‹xnï¼Œå‘ç° F(x)x+1=F(x)F(x)x+1=F(x)F(x)x+1=F(x)ï¼Œå› æ­¤å¾—åˆ° F(x)=11âˆ’xF(x)=\\cfrac{1}{1-x}F(x)=1âˆ’x1â€‹ï¼Œè¿™å°±æ˜¯ç”Ÿæˆå‡½æ•°çš„å°é—­å½¢å¼ã€‚ ä½œä¸ºç»ƒä¹ ï¼Œå¯ä»¥çœ‹ä¸€ä¸‹å°†è¿™å‡ ä¸ªé¢˜ï¼š 010203ï¼ˆäºŒé¡¹å¼å®šç†ï¼‰04ï¼ˆæ±‚å¯¼ï¼Œå‰ç¼€å’Œä¸å·®åˆ†ï¼Œæ•°å­¦å½’çº³æ³•ï¼‰ å†™å‡º a=&lt;0,1,1,â‹¯ &gt;a=\\left&lt;0,1,1,\\cdots \\right&gt;a=âŸ¨0,1,1,â‹¯âŸ© çš„ç”Ÿæˆå‡½æ•°ã€‚ æœ‰ F(x)=âˆ‘nâ‰¥1xnF(x)=\\sum_{n\\ge 1}x^nF(x)=âˆ‘nâ‰¥1â€‹xnï¼Œå› æ­¤ F(x)x+x=F(x)â‡’F(x)=x1âˆ’xF(x)x+x=F(x)\\Rightarrow F(x)=\\cfrac{x}{1-x}F(x)x+x=F(x)â‡’F(x)=1âˆ’xxâ€‹ã€‚ å†™å‡º a=&lt;1,0,1,0,1,0â‹¯ &gt;a=\\left&lt;1,0,1,0,1,0\\cdots \\right&gt;a=âŸ¨1,0,1,0,1,0â‹¯âŸ© çš„ç”Ÿæˆå‡½æ•°ã€‚ æœ‰ F(x)=âˆ‘nâ‰¥0x2n=âˆ‘nâ‰¥0(x2)nF(x)=\\sum_{n\\ge 0} x^{2n}=\\sum_{n\\ge 0} (x^{2})^nF(x)=âˆ‘nâ‰¥0â€‹x2n=âˆ‘nâ‰¥0â€‹(x2)nï¼Œå› æ­¤ F(x)x2+1=F(x)â‡’11âˆ’x2F(x)x^2+1=F(x)\\Rightarrow \\cfrac{1}{1-x^2}F(x)x2+1=F(x)â‡’1âˆ’x21â€‹ã€‚ å†™å‡ºåºåˆ— an=(mn)a_n=\\dbinom{m}{n}anâ€‹=(nmâ€‹) çš„ç”Ÿæˆå‡½æ•°ï¼ˆmmm æ˜¯å¸¸æ•°ï¼Œnâ‰¥0n\\ge 0nâ‰¥0ï¼‰ã€‚ F(x)=âˆ‘nâ‰¥0(mn)xn=(1+x)m\\begin{aligned} F(x)&amp;=\\sum_{n\\ge 0}\\binom{m}{n}x^n\\\\ &amp;=(1+x)^m \\end{aligned} F(x)â€‹=nâ‰¥0âˆ‘â€‹(nmâ€‹)xn=(1+x)mâ€‹ å†™å‡º a=&lt;1,2,3,4,5,6â‹¯ &gt;a=\\left&lt;1,2,3,4,5,6\\cdots \\right&gt;a=âŸ¨1,2,3,4,5,6â‹¯âŸ© çš„ç”Ÿæˆå‡½æ•°ã€‚ F(x)=âˆ‘nâ‰¥0nxnâˆ’1=âˆ‘nâ‰¥0(xn)â€²=1(1âˆ’x)2\\begin{aligned} F(x)&amp;=\\sum_{n\\ge 0}nx^{n-1}\\\\ &amp;=\\sum_{n\\ge 0} (x^n)&#x27;\\\\ &amp;=\\frac{1}{(1-x)^2} \\end{aligned} F(x)â€‹=nâ‰¥0âˆ‘â€‹nxnâˆ’1=nâ‰¥0âˆ‘â€‹(xn)â€²=(1âˆ’x)21â€‹â€‹ å¯ä»¥å‘ç°æ±‚ä¸€ä¸ªåºåˆ—çš„å‰ç¼€å’Œçš„ç”Ÿæˆå‡½æ•°åªéœ€è¦ä¹˜ä¸Š 11âˆ’x\\cfrac{1}{1-x}1âˆ’x1â€‹ï¼Œæ±‚å·®åˆ†åªéœ€è¦ä¹˜ä¸Š 1âˆ’x1-x1âˆ’xã€‚ å®é™…ä¸Šæˆ‘ä»¬æœ‰ï¼š 1(1âˆ’x)n+1=âˆ‘i(n+in)xi\\frac{1}{(1-x)^{n+1}}=\\sum_{i}\\binom{n+i}{n}x^i (1âˆ’x)n+11â€‹=iâˆ‘â€‹(nn+iâ€‹)xi ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå½“ n=1n=1n=1 æ—¶ï¼ŒåŸå¼æˆç«‹ï¼›å½“ n&gt;1n&gt;1n&gt;1 æ—¶ï¼Œæœ‰ï¼š 1(1âˆ’x)n+1=11âˆ’x1(1âˆ’x)n=âˆ‘ixiâˆ‘i(n+iâˆ’1nâˆ’1)xi=âˆ‘ixiâˆ‘j=0i(n+jâˆ’1j)=âˆ‘i(n+in)xi\\begin{aligned} \\frac{1}{(1-x)^{n+1}}&amp;=\\frac{1}{1-x}\\frac{1}{(1-x)^{n}}\\\\ &amp;=\\sum_{i}x^i\\sum_{i}\\binom{n+i-1}{n-1}x^i\\\\ &amp;=\\sum_{i}x^i\\sum_{j=0}^i\\binom{n+j-1}{j}\\\\ &amp;=\\sum_{i}\\binom{n+i}{n}x^i \\end{aligned} (1âˆ’x)n+11â€‹â€‹=1âˆ’x1â€‹(1âˆ’x)n1â€‹=iâˆ‘â€‹xiiâˆ‘â€‹(nâˆ’1n+iâˆ’1â€‹)xi=iâˆ‘â€‹xij=0âˆ‘iâ€‹(jn+jâˆ’1â€‹)=iâˆ‘â€‹(nn+iâ€‹)xiâ€‹ å®ƒè¿˜å¯ä»¥è¯´æ˜ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœ f(x)f(x)f(x) æ˜¯å…³äº xxx çš„ kkk æ¬¡å¤šé¡¹å¼ï¼Œé‚£ä¹ˆ f(x)f(x)f(x) çš„å·®åˆ†æ˜¯ kâˆ’1k-1kâˆ’1 æ¬¡å¤šé¡¹å¼ï¼Œå‰ç¼€å’Œæ˜¯ k+1k+1k+1 æ¬¡å¤šé¡¹å¼ã€‚ ç®€å•é¢˜ è¯´äº†è¿™ä¹ˆå¤šæ„Ÿè§‰å¾ˆç»•ï¼Ÿæˆ‘ä»¬é€šè¿‡å‡ é“ç®€å•çš„é¢˜ç›®æ¥è§è¯ç”Ÿæˆå‡½æ•°çš„å¼ºå¤§å¨åŠ›ï¼Œå³ä½¿å¤šé¡¹å¼ç®—æ³•è¿˜æ²¡æœ‰ç™»åœºã€‚ ç”Ÿæˆå‡½æ•°èƒ½ç®€å•çš„å°†åºåˆ—çš„è¿ç®—è½¬æ¢ä¸ºå¼å­çš„è¿ç®—ï¼Œå¹¶é€šè¿‡ç³»æ•°æ¥è¿˜åŸåºåˆ—ã€‚å¯¹äºæ— ç©·é¡¹çš„åºåˆ—ï¼Œå¯ä»¥è¯•å°†å…¶è½¬åŒ–ä¸ºå°é—­å½¢å¼è¿›è¡Œè®¡ç®—ï¼›å½“å°é—­å½¢å¼æ— æ³•ç›´æ¥å¾—å‡ºç»“æœï¼Œä¹Ÿå¯ä»¥å°†å…¶è½¬åŒ–ä¼šå½¢å¼å¹‚çº§æ•°ã€‚ [å…­çœè”è€ƒ 2017] ç»„åˆæ•°é—®é¢˜ Portal. ä»¤ F(x)=âˆ‘i(nki)xi=(1+x)nk\\displaystyle F(x)=\\sum_{i} \\binom{nk}{i}x^i=(1+x)^{nk}F(x)=iâˆ‘â€‹(inkâ€‹)xi=(1+x)nkï¼Œé‚£ä¹ˆè¦æ±‚çš„å°±æ˜¯ âˆ‘i mod k=rF[i]\\displaystyle\\sum_{i\\bmod k=r}F[i]imodk=râˆ‘â€‹F[i]ã€‚ å‰è€…ç›´æ¥æš´åŠ›è®¡ç®—ç”Ÿæˆå‡½æ•°çš„å·ç§¯ï¼Œç„¶åå¿«é€Ÿå¹‚å³å¯ã€‚åº•æ•°æ˜¯ä»€ä¹ˆï¼Ÿåƒä¸‡è®°ä½ï¼Œxxx åªæ˜¯è‡ªç”±å…ƒï¼Œå› æ­¤ 1+xâ‡’a[0]=a[1]=11+x\\Rightarrow a[0]=a[1]=11+xâ‡’a[0]=a[1]=1ã€‚ç”±äºæ˜¯æ±‚å¯¹ kkk å–æ¨¡çš„ç»“æœï¼Œå› æ­¤å¹‚æ¬¡å¯ä»¥åœ¨æ¨¡ kkk çš„æ„ä¹‰ä¸‹è¿›è¡Œï¼Œæœ€ç»ˆç­”æ¡ˆå°±æ˜¯ ans[r]ans[r]ans[r]ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef vector&lt;int> VI; typedef long long i64; int n, p, k, r; VI operator * (const VI &amp;a, const VI &amp;b) &#123; VI ans(k); for (int i = 0; i &lt; k; ++i) for (int j = 0; j &lt; k; ++j) ans[(i + j) % k] = (ans[(i + j) % k] + 1ll * a[i] * b[j]) % p; return ans; &#125; int main(void) &#123; cin >> n >> p >> k >> r; vector&lt;int> a(k), ans(k); ans[0] = 1; if (k == 1) a[0] = 2; else a[0] = a[1] = 1; i64 e = 1ll * n * k; for (; e; e >>= 1, a = a * a) if (e &amp; 1) ans = ans * a; cout &lt;&lt; ans[r] &lt;&lt; \"\\n\"; return 0; &#125; [Luogu P2000] æ‹¯æ•‘ä¸–ç•Œ Portal. å¯¹äºä¸€ç§å¬å”¤æ–¹å¼ï¼Œè®¾ ana_nanâ€‹ ä»£è¡¨è¿™ç§å¬å”¤æ–¹å¼é€‰æ‹© nnn ä¸ªçš„æ–¹æ¡ˆæ•°ï¼Œæ±‚å‡ºåºåˆ— aaa çš„ç”Ÿæˆå‡½æ•°ã€‚é‚£ä¹ˆä¸¤ç§å¬å”¤æ–¹å¼ä¸€å…±æœ‰ nnn å—çŸ³å¤´çš„é€‰æ‹©æ–¹å¼å°±æ˜¯è¿™ä¸¤ä¸ªç”Ÿæˆå‡½æ•°çš„å·ç§¯ FFF çš„ç¬¬ nnn é¡¹ç³»æ•°ã€‚ ä¸€å…±æœ‰ 101010 ä¸ªé™åˆ¶æ¡ä»¶ï¼Œä¾æ¬¡å†™å‡ºå®ƒä»¬çš„ç”Ÿæˆå‡½æ•°ï¼ˆå°é—­å½¢å¼ï¼‰ï¼Œç„¶åæŠŠå®ƒä»¬éƒ½ä¹˜èµ·æ¥å¾—åˆ° 1(1âˆ’x)5\\cfrac{1}{(1-x)^5}(1âˆ’x)51â€‹ã€‚è½¬åŒ–æˆå½¢å¼å¹‚çº§æ•°å°±æ˜¯ âˆ‘i(i+44)xi\\displaystyle\\sum_{i}\\binom{i+4}{4}x^iiâˆ‘â€‹(4i+4â€‹)xiã€‚å› æ­¤ç­”æ¡ˆæ˜¯ (n+44)\\dbinom{n+4}{4}(4n+4â€‹)ã€‚ æŸ¥çœ‹ä»£ç  # decimal é‡‡ç”¨å‹ä½ NTT å®ç°ï¼Œè¶³å¤Ÿå¿« from decimal import * getcontext().prec = 1000000 n = Decimal(input()) print((n + 1) * (n + 2) * (n + 3) * (n + 4) // 24) æ‹‰æ ¼æœ—æ—¥æ’å€¼ æ‹‰æ ¼æœ—æ—¥æ’å€¼æ˜¯æ²Ÿé€šå¤šé¡¹å¼çš„ç³»æ•°å½¢å¼ä¸ç‚¹å€¼å½¢å¼çš„é‡è¦å…¬å¼ã€‚ äº‹å®ä¸Šï¼Œnnn ä¸ªç‚¹ç¡®å®šå”¯ä¸€çš„å¤šé¡¹å¼ï¼Œå…¶æœ€é«˜é¡¹æ¬¡æ•°ä¸º nâˆ’1n-1nâˆ’1ã€‚ ä»ç³»æ•°è¡¨ç¤ºæ³•è½¬åŒ–ä¸ºç‚¹å€¼è¡¨ç¤ºæ³•å¯ä»¥è€ƒè™‘ç›´æ¥å¸¦å…¥ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n2)O(n^2)O(n2)ã€‚å¯ä»¥ä½¿ç”¨å¤šé¡¹å¼ç®—æ³•åŠ é€Ÿåˆ° O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ã€‚ å¯ä»¥ä½¿ç”¨æ‹‰æ ¼æœ—æ—¥æ’å€¼æ³•å°†ç‚¹å€¼è¡¨ç¤ºæ³•è½¬åŒ–ä¸ºç³»æ•°è¡¨ç¤ºæ³•ï¼Œé€šç”¨æƒ…å†µæ—¶æ—¶é—´å¤æ‚åº¦ä¸º O(n2)O(n^2)O(n2)ï¼Œå¯ä»¥ç”¨å¤šé¡¹å¼ç®—æ³•åŠ é€Ÿåˆ° O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ã€‚ ä¸€èˆ¬å½¢å¼ æ¨¡æ¿ã€‚nnn ä¸ªç‚¹å¯ä»¥ç¡®å®šä¸€ä¸ªå¤šé¡¹å¼ f(x)f(x)f(x)ï¼Œè¯·æ±‚å‡º f(k)f(k)f(k)ã€‚ æ ¸å¿ƒæ€æƒ³æ˜¯åˆ©ç”¨ç‚¹å€¼çš„å¯åŠ æ€§ã€‚ä»€ä¹ˆæ„æ€ï¼Ÿ æ„é€ ä¸€ä¸ªå‡½æ•° f(x)f(x)f(x) ç»è¿‡ P(x1,y1),â‹¯P(xn,yn)P(x_1,y_1),\\cdots P(x_n,y_n)P(x1â€‹,y1â€‹),â‹¯P(xnâ€‹,ynâ€‹)ï¼Œè®¾ç¬¬ iii ä¸ªç‚¹åœ¨ xxx è½´ä¸Šçš„æŠ•å½±ä¸º Piâ€²(xi,0)P_i^{\\prime}(x_i,0)Piâ€²â€‹(xiâ€‹,0)ã€‚è€ƒè™‘æ„é€  nnn ä¸ªå‡½æ•°ï¼Œä½¿å¾— fi(x)f_i(x)fiâ€‹(x) çš„å›¾åƒç»è¿‡ {Pjâ€²(xj,0),(jâ‰ i)Pi(xi,yi)\\begin{cases}P_j^{\\prime}(x_j,0),(j\\neq i)\\\\P_i(x_i,y_i)\\end{cases}{Pjâ€²â€‹(xjâ€‹,0),(jî€ =i)Piâ€‹(xiâ€‹,yiâ€‹)â€‹ï¼Œåˆ™ f(x)=âˆ‘i=1nfi(x)f(x)=\\sum_{i=1}^{n}f_i(x)f(x)=âˆ‘i=1nâ€‹fiâ€‹(x)ã€‚ è®¾ fi(x)=aâˆjâ‰ i(xâˆ’xj)f_i(x)=a\\prod_{j\\ne i}(x-x_j)fiâ€‹(x)=aâˆjî€ =iâ€‹(xâˆ’xjâ€‹)ï¼Œç„¶åå°† PiP_iPiâ€‹ çš„åæ ‡ä»£å…¥æ±‚å‡º a=yiâˆjâ‰ i(xiâˆ’xj)a=\\cfrac{y_i}{\\prod_{j\\ne i}(x_i-x_j)}a=âˆjî€ =iâ€‹(xiâ€‹âˆ’xjâ€‹)yiâ€‹â€‹ï¼Œè¿›è€Œå¯¼å‡ºï¼š f(k)=âˆ‘i=1nyiâˆiâ‰ jkâˆ’xjxiâˆ’xjf(k)=\\sum_{i=1}^n y_i\\prod_{i\\ne j}\\frac{k-x_j}{x_i-x_j} f(k)=i=1âˆ‘nâ€‹yiâ€‹iî€ =jâˆâ€‹xiâ€‹âˆ’xjâ€‹kâˆ’xjâ€‹â€‹ è¿™å°±æ˜¯æ‹‰æ ¼æœ—æ—¥æ’å€¼è¡¨è¾¾å¼ã€‚ å¦‚æœè¦æ±‚å‡ºç³»æ•°ï¼Œç”¨ O(n2)O(n^2)O(n2) å·å‡º F(x)=âˆi=1n(xâˆ’xi)F(x)=\\prod_{i=1}^n (x-x_i)F(x)=âˆi=1nâ€‹(xâˆ’xiâ€‹)ï¼Œç„¶åå¯¹äºæ¯ä¸ª iii æš´åŠ›å°† FFF é™¤æ‰ xâˆ’xix-x_ixâˆ’xiâ€‹ ç®—å‡º F(x)xâˆ’xi\\cfrac{F(x)}{x-x_i}xâˆ’xiâ€‹F(x)â€‹ çš„å„é¡¹ç³»æ•°ï¼Œå†ä¹˜ yiâˆjâ‰ ixiâˆ’xj\\cfrac{y_i}{\\prod_{j\\ne i}{x_i-x_j}}âˆjî€ =iâ€‹xiâ€‹âˆ’xjâ€‹yiâ€‹â€‹ å³å¯å¾—åˆ° fif_ifiâ€‹ çš„å„é¡¹ç³»æ•°ï¼ŒåŠ èµ·æ¥å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(n2)O(n^2)O(n2)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int n, k; int x[2005], y[2005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", x + i, y + i); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int s1 = y[i], s2 = 1; for (int j = 1; j &lt;= n; ++j) if (i != j) s1 = 1ll * s1 * (k - x[j]) % MOD, s2 = 1ll * s2 * (x[i] - x[j]) % MOD; ans = (ans + 1ll * s1 * poww(s2, MOD - 2)) % MOD; &#125; printf(\"%d\\n\", (ans % MOD + MOD) % MOD); return 0; &#125; è¿ç»­æƒ…å†µ å½“å·²çŸ¥ç‚¹çš„åæ ‡æ˜¯è¿ç»­æ•´æ•°æ—¶ï¼Œå¯ä»¥ O(n)O(n)O(n) å®Œæˆæ‹‰æ ¼æœ—æ—¥æ’å€¼ã€‚ä»¥ 0,1â‹¯nâˆ’10,1\\cdots n-10,1â‹¯nâˆ’1 ä¸ºä¾‹ï¼š æœ‰ï¼š f(x)=âˆ‘i=0nâˆ’1yiâˆiâ‰ jxâˆ’jiâˆ’jf(x)=\\sum_{i=0}^{n-1} y_i\\prod_{i\\ne j}\\frac{x-j}{i-j} f(x)=i=0âˆ‘nâˆ’1â€‹yiâ€‹iî€ =jâˆâ€‹iâˆ’jxâˆ’jâ€‹ åˆ†å­æ˜¯ä¸€å †æ•°çš„ä¹˜ç§¯æŒ–æ‰äº†ä¸€ä¸ªé¡¹ï¼Œå…¸å‹ç»´æŠ¤å‰åç¼€ç§¯ã€‚ å¯¹äº i&gt;ji&gt;ji&gt;j çš„åˆ†æ¯ï¼Œæœ‰ âˆj=0iâˆ’1(iâˆ’j)=i!\\displaystyle \\prod_{j=0}^{i-1}(i-j)=i!j=0âˆiâˆ’1â€‹(iâˆ’j)=i!ï¼Œå¯¹äº i&lt;ji&lt;ji&lt;jï¼Œæœ‰ âˆj=i+1nâˆ’1(iâˆ’j)=(âˆ’1)(âˆ’2)â‹¯(iâˆ’n+1)\\displaystyle \\prod_{j=i+1}^{n-1}(i-j)=(-1)(-2)\\cdots(i-n+1)j=i+1âˆnâˆ’1â€‹(iâˆ’j)=(âˆ’1)(âˆ’2)â‹¯(iâˆ’n+1)ï¼Œä¹Ÿå°±æ˜¯ (âˆ’1)nâˆ’i+1(nâˆ’iâˆ’1)!(-1)^{n-i+1}(n-i-1)!(âˆ’1)nâˆ’i+1(nâˆ’iâˆ’1)!ã€‚ æ‰€ä»¥ï¼š f(x)=âˆ‘i=0nâˆ’1yipisii!(âˆ’1)nâˆ’i+1(nâˆ’iâˆ’1)!f(x)=\\sum\\limits_{i=0}^{n-1} y_i \\frac{p_is_i}{i!(-1)^{n - i + 1}(n-i-1)!} f(x)=i=0âˆ‘nâˆ’1â€‹yiâ€‹i!(âˆ’1)nâˆ’i+1(nâˆ’iâˆ’1)!piâ€‹siâ€‹â€‹ é›†åˆå¹‚çº§æ•° å½¢å¼å¹‚çº§æ•°æ˜¯åˆ»ç”»æ•°åˆ—çš„é‡è¦æ–¹å¼ï¼Œè€Œé›†åˆå¹‚çº§æ•°æ˜¯å¤„ç†é›†åˆçš„ç‰¹æ®Šå½¢å¼ã€‚ ç”±äºç¬”è€…ç°åœ¨ä¸ä¼š FFTï¼Œå› æ­¤ä¼šé¿å¼€å…¶ä¸ FFT ç›¸å…³çš„å†…å®¹ã€‚ å®šä¹‰ å½¢å¼åŒ–åœ°ï¼ŒåŸŸ FFF ä¸Šçš„é›†åˆå¹‚çº§æ•° fff æ˜¯ 2Uâ†’F2^U\\rightarrow F2Uâ†’F çš„å‡½æ•°ï¼Œå¯¹äºæ¯ä¸ª SâŠ‚US\\subset USâŠ‚Uï¼Œå‡½æ•° fff å‡æœ‰å¯¹åº”çš„å–å€¼ fSâˆˆFf_S\\in FfSâ€‹âˆˆFã€‚ é›†åˆå¹‚çº§æ•°çš„åŠ æ³•éå¸¸å®¹æ˜“ï¼ŒæŒ‰ä½ç›¸åŠ å³å¯ã€‚è€Œä¹˜æ³•æ¯”è¾ƒå¤æ‚ï¼Œæœ‰å¾ˆå¤šç§ï¼Œä½†æ˜¯éƒ½æ»¡è¶³åˆ†é…å¾‹ï¼ˆåŒ…æ‹¬é€†è¿ç®—ï¼‰ã€‚ FMT &amp; FWT ç»™å®šåºåˆ— an,bn{a_n},{b_n}anâ€‹,bnâ€‹ï¼Œæ±‚å‡ºåºåˆ— cn{c_n}cnâ€‹ï¼Œæ»¡è¶³ ci=âˆ‘jâŠ•k=iajbkc_i=\\sum_{j\\oplus k=i}a_j b_kciâ€‹=âˆ‘jâŠ•k=iâ€‹ajâ€‹bkâ€‹ï¼Œè¿™æ ·çš„æ“ä½œç§°ä¹‹ä¸ºå·ç§¯ã€‚å½“å…¶ä¸ºåŠ å·æ—¶æ˜¯æˆ‘ä»¬ç†Ÿæ‚‰çš„å¤šé¡¹å¼ä¹˜æ³•ï¼ˆå’Œå·ç§¯ï¼‰ï¼Œè€Œå…¶ä¸ºä¹˜å·æ—¶ä¸ºç‹„åˆ©å…‹é›·å·ç§¯ã€‚ æ¨¡æ¿ã€‚ç”¨ FMT è§£å†³ä¸å·ç§¯å’Œæˆ–å·ç§¯ï¼ˆæˆ–å·ç§¯è¢«ç§°ä¸ºå¹¶å·ç§¯ï¼‰ï¼Œç”¨ FWT æ¥è§£å†³å¼‚æˆ–å·ç§¯ï¼ˆå¼‚æˆ–å·ç§¯ä¸ºå¯¹ç§°å·®å·ç§¯ï¼‰ã€‚ æˆ‘ä»¬é¦–å…ˆæ¥ä»‹ç» FMTï¼ˆå¿«é€Ÿè«æ¯”ä¹Œæ–¯å˜æ¢ï¼‰ã€‚ä»¥æˆ–å·ç§¯ä¸ºä¾‹ï¼Œå®šä¹‰åºåˆ— {a0,â‹¯a2nâˆ’1}\\{a_0,\\cdots a_{2^n-1}\\}{a0â€‹,â‹¯a2nâˆ’1â€‹} çš„ FMT å˜æ¢ä¸ºï¼šFMTâ¡(a)i=âˆ‘jâŠ†iaj\\operatorname{FMT}(a)_i=\\sum_{j\\subseteq i}a_jFMT(a)iâ€‹=âˆ‘jâŠ†iâ€‹ajâ€‹ï¼ŒIFMT ä¸ºä¸Šè¿°å˜æ¢çš„é€†å˜æ¢ã€‚é‚£ä¹ˆæˆ–å·ç§¯ç­‰ä»·äº c=IFMTâ¡(FMTâ¡(a)â‹…FMTâ¡(b))c=\\operatorname{IFMT}(\\operatorname{FMT}(a)\\cdot \\operatorname{FMT}(b))c=IFMT(FMT(a)â‹…FMT(b))ã€‚ ç„¶åæˆ‘ä»¬æ¥ä»‹ç» FWTï¼ˆå¿«é€Ÿæ²ƒå°”ä»€å˜æ¢ï¼‰ï¼Œå…¶æœ¬è´¨å°±æ˜¯é«˜ç»´ä¸è¿›ä½çš„åŠ æ³•å·ç§¯ã€‚å…¶å®šä¹‰å¼ä¸ºï¼šFWTâ¡(a)i=âˆ‘jâŠ†i(âˆ’1)âˆ£iâˆ’jâˆ£aj\\operatorname{FWT}(a)_i = \\sum_{j\\subseteq i} (-1)^{|i-j|}a_jFWT(a)iâ€‹=âˆ‘jâŠ†iâ€‹(âˆ’1)âˆ£iâˆ’jâˆ£ajâ€‹ã€‚IFWT ä¸ºä¸Šè¿°å˜æ¢çš„é€†å˜æ¢ã€‚ æ—¶é—´å¤æ‚åº¦å‡ä¸º O(nÃ—2n)O(n\\times 2^n)O(nÃ—2n)ã€‚ æ€§è´¨ FMT å’Œ FWT ä»¥åŠå®ƒä»¬çš„é€†è¿ç®—éƒ½æ˜¯ä¸€ç§çº¿æ€§å˜æ¢ã€‚ ä»¥ FMT æˆ–å·ç§¯ä¸ºä¾‹ï¼ˆFWT åŒç†ï¼‰ï¼Œè®¾ fif_ifiâ€‹ ä»£è¡¨ç¬¬ iii ä¸ªé›†åˆå¹‚çº§æ•°ï¼Œé‚£ä¹ˆï¼š âˆfi=IFMTâ¡(âˆFMTâ¡(fi))\\prod f_i=\\operatorname{IFMT}(\\prod\\operatorname{FMT}(f_i)) âˆfiâ€‹=IFMT(âˆFMT(fiâ€‹)) å·¦è¾¹çš„æ±‚ç§¯ç¬¦å·ä»£è¡¨é›†åˆå¹¶å·ç§¯ï¼Œå³è¾¹çš„ä»£è¡¨å¯¹åº”ç³»æ•°ç›¸ä¹˜ã€‚ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è§£å†³æ¨¡æ¿é¢˜äº†ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 1 &lt;&lt; 17; const int P = 998244353; int n, a[N], b[N], A[N], B[N]; void in(void) &#123; memcpy(A, a, N &lt;&lt; 2), memcpy(B, b, N &lt;&lt; 2); &#125; void get(void) &#123; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) A[i] = 1ll * A[i] * B[i] % P; &#125; void print(void) &#123; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) printf(\"%d \", A[i]); putchar('\\n'); &#125; void OR(int *f, int c) &#123; for (int i = 1; i &lt; 1 &lt;&lt; n; i &lt;&lt;= 1) for (int j = 0; j &lt; 1 &lt;&lt; n; ++j) if (i &amp; j) f[j] = (f[j] + 1ll * c * f[j ^ i] % P + P) % P; &#125; void AND(int *f, int c) &#123; for (int i = 1; i &lt; 1 &lt;&lt; n; i &lt;&lt;= 1) for (int j = 0; j &lt; 1 &lt;&lt; n; ++j) if (i &amp; j) f[j ^ i] = (f[j ^ i] + 1ll * c * f[j] + P) % P; &#125; void XOR(int *f, int c) &#123; for (int k = 1; k &lt; 1 &lt;&lt; n; k &lt;&lt;= 1) for (int i = 0; i &lt; 1 &lt;&lt; n; i += k &lt;&lt; 1) for (int j = 0, x, y; j &lt; k; ++j) x = f[i | j], y = f[i | j | k], f[i | j] = (x + y) % P, f[i | j | k] = (x - y + P) % P; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) f[i] = 1ll * f[i] * c % P; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) scanf(\"%d\", a + i); for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) scanf(\"%d\", b + i); in(); OR(A, 1); OR(B, 1); get(); OR(A, P - 1); print(); in(); AND(A, 1); AND(B, 1); get(); AND(A, P - 1); print(); int inv = (P + 1) >> 1; for (int i = 1; i &lt; n; ++i) inv = 1ll * inv * (P + 1 >> 1) % P; in(); XOR(A, 1); XOR(B, 1); get(); XOR(A, inv); print(); return 0; &#125; é«˜ç»´å‰ç¼€å’Œ é›†åˆå¹‚çº§æ•° fff ç»è¿‡ FMT å¾—åˆ°çš„è«æ¯”ä¹Œæ–¯å˜æ¢å½¢å¼ä¸é«˜ç»´å‰ç¼€å’Œæœ‰ç€å¯†ä¸å¯åˆ†çš„å…³ç³»ã€‚ FMT åœ¨ä»¤ç¬¬ iii ä½ä¸º 111 å¼€å§‹æ“ä½œæ—¶å¯ä»¥çœ‹ä½œåœ¨ç¬¬ iii ä¸ªç»´åº¦è¿›è¡Œé«˜ç»´å‰ç¼€å’Œã€‚ å­é›†å·ç§¯ å®šä¹‰å­é›†å·ç§¯ä¸ºï¼š ci=âˆ‘jorâ¡k=i,jandâ¡k=0ajbkc_i=\\sum_{j\\operatorname{or} k = i,j\\operatorname{and}k=0}a_j b_k ciâ€‹=jork=i,jandk=0âˆ‘â€‹ajâ€‹bkâ€‹ æ³¨æ„å½“ jorâ¡k=i,jandâ¡k=0j\\operatorname{or}k = i,j\\operatorname{and}k=0jork=i,jandk=0 çš„å……è¦æ¡ä»¶æ˜¯ âˆ£jâˆ£+âˆ£kâˆ£=i|j|+|k|=iâˆ£jâˆ£+âˆ£kâˆ£=iã€‚è®¾ fi,S=[âˆ£Sâˆ£=i]fSf_{i,S}=[|S|=i]f_Sfi,Sâ€‹=[âˆ£Sâˆ£=i]fSâ€‹ï¼Œggg åŒç†ã€‚ä»¤ Hi=âˆ‘j+k=ifjgkH_i=\\sum_{j+k=i}f_jg_kHiâ€‹=âˆ‘j+k=iâ€‹fjâ€‹gkâ€‹ï¼Œè¿™é‡Œçš„ HiH_iHiâ€‹ ä»£è¡¨ä¸€ä¸ªé›†åˆå¹‚çº§æ•°ã€‚ ç­‰å¼ä¸¤è¾¹åŒæ—¶ FMTï¼Œè®¡ç®—å‡º HHH ä¹‹å IFMT å›æ¥å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ O(n22n)O(n^2 2^n)O(n22n)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000009, N = 20; int n; int f[21][1 &lt;&lt; N], g[21][1 &lt;&lt; N], h[1 &lt;&lt; N], ans[1 &lt;&lt; N], popcnt[1 &lt;&lt; N]; void FMT(int *f, int c) &#123; for (int i = 1; i &lt; 1 &lt;&lt; n; i &lt;&lt;= 1) for (int j = 0; j &lt; 1 &lt;&lt; n; ++j) if (i &amp; j) f[j] = (f[j] + c * f[j ^ i]) % P; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) f[i] = (f[i] % P + P) % P; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) popcnt[i] = popcnt[i >> 1] + (i &amp; 1); for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) scanf(\"%d\", &amp;f[popcnt[i]][i]); for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) scanf(\"%d\", &amp;g[popcnt[i]][i]); for (int i = 0; i &lt;= n; ++i) FMT(f[i], 1), FMT(g[i], 1); ans[0] = 1ll * f[0][0] * g[0][0] % P; for (int i = 1; i &lt;= n; ++i) &#123; memset(h, 0, sizeof h); for (int j = i; j >= 0; --j) for (int k = 0; k &lt; 1 &lt;&lt; n; ++k) h[k] = (h[k] + 1ll * f[j][k] * g[i - j][k] % P) % P; FMT(h, -1); for (int j = 0; j &lt; 1 &lt;&lt; n; ++j) if (popcnt[j] == i) ans[j] = h[j]; &#125; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) printf(\"%d \", (ans[i] % P + P) % P); return putchar('\\n'), 0; &#125; å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFFTï¼‰ ä¸‡æ¶ä¹‹æºï¼Œå¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ŒFFTï¼Œå®ƒå¯ä»¥å¿«é€Ÿè®¡ç®—å¤šé¡¹å¼çš„å·ç§¯ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š å¿«é€Ÿæ•°è®ºå˜æ¢ï¼ˆNTTï¼‰ Problemset å‰ 222 ä¸ªå°èŠ‚æ²¡æœ‰ä½¿ç”¨å¤šé¡¹å¼ç®—æ³•ã€‚ æ‹‰æ ¼æœ—æ—¥æ’å€¼ å¾ˆæœ‰ç”¨ã€‚ [CF622F] The Sum of the k-th Powers Portal. å°†å…¶å†™æˆä¸€ä¸ªåºåˆ—ï¼šâˆ‘i=11ik,âˆ‘i=12ik,âˆ‘i=13ik,â‹¯\\sum_{i=1}^1 i^k,\\sum_{i=1}^2 i^k,\\sum_{i=1}^3 i^k,\\cdotsâˆ‘i=11â€‹ik,âˆ‘i=12â€‹ik,âˆ‘i=13â€‹ik,â‹¯ã€‚ å·®åˆ†åå¾—åˆ°ï¼š1k,2k,3kâ‹¯1^k,2^k,3^k\\cdots1k,2k,3kâ‹¯ï¼Œè¿™ä¸ªæ•°åˆ—çš„é€šé¡¹å…¬å¼æ˜¯ä¸€ä¸ª kkk æ¬¡å¤šé¡¹å¼ï¼Œé‚£ä¹ˆå–å‰ç¼€å’Œä¹‹åæ˜¯ä¸€ä¸ª k+1k+1k+1 æ¬¡å¤šé¡¹å¼ã€‚ ä½¿ç”¨è¿ç»­æƒ…å†µçš„æ‹‰æ ¼æœ—æ—¥æ’å€¼ï¼Œä¸é¢„å¤„ç†é€†å…ƒçš„è¯æ˜¯çº¿æ€§å¯¹æ•°çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n, k, pre[1000005], suf[1000005], fac[1000005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); fac[0] = pre[0] = suf[k + 3] = 1; for (int i = 1; i &lt;= k + 2; ++i) fac[i] = 1ll * fac[i - 1] * i % P; for (int i = 1; i &lt;= k + 2; ++i) pre[i] = 1ll * pre[i - 1] * (n - i) % P; for (int i = k + 2; i >= 1; --i) suf[i] = 1ll * suf[i + 1] * (n - i) % P; int ans = 0, y = 0; for (int i = 1; i &lt;= k + 2; ++i) &#123; y = (y + poww(i, k)) % P; int a = 1ll * pre[i - 1] * suf[i + 1] % P; int b = 1ll * fac[i - 1] * (k - i &amp; 1 ? -1 : 1) * fac[k + 2 - i] % P; ans = (ans + 1ll * y * a % P * poww(b, P - 2) % P) % P; &#125; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; [é›†è®­é˜Ÿäº’æµ‹ 2012] calc Portal. è®¾ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤ºè€ƒè™‘å‰ iii ä¸ªæ•°ï¼Œå€¼åŸŸä¸º [1,j][1,j][1,j]ï¼Œè€Œä¸”é™åˆ¶å–çš„è¦ä¸Šå‡ï¼Œè¿™æ ·ï¼š fi,j=fiâˆ’1,jâˆ’1Ã—j+fi,jâˆ’1f_{i,j}=f_{i-1,j-1}\\times j + f_{i,j-1} fi,jâ€‹=fiâˆ’1,jâˆ’1â€‹Ã—j+fi,jâˆ’1â€‹ æœ€ç»ˆç­”æ¡ˆä¸º fn,kÃ—n!f_{n,k}\\times n!fn,kâ€‹Ã—n!ã€‚ æ¨æµ‹ fn,if_{n,i}fn,iâ€‹ æ˜¯å…³äº iii çš„ g(n)g(n)g(n) æ¬¡å¤šé¡¹å¼ã€‚è¿™ä¸ªè½¬ç§»æ–¹ç¨‹æœ‰å·®åˆ†çš„å½¢å¼ï¼š fn,iâˆ’fn,iâˆ’1=fnâˆ’1,iâˆ’1Ã—if_{n,i}-f_{n,i-1}=f_{n-1,i-1}\\times i fn,iâ€‹âˆ’fn,iâˆ’1â€‹=fnâˆ’1,iâˆ’1â€‹Ã—i å·¦è¾¹æ˜¯å…³äº iii çš„ g(n)âˆ’1g(n)-1g(n)âˆ’1 æ¬¡å¤šé¡¹å¼ï¼Œå³è¾¹æ˜¯å…³äº iii çš„ g(nâˆ’1)+1g(n-1)+1g(nâˆ’1)+1 æ¬¡å¤šé¡¹å¼ï¼Œå› æ­¤ï¼š g(n)âˆ’1=g(nâˆ’1)+1g(n)-1=g(n-1)+1 g(n)âˆ’1=g(nâˆ’1)+1 è€Œ g(0)=0g(0)=0g(0)=0ï¼Œè¿™æ ·å¯ä»¥å¾—å‡º g(n)=2ng(n)=2ng(n)=2nã€‚ é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦æ±‚å‡º f(n,1)â‹¯f(n,2n+1)f(n,1)\\cdots f(n,2n+1)f(n,1)â‹¯f(n,2n+1)ï¼Œç„¶åå°±å¯ä»¥ä½¿ç”¨æ‹‰æ ¼æœ—æ—¥æ’å€¼æ±‚å‡º f(n,k)f(n,k)f(n,k)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int P; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int k, n, fac = 1; int f[505][1005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;k, &amp;n, &amp;P); for (int i = 1; i &lt;= n; ++i) fac = 1ll * fac * i % P; for (int j = 0; j &lt;= n * 2 + 1; ++j) f[0][j] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n * 2 + 1; ++j) f[i][j] = (1ll * f[i - 1][j - 1] * j % P + f[i][j - 1]) % P; int ans = 0; for (int i = 1; i &lt;= n * 2 + 1; ++i) &#123; int a = 1ll * f[n][i] * fac % P, b = 1; for (int j = 1; j &lt;= n * 2 + 1; ++j) if (i != j) a = 1ll * a * (k - j) % P, b = 1ll * b * (i - j) % P; ans = (ans + 1ll * a * poww(b, P - 2)) % P; &#125; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; [çœé€‰è”è€ƒ 2022] å¡«æ ‘ Portal. è€ƒè™‘é’¦å®šä¸€ä¸ªæœ€å°å€¼ wwwï¼Œé€‰æ‹©çš„èŒƒå›´å°±æ˜¯ [w,w+K][w,w+K][w,w+K]ï¼Œç„¶åå®¹æ–¥å‡å»æ²¡æœ‰å–åˆ°æœ€å°å€¼çš„ [w+1,w+K][w+1,w+K][w+1,w+K] çš„éƒ¨åˆ†ã€‚ ç¡®å®šä¸€ä¸ª www æ—¶ç­”æ¡ˆå¯ä»¥ç›´æ¥è¿›è¡Œä¸€æ¬¡æ ‘å½¢ DP æ±‚å‡ºã€‚ä¸åŒå–å€¼èŒƒå›´å¯ä»¥åˆ’åˆ†æˆä¸åŒæ®µï¼Œåœ¨åŒä¸€æ®µå†…çš„ç­”æ¡ˆæ˜¯ä¸€ä¸ªå…³äº www çš„å¤šé¡¹å¼ï¼ˆä¸€ä¸ªç‚¹çš„æ–¹æ¡ˆæ•°æ˜¯ä¸€æ¬¡çš„ï¼Œæƒå€¼æ˜¯äºŒæ¬¡çš„ï¼Œé“¾æ±‚å’Œåä¾ç„¶æ˜¯å¤šé¡¹å¼ï¼‰ï¼Œæ‹‰æ ¼æœ—æ—¥æ’å€¼ç»´æŠ¤æ¯ä¸€æ®µå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int sgn[2] = &#123;1, P - 1&#125;; inline int poww(int a, int b) &#123; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int n, K, l[205], r[205]; vector&lt;int> G[205]; int f[205], g[205], d1[205], d2[205]; // f ç»è¿‡ï¼Œd ä»å¼€å§‹ int ans1, ans2; void dfs(int x, int fa, int L, int R) &#123; f[x] = g[x] = d1[x] = d2[x] = 0; int ql = max(L, l[x]), qr = min(R, r[x]); int cntx = (ql &lt;= qr) ? qr - ql + 1 : 0; int sumx = (ql &lt;= qr) ? 1ll * (ql + qr) * (qr - ql + 1) / 2 % P : 0; f[x] = d1[x] = cntx; g[x] = d2[x] = sumx; for (int y : G[x]) if (y != fa) &#123; dfs(y, x, L, R); f[x] = (f[x] + f[y]) % P; g[x] = (g[x] + g[y]) % P; g[x] = (g[x] + 1ll * d2[x] * d1[y] + 1ll * d1[x] * d2[y]) % P; d2[x] = (d2[x] + 1ll * d2[y] * cntx + 1ll * d1[y] * sumx) % P; f[x] = (f[x] + 1ll * d1[x] * d1[y]) % P; d1[x] = (d1[x] + 1ll * d1[y] * cntx) % P; &#125; &#125; int m, a[805]; int Y1[805], Y2[805], pre[805], suf[805], inv[405]; void solve(int w) &#123; m = 0; a[++m] = w + 1; a[++m] = 1000000001; for (int i = 1; i &lt;= n; ++i) &#123; if (l[i] > w) a[++m] = l[i]; if (r[i] > w) a[++m] = r[i]; if (l[i] > K) a[++m] = l[i] - K + w; if (r[i] > K) a[++m] = r[i] - K + w; &#125; sort(a + 1, a + m + 1); m = unique(a + 1, a + m + 1) - (a + 1); for (int i = 1; i &lt; m; ++i) &#123; int k = min(a[i + 1] - a[i] + 3, n + 5); for (int j = 1; j &lt;= k; ++j) dfs(1, 0, a[i] + (j - 1), a[i] + (j - 1) + K - w), Y1[j] = f[1], Y2[j] = g[1]; for (int j = 1; j &lt;= k; ++j) Y1[j] = (Y1[j] + Y1[j - 1]) % P, Y2[j] = (Y2[j] + Y2[j - 1]) % P; int x = a[i + 1] - a[i]; pre[0] = suf[k + 1] = 1; for (int j = 1; j &lt;= k; ++j) pre[j] = 1ll * pre[j - 1] * (x - j + P) % P; for (int j = k; j >= 1; --j) suf[j] = 1ll * suf[j + 1] * (x - j + P) % P; for (int j = 1; j &lt;= k; ++j) &#123; int t = 1ll * pre[j - 1] * suf[j + 1] % P * inv[j - 1] % P * inv[k - j] % P * sgn[(k - j) &amp; 1] % P * sgn[w] % P; ans1 = (ans1 + 1ll * t * Y1[j]) % P; ans2 = (ans2 + 1ll * t * Y2[j]) % P; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;K); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", l + i, r + i); inv[0] = inv[1] = 1; for (int i = 2; i &lt;= n + 5; ++i) inv[i] = 1ll * (P - P / i) * inv[P % i] % P; for (int i = 3; i &lt;= n + 5; ++i) inv[i] = 1ll * inv[i - 1] * inv[i] % P; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; solve(0); solve(1); return printf(\"%d\\n%d\\n\", ans1, ans2), 0; &#125; é›†åˆå¹‚çº§æ•° [ABC212H] Nim Counting Portal.ç»™å®šä¸¤ä¸ªæ•° N,KN,KN,Kï¼Œä»¥åŠä¸€ä¸ªé•¿åº¦ä¸º KKK çš„æ•´æ•°æ•°ç»„ (Ai,A2...AK)(A_i,A_2...A_K)(Aiâ€‹,A2â€‹...AKâ€‹)ã€‚ç°åœ¨é€šè¿‡ä»¥ä¸‹æ–¹å¼ç”Ÿæˆä¸€ä¸ª Nim æ¸¸æˆï¼šä»»æ„é€‰æ‹©ä¸€ä¸ª 1â‰¤Mâ‰¤N1\\le M\\le N1â‰¤Mâ‰¤Nï¼ŒMMM è¡¨ç¤ºçŸ³å­å †æ•°ã€‚å¯¹äºæ¯ä¸€å †ï¼Œå…¶çŸ³å­æ•°æ˜¯ AAA ä¸­ä»»æ„ä¸€ä¸ªæ•°ã€‚å¯¹äº âˆ‘i=1NKi\\sum_{i=1}^N K^iâˆ‘i=1Nâ€‹Ki ç§æ¸¸æˆï¼Œæ±‚å…ˆæ‰‹è·èƒœçš„æ¸¸æˆæ•°ï¼Œç­”æ¡ˆå¯¹ 998244353998244353998244353 å–æ¨¡ã€‚1â‰¤Nâ‰¤2Ã—1051\\le N\\le 2\\times 10^51â‰¤Nâ‰¤2Ã—105ï¼Œ1â‰¤Ai,K&lt;2161\\le A_i,K&lt;2^{16}1â‰¤Aiâ€‹,K&lt;216ã€‚AiA_iAiâ€‹ ä¸¤ä¸¤ä¸åŒã€‚ ç›¸å½“äºæ˜¯ç»™å®šäº†ä¸€ä¸ªé›†åˆå¹‚çº§æ•°ã€‚nnn å †å¼å­å°±æ˜¯ nnn ä¸ªè¿™æ ·çš„é›†åˆå¹‚çº§æ•°çš„å¼‚æˆ–å·ç§¯ã€‚ åˆ©ç”¨ FWT çš„æ€§è´¨å°±å¯ä»¥å…ˆå°†é›†åˆå¹‚çº§æ•°ä»¬åŠ èµ·æ¥ï¼ˆç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼‰ï¼Œå† IFWT ä¸€æ¬¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 16, P = 998244353; inline int poww(int a, int b) &#123; a %= P; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int n, k, f[1 &lt;&lt; N]; void FWT(int *f, int c) &#123; for (int k = 1; k &lt; 1 &lt;&lt; N; k &lt;&lt;= 1) for (int i = 0; i &lt; 1 &lt;&lt; N; i += k &lt;&lt; 1) for (int j = 0, x, y; j &lt; k; ++j) x = f[i | j], y = f[i | j | k], f[i | j] = (x + y) % P, f[i | j | k] = (x - y + P) % P; for (int i = 0; i &lt; 1 &lt;&lt; N; ++i) f[i] = 1ll * f[i] * c % P; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1, x; i &lt;= k; ++i) scanf(\"%d\", &amp;x), ++f[x]; FWT(f, 1); for (int i = 0; i &lt; 1 &lt;&lt; N; ++i) if (f[i] == 1) f[i] = n; else f[i] = 1ll * (poww(f[i], n + 1) - f[i] + P) * poww(f[i] - 1 + P, P - 2) % P; FWT(f, poww(P + 1 >> 1, N)); int ans = 0; for (int i = 1; i &lt; 1 &lt;&lt; N; ++i) ans = (ans + f[i]) % P; return printf(\"%d\\n\", ans), 0; &#125; [çœé€‰è”è€ƒ 2022] å¡ç‰Œ Portal. æ ¹å·åˆ†æ²»ï¼Œâ‰¤2000\\le \\sqrt{2000}â‰¤2000â€‹ çš„è´¨æ•°åªæœ‰ 131313 ä¸ªï¼ˆåˆ° 414141ï¼‰ã€‚è€ƒè™‘ç»´æŠ¤ fif_ifiâ€‹ ä»£è¡¨æœ‰å¤šå°‘ç§é€‰æ‹©æ–¹å¼ä½¿å¾—æ°å¥½è¦†ç›– iii çš„é«˜ç»´å‰ç¼€å’Œã€‚é¢„å¤„ç†æ—¶ fff åªç»´æŠ¤å¹‚æ¬¡ï¼ˆè¿™æ ·å¯ä»¥å‡å°‘å–æ¨¡ï¼‰ã€‚ å¯¹äºå«æœ‰å¤§è´¨æ•°çš„å¡ç‰Œï¼Œç›´æ¥æ¯ä¸ªéƒ½ä¹˜ä¸Šå½“å‰è´¨æ•°çš„é€‰æ‹©å³å¯ã€‚ æœ€åç›´æ¥ IFMT æ±‚å‡ºçœŸå®å€¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; const int P[13] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41&#125;; const int V = 1 &lt;&lt; 13; inline void add(int &amp;x, int t) &#123; x += t; if (x >= MOD) x -= MOD; &#125; inline void sub(int &amp;x, int t) &#123; x -= t; if (x &lt; 0) x += MOD; &#125; int n, m; int a[2005], pw[1000005]; int c, p[18005], f[V], g[2005][V], h[V]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), ++a[x]; for (int i = pw[0] = 1; i &lt;= n; ++i) pw[i] = (pw[i - 1] &lt;&lt; 1) % MOD; for (int i = 1; i &lt;= 2000; ++i) if (a[i]) &#123; int tmp = i, msk = 0; for (int j = 0; j &lt; 13; ++j) while (tmp % P[j] == 0) tmp /= P[j], msk |= 1 &lt;&lt; j; for (int j = 0; j &lt; V; ++j) if ((j &amp; msk) == msk) f[j] += a[i]; if (tmp == 43 * 43) tmp = 43; // 43 * 43 &lt; 2000, 43 * 47 > 2000 if (tmp > 1) &#123; for (int j = 0; j &lt; V; ++j) if ((j &amp; msk) == msk) g[tmp][j] += a[i]; &#125; &#125; scanf(\"%d\", &amp;m); while (m--) &#123; scanf(\"%d\", &amp;c); int ans = 0, msk = 0; for (int i = 1; i &lt;= c; ++i) scanf(\"%d\", p + i); sort(p + 1, p + c + 1); c = unique(p + 1, p + c + 1) - (p + 1); memcpy(h, f, sizeof h); for (int i = 1; i &lt;= c; ++i) if (p[i] &lt;= 41) &#123; for (int j = 0; j &lt; 13; ++j) if (p[i] == P[j]) msk |= 1 &lt;&lt; j; &#125; else &#123; // å°†è¿™ä¸ªå¤§è´¨æ•°çš„è´¡çŒ®å‡å»ï¼Œåˆ°æ—¶å€™é‡æ–°ç»Ÿè®¡ for (int j = 0; j &lt; V; ++j) h[j] -= g[p[i]][j]; &#125; for (int i = 0; i &lt; V; ++i) h[i] = pw[h[i]]; for (int i = 1; i &lt;= c; ++i) if (p[i] > 41) for (int j = 0; j &lt; V; ++j) h[j] = 1ll * h[j] * (pw[g[p[i]][j]] - 1) % MOD; // æ’æ‰ä¸€ä¸ªéƒ½ä¸é€‰ // IFMT æˆ–å·ç§¯é€†è¿ç®—ï¼Œé«˜ç»´å·®åˆ† for (int i = 1; i &lt; V; i &lt;&lt;= 1) for (int j = 0; j &lt; V; ++j) if (i &amp; j) sub(h[j], h[j ^ i]); for (int i = 0; i &lt; V; ++i) if ((i &amp; msk) == msk) add(ans, h[i]); printf(\"%d\\n\", ans); &#125; return 0; &#125; å…·ä½“çš„å„ç±»ç”Ÿæˆå‡½æ•°è¯·å‚è€ƒã€Šç»„åˆè®¡æ•°è¿›é˜¶ã€‹ï¼Œè¿™é‡Œä»…ä»‹ç»åŸºæœ¬å†…å®¹ã€‚ â†©ï¸","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"å¤šé¡¹å¼","slug":"å¤šé¡¹å¼","permalink":"https://james1badcreeper.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"ç»„åˆè®¡æ•°åŸºç¡€","slug":"notes/æ•°å­¦/combination","date":"2022-12-20T00:00:00.000Z","updated":"2022-12-20T00:00:00.000Z","comments":true,"path":"6513c499/","link":"","permalink":"https://james1badcreeper.github.io/6513c499/","excerpt":"ç»„åˆè®¡æ•°æ˜¯ç»„åˆæ•°å­¦çš„åŸºç¡€ï¼Œç ”ç©¶æŸç»„ç¦»æ•£å¯¹è±¡æ»¡è¶³ä¸€å®šæ¡ä»¶çš„å®‰æ’çš„å­˜åœ¨æ€§ã€æ„é€ åŠè®¡æ•°ç­‰é—®é¢˜ã€‚çœ‹ä¼¼åå­—äººç•œæ— å®³ï¼Œå®åˆ™â€œç®—æ­»äººï¼Œä¸å¿å‘½â€ã€‚æœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ ç®€å•çš„ç»„åˆè®¡æ•°ï¼Œä¸ºæ¥ä¸‹æ¥å­¦ä¹ æ¯’ç˜¤çš„è®¡æ•°é—®é¢˜ä½œå‡†å¤‡ã€‚","text":"ç»„åˆè®¡æ•°æ˜¯ç»„åˆæ•°å­¦çš„åŸºç¡€ï¼Œç ”ç©¶æŸç»„ç¦»æ•£å¯¹è±¡æ»¡è¶³ä¸€å®šæ¡ä»¶çš„å®‰æ’çš„å­˜åœ¨æ€§ã€æ„é€ åŠè®¡æ•°ç­‰é—®é¢˜ã€‚çœ‹ä¼¼åå­—äººç•œæ— å®³ï¼Œå®åˆ™â€œç®—æ­»äººï¼Œä¸å¿å‘½â€ã€‚æœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ ç®€å•çš„ç»„åˆè®¡æ•°ï¼Œä¸ºæ¥ä¸‹æ¥å­¦ä¹ æ¯’ç˜¤çš„è®¡æ•°é—®é¢˜ä½œå‡†å¤‡ã€‚ åŸºæœ¬æ¦‚å¿µ ç»„åˆè®¡æ•°ä¸­æœ‰ä¸€äº›åŸºæœ¬æ¦‚å¿µï¼Œåœ¨è¿™é‡Œç®€ç•¥åœ°è¿›è¡Œä»‹ç»ã€‚ åŠ æ³•åŸç† æ¯”å¦‚ james1 è¦åƒä¸œè¥¿ï¼Œä»–å¯ä»¥åƒå‚»ç“œæœå’Œç¬¨è›‹æœä¸¤ç§æœå­ï¼Œå¸‚é¢ä¸Šåœ¨å”®çš„å‚»ç“œæœæœ‰ 333 ç§ï¼Œç¬¨è›‹æœæœ‰ 444 ç§ï¼Œå¦‚æœ james1 åªåƒä¸€é¢—æœå­å°±èƒ½åƒé¥±ï¼Œé‚£ä¹ˆä»–å°±æœ‰ 3+4=73+4=73+4=7 ç§é€‰æ‹©å»åƒé¥±ã€‚ å½¢å¼åŒ–åœ°ï¼Œå®Œæˆä¸€ä¸ª Project å¯ä»¥æœ‰ nnn ç±»åŠæ³•ï¼Œaia_iaiâ€‹ ä»£è¡¨ç¬¬ iii ç±»æ–¹æ³•çš„æ•°ç›®ã€‚é‚£ä¹ˆå®Œæˆè¿™ä¸ª Project å…±æœ‰ S=a1+a2+â‹¯+an=âˆ‘i=1naiS=a_1+a_2+\\cdots+a_n=\\sum\\limits_{i=1}^{n}a_iS=a1â€‹+a2â€‹+â‹¯+anâ€‹=i=1âˆ‘nâ€‹aiâ€‹ ç§ä¸åŒçš„æ–¹æ³•ã€‚ ä¹˜æ³•åŸç† æ¯”å¦‚ james1 è¦å˜å‚»ï¼ˆé›¾ï¼‰ï¼Œè¦åƒä¸€ç§å‚»ç“œæœå’Œä¸€ç§ç¬¨è›‹æœï¼Œå¸‚é¢ä¸Šåœ¨å”®çš„å‚»ç“œæœæœ‰ 333 ç§ï¼Œç¬¨è›‹æœæœ‰ 444 ç§ï¼Œé‚£ä¹ˆ james1 å˜å‚»çš„æ–¹å¼å°±æœ‰ 3Ã—4=123 \\times 4 = 123Ã—4=12ã€‚ å½¢å¼åŒ–åœ°ï¼Œå®Œæˆä¸€ä¸ª Project å¯ä»¥æœ‰ nnn ä¸ªæ­¥éª¤ï¼Œaia_iaiâ€‹ ä»£è¡¨å®Œæˆç¬¬ iii æ­¥çš„æ–¹æ³•æ•°ç›®ã€‚é‚£ä¹ˆå®Œæˆè¿™ä¸ª Project å…±æœ‰ S=a1Ã—a2Ã—â‹¯Ã—an=âˆi=1naiS=a_1 \\times a_2\\times\\cdots\\times a_n=\\prod\\limits_{i=1}^{n}a_iS=a1â€‹Ã—a2â€‹Ã—â‹¯Ã—anâ€‹=i=1âˆnâ€‹aiâ€‹ ç§ä¸åŒçš„æ–¹æ³•ã€‚ æŠ½å±‰åŸç†ï¼ˆé¸½ç¬¼åŸç†ï¼‰ å¸¸ç”¨äºå­˜åœ¨æ€§è¯æ˜ä¸æç«¯æƒ…å†µæ±‚è§£ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š ç®€å•å½¢å¼ james1 è¦å°† n+1n+1n+1 ä¸ªç¬¨è›‹æœæ”¾åˆ° nnn ä¸ªé¸½ç¬¼ä¸­ï¼Œé‚£ä¹ˆå¯ä»¥å¾—å‡ºè‡³å°‘æœ‰ä¸€ä¸ªé¸½ç¬¼ä¸­æœ‰ä¸¤ä¸ªï¼ˆæˆ–ä»¥ä¸Šï¼‰ç¬¨è›‹æœã€‚ è¯æ˜ï¼š é‡‡ç”¨åè¯æ³•ã€‚å‡å¦‚æ¯ä¸ªåˆ†ç»„æœ‰è‡³å¤š 111 ä¸ªç‰©ä½“ï¼Œé‚£ä¹ˆæœ€å¤šæœ‰ nnn ä¸ªç‰©ä½“ï¼Œè€Œå´æœ‰ n+1n+1n+1 ä¸ªç‰©ä½“ï¼ŒçŸ›ç›¾ã€‚ è¯æ¯•ã€‚ æ¨å¹¿ james1 è¦å°† nnn ä¸ªå‚»ç“œæœæ”¾åˆ° kkk ä¸ªé¸½ç¬¼ä¸­ï¼Œé‚£ä¹ˆå¯ä»¥å¾—å‡ºè‡³å°‘æœ‰ä¸€ä¸ªé¸½ç¬¼ä¸­æœ‰å¤§äºæˆ–ç­‰äº âŒˆnkâŒ‰\\lceil \\cfrac{n}{k} \\rceilâŒˆknâ€‹âŒ‰ ä¸ªç¬¨è›‹æœã€‚ è¯æ˜åŒæ ·é‡‡ç”¨åè¯æ³•ï¼Œç•™ç»™è¯»è€…æ’•çƒ¤ã€‚ æ’åˆ—æ•° ä» nnn ä¸ªä¸åŒå…ƒç´ ä¸­ï¼Œä»»å– mmmï¼ˆmâ©½nm\\leqslant nmâ©½nï¼‰ä¸ªå…ƒç´ æŒ‰ç…§ä¸€å®šçš„é¡ºåºæ’æˆä¸€åˆ—ï¼Œæ–¹æ¡ˆä¸ªæ•°è®°ä½œ AnmA_{n}^{m}Anmâ€‹ï¼ˆæ¨èï¼‰æˆ– PnmP_{n}^{m}Pnmâ€‹ã€‚ æ˜¾ç„¶ï¼Œç¬¬ä¸€ä¸ªæ•°æœ‰ nnn ç§å–æ³•ã€‚ ç¬¬äºŒä¸ªæ•°æœ‰ nâˆ’1n-1nâˆ’1 ç§ã€‚ â€¦\\dotsâ€¦ ç¬¬ mmm ä¸ªæ•°æœ‰ nâˆ’m+1n-m+1nâˆ’m+1 ç§å–æ³•ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œæœ‰ï¼š Anm=n(nâˆ’1)(nâˆ’2)â‹¯(nâˆ’m+1)=n!(nâˆ’m)!A_{n}^{m}=n(n-1)(n-2)\\cdots(n-m+1)=\\cfrac{n!}{(n-m)!} Anmâ€‹=n(nâˆ’1)(nâˆ’2)â‹¯(nâˆ’m+1)=(nâˆ’m)!n!â€‹ ç½®æ¢å’Œæ’åˆ— ä¸€ä¸ªæœ‰é™é›†åˆ SSS åˆ°è‡ªèº«çš„åŒå°„ç§°ä¸º SSS çš„ä¸€ä¸ªç½®æ¢ï¼Œé›†åˆ S=a1,â‹¯ ,anS={a_1,\\cdots,a_n}S=a1â€‹,â‹¯,anâ€‹ çš„ç½®æ¢å¯ä»¥è¡¨ç¤ºä¸ºï¼š f=(a1,a2,â€¦,anap1,ap2,â€¦,apn)f=\\begin{pmatrix}a_1,a_2,\\dots,a_n\\\\ a_{p_1},a_{p_2},\\dots,a_{p_n} \\end{pmatrix} f=(a1â€‹,a2â€‹,â€¦,anâ€‹ap1â€‹â€‹,ap2â€‹â€‹,â€¦,apnâ€‹â€‹â€‹) æ˜¯å°† aia_iaiâ€‹ æ˜ å°„ä¸º apia_{p_i}apiâ€‹â€‹ï¼Œè¿™æ · ppp æ˜¯ 1â‹¯n1\\cdots n1â‹¯n çš„ä¸€ä¸ªæ’åˆ—ï¼ŒSSS ä¸Šçš„æ‰€æœ‰ç½®æ¢çš„æ•°é‡ä¸º n!n!n!ã€‚ ç½®æ¢çš„è¿‡ç¨‹å¯ä»¥ä½¿ç”¨æœ‰å‘å›¾æ¥ç†è§£ï¼Œè¿è¾¹ iâ†’pii\\rightarrow p_iiâ†’piâ€‹ï¼Œå°±æ˜¯æ‰€æœ‰ç‚¹ç§»åŠ¨ 111 çš„è·ç¦»ã€‚ å¯¹äºä¸¤ä¸ªç½®æ¢ f,gf,gf,g çš„ä¹˜ç§¯è®°ä½œ fâˆ˜gf\\circ gfâˆ˜gï¼Œä»£è¡¨å…ˆé€šè¿‡ fff çš„æ˜ å°„ï¼Œå†é€šè¿‡ ggg çš„æ˜ å°„ã€‚ ä¸€ä¸ªæ’åˆ—ä¸­çš„é€†åºå¯¹ä¸ªæ•°ï¼Œä¹Ÿå«åšååºæ•°ï¼Œå¦‚æœæ˜¯å¶æ•°å°±æ˜¯å¶æ’åˆ—ï¼Œå¥‡æ•°åˆ™æ˜¯å¥‡æ’åˆ—ã€‚ å¯¹äºä¸€ä¸ªæ’åˆ— 1,â‹¯ ,n1,\\cdots,n1,â‹¯,nï¼Œå¦‚æœå°†ä»»æ„ä¸¤ä¸ªæ•° i,ji,ji,j äº¤æ¢ï¼Œå…¶å®ƒæ•°ä¿æŒä¸åŠ¨ï¼Œå°±ä¼šå¾—åˆ°ä¸€ä¸ªæ–°çš„æ’åˆ—ï¼Œé‚£ä¹ˆè¿™æ ·ä¸€ä¸ªå˜æ¢å«åšå¯¹æ¢ï¼Œç”¨ (i,j)(i,j)(i,j) è¡¨ç¤ºã€‚ ç»„åˆæ•° ä» nnn ä¸ªä¸åŒå…ƒç´ ä¸­ï¼Œä»»å– mmmï¼ˆmâ©½nm\\leqslant nmâ©½nï¼‰ä¸ªå…ƒç´ æŒ‰ç…§ä»»æ„çš„é¡ºåºç»„æˆä¸€ä¸ªé›†åˆï¼Œæ–¹æ¡ˆä¸ªæ•°è®°ä½œ CnmC_{n}^{m}Cnmâ€‹ã€‚ è¿™ mmm ä¸ªäººæ˜¯æ²¡æœ‰é¡ºåºçš„ï¼Œæ‰€ä»¥ AmmA_{m}^{m}Ammâ€‹ ä¸ªæ–¹æ¡ˆæ˜¯åŒä¸€ä¸ªæ–¹æ¡ˆï¼Œæ‰€ä»¥æ€»æ–¹æ¡ˆæ•°ä¸ºï¼š Cnm=AnmAmm=n!(nâˆ’m)!Ã·m!=n!(nâˆ’m)!m!Cnm=AnmAmm=n(nâˆ’1)(nâˆ’2)â‹¯(nâˆ’m+1)m!=âˆi=nâˆ’m+1nim!C_{n}^{m}=\\cfrac{A_{n}^{m}}{A_{m}^{m}}=\\cfrac{n!}{(n-m)!} \\div m! = \\cfrac{n!}{(n-m)!m!}\\\\ C_{n}^{m}=\\cfrac{A_{n}^{m}}{A_{m}^{m}}=\\cfrac{n(n-1)(n-2)\\cdots(n-m+1)}{m!}=\\cfrac{\\prod_{i=n-m+1}^n i}{m!} Cnmâ€‹=Ammâ€‹Anmâ€‹â€‹=(nâˆ’m)!n!â€‹Ã·m!=(nâˆ’m)!m!n!â€‹Cnmâ€‹=Ammâ€‹Anmâ€‹â€‹=m!n(nâˆ’1)(nâˆ’2)â‹¯(nâˆ’m+1)â€‹=m!âˆi=nâˆ’m+1nâ€‹iâ€‹ å®é™…ä¸Šï¼Œç»„åˆæ•°ä¹Ÿé€šå¸¸ç”¨ (nm)\\dbinom{n}{m}(mnâ€‹) è¡¨ç¤ºï¼Œç›¸å½“äº CnmC_{n}^{m}Cnmâ€‹ï¼Œè¿™ä¹Ÿè¢«ç§°ä¹‹ä¸ºäºŒé¡¹å¼ç³»æ•°ã€‚ ç»„åˆæ•°æœ‰ä»¥ä¸‹æ€§è´¨ï¼š Cnm=Cnnâˆ’mC_{n}^{m} = C_{n}^{n-m}Cnmâ€‹=Cnnâˆ’mâ€‹ï¼› Cn0+Cn1+Cn2+â‹¯+Cnn=âˆ‘i=0nCni=2nC_{n}^{0}+C_{n}^{1}+C_{n}^{2}+\\cdots+C_{n}^{n}=\\sum\\limits_{i=0}^{n}C_{n}^{i}=2^nCn0â€‹+Cn1â€‹+Cn2â€‹+â‹¯+Cnnâ€‹=i=0âˆ‘nâ€‹Cniâ€‹=2nï¼› (nk)=nâˆ’k+1k(nkâˆ’1)\\dbinom{n}{k}=\\cfrac{n-k+1}{k}\\dbinom{n}{k-1}(knâ€‹)=knâˆ’k+1â€‹(kâˆ’1nâ€‹)ã€‚ è¯æ˜ï¼š ä» nnn ä¸ªæ•°ä¸­é€‰ mmm ä½œä¸ºå­é›†ï¼Œå‰©ä¸‹çš„ nâˆ’mn-mnâˆ’m ä¸ªæ•°ä¹Ÿå¯¹åº”ä¸€ä¸ªé›†åˆï¼ˆè¿™ä¸€ç‚¹å¯ä»¥ç”¨å…¬å¼è¯æ˜ï¼Œç•™ç»™è¯»è€…æ’•çƒ¤ï¼‰ã€‚ä» nnn ä¸ªä¸åŒå…ƒç´ å–å‡ºè‹¥å¹²ä¸ªå…ƒç´ ç»„æˆä¸€ä¸ªé›†åˆï¼Œå½“ç„¶å¯ä»¥å– 0âˆ¼n0\\sim n0âˆ¼n ä¸ªæ•°ï¼Œå³ âˆ‘i=0nCni\\sum\\limits_{i=0}^{n}C_{n}^{i}i=0âˆ‘nâ€‹Cniâ€‹ï¼Œæ¯ä¸ªæ•°åˆæœ‰å–å’Œä¸å–ä¸¤ç§å¯èƒ½ï¼Œæ‰€ä»¥å®ƒç­‰äº 2n2^n2nã€‚ç”±ç»„åˆæ•°çš„å…¬å¼å¯ä»¥æ¨å¯¼å‡ºï¼Œå®ƒç»å¸¸è¢«ç”¨æ¥é€’æ¨æ±‚å•ä¸ªç»„åˆæ•°ã€‚å¤§æ¦‚é•¿è¿™æ ·ï¼šint C(int n, int m) &#123; int res = 1; for (int i = 1; i &lt;= m; ++i) res = 1ll * res * (n - i + 1) / i; return res; &#125; ç„¶åæ˜¯ä¸€äº›ä¸æ˜¯é‚£ä¹ˆå¥½æƒ³ï¼Œä½†æ˜¯åœ¨å…³é”®æ—¶åˆ»éå¸¸æœ‰ç”¨çš„å†…å®¹ï¼Œæ¨èèƒŒè¯µï¼š (nm)=nm(nâˆ’1mâˆ’1)\\dbinom{n}{m}=\\cfrac{n}{m}\\dbinom{n-1}{m-1}(mnâ€‹)=mnâ€‹(mâˆ’1nâˆ’1â€‹)ï¼› âˆ‘i=0m(ni)(mmâˆ’i)=(m+nm)(nâ‰¥m)\\sum\\limits_{i=0}^m\\dbinom{n}{i}\\dbinom{m}{m-i}=\\dbinom{m+n}{m}(n\\ge m)i=0âˆ‘mâ€‹(inâ€‹)(mâˆ’imâ€‹)=(mm+nâ€‹)(nâ‰¥m)ï¼Œå½“ n=mn=mn=m æ—¶æœ‰ âˆ‘i=0n(ni)2=(2nn)\\sum\\limits_{i=0}^{n}{\\dbinom{n}{i}}^2=\\dbinom{2n}{n}i=0âˆ‘nâ€‹(inâ€‹)2=(n2nâ€‹)ï¼› âˆ‘i=0n(ik)=(n+1k+1)\\sum\\limits_{i=0}^{n}\\dbinom{i}{k}=\\dbinom{n+1}{k+1}i=0âˆ‘nâ€‹(kiâ€‹)=(k+1n+1â€‹)ï¼› (nr)(rk)=(nk)(nâˆ’krâˆ’k)\\dbinom{n}{r}\\dbinom{r}{k}=\\dbinom{n}{k}\\dbinom{n-k}{r-k}(rnâ€‹)(krâ€‹)=(knâ€‹)(râˆ’knâˆ’kâ€‹)ï¼Œç›¸å½“äºæ˜¯ nnn åªå–µå–µä¸­é€‰ rrr ä¸ªé˜Ÿé•¿ï¼Œå†åœ¨é˜Ÿé•¿ä¸­é€‰æ‹© kkk ä¸ªå¤§é˜Ÿé•¿ï¼Œç­‰ä»·äº nnn åªå–µå–µå…ˆé€‰ kkk ä¸ªå¤§é˜Ÿé•¿å†é€‰ râˆ’kr-krâˆ’k ä¸ªé˜Ÿé•¿ï¼Œå› ä¸ºå¤§é˜Ÿé•¿ä¹Ÿæ˜¯é˜Ÿé•¿ã€‚ æ¨è¾‰ä¸‰è§’ æ¨è¾‰ä¸‰è§’é•¿è¿™æ ·ï¼ˆæ‰€æœ‰çš„ç©ºæ ¼å€¼éƒ½ä¸º 000ï¼‰ï¼š æ¨è¾‰ä¸‰è§’ ç¬¬ 000 åˆ— ç¬¬ 111 åˆ— ç¬¬ 222 åˆ— ç¬¬ 333 åˆ— ç¬¬ 444 åˆ— ç¬¬ 000 è¡Œ 111 ç¬¬ 111 è¡Œ 111 111 ç¬¬ 222 è¡Œ 111 222 111 ç¬¬ 333 è¡Œ 111 333 333 111 ç¬¬ 444 è¡Œ 111 444 666 444 111 å¯ä»¥è§‚å¯Ÿå‡º Cnm=Cnâˆ’1m+Cnâˆ’1mâˆ’1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnmâ€‹=Cnâˆ’1mâ€‹+Cnâˆ’1mâˆ’1â€‹ã€‚ è¯æ˜ï¼š æƒ³é€‰å‡º mmm ä¸ªæ•°ï¼Œè¦ä¹ˆé€‰ç¬¬ nnn ä¸ªæ•°ï¼Œè¦ä¹ˆä¸é€‰ï¼Œåˆ†åˆ«å¯¹åº” Cnâˆ’1mC_{n-1}^{m}Cnâˆ’1mâ€‹ å’Œ Cnâˆ’1mâˆ’1C_{n-1}^{m-1}Cnâˆ’1mâˆ’1â€‹ã€‚ æ‰€ä»¥ç»„åˆæ•°çš„æ¨è¾‰ä¸‰è§’é€’æ¨ä»£ç å¦‚ä¸‹ï¼š C[0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; j++) C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; &#125; äºŒé¡¹å¼å®šç† é«˜ä¸­å­¦è¿‡äºŒé¡¹å¼å®šç†ï¼š (a+b)n=âˆ‘i=1n(ni)anâˆ’ibi(a+b)^n = \\sum_{i=1}^{n}\\binom{n}{i}a^{n-i}b^i (a+b)n=i=1âˆ‘nâ€‹(inâ€‹)anâˆ’ibi è¿™ä¸ªå¼å­éå¸¸æœ‰ç”¨ï¼Œä¸€å®šè¦ç†Ÿè®°ã€‚å¦å¤–å¯ä»¥å‘ç°ï¼Œå¤šé¡¹å¼çš„ç³»æ•°å°±æ˜¯æ¨è¾‰ä¸‰è§’ã€‚ æ’åˆ—ç»„åˆæ–¹æ³• æˆ‘ä»¬æ¥çœ‹ä¸‰ä¸ªé—®é¢˜ï¼Œæ¥å¼•å‡ºæ’åˆ—ç»„åˆçš„ç»å…¸è®¡ç®—æ–¹æ³•ã€‚ æ†ç»‘æ³• nnn åªå…”å­å‚è§‚å¤§è¿å¸‚ç¬¬äºŒåå››ä¸­å­¦ï¼Œå…¶ä¸­ mmm åªå…”å­å…³ç³»ç‰¹åˆ«å¥½ï¼Œå®ƒä»¬ä¸€å®šè¦ç«™åœ¨ä¸€å—ã€‚é‚£ä¹ˆæœ‰å¤šå°‘ç§æ’åˆ—æ–¹æ³•ï¼Ÿ æˆ‘ä»¬æŠŠè¿™ mmm åªå…”å­çœ‹ä½œä¸€åªå¤§å…”å­ï¼Œé‚£ä¹ˆæ€»å…±å°±æœ‰ nâˆ’m+1n-m+1nâˆ’m+1 åªå…”å­ï¼Œæ’åˆ—æ–¹æ¡ˆæ•°æ˜¯ (nâˆ’m+1)!(n-m+1)!(nâˆ’m+1)!ï¼Œç„¶è€Œå¤§å…”å­é‡Œé¢ä¹Ÿæœ‰ m!m!m! ä¸­æ–¹æ³•ï¼Œé‚£ä¹ˆæ€»æ–¹æ³•æ•°å°±æ˜¯ (nâˆ’m+1)!m!(n-m+1)!m!(nâˆ’m+1)!m!ã€‚è¿™å°±æ˜¯æ†ç»‘æ³•ã€‚ æ’ç©ºæ³• nnn åªå…”å­å‚è§‚å¤§è¿å¸‚ç¬¬äºŒåå››ä¸­å­¦ï¼Œå…¶ä¸­ mmm åªå…”å­æœ‰ç€ä¸å…±æˆ´å¤©ä¹‹ä»‡ï¼Œå®ƒä»¬ä¸€å®šè¦ä¸èƒ½ç«™åœ¨ä¸€å—ã€‚é‚£ä¹ˆæœ‰å¤šå°‘ç§æ’åˆ—æ–¹æ³•ï¼Ÿ æˆ‘ä»¬å…ˆæŠŠ nâˆ’mn-mnâˆ’m åªå…”å­ç»™æ’åˆ—å¥½ï¼Œæœ‰ (nâˆ’m)!(n-m)!(nâˆ’m)! ç§æ–¹æ³•ã€‚è¿™äº›å…”å­ä¹‹é—´æœ‰ (nâˆ’m+1)(n-m+1)(nâˆ’m+1) ä¸ªç©ºï¼ˆç®—æœ€å·¦å’Œæœ€å³ï¼‰ï¼Œå†æŠŠè¿™äº›ä¸å…±æˆ´å¤©çš„å…”å­æ”¾åˆ°è¿™äº›ç©ºé‡Œï¼Œæœ‰ Anâˆ’m+1mA_{n-m+1}^{m}Anâˆ’m+1mâ€‹ ä¸ªæ–¹æ³•ã€‚æ€»æ–¹æ¡ˆæ•°å°±æ˜¯ (nâˆ’m)!Ã—Anâˆ’m+1m(n-m)!\\times A_{n-m+1}^{m}(nâˆ’m)!Ã—Anâˆ’m+1mâ€‹ã€‚è¿™å°±æ˜¯æ’ç©ºæ³•ã€‚ æ’æ¿æ³• james1 è¦å°† nnn ä¸ªç›¸åŒçš„èƒ¡èåœåˆ†ç»™ mmm åªå…”å­ï¼Œä»–ç§‰æŒé›¨éœ²å‡æ²¾çš„åŸåˆ™ï¼Œæ¯åªå…”å­è‡³å°‘åˆ†åˆ° 111 æ ¹èƒ¡èåœï¼Œæœ‰å¤šå°‘ç§æ–¹æ¡ˆï¼Ÿ æˆ‘ä»¬å…ˆä»‹ç»éš”æ¿æ³•ï¼ˆæ’æ¿æ³•ï¼‰ï¼Œæ˜¯æŒ‡åœ¨ nnn ä¸ªå…ƒç´ çš„ nâˆ’1n-1nâˆ’1 ä¸ªç©ºä¸­æ’å…¥ kkk ä¸ªæ¿ï¼Œå¯ä»¥æŠŠ nnn ä¸ªå…ƒç´ åˆ†ä¸º k+1k+1k+1 ç»„ã€‚ æˆ‘ä»¬æŠŠè¿™ nnn ä¸ªèƒ¡èåœæ’æˆ 111 è¡Œï¼Œå½“ä¸­å°±æœ‰ nâˆ’1n-1nâˆ’1 ä¸ªç©ºã€‚ç°åœ¨å¾€é‡Œé¢æ’å…¥ mâˆ’1m-1mâˆ’1 ä¸ªæ¿ï¼Œå°±å¯ä»¥å°†èƒ¡èåœåˆ†ä¸º mmm ç»„ï¼Œæ­£å¥½å¯ä»¥åˆ†ç»™ mmm åªå…”å­ï¼Œè€Œä¸”ç”±äºä¸å­˜åœ¨åœ¨åŒä¸€ä¸ªåœ°æ–¹æ’ä¸¤ä¸ªæ¿çš„æƒ…å†µï¼Œæ‰€ä»¥æ­£å¥½æ¯ä¸€åªå…”å­éƒ½èƒ½è‡³å°‘åˆ†åˆ° 111 æ ¹èƒ¡èåœã€‚é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ (nâˆ’1mâˆ’1)\\dbinom{n-1}{m-1}(mâˆ’1nâˆ’1â€‹)ã€‚ å®é™…ä¸Šè¿™ä¸ªé—®é¢˜ç›¸å½“äºæ±‚ä¸å®šæ–¹ç¨‹ x1+x2+â‹¯+xm=nx_1+x_2+\\cdots+x_m=nx1â€‹+x2â€‹+â‹¯+xmâ€‹=n çš„æ­£æ•´æ•°è§£çš„æ•°é‡ã€‚ å¦‚æœä»–æ˜¯ä¸ªå¤§é­”ç‹ï¼ˆä¸å¯èƒ½ï¼Œç»å¯¹ä¸å¯èƒ½ï¼‰ï¼Œæœ‰çš„å…”å­å¯èƒ½ 111 æ ¹èƒ¡èåœéƒ½å¾—ä¸åˆ°ï¼Œé‚£ä¹ˆæœ‰å¤šå°‘ç§æ–¹æ¡ˆï¼Ÿ åŒæ ·çš„æ–¹æ³•ï¼Œå¦‚æœå…è®¸æœ‰å…”å­åˆ†åˆ° 000 æ ¹èƒ¡èåœï¼Œæˆ‘ä»¬åªéœ€è¦å†åŠ ä¸Š mmm æ ¹èƒ¡èåœï¼Œå°±ç›¸å½“äºåˆšæ‰çš„é—®é¢˜äº†ã€‚ç­”æ¡ˆæ˜¯ (n+mâˆ’1mâˆ’1)=(n+mâˆ’1n)\\dbinom{n+m-1}{m-1}=\\dbinom{n+m-1}{n}(mâˆ’1n+mâˆ’1â€‹)=(nn+mâˆ’1â€‹)ã€‚ è¿™ä¸ªé—®é¢˜æœ¬è´¨ä¸Šæ˜¯è¦æ±‚ x1+x2+â‹¯+xm=nx_1+x_2+\\cdots+x_m=nx1â€‹+x2â€‹+â‹¯+xmâ€‹=n çš„è‡ªç„¶æ•°è§£çš„æ•°é‡ã€‚ å¦‚æœ james1 åçˆ±ä¸€äº›å…”å­ï¼Œè¦æ±‚ç¬¬ iii ä¸ªå…”å­è‡³å°‘åˆ†åˆ° eie_ieiâ€‹ ä¸ªèƒ¡èåœï¼Œé‚£ä¹ˆæœ‰å¤šå°‘ç§åˆ†æ³•å‘¢ï¼Ÿ ç±»æ¯”ä¸Šä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å†åŠ ä¸Š âˆ‘e\\sum eâˆ‘e ä¸ªèƒ¡èåœï¼Œç­”æ¡ˆå°±æ˜¯ (n+âˆ‘eâˆ’1n)\\dbinom{n+\\sum e - 1}{n}(nn+âˆ‘eâˆ’1â€‹)ã€‚ åœ¨ nnn ä¸ªæ•°ä¸­é€‰ mmm ä¸ªç»„åˆï¼Œè¦æ±‚ä»»æ„ä¸¤ä¸ªæ•°éƒ½ä¸ç›¸é‚»ï¼Œé‚£ä¹ˆæ–¹æ¡ˆæ•°æœ‰å¤šå°‘ï¼Ÿ (nâˆ’m+1n)\\dbinom{n-m+1}{n}(nnâˆ’m+1â€‹)ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦æ’å…¥ mâˆ’1m-1mâˆ’1 ä¸ªç©ºã€‚ ç®€å•é—®é¢˜ çœŸçš„åªæ˜¯åŠ æ³•åŸç†å’Œä¹˜æ³•åŸç†è€Œå·²ã€‚ [Luogu P1866] ç¼–å· Portal. ä¸ºäº†å°½å¯èƒ½é˜²æ­¢è´Ÿæ•°éœ€è¦å…ˆæ’åºï¼Œç„¶åä½¿ç”¨ä¹˜æ³•åŸç†è®¡ç®—ã€‚ä½†å¦‚æœè´Ÿæ•°çœŸçš„å‡ºç°äº†ï¼Œå°±æ— è§£ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define i64 long long using namespace std; const i64 MOD = 1000000007; int n; int a[55]; i64 ans = 1; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); for (int i = 1, k; i &lt;= n; i++) &#123; if ((k = a[i] - (i - 1)) > 0) ans = ans * k % MOD; else return puts(\"0\"), 0; &#125; printf(\"%d\\n\", ans); return 0; &#125; [NOIP2016 æé«˜ç»„] ç»„åˆæ•°é—®é¢˜ Portal. æˆ‘ä»¬ç›´æ¥åˆ©ç”¨æ¨è¾‰ä¸‰è§’é¢„å¤„ç†ç»„åˆæ•°ï¼Œç„¶åä½¿ç”¨äºŒç»´å‰ç¼€å’Œè®¡ç®—ç­”æ¡ˆå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int C[2005][2005]; int ans[2005][2005]; int main(void) &#123; int T, k; scanf(\"%d%d\", &amp;T, &amp;k); for (int i = 0; i &lt;= 2002; ++i) &#123; C[i][0] = 1, C[i][i] = 1; for (int j = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k; &#125; for (int i = 0; i &lt;= 2002; ++i) &#123; for (int j = 1; j &lt;= i; ++j) ans[i][j] = ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1] + (C[i][j] == 0); ans[i][i + 1] = ans[i][i]; &#125; while (T--) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", ans[n][min(n, m)]); &#125; return 0; &#125; [Luogu P1287] ç›’å­ä¸çƒ Portal. è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªçƒï¼Œæœ‰ jjj ä¸ªç›’å­çš„æ–¹æ¡ˆæ•°ã€‚æ˜¾ç„¶å¯ä»¥æ˜¯ç”±å‰ iâˆ’1i-1iâˆ’1 ä¸ªçƒï¼Œjjj ä¸ªç›’å­æ”¾åœ¨è¿™ jjj ä¸ªç›’å­ä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œä¹Ÿå¯ä»¥åªè€ƒè™‘ jâˆ’1j-1jâˆ’1 ä¸ªç›’å­ï¼Œåªèƒ½æ”¾åœ¨ç¬¬ jjj ä¸ªç›’å­ï¼Œä½†æ˜¯è¿™ç¬¬ jjj ä¸ªç›’å­çš„ä½ç½®å¯ä»¥ä»»æ„æ‘†æ”¾ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, r; int f[15][15]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;r); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= min(i, r); ++j) f[i][j] = j * (f[i - 1][j] + f[i - 1][j - 1]); printf(\"%d\\n\", f[n][r]); return 0; &#125; é‚£ä¹ˆç›’å­ç›¸åŒå‘¢ï¼Ÿè¿™æ ·å¯ä»¥ä¹˜ jjj çš„å°±åªæœ‰ f(iâˆ’1,j)f(i-1,j)f(iâˆ’1,j) äº†ï¼Œå¯ä»¥åšä¸€ä¸‹ [Luogu P1655] å°æœ‹å‹çš„çƒã€‚ [Luogu P2638] å®‰å…¨ç³»ç»Ÿ Portal. ä¸éš¾çœ‹å‡ºæ”¾ 01 å¯ä»¥åˆ†å¼€è®¡ç®—ï¼Œæœ€åä½¿ç”¨ä¹˜æ³•åŸç†ç»„åˆåœ¨ä¸€èµ·ã€‚è€Œä»»ä½•ä¸€ä¸ªéƒ½å¯ä»¥ä½¿ç”¨æ’æ¿æ³•çš„ç»“è®ºè¿›è¡Œè®¡ç®—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; int n, a, b; u64 C[105][105]; int main(void) &#123; C[0][0] = 1; for (int i = 1; i &lt;= 100; ++i) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; ++j) C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; &#125; scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b); u64 ans = 0; for (int i = 0; i &lt;= a; ++i) for (int j = 0; j &lt;= b; ++j) ans += C[n + i - 1][i] * C[n + j - 1][j]; printf(\"%llu\\n\", ans); return 0; &#125; [Luogu P8557] ç‚¼é‡‘æœ¯ Portal. ä¸€ç§é‡‘å±æœ‰ 2kâˆ’12^k-12kâˆ’1 ç§å¯èƒ½è¢«ç†”ç‚¼å‡ºæ¥ï¼Œç„¶åæ¯ä¸€ç§é‡‘å±çš„å¯èƒ½éƒ½è¦ä¹˜èµ·æ¥ï¼ˆä¹˜æ³•åŸç†ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; inline int poww(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % MOD; a = 1ll * a * a % MOD; b >>= 1; &#125; return res; &#125; int main(void) &#123; int n, k; cin >> n >> k; cout &lt;&lt; poww(poww(2, k) - 1, n) &lt;&lt; '\\n'; return 0; &#125; [UVA11609] Teams Portal. é˜Ÿé•¿æœ‰ nnn ä¸­å¯èƒ½ï¼Œæ¯ä¸€ä¸ªäººå½“é˜Ÿé•¿å‰©ä¸‹çš„äººéƒ½æœ‰ 2nâˆ’12^{n-1}2nâˆ’1 ç§å¯èƒ½ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; int poww(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % MOD; a = 1ll * a * a % MOD; b >>= 1; &#125; return res; &#125; int main(void) &#123; int T, kase = 0, n; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); printf(\"Case #%d: %d\\n\", ++kase, 1ll * n * poww(2, n - 1) % MOD); &#125; return 0; &#125; ç»„åˆå·¥å…· è®¡æ•°é—®é¢˜æœ‰ä¸€äº›å¸¸è§çš„å·¥å…·å¯ä»¥è¾…åŠ©è®¡ç®—ã€‚ ç»„åˆå…¬å¼ è¿˜è®°å¾—æœ‰å…³ç»„åˆæ•°çš„å…¬å¼å—ï¼Ÿäº‹å®ä¸Šï¼Œæœ€é‡è¦çš„å†…å®¹æœ‰åæœ‰å§“ï¼Œå¹¶ä¸”éå¸¸æœ‰ç”¨ï¼š å¸æ”¶æ’ç­‰å¼ï¼š(rk)=rk(râˆ’1kâˆ’1)\\dbinom{r}{k}=\\dfrac{r}{k}\\dbinom{r-1}{k-1}(krâ€‹)=krâ€‹(kâˆ’1râˆ’1â€‹)ï¼Œå½“äºŒé¡¹å¼å¤–æœ‰ä¸€ä¸ªæ— ç”¨çš„ç³»æ•°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒâ€œå¸æ”¶â€è¿›äºŒé¡¹å¼ç³»æ•°ã€‚ ä¸‹æŒ‡æ ‡æ±‚å’Œï¼ˆè¡Œæ±‚å’Œï¼‰ï¼šâˆ‘i=0n(ni)=2n\\displaystyle \\sum_{i=0}^{n}\\binom{n}{i}=2^ni=0âˆ‘nâ€‹(inâ€‹)=2nï¼Œç›¸å½“äºæ˜¯äºŒé¡¹å¼å®šç†ä¸­ a=b=1a=b=1a=b=1ï¼Œå®ƒè¿˜æœ‰å˜å¼ï¼š âˆ‘i=0n(âˆ’1)i(ni)=0\\displaystyle \\sum_{i=0}^{n}(-1)^i\\binom{n}{i}=0i=0âˆ‘nâ€‹(âˆ’1)i(inâ€‹)=0ï¼Œè¿™æ˜¯äºŒé¡¹å¼å®šç†ä¸­ a=1,b=âˆ’1a=1,b=-1a=1,b=âˆ’1ï¼› âˆ‘i=0niÃ—(ni)=n2nâˆ’1\\displaystyle \\sum_{i=0}^{n}i\\times \\binom{n}{i}=n2^{n-1}i=0âˆ‘nâ€‹iÃ—(inâ€‹)=n2nâˆ’1ï¼Œå› ä¸º mÃ—(nm)=nÃ—(nâˆ’1mâˆ’1)m\\times \\dbinom{n}{m}=n\\times \\dbinom{n-1}{m-1}mÃ—(mnâ€‹)=nÃ—(mâˆ’1nâˆ’1â€‹)ã€‚ ä¸ŠæŒ‡æ ‡æ±‚å’Œï¼ˆåˆ—æ±‚å’Œï¼‰ï¼šâˆ‘i=0n(im)=(n+1m+1)\\displaystyle \\sum_{i=0}^{n}\\binom{i}{m}=\\binom{n+1}{m+1}i=0âˆ‘nâ€‹(miâ€‹)=(m+1n+1â€‹)ï¼Œå¯ä»¥çœ‹ä½œæ˜¯æšä¸¾ç¬¬ m+1m+1m+1 ä¸ªæ•°çš„ä½ç½® i+1i+1i+1ã€‚ å¯¹è§’çº¿æ±‚å’Œï¼šâˆ‘i=0n(m+ii)=(m+n+1n)\\displaystyle\\sum_{i=0}^{n}\\binom{m+i}{i}=\\binom{m+n+1}{n}i=0âˆ‘nâ€‹(im+iâ€‹)=(nm+n+1â€‹)ï¼Œåå¤åˆ©ç”¨ Cnm=Cnâˆ’1m+Cnâˆ’1mâˆ’1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnmâ€‹=Cnâˆ’1mâ€‹+Cnâˆ’1mâˆ’1â€‹ å³å¯è¯æ˜ã€‚ èŒƒå¾·è’™å¾·å·ç§¯ï¼šâˆ‘i=0k(ni)(mkâˆ’i)=(n+mk)\\displaystyle \\sum_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}i=0âˆ‘kâ€‹(inâ€‹)(kâˆ’imâ€‹)=(kn+mâ€‹)ã€‚ä»ç»„åˆæ„ä¹‰ä¸Šå¾ˆå®¹æ˜“è¯æ˜ï¼ˆæšä¸¾ nnn å’Œ mmm ä¸­é€‰çš„ä¸ªæ•°ï¼‰ï¼Œå¸¸ç”¨äºåˆå¹¶ç»„åˆæ•°ï¼Œè€ƒè™‘å®ƒçš„æ¨è®ºï¼š âˆ‘i=1n(ni)(niâˆ’1)=(2nnâˆ’1)\\displaystyle \\sum_{i=1}^n\\binom{n}{i}\\binom{n}{i-1}=\\binom{2n}{n-1}i=1âˆ‘nâ€‹(inâ€‹)(iâˆ’1nâ€‹)=(nâˆ’12nâ€‹)ï¼Œè¯æ˜å¾ˆç®€å•ï¼Œå› ä¸º (niâˆ’1)=(nnâˆ’i+1),(2nnâˆ’1)=(2nn+1)\\dbinom{n}{i-1}=\\dbinom{n}{n-i+1},\\dbinom{2n}{n-1}=\\dbinom{2n}{n+1}(iâˆ’1nâ€‹)=(nâˆ’i+1nâ€‹),(nâˆ’12nâ€‹)=(n+12nâ€‹)ï¼› âˆ‘i=0n(ni)2=(2nn)\\displaystyle\\sum_{i=0}^n\\binom{n}{i}^2=\\binom{2n}{n}i=0âˆ‘nâ€‹(inâ€‹)2=(n2nâ€‹)ï¼Œè¯æ˜åŸºæœ¬åŒç†ï¼› âˆ‘i=0m(ni)(mi)=(n+mm)\\displaystyle\\sum_{i=0}^m\\binom{n}{i}\\binom{m}{i}=\\binom{n+m}{m}i=0âˆ‘mâ€‹(inâ€‹)(imâ€‹)=(mn+mâ€‹)ï¼Œè¿™ä¸ªä¹Ÿæ˜¯ç½‘æ ¼å›¾è·¯å¾„è®¡æ•°æ–¹æ¡ˆã€‚ N é¡¹å¼å®šç† äºŒé¡¹å¼å®šç†ä¹Ÿèƒ½æ‰©å±•ä¸º nnn é¡¹å¼å®šç†ï¼š (x1+â‹¯+xt)n=âˆ‘niâ‰¥0,n1+â‹¯+nt(nn1,â‹¯ ,nt)x1n1â‹¯xtnt(x_1+\\cdots+x_t)^n=\\sum_{n_i\\ge 0,n_1+\\cdots+n_t}\\binom{n}{n_1,\\cdots,n_t}x_{1}^{n_1}\\cdots x_{t}^{n_t} (x1â€‹+â‹¯+xtâ€‹)n=niâ€‹â‰¥0,n1â€‹+â‹¯+ntâ€‹âˆ‘â€‹(n1â€‹,â‹¯,ntâ€‹nâ€‹)x1n1â€‹â€‹â‹¯xtntâ€‹â€‹ å…¶ä¸­ (nn1,â‹¯ ,nt)=n!n1!â‹¯nt!\\binom{n}{n_1,\\cdots,n_t}=\\cfrac{n!}{n_1!\\cdots n_t!} (n1â€‹,â‹¯,ntâ€‹nâ€‹)=n1â€‹!â‹¯ntâ€‹!n!â€‹ Lucas å®šç† Lucas å®šç†æ˜¯è¯´ï¼Œå¯¹äºè´¨æ•° pppï¼Œæœ‰ï¼š (nm) mod p=(âŒŠn/pâŒ‹âŒŠm/pâŒ‹)â‹…(n mod pm mod p) mod p\\binom{n}{m}\\bmod p = \\binom{\\left\\lfloor n/p \\right\\rfloor}{\\left\\lfloor m/p\\right\\rfloor}\\cdot\\binom{n\\bmod p}{m\\bmod p}\\bmod p (mnâ€‹)modp=(âŒŠm/pâŒ‹âŒŠn/pâŒ‹â€‹)â‹…(mmodpnmodpâ€‹)modp æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, p; int fac[100005]; void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a % b, y, x); y -= a / b * x; &#125; int inv(int t) &#123; int x, y; exgcd(t, p, x, y); return (x % p + p) % p; &#125; int C(int n, int m) &#123; if (m > n) return 0; if (m == 0 || m == n) return 1; return 1ll * fac[n] * inv(fac[m]) % p * inv(fac[n - m]) % p; &#125; int Lucas(int n, int m) &#123; if (m == 0 || m == n) return 1; return 1ll * Lucas(n / p, m / p) * C(n % p, m % p) % p; &#125; int main(void) &#123; fac[0] = 1; int T; cin >> T; while (T--) &#123; cin >> n >> m >> p; for (int i = 1; i &lt;= p; ++i) fac[i] = 1ll * fac[i - 1] * i % p; cout &lt;&lt; Lucas(n + m, m) &lt;&lt; '\\n'; &#125; return 0; &#125; å› æ­¤å¯ä»¥å‘ç°ï¼ŒLucas å®šç†é¢å¯¹çš„æ¨¡æ•°ä¸ä¼šå¾ˆå¤§ï¼Œå¦åˆ™æ˜¯æ— æ³•è®¡ç®—çš„ã€‚ è€Œä¸”å½“æ¨¡æ•°å°çš„æ—¶å€™ï¼Œå¾€å¾€éœ€è¦ä½¿ç”¨ Lucas å®šç†ã€‚å› ä¸º nnn å¯èƒ½å¾ˆå¤§ï¼Œç”¨å…¬å¼è®¡ç®—ä¼šä½¿å¾—é˜¶ä¹˜åœ¨æ¨¡æ„ä¹‰ä¸‹ç›´æ¥å˜æˆ 000ã€‚ æ‰©å±• Lucas å®šç† æ¨¡æ¿ã€‚ å®¹æ–¥åŸç† å®¹æ–¥åŸç†æ˜¯éå¸¸é‡è¦çš„è®¡æ•°åŸç†ï¼Œèƒ½å¤Ÿå¯¹é—®é¢˜çš„è§’åº¦è¿›è¡Œè½¬åŒ–ï¼Œå¼±åŒ–æˆ–è€…åŠ å¼ºé—®é¢˜çš„é™åˆ¶ï¼Œä»è€Œä½¿é—®é¢˜æ›´åŠ ç®€æ´ã€‚ å¼•å…¥ å®¹æ–¥åŸç†å¤§å®¶ä¸€å®šä¸é™Œç”Ÿï¼Œæˆ‘ä»¬ç°åœ¨è¦ç»™å‡º nnn ä¸ªé›†åˆçš„æƒ…å†µã€‚è®¾å…¨é›†ä¸º UUUï¼Œæ‹¥æœ‰å±æ€§ PiP_iPiâ€‹ çš„å…ƒç´ æ„æˆé›†åˆ SiS_iSiâ€‹ï¼Œé‚£ä¹ˆï¼š âˆ£â‹ƒi=1nSiâˆ£=âˆ‘m=1n(âˆ’1)mâˆ’1âˆ‘ai&lt;ai+1âˆ£â‹‚i=1mSaiâˆ£\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i&lt;a_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right| â€‹i=1â‹ƒnâ€‹Siâ€‹â€‹=m=1âˆ‘nâ€‹(âˆ’1)mâˆ’1aiâ€‹&lt;ai+1â€‹âˆ‘â€‹â€‹i=1â‹‚mâ€‹Saiâ€‹â€‹â€‹ é›†åˆçš„äº¤é›† å¯ä»¥ä½¿ç”¨å…¨é›† UUU å‡å»è¡¥é›†çš„å¹¶é›†å¾—åˆ°ã€‚ âˆ£â‹‚i=1nSiâˆ£=âˆ£Uâˆ£âˆ’âˆ£â‹ƒi=1nSiâ€¾âˆ£\\left|\\bigcap_{i=1}^{n}S_i\\right|=|U|-\\left|\\bigcup_{i=1}^n\\overline{S_i}\\right| â€‹i=1â‹‚nâ€‹Siâ€‹â€‹=âˆ£Uâˆ£âˆ’â€‹i=1â‹ƒnâ€‹Siâ€‹â€‹â€‹ å­é›†æšä¸¾ å­é›†æšä¸¾å¯ä»¥è®©å®¹æ–¥åŸç†çš„è®¡ç®—å˜å¾—éå¸¸ç®€ä¾¿ï¼Œä»£ç å¦‚ä¸‹ï¼š for (int i = S; i; i = i - 1 &amp; S) è¿™æ · iii æšä¸¾çš„å°±æ˜¯ SSS çš„éç©ºå­é›†ã€‚ åº”ç”¨ å®¹æ–¥åŸç†æœ€ç»å…¸çš„ç”¨å¤„æ˜¯â€œè‡³å°‘â€ä¸â€œæ°å¥½â€ä¹‹é—´çš„è½¬åŒ–ï¼Œå®é™…ä¸Šæ˜¯ä¸€ä¸ªå­é›†åæ¼”çš„è¿‡ç¨‹ã€‚æ¯”è¾ƒæŠ½è±¡ï¼Œè¯·å‚è€ƒã€Šç»„åˆè®¡æ•°è¿›é˜¶ã€‹ã€‚ ç»å…¸è®¡æ•° åŒ…æ‹¬ä¸€äº›ç»å…¸é—®é¢˜å’Œè®¡æ•°æ•°åˆ—ã€‚ä½†æ˜¯é™äºæœ¬æ–‡çš„å®šä½ï¼Œå¹¶ä¸ä¼šè®²çš„å¾ˆæ·±ï¼Œæ›´æ·±çš„å†…å®¹è¯·å‚è€ƒã€Šç»„åˆè®¡æ•°è¿›é˜¶ã€‹ï¼Œå¹¶å…ˆé˜…è¯»ã€Šå¤šé¡¹å¼ä¸ç”Ÿæˆå‡½æ•°åŸºç¡€ã€‹ä¸­çš„ç”Ÿæˆå‡½æ•°éƒ¨åˆ†ã€‚ é”™æ’æ•° æ˜¯æŒ‡æ²¡æœ‰ä»»ä½•å…ƒç´ å‡ºç°åœ¨å…¶æœ‰åºä½ç½®çš„æ’åˆ—ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸å­˜åœ¨ Pi=iP_i=iPiâ€‹=iã€‚ æˆ‘ä»¬ä½¿ç”¨é€’æ¨è®¡ç®—è¿™ä¸ªé—®é¢˜ï¼Œè®¾ f(i)f(i)f(i) ä¸ºé•¿åº¦ä¸º iii çš„ç­”æ¡ˆã€‚é‚£ä¹ˆå¯ä»¥å‰ iâˆ’1i-1iâˆ’1 ä¸ªå…¨éƒ¨æ’é”™ï¼Œåªéœ€è¦ç¬¬ iii ä¸ªä¸å‰ iâˆ’1i-1iâˆ’1 ä¸ªä¸­çš„ä»»æ„ä¸€ä¸ªäº’æ¢å³å¯ï¼Œæ–¹æ¡ˆæ•°ä¸º (iâˆ’1)fiâˆ’1(i-1)f_{i-1}(iâˆ’1)fiâˆ’1â€‹ï¼›ä¹Ÿå¯ä»¥å‰é¢ä»…æœ‰ä¸€ä¸ªæ²¡æœ‰æ’é”™ï¼Œåªéœ€è¦å°†è¿™ä¸ªä¸ iii äº’æ¢ï¼Œæ–¹æ¡ˆæ•°ä¸º (iâˆ’1)fiâˆ’2(i-1)f_{i-2}(iâˆ’1)fiâˆ’2â€‹ï¼ˆæ²¡é”™æ’çš„å¯ä»¥æ˜¯ä»»æ„ä¸€ä¸ªï¼‰ã€‚ å› æ­¤ï¼šfi=(iâˆ’1)(fiâˆ’1+fiâˆ’2)f_i=(i-1)(f_{i-1}+f_{i-2})fiâ€‹=(iâˆ’1)(fiâˆ’1â€‹+fiâˆ’2â€‹)ã€‚ æ–¯ç‰¹æ—æ•° åˆ†ä¸ºç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•°å’Œç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ã€‚ç”±äºåè€…æ›´ä¸ºå¸¸ç”¨ï¼Œå› æ­¤æˆ‘ä»¬å…ˆæ¥ç ”ç©¶åè€…ã€‚ ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•° ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ä½¿ç”¨ {nk}\\begin{Bmatrix}n\\\\ k\\end{Bmatrix}{nkâ€‹} æˆ–è€… S(n,k)S(n,k)S(n,k) æ¥è¡¨ç¤ºï¼Œæ„ä¹‰æ˜¯å°† 1âˆ¼n1\\sim n1âˆ¼n çš„æ•´æ•°åˆ’åˆ†ä¸º kkk ä¸ªä¸äº¤çš„é›†åˆçš„æ–¹æ¡ˆæ•°ã€‚æ˜¾ç„¶ {n0}=[n=0]\\begin{Bmatrix}n\\\\ 0\\end{Bmatrix}=[n=0]{n0â€‹}=[n=0]ã€‚å¯ä»¥é‡‡ç”¨æš´åŠ›é€’æ¨æ³•æ±‚è§£ï¼š {nk}={nâˆ’1kâˆ’1}+k{nâˆ’1k}\\begin{Bmatrix}n\\\\ k\\end{Bmatrix}=\\begin{Bmatrix}n-1\\\\ k-1\\end{Bmatrix}+k\\begin{Bmatrix}n-1\\\\ k\\end{Bmatrix} {nkâ€‹}={nâˆ’1kâˆ’1â€‹}+k{nâˆ’1kâ€‹} ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿå°†ç¬¬ nnn ä¸ªå…ƒç´ æ”¾å…¥ä¸€ä¸ªæ–°çš„é›†åˆæœ‰ {nâˆ’1kâˆ’1}\\begin{Bmatrix}n-1\\\\ k-1\\end{Bmatrix}{nâˆ’1kâˆ’1â€‹} ç§æ–¹æ¡ˆï¼Œå°†ç¬¬ nnn ä¸ªå…ƒç´ æ’å…¥åŸæ¥ä»»æ„ä¸€ä¸ªé›†åˆæœ‰ k{nâˆ’1k}k\\begin{Bmatrix}n-1\\\\ k\\end{Bmatrix}k{nâˆ’1kâ€‹} çš„æ–¹æ¡ˆï¼Œæ ¹æ®åŠ æ³•åŸç†å¯å¾—é€’æ¨å¼ã€‚ å¯èƒ½éœ€è¦è®°ä½ä¸€äº›ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ï¼ˆå°±æ¯”å¦‚è¯´ï¼Œä¸€ä¸ªå‡ºç° 1,7,6,11,7,6,11,7,6,1 çš„é—®é¢˜å°±å¾ˆå¤§èƒ½ä¸ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°æœ‰å…³ï¼‰ï¼š 1 1 1 1 3 1 1 7 6 1 1 15 25 10 1 1 31 90 65 15 1 1 63 301 350 140 21 1 1 127 966 1701 1050 266 28 1 1 255 3025 7770 6951 2646 462 36 1 1 511 9330 34105 42525 22827 5880 750 45 1 ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°çš„é€šé¡¹å…¬å¼ï¼š {nm}=âˆ‘i=0m(âˆ’1)mâˆ’iini!(mâˆ’i)!\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\sum\\limits_{i=0}^m\\frac{(-1)^{m-i}i^n}{i!(m-i)!} {nmâ€‹}=i=0âˆ‘mâ€‹i!(mâˆ’i)!(âˆ’1)mâˆ’iinâ€‹ ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•° ç§°ä¹‹ä¸ºæ–¯ç‰¹æ—è½®æ¢æ•°ï¼Œè®°ä½œ [nk],s(n,k)\\begin{bmatrix}n\\\\ k\\end{bmatrix},s(n,k)[nkâ€‹],s(n,k)ï¼Œè¡¨ç¤ºå°† 1âˆ¼n1\\sim n1âˆ¼n çš„æ•´æ•°åˆ’åˆ†ä¸º kkk ä¸ªäº’ä¸åŒºåˆ†çš„éç©ºè½®æ¢æ–¹æ¡ˆæ•°ã€‚ ä¸€ä¸ªè½®æ¢æ˜¯æŒ‡ä¸€ä¸ªé¦–å°¾ç›¸æ¥çš„ç¯å½¢æ’åˆ—ï¼Œä¸¤ä¸ªå¯ä»¥é€šè¿‡æ—‹è½¬è€Œäº’ç›¸å¾—åˆ°çš„è½®æ¢æ˜¯ç­‰ä»·çš„ã€‚ ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•°çš„é€’æ¨å¼ï¼š [nk]=[nâˆ’1kâˆ’1]+(nâˆ’1)[nâˆ’1k]\\begin{bmatrix}n\\\\ k\\end{bmatrix}=\\begin{bmatrix}n-1\\\\ k-1\\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\\\ k\\end{bmatrix} [nkâ€‹]=[nâˆ’1kâˆ’1â€‹]+(nâˆ’1)[nâˆ’1kâ€‹] å‰è€…æ˜¯å°† nnn æ”¾åœ¨ä¸€ä¸ªå•ç‹¬çš„è½®æ¢ä¸­ï¼Œåè€…æ˜¯å°†å…¶æ”¾å…¥ä¸€ä¸ªç°æœ‰çš„è½®æ¢ä¸­ã€‚ è¿™ä¸ªç©æ„æ²¡æœ‰å®ç”¨çš„é€šé¡¹å…¬å¼ã€‚ å¡ç‰¹å…°æ•° å‰å‡ é¡¹é•¿è¿™æ ·ï¼š1 1 2 5 14 42 132ï¼Œéœ€è¦è®°ä½ã€‚å®ƒæœ‰éå¸¸å¤šçš„å«ä¹‰ï¼š nnn ä¸ªèŠ‚ç‚¹å¯æ„é€ çš„ä¸åŒäºŒå‰æ ‘ä¸ªæ•°ï¼› nnn ä¸ªæ•°ä¸åŒçš„å‡ºæ ˆåºåˆ—ä¸ªæ•°ï¼› â€¦â€¦ å¸¸è§å…¬å¼ï¼š Hn=Hnâˆ’1(4nâˆ’2)n+1Hn=(2nn)âˆ’(2nnâˆ’1)Hn=âˆ‘i=0nâˆ’1HiÃ—Hnâˆ’iâˆ’1(nâ‰¥2)H_n=\\frac{H_{n-1}(4n-2)}{n+1}\\\\ H_n=\\binom{2n}{n}-\\binom{2n}{n-1}\\\\ H_n=\\sum_{i=0}^{n-1}H_i\\times H_{n-i-1}(n\\ge 2) Hnâ€‹=n+1Hnâˆ’1â€‹(4nâˆ’2)â€‹Hnâ€‹=(n2nâ€‹)âˆ’(nâˆ’12nâ€‹)Hnâ€‹=i=0âˆ‘nâˆ’1â€‹Hiâ€‹Ã—Hnâˆ’iâˆ’1â€‹(nâ‰¥2) å¤šé‡é›†ç›¸å…³é—®é¢˜ æˆ‘ä»¬çŸ¥é“ä¸€ä¸ªå¤šé‡é›† SSS å¯ä»¥ä¸æ»¡è¶³äº’å¼‚æ€§ã€‚è®¾ S={n1Ã—a1â‹¯nkÃ—ak}S=\\{n_1\\times a_1\\cdots n_k\\times a_k\\}S={n1â€‹Ã—a1â€‹â‹¯nkâ€‹Ã—akâ€‹} ä»£è¡¨ç”± nin_iniâ€‹ ä¸ª aia_iaiâ€‹ ç»„æˆçš„å¤šé‡é›†ã€‚ å¤šé‡é›†çš„æ’åˆ—æ•° | å¤šé‡ç»„åˆæ•° è¿™ä¸¤ä¸ªæ˜¯åŒä¸€ä¸ªæ¦‚å¿µï¼Œæ˜¯è¦æ±‚å¤§å°ä¸º nnnï¼Œç¬¬ iii ä¸ªæ•°å‡ºç°æ¬¡æ•°ä¸º nin_iniâ€‹ çš„å¤šé‡é›† SSS çš„å…¨æ’åˆ—ä¸ªæ•°ï¼Œæˆ‘ä»¬è¦é™¤æ‰é‡å¤çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆ SSS çš„å…¨æ’åˆ—ä¸ªæ•°ç­‰äºï¼ˆå…¶å®å°±æ˜¯æŠŠç›¸åŒçš„æ•°é™¤æ‰äº†ï¼‰ï¼š (nn1,â€¦,nk)=n!âˆi=1kni!\\binom{n}{n_1,\\dots,n_k}=\\frac{n!}{\\prod_{i=1}^k n_i!} (n1â€‹,â€¦,nkâ€‹nâ€‹)=âˆi=1kâ€‹niâ€‹!n!â€‹ å¤šé‡ç»„åˆæ•°çš„æ„ä¹‰å°±æ˜¯å…ˆé€‰ n1n_1n1â€‹ ä¸ªï¼Œå†åœ¨å‰©ä¸‹çš„é€‰æ‹© n2n_2n2â€‹ ä¸ªï¼Œä»¥æ­¤ç±»æ¨ã€‚ [UVA11076] Add Again.ç»™å‡º nnn ä¸ªæ•°å­—ï¼Œæ±‚å‡ºä»–ä»¬æ’åˆ—åèƒ½å½¢æˆçš„æ‰€æœ‰æ•´æ•°çš„å’Œï¼Œå½¢æˆçš„æ•´æ•°ä¸é‡å¤ã€‚ æ•°çš„ä¸ªæ•°æ˜¾ç„¶å°±æ˜¯å¤šé‡ç»„åˆæ•°ï¼Œç„¶åæœ‰ nnn ä¸ªä½ç½®ï¼Œæ€»å…±çš„åºåˆ—ä¸ªæ•°æœ‰å¤šé‡ç»„åˆæ•° sss ä¸ªã€‚è®¾æ‰€æœ‰æ•°çš„å’Œä¸º sumsumsumï¼Œé‚£ä¹ˆå¹³å‡æ¯ä¸€ä½çš„å€¼å°±æ˜¯ sumÃ·nsum\\div nsumÃ·nï¼Œç„¶åå†ä¹˜ä¸ŠåŸºæ•°ï¼Œå…¨æ˜¯ 111 å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef unsigned long long u64; int main(void) &#123; int n; u64 f[15] = &#123;1&#125;; const u64 one[] = &#123;0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111, 11111111111, 111111111111&#125;; for (int i = 1; i &lt;= 12; ++i) f[i] = f[i - 1] * i; while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; static int cnt[10]; u64 sum = 0; memset(cnt, 0, sizeof(cnt)); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), ++cnt[x], sum += x; u64 s = f[n]; for (int i = 0; i &lt; 10; ++i) s /= f[cnt[i]]; printf(\"%llu\\n\", sum * s * one[n] / n); &#125; return 0; &#125; Problemset è¿™é‡Œçš„é¢˜ç›®éƒ½æ˜¯æ¯”è¾ƒåŸºç¡€çš„æ•°æ•°é¢˜ã€‚ ç®€å•é—®é¢˜ å¯ä»¥ç”¨æ¥å·©å›ºåŸºç¡€ã€‚ [USACO20FEB] Help Yourself G Portal.åœ¨ä¸€ä¸ªæ•°è½´ä¸Šæœ‰ NNN æ¡çº¿æ®µï¼Œç¬¬ iii æ¡çº¿æ®µè¦†ç›–äº† [li,ri][l_i,r_i][liâ€‹,riâ€‹]ã€‚å®šä¹‰è‹¥å¹²æ¡çº¿æ®µçš„å¹¶ä¸ºä¸€ä¸ªåŒ…å«äº†æ‰€æœ‰è¢«è‡³å°‘ä¸€ä¸ªçº¿æ®µè¦†ç›–çš„ç‚¹çš„é›†åˆã€‚å®šä¹‰è‹¥å¹²æ¡çº¿æ®µçš„å¤æ‚åº¦ä¸ºè¿™äº›çº¿æ®µçš„å¹¶å½¢æˆçš„è¿é€šå—çš„æ•°ç›®ã€‚ç°åœ¨ Bessie æƒ³è¦æ±‚å‡ºç»™å®š NNN æ¡çº¿æ®µçš„æ‰€æœ‰å­é›†ï¼ˆå…±æœ‰ 2N2^N2N ä¸ªï¼‰çš„å¤æ‚åº¦ä¹‹å’Œå¯¹ 109+710^9+7109+7 å–æ¨¡çš„ç»“æœã€‚ å¥½é¢˜ï¼ä¼¼ä¹æ²¡æœ‰ä»€ä¹ˆç‰¹æ®Šåšæ³•ï¼Œé‚£ä¹ˆè€ƒè™‘è®¡æ•° DPã€‚è®¾ fif_ifiâ€‹ ä»£è¡¨è€ƒè™‘å‰ iii æ¡çº¿æ®µçš„å¤æ‚åº¦ä¹‹å’Œã€‚å¦‚æœä¸é€‰ç¬¬ iii æ¡çº¿æ®µï¼Œé‚£ä¹ˆå¤æ‚åº¦å’Œæ˜¯ fiâˆ’1f_{i-1}fiâˆ’1â€‹ï¼›å¦‚æœé€‰ç¬¬ iii æ¡çº¿æ®µï¼Œé‚£ä¹ˆæ˜¯å¤šå°‘ï¼Ÿä¸å¥½åšï¼åŠ å…¥è¿™ä¸€æ¡çº¿æ®µä¹‹åå¯èƒ½æ–°å¢è”é€šå—ï¼Œä¹Ÿå¯èƒ½åˆå¹¶è”é€šå—ï¼Œé¬¼çŸ¥é“è´¡çŒ®æ˜¯ä»€ä¹ˆï¼ æ¢å¥è¯è¯´ï¼ŒçŠ¶æ€çš„è½¬ç§»é¡ºåºæœ‰é—®é¢˜ï¼Œå¯¼è‡´è´¡çŒ®ä¸å¥½è®¡ç®—ã€‚æˆ‘ä»¬å¯ä»¥æŒ‰ç…§çº¿æ®µçš„å·¦ç«¯ç‚¹ä»å°åˆ°å¤§æ’åºä¹‹åå†è¿›è¡Œè®¡ç®—ã€‚è¿™æ ·å°±ä¸å¯èƒ½åˆå¹¶è”é€šå—ï¼Œæ‰€ä»¥åŸæ¥çš„è´¡çŒ® fiâˆ’1f_{i-1}fiâˆ’1â€‹ éƒ½åœ¨ï¼›æ–°å¢è”é€šå—æ˜¯å¯ä»¥çš„ï¼Œå‡è®¾å‰é¢ä¸å½“å‰çº¿æ®µä¸äº¤çš„çº¿æ®µæœ‰ xxx æ¡ï¼ˆå¯ä»¥ä½¿ç”¨å‰ç¼€å’Œç»Ÿè®¡ï¼‰ï¼Œé‚£ä¹ˆæ–°å¢çš„å¤æ‚åº¦å°±æ˜¯ 2x2^x2xï¼ˆå°±æ˜¯åªé€‰è¿™ xxx æ¡çº¿æ®µçš„å­é›†æ—¶ï¼Œå¤æ‚åº¦ä¼šå¢åŠ  111ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define L first #define R second using namespace std; const int MOD = 1000000007; int n, f[100005], s[200005]; pair&lt;int, int> a[100005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;a[i].L, &amp;a[i].R), s[a[i].R]++; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n * 2; ++i) s[i] += s[i - 1]; for (int i = 1; i &lt;= n; ++i) f[i] = (f[i - 1] * 2 % MOD + poww(2, s[a[i].L - 1])) % MOD; printf(\"%d\\n\", f[n]); return 0; &#125; [CF340E] Iahub and Permutations æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªé”™æ’é—®é¢˜ï¼Œä½†æ˜¯å…¶ä¸­çš„ âˆ’1-1âˆ’1 å¯ä»¥æœ‰éšä¾¿å¡«çš„ï¼ŒåŠ ä¸€ä¸ªè½¬ç§»æ¥å¤„ç†å®ƒï¼ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, a[2005], tot1, tot2; // ä¸èƒ½æ”¾è‡ªèº«ï¼Œå¯ä»¥éšä¾¿æ”¾ bool p[2005]; int f[2005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] == i) return puts(\"0\"), 0; if (a[i] != -1) p[a[i]] = true; else ++tot1; &#125; for (int i = 1; i &lt;= n; ++i) if (a[i] == -1 &amp;&amp; p[i]) tot1--, tot2++; for (int i = f[0] = 1; i &lt;= tot2; ++i) f[0] = 1ll * f[0] * i % P; f[1] = 1ll * tot2 * f[0] % P; for (int i = 2; i &lt;= tot1; ++i) &#123; f[i] = 1ll * (f[i - 1] + f[i - 2]) * (i - 1) % P; f[i] = (f[i] + 1ll * tot2 * f[i - 1]) % P; &#125; return !printf(\"%d\\n\", f[tot1]); &#125; [AHOI2022] æ’åˆ— Portal. å»ºå‡ºç½®æ¢çš„æœ‰å‘å›¾ï¼Œæ¯ä¸ªç¯ç‹¬ç«‹ï¼Œé‚£ä¹ˆ vvv å°±æ˜¯æ¯ä¸ªç¯å¤§å°çš„ LCMã€‚å¦‚æœ i,ji,ji,j åœ¨ä¸€ä¸ªç¯é‡Œï¼Œé‚£ä¹ˆ f(i,j)=0f(i,j)=0f(i,j)=0ã€‚ è¿™ä¸ª swap æ“ä½œç›¸å½“äºåˆå¹¶äº†ä¸¤ä¸ªç¯ï¼Œè®¾ç¬¬ iii ä¸ªç¯çš„å¤§å°ä¸º aia_iaiâ€‹ï¼Œé‚£ä¹ˆç”±äº âˆ‘ai=n\\sum a_i=nâˆ‘aiâ€‹=nï¼Œå› æ­¤å€¼ä¸åŒçš„ aia_iaiâ€‹ åœ¨ n\\sqrt{n}nâ€‹ çº§åˆ«ã€‚æˆ‘ä»¬åªéœ€è¦æš´åŠ›æšä¸¾ä¸¤ä¸ªç¯çš„å¤§å°ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)O(n)O(n) çš„ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬éœ€è¦ç»´æŠ¤ä¸€ä¸ªé›†åˆçš„ LCMï¼Œæ”¯æŒåˆ é™¤ä¸¤ä¸ªæ•°å¹¶åŠ å…¥ä¸€ä¸ªæ–°çš„æ•°æ±‚å‡º LCMã€‚å°†æ•°è´¨å› æ•°åˆ†è§£ï¼Œå¯¹äºæ¯ä¸ªè´¨æ•°åªä¿ç•™ä¸‰ä¸ªå¹‚æ¬¡æœ€å¤§çš„ï¼ˆåˆ é™¤ä¸¤ä¸ªæ•°æ—¶æœ€ååªä¼šåˆ æ‰ä¸¤ä¸ªæœ€å¤§çš„ï¼‰ï¼ŒåŠ å…¥çš„æ—¶å€™æš´åŠ›ç»Ÿè®¡ä¸€ä¸‹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int N = 500000; void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; int n; int a[500005]; int fa[500005], siz[500005]; int find(int x) &#123; if (fa[x] == x) return x; return find(fa[x]); &#125; void uni(int x, int y) &#123; x = find(x), y = find(y); if (x == y) return; if (siz[x] > siz[y]) swap(x, y); fa[x] = y; siz[y] += siz[x]; &#125; int cnt[500005]; int prime[500005], tot, p[500005], inv[500005]; // p: æœ€å°è´¨å› å­ vector&lt;pair&lt;int, int>> fac[500005]; // fac[i] ä¿å­˜ i è´¨å› æ•°åˆ†è§£åçš„ç»“æœï¼Œfirst ä¸ºåº•æ•°ï¼Œsecond ä¸ºå¹‚ vector&lt;int> G[500005]; // G[i] ä¿å­˜è´¨æ•° i ä¸ºåº•æ•°çš„æœ€å¤§å¹‚ vector&lt;pair&lt;int, int>> E[500005]; // E ä¸ºä¸´æ—¶é™„åŠ  int A[1005], t, now; int C[500005]; int get(int v) &#123; // è·å–è´¨æ•° v çš„æœ€å¤§å¹‚ int mx = 1; for (int x : G[v]) ++C[x]; for (auto [x, k] : E[v]) C[x] += k; for (int x : G[v]) if (C[x]) mx = max(mx, x), C[x] = 0; for (auto [x, k] : E[v]) if (C[x]) mx = max(mx, x), C[x] = 0; return mx; &#125; void update(int v, int flag) &#123; for (auto [x, y] : fac[v]) &#123; now = 1ll * now * inv[get(x)] % P; E[x].emplace_back(y, flag); now = 1ll * now * get(x) % P; &#125; &#125; void remove(int v) &#123; for (auto [x, y] : fac[v]) E[x].clear(); &#125; int main(void) &#123; p[1] = inv[1] = 1; for (int i = 2; i &lt;= N; ++i) inv[i] = 1ll * (P - P / i) * inv[P % i] % P; for (int i = 2; i &lt;= N; ++i) &#123; if (!p[i]) prime[++tot] = i, p[i] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; p[i * prime[j]] = prime[j]; if (i % prime[j] == 0) break; &#125; &#125; for (int i = 1; i &lt;= N; ++i) &#123; int x = i; while (x != 1) &#123; int tmp = p[x], v = 1; while (x % tmp == 0) x /= tmp, v *= tmp; fac[i].emplace_back(tmp, v); &#125; &#125; int T; scanf(\"%d\", &amp;T); while (T--) &#123; memset(cnt, 0, sizeof cnt); t = 0; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), fa[i] = i, siz[i] = 1; for (int i = 1; i &lt;= n; ++i) uni(i, a[i]), G[i].clear(); for (int i = 1; i &lt;= n; ++i) if (find(i) == i) &#123; ++cnt[siz[i]]; for (auto [x, y] : fac[siz[i]]) G[x].emplace_back(y); &#125; for (int i = 1; i &lt;= n; ++i) if (cnt[i]) A[++t] = i; now = 1; for (int i = 1; i &lt;= n; ++i) if (G[i].size()) &#123; sort(G[i].begin(), G[i].end(), greater&lt;int>()); while (G[i].size() > 3) G[i].pop_back(); now = 1ll * now * G[i][0] % P; &#125; int ans = 0; for (int i = 1; i &lt;= t; ++i) &#123; int u = A[i]; if (cnt[u] > 1) &#123; int last = now; update(u, -1); update(u, -1); update(u + u, 1); add(ans, 1ll * cnt[u] * (cnt[u] - 1) % P * u % P * u % P * now % P); remove(u); remove(u + u); now = last; &#125; for (int j = i + 1; j &lt;= t; ++j) &#123; int last = now, v = A[j]; update(u, -1); update(v, -1); update(u + v, 1); add(ans, 2ll * cnt[u] * cnt[v] % P * u % P * v % P * now % P); remove(u); remove(v); remove(u + v); now = last; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [CF348D] Turtles Portal. åªæœ‰ä¸€åªä¹Œé¾Ÿçš„è¯æ˜¯ç»å…¸é—®é¢˜ï¼Œç°åœ¨è€ƒè™‘ä¸¤æ¡è·¯å¾„ä»€ä¹ˆæ—¶å€™æœ‰äº¤ã€‚ åªèƒ½æ˜¯ä¸€åªä¹Œé¾Ÿä» (1,2)(1,2)(1,2) èµ°åˆ° (nâˆ’1,m)(n-1,m)(nâˆ’1,m)ï¼Œå¦ä¸€åªä¹Œé¾Ÿä» (2,1)(2,1)(2,1) èµ°åˆ° (n,mâˆ’1)(n,m-1)(n,mâˆ’1)ã€‚å¦‚æœä¸€åªä¹Œé¾Ÿä» (1,2)(1,2)(1,2) èµ°åˆ° (n,mâˆ’1)(n,m-1)(n,mâˆ’1)ï¼Œå¦ä¸€åªä¹Œé¾Ÿä» (2,1)(2,1)(2,1) èµ°åˆ° (nâˆ’1,m)(n-1,m)(nâˆ’1,m)ï¼Œé‚£ä¹ˆè¿™æ ·è·¯å¾„æ˜¯ä¼šæœ‰äº¤çš„ã€‚ ä½†æ˜¯å‘ç°å‰è€…è‡ªèº«ä¹Ÿæœ‰å¯èƒ½æœ‰è·¯å¾„äº¤ï¼æ¯”å¦‚è¯´ä¸­é€”åœ¨ä¸€ä¸ªç‚¹è·¯å¾„ç›¸äº¤ã€‚æˆ‘ä»¬æŠŠè¿™ä¸ªç‚¹ä¹‹åçš„è·¯å¾„äº’æ¢ï¼Œå‘ç°éƒ½å¯ä»¥å¯¹åº”åˆ°ç¬¬äºŒç§çš„èµ°æ³•ã€‚è¿™æ ·åªéœ€è¦ç”¨å‰è€…å‡å»åè€…å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, m; char s[3005][3005]; int f[3005][3005]; int dp(int x, int y, int n, int m) &#123; memset(f, 0, sizeof f); for (int i = x; i &lt;= n; ++i) for (int j = y; j &lt;= m; ++j) if (s[i][j] != '#') &#123; if (i == x &amp;&amp; j == y) f[i][j] = 1; else f[i][j] = (f[i - 1][j] + f[i][j - 1]) % P; &#125; return f[n][m]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); f[1][1] = 1; for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", s[i] + 1); printf(\"%d\\n\", ((1ll * dp(1, 2, n - 1, m) * dp(2, 1, n, m - 1) - 1ll * dp(1, 2, n, m - 1) * dp(2, 1, n - 1, m)) % P + P) % P); return 0; &#125; å®é™…ä¸Šæœ¬é¢˜æ˜¯ LGV å¼•ç†çš„ä¸€ä¸ªåº”ç”¨ï¼Œç›¸å…³å†…å®¹åœ¨ã€Šç»„åˆè®¡æ•°è¿›é˜¶ã€‹æœ‰ä»‹ç»ã€‚ç”±äºæœ¬é¢˜åªæœ‰ä¸¤åªä¹Œé¾Ÿï¼Œå› æ­¤å¯ä»¥æ¯”è¾ƒæ–¹ä¾¿çš„ç”¨å®¹æ–¥åŸç†ç†è§£ã€‚ è®¡æ•°é—®é¢˜ å€ŸåŠ©åŠ¨æ€è§„åˆ’ç®—æ³•çš„å¤šé˜¶æ®µå†³ç­–ï¼Œå¯ä»¥é«˜æ•ˆçš„è§£å†³è®¡æ•°é—®é¢˜ã€‚ [HAOI2008] ç¡¬å¸è´­ç‰© Portal. å…±æœ‰ 444 ç§ç¡¬å¸ã€‚é¢å€¼åˆ†åˆ«ä¸º c1,c2,c3,c4c_1,c_2,c_3,c_4c1â€‹,c2â€‹,c3â€‹,c4â€‹ã€‚æŸäººå»å•†åº—ä¹°ä¸œè¥¿ï¼Œå»äº† nnn æ¬¡ï¼Œå¯¹äºæ¯æ¬¡è´­ä¹°ï¼Œä»–å¸¦äº† did_idiâ€‹ æš iii ç§ç¡¬å¸ï¼Œæƒ³è´­ä¹° sss çš„ä»·å€¼çš„ä¸œè¥¿ã€‚è¯·é—®æ¯æ¬¡æœ‰å¤šå°‘ç§ä»˜æ¬¾æ–¹æ³•ã€‚ å¦‚æœæ¯ä¸€ç§ç¡¬å¸éƒ½æœ‰æ— é™å¤šï¼Œé‚£ä¹ˆè¿™å°±æˆäº†ä¸ªå®Œå…¨èƒŒåŒ…ï¼Œç›´æ¥åšå°±å¯ä»¥ï¼Œè®°ä¸º f(s)f(s)f(s)ã€‚ æ¥ä¸‹æ¥è€ƒè™‘æ€§è´¨ã€‚åˆ©ç”¨è¡¥é›†æ€æƒ³ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ f(s)f(s)f(s) å‡å»è‡³å°‘æœ‰ä¸€ä¸ªè¶…è¿‡ã€‚ä¹Ÿå°±æ˜¯ f(sâˆ’(d1+1)Ã—c1)f(s-(d_1+1)\\times c_1)f(sâˆ’(d1â€‹+1)Ã—c1â€‹)ï¼Œä»¥æ­¤ç±»æ¨ã€‚ä½¿ç”¨å®¹æ–¥åŸç†è®¡ç®—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int M = 100000; int c1, c2, c3, c4, q; i64 f[M + 5]; inline i64 g(i64 x) &#123; return x &lt; 0 ? 0 : f[x]; &#125; int main(void) &#123; cin >> c1 >> c2 >> c3 >> c4 >> q; f[0] = 1; for (int i = c1; i &lt;= M; ++i) f[i] += f[i - c1]; for (int i = c2; i &lt;= M; ++i) f[i] += f[i - c2]; for (int i = c3; i &lt;= M; ++i) f[i] += f[i - c3]; for (int i = c4; i &lt;= M; ++i) f[i] += f[i - c4]; while (q--) &#123; int d1, d2, d3, d4, s; cin >> d1 >> d2 >> d3 >> d4 >> s; d1 = (d1 + 1) * c1, d2 = (d2 + 1) * c2, d3 = (d3 + 1) * c3, d4 = (d4 + 1) * c4; cout &lt;&lt; g(s) - g(s - d1) - g(s - d2) - g(s - d3) - g(s - d4) + g(s - d1 - d2) + g(s - d1 - d3) + g(s - d1 - d4) + g(s - d2 - d3) + g(s - d2 - d4) + g(s - d3 - d4) - g(s - d1 - d2 - d3) - g(s - d1 - d3 - d4) - g(s - d1 - d2 - d4) - g(s - d2 - d3 - d4) + g(s - d1 - d2 - d3 - d4) &lt;&lt; '\\n'; &#125; return 0; &#125; [ZJOI2010] æ’åˆ—è®¡æ•° Portal.ç§°ä¸€ä¸ª 1âˆ¼n1 \\sim n1âˆ¼n çš„æ’åˆ— p1,p2,â€¦,pnp_1,p_2, \\dots ,p_np1â€‹,p2â€‹,â€¦,pnâ€‹ æ˜¯ Magic çš„ï¼Œå½“ä¸”ä»…å½“ï¼šâˆ€iâˆˆ[2,n],pi&gt;pâŒŠi/2âŒ‹\\forall i \\in [2,n],p_i &gt; p_{\\lfloor i/2 \\rfloor}âˆ€iâˆˆ[2,n],piâ€‹&gt;pâŒŠi/2âŒ‹â€‹è®¡ç®— 1âˆ¼n1 \\sim n1âˆ¼n çš„æ’åˆ—ä¸­æœ‰å¤šå°‘æ˜¯ Magic çš„ï¼Œç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œåªèƒ½è¾“å‡ºæ¨¡ mmm ä»¥åçš„å€¼ã€‚1â‰¤nâ‰¤1061\\le n \\le 10^61â‰¤nâ‰¤106, 1â‰¤mâ‰¤1091\\le m \\le 10^91â‰¤mâ‰¤109ï¼Œmmm æ˜¯ä¸€ä¸ªè´¨æ•°ã€‚ å‘ç°è¿™ä¸ªåºåˆ—æè¿°çš„å°±æ˜¯ä¸€ä¸ªå°æ ¹å †ã€‚è®¾ f(i)f(i)f(i) ä¸º iii ä¸ªæ•°ç»„æˆçš„æ»¡è¶³æ’åˆ—çš„ä¸ªæ•°ã€‚æˆ‘ä»¬å…ˆè®¡ç®—å‡ºè¿™ä¸ªå †çš„æ ¹èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ä¸ªæ•°å’Œå³å­èŠ‚ç‚¹ä¸ªæ•°ï¼Œé‚£ä¹ˆå½“å‰æ–¹æ¡ˆæ•°å°±æ˜¯å·¦å­æ ‘æ–¹æ¡ˆæ•°å’Œå³å­æ ‘æ–¹æ¡ˆæ•°ã€‚å·¦å­æ ‘å¯ä»¥åœ¨ iâˆ’1i-1iâˆ’1 ä¸­é€‰æ‹© lll ä¸ªï¼Œé‚£ä¹ˆå³å­æ ‘èƒ½é€‰çš„æ•°ä¹Ÿå°±ç¡®å®šï¼Œæ–¹æ¡ˆæ•°å°±æ˜¯ f(l)Ã—(iâˆ’1l)Ã—f(r)f(l)\\times \\binom{i-1}{l} \\times f(r)f(l)Ã—(liâˆ’1â€‹)Ã—f(r) äº†ã€‚æ³¨æ„ä½¿ç”¨ Lucas å®šç†è®¡ç®—ï¼ˆnnn å¯èƒ½å¤§äºæ¨¡æ•°ï¼Œé€†å…ƒè®¡ç®—ä¸æˆç«‹ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, p; int f[1000005], lg[1000005], fac[1000005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % p) if (b &amp; 1) res = 1ll * res * a % p; return res; &#125; int C(int n, int m) &#123; return 1ll * fac[n] * poww(fac[m], p - 2) % p * poww(fac[n - m], p - 2) % p; &#125; int Lucas(int n, int m) &#123; if (m == n || m == 0) return 1; return 1ll * Lucas(n / p, m / p) * C(n % p, m % p) % p; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); f[0] = f[1] = 1; for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % p; int l = 0, r = 0; for (int i = 2; i &lt;= n; ++i) &#123; int dep = lg[i] + 1; if (i &lt; ((1 &lt;&lt; dep) - (1 &lt;&lt; (dep - 2)))) ++l; else ++r; f[i] = 1ll * f[l] * Lucas(i - 1, l) % p * f[r] % p; &#125; printf(\"%d\\n\", f[n]); return 0; &#125; ã€JROI-4ã€æ²ˆé˜³å¤§è¡— 2 Portal. ç›¸å½“äºæ˜¯å¯ä»¥éšä¾¿æ’ï¼Œé‚£ä¹ˆå°† A,BA,BA,B åˆå¹¶ä¸º CCCï¼Œå°†å…¶ä»å¤§åˆ°å°æ’åºåå¯å¾—è´¡çŒ®æ˜¯æœ€åä¸€ä¸ªæ•°ã€‚è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨è€ƒè™‘åˆ° CiC_iCiâ€‹ é€‰äº† jjj å¯¹ï¼Œç„¶åè½¬ç§»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int n, f[10005][5005], cnt[2][10005]; pair&lt;int, bool> a[10005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i].first); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i + n].first), a[i + n].second = 1; sort(a + 1, a + n * 2 + 1, greater&lt;pair&lt;int, bool>>()); f[0][0] = 1; for (int i = 1; i &lt;= n * 2; ++i) &#123; cnt[0][i] = cnt[0][i - 1], cnt[1][i] = cnt[1][i - 1]; f[i][0] = 1; ++cnt[a[i].second][i]; int t = cnt[!a[i].second][i]; for (int j = 1; j &lt;= (i >> 1); ++j) &#123; if (t - j + 1 >= 0) f[i][j] = 1ll * f[i - 1][j - 1] * a[i].first % MOD * (t - j + 1) % MOD; f[i][j] = (f[i][j] + f[i - 1][j]) % MOD; &#125; &#125; int res = 1; for (int i = 1; i &lt;= n; ++i) res = 1ll * res * i % MOD; printf(\"%d\\n\", 1ll * poww(res, MOD - 2) * f[n * 2][n] % MOD); return 0; &#125; ç»å…¸æ¨¡å‹ è¿™äº›é—®é¢˜ä¸ç»å…¸æ¨¡å‹å…³ç³»å¾ˆå¤§ï¼ [SDOI2016] æ’åˆ—è®¡æ•° Portal. é™¤æ‰è¿™ mmm ä¸ªæ•°å°±æ˜¯é”™æ’é—®é¢˜ï¼Œè€Œé€‰æ‹© mmm ä¸ªæ•°å…±æœ‰ (nm)\\dbinom{n}{m}(mnâ€‹) ç§æ–¹æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; const int N = 1000000; int n, m; int fac[1000005], f[1000005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int C(int n, int m) &#123; return 1ll * fac[n] * poww(1ll * fac[m] * fac[n - m] % MOD, MOD - 2) % MOD; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); fac[0] = 1; f[2] = 1; f[0] = 1; for (int i = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; for (int i = 3; i &lt;= N; ++i) f[i] = 1ll * (i - 1) * (f[i - 1] + f[i - 2]) % MOD; while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", 1ll * C(n, m) * f[n - m] % MOD); &#125; return 0; &#125; [CF785D] Anton and School - 2 Portal. ç›´æ¥æš´åŠ›è®¡æ•°ï¼Œç„¶åä½¿ç”¨èŒƒå¾·è’™å¾·å·ç§¯åŒ–ç®€ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 1000000007; int n, a[200005], b[200005]; i64 fac[200005] = &#123;1&#125;; char s[200005]; i64 poww(i64 a, int b) &#123; i64 res = 1; a %= MOD; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) a[i] = a[i - 1] + (s[i] == '('); for (int i = n; i >= 1; --i) b[i] = b[i + 1] + (s[i] == ')'); for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % MOD; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) if (s[i] == '(') &#123; int x = a[i], y = b[i]; ans = (ans + fac[x + y - 1] * poww(fac[y - 1] * fac[x], MOD - 2)) % MOD; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [Cnoi2020] å››è§’é“¾ Portal. è®¾ f(n,k)f(n,k)f(n,k) ä¸ºç­”æ¡ˆï¼Œé‚£ä¹ˆ f(n,k)=f(nâˆ’1,k)+(nâˆ’k+1)Ã—f(nâˆ’1,kâˆ’1)f(n,k)=f(n-1,k)+(n-k+1)\\times f(n-1,k-1)f(n,k)=f(nâˆ’1,k)+(nâˆ’k+1)Ã—f(nâˆ’1,kâˆ’1)ã€‚è¯•å‡ ä¸ªæ•°å‘ç° f(n,k)=S(n,nâˆ’k)f(n,k)=S(n,n-k)f(n,k)=S(n,nâˆ’k)ï¼Œå› æ­¤ä½¿ç”¨ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°æ±‚è§£å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; int n, m, k; int fac[1000005]; int f[5005][5005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); m = n - k; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; int ans = 0; for (int i = 0; i &lt;= m; ++i) &#123; int tmp = 1ll * poww(i, n) * poww(fac[i], MOD - 2) % MOD * poww(fac[m - i], MOD - 2) % MOD; ans = (ans + tmp * ((m - i) % 2 == 0 ? 1 : -1)) % MOD; &#125; printf(\"%d\\n\", (ans + MOD) % MOD); return 0; &#125; [NOI2021] é‡å­é€šä¿¡ Portal. kâ‰¤15k\\le 15kâ‰¤15 æ˜¯å…³é”®çªç ´ç‚¹ï¼Œæˆ‘ä»¬æŠŠæ¯ 161616 ä½å‹æˆä¸€ä½ï¼Œå¿…ç„¶æœ‰ä¸€ä¸ªæ•°æ˜¯ä¸åŒçš„ï¼ˆé¸½å·¢åŸç†ï¼‰ã€‚å°†ç›¸åŒçš„å‹æˆä¸€ä½çš„å•è¯å­˜åœ¨ä¸€ä¸ª vector é‡Œï¼Œæš´åŠ›åˆ¤æ–­å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long ull; bool s[400005][256]; inline ull myRand(ull &amp;k1, ull &amp;k2) &#123; ull k3 = k1, k4 = k2; k1 = k4; k3 ^= (k3 &lt;&lt; 23); k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26); return k2 + k4; &#125; void gen(int n, ull a1, ull a2) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; 256; j++) s[i][j] = (myRand(a1, a2) &amp; (1ull &lt;&lt; 32)) ? 1 : 0; &#125; int n, m, val[400005][16], aa[16]; vector&lt;int> buc[16][65536]; ull a1, a2; bool a[256]; int main(void) &#123; cin >> n >> m >> a1 >> a2; gen(n, a1, a2); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; 16; ++j) &#123; for (int k = 0; k &lt; 16; ++k) val[i][j] += (s[i][j * 16 + k] &lt;&lt; k); buc[j][val[i][j]].emplace_back(i); &#125; &#125; bool last = 0; int k; while (m--) &#123; for (int i = 0; i &lt; 64; ++i) &#123; char c = getchar(); int v; if (isdigit(c)) v = c - '0'; else if (c >= 'A' &amp;&amp; c &lt;= 'F') v = 10 + c - 'A'; else &#123; --i; continue; &#125; for (int j = 0; j &lt; 4; ++j) a[i * 4 + j] = (((v >> (3 - j)) &amp; 1) ^ last); &#125; bool flag = 0; scanf(\"%d\", &amp;k); memset(aa, 0, sizeof(aa)); // aa å­˜å‚¨å½“å‰å­—ç¬¦ä¸²è¢«å‹ç¼©åçš„ç»“æœ for (int i = 0; i &lt; 16; ++i) for (int j = 0; j &lt; 16; ++j) aa[i] += (a[i * 16 + j] &lt;&lt; j); for (int i = 0; i &lt; 16 &amp;&amp; !flag; ++i) &#123; for (auto x : buc[i][aa[i]]) &#123; int it = x, cnt = 0; for (int j = 0; j &lt; 16 &amp;&amp; cnt &lt;= k; ++j) cnt += __builtin_popcount(val[it][j] ^ aa[j]); if (cnt &lt;= k) &#123; flag = true; break; &#125; &#125; &#125; printf(\"%d\\n\", (last = flag)); &#125; return 0; &#125; [JSOI2015] æŸ“è‰²é—®é¢˜ Portal. è®¾ f(i)f(i)f(i) ä»£è¡¨æœ€å¤šä½¿ç”¨ iii ç§é¢œè‰²å®Œæˆç›®æ ‡çš„æ–¹æ¡ˆæ•°ã€‚è€ƒè™‘ SiS_iSiâ€‹ ä»£è¡¨æœ‰ç¬¬ iii ç§é¢œè‰²çš„æ–¹æ¡ˆé›†åˆã€‚â€œæ¯ä¸ªé¢œè‰²éƒ½è‡³å°‘å‡ºç°ä¸€æ¬¡â€ä¸º âˆ£â‹‚i=1nSiâˆ£\\displaystyle\\left|\\bigcap_{i=1}^{n}S_i\\right|â€‹i=1â‹‚nâ€‹Siâ€‹â€‹ï¼Œå¯ä»¥å†™ä¸ºï¼š âˆ£Uâˆ£âˆ’âˆ£â‹ƒi=1nSiâ€¾âˆ£=âˆ£Uâˆ£âˆ’âˆ‘m=1n(âˆ’1)mâˆ’1âˆ‘ai&lt;ai+1âˆ£â‹‚i=1mSaiâ€¾âˆ£\\begin{aligned} &amp;\\left|U\\right|-\\left|\\bigcup_{i=1}^{n}\\overline{S_i}\\right|\\\\ =&amp;\\left|U\\right| - \\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i&lt;a_{i+1} }\\left|\\bigcap_{i=1}^m\\overline{S_{a_i}}\\right| \\end{aligned} =â€‹âˆ£Uâˆ£âˆ’â€‹i=1â‹ƒnâ€‹Siâ€‹â€‹â€‹âˆ£Uâˆ£âˆ’m=1âˆ‘nâ€‹(âˆ’1)mâˆ’1aiâ€‹&lt;ai+1â€‹âˆ‘â€‹â€‹i=1â‹‚mâ€‹Saiâ€‹â€‹â€‹â€‹â€‹ åé¢è¿™ä¸ª âˆ£â‹‚i=1mSaiâ€¾âˆ£\\displaystyle\\left|\\bigcap_{i=1}^m\\overline{S_{a_i}}\\right|â€‹i=1â‹‚mâ€‹Saiâ€‹â€‹â€‹â€‹ æ˜¯è¯´è‡³å°‘ä¸é€‰ mmm ç§é¢œè‰²ï¼Œæœ‰ (cm)\\dbinom{c}{m}(mcâ€‹) ç§é€‰æ‹©æ–¹å¼ï¼Œå•ä¸ªé€‰æ‹©æ–¹å¼æœ‰ f[câˆ’m]f[c-m]f[câˆ’m] ç§åˆæ³•æ–¹æ¡ˆæ•°ã€‚å¯ä»¥ä½¿ç”¨å®¹æ–¥åŸç†è®¡ç®—ï¼Œé‚£ä¹ˆæœ€ç»ˆï¼š ans=f(c)âˆ’âˆ‘i=1c(âˆ’1)iâˆ’1(ci)Ã—f[câˆ’i]=âˆ‘i=0c(âˆ’1)i(ci)Ã—f[câˆ’i]\\begin{aligned} ans&amp;=f(c)-\\displaystyle\\sum\\limits_{i=1}^c(-1)^{i-1}\\binom{c}{i}\\times f[c-i]\\\\ &amp;=\\displaystyle\\sum\\limits_{i=0}^c(-1)^{i}\\binom{c}{i}\\times f[c-i] \\end{aligned} ansâ€‹=f(c)âˆ’i=1âˆ‘câ€‹(âˆ’1)iâˆ’1(icâ€‹)Ã—f[câˆ’i]=i=0âˆ‘câ€‹(âˆ’1)i(icâ€‹)Ã—f[câˆ’i]â€‹ fff ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»ä¼¼çš„æ–¹å¼è®¡ç®—å‡ºæ¥ã€‚SiS_iSiâ€‹ ä»£è¡¨ç¬¬ iii åˆ—æœ‰é¢œè‰²çš„æ–¹æ¡ˆé›†åˆï¼Œç„¶åæ¨å¯¼å‡ºæ¥çš„ âˆ£â‹‚i=1kSaiâ€¾âˆ£\\displaystyle\\left|\\bigcap_{i=1}^k\\overline{S_{a_i}}\\right|â€‹i=1â‹‚kâ€‹Saiâ€‹â€‹â€‹â€‹ å°±æ˜¯ a1â‹¯aka_1\\cdots a_ka1â€‹â‹¯akâ€‹ è¿™ kkk åˆ—æ²¡æœ‰é¢œè‰²ï¼Œé‚£ä¹ˆï¼š fi=âˆ‘k=0m(âˆ’1)k(mk)((i+1)mâˆ’kâˆ’1)nf_i=\\sum_{k=0}^{m}(-1)^{k}\\binom{m}{k}((i+1)^{m-k}-1)^n fiâ€‹=k=0âˆ‘mâ€‹(âˆ’1)k(kmâ€‹)((i+1)mâˆ’kâˆ’1)n æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 1000000007; i64 poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; void add(i64 &amp;a, int t) &#123; a = ((a + t) % MOD + MOD) % MOD; &#125; int n, m, c; int C[405][405]; i64 f[405]; int main(void) &#123; for (int i = 0; i &lt;= 400; ++i) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD; &#125; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c); for (int i = 1; i &lt;= c; ++i) for (int k = 0; k &lt;= m; ++k) add(f[i], (k &amp; 1 ? -1 : 1) * C[m][k] * poww(poww(i + 1, m - k) - 1, n) % MOD); i64 ans = 0; for (int i = 0; i &lt;= c; ++i) add(ans, (i &amp; 1 ? -1 : 1) * C[c][i] * f[c - i] % MOD); printf(\"%lld\\n\", ans); return 0; &#125; æ•°å­¦æ¨å¯¼ æ¨å¼å­ï¼ˆæŸ¿å­ï¼‰æ˜¯ä¸€ä»¶æœ‰è¶£çš„äº‹æƒ…ï¼ [CF1545B] AquaMoon and Chess Portal. åªæœ‰ 000 å’Œ 111111 æ˜¯æœ‰ç”¨çš„ï¼Œç­”æ¡ˆæ˜¯ (a+ba)\\dbinom{a+b}{a}(aa+bâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; int n; char a[100005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int C(int n, int m) &#123; int res = 1; for (int i = 1; i &lt;= m; ++i) res = 1ll * res * (n - i + 1) % MOD * poww(i, MOD - 2) % MOD; return res; &#125; void solve(void) &#123; cin >> n >> a; int x = 0, y = 0; for (int i = 0; i &lt; n; ++i) if (i &lt; n - 1 &amp;&amp; a[i] == '1' &amp;&amp; a[i + 1] == '1') ++x, ++i; else if (a[i] == '0') ++y; cout &lt;&lt; C(x + y, y) &lt;&lt; '\\n'; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; [SCOI2010] ç”Ÿæˆå­—ç¬¦ä¸² Portal. æŠŠ nnn ä¸ª 111 å’Œ mmm ä¸ª 000 ç»„æˆå­—ç¬¦ä¸²ï¼Œåœ¨ä»»æ„çš„å‰ kkk ä¸ªå­—ç¬¦ä¸­ï¼Œ111 çš„ä¸ªæ•°ä¸èƒ½å°‘äº 000 çš„ä¸ªæ•°ã€‚æ»¡è¶³è¦æ±‚çš„å­—ç¬¦ä¸²å…±æœ‰å¤šå°‘ä¸ªï¼Ÿ è€ƒè™‘å…¶å‡ ä½•æ„ä¹‰ï¼šé€‰ 1 ä»£è¡¨å‘å³ä¸Šèµ°ï¼Œé€‰ 0 ä»£è¡¨å‘å³ä¸‹èµ°ï¼Œè¦èµ°åˆ° (n+m,nâˆ’m)(n+m,n-m)(n+m,nâˆ’m)ï¼Œè€Œä¸”éœ€è¦æ»¡è¶³ä»»æ„æ—¶åˆ»çš„çºµåæ ‡æ˜¯éè´Ÿçš„ã€‚ æ€ä¹ˆåŠå‘¢ï¼Ÿåˆ©ç”¨è¡¥é›†æ€æƒ³ï¼Œæ€»å…±æœ‰ (n+mm)\\dbinom{n+m}{m}(mn+mâ€‹) ç§èµ°æ³•ï¼ˆç½‘æ ¼å›¾è·¯å¾„è®¡æ•°ï¼‰ï¼Œèƒ½å¤Ÿèµ°åˆ° y=âˆ’1y=-1y=âˆ’1ï¼Œç›¸å½“äºä» (0,âˆ’2)(0,-2)(0,âˆ’2) å¼€å§‹èµ°ï¼Œnâ€²=n+1,mâ€²=mâˆ’1n&#x27;=n+1,m&#x27;=m-1nâ€²=n+1,mâ€²=mâˆ’1ï¼Œèµ°åˆ° (n+m,nâˆ’m)(n+m,n-m)(n+m,nâˆ’m)ï¼Œæ–¹æ¡ˆæ•°ä¸º (n+1+mâˆ’1mâˆ’1)\\dbinom{n+1+m-1}{m-1}(mâˆ’1n+1+mâˆ’1â€‹)ï¼Œå› æ­¤ç­”æ¡ˆä¸º (n+mm)âˆ’(n+mmâˆ’1)\\dbinom{n+m}{m}-\\dbinom{n+m}{m-1}(mn+mâ€‹)âˆ’(mâˆ’1n+mâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 20100403; int fac[2000005]; int poww(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % MOD; a = 1ll * a * a % MOD; b >>= 1; &#125; return res; &#125; int inv(int a) &#123; return poww(a, MOD - 2); &#125; int C(int n, int m) &#123; return 1ll * fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD; &#125; int main(void) &#123; fac[0] = 1; for (int i = 1; i &lt;= 2000000; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", (C(n + m, m) - C(n + m, m - 1) + MOD) % MOD); return 0; &#125; [GXOI/GZOI2019] é€¼æ­»å¼ºè¿«ç—‡ Portal. è®¾ f(i)f(i)f(i) è¡¨ç¤º 2Ã—i2\\times i2Ã—i çš„ç­”æ¡ˆï¼Œé‚£ä¹ˆ f(i)=f(iâˆ’1)+f(iâˆ’2)+2âˆ‘j=0iâˆ’3F(j)f(i)=f(i-1)+f(i-2)+2\\sum_{j=0}^{i-3}F(j)f(i)=f(iâˆ’1)+f(iâˆ’2)+2âˆ‘j=0iâˆ’3â€‹F(j)ã€‚ä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚è®¡ç®—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; struct Matrix &#123; int a[5][5]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 5; ++i) for (int k = 0; k &lt; 5; ++k) &#123; int r = a.a[i][k]; for (int j = 0; j &lt; 5; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b.a[k][j]) % MOD; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; for (int i = 0; i &lt; 5; ++i) res.a[i][i] = 1; for (; b; b >>= 1, a = a * a) if (b &amp; 1) res = res * a; return res; &#125; int main(void) &#123; int T, n; scanf(\"%d\", &amp;T); Matrix f, a; a.a[2][0] = a.a[3][0] = a.a[4][0] = 1; f.a[0][0] = f.a[0][1] = f.a[1][0] = f.a[2][2] = f.a[2][3] = f.a[3][3] = f.a[3][4] = f.a[4][3] = 1; f.a[0][2] = 2; Matrix t = f * a; while (T--) &#123; scanf(\"%d\", &amp;n); if (n &lt;= 2) &#123; puts(\"0\"); continue; &#125; printf(\"%d\\n\", (poww(f, n - 2) * a).a[0][0]); &#125; return 0; &#125; ã€ŒKDOI-02ã€ä¸€ä¸ªä»‡çš„å¤ Portal.ä½ æœ‰ 1Ã—x1\\times x1Ã—xï¼ˆxxx ä¸ºä»»æ„æ­£æ•´æ•°ï¼‰çš„çŸ©å½¢å„æ— ç©·å¤šä¸ªå’Œä¸€ä¸ª 2Ã—n2\\times n2Ã—n çš„ç½‘æ ¼ï¼Œè¯·æ±‚å‡ºæ°å¥½é€‰æ‹©å…¶ä¸­ kkk ä¸ªçŸ©å½¢ï¼ˆå¯ä»¥é€‰æ‹©ç›¸åŒçš„çŸ©å½¢ï¼‰ä¸é‡ä¸æ¼åœ°é“ºæ»¡æ•´ä¸ªç½‘æ ¼çš„æ–¹æ¡ˆæ•°ã€‚çŸ©å½¢å¯ä»¥æ—‹è½¬ã€‚ç­”æ¡ˆå¯¹ 998244353998244353998244353 å–æ¨¡ï¼Œnâ‰¤2Ã—107,kâ‰¤5000n\\le 2\\times 10^7,k\\le 5000nâ‰¤2Ã—107,kâ‰¤5000ã€‚ å…ˆè§£å†³ä¸€ä¸ªç®€å•é—®é¢˜ï¼Œåªå…è®¸æ¨ªç€æ”¾ï¼Ÿæ’æ¿ï¼Œæšä¸¾ç¬¬ 111 è¡Œç”¨ iii ä¸ªï¼Œé‚£ä¹ˆæ€»æ–¹æ¡ˆæ•°ä¸º âˆ‘i=1aâˆ’1(bâˆ’1iâˆ’1)(bâˆ’1aâˆ’iâˆ’1)=âˆ‘i=0aâˆ’2(bâˆ’1i)(bâˆ’1aâˆ’2âˆ’i)\\displaystyle \\sum_{i=1}^{a-1}\\binom{b-1}{i-1}\\binom{b-1}{a-i-1}=\\sum_{i=0}^{a-2}\\binom{b-1}{i}\\binom{b-1}{a-2-i}i=1âˆ‘aâˆ’1â€‹(iâˆ’1bâˆ’1â€‹)(aâˆ’iâˆ’1bâˆ’1â€‹)=i=0âˆ‘aâˆ’2â€‹(ibâˆ’1â€‹)(aâˆ’2âˆ’ibâˆ’1â€‹)ï¼Œç”¨èŒƒå¾·è’™å¾·å·ç§¯åˆå¹¶å¯å¾—ç­”æ¡ˆæ˜¯ (2bâˆ’2aâˆ’2)\\dbinom{2b-2}{a-2}(aâˆ’22bâˆ’2â€‹)ã€‚ ç”±äºå®½åº¦ä¸º 222ï¼Œç«–ç€çš„é•¿æ–¹å½¢ä»…èƒ½æœ‰ 1Ã—21\\times 21Ã—2ã€‚è€ƒè™‘å…ˆç”¨ jjj ä¸ª 1Ã—21\\times 21Ã—2 çš„ç«–ç€çš„é•¿æ–¹å½¢ï¼Œç„¶ååˆ†å‰²æˆäº† 2Ã—al2\\times a_l2Ã—alâ€‹ çš„å°é•¿æ–¹å½¢ï¼Œç‹¬ç«‹ç»Ÿè®¡å³å¯ã€‚ è®¾è¦åˆ†æˆ iii æ®µï¼Œä½¿ç”¨ jjj ä¸ªç«–ç€çš„ï¼Œé‚£ä¹ˆåˆ†æ®µæ–¹å¼æ’æ¿è®¡ç®—æœ‰ (j+1i)\\dbinom{j+1}{i}(ij+1â€‹) ç§ï¼ˆåªæœ‰ä¸¤å¤´å…è®¸æ”¾ç©ºï¼Œå¢åŠ  111 ä¸ªæ¿ï¼‰ï¼Œç„¶åè¦å°†å‰©ä½™çš„ nâˆ’jn-jnâˆ’j ä¸ªä½ç½®åˆ†ç»™ iii æ®µï¼Œæ’æ¿æœ‰ (nâˆ’jâˆ’1iâˆ’1)\\dbinom{n-j-1}{i-1}(iâˆ’1nâˆ’jâˆ’1â€‹) ç§æ–¹æ¡ˆã€‚ ç„¶åå°±æ˜¯æŠŠ kâˆ’jk-jkâˆ’j ä¸ªæ¨ªç€çš„æ”¾åˆ°æ¯æ®µé•¿åº¦ä¸º ala_lalâ€‹ çš„æ¯æ®µä¸­ï¼Œæ–¹æ¡ˆæ•°ï¼š âˆ‘âˆ‘l=1ibl = kâˆ’jâˆl=1i(2alâˆ’2blâˆ’2)\\sum_{\\sum\\limits_{l=1}^i b_l\\ =\\ k-j}\\prod_{l=1}^{i}\\binom{2a_l-2}{b_l-2} l=1âˆ‘iâ€‹blâ€‹ = kâˆ’jâˆ‘â€‹l=1âˆiâ€‹(blâ€‹âˆ’22alâ€‹âˆ’2â€‹) è¿™æ˜¯ä¸ªä»€ä¹ˆï¼Ÿæƒ³ä¸€æƒ³èŒƒå¾·è’™å¾·å·ç§¯çš„ç»„åˆæ„ä¹‰ï¼Œå°±ä¼šå‘ç°è·Ÿé‚£ä¸ªæ˜¯ä¸€æ ·çš„ï¼šæšä¸¾æ¯ä¸ªå­é›†é€‰çš„ä¸ªæ•°ï¼Œé€‰çš„æ€»æ•°æ˜¯ kâˆ’jâˆ’2ik-j-2ikâˆ’jâˆ’2iã€‚äºæ˜¯æˆ‘ä»¬å°†å®ƒåˆèµ·æ¥ï¼ˆå°±æ˜¯åŸæœ¬äºŒé¡¹å¼ç³»æ•°ä¸Šé¢çš„å’Œä¸‹é¢çš„å’Œå½¢æˆæ–°çš„äºŒé¡¹å¼ç³»æ•°ï¼‰ï¼Œå°±æˆäº†ï¼š(âˆ‘2alâˆ’2âˆ‘blâˆ’2)=(2(nâˆ’j)âˆ’2ikâˆ’jâˆ’2i)\\dbinom{\\sum 2a_l-2}{\\sum b_l-2}=\\dbinom{2(n-j)-2i}{k-j-2i}(âˆ‘blâ€‹âˆ’2âˆ‘2alâ€‹âˆ’2â€‹)=(kâˆ’jâˆ’2i2(nâˆ’j)âˆ’2iâ€‹)ã€‚ æ³¨æ„ä¸€ä¸‹éœ€è¦ç‰¹åˆ¤ k=nk=nk=n çš„æ—¶å€™ï¼Œå¯ä»¥æ”¾ kkk ä¸ªç«–ç€çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; inline int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int n, k; int fac[40000005]; int C(int n, int m) &#123; return 1ll * fac[n] * poww(1ll * fac[m] * fac[n - m] % MOD, MOD - 2) % MOD; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); fac[0] = 1; for (int i = 1; i &lt;= n * 2; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; int ans = 0; for (int i = 1; i &lt;= k; ++i) &#123; int R = min(&#123;k - 2 * i, n - i, 2 * n - k&#125;); for (int j = i - 1; j &lt;= R; ++j) &#123; int a = C(2 * (n - j) - 2 * i, k - j - 2 * i); int b = C(j + 1, i), c = C(n - j - 1, i - 1); ans = (ans + 1ll * a * b % MOD * c % MOD) % MOD; &#125; &#125; printf(\"%lld\\n\", ans + (k == n)); return 0; &#125; [FJOI2017] çŸ©é˜µå¡«æ•° Portal.ç»™å®šä¸€ä¸ª hÃ—wh \\times whÃ—w çš„çŸ©é˜µï¼Œåœ¨è¿™ä¸ªçŸ©é˜µä¸­ä½ éœ€è¦åœ¨æ¯ä¸ªæ ¼å­ä¸­å¡«å…¥ 1âˆ¼m1 \\sim m1âˆ¼m ä¸­çš„æŸä¸ªæ•°ã€‚ç»™è¿™ä¸ªçŸ©é˜µå¡«æ•°çš„æ—¶å€™æœ‰ä¸€äº›é™åˆ¶ï¼Œç»™å®š nnn ä¸ªè¯¥çŸ©é˜µçš„å­çŸ©é˜µï¼Œä»¥åŠè¯¥å­çŸ©é˜µçš„æœ€å¤§å€¼ vvvï¼Œè¦æ±‚ä½ æ‰€å¡«çš„æ–¹æ¡ˆæ»¡è¶³è¯¥å­çŸ©é˜µçš„æœ€å¤§å€¼ä¸º vvvã€‚ç°åœ¨ï¼Œä½ çš„ä»»åŠ¡æ˜¯æ±‚å‡ºæœ‰å¤šå°‘ç§å¡«æ•°çš„æ–¹æ¡ˆæ»¡è¶³ nnn ä¸ªé™åˆ¶ã€‚è¾“å‡ºç­”æ¡ˆå¯¹ 109+710^9+7109+7 å–æ¨¡åçš„ç»“æœã€‚å¯¹äº 100%100\\%100% çš„æ•°æ®ï¼ŒTâ‰¤5T \\le 5Tâ‰¤5ï¼Œ1â‰¤h,w,mâ‰¤1041 \\le h, w, m \\le 10 ^ 41â‰¤h,w,mâ‰¤104ï¼Œ1â‰¤nâ‰¤101 \\le n \\le 101â‰¤nâ‰¤10ï¼Œ1â‰¤vâ‰¤m1 \\le v \\le m1â‰¤vâ‰¤mã€‚ æ²¡æœ‰çŸ©å½¢é™åˆ¶çš„åœ°æ–¹æ˜¯å¯ä»¥ä»»æ„å¡«çš„ã€‚ å°†é™åˆ¶æ¡ä»¶æŒ‰ç…§ vvv ä»å°åˆ°å¤§æ’åºï¼Œç„¶åå¤§å°ç›¸åŒçš„ç»Ÿä¸€å¤„ç†ï¼ˆå…ˆè€ƒè™‘é™åˆ¶æ›´ä¸¥çš„ï¼Œé™åˆ¶æ›´æ¾çš„è‡ªç„¶æ»¡è¶³ï¼‰ã€‚å¯¹äºä¸€ä¸ª vvvï¼Œä½¿ç”¨ä¸€ä¸ªå¥—è·¯ï¼šæœ€å¤§å€¼ç­‰äº vvv å¯ä»¥è½¬åŒ–ä¸ºæœ€å¤§å€¼ä¸è¶…è¿‡ vvv å’Œæœ€å¤§å€¼ä¸è¶…è¿‡ vâˆ’1v-1vâˆ’1ã€‚è¿™æ ·å°±å¯ä»¥å¾ˆæ–¹ä¾¿çš„ä½¿ç”¨å®¹æ–¥åŸç†è®¡ç®—äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 1000000007; const int N = 10; i64 poww(i64 a, int b) &#123; int res = 1; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int h, w, m, n; int bitcount[1030]; int s[1030], u[1030]; // äº¤é›†ï¼Œå¹¶é›† struct rec &#123; int x1, y1, x2, y2, v; rec(int x1 = 0, int y1 = 0, int x2 = 0, int y2 = 0) : x1(x1), y1(y1), x2(x2), y2(y2) &#123;&#125; void rd(void) &#123; scanf(\"%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;v); &#125; bool empty(void) &#123; return x1 > x2 || y1 > y2; &#125; int square(void) &#123; return (x2 - x1 + 1) * (y2 - y1 + 1); &#125; void operator&amp;= (const rec &amp;a) &#123; x1 = max(x1, a.x1), y1 = max(y1, a.y1); x2 = min(x2, a.x2), y2 = min(y2, a.y2); &#125; bool operator&lt; (const rec &amp;a) const &#123; return v &lt; a.v; &#125; &#125; a[15]; int main(void) &#123; for (int s = 0; s &lt; 1 &lt;&lt; N; ++s) bitcount[s] = bitcount[s >> 1] + (s &amp; 1); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d%d\", &amp;h, &amp;w, &amp;m, &amp;n); int xtot = 0, ytot = 0; for (int i = 0; i &lt; n; ++i) a[i].rd(); sort(a, a + n); for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) &#123; rec tmp(1, 1, h, w); s[i] = -1; for (int p = i, j = 0; p; p >>= 1, ++j) if (p &amp; 1) &#123; tmp &amp;= a[j]; if (tmp.empty()) &#123; s[i] = 0; break; &#125; &#125; if (s[i] == -1) s[i] = tmp.square(); &#125; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) &#123; u[i] = 0; for (int j = i; j; j = j - 1 &amp; i) if (bitcount[j] % 2) u[i] += s[j]; else u[i] -= s[j]; &#125; int ns = 0, ls = 0; i64 res = 1; for (int i = 0; i &lt; n; ++i) &#123; ns |= (1 &lt;&lt; i); if (a[i].v == a[i + 1].v) continue; int tot = u[ns | ls] - u[ls], st = tot; i64 ret = poww(a[i].v, tot); // æœ€å¤§å€¼ä¸è¶…è¿‡ v for (int j = ns; j; j = j - 1 &amp; ns) &#123; tot = u[j | ls] - u[ls]; i64 del = poww(a[i].v - 1, tot) * poww(a[i].v, st - tot) % MOD; // æšä¸¾çš„å­é›†ä¸­çš„è¿™äº›æœ€å¤§å€¼ä¸è¶…è¿‡ v-1ï¼Œå‰©ä¸‹çš„éšä¾¿ if (bitcount[j] % 2) ret = (ret - del + MOD) % MOD; else ret = (ret + del) % MOD; &#125; res = res * ret % MOD; ls |= ns; ns = 0; &#125; printf(\"%lld\\n\", res * poww(m, h * w - u[(1 &lt;&lt; n) - 1]) % MOD); &#125; return 0; &#125; ç»„åˆç»¼åˆ è¿™é‡Œçš„é—®é¢˜ä¼šä¸æ•°è®ºã€DP ç­‰å†…å®¹ç»“åˆåœ¨ä¸€èµ·ï¼Œç»¼åˆæ€§ä¼šæ¯”è¾ƒå¼ºã€‚ [SDOI2010] å¤ä»£çŒªæ–‡ Portal. ç¿»è¯‘æˆäººè¯ï¼Œå°±æ˜¯è¦æ±‚ï¼š gâˆ‘kâˆ£n(nk) mod 999911659g^{\\sum_{k\\mid n} \\binom{n}{k}} \\bmod 999911659 gâˆ‘kâˆ£nâ€‹(knâ€‹)mod999911659 ä½¿ç”¨è´¹é©¬å°å®šç†é™å¹‚å¯å¾—ï¼š gâˆ‘kâˆ£n(nk) mod 999911658 mod 999911659g^{\\sum_{k\\mid n} \\binom{n}{k} \\bmod 999911658} \\bmod 999911659 gâˆ‘kâˆ£nâ€‹(knâ€‹)mod999911658mod999911659 999911658=2Ã—3Ã—4679Ã—35617999911658=2\\times 3\\times 4679 \\times 35617999911658=2Ã—3Ã—4679Ã—35617ï¼Œè¿™æ ·å°çš„è´¨æ•°æ¨¡æ•°å·²ç»å¯ä»¥ä½¿ç”¨ Lucas å®šç†ï¼Œæ±‚å››éä¹‹åä½¿ç”¨ CRT åˆå¹¶å‡ºè§£å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 999911659; int fac[40005] = &#123;1&#125;; int poww(int a, int b, int p) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % p; a = 1ll * a * a % p; b >>= 1; &#125; return res % p; &#125; void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a % b, y, x); y -= a / b * x; &#125; int inv(int t, int p) &#123; int x, y; exgcd(t, p, x, y); return (x % p + p) % p; &#125; int C(int n, int m, int p) &#123; if (m > n) return 0; if (m == 0 || m == n) return 1; return 1ll * fac[n] * inv(fac[m], p) % p * inv(fac[n - m], p) % p; &#125; int Lucas(int n, int m, int p) &#123; if (m == 0 || m == n) return 1; return 1ll * Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p; &#125; int a[10], m[10] = &#123;0, 2, 3, 4679, 35617&#125;, M[10]; int CRT(void) &#123; int ans = 0, x; for (int i = 1; i &lt;= 4; ++i) &#123; M[i] = (MOD - 1) / m[i]; ans = (ans + 1ll * a[i] * M[i] % (MOD - 1) * inv(M[i], m[i])) % (MOD - 1); &#125; return (ans % (MOD - 1) + (MOD - 1)) % (MOD - 1); &#125; int n, g; int calc(void) &#123; for (int op = 1; op &lt;= 4; ++op) &#123; for (int i = 1; i &lt;= 40000; ++i) fac[i] = 1ll * fac[i - 1] * i % m[op]; for (int i = 1; i * i &lt;= n; ++i) if (n % i == 0) &#123; a[op] = (a[op] + Lucas(n, i, m[op])) % m[op]; if (i * i != n) a[op] = (a[op] + Lucas(n, n / i, m[op])) % m[op]; &#125; &#125; return CRT(); &#125; int main(void) &#123; cin >> n >> g; int t = calc(); if (g == MOD &amp;&amp; t == 0) puts(\"0\"); // æ³¨æ„è¿™é‡Œï¼Œå› ä¸ºè´¹é©¬å°å®šç†å–æ¨¡çš„åŸå› ï¼Œæ‰€ä»¥ t == 0 æ—¶å…¶å® t == k(MOD - 1)ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ 0 ä¸æ˜¯ 1ï¼Œæ‰©å±•æ¬§æ‹‰å®šç†é™å¹‚çš„æ—¶å€™ä¹Ÿæœ‰ç±»ä¼¼çš„é—®é¢˜ else cout &lt;&lt; poww(g, t, MOD) &lt;&lt; '\\n'; return 0; &#125; ç»„åˆæ•°å¥‡å¶æ€§å…¬å¼ | [CTSC2017] å‰å¤«ç‰¹ Portal.è¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„æ•°åˆ— a1,a2,â‹¯ ,ana_1, a_2, \\cdots , a_na1â€‹,a2â€‹,â‹¯,anâ€‹ é—®æœ‰å¤šå°‘ä¸ªé•¿åº¦å¤§äºç­‰äº 222 çš„ä¸ä¸Šå‡çš„å­åºåˆ—æ»¡è¶³ï¼šâˆi=2k(abiâˆ’1abi) mod 2=(ab1ab2)Ã—(ab2ab3)Ã—â‹¯(abkâˆ’1abk) mod 2&gt;0\\prod _{i=2}^{k} \\binom{a_{b_{i-1}}}{a_{b_i}} \\bmod 2 = \\binom{a_{b_1}}{a_{b_2}} \\times \\binom{a_{b_2}}{a_{b_3}} \\times \\cdots \\binom{a_{b_{k-1}}}{a_{b_k}} \\bmod 2 &gt; 0i=2âˆkâ€‹(abiâ€‹â€‹abiâˆ’1â€‹â€‹â€‹)mod2=(ab2â€‹â€‹ab1â€‹â€‹â€‹)Ã—(ab3â€‹â€‹ab2â€‹â€‹â€‹)Ã—â‹¯(abkâ€‹â€‹abkâˆ’1â€‹â€‹â€‹)mod2&gt;0è¾“å‡ºè¿™ä¸ªä¸ªæ•°å¯¹ 100000000710000000071000000007 å–æ¨¡çš„ç»“æœã€‚1â‰¤nâ‰¤2119851\\leq n\\leq 2119851â‰¤nâ‰¤211985ï¼Œ1â‰¤aiâ‰¤2333331\\leq a_i\\leq 2333331â‰¤aiâ€‹â‰¤233333ã€‚æ‰€æœ‰çš„ aia_iaiâ€‹ äº’ä¸ç›¸åŒï¼Œä¹Ÿå°±æ˜¯è¯´ä¸å­˜åœ¨ i,ji, ji,j åŒæ—¶æ»¡è¶³ 1â‰¤i&lt;jâ‰¤n1\\leq i &lt; j\\leq n1â‰¤i&lt;jâ‰¤n å’Œ ai=aja_i = a_jaiâ€‹=ajâ€‹ã€‚ ç»“è®ºï¼š(nm)â‰¡1(mod2) âŸº n &amp; m=m\\binom{n}{m}\\equiv 1 \\pmod 2 \\iff n\\ \\&amp; \\ m=m(mnâ€‹)â‰¡1(mod2)âŸºn &amp; m=mã€‚ä½¿ç”¨ Lucas å®šç†æ¥è¯æ˜ï¼Œéœ€ä¿è¯ä¸å‡ºç° (01)\\binom{0}{1}(10â€‹)ã€‚è¿™å°±æ˜¯ç»„åˆæ•°å¥‡å¶æ€§å…¬å¼ã€‚ äºæ˜¯ç›´æ¥æ•´ä¸€ä¸ª DPï¼Œè®¾ f(i)f(i)f(i) ä»£è¡¨ä»¥ iii ç»“å°¾çš„å­åºåˆ—ä¸ªæ•°ï¼Œç„¶åé‡‡ç”¨åˆ·è¡¨è½¬ç§»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; int n, ans = 0; int f[233340]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, a; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;a); f[a] += 1; for (int S = a - 1 &amp; a; S; S = S - 1 &amp; a) f[S] = (f[S] + f[a]) % MOD; ans = (ans + f[a]) % MOD; &#125; printf(\"%d\\n\", ans - n); // å‡å»åªæœ‰ä¸€ä¸ªæ•°çš„ return 0; &#125; ã€ŒKDOI-03ã€æ„é€ æ•°ç»„ Portal.ä½ ç°åœ¨æœ‰ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„æ•°ç»„ aaaã€‚ä¸€å¼€å§‹ï¼Œæ‰€æœ‰ aia_iaiâ€‹ å‡ä¸º 000ã€‚ç»™å‡ºä¸€ä¸ªåŒæ ·é•¿åº¦ä¸º nnn çš„ç›®æ ‡æ•°ç»„ bbbã€‚æ±‚æœ‰å¤šå°‘ç§æ–¹æ¡ˆï¼Œä½¿å¾—é€šè¿‡è‹¥å¹²æ¬¡ä»¥ä¸‹æ“ä½œï¼Œå¯ä»¥è®© aaa æ•°ç»„å˜æˆ bbbã€‚é€‰å‡ºä¸¤ä¸ªä¸åŒçš„ä¸‹æ ‡ 1â‰¤i&lt;jâ‰¤n1\\leq i&lt;j\\leq n1â‰¤i&lt;jâ‰¤nï¼Œå¹¶å°† aia_iaiâ€‹ å’Œ aja_jajâ€‹ åŒæ—¶å¢åŠ  111ã€‚ä¸¤ç§æ–¹æ¡ˆè¢«ç§°ä¹‹ä¸ºä¸åŒçš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ä¸€ä¸ª xxx ä½¿å¾—ä¸€ç§æ–¹æ¡ˆä¸­ç¬¬ xxx æ¬¡æ“ä½œé€‰æ‹©çš„ä¸¤ä¸ªä¸‹æ ‡ (i,j)(i,j)(i,j) ä¸å¦ä¸€ç§æ–¹æ¡ˆä¸­çš„ä¸åŒã€‚ç­”æ¡ˆå¯¹ 998244353998244353998244353 å–æ¨¡ã€‚å¯¹äº 100%100\\%100% çš„æ•°æ®ï¼Œ1â‰¤nâ‰¤5 0001\\le n\\le5~0001â‰¤nâ‰¤5 000ï¼Œ1â‰¤biâ‰¤30 0001\\leq b_i\\le30~0001â‰¤biâ€‹â‰¤30 000ï¼Œâˆ‘biâ‰¤30 000\\sum b_i\\le30~000âˆ‘biâ€‹â‰¤30 000ã€‚ æ•´ä¸€ä¸ª DPã€‚è®¾ f(i,m2)f(i, m2)f(i,m2) ä»£è¡¨è€ƒè™‘åˆ°ç¬¬ iii ä¸ªæ•°ï¼Œå¡«å¥½äº† m2m2m2 ä¸ªæ“ä½œæ•°å¯¹ï¼Œå¯ä»¥è®¡ç®—å‡ºæ­¤æ—¶å¡«äº† m1m1m1 ä¸ªæ“ä½œæ•°å¯¹çš„ä¸€ä¸ªæ•°å’Œ m0m0m0 ä¸ªç©ºçš„æ“ä½œæ•°å¯¹ã€‚é‡‡ç”¨åˆ·è¡¨æ³•è½¬ç§»ï¼Œf(i,m2)f(i,m2)f(i,m2) å¯ä»¥è½¬ç§»åˆ° f(i+1,m2+k)f(i+1,m2+k)f(i+1,m2+k)ï¼Œæœ‰ (m1k)(m0biâˆ’k)\\dbinom{m1}{k}\\dbinom{m0}{b_i-k}(km1â€‹)(biâ€‹âˆ’km0â€‹) ç§æ–¹æ¡ˆæ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; inline int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int n, m; int b[5005], s[5005], fac[30005], inv[30005]; int f[2][30005]; inline int C(int n, int m) &#123; return 1ll * fac[n] * inv[m] % MOD * inv[n - m] % MOD; &#125; inline void add(int &amp;x, int k) &#123; x = (x + k) % MOD; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i), s[i] = s[i - 1] + b[i]; m = s[n]; if (m &amp; 1) return !puts(\"0\"); m >>= 1; fac[0] = 1; for (int i = 1; i &lt;= m; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; inv[m] = poww(fac[m], MOD - 2); for (int i = m - 1; i >= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD; f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= m; ++j) f[i &amp; 1][j] = 0; for (int j = 0; j &lt;= m; ++j) &#123; int m2 = j, m1 = s[i - 1] - 2 * m2, m0 = m - m1 - m2; if (m0 &lt; 0 || m1 &lt; 0) continue; int R = min(&#123;m1, b[i], m - m2&#125;); for (int k = max(0, b[i] - m0); k &lt;= R; ++k) add(f[i &amp; 1][m2 + k], 1ll * f[i - 1 &amp; 1][m2] * C(m1, k) % MOD * C(m0, b[i] - k) % MOD); &#125; &#125; printf(\"%d\\n\", f[n &amp; 1][m]); return 0; &#125; [CF985G] Team Players Portal. ä¸€çœ¼çœ‹å»åœ¨è¡¥å›¾ä¸Šè·‘ä¸‰å…ƒç¯è®¡æ•°ï¼Œç„¶åå‘ç°è¾¹æ•°çˆ†ç‚¸ï¼Œç›´æ¥å‘Šè¾ã€‚ ä½†æ˜¯å”¯ä¸€ä¼šçš„å¥½åƒå°±æ˜¯æ•°ä¸‰å…ƒç¯ã€‚è€ƒè™‘æ±‚ç­”æ¡ˆçš„è¡¥é›†ï¼Œç­”æ¡ˆåº”è¯¥æ˜¯æ‰€æœ‰ä¸‰å…ƒç»„çš„ç­”æ¡ˆï¼Œå‡å»è‡³å°‘æœ‰ä¸€æ¡è¾¹çš„ä¸‰å…ƒç»„çš„ç­”æ¡ˆã€‚ ç„¶ååé¢è¿™ä¸ªæ€ä¹ˆåšå‘¢ï¼Ÿæˆ‘ä»¬è‚¯å®šæ˜¯è¦å»çœ‹è¾¹çš„ï¼Œè¿™æ ·å°±ä¼šå¯¼è‡´å¯¹äºä¸€ä¸ªæœ‰ä¸¤æ¡è¾¹çš„ä¸‰å…ƒç»„ï¼Œè¢«ç»Ÿè®¡ä¸¤æ¬¡ã€‚å› æ­¤åé¢è¿™ä¸ªä¹Ÿéœ€è¦å®¹æ–¥ã€‚ æœ€ç»ˆç­”æ¡ˆå°±æ˜¯æ‰€æœ‰ä¸‰å…ƒç»„çš„ç­”æ¡ˆï¼ˆ1ï¼‰ï¼Œå‡å»è‡³å°‘æœ‰ä¸€æ¡è¾¹çš„ç­”æ¡ˆï¼ˆ2ï¼‰ï¼ŒåŠ ä¸Šè‡³å°‘æœ‰ä¸¤æ¡è¾¹çš„ç­”æ¡ˆï¼ˆ3ï¼‰ï¼Œå‡å»æœ‰ä¸‰æ¡è¾¹çš„ç­”æ¡ˆï¼ˆ4ï¼‰ã€‚æ¥ä¸‹æ¥åˆ†åˆ«çœ‹è¿™å››ä¸ªä¸œè¥¿æ€ä¹ˆåšã€‚ æšä¸¾ uâˆˆ[0,n)u\\in [0,n)uâˆˆ[0,n) ä¸­åœ¨ä¸‰å…ƒç»„ (i,j,k)(i,j,k)(i,j,k) çš„ä½ç½®ï¼Œç„¶ååˆ©ç”¨ä¹˜æ³•åŸç†è®¡ç®—ç­”æ¡ˆã€‚ åªæœ‰ä¸€æ¡è¾¹ï¼Œé‚£ä¹ˆæšä¸¾æ‰€æœ‰è¾¹ (x,y)(x,y)(x,y)ï¼Œä¸å¦¨ä»¤ x&lt;yx&lt;yx&lt;yï¼Œç„¶åä»¤ç¬¬ä¸‰ä¸ªç‚¹ä¸º zzzï¼Œè€ƒè™‘ x,y,zx,y,zx,y,z å¯¹ä¸‰å…ƒç»„ (i,j,k)(i,j,k)(i,j,k) çš„è´¡çŒ®ã€‚ x=ix=ix=iï¼Œæ­¤æ—¶ z&gt;xz&gt;xz&gt;xï¼Œxxx çš„è´¡çŒ®ä¸º AÃ—xÃ—(nâˆ’xâˆ’2)A\\times x\\times (n-x-2)AÃ—xÃ—(nâˆ’xâˆ’2)ï¼› x=jx=jx=jï¼Œæ­¤æ—¶ z&lt;xz&lt;xz&lt;xï¼Œxxx çš„è´¡çŒ®ä¸º BÃ—xÃ—xB\\times x\\times xBÃ—xÃ—xï¼› y=jy=jy=jï¼Œæ­¤æ—¶ z&gt;yz&gt;yz&gt;yï¼Œyyy çš„è´¡çŒ®ä¸º BÃ—yÃ—(nâˆ’yâˆ’1)B\\times y\\times (n-y-1)BÃ—yÃ—(nâˆ’yâˆ’1)ï¼› y=ky=ky=kï¼Œæ­¤æ—¶ z&lt;yz&lt;yz&lt;yï¼Œyyy çš„è´¡çŒ®ä¸º CÃ—yÃ—(yâˆ’1)C\\times y\\times (y-1)CÃ—yÃ—(yâˆ’1)ï¼› z=iz=iz=iï¼Œæ­¤æ—¶ 0â‰¤z&lt;x0\\le z&lt;x0â‰¤z&lt;xï¼Œzzz çš„è´¡çŒ®ä¸º AÃ—âˆ‘p=0xâˆ’1p=AÃ—xÃ—(xâˆ’1)2\\displaystyle A\\times \\sum_{p=0}^{x-1}p=A\\times \\frac {x\\times (x-1)} 2AÃ—p=0âˆ‘xâˆ’1â€‹p=AÃ—2xÃ—(xâˆ’1)â€‹ï¼› z=jz=jz=jï¼Œæ­¤æ—¶ x&lt;z&lt;yx&lt;z&lt;yx&lt;z&lt;yï¼Œzzz çš„è´¡çŒ®ä¸º BÃ—âˆ‘p=x+1yâˆ’1p=BÃ—(x+y)Ã—(yâˆ’xâˆ’1)2\\displaystyle B\\times \\sum_{p=x+1}^{y-1}p=B\\times\\frac{(x+y) \\times (y-x-1)} 2BÃ—p=x+1âˆ‘yâˆ’1â€‹p=BÃ—2(x+y)Ã—(yâˆ’xâˆ’1)â€‹ï¼› z=kz=kz=kï¼Œæ­¤æ—¶ y&lt;z&lt;ny&lt;z&lt;ny&lt;z&lt;nï¼Œzzz çš„è´¡çŒ®ä¸º CÃ—âˆ‘p=y+1nâˆ’1p=CÃ—(n+y)Ã—(nâˆ’yâˆ’1)2\\displaystyle C\\times \\sum_{p=y+1}^{n-1}p=C\\times \\frac{(n+y)\\times (n-y-1)} 2CÃ—p=y+1âˆ‘nâˆ’1â€‹p=CÃ—2(n+y)Ã—(nâˆ’yâˆ’1)â€‹ã€‚ ä¸¤æ¡è¾¹ï¼Œè¦æ±‚çš„æ˜¯ä¸‰ä¸ªç‚¹çš„é“¾ã€‚ä¸å¦¨è€ƒè™‘æšä¸¾çš„æ˜¯ä¸­é—´ç‚¹ xxxï¼Œæ­¤æ—¶ x=jx=jx=jã€‚æšä¸¾ xxx çš„æ¯ä¸€æ¡å‡ºè¾¹åˆ°è¾¾ç‚¹ yyyï¼Œè®¾ xxx çš„å‡ºåº¦ä¸º tttã€‚ç”±äº xxx ä¹Ÿä¼šå½±å“ yyy å……å½“çš„æ˜¯ i,ji,ji,j è¿˜æ˜¯ kkkï¼Œå› æ­¤ä¸å¦¨æŠŠ xxx ä¹ŸåŠ è¿› xxx çš„å‡ºè¾¹ä¸­ï¼ˆttt åŒæ—¶ä¹Ÿå¢å¤§ 111ï¼‰ã€‚è®¾ yyy åœ¨è¿™äº›æ•°ä¸­çš„æ’åä¸º rrrï¼Œåˆ†ä¸¤ç§æƒ…å†µè®¡ç®— yyy çš„è´¡çŒ®ï¼š y&lt;xy&lt;xy&lt;xï¼Œæ­¤æ—¶è€ƒè™‘ç¬¬ä¸‰ä¸ªç‚¹ zzz ï¼š z&gt;yz&gt;yz&gt;yï¼Œyyy çš„è´¡çŒ®ä¸º AÃ—yÃ—(tâˆ’râˆ’2)A\\times y\\times (t-r-2)AÃ—yÃ—(tâˆ’râˆ’2)ï¼› z&lt;yz&lt;yz&lt;yï¼Œyyy çš„è´¡çŒ®ä¸º BÃ—yÃ—rB\\times y\\times rBÃ—yÃ—rï¼› y&gt;xy&gt;xy&gt;xï¼Œæ­¤æ—¶è€ƒè™‘ç¬¬ä¸‰ä¸ªç‚¹ zzzï¼› z&gt;yz&gt;yz&gt;yï¼Œyyy çš„è´¡çŒ®ä¸º BÃ—yÃ—(tâˆ’râˆ’1)B\\times y\\times (t-r-1)BÃ—yÃ—(tâˆ’râˆ’1)ï¼› z&lt;yz&lt;yz&lt;yï¼Œyyy çš„è´¡çŒ®ä¸º CÃ—yÃ—(râˆ’1)C\\times y\\times (r-1)CÃ—yÃ—(râˆ’1)ã€‚ ç„¶åå¯¹äº xxx è‡ªå·±è¦è¿›è¡Œä¸€ä¸ªç»Ÿè®¡ï¼Œè€ƒè™‘ä¸‰ç§æƒ…å†µï¼š y,z&lt;xy,z&lt;xy,z&lt;xï¼Œxxx çš„è´¡çŒ®ä¸º CÃ—xÃ—rÃ—(râˆ’1)2C\\times x\\times \\dfrac{r\\times (r-1)}{2}CÃ—xÃ—2rÃ—(râˆ’1)â€‹ï¼› y,z&gt;xy,z&gt;xy,z&gt;xï¼Œxxx çš„è´¡çŒ®ä¸º AÃ—xÃ—(tâˆ’râˆ’1)Ã—(tâˆ’râˆ’2)2A\\times x\\times \\dfrac{(t-r-1)\\times (t-r-2)}{2}AÃ—xÃ—2(tâˆ’râˆ’1)Ã—(tâˆ’râˆ’2)â€‹ï¼› y&lt;x,z&gt;xy&lt;x,z&gt;xy&lt;x,z&gt;xï¼Œxxx çš„è´¡çŒ®ä¸º BÃ—xÃ—rÃ—(tâˆ’râˆ’1)B\\times x\\times r\\times (t-r-1)BÃ—xÃ—rÃ—(tâˆ’râˆ’1)ã€‚ ç›´æ¥æä¸€ä¸ªä¸‰å…ƒç¯è®¡æ•°æ¨¡æ¿å°±è¡Œã€‚ äºæ˜¯å°±å¾ˆé«˜å…´åœ°åšå®Œäº†ï¼Œæ—¶é—´å¤æ‚åº¦åº”è¯¥æ˜¯ O(n)+O(m)+O(n+m)+O(mm)=O(n+mm)O(n)+O(m)+O(n+m)+O(m\\sqrt{m})=O(n+m\\sqrt{m})O(n)+O(m)+O(n+m)+O(mmâ€‹)=O(n+mmâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; int n, m, u[200005], v[200005], deg[200005]; u64 A, B, C; vector&lt;int> G[200005], E[200005]; u64 calc0(void) &#123; u64 ans = 0; for (int i = 0; i &lt; n; ++i) &#123; ans += A * (n - i - 1) * (n - i - 2) / 2 * i; ans += B * i * (n - i - 1) * i; ans += C * i * (i - 1) / 2 * i; &#125; cerr &lt;&lt; \"A0 \" &lt;&lt; ans &lt;&lt; \"\\n\"; return ans; &#125; u64 calc1(void) &#123; u64 ans = 0; for (int i = 0; i &lt; m; ++i) &#123; int x = u[i], y = v[i]; ans += A * x * (n - x - 2); ans += B * x * x; ans += B * y * (n - y - 1); ans += C * y * (y - 1); ans += A * x * (x - 1) / 2; ans += B * (x + y) * (y - x - 1) / 2; ans += C * (n + y) * (n - y - 1) / 2; &#125; cerr &lt;&lt; \"A1 \" &lt;&lt; ans &lt;&lt; \"\\n\"; return ans; &#125; u64 calc2(void) &#123; u64 ans = 0; for (int x = 0; x &lt; n; ++x) &#123; int t = G[x].size(); // ç®— x è‡ªå·± for (int i = 0; i &lt; t; ++i) &#123; int y = G[x][i]; if (y &lt; x) &#123; ans += A * y * (t - i - 2); ans += B * y * i; &#125; else if (y > x) &#123; ans += B * y * (t - i - 1); ans += C * y * (i - 1); &#125; else &#123; ans += C * i * (i - 1) / 2 * x; ans += A * (t - i - 1) * (t - i - 2) / 2 * x; ans += B * i * (t - i - 1) * x; &#125; &#125; &#125; cerr &lt;&lt; \"A2 \" &lt;&lt; ans &lt;&lt; \"\\n\"; return ans; &#125; int vis[200005]; u64 calc3(void) &#123; u64 ans = 0; memset(vis, 0xff, sizeof vis); for (int x = 0; x &lt; n; ++x) &#123; for (int y : E[x]) vis[y] = x; for (int y : E[x]) for (int z : E[y]) if (vis[z] == x) &#123; int t[] = &#123;x, y, z&#125;; sort(t, t + 3); ans += A * t[0] + B * t[1] + C * t[2]; &#125; &#125; cerr &lt;&lt; \"A3 \" &lt;&lt; ans &lt;&lt; \"\\n\"; return ans; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m >> A >> B >> C; for (int i = 0; i &lt; m; ++i) &#123; cin >> u[i] >> v[i]; ++deg[u[i]]; ++deg[v[i]]; G[u[i]].emplace_back(v[i]); G[v[i]].emplace_back(u[i]); if (u[i] > v[i]) swap(u[i], v[i]); &#125; for (int i = 0; i &lt; n; ++i) G[i].emplace_back(i), sort(G[i].begin(), G[i].end()); for (int i = 0; i &lt; m; ++i) &#123; int x = u[i], y = v[i]; if (deg[x] > deg[y] || (deg[x] == deg[y] &amp;&amp; x > y)) swap(x, y); E[x].emplace_back(y); &#125; cout &lt;&lt; calc0() - calc1() + calc2() - calc3() &lt;&lt; \"\\n\"; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ç»„åˆæ•°å­¦","slug":"ç»„åˆæ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"å¤æ‚æ ‘å½¢é—®é¢˜","slug":"notes/DS/tree-ex","date":"2022-12-13T00:00:00.000Z","updated":"2022-12-13T00:00:00.000Z","comments":true,"path":"6a4a6864/","link":"","permalink":"https://james1badcreeper.github.io/6a4a6864/","excerpt":"é«˜é˜¶çš„æ ‘å½¢é—®é¢˜æ›´ä¸ºå›°éš¾ï¼ŒåŒ…æ‹¬ä¸€äº›æ¯”è¾ƒå¤æ‚çš„ç®—æ³•æŠ€å·§å’Œæ•°æ®ç»“æ„ã€‚","text":"é«˜é˜¶çš„æ ‘å½¢é—®é¢˜æ›´ä¸ºå›°éš¾ï¼ŒåŒ…æ‹¬ä¸€äº›æ¯”è¾ƒå¤æ‚çš„ç®—æ³•æŠ€å·§å’Œæ•°æ®ç»“æ„ã€‚ åŸºç¯æ ‘ å¦‚æœä¸€ä¸ªè¿é€šæ— å‘å›¾æœ‰ nnn ä¸ªç‚¹å’Œ nnn æ¡è¾¹ï¼Œç›¸å½“äºåœ¨ä¸€æ£µæ ‘ä¸ŠåŠ äº†ä¸€æ¡è¾¹ï¼Œé•¿å‡ºäº†ä¸€ä¸ªç¯ï¼Œé‚£ä¹ˆè¿™ä¸ªä¸œè¥¿å°±æˆäº†åŸºç¯æ ‘ã€‚é™¤äº†è¿™ä¸ªåŸºç¯ä¹‹å¤–ï¼Œå‰©ä¸‹çš„æ¯ä¸€éƒ¨åˆ†éƒ½æ˜¯è‹¥å¹²æ£µå­æ ‘ã€‚ æ¦‚å¿µ nnn ä¸ªç‚¹ nnn æ¡è¾¹çš„æ— å‘å›¾ä¹Ÿæœ‰å¯èƒ½æ˜¯â€œåŸºç¯æ ‘æ£®æ—â€ã€‚å¦‚æœå›¾æ˜¯æœ‰å‘çš„ï¼Œé‚£ä¹ˆè¿˜æœ‰å†…å‘åŸºç¯æ ‘ï¼ˆæ¯ä¸ªç‚¹ä»…æœ‰ 111 æ¡å‡ºè¾¹ï¼‰å’Œå¤–å‘åŸºç¯æ ‘ï¼ˆæ¯ä¸ªç‚¹ä»…æœ‰ 111 æ¡å…¥è¾¹ï¼‰ã€‚ åœ¨æ±‚è§£ä¸åŸºç¯æ ‘ç›¸å…³çš„é—®é¢˜æ—¶ï¼Œä¸€èˆ¬éƒ½è¦æ‰¾åˆ°åŸºç¯ï¼ŒæŠŠåŸºç¯ä½œä¸ºå¹¿ä¹‰çš„â€œæ ¹èŠ‚ç‚¹â€è¿›è¡Œå¤„ç†ã€‚ åŸºç¯æ ‘ DP åŸºç¯æ ‘ä¸Šçš„ DP å¤§è‡´ä¸æ ‘å½¢ DP ä¸€è‡´ã€‚ [ZJOI2008] éª‘å£«ã€‚æ ‘çš„æœ€å¤§ç‹¬ç«‹é›†ï¼Œä½†æ˜¯åŸºç¯æ ‘ã€‚ æ³¨æ„è¿™æœ‰å¯èƒ½æ˜¯ä¸€ä¸ªåŸºç¯æ ‘æ£®æ—ï¼Œæ‰€ä»¥éœ€è¦è¿›è¡Œå¤šæ¬¡ DPã€‚ ç¬›å¡å°”æ ‘ ç¬›å¡å°”æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„ Treapï¼Œå…¶èŠ‚ç‚¹æƒå€¼ä¸å†æ˜¯éšæœºçš„ï¼Œè€Œæ˜¯ç»™å®šçš„ã€‚æ¯ä¸ªèŠ‚ç‚¹çš„æƒå€¼ç”¨ (xi,yi)(x_i,y_i)(xiâ€‹,yiâ€‹) è¡¨ç¤ºï¼Œåªè€ƒè™‘ xxx æ—¶å®ƒæ˜¯ BSTï¼Œåªè€ƒè™‘ yyy æ—¶å®ƒæ˜¯å †ï¼ˆæ­¤å¤„ä»¥å°æ ¹å †ä¸ºä¾‹ï¼‰ã€‚ åœ¨ xxx é€’å¢æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥çº¿æ€§å¤æ‚åº¦å»ºå‡ºç¬›å¡å°”æ ‘ã€‚æ’å…¥æ–°èŠ‚ç‚¹æ—¶ï¼Œä¸ºäº†ä¿è¯ xxx çš„æ€§è´¨æ»¡è¶³ï¼Œè¦å°† xxx æ’å…¥åˆ°å°½é‡å³çš„åœ°æ–¹ã€‚ å…·ä½“æ¥è®²ï¼Œç»´æŠ¤ä¸€ä¸ªä»æ ¹èŠ‚ç‚¹ä¸€ç›´èµ°åˆ°å³å„¿å­çš„é“¾ã€‚è®¾å½“å‰éœ€è¦æ’å…¥ uuuï¼Œåˆ™éœ€è¦æ‰¾åˆ°ç¬¬ä¸€ä¸ª yv&lt;yuy_v&lt;y_uyvâ€‹&lt;yuâ€‹ï¼Œå°† vvv çš„å³å„¿å­è®¾ä¸º uuuï¼ˆä¸å­˜åœ¨åˆ™å°† uuu è®¾ä¸ºæ ¹ï¼‰ï¼Œå¦‚æœ vvv åŸæœ¬æœ‰å³å­æ ‘ï¼Œåˆ™å°† vvv çš„å³å­æ ‘æ”¹è¿åœ¨ uuu çš„å·¦å­æ ‘ä¸‹é¢æ¥æ»¡è¶³ BST æ€§è´¨ã€‚ä½¿ç”¨å•è°ƒæ ˆç»´æŠ¤æ­¤é“¾ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ æ¨¡æ¿é¢˜æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š for (int i = 1, tot = 0, cur = 0; i &lt;= n; ++i) &#123; scanf(\"%d\", p + i); cur = tot; while (cur &amp;&amp; p[st[cur]] > p[i]) --cur; if (cur) rs[st[cur]] = i; if (cur &lt; tot) ls[i] = st[cur + 1]; // æ”¾åˆ°å·¦èŠ‚ç‚¹ä»¥æ»¡è¶³ BST æ€§è´¨ st[++cur] = i; tot = cur; &#125; æ€§è´¨ï¼šå¦‚æœèŠ‚ç‚¹ç¼–å· 1âˆ¼n1\\sim n1âˆ¼n ä¸º BST æƒå€¼ï¼Œç„¶åç‚¹æƒæ»¡è¶³å°æ ¹å †æ€§è´¨ï¼Œé‚£ä¹ˆ minâ¡{ax,â‹¯ ,ay}=aLCAâ¡(x,y)\\min\\{a_x,\\cdots,a_y\\}=a_{\\operatorname{LCA}(x,y)}min{axâ€‹,â‹¯,ayâ€‹}=aLCA(x,y)â€‹ã€‚ æ ‘ä¸Šå¯å‘å¼åˆå¹¶ è¿˜è®°å¾—å¹¶æŸ¥é›†çš„æŒ‰ç§©åˆå¹¶å—ï¼Ÿå½“ç§©å®šä¹‰ä¸ºé›†åˆçš„å¤§å°æ—¶ï¼Œå°±å˜æˆäº†å¯å‘å¼åˆå¹¶ã€‚æ ‘ä¸Šå¯å‘å¼åˆå¹¶ï¼ˆdsu on treeï¼‰è®©ç‚¹æ•°å°çš„æ ‘æˆä¸ºç‚¹æ•°è¾ƒå¤§çš„æ ‘çš„å­æ ‘ï¼Œåœ¨å¤„ç†ä¸€äº›å¯ä»¥ç¦»çº¿çš„æ ‘ä¸Šé—®é¢˜æ—¶éå¸¸ç®€å•ï¼Œè€Œä¸”å¤æ‚åº¦æ˜¯ logâ¡\\loglog çš„ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€é“ç®€å•é¢˜ï¼š ç»™å®šä¸€æ£µ n(nâ‰¤2Ã—105)n(n\\le 2\\times 10^5)n(nâ‰¤2Ã—105) ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼ŒèŠ‚ç‚¹ xxx çš„é¢œè‰²æ˜¯ cxc_xcxâ€‹ï¼Œç°åœ¨è¯¢é—®å¯¹äº xxx çš„å­æ ‘é‡Œå‡ºç°äº†å¤šå°‘ä¸åŒç§é¢œè‰²ã€‚å¼ºåˆ¶ç¦»çº¿ã€‚ æˆ‘ä»¬å…ˆå¤„ç†å‡ºæ¯ä¸ªå­èŠ‚ç‚¹çš„å­æ ‘å¤§å°å’Œé‡å„¿å­ï¼Œè¿˜æœ‰å½“å‰èŠ‚ç‚¹å­æ ‘ä¸­çš„æœ€å¤§æœ€å°æ—¶é—´æˆ³ï¼Œä½¿ç”¨ç±»ä¼¼äºé‡é“¾å‰–åˆ†çš„è¿‡ç¨‹å°±å¯ä»¥å®Œæˆã€‚ç”¨ cnt[i]cnt[i]cnt[i] è¡¨ç¤ºé¢œè‰² iii å‡ºç°çš„æ¬¡æ•°ï¼Œans[x]ans[x]ans[x] ä»£è¡¨èŠ‚ç‚¹ xxx çš„ç­”æ¡ˆã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬è¿›è¡Œç¬¬äºŒæ¬¡ dfs(x, fa, keep)ï¼Œkeepkeepkeep ä»£è¡¨æ˜¯å¦ä¿ç•™å½±å“ï¼š å…ˆéå† xxx çš„è½»å„¿å­ï¼Œå¹¶è®¾ç½® keep=falsekeep=falsekeep=falseï¼› éå† xxx çš„é‡å„¿å­ï¼Œè®¾ç½® keep=truekeep=truekeep=trueï¼› å°†è½»å„¿å­çš„ç­”æ¡ˆå…¨éƒ¨åŠ å…¥ï¼ˆéå†æ—¶é—´æˆ³ï¼‰ï¼Œç»Ÿè®¡ç­”æ¡ˆï¼Œå®Œæˆååˆ é™¤ã€‚ è¿™ç›¸å½“äºæ˜¯å¹²äº†ä¸ªä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬è¦ç»Ÿè®¡ä¸€ä¸ª xxx å­æ ‘çš„ç­”æ¡ˆï¼Œè‚¯å®šæ˜¯è¦å°†å®ƒçš„æ‰€æœ‰å„¿å­çš„ä¹Ÿéƒ½éå†çš„ã€‚ä½†é—®é¢˜æ˜¯æˆ‘ä»¬ä¸èƒ½ä¿ç•™è¿™äº›ï¼Œéå†ä¸€ä¸ªå„¿å­çš„ç­”æ¡ˆä¹‹åå¿…é¡»é©¬ä¸Šåˆ é™¤ï¼Œå¦åˆ™ä¸‹ä¸€ä¸ªå„¿å­çš„ç­”æ¡ˆæ˜¯é”™è¯¯çš„ã€‚è€Œæœ€åä¸€ä¸ªå„¿å­çš„ç­”æ¡ˆæ˜¯ä¸ç”¨åˆ é™¤çš„ï¼Œå› ä¸ºé©¬ä¸Šå°±ä¼šå›æº¯ï¼Œè¿™ä¸ªç­”æ¡ˆè‚¯å®šè¿˜è¦å†æ¬¡è¢«ä½¿ç”¨ï¼Œæˆ‘ä»¬è‚¯å®šé€‰æ‹©æœ€é‡çš„ä¸€ä¸ªä¿ç•™ã€‚ ç†è®ºæ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogâ¡n)O(n\\log n)O(nlogn)ï¼Œå…·ä½“è¯æ˜è¾ƒä¸ºå¤æ‚ï¼Œåˆ°æ—¶å€™å†è¡¥å§ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, siz[200005], son[200005]; int L[200005], R[200005], idx[200005], num = 0; vector&lt;int> G[200005]; void dfs1(int x, int fa) &#123; siz[x] = 1; L[x] = ++num; idx[num] = x; int max_part = -1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > max_part) son[x] = y, max_part = siz[y]; &#125; R[x] = num; &#125; int c[200005], cnt[200005], anscol; int ans[200005]; void add(int x) &#123; if (cnt[c[x]] == 0) ++anscol; ++cnt[c[x]]; &#125; void del(int x) &#123; if (cnt[c[x]] == 1) --anscol; --cnt[c[x]]; &#125; void dfs2(int x, int fa, bool keep) &#123; for (int y : G[x]) if (y != fa &amp;&amp; y != son[x]) dfs2(y, x, false); if (son[x] != -1) dfs2(son[x], x, true); for (int y : G[x]) if (y != fa &amp;&amp; y != son[x]) for (int i = L[y]; i &lt;= R[y]; ++i) add(idx[i]); add(x); ans[x] = anscol; if (!keep) for (int i = L[x]; i &lt;= R[x]; ++i) del(idx[i]); // å®é™…ä¸Šä¸Šä¸€æ­¥ä¼šå…¨éƒ¨æ¸…ç©ºï¼Œå› ä¸ºå½“å‰å­æ ‘ä¸­æ²¡æœ‰éœ€è¦ä¿ç•™çš„å†…å®¹ &#125; int main(void) &#123; memset(son, -1, sizeof(son)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", c + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs1(1, 0); dfs2(1, 0, false); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", ans[i]); putchar('\\n'); return 0; &#125; Kruskal é‡æ„æ ‘ å¾—ç›Šäº Kruskal çš„ç¾å¦™æ€§è´¨ï¼ŒKruskal é‡æ„æ ‘æ˜¯è§£å†³ä¸€äº›è·¯å¾„æœ€å€¼ç›¸å…³é—®é¢˜çš„å¼ºæœ‰åŠ›æ­¦å™¨ã€‚ å…¶æœ¬è´¨ä¸Šæ˜¯å¯å‘å¼åˆå¹¶çš„ä¸€ç§åº”ç”¨ã€‚ å®šä¹‰ åœ¨æ±‚è§£ Kruskal çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šä»å°åˆ°å¤§åŠ å…¥è‹¥å¹²æ¡è¾¹ã€‚å¼€å§‹æ—¶æˆ‘ä»¬å»ºç«‹ nnn ä¸ªé›†åˆï¼Œæ¯ä¸ªé›†åˆæ°å¥½æœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç‚¹æƒä¸º 000ã€‚ æ¯æ¬¡åŠ è¾¹ä¼šåˆå¹¶ä¸¤ä¸ªé›†åˆï¼Œè¿™æ—¶å€™æˆ‘ä»¬æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œç‚¹æƒä¸ºåŠ å…¥çš„è¾¹çš„è¾¹æƒï¼ŒåŒæ—¶å°†ä¸¤ä¸ªé›†åˆçš„æ ¹èŠ‚ç‚¹åˆ†åˆ«è®¾ä¸ºæ–°å»ºèŠ‚ç‚¹çš„å·¦å³å„¿å­ï¼Œè¿™æ—¶è¿™ä¸¤ä¸ªé›†åˆå’Œæ–°å»ºç‚¹ä¼šå¹¶ä¸ºä¸€ä¸ªé›†åˆï¼Œæ–°å»ºç‚¹ä¸ºé›†åˆçš„æ ¹ã€‚ å½“ Kruskal å®Œæˆæ—¶ï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€æ£µæ°å¥½åŒ…å« nnn ä¸ªå¶å­çš„äºŒå‰æ ‘ï¼ˆæ€»èŠ‚ç‚¹æ•°ä¸º 2nâˆ’12n-12nâˆ’1ï¼‰ï¼ŒåŒæ—¶æ¯ä¸ªéå¶å­èŠ‚ç‚¹æ°å¥½æœ‰ä¸¤ä¸ªå„¿å­ï¼Œå¾—åˆ°çš„è¿™æ£µæ ‘å°±å«åš Kruskal é‡æ„æ ‘ã€‚ æ€§è´¨ çˆ¶äº²èŠ‚ç‚¹çš„ç‚¹æƒå¤§äºç­‰äºå„¿å­çš„ç‚¹æƒã€‚ åŸå›¾ä¸­çš„ä¸¤ç‚¹é—´æ‰€æœ‰ç®€å•è·¯å¾„ä¸Šæœ€å¤§è¾¹æƒçš„æœ€å°å€¼ï¼Œå°±æ˜¯æœ€å°ç”Ÿæˆæ ‘ä¸Šä¸¤ä¸ªç‚¹ä¹‹é—´çš„ç®€å•è·¯å¾„ä¸Šçš„æœ€å¤§è¾¹æƒå€¼ï¼Œå°±æ˜¯ Kruskal é‡æ„æ ‘ä¸Šä¸¤ç‚¹çš„ LCA çš„æƒå€¼ã€‚ [CF1706E] Qpwoeirut and Vertices. æ ¹æ®è¾¹çš„é¡ºåºèµ‹äºˆæƒå€¼ï¼Œæ„å»ºå‡º Kruskal é‡æ„æ ‘ï¼Œè¯¢é—®ç›¸å½“äºæ±‚åŒºé—´ç‚¹çš„ LCA çš„æƒå€¼ï¼Œå¯ä»¥ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; struct edge &#123; int u, v, w; &#125; e[200005]; int n, m, q, a[200005], bin[200005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; vector&lt;int> G[200005]; void addedge(int x, int fa) &#123; G[x].emplace_back(fa); G[fa].emplace_back(x); &#125; int f[17][200005], dep[200005], dfn[200005], num = 0; void dfs(int x, int fa) &#123; f[0][x] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= 16; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 16; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = 16; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; int T[400005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = l, void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = LCA(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return LCA(query(o &lt;&lt; 1, l, mid, x, y), query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); &#125; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;e[i].u, &amp;e[i].v), e[i].w = i; for (int i = 1; i &lt;= n * 2; ++i) bin[i] = i, a[i] = 0, G[i].clear(); int tot = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v, w = e[i].w; int x = find(u), y = find(v); if (x == y) continue; a[++tot] = w; bin[x] = bin[y] = tot; addedge(x, tot); addedge(y, tot); if (tot == 2 * n - 1) break; &#125; dfs(tot, 0); build(1, 1, n); while (q--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d \", a[query(1, 1, n, l, r)]); &#125; putchar('\\n'); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; ç‚¹æƒé‡æ„æ ‘ å¯¹äºç‚¹æƒçš„é™åˆ¶ä¸€æ ·å¯ä»¥å¤„ç†ã€‚ ä¸€ç§é€‰æ‹©æ˜¯ï¼Œé™åˆ¶ç»è¿‡çš„ç‚¹æƒæœ€å¤§å€¼ï¼Œå› ä¸ºèµ° (u,v)(u,v)(u,v) éœ€è¦æ»¡è¶³å‡ä¸è¶…è¿‡ wu,wvw_u,w_vwuâ€‹,wvâ€‹ï¼Œå› æ­¤å°†è¾¹æƒèµ‹å€¼ä¸º maxâ¡{wu,wv}\\max\\{w_u,w_v\\}max{wuâ€‹,wvâ€‹}ã€‚ ç„¶è€Œäº‹å®ä¸Šæˆ‘ä»¬å¯ä»¥é€ ä¸€ä¸ªå¤šå‰é‡æ„æ ‘ã€‚æ¯”å¦‚é™åˆ¶ç»è¿‡ç‚¹æƒçš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆå°†èŠ‚ç‚¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºï¼Œéå†æ¯ä¸ªèŠ‚ç‚¹ uuu å’Œèƒ½åˆ°è¾¾çš„èŠ‚ç‚¹ vvvï¼Œè‹¥ vvv å·²ç»éå†ï¼Œåˆ™ wuâ‰¥wvw_u\\ge w_vwuâ€‹â‰¥wvâ€‹ï¼Œmaxâ¡{wu,wv}\\max\\{w_u,w_v\\}max{wuâ€‹,wvâ€‹} å–åˆ° wuw_uwuâ€‹ï¼Œè‹¥ä¸è¿é€šåˆ™ uuu æ˜¯ vvv æ‰€å±é›†åˆçš„çˆ¶äº²ã€‚ è™šæ ‘ å¦‚æœæ ‘çš„è§„æ¨¡å¾ˆå¤§ï¼Œä½†æ˜¯æ¯æ¬¡è¯¢é—®çš„ç‚¹æ¯”è¾ƒå°‘æ€ä¹ˆåŠï¼Ÿ å¼•å…¥ [SDOI2011] æ¶ˆè€—æˆ˜ã€‚ å¦‚æœæŸ¥è¯¢åªæœ‰ä¸€æ¬¡ï¼Œå¯ä»¥ç›´æ¥æ ‘å½¢ DPï¼šè®¾ f(i)f(i)f(i) ä»£è¡¨ä¸å…¶å­æ ‘å†…ä»»æ„è¯¢é—®ç‚¹ä¸è¿é€šçš„æœ€å°ä»£ä»·ï¼Œå¦‚æœå®ƒè‡ªå·±æ˜¯è¯¢é—®ç‚¹åˆ™ f(i)=+âˆf(i)=+\\inftyf(i)=+âˆï¼Œå¦åˆ™ fx=âˆ‘yâˆˆson(x)minâ¡{fy,wx,y}f_x=\\sum_{y\\in son(x)}\\min\\{f_y,w_{x,y}\\}fxâ€‹=âˆ‘yâˆˆson(x)â€‹min{fyâ€‹,wx,yâ€‹}ã€‚ ä½†æ˜¯å¤šæ¬¡è¯¢é—®ï¼å­˜åœ¨å¾ˆå¤šæ— ç”¨å€¼ï¼Œæ¯”å¦‚è¯´ä¸€æ¡é“¾ä¸Šé¢æ²¡æœ‰ä¸œè¥¿ï¼Œæˆ‘ä»¬åªå…³å¿ƒè¿™æ¡é“¾çš„æƒå€¼ï¼›è¿˜æœ‰å…³é”®ç‚¹å…¨åœ¨ä¸€æ£µå­æ ‘å†…ï¼Œæˆ‘ä»¬æ ¹æœ¬ä¸éœ€è¦å» DP å…¶å®ƒå­æ ‘ã€‚ç”±äºä¸€èˆ¬ä»æ ¹èŠ‚ç‚¹å¼€å§‹ DPï¼Œå› æ­¤æ¨èé»˜è®¤æŠŠ 111 å·èŠ‚ç‚¹åŠ å…¥è™šæ ‘ã€‚ æˆ‘ä»¬åªéœ€è¦è®°å½•å…³é”®ç‚¹çš„ LCA å³å¯ï¼Œè¿™æ ·å°±èƒ½å®Œæ•´ä¿å­˜æ ‘ä¸­çš„å­å­™åä»£å…³ç³»ã€‚ä½†æ˜¯è¿˜èƒ½ O(n2)O(n^2)O(n2) æšä¸¾ LCA å—ï¼Ÿä¸èƒ½ï¼å°†å…³é”®ç‚¹æŒ‰ç…§ DFS åºæ’åºï¼Œæ’åºåç›¸é‚»çš„ä¸¤ä¸ªå…³é”®ç‚¹æ±‚ LCA å¹¶æŠŠå®ƒåŠ å…¥è™šæ ‘å³å¯ã€‚ä½†æ˜¯è¿™æ ·å¾ˆæ…¢ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ª DFS åºé€’å¢çš„å•è°ƒæ ˆå»ºç«‹è™šæ ‘ï¼š å°† 111 åŠ å…¥è™šæ ‘ã€‚ å¦‚æœ deplcaâ‰¤deptâˆ’1dep_{lca}\\le dep_{t-1}deplcaâ€‹â‰¤deptâˆ’1â€‹ï¼Œé‚£ä¹ˆ t,tâˆ’1t,t-1t,tâˆ’1 ä¹‹é—´ä¸€å®šæœ‰è¾¹ï¼Œä¸æ–­å¼¹æ ˆç›´åˆ°æ¡ä»¶ä¸æ»¡è¶³ã€‚ å¦‚æœ lcalcalca ä¸æ˜¯æ ˆé¡¶ï¼Œåˆ™å°† lcalcalca å‘æ ˆé¡¶è¿è¾¹ã€‚ ç‚¹ pip_ipiâ€‹ å…¥æ ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, k, dep[250005], lg[250005]; int mi[18][250005], dfn[250005], num, d[18][250005], fa[18][250005]; int p[250005]; bool tag[250005]; vector&lt;pair&lt;int, int>> G[250005]; int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int ff) &#123; mi[0][dfn[x] = ++num] = ff; dep[x] = dep[fa[0][x] = ff] + 1; for (auto [y, w] : G[x]) if (y != ff) d[0][y] = w, dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int dist(int x, int y) &#123; int res = 1e9; for (int i = lg[dep[y] - dep[x]]; i >= 0; --i) if (dfn[fa[i][y]] >= dfn[x]) &#123; res = min(res, d[i][y]); y = fa[i][y]; &#125; return res; &#125; vector&lt;int> E[250005]; inline void addedge(int x, int y) &#123; // x æ˜¯çˆ¶äº²ï¼Œy æ˜¯å„¿å­ E[x].emplace_back(y); E[y].emplace_back(x); &#125; int st[250005], tot; i64 f[250005]; void dp(int x, int ff) &#123; if (tag[x]) f[x] = 1e15; for (int y : E[x]) if (y != ff) &#123; dp(y, x); if (!tag[x]) f[x] += min(f[y], (i64)dist(x, y)); &#125; E[x].clear(); &#125; void build_tree(void) &#123; sort(p + 1, p + k + 1, [](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;); st[tot = 1] = 1; for (int i = 1; i &lt;= k; ++i) if (p[i] != 1) &#123; int lca = LCA(st[tot], p[i]); while (tot > 1 &amp;&amp; dep[lca] &lt;= dep[st[tot - 1]]) addedge(st[tot - 1], st[tot]), --tot; if (lca != st[tot]) f[lca] = 0, addedge(lca, st[tot]), st[tot] = lca; st[++tot] = p[i]; &#125; for (int i = 1; i &lt; tot; ++i) addedge(st[i], st[i + 1]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].emplace_back(v, d); G[v].emplace_back(u, d); &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j &lt;= n; ++j) &#123; fa[i][j] = fa[i - 1][fa[i - 1][j]]; d[i][j] = min(d[i - 1][j], d[i - 1][fa[i - 1][j]]); if (j + (1 &lt;&lt; i) - 1 &lt;= n) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); &#125; scanf(\"%d\", &amp;m); while (m--) &#123; scanf(\"%d\", &amp;k); f[1] = 0; for (int i = 1; i &lt;= k; ++i) scanf(\"%d\", p + i), tag[p[i]] = 1, f[p[i]] = 0; build_tree(); dp(1, 0); printf(\"%lld\\n\", f[1]); f[1] = 0; for (int i = 1; i &lt;= k; ++i) tag[p[i]] = 0; &#125; return 0; &#125; æ€§è´¨ ç‚¹é›† SSS çš„è™šæ ‘è¾¹æƒå’Œç­‰äºæ‰€æœ‰æ—¶é—´æˆ³ç›¸é‚»çš„èŠ‚ç‚¹çš„è·ç¦»ä¹‹å’Œé™¤ä»¥ 222ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè®¾æ’åºåçš„æ—¶é—´æˆ³ä¸º a0,â‹¯aâˆ£Sâˆ£âˆ’1a_0,\\cdots a_{|S|-1}a0â€‹,â‹¯aâˆ£Sâˆ£âˆ’1â€‹ï¼Œé‚£ä¹ˆè¾¹æƒå’Œä¸º âˆ‘i=0âˆ£Sâˆ£dist(ai,a(i+1) mod âˆ£Sâˆ£)Ã·2\\sum_{i=0}^{|S|}dist(a_i,a_{(i+1)\\bmod |S|})\\div 2âˆ‘i=0âˆ£Sâˆ£â€‹dist(aiâ€‹,a(i+1)modâˆ£Sâˆ£â€‹)Ã·2ã€‚è¿™å…¶å®å°±æ˜¯ DFS åºçš„æ€§è´¨ã€‚ æ ‘ä¸Šåˆ†æ²»ç®—æ³• åˆ†æ²»åˆæ¥äº†ï¼æ ‘ä¸Šåˆ†æ²»ç®—æ³•ä¸€èˆ¬åˆ†ä¸ºç‚¹åˆ†æ²»ï¼ˆæ›´ä¸ºå¸¸ç”¨ï¼‰å’Œè¾¹åˆ†æ²»ï¼Œç±»ä¼¼å°†åŒºé—´åˆ†æˆä¸¤åŠã€‚ é™æ€ç‚¹åˆ†æ²» æ¨¡æ¿ã€‚ç»™å®šä¸€æ£µè¾¹å¸¦æƒçš„æ ‘ï¼Œå¤šæ¬¡è¯¢é—®æ ‘ä¸Šè·ç¦»ä¸º kkk çš„ç‚¹æ˜¯å¦å­˜åœ¨ã€‚ æˆ‘ä»¬å…ˆçœ‹ä¸€çœ‹è¿™ä¸ªé—®é¢˜åœ¨é“¾ä¸Šå¦‚ä½•è§£å†³ï¼šå¯¹äºå½“å‰åŒºé—´ [l,r],mid=(l+r)/2[l,r],mid=(l+r)/2[l,r],mid=(l+r)/2ï¼Œç­”æ¡ˆåŒºé—´ [i,j][i,j][i,j] è¦ä¹ˆæ»¡è¶³ i,jâ‰¤mid,i,j&gt;midi,j\\le mid,i,j&gt;midi,jâ‰¤mid,i,j&gt;midï¼Œè¦ä¹ˆè·¨è¶Šä¸­ç‚¹ iâ‰¤mid&lt;ji\\le mid&lt;jiâ‰¤mid&lt;jã€‚å½“è·¨è¶Šä¸­ç‚¹æ—¶ï¼Œå¯¹åŸåºåˆ—çš„å‰ç¼€å’Œæ•°ç»„æ±‚ä¸€ç»„ sjâˆ’si=ks_j-s_i=ksjâ€‹âˆ’siâ€‹=kï¼Œé‚£ä¹ˆåœ¨åˆ†æ²»çš„åŒæ—¶å¯¹ sss è¿›è¡Œå½’å¹¶æ’åºï¼Œæšä¸¾ sjs_jsjâ€‹ï¼Œåˆ¤æ–­ sjâˆ’ks_j-ksjâ€‹âˆ’k æ˜¯å¦åœ¨ [l,mid][l,mid][l,mid] ä¸­å‡ºç°è¿‡ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚ æˆ‘ä»¬å…ˆä»»æ„é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹ rootrootrootï¼ˆæ˜¾ç„¶é‡å¿ƒæ¯”è¾ƒå¥½ï¼‰ï¼Œæ‰€æœ‰å®Œå…¨ä½äºå…¶å­æ ‘ä¸­çš„è·¯å¾„å¯ä»¥åˆ†ä¸ºï¼š ä¸ç»è¿‡å½“å‰æ ¹èŠ‚ç‚¹çš„è·¯å¾„ï¼› ç»è¿‡å½“å‰æ ¹èŠ‚ç‚¹çš„è·¯å¾„ï¼Œåˆå¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼š ä»¥æ ¹èŠ‚ç‚¹ä¸ºä¸€ä¸ªç«¯ç‚¹çš„è·¯å¾„ï¼› è·¨è¶Šæ ¹èŠ‚ç‚¹çš„è·¯å¾„ï¼Œå®é™…ä¸Šæ˜¯æœ‰ä¸¤æ¡ä»¥ä¸€ä¸ªæ ¹èŠ‚ç‚¹ä¸ºç«¯ç‚¹çš„è·¯å¾„åˆå¹¶è€Œæˆï¼Œåˆ†æ²»çš„æ—¶å€™åªéœ€è¦åˆå¹¶è¿™ç§ä¿¡æ¯ã€‚ æ‰€ä»¥æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ç±»ä¼¼åˆ†æ²»çš„æ–¹å¼è¿›è¡Œæ±‚è§£ï¼æ‰¾åˆ°é‡å¿ƒ rrr ä½œä¸ºåˆ†æ²»ä¸­å¿ƒï¼Œæ‰“ä¸Šåˆ é™¤æ ‡è®°ï¼Œå¹¶ dfs å®ƒçš„æ¯ä¸€æ£µå­æ ‘ï¼ˆé‡åˆ°æ‰“äº†åˆ é™¤æ ‡è®°çš„ç‚¹å°±è¦ç«‹å³åœæ­¢ï¼‰ã€‚æ±‚å‡ºå­æ ‘å†…æ¯ä¸ªèŠ‚ç‚¹åˆ°åˆ†æ²»é‡å¿ƒçš„è·ç¦»å’Œæ¥æºäºå“ªä¸ªå„¿å­çš„å­æ ‘ï¼Œç»Ÿä¸€å­˜åœ¨ä¸€ä¸ª vector é‡Œï¼Œä½¿ç”¨åŒæŒ‡é’ˆæ¥åˆå¹¶ç­”æ¡ˆï¼ˆæ³¨æ„åªèƒ½åˆå¹¶ä¸åŒçš„å­æ ‘ï¼‰ã€‚ ç¦»çº¿ç»Ÿä¸€å¤„ç†å¯ä»¥å°†æ—¶é—´å¤æ‚åº¦é™ä½ä¸º O(nlogâ¡n(m+logâ¡n))O(n\\log n(m+\\log n))O(nlogn(m+logn))ï¼Œæ­£å¸¸å•æ¬¡ç‚¹åˆ†æ²»çš„æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; typedef pair&lt;int, int> pii; int n, m, k[10005], siz[10005], maxx[10005]; int root = 0; bool vis[10005], ans[10005]; vector&lt;pii> G[10005]; void froot(int x, int fa, int tot) &#123; siz[x] = 1; maxx[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; froot(y, x, tot); siz[x] += siz[y]; maxx[x] = max(maxx[x], siz[y]); &#125; maxx[x] = max(maxx[x], tot - siz[x]); if (maxx[x] &lt; maxx[root]) root = x; &#125; vector&lt;pii> info; void getinfo(int x, int fa, int anc, int d) &#123; info.emplace_back(make_pair(d, anc)); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; getinfo(y, x, anc, d + G[x][i].second); &#125; &#125; void divide(int x) &#123; vis[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; getinfo(y, x, y, G[x][i].second); &#125; info.emplace_back(make_pair(0, x)); sort(info.begin(), info.end()); for (int i = 1; i &lt;= m; ++i) &#123; int l = 0, r = info.size() - 1; while (l &lt; r &amp;&amp; !ans[i]) &#123; if (info[l].first + info[r].first > k[i]) --r; else if (info[l].first + info[r].first &lt; k[i]) ++l; else &#123; if (info[l].second != info[r].second) ans[i] = true; if (info[l].first == info[l + 1].first) ++l; else --r; &#125; &#125; &#125; info.clear(); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].emplace_back(make_pair(v, w)); G[v].emplace_back(make_pair(u, w)); &#125; for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", k + i); maxx[0] = n + 1; froot(1, 0, n); divide(root); for (int i = 1; i &lt;= m; ++i) puts(ans[i] ? \"AYE\" :\"NAY\"); return 0; &#125; é™æ€è¾¹åˆ†æ²» æ¯æ¬¡åˆ†æ²»æ—¶æ‰¾ä¸€æ¡è¾¹ï¼Œç„¶åç»Ÿè®¡ç»è¿‡è¿™æ¡è¾¹çš„è·¯å¾„ï¼Œå†åˆ å»è¿™æ¡è¾¹é€’å½’ç»Ÿè®¡ã€‚å‘ç°å…¶æ›´å¥½åœ°å¯¹åº”äº†åºåˆ—åˆ†æ²»ï¼ˆåªåˆ†æˆäº†ä¸¤éƒ¨åˆ†ï¼‰ã€‚ ä¸‰åº¦åŒ– ä½†æ˜¯è¿™æ ·å¤æ‚åº¦æœ‰é—®é¢˜ï¼å¦‚æœæ ‘æ˜¯èŠèŠ±å›¾ï¼Œé‚£ä¹ˆå¯ä»¥è¢«å¡åˆ° O(n2)O(n^2)O(n2)ã€‚æ­¤æ—¶åº”è¯¥å¯¹è¯¥æ ‘è¿›è¡Œä¸‰åº¦åŒ–ï¼Œå¢åŠ è™šç‚¹æ¥è®©è¯¥èŠ‚ç‚¹çš„åº¦æ•°å˜ä¸º 333ã€‚ åŠ¨æ€ç‚¹åˆ†æ²» å…¶å¯ä»¥å¤„ç†å¸¦ä¿®é—®é¢˜ã€‚ ç‚¹åˆ†æ ‘ å¯¹äºä¸€ä¸ªèŠ‚ç‚¹ xxx é•¿é“¾å‰–åˆ† å°†å­æ ‘æ·±åº¦æœ€å¤§çš„å„¿å­ä½œä¸ºé‡å„¿å­ï¼ˆè™½ç„¶åº”è¯¥ä¸èƒ½å«è¿™ä¸ªåå­—ï¼‰ï¼Œæ‹¥æœ‰å¦‚ä¸‹æ€§è´¨ï¼š é“¾çš„è§„æ¨¡æ˜¯ O(n)O(\\sqrt{n})O(nâ€‹) çš„ã€‚ ä¸€ä¸ªèŠ‚ç‚¹çš„ kkk çº§ç¥–å…ˆæ‰€åœ¨é•¿é“¾çš„é•¿åº¦ä¸€å®šä¸å°äº kkkã€‚ æ¯ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„é•¿é“¾æœ«ç«¯æ˜¯å…¶å­æ ‘å†…çš„æœ€æ·±èŠ‚ç‚¹ã€‚ æ ‘ä¸Š k çº§ç¥–å…ˆ æ¨¡æ¿ã€‚ æœ€ç›´æ¥çš„æ–¹å¼å°±æ˜¯é‡é“¾å‰–åˆ†ï¼Œç„¶åå¦‚æœé“¾çš„é•¿åº¦ â‰¤k\\le kâ‰¤k å°±å¾€ä¸Šè·³ï¼Œå¦åˆ™ç›´æ¥è¾“å‡ºï¼ˆå› ä¸ºé‡é“¾ä¸Šçš„ DFS åºæ˜¯è¿ç»­çš„ï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n+qlogâ¡n)O(n+q\\log n)O(n+qlogn)ã€‚ è€ƒè™‘é•¿é“¾å‰–åˆ†ï¼Œå€å¢é¢„å¤„ç†å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„ 2k2^k2k çº§ç¥–å…ˆï¼Œå¹¶å¯¹äºæ¯æ¡é•¿é“¾æ±‚å‡ºå…¶ä»é¡¶ç«¯å‘ä¸Š/å‘ä¸‹èµ° iii æ­¥èƒ½èµ°åˆ°å“ªä¸ªèŠ‚ç‚¹ã€‚å¯¹äºè¯¢é—® x,kx,kx,kï¼Œå…ˆè·³åˆ° kkk çš„äºŒè¿›åˆ¶æœ€é«˜ä½ tttï¼Œå³ 2t2^t2t çº§çˆ¶äº²ã€‚è¿™æ ·å¯ä»¥å°† kkk ç¼©å‡ä¸€åŠï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥ä»é•¿é“¾é¡¶ç«¯æ ¹æ®æ·±åº¦å¼€è·³äº†ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n+q)O(n\\log n + q)O(nlogn+q)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define ui unsigned int #define i64 long long using namespace std; ui s; inline ui get(ui x) &#123; x ^= x &lt;&lt; 13; x ^= x >> 17; x ^= x &lt;&lt; 5; return s = x; &#125; int n, q, root, lg[500005]; int f[19][500005], dep[500005], h[500005]; int son[500005], top[500005]; vector&lt;int> G[500005], up[500005], down[500005]; void dfs1(int x) &#123; dep[x] = dep[f[0][x]] + 1; h[x] = 1; for (int i = 1; i &lt; 19; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) &#123; dfs1(y); h[x] = max(h[x], h[y] + 1); if (h[son[x]] &lt; h[y]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; if (x == topf) up[x].resize(h[x]), down[x].resize(h[x]); down[topf][dep[x] - dep[topf]] = x; top[x] = topf; if (son[x]) dfs2(son[x], topf); for (int y : G[x]) if (y != son[x]) dfs2(y, y); &#125; int main(void) &#123; scanf(\"%d%d%u\", &amp;n, &amp;q, &amp;s); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;f[0][i]); if (f[0][i] == 0) root = i; else G[f[0][i]].emplace_back(i); &#125; dfs1(root); dfs2(root, root); for (int i = 1; i &lt;= n; ++i) if (top[i] == i) // é•¿é“¾é¡¶ç«¯ for (int j = 0, cur = i; j &lt; h[i] &amp;&amp; cur; ++j, cur = f[0][cur]) up[i][j] = cur; i64 ans = 0; for (int last = 0, i = 1; i &lt;= q; ++i) &#123; int x = (get(s) ^ last) % n + 1, k = (get(s) ^ last) % dep[x]; x = (k == 0 ? x : f[lg[k]][x]), k -= (k == 0 ? 0 : (1 &lt;&lt; lg[k])); int t = top[x]; if (dep[x] - k >= dep[t]) last = down[t][dep[x] - k - dep[t]]; else last = up[t][dep[t] - dep[x] + k]; ans ^= 1ll * i * last; &#125; printf(\"%lld\\n\", ans); return 0; &#125; ä¼˜åŒ–æ·±åº¦ç›¸å…³çš„ DP Portal.ç»™å®šä¸€æ£µ n(nâ‰¤106)n(n\\le 10^6)n(nâ‰¤106) ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œè®¾ d(u,x)d(u,x)d(u,x) ä¸º uuu å­æ ‘ä¸­åˆ° uuu çš„è·ç¦»ä¸º xxx çš„èŠ‚ç‚¹æ•°ã€‚å¯¹äºæ¯ä¸ªç‚¹ï¼Œæ±‚æœ€å°çš„ kkk ä½¿ d(u,k)d(u,k)d(u,k) æœ€å¤§ã€‚ æˆ‘ä»¬åªå…³å¿ƒæ¯ä¸ªèŠ‚ç‚¹å†…æ·±åº¦ä¸º jjj çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œæ·±åº¦ç›¸åŒçš„èŠ‚ç‚¹æ˜¯ç­‰ä»·çš„ã€‚è®¾ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤ºå­æ ‘ iii å†…æ·±åº¦ä¸º jjj çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œåˆ™ fi,j=âˆ‘kâˆˆson(i)fk,jâˆ’1f_{i,j}=\\sum_{k\\in son(i)}f_{k,j-1}fi,jâ€‹=âˆ‘kâˆˆson(i)â€‹fk,jâˆ’1â€‹ã€‚ è€ƒè™‘é•¿é“¾å‰–åˆ†ä¼˜åŒ–ï¼šå¯¹äºé‡å„¿å­ï¼Œç›´æ¥ç»§æ‰¿å®ƒçš„ç­”æ¡ˆã€‚ç„¶ååˆå¹¶è½»å„¿å­çš„ç­”æ¡ˆï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šè¢«åˆå¹¶ä¸€æ¬¡ã€‚ å¯ä»¥çœ‹å‡ºï¼Œè¿™å®é™…ä¸Šæ˜¯åŸºäºé•¿é“¾å‰–åˆ†çš„æ ‘ä¸Šå¯å‘å¼åˆå¹¶ï¼Œå¦‚æœç‚¹åªæœ‰æ·±åº¦ä¿¡æ¯æœ‰ç”¨çš„æ—¶å€™å¯ä»¥ä½¿ç”¨ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, fa[1000005], h[1000005], son[1000005]; int *f[1000005], buf[1000005], *poi = buf; int ans[1000005], mx[1000005]; vector&lt;int> G[1000005]; void dfs1(int x, int ff) &#123; fa[x] = ff; h[x] = 1; for (int y : G[x]) if (y != ff) &#123; dfs1(y, x); h[x] = max(h[x], h[y] + 1); if (h[son[x]] &lt; h[y]) son[x] = y; &#125; &#125; void dfs2(int x) &#123; if (son[x]) f[son[x]] = f[x] + 1, dfs2(son[x]), mx[x] = mx[son[x]], ans[x] = ans[son[x]] + 1; // é•¿é“¾çš„ä¿®æ”¹ç›´æ¥ä¿®æ”¹è‡ªå·± for (int y : G[x]) if (y != fa[x] &amp;&amp; y != son[x]) &#123; f[y] = poi; poi += h[y]; dfs2(y); for (int i = 1; i &lt;= h[y]; ++i) &#123; f[x][i] += f[y][i - 1]; if (f[x][i] > mx[x] || f[x][i] == mx[x] &amp;&amp; ans[x] > i) mx[x] = f[x][i], ans[x] = i; &#125; &#125; f[x][0] = 1; if (mx[x] &lt;= 1) mx[x] = 1, ans[x] = 0; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(1, 0); f[1] = poi; poi += h[1]; dfs2(1); for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; æ€§è´¨ Problemset å¯èƒ½ä¼šæ¯”è¾ƒå¤šã€‚ æ ‘ä¸Šå¯å‘å¼åˆå¹¶ ä¸»è¦ç”¨äºå¤„ç†ä¸€äº›ç¦»çº¿ä¸å¸¦ä¿®æ”¹çš„é—®é¢˜ï¼Œè¿˜å¯ä»¥åŠæ‰“æ ‘ä¸Šè«é˜Ÿã€‚ [CF600E] Lomsat gelral Portal.n(nâ‰¤105)n(n\\le 10^5)n(nâ‰¤105) æ ‘çš„èŠ‚ç‚¹æœ‰é¢œè‰²ï¼Œä¸€ç§é¢œè‰²å é¢†äº†ä¸€ä¸ªå­æ ‘ï¼Œå½“ä¸”ä»…å½“æ²¡æœ‰å…¶ä»–é¢œè‰²åœ¨è¿™ä¸ªå­æ ‘ä¸­å‡ºç°å¾—æ¯”å®ƒå¤šï¼ˆå½“ç„¶å¯èƒ½æœ‰å¤šä¸ªï¼‰ã€‚æ±‚å é¢†æ¯ä¸ªå­æ ‘çš„æ‰€æœ‰é¢œè‰²ç¼–å·ä¹‹å’Œã€‚ å‡ ä¹æ˜¯æ ‘ä¸Šå¯å‘å¼åˆå¹¶çš„æ¿å­ï¼Œåœ¨åŠ å…¥çš„æ—¶å€™é‡æ–°ç»Ÿè®¡ç­”æ¡ˆï¼Œæ¸…ç©ºçš„æ—¶å€™ç›´æ¥å°†ç­”æ¡ˆæ¸…é›¶å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int c[100005], son[100005], siz[100005]; int L[100005], R[100005], idx[100005], num = 0; vector&lt;int> G[100005]; void dfs1(int x, int fa) &#123; L[x] = ++num; idx[num] = x; siz[x] = 1; int max_part = -1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > max_part) max_part = siz[y], son[x] = y; &#125; R[x] = num; &#125; int cnt[100005]; i64 ans[100005], nowAns, maxcnt; void add(int x) &#123; ++cnt[c[x]]; if (cnt[c[x]] > maxcnt) maxcnt = cnt[nowAns = c[x]]; else if (cnt[c[x]] == maxcnt) nowAns += c[x]; &#125; void dfs2(int x, int fa, bool keep) &#123; for (int y : G[x]) if (y != fa &amp;&amp; y != son[x]) dfs2(y, x, false); if (son[x] != -1) dfs2(son[x], x, true); for (int y : G[x]) if (y != fa &amp;&amp; y != son[x]) for (int i = L[y]; i &lt;= R[y]; ++i) add(idx[i]); add(x); ans[x] = nowAns; if (!keep) &#123; for (int i = L[x]; i &lt;= R[x]; ++i) --cnt[c[idx[i]]]; maxcnt = nowAns = 0; &#125; &#125; int main(void) &#123; memset(son, -1, sizeof(son)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", c + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs1(1, 0); dfs2(1, 0, 1); for (int i = 1; i &lt;= n; ++i) printf(\"%lld \", ans[i]); putchar('\\n'); return 0; &#125; Kruskal é‡æ„æ ‘ èƒ½é«˜æ•ˆè§£å†³è·¯å¾„æœ€å€¼çš„ç›¸å…³é—®é¢˜ã€‚ [NOI2018] å½’ç¨‹ Portal. å¯¹å›¾å»ºç«‹å‡º Kruskal é‡æ„æ ‘ï¼Œæ»¡è¶³çš„ç‚¹å°±æ˜¯é€‰æ‹©çš„å‡ºå‘ç‚¹è·³åˆ°æ»¡è¶³æ¡ä»¶çš„æœ€æµ…çš„ç‚¹ï¼Œé¢„å¤„ç†å‡ºå­æ ‘å†…æœ€çŸ­è·¯çš„æœ€å°å€¼å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; struct edge &#123; int u, v, w; bool operator &lt; (const edge &amp;a) const &#123; return w > a.w; &#125; &#125; e[400005]; struct Dijkstra &#123; bool v[200005]; int d[200005]; vector&lt;pair&lt;int, int>> G[200005]; void dijkstra(void) &#123; memset(v, 0, sizeof(v)); memset(d, 0x3f, sizeof(d)); #define pii pair&lt;int, int> priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.push(&#123;d[1] = 0, 1&#125;); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (v[u]) continue; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int to = G[u][i].first, w = G[u][i].second; if (d[to] > d[u] + w) q.push(&#123;d[to] = d[u] + w, to&#125;); &#125; &#125; &#125; &#125; Solver; int bin[400005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; vector&lt;int> G[400005]; int d[400005], a[400005]; int dep[400005], f[21][400005]; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; f[0][x] = fa; d[x] = (x &lt;= n ? Solver.d[x] : 1e9); for (int i = 1; i &lt;= 20; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x), d[x] = min(d[x], d[y]); &#125; int query(int x, int y) &#123; for (int i = 20; i >= 0; --i) if (a[f[i][x]] > y) x = f[i][x]; return d[x]; &#125; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) Solver.G[i].clear(); for (int i = 1; i &lt;= n &lt;&lt; 1; ++i) bin[i] = i, a[i] = 0, G[i].clear(); for (int i = 1; i &lt;= m; ++i) &#123; int u, v, l, a; scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;l, &amp;a); Solver.G[u].emplace_back(make_pair(v, l)); Solver.G[v].emplace_back(make_pair(u, l)); e[i].u = u, e[i].v = v, e[i].w = a; &#125; Solver.dijkstra(); sort(e + 1, e + m + 1); int tot = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v, w = e[i].w; int x = find(u), y = find(v); if (x == y) continue; a[++tot] = w; bin[x] = tot; bin[y] = tot; G[x].emplace_back(tot); G[tot].emplace_back(x); G[y].emplace_back(tot); G[tot].emplace_back(y); &#125; dfs(tot, 0); int q, k, s, last; scanf(\"%d%d%d\", &amp;q, &amp;k, &amp;s); while (q--) &#123; int v, p; scanf(\"%d%d\", &amp;v, &amp;p); v = (v + k * last - 1) % n + 1; p = (p + k * last) % (s + 1); printf(\"%d\\n\", last = query(v, p)); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [IOI2018] Werewolf Portal. æ˜¯é’ˆå¯¹ç‚¹æƒé™åˆ¶çš„ Kruskal é‡æ„æ ‘ã€‚å»ºç«‹ä¸€ä¸ª LLL æ¥ä»£è¡¨å­æ ‘ä¸­éƒ½æ¯”å®ƒå°ï¼ŒRRR æ¥ä»£è¡¨å­æ ‘ä¸­éƒ½æ¯”å®ƒå¤§ã€‚å°† sss åœ¨ RRR ä¸Šå€å¢åˆ° aâ‰¥la\\ge laâ‰¥l çš„æœ€å° aaaï¼Œå°† eee åœ¨ LLL ä¸Šå€å¢åˆ° bâ‰¤rb\\le rbâ‰¤r çš„æœ€å¤§ bbbï¼Œç„¶åå°±æ˜¯è¯¢é—®è¿™ä¸¤ä¸ªå­æ ‘æœ‰æ²¡æœ‰å…¬å…±çš„å­èŠ‚ç‚¹ï¼Œå°±æ˜¯äºŒç»´æ•°ç‚¹é—®é¢˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, q, idx[200005]; vector&lt;int> G[200005]; vector&lt;pair&lt;int, int>> E[200005]; struct Tree &#123; int bin[200005], f[21][200005]; int dfn[200005], num, siz[200005]; vector&lt;int> G[200005]; int find(int x) &#123; return bin[x] == x ? x : bin[x] = find(bin[x]); &#125; void init(void) &#123; for (int i = 1; i &lt;= n; ++i) bin[i] = i; &#125; void merge(int u, int v) &#123; // å°† v çš„ç¥–å…ˆè®¾ç½®ä¸º u v = find(v); if (u == v) return; bin[v] = u; f[0][v] = u; G[u].emplace_back(v); &#125; void dfs(int x, int fa) &#123; siz[x] = 1; dfn[x] = ++num; for (int i = 1; i &lt;= 20; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) dfs(y, x), siz[x] += siz[y]; &#125; int query(int x, int lim, bool t) &#123; // å°† x è·³åˆ° t = 1 åˆ™è·³åˆ°ç¬¬ä¸€ä¸ª >= limï¼Œt = 0 è·³åˆ°ç¬¬ä¸€ä¸ª &lt;= lim for (int i = 20; i >= 0; --i) if (f[i][x] &amp;&amp; (t ? f[i][x] >= lim : f[i][x] &lt;= lim)) x = f[i][x]; return x; &#125; &#125; L, R; // L é™åˆ¶æœ€å¤§å€¼ï¼ŒR é™åˆ¶æœ€å°å€¼ int C[200005], ans[200005], ql[200005], qr[200005]; void add(int x) &#123; for (; x &lt;= n; x += x &amp; -x) ++C[x]; &#125; int query(int x) &#123; int s = 0; for (; x; x -= x &amp; -x) s += C[x]; return s; &#125; int query(int x, int y) &#123; return query(y) - query(x - 1); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); ++u, ++v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; L.init(); R.init(); for (int u = 1; u &lt;= n; ++u) for (int v : G[u]) if (u > v) L.merge(u, v); for (int u = n; u >= 1; --u) for (int v : G[u]) if (u &lt; v) R.merge(u, v); L.dfs(n, 0); R.dfs(1, 0); for (int i = 1; i &lt;= n; ++i) idx[L.dfn[i]] = R.dfn[i]; for (int i = 1; i &lt;= q; ++i) &#123; int s, e, l, r; scanf(\"%d%d%d%d\", &amp;s, &amp;e, &amp;l, &amp;r); ++s, ++e, ++l, ++r; s = R.query(s, l, 1); e = L.query(e, r, 0); E[L.dfn[e] - 1].emplace_back(i, -1); E[L.dfn[e] + L.siz[e] - 1].emplace_back(i, 1); ql[i] = R.dfn[s], qr[i] = R.dfn[s] + R.siz[s] - 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; add(idx[i]); for (auto [x, flag] : E[i]) ans[x] += query(ql[x], qr[x]) * flag; &#125; for (int i = 1; i &lt;= q; ++i) printf(\"%d\\n\", ans[i] > 0); return 0; &#125; [CF1583H] Omkar and Tours Portal. ç¬¬ä¸€é—®æ¯”è¾ƒç»å…¸ï¼Œç¦»çº¿ï¼Œå°†è¯¢é—®æŒ‰ç…§ vvv ä»å¤§åˆ°å°æ’åºï¼Œä¾æ¬¡åŠ å…¥è¾¹ï¼ŒDFS åˆå¹¶è¿é€šå—ï¼Œç»´æŠ¤æœ€å¤§å€¼å³å¯ã€‚ ç¬¬äºŒé—®ï¼Œå¸Œæœ›è·¯å¾„ä¸Š ttt çš„æœ€å¤§å€¼å°½å¯èƒ½å¤§ï¼ŒKruskal é‡æ„æ ‘ï¼å»ºç«‹ä¸€æ£µåŸºäº ttt çš„è¾¹æƒé‡æ„æ ‘ã€‚è®¾èƒ½åˆ°è¾¾çš„èŠ‚ç‚¹æ˜¯ yyyï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º maxâ¡{aLCAâ¡(x,y)}\\max\\{a_{\\operatorname{LCA}(x,y)}\\}max{aLCA(x,y)â€‹}ã€‚ ç”±äº LCA å¿…å®šåœ¨ xxx åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¸Œæœ›è¯¥ LCA çš„æ·±åº¦å°½å¯èƒ½å°ã€‚ä»€ä¹ˆæ—¶å€™æ»¡è¶³å‘¢ï¼Ÿå°†æ‰€æœ‰ yyy æŒ‰ç…§ DFS åºæ’åºï¼Œå…¶ä¸­ DFS åºæœ€å°å’Œæœ€å¤§çš„å¯èƒ½ç§°ä¸ºç­”æ¡ˆï¼ˆKruskal é‡æ„æ ‘æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œæƒ³è¦ LCA ç¦» xxx è¶Šè¿œï¼Œé‚£ä¹ˆ yyy å°±å¿…å®šç¦» xxx è¶Šè¿œï¼Œä¹Ÿå°±æ˜¯ DFS åºå·®è¶Šå¤§ï¼‰ã€‚ å®ç°ä¸Šåªéœ€è¦å…ˆå»ºå‡º Kruskal é‡æ„æ ‘ï¼Œç„¶ååœ¨ç¬¬ä¸€é—®æ—¶å¹¶æŸ¥é›†ç»´æŠ¤ DFS åºæœ€å¤§æœ€å°å€¼ã€‚æ—¶é—´å¤æ‚åº¦åœ¨ O(nlogâ¡n)O(n\\log n)O(nlogn) çº§åˆ«ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, q, ans1[200005], ans2[200005]; int a[200005]; struct Query &#123; int v, x, id; bool operator&lt; (const Query &amp;a) const &#123; return v > a.v; &#125; &#125; Q[200005]; struct edge &#123; int a, b, c, t; bool operator&lt; (const edge &amp;a) const &#123; return c > a.c; &#125; &#125; e[200005]; vector&lt;int> G[400005]; int bin[400005], val[400005], mx[200005], mn[200005]; int find(int x) &#123; return bin[x] == x ? x : bin[x] = find(bin[x]); &#125; int dfn[400005], num, mi[19][400005], lg[400005], idx[400005]; inline int get(int x, int y) &#123; return dfn[x] &lt; dfn[y] ? x : y; &#125; void dfs(int x, int fa) &#123; mi[0][dfn[x] = ++num] = fa; idx[num] = x; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; inline int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> q; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1; i &lt;= n * 2; ++i) bin[i] = i; for (int i = 2; i &lt;= n * 2; ++i) lg[i] = lg[i >> 1] + 1; // å»ºç«‹ Kruskal é‡æ„æ ‘ for (int i = 1; i &lt; n; ++i) cin >> e[i].a >> e[i].b >> e[i].c >> e[i].t; sort(e + 1, e + n, [&amp;](edge a, edge b) &#123; return a.t &lt; b.t; &#125;); int tot = n; for (int i = 1; i &lt; n; ++i) &#123; int u = find(e[i].a), v = find(e[i].b); val[++tot] = e[i].t; bin[u] = bin[v] = tot; G[tot].emplace_back(u); G[u].emplace_back(tot); G[tot].emplace_back(v); G[v].emplace_back(tot); &#125; dfs(tot, 0); for (int i = 1; i &lt;= lg[n * 2]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n * 2 - 1; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1; i &lt;= q; ++i) cin >> Q[i].v >> Q[i].x, Q[i].id = i; for (int i = 1; i &lt;= n; ++i) bin[i] = i, val[i] = a[i], mn[i] = mx[i] = dfn[i]; sort(e + 1, e + n); sort(Q + 1, Q + q + 1); for (int i = 1, j = 0; i &lt;= q; ++i) &#123; while (j &lt; n - 1 &amp;&amp; e[j + 1].c >= Q[i].v) &#123; ++j; int u = find(e[j].a), v = find(e[j].b); if (val[u] == val[v]) mx[v] = max(mx[v], mx[u]); else mx[v] = val[u] > val[v] ? mx[u] : mx[v]; if (val[u] == val[v]) mn[v] = min(mn[v], mn[u]); else mn[v] = val[u] > val[v] ? mn[u] : mn[v]; val[v] = max(val[v], val[u]); bin[u] = v; &#125; int id = Q[i].id, x = Q[i].x, u = find(x); ans1[id] = val[u]; if (idx[mx[u]] != x) ans2[id] = max(ans2[id], val[LCA(x, idx[mx[u]])]); if (idx[mn[u]] != x) ans2[id] = max(ans2[id], val[LCA(x, idx[mn[u]])]); &#125; for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; ans1[i] &lt;&lt; \" \" &lt;&lt; ans2[i] &lt;&lt; \"\\n\"; return 0; &#125; è™šæ ‘ è¿™é‡Œçš„ä¸ä¼šå¾ˆéš¾ï¼Œéš¾çš„è™šæ ‘ä¼šå’Œåˆ«çš„æ ‘ä¸Šç®—æ³•ç»¼åˆã€‚ [HEOI2014] å¤§å·¥ç¨‹ Portal. å»ºå‡ºè™šæ ‘åè¿›è¡Œ DPï¼Œè®¾ szx,mnx,mxxsz_x,mn_x,mx_xszxâ€‹,mnxâ€‹,mxxâ€‹ åˆ†åˆ«ä»£è¡¨å­æ ‘å†…å…³é”®ç‚¹ä¸ªæ•°ï¼Œå½“å‰èŠ‚ç‚¹åˆ°å…³é”®ç‚¹çš„æœ€å°å’Œæœ€å¤§è·ç¦»ï¼Œç”¨å®ƒä»¬æ›´æ–° ansansans å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k, q, lg[1000005], p[1000005]; int dep[1000005]; int dfn[1000005], num, mi[20][1000005]; vector&lt;int> G[1000005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; mi[0][dfn[x] = ++num] = fa; dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int st[1000005], tot, ans2, ans3; i64 ans1; int sz[1000005], mx[1000005], mn[1000005]; vector&lt;int> E[1000005]; inline void addedge(int x, int y) &#123; E[x].emplace_back(y); E[y].emplace_back(x); &#125; void dp(int x, int fa) &#123; for (int y : E[x]) if (y != fa) &#123; dp(y, x); int d = dep[y] - dep[x]; ans1 += 1ll * sz[y] * (k - sz[y]) * d; ans2 = min(ans2, mn[x] + mn[y] + d); ans3 = max(ans3, mx[x] + mx[y] + d); mn[x] = min(mn[x], mn[y] + d); mx[x] = max(mx[x], mx[y] + d); sz[x] += sz[y]; &#125; E[x].clear(); &#125; void build_tree(void) &#123; sort(p + 1, p + k + 1, [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;); st[tot = 1] = 1; if (p[1] != 1) sz[1] = 0, mn[1] = 1e9, mx[1] = -1e9; for (int i = 1; i &lt;= k; ++i) if (p[i] != 1) &#123; int lca = LCA(st[tot], p[i]); while (tot > 1 &amp;&amp; dep[lca] &lt;= dep[st[tot - 1]]) addedge(st[tot - 1], st[tot]), --tot; if (lca != st[tot]) &#123; sz[lca] = 0; mn[lca] = 1e9; mx[lca] = -1e9; addedge(lca, st[tot]), st[tot] = lca; &#125; st[++tot] = p[i]; &#125; for (int i = 1; i &lt; tot; ++i) addedge(st[i], st[i + 1]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); scanf(\"%d\", &amp;q); while (q--) &#123; scanf(\"%d\", &amp;k); ans1 = ans3 = 0, ans2 = 1e9; for (int i = 1; i &lt;= k; ++i) scanf(\"%d\", p + i), sz[p[i]] = 1, mn[p[i]] = mx[p[i]] = 0; build_tree(); dp(1, 0); printf(\"%lld %d %d\\n\", ans1, ans2, ans3); &#125; return 0; &#125; [CF613D] Kingdom and its Cities Portal. é¦–å…ˆå¦‚æœå…³é”®ç‚¹ç›¸é‚»ç›´æ¥æ— è§£ï¼Œå¦åˆ™è®¾è®¡ DPï¼šg(x)g(x)g(x) ä¸ºä»¥ xxx ä¸ºæ ¹ï¼Œå­æ ‘å†…æ˜¯å¦æœ‰å…³èŠ‚ç‚¹ï¼›f(x)f(x)f(x) ä¸ºä»¥ xxx ä¸ºæ ¹çš„ç­”æ¡ˆã€‚ å¦‚æœ xxx æ˜¯å…³é”®ç‚¹ï¼Œé‚£ä¹ˆå„¿å­å†…æœ‰å…³é”®ç‚¹çš„éœ€è¦å…¨éƒ¨æ–­æ‰ã€‚è‹¥ä¸æ˜¯å…³é”®ç‚¹ï¼Œå„¿å­å†…æœ‰è¶…è¿‡ä¸¤ä¸ªå…³é”®ç‚¹åˆ™ç›´æ¥åˆ æ‰è‡ªå·±ï¼ˆå¦åˆ™å°±è¿ä¸Šäº†ï¼‰ï¼Œå¦åˆ™å¯ä»¥ç•™åˆ°çˆ¶äº²å¤„å†åšè€ƒè™‘ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, k, p[100005], lg[100005]; int tot, st[100005], tag[100005], fa[100005]; int dfn[100005], num, mi[17][100005], dep[100005]; vector&lt;int> E[100005], G[100005]; inline void addedge(int x, int y) &#123; G[x].emplace_back(y); G[y].emplace_back(x); &#125; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int ff) &#123; mi[0][dfn[x] = ++num] = ff; fa[x] = ff; dep[x] = dep[ff] + 1; for (int y : E[x]) if (y != ff) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int f[100005], g[100005]; void build_tree(void) &#123; sort(p + 1, p + k + 1, [](int x, int y)&#123; return dfn[x] &lt; dfn[y]; &#125;); st[tot = 1] = 1; f[1] = g[1] = 0; for (int i = 1; i &lt;= k; ++i) if (p[i] != 1) &#123; int lca = LCA(st[tot], p[i]); while (tot > 1 &amp;&amp; dep[lca] &lt;= dep[st[tot - 1]]) addedge(st[tot - 1], st[tot]), --tot; if (lca != st[tot]) addedge(lca, st[tot]), st[tot] = lca, f[lca] = g[lca] = 0; st[++tot] = p[i]; &#125; for (int i = 1; i &lt; tot; ++i) addedge(st[i], st[i + 1]); &#125; void dp(int x, int fa) &#123; int num = 0; for (int y : G[x]) if (y != fa) &#123; dp(y, x); f[x] += f[y]; num += g[y]; &#125; if (tag[x]) f[x] += num, g[x] = 1; // å°†å„¿å­å…¨æ–­æ‰ else if (num > 1) ++f[x], g[x] = 0; else g[x] = num; G[x].clear(); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v); E[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); scanf(\"%d\", &amp;m); while (m--) &#123; scanf(\"%d\", &amp;k); for (int i = 1; i &lt;= k; ++i) scanf(\"%d\", p + i), tag[p[i]] = 1, f[p[i]] = g[p[i]] = 0; for (int i = 1; i &lt;= k; ++i) if (tag[fa[p[i]]]) &#123; puts(\"-1\"); goto over; &#125; build_tree(); dp(1, 0); printf(\"%d\\n\", f[1]); over: for (int i = 1; i &lt;= k; ++i) tag[p[i]] = 0; &#125; return 0; &#125; æ ‘ä¸Šåˆ†æ²»ç®—æ³• éƒ¨åˆ†é¢˜ç›®ç›¸å½“å¤æ‚ï¼Œä½†æ˜¯å¯¹è®­ç»ƒéå¸¸æœ‰ç›Šã€‚ [Luogu P4178] Tree Portal. ä¼¼ä¹ä½¿ç”¨åŒæŒ‡é’ˆè®¡ç®—æ¯”è¾ƒéš¾é˜²æ­¢ç®—é‡åŒä¸€æ£µå­æ ‘å†…çš„ç‚¹ï¼Œäºæ˜¯æˆ‘ä»¬åœ¨é‡‡é›†å­æ ‘ä¿¡æ¯çš„æ—¶å€™ç›´æ¥ç®—ä¸€éå­æ ‘å†…çš„è´¡çŒ®ï¼Œå‡å»å®ƒå°±å¥½äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; typedef pair&lt;int, int> pii; int n, k, root, siz[40005], mx[40005], ans = 0; bool vis[40005]; vector&lt;pii> G[40005]; void froot(int x, int fa, int tot) &#123; siz[x] = 1; mx[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; froot(y, x, tot); siz[x] += siz[y]; mx[x] = max(mx[x], siz[y]); &#125; mx[x] = max(mx[x], tot - siz[x]); if (mx[root] > mx[x]) root = x; &#125; int calc(vector&lt;int> &amp;val) &#123; int res = 0; sort(val.begin(), val.end()); for (int l = 0, r = val.size() - 1; l &lt; r; ++l) &#123; while (l &lt; r &amp;&amp; val[l] + val[r] > k) --r; res += r - l; &#125; return res; &#125; vector&lt;int> val, t; void getinfo(int x, int fa, int anc, int d) &#123; t.push_back(d); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; getinfo(y, x, anc, d + G[x][i].second); &#125; &#125; void divide(int x) &#123; vis[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; t.clear(); getinfo(y, x, y, G[x][i].second); ans -= calc(t); for (int z : t) val.push_back(z); &#125; val.push_back(0); ans += calc(val); val.clear(); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); mx[0] = n + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].push_back(&#123;v, w&#125;); G[v].push_back(&#123;u, w&#125;); &#125; scanf(\"%d\", &amp;k); froot(1, 0, n); divide(root); printf(\"%d\\n\", ans); return 0; &#125; [IOI2011] Race Portal. ç”±äº kkk ä¸æ˜¯å¾ˆå¤§ï¼Œå¼€ä¸€ä¸ªæ¡¶è®°å½•æƒå€¼å¯¹åº”çš„æœ€å°è¾¹æ•°å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> #include &lt;cstring> using namespace std; const int MAXD = 1000005; typedef pair&lt;int, int> pii; int n, k, ans, root; int siz[200005], maxx[200005]; int buc[1000005]; bool vis[200005]; vector&lt;pii> G[200005]; void froot(int x, int fa, int tot) &#123; siz[x] = 1; maxx[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; froot(y, x, tot); siz[x] += siz[y]; maxx[x] = max(maxx[x], siz[y]); &#125; maxx[x] = max(maxx[x], tot - siz[x]); if (maxx[x] &lt; maxx[root]) root = x; &#125; vector&lt;pii> f[200005]; void getinfo(int x, int fa, int anc, int d, int cnt) &#123; f[anc].emplace_back(make_pair(d, cnt)); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y] || y == fa) continue; getinfo(y, x, anc, min(MAXD, d + G[x][i].second), cnt + 1); &#125; &#125; void divide(int x) &#123; vis[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; getinfo(y, x, y, G[x][i].second, 1); for (pii info : f[y]) &#123; int dis = info.first, w = info.second; if (dis &lt;= k) ans = min(ans, buc[k - dis] + w); &#125; for (pii info : f[y]) &#123; int dis = info.first, w = info.second; if (dis &lt;= k) buc[dis] = min(buc[dis], w); &#125; &#125; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; for (pii info : f[y]) buc[info.first] = 0x3f3f3f3f; f[y].clear(); &#125; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); memset(buc, 0x3f, sizeof(buc)); buc[0] = 0; for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); ++u, ++v; G[u].emplace_back(make_pair(v, w)); G[v].emplace_back(make_pair(u, w)); &#125; ans = maxx[0] = n + 1; froot(1, 0, n); divide(root); if (ans == n + 1) puts(\"-1\"); else printf(\"%d\\n\", ans); return 0; &#125; [çœé€‰è”è€ƒ 2020 B å·] æ¶ˆæ¯ä¼ é€’ Portal. æˆ‘ä»¬ç»™æ‰€æœ‰èŠ‚ç‚¹å¼€ä¸€ä¸ª vector æ¥ä¿å­˜è¯¢é—®ï¼Œç„¶åå¯¹ä¼ æ’­è·¯å¾„æ˜¯å¦ç»è¿‡å½“å‰ç‚¹ xxx è¿›è¡Œåˆ†æ²»ã€‚è·å–å­æ ‘ä¿¡æ¯æ—¶ï¼Œæˆ‘ä»¬å°†å½“å‰è·ç¦» ddd åŠ åœ¨ä¸€ä¸ªæ¡¶ä¸­ï¼Œæ¯æ‰«æåˆ°ä¸€ä¸ªèŠ‚ç‚¹ iii éƒ½æŸ¥çœ‹å½“å‰èŠ‚ç‚¹çš„è¯¢é—®ï¼Œå®ƒåº”è¯¥æ»¡è¶³ kâ‰¥dk\\ge dkâ‰¥dï¼Œåœ¨è·å–å®Œæ‰€æœ‰ä¿¡æ¯ååœ¨æ¡¶ä¸­æŸ¥ kâˆ’dk-dkâˆ’d çš„æ•°é‡æ¥è·å–ç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, root, siz[100005], maxx[100005], ans[100005]; bool vis[100005]; vector&lt;int> G[100005]; vector&lt;pair&lt;int, int>> Q[100005]; // x, id void froot(int x, int fa, int tot) &#123; siz[x] = 1; maxx[x] = 0; for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) &#123; froot(y, x, tot); siz[x] += siz[y]; maxx[x] = max(maxx[x], siz[y]); &#125; maxx[x] = max(maxx[x], tot - siz[x]); if (maxx[x] &lt; maxx[root]) root = x; &#125; vector&lt;pair&lt;int, int> > info; int buc[100005], maxd; void getinfo(int x, int fa, int d) &#123; ++buc[d]; maxd = max(d, maxd); for (auto [k, id] : Q[x]) if (k - d >= 0) info.emplace_back(k - d, id); // æ‰¾å½“å‰è¿™ä¸ªç‚¹çš„è¯¢é—® for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) getinfo(y, x, d + 1); &#125; void divide(int x) &#123; vis[x] = true; for (int y : G[x]) if (!vis[y]) &#123; getinfo(y, x, 1); for (auto [k, id] : info) ans[id] -= buc[k]; for (int i = 0; i &lt;= maxd; ++i) buc[i] = 0; maxd = 0; info.clear(); &#125; getinfo(x, 0, 0); for (auto [k, id] : info) ans[id] += buc[k]; for (int i = 0; i &lt;= maxd; ++i) buc[i] = 0; maxd = 0; info.clear(); for (int y : G[x]) if (!vis[y]) &#123; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); maxx[0] = n + 1; for (int i = 1; i &lt;= n; ++i) G[i].clear(), Q[i].clear(), vis[i] = 0; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x, k; scanf(\"%d%d\", &amp;x, &amp;k); Q[x].emplace_back(k, i); ans[i] = 0; &#125; root = 0; froot(1, 0, n); divide(root); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); &#125; return 0; &#125; [SDOI2016] æ¨¡å¼å­—ç¬¦ä¸² Portal. ç‚¹åˆ†æ²»ï¼Œç„¶åä½¿ç”¨å­—ç¬¦ä¸² Hash æ¥åˆ¤æ–­æ˜¯å¦èƒ½ä½œä¸ºæ¨¡å¼ä¸²çš„å‰åç¼€ï¼Œç„¶åç”¨ä¸€ä¸ªæ¡¶æ¥ç»Ÿè®¡è¿›è¡Œç­”æ¡ˆåˆå¹¶ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; const int N = 1000000; typedef unsigned long long u64; int n, m, root, ans; char s[1000005], t[1000005]; int maxx[1000005], siz[1000005], buc[1000005]; u64 poww[1000005], pre[1000005], suf[1000005]; bool vis[1000005]; vector&lt;int> G[1000005]; void froot(int x, int fa, int tot) &#123; siz[x] = 1; maxx[x] = 0; for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) &#123; froot(y, x, tot); siz[x] += siz[y]; maxx[x] = max(maxx[x], siz[y]); &#125; maxx[x] = max(maxx[x], tot - siz[x]); if (maxx[x] &lt; maxx[root]) root = x; &#125; int calc(vector&lt;int> &amp;x, vector&lt;int> &amp;y) &#123; int res = 0; for (int it : x) ++buc[1 + (it - 1) % m]; for (int it : y) res += buc[m - (it - 1) % m]; for (int it : x) --buc[1 + (it - 1) % m]; return res; &#125; vector&lt;int> p, q, pt, qt; void getinfo(int x, int fa, u64 hash, int dep) &#123; hash += s[x] * poww[dep - 1]; if (pre[dep] == hash) pt.emplace_back(dep); if (suf[dep] == hash) qt.emplace_back(dep); for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) getinfo(y, x, hash, dep + 1); &#125; void divide(int x) &#123; vis[x] = true; p.clear(); q.clear(); if (s[x] == t[1]) p.emplace_back(1); if (s[x] == t[m]) q.emplace_back(1); for (int y : G[x]) if (!vis[y]) &#123; getinfo(y, x, s[x], 2); ans -= calc(pt, qt); for (int it : pt) p.emplace_back(it); for (int it : qt) q.emplace_back(it); pt.clear(); qt.clear(); &#125; ans += calc(p, q); for (int y : G[x]) if (!vis[y]) &#123; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; void solve(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, s + 1); maxx[0] = n + 1; for (int i = 1; i &lt;= n; ++i) G[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; scanf(\"%s\", t + 1); for (int i = 1; i &lt;= n; ++i) &#123; pre[i] = pre[i - 1] * 239 + t[1 + (i - 1) % m]; suf[i] = suf[i - 1] * 239 + t[m - (i - 1) % m]; &#125; memset(vis, 0, sizeof(vis)); ans = root = 0; froot(1, 0, n); divide(root); printf(\"%d\\n\", ans); &#125; int main(void) &#123; for (int i = poww[0] = 1; i &lt;= N; ++i) poww[i] = poww[i - 1] * 239; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [CF914E] Palindromes in a Tree Portal. åªè¦å‡ºç°å¥‡æ•°æ¬¡çš„å­—ç¬¦æœ€å¤šåªæœ‰ä¸€ä¸ªï¼Œé‚£ä¹ˆå°±å¯ä»¥é‡æ’ä¸ºå›æ–‡ï¼Œå¯ä»¥çŠ¶å‹æ¥ç»Ÿè®¡å­—ç¬¦çš„å¥‡å¶æ€§ã€‚ å¯¹å›æ–‡è·¯å¾„æ˜¯å¦ç»è¿‡ç‚¹ pospospos è¿›è¡Œç‚¹åˆ†æ²»ï¼Œè·å–å­æ ‘çŠ¶å‹çš„å­—ç¬¦ä¿¡æ¯æ”¾åœ¨ vector é‡Œï¼Œåœ¨ç»Ÿè®¡ç­”æ¡ˆæ—¶å°†å¼‚æˆ–ä¿¡æ¯æ”¾åœ¨æ¡¶é‡Œã€‚ç‚¹çš„ç­”æ¡ˆè¦åŠ ä¸Šå­æ ‘çš„ç­”æ¡ˆï¼Œå› ä¸ºå­æ ‘çš„å›æ–‡è·¯å¾„ä¹Ÿä¼šç»è¿‡è¿™ä¸ªç‚¹ã€‚ å­æ ‘çš„ä¼šç®—é‡ï¼Œå› æ­¤æå‰å‡å»ã€‚åˆ†æ²»é‡å¿ƒçš„ç­”æ¡ˆçš„ä¸¤ä¸ªç«¯ç‚¹åœ¨ä¸åŒå­æ ‘ç­”æ¡ˆä¼šç®—é‡ï¼Œå› æ­¤é™¤ä»¥äºŒã€‚åˆ†æ²»é‡å¿ƒè‡ªå·±ä¹Ÿå¯ä»¥ç§°ä¸ºç­”æ¡ˆï¼Œè¦åŠ ä¸€ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, root, mx[200005], siz[200005]; i64 ans[200005], d[200005]; char s[200005]; bool vis[200005]; vector&lt;int> G[200005]; void froot(int x, int fa, int tot) &#123; mx[x] = 0; siz[x] = 1; for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) &#123; froot(y, x, tot); siz[x] += siz[y]; mx[x] = max(mx[x], siz[y]); &#125; mx[x] = max(mx[x], tot - siz[x]); if (mx[x] &lt; mx[root]) root = x; &#125; int buc[1 &lt;&lt; 20]; void calc(vector&lt;pair&lt;int, int>> &amp;a, int flag, int msk) &#123; for (auto it : a) buc[it.first] += flag; for (auto [x, pos] : a) &#123; int cnt = buc[x ^ msk]; // æ’æ‰åˆ†æ²»ä¸­å¿ƒç»Ÿè®¡å¦ä¸€ç«¯ for (int i = 0; i &lt; 20; ++i) cnt += buc[x ^ msk ^ (1 &lt;&lt; i)]; d[pos] += cnt; &#125; for (auto it : a) buc[it.first] = 0; &#125; vector&lt;pair&lt;int, int>> info, q; void getinfo(int x, int fa, int msk) &#123; d[x] = 0; msk ^= 1 &lt;&lt; s[x]; q.emplace_back(msk, x); for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) getinfo(y, x, msk); &#125; void getans(int x, int fa) &#123; for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) &#123; getans(y, x); d[x] += d[y]; &#125; if (!fa) d[x] = d[x] / 2 + 1; ans[x] += d[x]; &#125; void divide(int x) &#123; vis[x] = 1; d[x] = 0; int msk = 1 &lt;&lt; s[x]; for (int y : G[x]) if (!vis[y]) &#123; getinfo(y, x, msk); calc(q, -1, msk); for (auto tmp : q) info.emplace_back(tmp); q.clear(); &#125; info.emplace_back(msk, x); calc(info, 1, msk); info.clear(); getans(x, 0); for (int y : G[x]) if (!vis[y]) &#123; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); mx[0] = n + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; scanf(\"%s\", s + 1); for (int i = 1; i &lt;= n; ++i) s[i] -= 'a'; froot(1, 0, n); divide(root); for (int i = 1; i &lt;= n; ++i) printf(\"%lld \", ans[i]); putchar('\\n'); return 0; &#125; å¤æ‚æ ‘ä¸Šä¹±æ éå¸¸å¥‡æ€ªï¼Œä½†å¾ˆæœ‰è¶£ã€‚ åœ¨æ€è€ƒè¿™äº›å†…å®¹æ—¶ï¼Œè¯·å›é¡¾æ ‘ä¸Šé—®é¢˜çš„å¸¸è§å¤„ç†æ‰‹æ®µï¼š [CF1580D] Subsequence Portal. å…ˆæ¥çœ‹ä¸€ä¸‹è¦æ±‚çš„è¿™ä¸ªä¸œè¥¿ï¼š åŸå¼=âˆ‘i=1m(mâ‹…abi)âˆ’âˆ‘i=1mâˆ‘j=1mf(minâ¡(bi,bj),maxâ¡(bi,bj))=(mâˆ’1)âˆ‘i=1mabiâˆ’2âˆ‘i=1mâˆ‘j=i+1mminâ¡{abi,abi+1â‹¯ ,abjâˆ’1,abj}\\begin{aligned} \\text{åŸå¼}&amp;=\\sum_{i = 1}^m (m \\cdot a_{b_i}) - \\sum_{i = 1}^m \\sum_{j = 1}^m f(\\min(b_i, b_j), \\max(b_i, b_j))\\\\ &amp;=(m-1)\\sum_{i = 1}^m a_{b_i}-2\\sum_{i=1}^m\\sum_{j=i+1}^m \\min\\{a_{b_i},a_{b_i+1}\\cdots,a_{b_j-1},a_{b_j}\\} \\end{aligned} åŸå¼â€‹=i=1âˆ‘mâ€‹(mâ‹…abiâ€‹â€‹)âˆ’i=1âˆ‘mâ€‹j=1âˆ‘mâ€‹f(min(biâ€‹,bjâ€‹),max(biâ€‹,bjâ€‹))=(mâˆ’1)i=1âˆ‘mâ€‹abiâ€‹â€‹âˆ’2i=1âˆ‘mâ€‹j=i+1âˆ‘mâ€‹min{abiâ€‹â€‹,abiâ€‹+1â€‹â‹¯,abjâ€‹âˆ’1â€‹,abjâ€‹â€‹}â€‹ è¦æ±‚è¿™ä¸ªä¸œè¥¿çš„æœ€å¤§å€¼ï¼Œåé¢è¿™ä¸ªåŒºé—´æœ€å°å€¼å¯ä»¥è€ƒè™‘æ”¾åˆ°ç¬›å¡å°”æ ‘ä¸Šï¼Œç„¶åç”¨æ ‘å½¢ DP æ±‚è§£è¿™ä¸ªé—®é¢˜ã€‚ è®¾ fx,kf_{x,k}fx,kâ€‹ ä»£è¡¨ xxx ä¸­é€‰æ‹© kkk ä¸ªèŠ‚ç‚¹çš„æœ€å¤§ä»·å€¼ï¼Œåˆå§‹ fi,1=(mâˆ’1)aif_{i,1}=(m-1)a_ifi,1â€‹=(mâˆ’1)aiâ€‹ï¼Œç„¶åè½¬ç§»æ˜¯ä¸€ä¸ªç±»ä¼¼æ ‘å½¢èƒŒåŒ…çš„è¿‡ç¨‹ï¼š fx,i+j=maxâ¡{fx,i+fy,jâˆ’2Ã—axÃ—iÃ—j}f_{x,i+j}=\\max\\{f_{x,i}+f_{y,j}-2\\times a_x\\times i\\times j\\} fx,i+jâ€‹=max{fx,iâ€‹+fy,jâ€‹âˆ’2Ã—axâ€‹Ã—iÃ—j} æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; inline void ckmax(i64 &amp;x, i64 t) &#123; if (x &lt; t) x = t; &#125; int n, m, rt; int a[4005], ls[4005], rs[4005], st[4005], siz[4005]; i64 f[4005][4005]; bool v[4005]; void dfs(int x) &#123; f[x][1] = 1ll * (m - 1) * a[x]; siz[x] = 1; function&lt;void(int)> work = [&amp;] (int y) &#123; dfs(y); for (int i = siz[x]; i >= 0; --i) for (int j = 0; j &lt;= siz[y]; ++j) ckmax(f[x][i + j], f[x][i] + f[y][j] - 2ll * a[x] * i * j); siz[x] += siz[y]; &#125;; if (ls[x]) work(ls[x]); if (rs[x]) work(rs[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, cur = 0, tot = 0; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); cur = tot; while (cur &amp;&amp; a[st[cur]] > a[i]) --cur; if (cur) rs[st[cur]] = i; if (cur &lt; tot) ls[i] = st[cur + 1]; st[++cur] = i; tot = cur; &#125; for (int i = 1; i &lt;= n; ++i) v[ls[i]] = v[rs[i]] = 1; for (int i = 1; i &lt;= n; ++i) if (!v[i]) dfs(i), printf(\"%lld\\n\", f[i][m]); return 0; &#125; [CF983E] NN country Portal. è€ƒè™‘åœ¨é“¾ä¸Šæ€ä¹ˆåšã€‚è´ªå¿ƒçš„ä¹˜åèƒ½åˆ°è¾¾çš„æœ€è¿œçš„è½¦ï¼Œå¹¶ä½¿ç”¨å€å¢åŠ é€Ÿã€‚æ”¾åˆ°æ ‘ä¸Šå°±æ˜¯é¢„å¤„ç†å‡ºæ•°ç»„ gi,jg_{i,j}gi,jâ€‹ è¡¨ç¤ºä¹˜å i+1i+1i+1 æ¬¡è½¦ï¼Œä» jjj èƒ½åˆ°è¾¾çš„æœ€æµ…èŠ‚ç‚¹ã€‚ ç‰¹åˆ¤æ‰ u,vu,vu,v å…¶ä¸­ä¸€ä¸ªæ˜¯å¦ä¸€ä¸ªçš„ç¥–å…ˆçš„æƒ…å†µï¼Œæˆ‘ä»¬è®© u,vu,vu,v åˆ†åˆ«ä¹˜ååˆ°å®ƒä»¬ LCA çš„åº•ä¸‹ï¼Œç„¶åå†ä¹˜åä¸¤æ¬¡è½¦å°±å¯ä»¥åˆ°äº†ã€‚ä½†æ˜¯å¦‚æœæœ‰ä¸€è¾†è½¦å¯ä»¥ç›´æ¥ä»ä¸€ä¸ªå­æ ‘åˆ°å¦ä¸€ä¸ªå­æ ‘ï¼Œé‚£ä¹ˆå¯ä»¥é€‰æ‹©ä¹˜åå®ƒã€‚è¿™æ ·å°±æˆäº†ä¸€ä¸ªäºŒç»´æ•°ç‚¹é—®é¢˜ï¼Œåˆ¤æ–­ä¸¤æ£µå­æ ‘å†…æ˜¯å¦æœ‰ç›¸åŒçš„å…¬äº¤è½¦ï¼ŒDFS åºåŠ ä¸»å¸­æ ‘å³å¯åœ¨çº¿ç»´æŠ¤ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, q, lg[200005], dep[200005], g[18][200005]; int f[200005], mi[18][200005], dfn[200005], num, L[200005], R[200005]; vector&lt;int> G[200005], bus[200005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; mi[0][dfn[x] = L[x] = ++num] = fa; dep[x] = dep[fa] + 1; for (int y : G[x]) dfs(y, x); R[x] = num; &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; struct Node &#123; int ls, rs; int val; &#125; T[40 * 200005]; int root[200005], tot; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; int o = ++tot; T[tot] = T[pre]; T[tot].val++; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x); else T[o].rs = update(T[pre].rs, mid + 1, r, x); return o; &#125; int query(int o, int l, int r, int x, int y) &#123; if (!o) return 0; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].val; int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(T[o].ls, l, mid, x, y); if (mid &lt; y) res += query(T[o].rs, mid + 1, r, x, y); return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i); G[f[i]].emplace_back(i); lg[i] = lg[i >> 1] + 1; &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= n; ++i) g[0][i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); int l = LCA(x, y); g[0][x] = min(g[0][x], l); g[0][y] = min(g[0][y], l); bus[dfn[x]].emplace_back(dfn[y]); bus[dfn[y]].emplace_back(dfn[x]); &#125; for (int i = n; i >= 1; --i) g[0][f[i]] = min(g[0][f[i]], g[0][i]); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j &lt;= n; ++j) g[i][j] = g[i - 1][g[i - 1][j]]; root[0] = build(1, n); for (int i = 1; i &lt;= n; ++i) &#123; root[i] = root[i - 1]; for (int k : bus[i]) root[i] = update(root[i], 1, n, k); &#125; scanf(\"%d\", &amp;q); while (q--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (u == v) &#123; puts(\"0\"); continue; &#125; int l = LCA(u, v); if (g[lg[n]][u] > l || g[lg[n]][v] > l) &#123; puts(\"-1\"); continue; &#125; // è·³ä¸åˆ° LCA ä¸Šï¼Œæ— ç­”æ¡ˆ int ans = 2; for (int i = lg[n]; i >= 0; --i) if (g[i][u] > l) u = g[i][u], ans += 1 &lt;&lt; i; for (int i = lg[n]; i >= 0; --i) if (g[i][v] > l) v = g[i][v], ans += 1 &lt;&lt; i; if (u == l || v == l) --ans; else ans -= (query(root[R[u]], 1, n, L[v], R[v]) - query(root[L[u] - 1], 1, n, L[v], R[v])) > 0; printf(\"%d\\n\", ans); &#125; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"çœé€‰ä¼˜åŒ–æŠ€å·§","slug":"notes/æ‚é¡¹/sx-tricks","date":"2022-12-12T00:00:00.000Z","updated":"2022-12-12T00:00:00.000Z","comments":true,"path":"75dc3e62/","link":"","permalink":"https://james1badcreeper.github.io/75dc3e62/","excerpt":"çœé€‰åŒæ ·æœ‰å¾ˆå¤šæ‚é¡¹ç®—æ³•ï¼Œå½“ä¸­ä¸ä¹ä¸€äº›éå¸¸å®ç”¨çš„å°æŠ€å·§ã€‚","text":"çœé€‰åŒæ ·æœ‰å¾ˆå¤šæ‚é¡¹ç®—æ³•ï¼Œå½“ä¸­ä¸ä¹ä¸€äº›éå¸¸å®ç”¨çš„å°æŠ€å·§ã€‚ æ›´æ–°æ—¥å¿— 2023/10/16å®Œæˆé‡æ„ã€‚2023/4/16å¼€å§‹é‡æ„æ–‡ç« ï¼Œæ•´ç†äº†æ„æˆå’Œéœ€è¦å†™çš„éƒ¨åˆ†ã€‚ å®é™…ä¸Šéƒ½æ˜¯å¿…å¤‡æŠ€èƒ½ã€‚ log ä¼˜åŒ–æŠ€å·§ å¤šç§æ–¹å¼å¯ä»¥å¾—åˆ° logâ¡\\loglog çº§åˆ«çš„ä¼˜åŒ–ï¼Œä½†æ˜¯å½“ä¸­æœ‰ä¸€äº›åˆ«çš„ã€‚ åŸºäºäºŒåˆ†çš„ä¼˜åŒ– äºŒåˆ†æ˜¯å¯¹å•è°ƒæ€§çš„åˆ©ç”¨ï¼Œåªè¦æœ‰å•è°ƒæ€§éƒ½å¯ä»¥è¯•è¯•äºŒåˆ†ï¼ ä¸‰åˆ†æ³• ç°åœ¨æœ‰ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ˜¯ä¸€ä¸ªå•å³°æˆ–è€…å•è°·å‡½æ•°ï¼Œè¦æ±‚å‡ºå®ƒçš„æå€¼ã€‚ ä¼ ç»Ÿçš„äºŒåˆ†æ³•ä¼¼ä¹å¹¶ä¸å¥½åšï¼Œæ‰¾åˆ° mid ä¹‹åï¼Œæ— æ³•ç¡®å®šæå€¼åœ¨é‚£ä¸€è¾¹ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‰åˆ†æ³•ï¼šåœ¨ l,rl,rl,r å†…ä»»å–ä¸¤ç‚¹ lmid,rmidlmid,rmidlmid,rmidï¼Œå¦‚æœ f(lmid)&lt;f(rmid)f(lmid)&lt;f(rmid)f(lmid)&lt;f(rmid)ï¼Œåˆ™å‡½æ•°åœ¨ [rmid,r][rmid,r][rmid,r] ä¸­å¿…ç„¶å•è°ƒé€’å¢æˆ–è€…å•è°ƒé€’å‡ï¼ˆç”»ä¸ªå›¾ï¼Œç„¶ååˆ†ç±»è®¨è®ºï¼Œçœ‹ lmid,rmidlmid,rmidlmid,rmid æ˜¯å¦åˆ†å¸ƒåœ¨æå€¼ç‚¹ä¸¤ä¾§ï¼Œå°±çŸ¥é“äº†ï¼‰ï¼Œåä¹‹åŒç†ã€‚é‚£ä¹ˆè¿™æ ·å°±å¯ä»¥åˆ†å‡ºæå€¼ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const double eps = 1e-7; int n; double l, r, a[20]; double f(double x) &#123; double ans = 0, b = 1; for (int i = n; i >= 0; --i, b *= x) ans += a[i] * b; return ans; &#125; int main(void) &#123; scanf(\"%d%lf%lf\", &amp;n, &amp;l, &amp;r); for (int i = 0; i &lt;= n; ++i) scanf(\"%lf\", a + i); while (l + eps &lt; r) &#123; double lmid = (l + r) / 2, rmid = (mid + r) / 2; if (f(lmid) > f(rmid)) r = mid; else l = mid; &#125; printf(\"%.5lf\\n\", l); return 0; &#125; åˆ†æ•°è§„åˆ’ åˆ†æ•°è§„åˆ’ï¼Œä¸€èˆ¬æŒ‡ 01 åˆ†æ•°è§„åˆ’ï¼Œç”¨æ¥æ±‚ä¸€ä¸ªåˆ†å¼çš„æå€¼ï¼Œä¹Ÿå°±æ±‚ä¸€ç»„ wi={0,1}w_i=\\{0,1\\}wiâ€‹={0,1}ï¼Œæœ€å¤§åŒ–æˆ–è€…æœ€å°åŒ–ï¼š âˆ‘aiÃ—wiâˆ‘biÃ—wi\\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i} âˆ‘biâ€‹Ã—wiâ€‹âˆ‘aiâ€‹Ã—wiâ€‹â€‹ æœ‰çš„æ—¶å€™é¢˜ç›®è¿˜æœ‰ä¸€äº›é™åˆ¶ï¼Œæ¯”å¦‚åˆ†æ¯è‡³å°‘ä¸º WWWï¼Œæ°å¥½æœ‰ kkk ä¸ª wiw_iwiâ€‹ æ˜¯ 111ã€‚ æˆ‘ä»¬ä¸€èˆ¬ä½¿ç”¨äºŒåˆ†ç­”æ¡ˆæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä»¥æœ€å¤§å€¼ä¸ºä¾‹ï¼š âˆ‘aiÃ—wiâˆ‘biÃ—wi&gt;midâŸ¹âˆ‘aiÃ—wiâˆ’midÃ—âˆ‘biÃ—wi&gt;0âŸ¹âˆ‘wi(aiâˆ’midÃ—bi)&gt;0\\begin{aligned} &amp;\\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i}&gt;mid\\\\ \\Longrightarrow&amp; \\sum a_i\\times w_i - mid\\times \\sum b_i\\times w_i &gt; 0\\\\ \\Longrightarrow&amp; \\sum w_i(a_i-mid\\times b_i)&gt;0 \\end{aligned} âŸ¹âŸ¹â€‹âˆ‘biâ€‹Ã—wiâ€‹âˆ‘aiâ€‹Ã—wiâ€‹â€‹&gt;midâˆ‘aiâ€‹Ã—wiâ€‹âˆ’midÃ—âˆ‘biâ€‹Ã—wiâ€‹&gt;0âˆ‘wiâ€‹(aiâ€‹âˆ’midÃ—biâ€‹)&gt;0â€‹ æˆ‘ä»¬ä½¿ç”¨è´ªå¿ƒçš„æ–¹å¼å°±å¯ä»¥æ±‚å‡ºå·¦è¾¹çš„æœ€å¤§å€¼ã€‚ æ¨¡æ¿ï¼Œè¦æ±‚æ°å¥½ kkk ä¸ª 111ã€‚é‚£ä¹ˆæ’åºå³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; const double eps = 1e-6; int n, k; double t[100005]; int a[100005], b[100005]; bool check(double x) &#123; for (int i = 1; i &lt;= n; ++i) t[i] = a[i] - x * b[i]; sort(t + 1, t + n + 1); double ans = 0; for (int i = n - k + 1; i &lt;= n; ++i) ans += t[i]; return ans > 0; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i); double l = 0, r = 1e18; while (l + eps &lt; r) &#123; double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; &#125; printf(\"%.4lf\\n\", r); return 0; &#125; åŸºäºäºŒåˆ†å•è°ƒæ€§çš„ä¼˜åŒ– å°†ä¼šåœ¨ã€ŠDP ä¼˜åŒ–ã€‹ä¸­å‡ºç°ã€‚ å€å¢ å€å¢å’ŒäºŒåˆ†éƒ½éœ€è¦å…·æœ‰å•è°ƒæ€§ï¼Œä½†æ˜¯å€å¢èƒ½å¤Ÿè§£å†³ä¸€äº›äºŒåˆ†ä¸èƒ½è§£å†³çš„é—®é¢˜ï¼Œå°±åƒäºŒåˆ†å‡º mid ä¹‹åå‘ç° mid æ— æ³•ç®€å• checkï¼Œä½†æ˜¯å€å¢å´å¯ä»¥æ–¹ä¾¿çš„åˆå¹¶ä¿¡æ¯ã€‚ å€å¢ç­”æ¡ˆ äºŒåˆ†ç­”æ¡ˆï¼Ÿå€å¢ç­”æ¡ˆï¼äºŒåˆ†ç­”æ¡ˆè¦æ±‚ç­”æ¡ˆæ˜¯å…·æœ‰å•è°ƒæ€§çš„ï¼Œä½†æ˜¯å€å¢åŒæ ·å¯ä»¥åšåˆ°ï¼ äºŒåˆ†ä¸Šç•Œä¸ç¡®å®šçš„å†…å®¹çš„æœ€ä½³æ–¹å¼æ˜¯å€å¢ã€‚åˆå§‹æ—¶ä½¿ç”¨å€å¢æ±‚å‡ºä¸Šç•Œï¼›æ±‚è§£æ—¶ï¼Œç±»ä¼¼äºå€å¢ LCA çš„æ–¹å¼ï¼Œä»ä¸Šç•Œå¼€å§‹ï¼Œåˆæ³•çš„æœ€å°å€¼å°±æ˜¯ä¸åˆæ³•çš„æœ€å¤§å€¼ +1ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»äºŒè¿›åˆ¶ä½é«˜åˆ°ä½æšä¸¾ï¼Œå¦‚æœåŠ ä¸Šè¿™ä¹ˆå¤šè¿˜ä¸æ»¡è¶³å°±ä¸€å®šè·³! // ä½¿ç”¨ç±»ä¼¼äºä¸‹é¢çš„æ–¹å¼æ±‚è§£ä¸Šç•Œ int st = query(); // åˆå§‹è¾¹ç•Œå€¼ int pw = 0; while (1) &#123; if (query(r + (1ll &lt;&lt; pw)) != st) break; r += 1ll &lt;&lt; pw; ++pw; &#125; // ä½¿ç”¨ç±»ä¼¼äºä¸‹é¢çš„æ–¹å¼æ±‚è§£ç­”æ¡ˆ int ans = 0; for (int i = 30; i >= 0; --i) if (!check(ans | (1 &lt;&lt; i))) ans |= (1 &lt;&lt; i); ans += 1; å€å¢ä¼˜åŒ– DP è¿™æ˜¯å€å¢çš„ä¸€ä¸ªé‡è¦åº”ç”¨ï¼Œå°±æ˜¯åˆ©ç”¨ DP è½¬ç§»çŠ¶æ€çš„å•è°ƒæ€§æ¥è®¾è®¡ä¸€ä¸ªå½¢å¦‚ f(i,j)f(i,j)f(i,j)ï¼Œå…¶ä¸­ jjj ä»£è¡¨é•¿åº¦ä¸º 2j2^j2j çš„æ®µã€‚ åˆ†æ²» æ™®åŠç»„ç®—æ³•çš„å¤ä»‡ã€‚ æˆ‘ä»¬çŸ¥é“åˆ†æ²»æ˜¯å°†å¤æ‚çš„é—®é¢˜æ‹†æˆå¤šä¸ªï¼ˆä¸€èˆ¬æ˜¯ä¸¤ä¸ªï¼‰ç›¸ä¼¼çš„å­é—®é¢˜ï¼Œç›´åˆ°æœ€ååˆ†æˆçš„å­é—®é¢˜å¯ä»¥ç®€å•æ±‚è§£ï¼Œç„¶åé€šè¿‡å­é—®é¢˜çš„ç­”æ¡ˆåˆå¹¶å‡ºå¤§é—®é¢˜çš„ç­”æ¡ˆã€‚ æˆ‘çŸ¥é“ä½ æ—©å°±çŸ¥é“äº†ä¸Šé¢è¯´çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜æ˜¯æ¥çœ‹ç‚¹æœ‰æ„æ€çš„å§ï¼ˆåœ¨è¿™é‡Œæ²¡å‡ºç°çš„åˆ†æ²»å‡åœ¨å…¶å®ƒæ–‡ç« é‡Œå‡ºç°ï¼‰ã€‚ æ™®é€šåˆ†æ²» å°±æ˜¯æ­£å¸¸åˆ†æ²»ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€é“é¢˜ï¼š [Luogu P7883] å¹³é¢æœ€è¿‘ç‚¹å¯¹ï¼ˆåŠ å¼ºåŠ å¼ºç‰ˆï¼‰ã€‚æ±‚ä¸€ä¸ªå¹³é¢ä¸Šæœ€è¿‘çš„ç‚¹å¯¹ï¼Œç‚¹æ•°åœ¨ 4Ã—1054\\times 10^54Ã—105 çº§åˆ«ã€‚ å…ˆå°†æ‰€æœ‰ç‚¹æŒ‰ç…§ xxx åæ ‡æ’åºï¼Œç„¶åå¼€å§‹åˆ†æ²»ã€‚å…³é”®åœ¨äºå¦‚ä½•åˆå¹¶ï¼šå¦‚æœä¸€ä¸ªç‚¹æ»¡è¶³ âˆ£x[mid]âˆ’x[i]âˆ£&lt;d|x[mid]-x[i]|&lt;dâˆ£x[mid]âˆ’x[i]âˆ£&lt;dï¼Œå…¶ä¸­ ddd ä»£è¡¨å·¦å³ä¸¤è¾¹ç­”æ¡ˆçš„æœ€å°å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°ç‚¹ iii æ˜¯åˆæ³•çš„ã€‚ç„¶åå°†è¿™äº›åˆæ³•çš„ç‚¹å†æŒ‰ç…§ yyy åæ ‡æ’åºï¼Œå†è¿›è¡Œæšä¸¾ï¼Œyyy åæ ‡è·ç¦»å¤§äº ddd å°± break æ‰ã€‚ è¿™æ ·å¯ä»¥ä¿è¯åˆå¹¶çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)O(n)O(n) çš„ï¼ˆéœ€è¦é‡‡ç”¨å½’å¹¶æ’åºï¼‰ï¼Œå…·ä½“è¯æ˜éœ€è¦é€šè¿‡ä¸€äº›å‡ ä½•çš„æ–¹å¼ï¼Œä¸æ‰“ç®—ç ”ç©¶ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 1e15; int n; struct Point &#123; int x, y; bool operator &lt; (const Point &amp;a) const &#123; if (x == a.x) return y &lt; a.y; return x &lt; a.x; &#125; &#125; a[400005]; i64 dist(int i, int j) &#123; i64 x = 1ll * (a[i].x - a[j].x) * (a[i].x - a[j].x); i64 y = 1ll * (a[i].y - a[j].y) * (a[i].y - a[j].y); return x + y; &#125; bool cmp(const int &amp;x, const int &amp;y) &#123; return a[x].y &lt; a[y].y; &#125; int g[400005]; i64 merge(int l, int r) &#123; if (l == r) return INF; if (l + 1 == r) return dist(l, r); int mid = l + r >> 1; i64 d1 = merge(l, mid), d2 = merge(mid + 1, r); i64 d = min(d1, d2); int tot = 0; for (int i = l; i &lt;= r; ++i) &#123; i64 k = abs(a[mid].x - a[i].x); if (k &lt; INF &amp;&amp; k * k &lt; d) g[++tot] = i; &#125; sort(g + 1, g + tot + 1, cmp); for (int i = 1; i &lt; tot; ++i) for (int j = i + 1; j &lt;= tot &amp;&amp; 1ll * (a[g[j]].y - a[g[i]].y) * (a[g[j]].y - a[g[i]].y) &lt; d; ++j) d = min(d, dist(g[i], g[j])); return d; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); sort(a + 1, a + n + 1); printf(\"%lld\\n\", merge(1, n)); return 0; &#125; äºŒç»´åˆ†æ²» å…¶å®å°±æ˜¯å¯¹ä¸¤ä¸ªä¸œè¥¿è¿›è¡Œåˆ†æ²»ï¼Œæ¯æ¬¡å°†å…¶ä¸­ä¸€ä¸ªä¸œè¥¿åˆ‡åŠï¼ˆä¸ºäº†ä¿è¯æ•ˆç‡ï¼Œä¸€èˆ¬é€‰æ‹©å…¶ä¸­åŒºé—´æ›´é•¿çš„ä¸€ä¸ªåˆ‡åŠï¼‰ï¼Œç„¶ååˆå¹¶ç­”æ¡ˆã€‚ [CF364E] Empty Rectangles.ç»™å®šä¸€ä¸ª nÃ—m(1â‰¤n,mâ‰¤2.5Ã—103)n\\times m(1\\le n, m\\le 2.5\\times 10^3)nÃ—m(1â‰¤n,mâ‰¤2.5Ã—103) çš„ 01 çŸ©é˜µï¼Œè¯¢é—®æœ‰å¤šå°‘ä¸ªå­çŸ©é˜µæ»¡è¶³åªæœ‰ k(1â‰¤kâ‰¤6)k(1\\le k\\le 6)k(1â‰¤kâ‰¤6) ä¸ª 1ã€‚ æœ¬é¢˜è¦æ±‚æ°å¥½æœ‰ kkk ä¸ª 1 çš„å­çŸ©å½¢æ•°é‡ï¼Œæˆ‘ä»¬å°†å½“å‰çŸ©å½¢åŠˆæˆä¸¤åŠï¼ˆä»¥åŠˆæˆå·¦ä¸€åŠå’Œå³ä¸€åŠä¸ºä¾‹ï¼‰ï¼Œé‚£ä¹ˆç¬¦åˆæ¡ä»¶çš„å­çŸ©å½¢è¦ä¹ˆåœ¨å·¦åŠï¼Œè¦ä¹ˆåœ¨å³åŠï¼Œè¦ä¹ˆè·¨è¶Šä¸­çº¿ã€‚ è€ƒè™‘è·¨è¶Šä¸­çº¿çš„å¦‚ä½•åˆå¹¶ã€‚æˆ‘ä»¬æšä¸¾å­çŸ©å½¢çš„ä¸Šä¸‹è¾¹ç•Œï¼Œç„¶åå¼€ä¸ªæ¡¶ ppp ç»Ÿè®¡å·¦åŠçŸ©å½¢æ‰€å« 111 æ•°é‡å°äº iii æ—¶å·¦è¾¹ç•Œçš„æœ€å°å€¼ï¼ˆå³åŠçŸ©å½¢åŒç†ï¼‰ï¼Œç„¶åç›´æ¥æšä¸¾å·¦åŠè¾¹çš„ 111 çš„ä¸ªæ•°å°±å¯ä»¥ç»Ÿè®¡äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, K; i64 ans = 0; int s[2505][2505], p[10], q[10]; int F(int x1, int y1, int x2, int y2) &#123; if (x1 > x2 || y1 > y2) return 0; return s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]; &#125; void divide(int xl, int yl, int xr, int yr) &#123; if (xl > xr || yl > yr) return; if (xl == xr &amp;&amp; yl == yr) &#123; ans += (F(xl, yl, xr, yr) == K); return; &#125; int d = (xr - xl > yr - yl); if (d) &#123; int mid = xl + xr >> 1; divide(xl, yl, mid, yr); divide(mid + 1, yl, xr, yr); for (int i = yl; i &lt;= yr; ++i) &#123; p[0] = mid + 1; q[0] = mid; for (int k = 1; k &lt;= K + 1; ++k) p[k] = xl, q[k] = xr; for (int j = i; j &lt;= yr; ++j) &#123; for (int k = 1; k &lt;= K + 1; ++k) &#123; while (F(p[k], i, mid, j) >= k) ++p[k]; while (F(mid + 1, i, q[k], j) >= k) --q[k]; &#125; for (int k = 0; k &lt;= K; ++k) ans += (p[k] - p[k + 1]) * (q[K - k + 1] - q[K - k]); &#125; &#125; &#125; else &#123; int mid = yl + yr >> 1; divide(xl, yl, xr, mid); divide(xl, mid + 1, xr, yr); for (int i = xl; i &lt;= xr; ++i) &#123; p[0] = mid + 1; q[0] = mid; for (int k = 1; k &lt;= K + 1; ++k) p[k] = yl, q[k] = yr; for (int j = i; j &lt;= xr; ++j) &#123; for (int k = 1; k &lt;= K + 1; ++k) &#123; while (F(i, p[k], j, mid) >= k) ++p[k]; while (F(i, mid + 1, j, q[k]) >= k) --q[k]; &#125; for (int k = 0; k &lt;= K; ++k) ans += (p[k] - p[k + 1]) * (q[K - k + 1] - q[K - k]); &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;K); for (int i = 1; i &lt;= n; ++i) &#123; char t[2505]; scanf(\"%s\", t + 1); for (int j = 1; j &lt;= m; ++j) s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + (t[j] - '0'); &#125; divide(1, 1, n, m); printf(\"%lld\\n\", ans); return 0; &#125; CDQ åˆ†æ²» è®°å¾—å½’å¹¶æ’åºå—ï¼Ÿæˆ‘ä»¬è¦æ±‚è®¡ç®—åˆ†æ²»ä¸­å¿ƒå·¦å³ä¸¤è¾¹éƒ¨åˆ†çš„ä¿¡æ¯åˆå¹¶ï¼Œè¿™éƒ¨åˆ†æ±‚å€¼çš„å…ˆåé¡ºåºæ²¡æœ‰è¦æ±‚ã€‚è¿™æ ·ä¿¡æ¯å¯èƒ½å¯ä»¥ç®€å•åœ°åˆå¹¶ä»¥å¾—åˆ°ä¸€ä¸ªåˆ†æ²»åšæ³•ã€‚è¿™ç§åšæ³•ç”¨æ¥å¯¹æ—¶é—´ç»´åº¦è¿›è¡Œé™ç»´ï¼ˆå°±æ˜¯å»æ‰ä¸€ä¸ªååºé™åˆ¶ï¼‰ï¼Œä¹Ÿå¯ä»¥å¤„ç†å¸¦æœ‰æ—¶é—´é™åˆ¶çš„é—®é¢˜ï¼ˆé™å®šåˆå¹¶æ–¹å‘ï¼‰ã€‚è¿™ç§æ“ä½œè¢«ç§°ä¸º CDQ åˆ†æ²»ã€‚ ä¸‰ç»´ååºé—®é¢˜ã€‚ç»™å®š nnn ä¸ªä¸‰ç»´ç©ºé—´ä¸Šçš„ç‚¹ï¼Œè®¾ f(i)f(i)f(i) è¡¨ç¤ºæ»¡è¶³ xjâ‰¤xi,yjâ‰¤yi,zjâ‰¤zix_j\\le x_i,y_j\\le y_i,z_j\\le z_ixjâ€‹â‰¤xiâ€‹,yjâ€‹â‰¤yiâ€‹,zjâ€‹â‰¤ziâ€‹ çš„ jjj çš„æ•°é‡ï¼Œæ±‚æ»¡è¶³ f(i)=df(i)=df(i)=d çš„ iii çš„æ•°é‡ï¼Œè¦æ±‚å¯¹æ‰€æœ‰ ddd ç»™å‡ºç›¸åº”çš„ç­”æ¡ˆã€‚ è§£å†³è¿™ç±»é—®é¢˜çš„æµç¨‹å¦‚ä¸‹ï¼š æ‰¾åˆ°è¿™ä¸ªåºåˆ—çš„ä¸­ç‚¹ midmidmidï¼› å°†æ‰€æœ‰ç‚¹å¯¹ (i,j)(i,j)(i,j) åˆ’åˆ†ä¸ºä¸‰ç±»ï¼š 1â‰¤i,jâ‰¤mid1\\le i,j\\le mid1â‰¤i,jâ‰¤midï¼Œ 1â‰¤iâ‰¤mid,mid+1â‰¤jâ‰¤n1\\le i\\le mid,mid+1\\le j\\le n1â‰¤iâ‰¤mid,mid+1â‰¤jâ‰¤nï¼Œ mid+1â‰¤i,jâ‰¤nmid+1\\le i,j\\le nmid+1â‰¤i,jâ‰¤nã€‚ æ‹†æˆå·¦å³ä¸¤åŠçš„å­åºåˆ—ï¼Œç„¶åé€’å½’æ±‚è§£ï¼› è®¾æ³•å¤„ç†ç¬¬äºŒç§ç‚¹å¯¹ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼ŒCDQ åˆ†æ²»å°±æ˜¯ä¸æ–­æŠŠç‚¹å¯¹é€šè¿‡é€’å½’çš„æ–¹å¼åˆ†ç»™å·¦å³ä¸¤ä¸ªåŒºé—´ã€‚ç°åœ¨æˆ‘ä»¬æ¥çœ‹å¦‚ä½•è§£å†³ä¸‰ç»´ååºé—®é¢˜ï¼š åˆ†åˆ«å¤„ç†ä¸‰ä¸ªä¿¡æ¯ã€‚ç¬¬ä¸€ç»´å¯ä»¥å°†åŸæ•°ç»„æŒ‰ç…§ xxx æ’åºï¼Œxiâ‰¤xjx_i\\le x_jxiâ€‹â‰¤xjâ€‹ è½¬åŒ–ä¸º i&lt;ji&lt;ji&lt;jã€‚æ³¨æ„æ­¤æ—¶å¦‚æœæ•°éƒ½ç›¸åŒä¼šå‡ºé—®é¢˜ï¼Œå› æ­¤å»ä¸ªé‡ã€‚ ç¬¬äºŒç»´å¯ä»¥åœ¨åˆ†æ²»æ—¶é‡‡ç”¨ç±»ä¼¼äºå½’å¹¶æ’åºçš„æ–¹å¼è§£å†³ï¼ˆæ±‚æ­£åºå¯¹ï¼‰ï¼Œä¸è¿‡ç”±äºç¬¬ä¸‰ç»´çš„é™åˆ¶ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„ä¿¡æ¯éƒ½å¯ä»¥åŠ åˆ°ç­”æ¡ˆé‡Œçš„ï¼Œéœ€è¦æ•´ä¸€ä¸ªæƒå€¼æ ‘çŠ¶æ•°ç»„æ¥å¤„ç†ç¬¬ä¸‰ç»´çš„ä¿¡æ¯ï¼šå·¦åŠæ®µåºåˆ—çš„ä¿¡æ¯åŠ å…¥æ ‘çŠ¶æ•°ç»„ï¼Œå³åŠæ®µä¿¡æ¯è¿›è¡Œç»Ÿè®¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, k; struct Node &#123; int a, b, c, cnt, ans; bool operator&lt; (const Node &amp;a) const &#123; if (this->a != a.a) return this->a &lt; a.a; if (b != a.b) return b &lt; a.b; return c &lt; a.c; &#125; &#125; a[100005], T[100005]; int ans[100005]; int C[200005]; void add(int x, int t) &#123; for (; x &lt;= k; x += x &amp; -x) C[x] += t; &#125; int sum(int x) &#123; int s = 0; for (; x; x -= x &amp; -x) s += C[x]; return s; &#125; void CDQ(int l, int r) &#123; if (l == r) return a[l].ans += a[l].cnt - 1, void(); int mid = l + r >> 1; CDQ(l, mid); CDQ(mid + 1, r); int p = l, q = mid + 1; for (int i = l; i &lt;= r; ++i) &#123; if (p &lt;= mid &amp;&amp; (q > r || a[p].b &lt;= a[q].b)) add(a[p].c, a[p].cnt), T[i] = a[p++]; else a[q].ans += sum(a[q].c), T[i] = a[q++]; &#125; for (int i = l; i &lt;= mid; ++i) add(a[i].c, -a[i].cnt); for (int i = l; i &lt;= r; ++i) a[i] = T[i]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d%d\", &amp;a[i].a, &amp;a[i].b, &amp;a[i].c), a[i].cnt = 1; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) if (a[i].a != a[m].a || a[i].b != a[m].b || a[i].c != a[m].c) a[++m] = a[i]; else ++a[m].cnt; CDQ(1, m); for (int i = 1; i &lt;= m; ++i) ans[a[i].ans] += a[i].cnt; for (int i = 0; i &lt; n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; æ•´ä½“æ“ä½œä¸Šæ¥è®²ï¼ŒCDQ åˆ†æ²»çš„è¿‡ç¨‹ä¸å½’å¹¶æ’åºåŸºæœ¬æ— å¼‚ã€‚ CDQ åˆ†æ²»åœ¨å…¶å®ƒåœ°æ–¹çš„åº”ç”¨éƒ½æ˜¯å°†å„ç±»ä¿¡æ¯è½¬åŒ–ä¸ºååºå…³ç³»ç„¶åæ±‚è§£ï¼Œå…·ä½“å¯ä»¥è§ Problemsetã€‚ æ•´ä½“äºŒåˆ† å¦‚æœåˆ†æ²»ä¸­éµå¾ªå…ˆé€’å½’å·¦å­æ ‘ï¼Œå†é€’å½’å³å­æ ‘çš„æ³•åˆ™ï¼Œé‚£ä¹ˆç»´æŠ¤ä¸€ä¸ªæŒ‡é’ˆå»â€œè·Ÿè¸ªâ€åˆ†æ²»ä¸­å¿ƒï¼Œè¿™ä¸ªæŒ‡é’ˆçš„ç§»åŠ¨è·ç¦»æ˜¯ O(nlogâ¡n)O(n\\log n)O(nlogn) çš„ã€‚ å¾ˆå¤šé¢˜ç›®éƒ½å¯ä»¥ä½¿ç”¨äºŒåˆ†æ¥è§£å†³ï¼Œä½†æ˜¯å®ƒä»¬åªæœ‰ä¸€ç»„è¯¢é—®ã€‚å¦‚æœæœ‰å¤šç»„è¯¢é—®æ€ä¹ˆåŠï¼Ÿæ•´ä½“äºŒåˆ†ï¼åˆç§°åŸºäºå€¼åŸŸçš„åˆ†æ²»ç®—æ³•ã€‚ è®° [l,r][l,r][l,r] ä¸ºç­”æ¡ˆçš„å€¼åŸŸï¼Œ[L,R][L,R][L,R] ä¸ºç­”æ¡ˆçš„å®šä¹‰åŸŸï¼ˆäººè¯ï¼šè€ƒè™‘ä¸‹æ ‡åœ¨åŒºé—´ [L,R][L,R][L,R] å†…çš„æ“ä½œå’Œè¯¢é—®ï¼Œè¯¢é—®çš„ç­”æ¡ˆåœ¨ [l,r][l,r][l,r] å†…ï¼‰ã€‚ æˆ‘ä»¬æŠŠæ‰€æœ‰æ“ä½œæŒ‰ç…§æ—¶é—´é¡ºåºå­˜å…¥æ•°ç»„ä¸­ï¼Œç„¶åå¼€å§‹åˆ†æ²»ï¼Œå¹¶åˆ©ç”¨åˆé€‚çš„æ•°æ®ç»“æ„ï¼ˆFenwick æ ‘æœ€ä¸ºå¸¸ç”¨ï¼‰ç»Ÿè®¡å½“å‰æŸ¥è¯¢çš„ç­”æ¡ˆå’Œåˆ†æ²»ä¸­å¿ƒ midmidmid ä¹‹é—´çš„å…³ç³»ï¼Œæ ¹æ®æŸ¥è¯¢å‡ºæ¥çš„ç»“æœå°†åºåˆ—æŒ‰ç…§åˆ†æˆä¸¤ä»½é€’å½’å¤„ç†ï¼Œæœ€ååªæœ‰ä¸€ä¸ªç‚¹å°±æ‰¾åˆ°äº†ç­”æ¡ˆã€‚ ä½ ç¡®å®šè¿™æ˜¯äººè¯ï¼Ÿï¼å—¯ï¼Œç¡®å®ä¸æ˜¯ã€‚ é‚£ä¹ˆæˆ‘ä»¬ä½¿ç”¨é¢˜ç›®æ¥è®²äººè¯ï¼š é™æ€åŒºé—´ kkk å°é—®é¢˜ã€‚é™æ€åŒºé—´ kkk å°ï¼Œä½†æ˜¯ç©ºé—´é™åˆ¶ 10MBã€‚æƒ³å†™ä¸»å¸­æ ‘å’Œæ ‘å¥—æ ‘çš„äººæ´—æ´—ç¡å§ æˆ‘ä»¬è€ƒè™‘ä½¿ç”¨æ•´ä½“äºŒåˆ†è§£å†³è¿™ä¸ªé¢˜ç›®ã€‚å…ˆæƒ³ä¸€æƒ³ï¼Œæ­£å¸¸ç”¨äºŒåˆ†è§£å†³å…¨å±€ kkk å°é—®é¢˜æ€ä¹ˆåšï¼Ÿæˆ‘ä»¬å…ˆå°†æ•°ç»„æ’åºï¼Œç„¶åå†äºŒåˆ†ã€‚è€Œå¤šæ¬¡è¯¢é—®çš„è¯ï¼Œå°±çŒœæµ‹å½“å‰çš„ç­”æ¡ˆæ˜¯ midmidmidï¼Œä¾æ¬¡éªŒè¯æ¯ä¸ªè¯¢é—®çš„ç­”æ¡ˆåº”è¯¥æ˜¯å°äºç­‰äº midmidmid è¿˜æ˜¯å¤§äº midmidmidï¼Œæ ¹æ®æ­¤å°†è¯¢é—®åˆ’åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ã€‚æ³¨æ„ï¼Œå¦‚æœä¸€ä¸ªè¯¢é—®çš„ç­”æ¡ˆæ˜¯å¤§äº midmidmidï¼Œé‚£ä¹ˆéœ€è¦æ›´æ–°å®ƒçš„ kkkï¼šå‡å»åœ¨å€¼åŸŸ [l,mid][l,mid][l,mid] ä¸Šæ¯”å®ƒå°çš„æ•°ã€‚ç†ç”±å¾ˆç®€å•ï¼Œæ¥ä¸‹æ¥å¯¹å³åŠæ®µè¯¢é—®æ—¶ä¸ä¼šå†è€ƒè™‘ä¹‹å‰åœ¨å·¦åŠæ®µæ¯”å®ƒå°çš„ï¼Œéœ€è¦æå‰æŠŠè¿™äº›å‡å»ã€‚ è¿˜æœ‰ä¸€ç‚¹ï¼Œä¸è¦çœŸçš„å»äºŒåˆ†å€¼åŸŸï¼Œå°†åŸæ•°ç»„æ’åºåäºŒåˆ†ç­”æ¡ˆçš„ä½ç½®ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; typedef pair&lt;int, int> pii; int n, m, C[200005], id[200005]; struct Query &#123; int l, r, k; &#125; Q[200005]; struct Number &#123; int x, id; bool operator &lt; (const Number &amp;a) const &#123; return x &lt; a.x; &#125; &#125; a[200005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int sum(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int ans[200005], t1[200005], t2[200005], cur[200005]; void solve(int l, int r, int ql, int qr) &#123; // å€¼åŸŸ [l, r]ï¼Œè¯¢é—®åŒºé—´ [ql, qr] if (ql > qr) return; // æ²¡æœ‰æ“ä½œï¼Œå†è§ if (l == r) &#123; for (int i = ql; i &lt;= qr; ++i) ans[id[i]] = a[l].x; return; &#125; int mid = l + r >> 1; for (int i = l; i &lt;= mid; ++i) add(a[i].id, 1); // å°†å€¼åŸŸçš„å‰ä¸€åŠåŠ ä¸Š 1 int p = 0, q = 0; for (int i = ql; i &lt;= qr; ++i) &#123; int u = id[i]; int s = sum(Q[u].r) - sum(Q[u].l - 1); // åœ¨åŒºé—´å†…æ¯”å°äºç­‰äº mid çš„æ•° if (s >= Q[u].k) t1[++p] = u; // åœ¨ [l, mid] ä¸­æ¯”å®ƒå°çš„æ•°å¤§äºå…¶æ’åï¼Œç­”æ¡ˆåº”åœ¨ [l, mid] else t2[++q] = u, Q[u].k -= s; &#125; int tot = ql - 1; for (int i = 1; i &lt;= p; ++i) id[++tot] = t1[i]; for (int i = 1; i &lt;= q; ++i) id[++tot] = t2[i]; for (int i = l; i &lt;= mid; ++i) add(a[i].id, -1); // æ’¤é”€ä¿®æ”¹æ“ä½œ solve(l, mid, ql, ql + p - 1); // å‰ p ä¸ªè¯¢é—®çš„ç­”æ¡ˆåœ¨ [l, mid] solve(mid + 1, r, ql + p, qr); // å‰©ä¸‹çš„åœ¨ [mid+1, r] &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i].x), a[i].id = i; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;Q[i].l, &amp;Q[i].r, &amp;Q[i].k), id[i] = i; solve(1, n, 1, m); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; æ•´ä½“äºŒåˆ†è¿˜å¯ä»¥ç”¨æ¥è§£å†³å…·æœ‰å•è°ƒæ€§çš„ DP è½¬ç§»é—®é¢˜ï¼š [CF868F] Yet Another Minimization Problem.é¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªåºåˆ— aaaï¼Œè¦æŠŠå®ƒåˆ†æˆ kkk ä¸ªå­æ®µã€‚æ¯ä¸ªå­æ®µçš„è´¹ç”¨æ˜¯å…¶ä¸­ç›¸åŒå…ƒç´ çš„å¯¹æ•°ã€‚æ±‚æ‰€æœ‰å­æ®µçš„è´¹ç”¨ä¹‹å’Œçš„æœ€å°å€¼ã€‚2â‰¤nâ‰¤1052 \\leq n \\leq 10^52â‰¤nâ‰¤105ï¼Œ2â‰¤kâ‰¤minâ¡(n,20)2 \\leq k \\leq \\min(n,20)2â‰¤kâ‰¤min(n,20)ï¼Œ1â‰¤aiâ‰¤n1 \\leq a_i \\leq n1â‰¤aiâ€‹â‰¤n ã€‚ æœ€æš´åŠ›çš„åšæ³•æ˜¯è®¾å°†åºåˆ—å‰ iii ä¸ªæ•°åˆ’åˆ†ä¸º jjj æ®µçš„æœ€å°è´¹ç”¨ä¸º fi,jf_{i,j}fi,jâ€‹ï¼Œè½¬ç§»ä¸º fi,j=minâ¡{fx,jâˆ’1+wx+1,i}f_{i,j}=\\min\\{f_{x,j-1}+w_{x+1,i}\\}fi,jâ€‹=min{fx,jâˆ’1â€‹+wx+1,iâ€‹}ã€‚ è¿™ä¸ªè½¬ç§»æ˜¯å…·æœ‰å•è°ƒæ€§çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœ j1=j2,i1&lt;i2j_1=j_2,i_1&lt;i_2j1â€‹=j2â€‹,i1â€‹&lt;i2â€‹ï¼Œé‚£ä¹ˆè½¬ç§»è¿‡æ¥çš„åœ°æ–¹ä¸€å®šæ»¡è¶³ x1â‰¤x2x_1\\le x_2x1â€‹â‰¤x2â€‹ã€‚ è¯æ˜ å‡å®š x1&gt;x2x_1&gt;x_2x1â€‹&gt;x2â€‹ï¼Œé‚£ä¹ˆæœ‰ fx1,jâˆ’1+wx1+1,i1â‰¤fx2,jâˆ’1+wx2+1,i1,fx2,jâˆ’1+wx2+1,i2â‰¤fx1,jâˆ’1+wx1+1,i2f_{x_1,j-1}+w_{x_1+1, i_1}\\le f_{x2,j-1}+w_{x_2+1, i_1},f_{x_2,j-1}+w_{x_2+1,i_2}\\le f_{x_1,j-1}+w_{x_1+1,i_2}fx1â€‹,jâˆ’1â€‹+wx1â€‹+1,i1â€‹â€‹â‰¤fx2,jâˆ’1â€‹+wx2â€‹+1,i1â€‹â€‹,fx2â€‹,jâˆ’1â€‹+wx2â€‹+1,i2â€‹â€‹â‰¤fx1â€‹,jâˆ’1â€‹+wx1â€‹+1,i2â€‹â€‹ã€‚å½“ä¸¤ä¸ªç­‰å·åŒæ—¶æˆç«‹æ—¶ï¼Œä»¤ x2â‰¥x1x_2\\ge x_1x2â€‹â‰¥x1â€‹ ä¸€å®šèƒ½å–åˆ°ä¸€ä¸ªæœ€ä¼˜è§£ã€‚å¦åˆ™å¯ä»¥å¾—åˆ° wx2+1,i1âˆ’wx1+1,i1&gt;wx2+1,i2âˆ’wx1+1,i2w_{x_2+1,i_1}-w_{x_1+1,i_1} &gt; w_{x_2+1,i_2} - w_{x_1+1,i_2}wx2â€‹+1,i1â€‹â€‹âˆ’wx1â€‹+1,i1â€‹â€‹&gt;wx2â€‹+1,i2â€‹â€‹âˆ’wx1â€‹+1,i2â€‹â€‹ï¼Œç”±äºi2&gt;i1i_2&gt;i_1i2â€‹&gt;i1â€‹ï¼Œè¿™ä¸ªä¸œè¥¿æ˜¾ç„¶æ˜¯ä¸æˆç«‹çš„ã€‚ è¿™ä¸ª DP æˆ‘ä»¬å¯ä»¥çœ‹ä½œæ˜¯åš kkk è½®ã€‚æˆ‘ä»¬å¯ä»¥é‡‡ç”¨æ•´ä½“äºŒåˆ†çš„æ€æƒ³ï¼Œæ±‚è§£çš„è¯¢é—®æ˜¯å½“å‰è¿™ä¸€è½® DP æ•°ç»„çš„å€¼ï¼Œæ¯ä¸€æ¬¡åˆ†æ²»æˆ‘ä»¬è¦æ±‚è§£ midmidmid çš„ç­”æ¡ˆï¼Œæ‰¾åˆ°å…¶è½¬ç§»ç‚¹ä½œä¸ºå•è°ƒæ€§çš„åˆ†ç•Œç‚¹ã€‚ æ—¶é—´å¤æ‚åº¦ O(knlogâ¡n)O(kn\\log n)O(knlogn)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 1e12; int n, k, m; int a[100005], cnt[100005], L = 1, R; i64 f[22][100005], sum; i64 calc(int cl, int cr) &#123; for (; L > cl; --L) sum += cnt[a[L - 1]], ++cnt[a[L - 1]]; for (; R &lt; cr; ++R) sum += cnt[a[R + 1]], ++cnt[a[R + 1]]; for (; L &lt; cl; ++L) --cnt[a[L]], sum -= cnt[a[L]]; for (; R > cr; --R) --cnt[a[R]], sum -= cnt[a[R]]; return sum; &#125; void divide(int ql, int qr, int l, int r) &#123; // æ±‚ [ql, qr] çš„ DP å€¼ï¼Œæœ€ä¼˜å†³ç­–ç‚¹åœ¨ [l, r] if (l > r) return; int mid = ql + qr >> 1, pos; i64 minn = INF; for (int i = l; i &lt;= min(mid, r); ++i) &#123; // æœ€å¤§åªèƒ½åˆ° mid i64 val = f[k - 1][i - 1] + calc(i, mid); if (val &lt; minn) minn = val, pos = i; &#125; f[k][mid] = minn; if (ql == qr) return; divide(ql, mid, l, pos); divide(mid + 1, qr, pos, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); f[0][0] = 0; for (int i = 1; i &lt;= n; ++i) f[0][i] = INF; for (k = 1; k &lt;= m; ++k) divide(1, n, 1, n); printf(\"%lld\\n\", f[m][n]); return 0; &#125; å®é™…ä¸Šè¿™ä¸€ç±»é—®é¢˜çš„å…±åŒç‰¹å¾æ˜¯è½¬ç§»ç‚¹å•è°ƒï¼Œæ‰€ä»¥ç»´æŠ¤æŒ‡é’ˆæ¥è·Ÿè¸ªåˆ†æ²»é‡å¿ƒï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚ çº¿æ®µæ ‘åˆ†æ²» å…¶å®ä¹‹å‰å°±è§è¿‡çº¿æ®µæ ‘åˆ†æ²»ï¼šæ•°å­¦è®¡ç®—ã€‚æˆ‘ä»¬åŸºäºæ—¶é—´ç”¨çº¿æ®µæ ‘è¿›è¡Œæ“ä½œã€‚åŸºäºæ—¶é—´ï¼Ÿè¿™ä¸å°±æ˜¯ CDQ åˆ†æ²»å—ï¼Ÿ å®é™…ä¸Šçº¿æ®µæ ‘åˆ†æ²»å°±æ˜¯ä¸€ç§ç»´æŠ¤æ—¶é—´åŒºé—´çš„æ•°æ®ç»“æ„ï¼Œè€Œä¸”è¿™ç©æ„æ˜¯å¯ä»¥åœ¨çº¿çš„ï¼ˆåªéœ€è¦æ¯æ¬¡éƒ½æŸ¥è¯¢ä¸€ä¸‹å³å¯ï¼Œè™½ç„¶è¿™æ ·å¯èƒ½å¾ˆæ…¢ï¼‰ï¼è€Œä¸”è¿˜å¯ä»¥æ”¯æŒæ’¤é”€æ“ä½œï¼è¿™æ˜¯æ™®é€š CDQ è¾¾ä¸åˆ°çš„é«˜åº¦ï¼ [CF601E] A Museum Robbery.ç»´æŠ¤ä¸€ä¸ªå›ºå®šä½“ç§¯çš„ 01 èƒŒåŒ…ï¼Œæ”¯æŒæ·»åŠ ã€åˆ é™¤ç‰©å“å’ŒæŸ¥è¯¢ç­”æ¡ˆã€‚ èƒŒåŒ…æ·»åŠ ç‰©å“å¥½åšåˆ é™¤ä¸å¥½åšã€‚å»ºç«‹ä¸€æ£µåŸºäºè¯¢é—®æ—¶é—´çš„çº¿æ®µæ ‘ï¼Œç»Ÿè®¡æ¯ä¸€ä¸ªç‰©å“çš„æœ‰æ•ˆæœŸå¹¶åœ¨çº¿æ®µæ ‘ä¸ŠåŒºé—´ä¿®æ”¹æ·»åŠ ç‰©å“ï¼Œæœ€åç»Ÿä¸€æŸ¥è¯¢è®¡ç®—ä¸€éå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int B = 10000019; const int M = 1000000007; int n, k, m, tot = 0, tt = 1, tmp[1005]; struct item &#123; int l, r, v, w; &#125; E[15005]; vector&lt;item> T[120005]; void update(int o, int l, int r, int x, int y, int val) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].emplace_back(E[val]), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, val); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, val); &#125; void solve(int o, int l, int r, int *f) &#123; int g[1005]; memcpy(g, f, sizeof(g)); for (item x : T[o]) for (int j = k; j >= x.v; --j) g[j] = max(g[j], g[j - x.v] + x.w); if (l == r) &#123; int res = 0; for (int i = k; i >= 1; --i) res = (1ll * res * B + g[i]) % M; return printf(\"%d\\n\", res), void(); &#125; int mid = l + r >> 1; solve(o &lt;&lt; 1, l, mid, g); solve(o &lt;&lt; 1 | 1, mid + 1, r, g); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; int v, w; scanf(\"%d%d\", &amp;w, &amp;v); E[++tot] = &#123;tt, -1, v, w&#125;; &#125; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int op; scanf(\"%d\", &amp;op); if (op == 1) &#123; int v, w; scanf(\"%d%d\", &amp;w, &amp;v); E[++tot] = &#123;tt, -1, v, w&#125;; &#125; else if (op == 2) &#123; int x; scanf(\"%d\", &amp;x); E[x].r = tt - 1; &#125; else ++tt; &#125; --tt; for (int i = 1; i &lt;= tot; ++i) &#123; if (E[i].r == -1) E[i].r = tt; if (E[i].l &lt;= E[i].r) update(1, 1, tt, E[i].l, E[i].r, i); &#125; solve(1, 1, tt, tmp); return 0; &#125; æ ‘åˆ†æ²» å‚è€ƒã€Šæ ‘å½¢é—®é¢˜è¿›é˜¶ã€‹ã€‚ ç»å…¸é—®é¢˜ è¿™é‡Œè®°å½•äº†ä¸€äº›ç»å…¸é—®é¢˜ï¼Œä½†æ˜¯å¾€å¾€é‡åˆ°æ—¶åˆä¸çŸ¥è¯¥å¦‚ä½•å¤„ç†ã€‚ éšæœºåŒ–ç®—æ³• æœ‰çš„æ—¶å€™ä¸çŸ¥é“æ€ä¹ˆåšï¼Ÿæˆ–è€…é‡åˆ°ç¥ç§˜çš„æäº¤ç­”æ¡ˆé¢˜ï¼ˆæœ‰äº›æäº¤ç­”æ¡ˆæ˜¯ä¸å¯åšä¼˜åŒ–é¢˜ï¼‰ï¼Ÿå¯ä»¥è€ƒè™‘ä½¿ç”¨éšæœºåŒ–ã€‚ éšæœºåŒ–æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯æ“ä½œæ¬¡æ•°ä¸€å®šï¼Œæ­£ç¡®æ€§ä¸è¿›è¡Œçš„è½®æ•°æœ‰å…³ï¼ˆæ¨¡æ‹Ÿé€€ç«ç­‰ï¼‰ï¼›å¦ä¸€ç§æ˜¯æœŸæœ›æ“ä½œæ¬¡æ•°ï¼Œè¦æ±‚æ•°æ®éšæœºï¼ˆé™¤éä½ çš„æ–¹æ³•å¾ˆç¥ç§˜ï¼Œå‡ºé¢˜äººæ²¡æƒ³åˆ°ï¼Œä½†æ˜¯å¦‚æœäº¤äº’åº“æ˜¯è‡ªé€‚åº”çš„å°±æ²¡è¾™äº†ï¼‰ã€‚ éšæœºåŒ–å‡½æ•° mt19937 Rnd(time(0)); int rndint(int l, int r) &#123; return uniform_int_distribution&lt;>(l, r)(Rnd); &#125; double rnddb(int l, int r) &#123; return uniform_real_distribution&lt;>(l, r)(Rnd); &#125; çˆ¬å±±æ³• å¯¹äºå•å³°å‡½æ•°ï¼Œä¸‰åˆ†å¯èƒ½å¾ˆéš¾å®ç°ï¼Œé‚£ä¹ˆå¯ä»¥è€ƒè™‘ä½¿ç”¨çˆ¬å±±ã€‚å¦‚æœå½“ç›®å‰æ— æ³•ç›´æ¥åˆ°è¾¾æœ€ä¼˜è§£ï¼Œä½†æ˜¯å¯ä»¥åˆ¤æ–­ä¸¤ä¸ªè§£å“ªä¸ªæ›´ä¼˜çš„æ—¶å€™ï¼Œæ ¹æ®ä¸€äº›åé¦ˆä¿¡æ¯ç”Ÿæˆä¸€ä¸ªæ–°çš„å¯èƒ½è§£ã€‚ [JSOI2008] çƒå½¢ç©ºé—´äº§ç”Ÿå™¨ã€‚ç»™å‡º nnn ç»´ç©ºé—´çš„ n+1n+1n+1 ä¸ªç‚¹ï¼Œæ±‚å‡ºçƒå¿ƒï¼ˆä¿è¯å­˜åœ¨ï¼‰ã€‚ å¯¹äºæ¯ä¸€ä¸ªç»´åº¦éƒ½æ˜¯å•å³°å‡½æ•°ï¼Œå› æ­¤å¯ä»¥é‡‡ç”¨çˆ¬å±±æ³•ã€‚ å‡å®šçƒå¿ƒä¸ºæ‰€æœ‰ç‚¹çš„é‡å¿ƒï¼Œç„¶åæ±‚å‡ºæ‰€æœ‰ç‚¹åˆ°çƒå¿ƒè·ç¦»çš„å¹³å‡å€¼ï¼Œç„¶åå¯ä»¥è®¡ç®—æ¯ä¸ªç»´åº¦ä¸Šçƒå¿ƒè·ç¦»çš„æ”¹å˜å€¼ï¼ˆåˆ°æŸä¸ªç‚¹çš„è·ç¦»ä¸å¹³å‡è·ç¦»å·® Ã—\\timesÃ— å·®è·è´¡çŒ®ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; double dis[15]; // ç­”æ¡ˆåˆ°ç‚¹çš„è·ç¦» double ans[15], cans[15], a[15][15]; void check(void) &#123; double tot = 0; for (int i = 1; i &lt;= n + 1; ++i) &#123; dis[i] = cans[i] = 0; for (int j = 1; j &lt;= n; ++j) dis[i] += (a[i][j] - ans[j]) * (a[i][j] - ans[j]); tot += (dis[i] = sqrt(dis[i])) / (n + 1); &#125; for (int i = 1; i &lt;= n + 1; ++i) for (int j = 1; j &lt;= n; ++j) cans[j] += (dis[i] - tot) / tot * (a[i][j] - ans[j]); // dis[i] - tot ä¸ºå½“å‰ç‚¹ä¸åŸçƒå¿ƒçš„è·ç¦»å·®ä¸å¹³å‡è·ç¦»çš„å·®ï¼Œé™¤ä»¥ tot ä»¥è®¡ç®—è¿™ä¸€ç»´åº¦å¯¹å¹³å‡è·ç¦»çš„è´¡çŒ®å æ¯” // a[i][j] - ans[j] ä¸ºåœ¨å½“å‰ç»´åº¦çš„å½“å‰ç‚¹ä¸åŸçƒå¿ƒè·ç¦»å·®ï¼Œæ ¹æ®æ­¤å€¼è¿›è¡Œç§»åŠ¨ &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n + 1; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%lf\", &amp;a[i][j]), ans[j] += a[i][j]; for (int i = 1; i &lt;= n; ++i) ans[i] /= (n + 1); // æ”¾åˆ°é‡å¿ƒ for (double T = 20000; T > 1e-4; T *= 0.99996) &#123; check(); for (int i = 1; i &lt;= n; ++i) ans[i] += cans[i] * T; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%.3lf \", ans[i]); return putchar('\\n'), 0; &#125; æ¨¡æ‹Ÿé€€ç« [JSOI2004] å¹³è¡¡ç‚¹ã€‚ ç»™å‡ºæ¨¡æ‹Ÿé€€ç«çš„ä¸€èˆ¬å®ç°æ–¹å¼ï¼šæ–°çš„ç­”æ¡ˆé€‰æ‹©è¦ä¸ºéšæœºæ•´æ•°ä¹˜ä¸Šå½“å‰çš„æ¸©åº¦ï¼Œç„¶åä»¥ eÎ”/Te^{\\Delta / T}eÎ”/T çš„æ¦‚ç‡æ¥å—å½“å‰éæœ€ä¼˜è§£ï¼ˆä¿è¯ Î”\\DeltaÎ” ä¸ºæ­£ï¼Œå¤§äº rnd(0, 1) æ¥å—ï¼Œå°äºä¸æ¥å—ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int x[1005], y[1005], w[1005]; mt19937 Rand(20070521); double energy(double X, double Y) &#123; double r = 0; for (int i = 1; i &lt;= n; ++i) r += hypot(X - x[i], Y - y[i]) * w[i]; return r; &#125; int rndint(int l, int r) &#123; return uniform_int_distribution&lt;int>(l, r)(Rand); &#125; void sa(double a, double b) &#123; double ax = a, ay = b, T = 100, ans = energy(ax, ay); const double delta = 0.99; while (T > 1e-14) &#123; double xx = ax + rndint(-INT_MAX, INT_MAX) * T, yy = ay + rndint(-INT_MAX, INT_MAX) * T; double now = energy(xx, yy), cmp = ans - now; if (cmp > 0) ans = now, ax = xx, ay = yy; else if (exp(cmp / T) * INT_MAX > rndint(0, INT_MAX)) ax = xx, ay = yy; T *= delta; &#125; printf(\"%.3lf %.3lf\\n\", ax, ay); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); double a = 0, b = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d%d\", x + i, y + i, w + i), a += x[i] * w[i] / n, b += y[i] * w[i] / n; return sa(a, b), 0; &#125; å®é™…ä¸Šå¯¹äºæ¨¡æ‹Ÿé€€ç«ï¼Œåªæœ‰åœ¨ Î”T\\Delta TÎ”T è¾ƒå°çš„æ—¶å€™ï¼Œå–æ‰€æœ‰æƒ…å†µçš„æœ€ä¼˜ç­”æ¡ˆä¼šå¾—åˆ°éå¸¸æ£’çš„ç­”æ¡ˆï¼Œä½†æ˜¯ Î”T\\Delta TÎ”T è¶³å¤Ÿå¤§æ—¶æ²¡ä»€ä¹ˆåŒºåˆ«ï¼Œç›´æ¥å°†ç­”æ¡ˆä¹Ÿæ”¹æˆä¸ä¼˜çš„ä¹Ÿå¯ã€‚ å…¶å®ƒéšæœºåŒ– æ²¡æœ‰ç»Ÿä¸€çš„æ–¹å¼ã€‚æœ‰äº›å¥—è·¯å¦‚éšæœºæ’’ç‚¹ï¼ŒéšæœºåŒ–è´ªå¿ƒç­‰ï¼Œæ›´å¤šçš„è¿˜æ˜¯è¦æ ¹æ®å…·ä½“çš„é—®é¢˜è¿›è¡Œåˆ†æã€‚ å…¶å®ƒä¼˜åŒ–æŠ€å·§ è¿™é‡Œæ”¾ç½®äº†ä¸€äº›æ‚é¡¹ä¼˜åŒ–æŠ€å·§ã€‚ ç®€å•å†…å®¹ åœ¨ã€Šæé«˜ä¼˜åŒ–æŠ€å·§ã€‹å‡ºç°ã€‚ è´ªå¿ƒï¼šåŒ…æ‹¬æ’åºè´ªå¿ƒå’Œåæ‚”è´ªå¿ƒã€‚ åŒæŒ‡é’ˆï¼šæ‰«æå…·æœ‰å•è°ƒæ€§çš„å†…å®¹ã€‚ å‰ç¼€å’Œä¸å·®åˆ†ï¼šå¿…å¤‡æŠ€èƒ½ã€‚ å•è°ƒæ ˆä¸å•è°ƒé˜Ÿåˆ—ï¼šç»´æŠ¤å•è°ƒæ€§çš„å¸¸è§æ‰‹æ®µã€‚ æ ¹å·åˆ†æ²» æ ¹å·åˆ†æ²»æ˜¯ä¸€ç§æŒ‰è§„æ¨¡å¤§å°åˆ†ç±»è®¨è®ºçš„æ€æƒ³ã€‚å¯¹äºè§„æ¨¡ä¸º xxx çš„é—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ O(x)O(x)O(x) å’Œ O(nx)O(\\frac{n}{x})O(xnâ€‹) çš„å¤æ‚åº¦è§£å†³ï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ xâ‰¤nx\\le \\sqrt{n}xâ‰¤nâ€‹ æ—¶ä½¿ç”¨ O(x)O(x)O(x) ç®—æ³•ï¼Œå¦åˆ™ä½¿ç”¨ O(nx)O(\\frac{n}{x})O(xnâ€‹) ç®—æ³•ã€‚è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)O(\\sqrt{n})O(nâ€‹)ã€‚ [Luogu P3396] å“ˆå¸Œå†²çªã€‚B å›å¯¹ hash å†²çªå¾ˆæ„Ÿå…´è¶£ã€‚ä»–ä¼šç»™å‡ºä¸€ä¸ªæ­£æ•´æ•°åºåˆ— value\\text{value}valueã€‚è‡ªç„¶ï¼ŒB å›ä¼šæŠŠè¿™äº›æ•°æ®å­˜è¿› hash æ± ã€‚ç¬¬ valuek\\text{value}_kvaluekâ€‹ ä¼šè¢«å­˜è¿› (k mod p)(k \\bmod p)(kmodp) è¿™ä¸ªæ± ã€‚è¿™æ ·å°±èƒ½é€ æˆå¾ˆå¤šå†²çªã€‚B å›ä¼šç»™å®šè®¸å¤šä¸ª ppp å’Œ xxxï¼Œè¯¢é—®åœ¨æ¨¡ ppp æ—¶ï¼Œxxx è¿™ä¸ªæ± å†… æ•°çš„æ€»å’Œã€‚å¦å¤–ï¼ŒB å›ä¼šéšæ—¶æ›´æ”¹ valuek\\text{value}_kvaluekâ€‹ã€‚æ¯æ¬¡æ›´æ”¹ç«‹å³ç”Ÿæ•ˆã€‚å¯¹äº 100%100\\%100% çš„æ•°æ®ï¼Œæœ‰ nâ‰¤150000,mâ‰¤150000n\\leq 150000,m\\leq 150000nâ‰¤150000,mâ‰¤150000. å½“ x&gt;nx&gt;\\sqrt{n}x&gt;nâ€‹ çš„æ—¶å€™ï¼Œæš´åŠ›å³å¯ã€‚ å½“ xâ‰¤nx\\le\\sqrt{n}xâ‰¤nâ€‹ï¼Œè€ƒè™‘åœ¨ä¿®æ”¹æ—¶å°±æ›´æ–°ç­”æ¡ˆï¼Œè¯¢é—®æ—¶ç›´æ¥è¾“å‡ºã€‚ è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä¸º O(mn)O(m\\sqrt{n})O(mnâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, t; int a[150005]; int res[400][400]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); t = sqrt(n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); for (int j = 1; j &lt;= t; ++j) res[j][i % j] += a[i]; &#125; char s[5]; int x, y; while (m--) &#123; scanf(\"%s%d%d\", s, &amp;x, &amp;y); if (s[0] == 'A') &#123; if (x > t) &#123; int ans = 0; for (int i = y; i &lt;= n; i += x) ans += a[i]; printf(\"%d\\n\", ans); &#125; else printf(\"%d\\n\", res[x][y]); &#125; else &#123; for (int i = 1; i &lt;= t; ++i) res[i][x % i] += y - a[x]; a[x] = y; &#125; &#125; return 0; &#125; æ— å‘å›¾ä¸‰å…ƒç¯è®¡æ•° Portal. è®©åº¦æ•°å°çš„ç‚¹å‘åº¦æ•°å¤§çš„ç‚¹è¿è¾¹ï¼Œç„¶åæš´åŠ› for æŸ¥æ‰¾ã€‚å¦‚æœä¸€ä¸ªç‚¹çš„åº¦æ•°å¤§äº m\\sqrt{m}mâ€‹ï¼Œè¿™æ ·çš„ç‚¹ä¸è¶…è¿‡ m\\sqrt{m}mâ€‹ ä¸ªï¼›å¦‚æœä¸€ä¸ªç‚¹åº¦æ•°å°äº m\\sqrt{m}mâ€‹ï¼Œé‚£ä¹ˆè¿™æ ·çš„ç‚¹æœ€å¤š mmm ä¸ªã€‚å› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º O(mm)O(m\\sqrt{m})O(mmâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, m, ans, deg[100005]; int u[200005], v[200005], vis[100005]; vector&lt;int> G[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", u + i, v + i); ++deg[u[i]]; ++deg[v[i]]; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x = u[i], y = v[i]; if (deg[x] > deg[y] || (deg[x] == deg[y] &amp;&amp; x > y)) swap(x, y); G[x].emplace_back(y); &#125; for (int u = 1; u &lt;= n; ++u) &#123; for (int v : G[u]) vis[v] = u; for (int v : G[u]) for (int w : G[v]) if (vis[w] == u) ++ans; &#125; printf(\"%d\\n\", ans); return 0; &#125; å››å…ƒç¯è®¡æ•° æ¨¡æ¿ã€‚æ•´ä½“æ€è·¯è·Ÿä¸‰å…ƒç¯è®¡æ•°ä¸€æ ·ï¼Œè€ƒè™‘æ€æ ·æ•°çš„ä¸é‡ä¸æ¼ã€‚æšä¸¾ä¸€ä¸ªèµ·ç‚¹ uuuï¼Œä¿è¯å®ƒæ˜¯æ’åæœ€å¤§çš„ç‚¹ï¼Œç„¶åæšä¸¾ä¸å®ƒè·ç¦»ä¸º 222 çš„ç‚¹ï¼Œç»Ÿè®¡å…¶ä¸­æ— åºå¯¹ (x,y)(x,y)(x,y) çš„ä¸ªæ•°å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, ans, cnt[100005]; int deg[100005], a[100005], rk[100005]; vector&lt;int> G[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); ++deg[u]; ++deg[v]; &#125; for (int i = 1; i &lt;= n; ++i) a[i] = i; sort(a + 1, a + n + 1, [&amp;](int x, int y) &#123; return deg[x] &lt; deg[y] || (deg[x] == deg[y] &amp;&amp; x &lt; y); &#125;); for (int i = 1; i &lt;= n; ++i) rk[a[i]] = i; for (int u = 1; u &lt;= n; ++u) &#123; for (int v : G[u]) if (rk[u] > rk[v]) for (int w : G[v]) if (rk[u] > rk[w]) ans += cnt[w]++; for (int v : G[u]) if (rk[u] > rk[v]) for (int w : G[v]) cnt[w] = 0; &#125; return !printf(\"%d\\n\", ans); &#125; Problemset å—¯ï¼Œé¢˜ç›®çœŸçš„å¾ˆæ‚ï¼ äºŒåˆ†ä¸ä¸‰åˆ† åŒ…æ‹¬äºŒåˆ†å’Œä¸‰åˆ†æ³•ä»¥åŠå®ƒä»¬çš„åº”ç”¨ã€‚ [JXOI2017] åŠ æ³• Portal. äºŒåˆ†ç­”æ¡ˆï¼Œæ‰«æçº¿ç»´æŠ¤æ“ä½œçš„å·¦ç«¯ç‚¹ï¼Œå³ç«¯ç‚¹è´ªå¿ƒåœ°é€‰æœ€å¤§çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, k, v; int a[200005]; struct Operation &#123; int l, r; bool operator&lt;(const Operation&amp; a) const &#123; if (l != a.l) return l &lt; a.l; return r > a.r; &#125; &#125; d[200005]; int C[200005]; inline void add(int x, int k) &#123; for (; x &lt;= n; x += x &amp; -x) C[x] += k; &#125; inline void add(int l, int r, int k) &#123; add(l, k); add(r + 1, -k); &#125; inline int query(int x) &#123; int r = 0; for (; x; x -= x &amp; -x) r += C[x]; return r; &#125; bool check(int x) &#123; // æœ€å°å€¼å¤§äºç­‰äº x memset(C, 0, sizeof C); for (int i = 1; i &lt;= n; ++i) add(i, a[i] - a[i - 1]); int cnt = 0, p = 0; priority_queue&lt;int> q; for (int i = 1; i &lt;= n; ++i) &#123; while (p &lt; m &amp;&amp; d[p + 1].l == i) q.push(d[++p].r); while (!q.empty() &amp;&amp; query(i) &lt; x) &#123; // printf(\"A %d %d\\n\", i, q.top()); add(i, q.top(), v), q.pop(), ++cnt; &#125; if (query(i) &lt; x) return 0; &#125; return cnt &lt;= k; &#125; int main(void) &#123; ios::sync_with_stdio(0); int T; cin >> T; while (T--) &#123; cin >> n >> m >> k >> v; int L = 2e8, R; for (int i = 1; i &lt;= n; ++i) cin >> a[i], L = min(L, a[i]); for (int i = 1; i &lt;= m; ++i) cin >> d[i].l >> d[i].r; sort(d + 1, d + m + 1); R = L + m * v + 1; L -= 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) L = mid; else R = mid; &#125; cout &lt;&lt; L &lt;&lt; \"\\n\"; &#125; return 0; &#125; [CF1661F] Teleporters Portal. å¯ä»¥å°†åŸé—®é¢˜åˆ’åˆ†æˆå‡ æ®µï¼Œç„¶åå¯¹äºæ¯ä¸€æ®µæ”¾ç½®ä¼ é€å™¨çš„è¯åˆ†çš„çº¦å‡åŒ€è¶Šå¥½ï¼Œå…¨å±€çš„æœ€å°ä¸¤ç›¸é‚»ä¼ é€æœºè·ç¦»åº”è¯¥æ˜¯ä¸€ä¸ªï¼ˆå°½å¯èƒ½æ»¡è¶³å¹³å‡ï¼‰ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ f(x,k)f(x,k)f(x,k) æ¥è¡¨ç¤º 0â†’x0\\rightarrow x0â†’x ä¸­é¢å¤–æ’å…¥ kkk ä¸ªçš„æœ€å°ä»£ä»·ï¼Œæ˜¾ç„¶æ˜¯å¥½æ±‚çš„ã€‚ ç›´æ¥äºŒåˆ†éœ€è¦å®‰è£…çš„ä¼ é€æœºæ•°é‡ï¼Ÿæˆ‘ä»¬å¥½åƒæ²¡æœ‰åŠæ³• checkï¼ŒåªçŸ¥é“æœ€å¤šä¼ é€æœºæ•°é‡çš„è¯æ²¡æœ‰ä¸€ä¸ªåˆé€‚çš„è´ªå¿ƒç­–ç•¥ã€‚æˆ‘ä»¬å¯¹å¦ä¸€ä¸ªæ¡ä»¶â€”â€”æ€»èŠ±è´¹è¿›è¡Œè€ƒè™‘ã€‚å› ä¸ºèŠ±è´¹è¶Šå¤§ç›´æ¥æ„å‘³ç€ä¼ é€æœºæ•°é‡è¶Šå°‘ã€‚ æ³¨æ„åˆ° f(x,kâˆ’1)âˆ’f(x,k)f(x,k-1)-f(x,k)f(x,kâˆ’1)âˆ’f(x,k) éšç€ kkk çš„å¢å¤§å•è°ƒä¸å¢ï¼Œè¿™æ ·å¯ä»¥åœ¨å¤–å±‚äºŒåˆ†å…¶å€¼ vvv æ¥ä»£è¡¨ä¸€ä¸ªæ®µå†…çš„æœ€å°ä¼ é€æœºè·ç¦»ï¼ˆç±»ä¼¼ wqs çš„æ€æƒ³ï¼‰ï¼Œæ‰¾å‡ºä¸€ä¸ª f(x,kâˆ’1)âˆ’f(x,k)â‰¥vf(x,k-1)-f(x,k)\\ge vf(x,kâˆ’1)âˆ’f(x,k)â‰¥v çš„æœ€å¤§ kkkï¼Œè€Œ kkk è¶Šå¤§èŠ±è´¹è¶Šå°ï¼Œç›´æ¥åˆ©ç”¨ kkk æ¥è¿›è¡Œè´ªå¿ƒæ±‚å‡ºæ¯ä¸€æ®µçš„æœ€å°ä»£ä»·ï¼Œä¸ mmm æ¯”è¾ƒæ¥ç¡®å®šäºŒåˆ†çš„ç­”æ¡ˆã€‚ è®¾äºŒåˆ†å‡ºæ¥çš„ç­”æ¡ˆæ˜¯ kkkï¼Œé€‰å®Œä¹‹å mmm çš„å€¼è¿˜æœ‰å‰©ä½™ï¼Œæˆ‘ä»¬å°½å¯èƒ½å¤šçš„å€¼é€‰æ‹© k+1k+1k+1 æ¥æ¦¨å¹² mmm çš„å‰©ä½™ä»·å€¼ã€‚ æ—¶é—´å¤æ‚åº¦ O(nlogâ¡2V)O(n\\log^2 V)O(nlog2V)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define i64 long long #define pii pair&lt;i64, int> #define fi first #define se second using namespace std; const i64 INF = 1e18 + 500; int n; i64 m; int a[200005]; inline i64 f(int x, int k) &#123; // 0->x æ”¾ k i64 va = (x + k) / (k + 1), vb = x / (k + 1); int ra = x % (k + 1), rb = k + 1 - ra; return ra * va * va + rb * vb * vb; &#125; int calc(int len, i64 v) &#123; // f(len, x - 1) - f(len, x) >= v çš„æœ€å° x int L = 0, R = len; while (L + 1 != R) &#123; int mid = L + R >> 1; if (f(len, mid - 1) - f(len, mid) >= v) L = mid; else R = mid; &#125; return L; &#125; pii check(i64 v) &#123; pii ans(0, 0); for (int i = 1; i &lt;= n; ++i) &#123; int x = calc(a[i], v); ans.fi += f(a[i], x), ans.se += x; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = n; i >= 1; --i) a[i] -= a[i - 1]; scanf(\"%lld\", &amp;m); i64 L = -1, R = INF + 1; while (L + 1 != R) &#123; i64 mid = L + R >> 1; if (check(mid).fi &lt;= m) L = mid; else R = mid; &#125; pii res = check(L + 1); printf(\"%lld\\n\", res.se + (res.fi - m + L - 1) / L); return 0; &#125; [ZJOI2018] èƒ– Portal. ä» 000 å·ç‚¹åˆ°è¾¾æŸä¸€ä¸ªç‚¹åï¼Œå¯ä»¥è¢«æ›´æ–°çš„ç­æœ›å¡”æ˜¾ç„¶æ˜¯ä¸€æ®µè¿ç»­çš„åŒºé—´ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åˆ†åˆ«å¯¹åšå³ç«¯ç‚¹è¿›è¡ŒäºŒåˆ†ã€‚ è®¾è¦ä» ppp æ›´æ–°ï¼Œè¿™æ¡è·¯çš„è·ç¦»ä¸º lllï¼Œåˆ°è¾¾ç¬¬ xxx ä¸ªç‚¹ï¼Œé‚£ä¹ˆä»¤ d=âˆ£lâˆ’xâˆ£d=|l-x|d=âˆ£lâˆ’xâˆ£ï¼Œåœ¨ [xâˆ’d,x+d][x-d,x+d][xâˆ’d,x+d] å½“ä¸­ä¸åº”è¯¥å­˜åœ¨è·ç¦»å°äº ppp æ—¶è·ç¦»çš„ç‚¹ã€‚é¢„å¤„ç†å‡ºå›¾ä¸Šè·ç¦»çš„å‰ç¼€å’Œ disdisdisï¼Œè·ç¦»çš„æœ€å°å€¼è¦åˆ†åœ¨ xxx çš„å·¦å³è®¨è®ºï¼Œåœ¨ xxx å·¦è¾¹æ—¶æ˜¯ disx+(lâˆ’disp)dis_x+(l-dis_p)disxâ€‹+(lâˆ’dispâ€‹)ï¼Œå³è¾¹æ—¶æ˜¯ âˆ’disx+(l+disp)-dis_x+(l+dis_p)âˆ’disxâ€‹+(l+dispâ€‹)ï¼Œè¯¢é—®å‰ ST è¡¨é¢„å¤„ç†ä¸¤ä¸ªä¿¡æ¯å³å¯æ±‚å‡ºè·ç¦»çš„æœ€å°å€¼ï¼ˆå»ºç«‹å¤§å°ä¸º KKK çš„ ST è¡¨ï¼Œè¯¢é—®çš„æ—¶å€™ç›´æ¥äºŒåˆ†å‡ºå·¦å³ç«¯ç‚¹çš„ä½ç½®ï¼‰ã€‚ æ³¨æ„è·ç¦»ç›¸ç­‰æ—¶æ›´æ–°é¡ºåºçš„é—®é¢˜ï¼ŒäºŒåˆ†å³ç«¯ç‚¹æ—¶è¦å¯¹ x+dx+dx+d çš„ä½ç½®åšä¸€ä¸ªå•ç‹¬çš„è®¨è®ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 2e18; int n, m, K; struct Node &#123; int p, d; bool operator&lt; (const Node &amp;a) const &#123; return p &lt; a.p; &#125; &#125; a[200005]; i64 dis[200005]; namespace ST &#123; int lg[200005]; i64 f[18][200005], g[18][200005]; i64 query(int op, int l, int r) &#123; l = max(1, l); r = min(r, n); Node tmp = &#123;l, 0&#125;; l = lower_bound(a + 1, a + K + 1, tmp) - a; tmp = &#123;r, 0&#125;; r = upper_bound(a + 1, a + K + 1, tmp) - (a + 1); if (l > r) return INF; int k = lg[r - l + 1]; if (op == 1) return min(f[k][l], f[k][r - (1 &lt;&lt; k) + 1]); return min(g[k][l], g[k][r - (1 &lt;&lt; k) + 1]); &#125; void init(void) &#123; for (int i = 2; i &lt;= K; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= K; ++i) f[0][i] = a[i].d - dis[a[i].p], g[0][i] = a[i].d + dis[a[i].p]; for (int i = 1; i &lt;= lg[K]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= K; ++j) f[i][j] = min(f[i - 1][j], f[i - 1][j + (1 &lt;&lt; i - 1)]), g[i][j] = min(g[i - 1][j], g[i - 1][j + (1 &lt;&lt; i - 1)]); &#125; &#125; using namespace ST; bool checkl(int p, int x) &#123; // p æ›´æ–°åˆ° xï¼Œx &lt; p if (p == x) return 1; int d = abs(p - x); i64 t1 = query(1, x - d, x) + dis[x]; i64 t2 = query(2, x, x + d - 1) - dis[x]; i64 now = query(2, p, p) - dis[x]; return t1 > now &amp;&amp; t2 > now; &#125; int calcl(int p) &#123; int L = 0, R = p + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (checkl(p, mid)) R = mid; else L = mid; &#125; return R; &#125; bool checkr(int p, int x) &#123; // ä» p èƒ½å¦æ›´æ–°åˆ° xï¼Œx > p if (p == x) return 1; int d = abs(p - x); i64 t1 = query(1, x - d + 1, x) + dis[x]; i64 t2 = query(2, x, x + d - 1) - dis[x]; i64 now = query(1, p, p) + dis[x]; if (t1 &lt;= now || t2 &lt;= now) return 0; if (x + d &lt;= n) return query(2, x + d, x + d) - dis[x] >= now; // p åœ¨ x å·¦è¾¹ï¼Œç›¸ç­‰æ—¶ä¼šå…ˆæ›´æ–° return 1; &#125; int calcr(int p) &#123; int L = p - 1, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (checkr(p, mid)) L = mid; else R = mid; &#125; return L; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) scanf(\"%lld\", dis + i), dis[i] += dis[i - 1]; while (m--) &#123; scanf(\"%d\", &amp;K); for (int i = 1; i &lt;= K; ++i) scanf(\"%d%d\", &amp;a[i].p, &amp;a[i].d); sort(a + 1, a + K + 1); ST::init(); i64 ans = 0; for (int i = 1; i &lt;= K; ++i) ans += (calcr(a[i].p) - calcl(a[i].p) + 1); printf(\"%lld\\n\", ans); &#125; return 0; &#125; [USACO18OPEN] Talent Show G Portal.åˆ†æ•°è§„åˆ’ï¼Œä½†æ˜¯é™åˆ¶ bbb çš„å’Œè‡³å°‘ä¸º WWWã€‚ è¿™å›ä¸èƒ½ç®€å•çš„æ’åºäº†ã€‚ä½†æ˜¯ï¼æˆ‘ä»¬å¯ä»¥ç”¨ 01 èƒŒåŒ…çš„æ¨¡å‹è§£å†³è¿™ä¸ªé—®é¢˜ã€‚è®¾ f(i)f(i)f(i) ä»£è¡¨ä½“ç§¯ä¸º iii æ—¶çš„æœ€å¤§ä»·å€¼ã€‚ç‰¹åˆ«çš„ï¼Œå½“ iâ‰¥Wi\\ge Wiâ‰¥W æ—¶ï¼Œå°† iii å¼ºè¡Œèµ‹å€¼ä¸º WWWï¼Œè½¬ç§»çš„æ—¶å€™é‡‡ç”¨åˆ·è¡¨æ³•ã€‚è¿™æ ·å¹¶ä¸ä¼šå½±å“ç­”æ¡ˆï¼Œå› ä¸ºæ˜¯åˆ·è¡¨ï¼Œåˆ·å‡ºä¸€ä¸ª &gt;W&gt;W&gt;W çš„çŠ¶æ€å¯ä»¥ç›´æ¥å­˜åœ¨ f[W]f[W]f[W] é‡Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const double eps = 1e-5; int n, W; int a[300], b[300]; double f[1005]; bool check(double x) &#123; for (int i = 1; i &lt;= W; ++i) f[i] = -1e9; for (int i = 1; i &lt;= n; ++i) for (int j = W; j >= 0; --j) &#123; int k = min(W, j + b[i]); f[k] = max(f[k], f[j] + a[i] - x * b[i]); &#125; return f[W] > 0; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;W); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", b + i, a + i); double L = 0, R = 1e9; while (L + eps &lt; R) &#123; double mid = (L + R) / 2; if (check(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", int(L * 1000)); return 0; &#125; å€å¢ é¢˜ç›®éƒ½æ¯”è¾ƒç®€å•ã€‚ [SCOI2015] å›½æ——è®¡åˆ’ Portal. å…ˆå°†æˆ˜å£«æŒ‰ç…§å·¦ç«¯ç‚¹æ’åºï¼Œç„¶åå°†ç¯å¤åˆ¶æˆäºŒå€é“¾ã€‚æ³¨æ„åˆ°æ¯åè¾¹é˜²æˆ˜å£«çš„å¥”è¢­åŒºé—´éƒ½ä¸ä¼šè¢«å…¶ä»–è¾¹é˜²æˆ˜å£«çš„å¥”è¢­åŒºé—´æ‰€åŒ…å«ï¼Œæ‰€ä»¥è¿™æ ·æ’åºåå³ç«¯ç‚¹å°±æ˜¯é€’å¢çš„ã€‚è®¾ f(i)f(i)f(i) ä»£è¡¨ç¬¬ iii ä¸ªæˆ˜å£«èƒ½å°†å›½æ——ä¼ é€’ç»™çš„æœ€è¿œçš„æˆ˜å£«ç¼–å·ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ä¾æ¬¡æ±‚è§£ï¼Œä½†æ˜¯è¿™æ ·å•æ¬¡æ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ï¼æ³¨æ„åˆ°ç­”æ¡ˆå…·æœ‰å•è°ƒæ€§ï¼ˆæˆ˜å£«è¶Šå¤šå¥”è¢­è·ç¦»è¶Šé•¿ï¼‰ï¼ŒäºŒåˆ†ç­”æ¡ˆä¼¼ä¹å¹¶ä¸æ˜¯å¾ˆå¥½åšï¼ˆä¸çŸ¥é“è¿™ä¸ªæˆ˜å£«è·³åˆ°äº†å“ªé‡Œï¼‰ï¼Œå› æ­¤è€ƒè™‘å€å¢ï¼è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨ç¬¬ iii ä¸ªæˆ˜å£«å¼€å§‹å€Ÿç”¨ 2j2^j2jï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰çš„æˆ˜å£«çš„åŠ›é‡å¯ä»¥ä¼ é€’ç»™æœ€è¿œçš„æˆ˜å£«çš„ç¼–å·ï¼Œé‚£ä¹ˆå‚è€ƒå€å¢ LCA çš„æ–¹å¼ä»é«˜åˆ°ä½å¼€å§‹æšä¸¾ã€‚åŒæ—¶æ³¨æ„ï¼Œæœ€åä¸èƒ½è·‘åˆ° a[i].l+ma[i].l+ma[i].l+mï¼Œåªèƒ½è·‘åˆ°å®ƒå‰ä¸€ä¸ªï¼Œè¿™æ ·å†æ¥ä¸€ä¸ªæˆ˜å£«å°±ä¸€å®šèƒ½è·‘è¿‡å»ï¼ˆå› ä¸ºå¾ˆå¯èƒ½è·‘è¿‡ï¼Œæ‰€ä»¥æœ€åå† +1ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int f[22][400005]; // ç¬¬ i ~ i+2^j-1 ä¸ªæˆ˜å£«çš„å¥”è¢­ä½ç½® int Ans[200005]; struct soldier &#123; int id, l, r; bool operator &lt; (const soldier &amp;a) const &#123; return l &lt; a.l; &#125; &#125; a[400005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;a[i].l, &amp;a[i].r); if (a[i].r &lt; a[i].l) a[i].r += m; a[i].id = i; &#125; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i + n].id = a[i].id; a[i + n].l = a[i].l + m; a[i + n].r = a[i].r + m; &#125; for (int i = 1, p = i; i &lt;= n * 2; ++i) &#123; while (p &lt;= n * 2 &amp;&amp; a[p].l &lt;= a[i].r) ++p; f[0][i] = p - 1; &#125; for (int i = 1; i &lt; 20; ++i) for (int j = 1; j &lt;= n * 2; ++j) f[i][j] = f[i - 1][f[i - 1][j]]; for (int i = 1; i &lt;= n; ++i) &#123; int mx = a[i].l + m, ans = 1, p = i; // åˆå§‹æœ‰ 1 ä¸ªæˆ˜å£« for (int j = 19; j >= 0; --j) if (f[j][p] &amp;&amp; a[f[j][p]].r &lt; mx) ans += 1 &lt;&lt; j, p = f[j][p]; // å¥”è¢­åˆ° f[j][p] çš„å³ç«¯ç‚¹ Ans[a[i].id] = ans + 1; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", Ans[i]); putchar('\\n'); return 0; &#125; [CF1809F] Traveling in Berland Portal. å¦‚æœå½“å‰ä½ç½®æ²¹ä»·æ˜¯ 111ï¼Œé‚£ä¹ˆè‚¯å®šèƒ½åŠ æ»¡å°±åŠ æ»¡ï¼ˆä¼šç”¨å®Œï¼‰ï¼Œ222 çš„è¯èƒ½åŠ å¤šå°‘åŠ å¤šå°‘ã€‚è®¾ fif_{i}fiâ€‹ ä»£è¡¨ iii åˆ°ä¸‹ä¸€ä¸ªæ²¹ä»·æ˜¯ 111 çš„ä½ç½®çš„ä½ç½®ï¼Œsis_{i}siâ€‹ ä»£è¡¨ä»£ä»·ï¼Œå€å¢è¿™ä¸ªè¿‡ç¨‹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k; int a[400005], b[400005], f[19][400005]; // f ä¸ºä» j å¼€å§‹èµ°çš„ä¸‹ä¸€ä¸ª 1 çš„ä½ç½® i64 d[400005], s[19][400005]; // s ä¸ºä» j å¼€å§‹èµ°åˆ°ä¸‹ä¸€ä¸ª 1 ä½ç½®çš„æ¶ˆè€— i64 calc(int s, int t) &#123; i64 di = d[t] - d[s - 1]; if (b[s] == 1) return di &lt;= k ? di : di * 2 - k; return di * 2; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;k); int lg = 18; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), a[n + i] = a[i]; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i), b[n + i] = b[i]; for (int i = 1; i &lt;= n * 2; ++i) d[i] = d[i - 1] + a[i]; int nxt = n * 2 + 1; f[0][nxt] = nxt, s[0][nxt] = 0; for (int i = n * 2; i >= 1; --i) &#123; f[0][i] = nxt; s[0][i] = calc(i, nxt - 1); if (b[i] == 1) nxt = i; &#125; for (int i = 1; i &lt;= lg; ++i) for (int j = 1; j &lt;= n * 2 + 1; ++j) f[i][j] = f[i - 1][f[i - 1][j]], s[i][j] = s[i - 1][j] + s[i - 1][f[i - 1][j]]; for (int i = 1; i &lt;= n; ++i) &#123; int cur = i; i64 res = 0; for (int j = lg; j >= 0; --j) if (f[j][cur] &lt;= i + n) &#123; res += s[j][cur]; cur = f[j][cur]; &#125; printf(\"%lld \", res + calc(cur, i + n - 1)); &#125; putchar('\\n'); &#125; return 0; &#125; [???] æœ€å°ç”Ÿæˆæ ‘ ç»™å®šä¸€å¼ å¸¦æƒæ— å‘å›¾ï¼Œå…¶ä¸­è¾¹çš„ç¼–å·ä¸º 1âˆ¼m1\\sim m1âˆ¼mã€‚æŠŠè¿™äº›è¾¹åˆ†ç»„ï¼Œæ¯ç»„æ„æˆåŸå›¾çš„ä¸€æ£µç”Ÿæˆæ ‘ï¼Œä¸”æ¯æ£µç”Ÿæˆæ ‘çš„è¾¹æƒå’Œéƒ½ä¸è¶…è¿‡ SSSã€‚åŒæ—¶ï¼Œå¥¹è¿˜å¸Œæœ›ä»»æ„ä¸¤æ£µç”Ÿæˆæ ‘éƒ½æ˜¯&quot;ä¸ç›¸äº¤&quot;çš„ï¼Œå³åˆ†ç»„åè¾¹çš„ç¼–å·æ˜¯è¿ç»­çš„ã€‚æ•°æ®èŒƒå›´åœ¨ 10510^5105 çº§åˆ«ã€‚ å¯ä»¥ç›´æ¥è´ªå¿ƒ+äºŒåˆ†ç­”æ¡ˆã€‚ä½†æ˜¯å¦‚æœ nnn å¾ˆå°ï¼Œé‚£ä¹ˆå¯èƒ½ä¼šå¯¼è‡´äºŒåˆ†æ¬¡æ•°è¿‡å¤šã€‚å› æ­¤å¯ä»¥å°†äºŒåˆ†ç­”æ¡ˆæ”¹ä¸ºå€å¢ç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, S; int fa[100005], u[100005], v[100005], w[100005]; struct edge &#123; int u, v, w; bool operator&lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[100005]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; inline bool Kruskal(int l, int r) &#123; int ans = 0; for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = l; i &lt;= r; ++i) e[i].u = u[i], e[i].v = v[i], e[i].w = w[i]; int tot = 1; sort(e + l, e + r + 1); for (int i = l; i &lt;= r; ++i) &#123; int u = find(e[i].u), v = find(e[i].v), w = e[i].w; if (u == v) continue; fa[u] = v; ++tot; if ((ans += w) > S) return 0; if (tot == n) break; &#125; return ans &lt;= S &amp;&amp; tot == n; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;S); int ans = 0; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", u + i, v + i, w + i); for (int i = 1, flag = 1; i &lt;= m &amp;&amp; flag; ) &#123; int pw = 0; while (1) &#123; if (i + (1 &lt;&lt; pw) > m) &#123; ans += Kruskal(i, m); goto over; &#125; if (!Kruskal(i, i + (1 &lt;&lt; pw))) ++pw; else break; &#125; if (!flag) break; int acc = 1 &lt;&lt; pw; for (int j = pw; j >= 0; --j) if (Kruskal(i, i + acc - (1 &lt;&lt; j))) acc -= 1 &lt;&lt; j; // printf(\"MST %d %d\\n\", i, i + acc); ++ans; i += acc + 1; &#125; over: printf(\"%d\\n\", ans); &#125; return 0; &#125; ã€ŒWdoi-2ã€æ­»äº¡ä¹‹åæ„ˆå‘æ„‰æ‚¦ Portal. i+1i+1i+1 ä¸ªå¯çˆ±æ•°è¿ç€ iii ä¸ªéå¯çˆ±æ•°ã€‚è®¾ j(a)j(a)j(a) ä»£è¡¨ aaa æ˜¯å¦ä¸ºå¯çˆ±æ•°ã€‚æ±‚å‡º j(a)=j(a+p)j(a)=j(a+p)j(a)=j(a+p) çš„æœ€å¤§ pppï¼Œj(a+p+1)=j(a+p+q)j(a+p+1)=j(a+p+q)j(a+p+1)=j(a+p+q) çš„æœ€å¤§ qqqï¼Œåˆ™å®¹æ˜“æ ¹æ® p,q,j(a)p,q,j(a)p,q,j(a) è§£å‡º aaaã€‚ å¯¹äºæ±‚è§£ p,qp,qp,qï¼Œè€ƒè™‘å€å¢ã€‚æ³¨æ„å€å¢æ—¶è¦å…ˆè·³ä¸¤ä¸ª 202^020ï¼Œè¿™æ ·ä¿è¯æ¯ä¸€æ¬¡è·³è·ƒçš„é•¿åº¦ä¸å¤§äºä»¥å‰è·³è·ƒçš„é•¿åº¦ï¼Œå› ä¸ºåŒºé—´å¹¶ä¸æ˜¯ä¸¥æ ¼å•è°ƒçš„ï¼Œè¿™æ ·é˜²æ­¢è·³å‡ºåŒºé—´ã€‚ å¯¹äº qqq çš„å€å¢å¹¶ä¸éœ€è¦ä» 000 å¼€å§‹ï¼Œå¯ä»¥å‘ç° pâ‰¤qp\\le qpâ‰¤qï¼Œå› æ­¤å¯ä»¥ç›´æ¥å…ˆè·³ä¸€ä¸ªä¸è¶…è¿‡ pâˆ’1p-1pâˆ’1 çš„æ•°è€Œä¸æ˜¯ 111ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; map&lt;int, bool> ans; inline bool query(i64 x) &#123; if (ans.find(x) != ans.end()) return ans[x]; cout &lt;&lt; \"? \" &lt;&lt; x &lt;&lt; endl; cin >> ans[x]; return ans[x]; &#125; inline void answer(i64 x) &#123; cout &lt;&lt; \"! \" &lt;&lt; x &lt;&lt; endl; &#125; i64 calc(i64 x, i64 acc) &#123; // æ±‚ j(a + x) ~ j(a + p) ç›¸ç­‰çš„æœ€å¤§ p bool st = query(x); if (query(x + 1) != st) return x; int pw = 0; while (1ll &lt;&lt; pw + 1 &lt;= acc) ++pw; while (1) &#123; if (query(x + acc + (1ll &lt;&lt; pw)) != st) break; acc += 1ll &lt;&lt; pw; ++pw; &#125; for (int i = pw - 1; i >= 0; --i) if (query(x + acc + (1 &lt;&lt; i)) == st) acc += 1ll &lt;&lt; i; return x + acc; &#125; int main(void) &#123; ios::sync_with_stdio(0); int T; cin >> T; while (T--) &#123; ans.clear(); i64 p = calc(0, 1); i64 q = calc(p + 1, max(1ll, p - 1)) - p; if (query(0)) answer(q * (q + 1) - p); // a æ˜¯å¯çˆ±æ•° else answer((q - 1) * (q - 1) - 1 - p); // a ä¸æ˜¯å¯çˆ±æ•° &#125; return 0; &#125; åˆ†æ²» åˆ†æ²»æ˜¯å¾ˆå®ç”¨çš„æ€æƒ³ï¼Œè¿™é‡Œçœ‹å‡ é“é¢˜æ¥ä½“ä¼šä¸€ä¸‹ï¼Œå› ä¸ºåˆ†æ²»åœ¨åˆ°å¤„éƒ½æœ‰æ¸—é€ã€‚ [UVA1608] Non-boring sequences Portal. ä¸€å®šèƒ½åœ¨ä¸­é—´æ‰¾åˆ°ä¸€ä¸ªå”¯ä¸€çš„å…ƒç´ ï¼Œç„¶ååˆ†æ²»æ±‚è§£ä¸¤è¾¹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int a[200005], b[200005], p[200005]; int pre[200005], nxt[200005]; bool divide(int l, int r) &#123; if (l >= r) return true; int p = l, q = r; while (p &lt;= q) &#123; if (pre[q] &lt; l &amp;&amp; nxt[q] > r) if (divide(l, q - 1) &amp;&amp; divide(q + 1, r)) return true; if (pre[p] &lt; l &amp;&amp; nxt[p] > r) if (divide(l, p - 1) &amp;&amp; divide(p + 1, r)) return true; --q; ++p; &#125; return false; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i), b[i] = a[i]; p[i] = 0; pre[i] = 0; nxt[i] = n + 1; &#125; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b; for (int i = 1; i &lt;= n; ++i) &#123; if (p[a[i]]) pre[i] = p[a[i]], nxt[p[a[i]]] = i; p[a[i]] = i; &#125; if (divide(1, n)) puts(\"non-boring\"); else puts(\"boring\"); &#125; return 0; &#125; [CF1442D] Sum Portal.ç»™å®š nnn ä¸ªä¸é™çš„æ•°ç»„ã€‚æœ‰ä¸€ä¸ªå€¼ ansansansï¼Œåˆå§‹ä¸º 000ã€‚ä½ éœ€è¦è¿›è¡Œå¦‚ä¸‹æ“ä½œ kkk æ¬¡ï¼šé€‰æ‹©ä¸€ä¸ªæ•°ç»„ï¼ŒæŠŠ ansansans åŠ ä¸Šæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä¹‹åæŠŠå®ƒåˆ é™¤ã€‚è¯·æ±‚å‡º ansansans æœ€å¤§æ˜¯å¤šå°‘ã€‚æ‰€æœ‰æ•°ç»„çš„å…ƒç´ æ€»ä¸ªæ•° â‰¤106\\leq 10^6â‰¤106ï¼Œn,kâ‰¤3000n,k\\leq 3000n,kâ‰¤3000ã€‚ æ³¨æ„åˆ°æ•°ç»„æ˜¯å•è°ƒä¸é™çš„ï¼Œå› æ­¤è¦å–ä¸€ä¸ªæ•°ç»„å°±ä¼šä¸€ç›´å–ä¸‹å»ç›´åˆ°ä¸èƒ½å–æˆ–è€…å–å…‰äº†ã€‚ æ‰€ä»¥å¯ä»¥æƒ³åˆ°ä¸€ä¸ªæš´åŠ›ä¸€ç‚¹çš„åšæ³•ï¼šå°†ä¸€ä¸ªæ•°ç»„è§†ä¸ºä¸€ä¸ªæœ‰ä½“ç§¯æœ‰ä»·å€¼çš„ç‰©å“ï¼Œç„¶åæ­£ååšä¸¤é 01 èƒŒåŒ…ï¼Œæšä¸¾æ²¡å–æ»¡çš„é‚£ä¸ªæ•°ç»„å’Œè¿™ä¸ªæ•°ç»„å–å¤šå°‘ä¸ªï¼Œå†æšä¸¾å‰é¢å–çš„ä½“ç§¯ï¼Œè¿™æ ·å°±å¯ä»¥å¾—å‡ºåé¢å–çš„ä½“ç§¯ï¼Œå¹¶è®¡ç®—å‡ºæ€»ä»·å€¼ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nk2)O(nk^2)O(nk2)ã€‚ è¿™æ ·è‚¯å®šè¿‡ä¸å»ï¼Œå‘ç°å°±æ˜¯åˆå¹¶å¤ªæ…¢äº†ï¼Œè€ƒè™‘ä½¿ç”¨åˆ†æ²»ç®—æ³•åˆå¹¶ï¼šæ±‚è§£ (l,r)(l,r)(l,r) æ—¶ï¼Œæˆ‘ä»¬å…ˆå°† (l,mid)(l,mid)(l,mid) åŠ å…¥èƒŒåŒ…ï¼Œç„¶åé€’å½’æ±‚è§£ (mid+1,r)(mid+1,r)(mid+1,r)ï¼Œå½“ l=rl=rl=r æ—¶å°±å¯ä»¥æšä¸¾å½“å‰ä½“ç§¯äº†ã€‚æ—¶é—´å¤æ‚åº¦ O(nklogâ¡n)O(nk\\log n)O(nklogn)ã€‚ è¿™ä¸ªé—®é¢˜è¢«ç§°ä¸ºç¼ºä¸€èƒŒåŒ…ï¼Œæ„æ€æ˜¯å…¶ä¸­æœ‰ä¸€ä¸ªå¯ä»¥å–ä¸æ»¡ï¼Œä¸€èˆ¬é‡‡ç”¨ä¸Šè¿°åˆ†æ²»æ³•è§£å†³ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k; vector&lt;i64> a[3005]; i64 ans = 0, f[3005]; void merge(int l, int r) &#123; if (l == r) &#123; for (int i = 0; i &lt;= min(k, (int)a[l].size() - 1); ++i) ans = max(ans, a[l][i] + f[k - i]); return; &#125; int mid = l + r >> 1; i64 g[3005]; memcpy(g, f, sizeof(g)); for (int i = mid + 1; i &lt;= r; ++i) for (int j = k; j >= a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(l, mid); memcpy(f, g, sizeof(f)); for (int i = l; i &lt;= mid; ++i) for (int j = k; j >= a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(mid + 1, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; int m; scanf(\"%d\", &amp;m); a[i].resize(m + 1); for (int j = 1, x; j &lt;= m; ++j) scanf(\"%lld\", &amp;a[i][j]), a[i][j] += a[i][j - 1]; &#125; merge(1, n); printf(\"%lld\\n\", ans); return 0; &#125; CDQ åˆ†æ²» ç»´æŠ¤çš„æ˜¯ååºå…³ç³»ã€‚ [CQOI2011] åŠ¨æ€é€†åºå¯¹ Portal.ç»™å®šä¸€ä¸ª 1âˆ¼n1\\sim n1âˆ¼n çš„æ’åˆ—ï¼ŒæŒ‰ç…§é¡ºåºä¾æ¬¡åˆ é™¤ mmm ä¸ªå…ƒç´ ï¼Œç»Ÿè®¡æ¯ä¸ªå…ƒç´ è¢«åˆ é™¤ä¹‹å‰æ•´ä¸ªåºåˆ—çš„é€†åºå¯¹æ•°ã€‚ åˆ é™¤ä¸å¤ªå¥½åšï¼Œäºæ˜¯æˆ‘ä»¬æŠŠè¿™ä¸ªè¿‡ç¨‹åè¿‡æ¥ï¼Œæ”¹æˆæ·»åŠ å…ƒç´ ï¼Œè¿™æ ·æ¯ä¸ªå…ƒç´ å°±å¤šäº†ä¸€ä¸ªâ€œæ—¶é—´â€ï¼Œè‡ªèº«è¿˜æœ‰â€œä½ç½®â€å’Œâ€œå¤§å°â€ï¼Œè¦æ±‚ tiâ‰¤tj,i&lt;j,ai&gt;ajt_i\\le t_j,i&lt;j,a_i&gt;a_jtiâ€‹â‰¤tjâ€‹,i&lt;j,aiâ€‹&gt;ajâ€‹ï¼Œè¿™å°±æˆäº†ä¸‰ç»´ååºé—®é¢˜ã€‚ æ³¨æ„åœ¨åˆå¹¶çš„æ—¶å€™ï¼Œä¸¤è¾¹çš„åºåˆ—ä½ç½® ppp éƒ½æ˜¯æŒ‰é¡ºåºæ’å¥½çš„ï¼Œå› æ­¤è¦æ­£ååšä¸¤éï¼Œåˆ†åˆ«å¯¹ i&lt;j,ai&gt;aji&lt;j,a_i&gt;a_ji&lt;j,aiâ€‹&gt;ajâ€‹ å’Œ i&gt;j,ai&lt;aji&gt;j,a_i&lt;a_ji&gt;j,aiâ€‹&lt;ajâ€‹ è¿›è¡Œç»Ÿè®¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; struct Node &#123; int t, p, v; bool operator &lt; (const Node &amp;a) const &#123; if (t == a.t) return p &lt; a.p; return t &lt; a.t; &#125; &#125; a[100005], T[100005]; int n, m, idx[100005]; i64 ans[100005]; int C[100005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int sum(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; void CDQ(int l, int r) &#123; if (l == r) return; int mid = l + r >> 1; CDQ(l, mid); CDQ(mid + 1, r); int p = l, q = mid + 1; for (int i = l; i &lt;= r; ++i) &#123; if (p &lt;= mid &amp;&amp; (q > r || a[p].p &lt; a[q].p)) add(a[p].v, 1), T[i] = a[p++]; else ans[a[q].t] += sum(n) - sum(a[q].v), T[i] = a[q++]; &#125; for (int i = l; i &lt;= mid; ++i) add(a[i].v, -1); p = mid, q = r; for (int i = l; i &lt;= r; ++i) &#123; if (p >= l &amp;&amp; (q &lt; mid + 1 || a[p].p > a[q].p)) add(a[p].v, 1), --p; else ans[a[q].t] += sum(a[q].v), --q; &#125; for (int i = l; i &lt;= mid; ++i) add(a[i].v, -1); for (int i = l; i &lt;= r; ++i) a[i] = T[i]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i].v), a[i].p = i, idx[a[i].v] = i, a[i].t = 1; for (int i = 1, x; i &lt;= m; ++i) scanf(\"%d\", &amp;x), a[idx[x]].t = m - i + 1; sort(a + 1, a + n + 1); CDQ(1, n); for (int i = 1; i &lt;= m; ++i) ans[i] += ans[i - 1]; for (int i = m; i >= 1; --i) printf(\"%lld\\n\", ans[i]); return 0; &#125; [Violet] å¤©ä½¿ç©å¶ Portal. ç»å¯¹å€¼ä¸å¥½å¤„ç†ï¼Œè€ƒè™‘æ‹†å¼€åˆ†ç±»è®¨è®ºï¼Œå‡å®š x1â‰¤x2,y1â‰¤y2x_1\\le x_2,y_1\\le y_2x1â€‹â‰¤x2â€‹,y1â€‹â‰¤y2â€‹ï¼Œåªéœ€è¦æ‰¾åˆ°æœ€å¤§çš„ x1+y1x_1+y_1x1â€‹+y1â€‹ å³å¯ã€‚ç¦»çº¿æ—¶é—´ç»´è½¬åŒ–ä¸ºç¬¬ä¸‰ç»´ï¼ŒCDQ åˆ†æ²»å¤„ç†å››ä¸ªæ–¹å‘å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 1000002; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x; &#125; int n, m; struct Node &#123; int x, y, t; bool f; // f è®°å½•æ˜¯å¦ä¸ºè¯¢é—® bool operator&lt; (const Node &amp;a) &#123; return x &lt; a.x; &#125; Node(int x = 0, int y = 0, int t = 0, bool f = 0) : x(x), y(y), t(t), f(f) &#123;&#125; &#125; a[600005], p[600005], T[600005]; int ans[600005]; int C[1000005]; inline void add(int x, int k) &#123; for (; x &lt;= N; x += x &amp; -x) C[x] = max(C[x], k); &#125; inline int qmax(int x) &#123; int r = 0; for (; x; x -= x &amp; -x) r = max(r, C[x]); return r; &#125; inline void clear(int x) &#123; for (; x &lt;= N; x += x &amp; -x) C[x] = 0; &#125; void CDQ(int l, int r) &#123; if (l == r) return; int mid = l + r >> 1; CDQ(l, mid); CDQ(mid + 1, r); // å·¦ç«¯ç‚¹å¯¹å³ç«¯è¯¢é—®ç‚¹çš„å½±å“ for (int p = l, q = mid + 1, tmp; q &lt;= r; ++q) if (a[q].f) &#123; for (; p &lt;= mid &amp;&amp; a[p].x &lt;= a[q].x; ++p) if (!a[p].f) add(a[p].y, a[p].x + a[p].y); if (tmp = qmax(a[q].y)) ans[a[q].t] = min(ans[a[q].t], a[q].x + a[q].y - tmp); // æ³¨æ„æœ‰å¯èƒ½æ²¡æœ‰ç‚¹ &#125; for (int i = l; i &lt;= mid; ++i) if (!a[i].f) clear(a[i].y); merge(a + l, a + mid + 1, a + mid + 1, a + r + 1, T + l); for (int i = l; i &lt;= r; ++i) a[i] = T[i]; &#125; int main(void) &#123; n = read(), m = read(); memset(ans, 0x3f, sizeof ans); for (int i = 1; i &lt;= n; ++i) p[i].x = read() + 1, p[i].y = read() + 1; for (int i = 1; i &lt;= m; ++i) p[++n].f = read() - 1, p[n].x = read() + 1, p[n].y = read() + 1, p[n].t = i; for (int i = 1; i &lt;= n; ++i) a[i] = p[i]; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) a[i] = p[i], a[i].x = N - a[i].x; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) a[i] = p[i], a[i].y = N - a[i].y; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) a[i] = p[i], a[i].x = N - a[i].x, a[i].y = N - a[i].y; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) if (p[i].f) printf(\"%d\\n\", ans[p[i].t]); return 0; &#125; [SDOI2011] æ‹¦æˆªå¯¼å¼¹ Portal. è®¾ fif_ifiâ€‹ ä»£è¡¨ä»¥ iii ç»“å°¾çš„æœ€é•¿å­åºåˆ—ï¼ˆè®°ä¸º XLISï¼‰é•¿åº¦ï¼Œé‚£ä¹ˆ fi=maxâ¡{fjâˆ£i&gt;j,hi&lt;hj,vi&lt;vj}+1f_i=\\max\\{f_j|i&gt;j,h_i&lt;h_j,v_i&lt;v_j\\}+1fiâ€‹=max{fjâ€‹âˆ£i&gt;j,hiâ€‹&lt;hjâ€‹,viâ€‹&lt;vjâ€‹}+1ï¼Œgig_igiâ€‹ ä»£è¡¨ XLIS ä¸ªæ•°ï¼Œæ˜¯ä¸‰ç»´ååºï¼ç„¶åå¤„ç†ä»¥å½“å‰ç‚¹ä¸ºèµ·ç‚¹å’Œç»ˆç‚¹çš„ç­”æ¡ˆï¼Œç„¶åæœ€ç»ˆç­”æ¡ˆå°±å¾ˆå¥½ç»Ÿè®¡äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct Node &#123; int x, y, z; friend bool operator&lt; (const Node &amp;a, const Node &amp;b) &#123; return a.x &lt; b.x; &#125; &#125; a[50005]; bool cmp(Node &amp;a, Node &amp;b) &#123; return a.y &lt; b.y; &#125; bool cmp2(Node &amp;a, Node &amp;b) &#123; return a.x > b.x; &#125; int n, h[50005], v[50005]; int mh, mv, b[50005]; int f1[50005], f2[50005]; double g1[50005], g2[50005]; void init(int *a, int &amp;m) &#123; for (int i = 1; i &lt;= n; ++i) b[i] = a[i]; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = m - a[i] + 1; &#125; int C[50005]; double F[50005]; void add(int o, int x, double y) &#123; for (int i = o; i &lt;= n; i += i &amp; -i) if (C[i] &lt; x) C[i] = x, F[i] = y; else if (C[i] == x) F[i] += y; &#125; auto query(int x) &#123; int r1 = 0; double r2 = 0; for (int i = x; i; i -= i &amp; -i) if (r1 &lt; C[i]) r1 = C[i], r2 = F[i]; else if (r1 == C[i]) r2 += F[i]; return make_pair(r1, r2); &#125; void clear(int o) &#123; for (int i = o; i &lt;= n; i += i &amp; -i) C[i] = F[i] = 0; &#125; void CDQ(int l, int r, int *f, double *g, int type) &#123; if (l == r) return; int mid = l + r >> 1; CDQ(l, mid, f, g, type); sort(a + l, a + mid + 1, cmp); sort(a + mid + 1, a + r + 1, cmp); for (int p = l, q = mid + 1; q &lt;= r; ++q) &#123; for (; p &lt;= mid &amp;&amp; a[p].y &lt;= a[q].y; ++p) add(a[p].z, f[a[p].x], g[a[p].x]); auto r = query(a[q].z); if (r.first + 1 == f[a[q].x]) g[a[q].x] += r.second; else if (r.first + 1 > f[a[q].x]) f[a[q].x] = r.first + 1, g[a[q].x] = r.second; &#125; for (int i = l; i &lt;= mid; ++i) clear(a[i].z); if (type == 1) sort(a + mid + 1, a + r + 1); else sort(a + mid + 1, a + r + 1, cmp2); CDQ(mid + 1, r, f, g, type); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", h + i, v + i), f1[i] = g1[i] = f2[i] = g2[i] = 1; init(h, mh); init(v, mv); for (int i = 1; i &lt;= n; ++i) a[i].x = i, a[i].y = h[i], a[i].z = v[i]; CDQ(1, n, f1, g1, 1); for (int i = 1; i &lt;= n; ++i) a[i].x = i, a[i].y = mh - h[i] + 2, a[i].z = mv - v[i] + 2; reverse(a + 1, a + n + 1); CDQ(1, n, f2, g2, 2); int ans = 0; double s = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f1[i]); printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (f1[i] == ans) s += g1[i]; for (int i = 1; i &lt;= n; ++i) if (f1[i] + f2[i] - 1 == ans) printf(\"%.6lf \", g1[i] * g2[i] / s); else fputs(\"0 \", stdout); return putchar('\\n'), 0; &#125; æ•´ä½“äºŒåˆ† é€šè¿‡è·Ÿè¸ªåˆ†æ²»ä¸­å¿ƒæ¥å¾—åˆ°ä¼˜ç§€çš„åšæ³•ã€‚ [POI2011] MET-Meteors Portal.æœ‰ nâ€‹nâ€‹nâ€‹ ä¸ªæˆå‘˜å›½ã€‚ç°åœ¨å®ƒå‘ç°äº†ä¸€é¢—æ–°çš„æ˜Ÿçƒï¼Œè¿™é¢—æ˜Ÿçƒçš„è½¨é“è¢«åˆ†ä¸º mâ€‹mâ€‹mâ€‹ ä»½ï¼ˆç¬¬ mâ€‹mâ€‹mâ€‹ ä»½å’Œç¬¬ 1â€‹1â€‹1â€‹ ä»½ç›¸é‚»ï¼‰ï¼Œç¬¬ iâ€‹iâ€‹iâ€‹ ä»½ä¸Šæœ‰ç¬¬ aiâ€‹a_iâ€‹aiâ€‹â€‹ ä¸ªå›½å®¶çš„å¤ªç©ºç«™ã€‚è¿™ä¸ªæ˜Ÿçƒç»å¸¸ä¼šä¸‹é™¨çŸ³é›¨ã€‚BIU å·²ç»é¢„æµ‹äº†æ¥ä¸‹æ¥ kkk åœºé™¨çŸ³é›¨çš„æƒ…å†µã€‚BIU çš„ç¬¬ iii ä¸ªæˆå‘˜å›½å¸Œæœ›èƒ½å¤Ÿæ”¶é›† pip_ipiâ€‹ å•ä½çš„é™¨çŸ³æ ·æœ¬ã€‚ä½ çš„ä»»åŠ¡æ˜¯åˆ¤æ–­å¯¹äºæ¯ä¸ªå›½å®¶ï¼Œå®ƒéœ€è¦åœ¨ç¬¬å‡ æ¬¡é™¨çŸ³é›¨ä¹‹åï¼Œæ‰èƒ½æ”¶é›†è¶³å¤Ÿçš„é™¨çŸ³ã€‚ ä¸€æ¬¡è¯¢é—®çš„è¯äºŒåˆ†ç­”æ¡ˆæ˜¯å¯åšçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è€ƒè™‘æ•´ä½“äºŒåˆ†ã€‚å°†ç¯å±•æˆäºŒå€é“¾ï¼Œç”¨ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ç»´æŠ¤æ¯ä¸ªåŒºé—´çš„å€¼ã€‚æ³¨æ„é™¨çŸ³é›¨å¯èƒ½è½åœ¨åŒä¸€ä¸ªå›½å®¶ä½¿å¾—ç­”æ¡ˆå¾ˆå¤§ï¼Œè¯·ä½¿ç”¨åˆç†çš„å˜é‡ç±»å‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; int n, m, k, ans[300005], id[300005]; int L[300005], R[300005], T[300005]; vector&lt;int> a[300005]; int Q[300005], t1[300005], t2[300005]; __int128 C[600005]; void add(int x, int k) &#123; for (; x &lt;= 2 * m; x += lowbit(x)) C[x] += k; &#125; __int128 query(int x) &#123; __int128 ans = 0; for (; x; x -= lowbit(x)) ans += C[x]; return ans; &#125; void solve(int l, int r, int ql, int qr) &#123; if (ql > qr) return; if (l == r) &#123; for (int i = ql; i &lt;= qr; ++i) ans[id[i]] = l; return; &#125; int mid = l + r >> 1, p = 0, q = 0; for (int i = l; i &lt;= mid; ++i) add(L[i], T[i]), add(R[i] + 1, -T[i]); for (int i = ql; i &lt;= qr; ++i) &#123; int u = id[i]; __int128 s = 0; for (int j : a[u]) s += query(j) + query(j + m); if (s >= Q[u]) t1[++p] = u; else t2[++q] = u, Q[u] -= s; &#125; int tot = ql - 1; for (int i = 1; i &lt;= p; ++i) id[++tot] = t1[i]; for (int i = 1; i &lt;= q; ++i) id[++tot] = t2[i]; for (int i = l; i &lt;= mid; ++i) add(L[i], -T[i]), add(R[i] + 1, T[i]); solve(l, mid, ql, ql + p - 1); solve(mid + 1, r, ql + p, qr); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, x; i &lt;= m; ++i) scanf(\"%d\", &amp;x), a[x].push_back(i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;Q[i]), id[i] = i; scanf(\"%d\", &amp;k); for (int i = 1; i &lt;= k; ++i) &#123; scanf(\"%d%d%d\", L + i, R + i, T + i); if (R[i] &lt; L[i]) R[i] += m; &#125; L[k + 1] = 1, R[k + 1] = m, T[k + 1] = 1e9; solve(1, k + 1, 1, n); for (int i = 1; i &lt;= n; ++i) if (ans[i] != k + 1) printf(\"%d\\n\", ans[i]); else puts(\"NIE\"); return 0; &#125; [CTSC2018] æ··åˆæœæ± Portal. å¯ä»¥äºŒåˆ†å‡ºç¾å‘³åº¦çš„ç­”æ¡ˆï¼Œè€Œåˆæœ‰å¤šç»„è¯¢é—®ï¼Œå› æ­¤è€ƒè™‘æ•´ä½“äºŒåˆ†ã€‚å…ˆåŠ å…¥ä¸€ä¸ªç¾å‘³åº¦ä¸º âˆ’1-1âˆ’1ï¼Œå¯ä»¥æ— é™ä¹°çš„å…è´¹æœæ±æ–¹ä¾¿å¤„ç†ã€‚å°†æœæ±æŒ‰ç…§ç¾å‘³åº¦ä»å¤§åˆ°å°æ’åºã€‚ æˆ‘ä»¬å°†ç¾å‘³åº¦ â‰¤mid\\le midâ‰¤mid çš„æœæ±å…¨éƒ¨åŠ å…¥æ ‘çŠ¶æ•°ç»„ã€‚å¯¹å½“å‰è¯¢é—®çš„åˆ†ç»„éœ€è¦äºŒåˆ†å‡ºæ»¡è¶³å…¶ä½“ç§¯é™åˆ¶çš„æœ€å°ä»·æ ¼ï¼Œåªéœ€è¦è€ƒè™‘æ¯”è¿™ä¸ªä»·æ ¼ä½çš„æœæ±ä¸€å®šè¦å…¨ä¹°ï¼Œä¸è¶³çš„ç”¨ä»·æ ¼ç­‰äºè¿™ä¸ªçš„æœæ±è¡¥å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦ O(nlogâ¡3n)O(n\\log^3 n)O(nlog3n)ï¼Œæ¢æˆæ ‘çŠ¶æ•°ç»„å€å¢å¯ä»¥åšåˆ° O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, id[100005], ans[100005]; int t1[100005], t2[100005]; struct Query &#123; i64 g, l; &#125; Q[100005]; struct juice &#123; int d, p; i64 l; // ç¾å‘³åº¦ï¼Œæ¯å‡ä»·æ ¼ï¼Œæœ€å¤§ä½“ç§¯ juice(int d = 0, int p = 0, i64 l = 0) : d(d), p(p), l(l) &#123;&#125; bool operator &lt; (const juice &amp;a) const &#123; return d > a.d; &#125; &#125; a[100005]; struct Fenwick &#123; #define lowbit(x) (x &amp; -x) i64 C[100005]; void add(int x, i64 k) &#123; ++x; for (; x &lt;= 100000; x += lowbit(x)) C[x] += k; &#125; i64 query(int x) &#123; ++x; i64 res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; &#125; P, L; // æ€»ä»·æ ¼ï¼Œæ€»ä½“ç§¯ inline void update(int i, i64 flag) &#123; L.add(a[i].p, flag * a[i].l); P.add(a[i].p, flag * a[i].l * a[i].p); &#125; int find(int x) &#123; // äºŒåˆ†å‡ºæ»¡è¶³ä½“ç§¯é™åˆ¶çš„æœ€å°ä»·æ ¼ int l = 0, r = 100001; while (l + 1 != r) &#123; int mid = l + r >> 1; if (L.query(mid) >= Q[x].l) r = mid; else l = mid; &#125; return r; &#125; int now; void solve(int l, int r, int ql, int qr) &#123; if (ql > qr) return; if (l == r) &#123; for (int i = ql; i &lt;= qr; ++i) ans[id[i]] = a[l].d; return; &#125; int mid = l + r >> 1, p = 0, q = 0; while (now &lt; mid) update(++now, 1); while (now > mid) update(now--, -1); for (int i = ql; i &lt;= qr; ++i) &#123; int u = id[i]; int x = find(u); i64 Pv = P.query(x), Pl = L.query(x); if (Pl >= Q[u].l &amp;&amp; Pv - x * (Pl - Q[u].l) &lt;= Q[u].g) t1[++p] = u; else t2[++q] = u; &#125; int tot = ql - 1; for (int i = 1; i &lt;= p; ++i) id[++tot] = t1[i]; for (int i = 1; i &lt;= q; ++i) id[++tot] = t2[i]; solve(l, mid, ql, ql + p - 1); solve(mid + 1, r, ql + p, qr); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d%d\", &amp;a[i].d, &amp;a[i].p, &amp;a[i].l); a[++n] = juice(-1, 0, 1e18); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= m; ++i) scanf(\"%lld%lld\", &amp;Q[i].g, &amp;Q[i].l), id[i] = i; solve(1, n, 1, m); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; æ•´ä½“äºŒåˆ†å¸¦ä¿® | [Luogu P2617] Dynamic Rankings Portal. å¸¦ä¿®æ”¹çš„æ•´ä½“äºŒåˆ†ä¹Ÿå¾ˆå¥½å¤„ç†ï¼Œåªéœ€è¦å°†ä¿®æ”¹ä¹Ÿä½œä¸ºäº‹ä»¶ã€‚ç”±äºå¸¦ä¿®æ•°å¾ˆæ‚ï¼Œå› æ­¤å¯ä»¥é€‰æ‹©ç›´æ¥äºŒåˆ†å€¼åŸŸã€‚è¿™æ ·åªéœ€è¦å°† â‰¤mid\\le midâ‰¤mid çš„æ•°åŠ å…¥æ ‘çŠ¶æ•°ç»„ç»Ÿè®¡å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; int n, m; int w[100005], ans[300005]; struct operation &#123; int type, l, r, k; &#125; Q[300005]; int id[300005], t1[300005], t2[300005]; int C[100005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int ask(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int ask(int l, int r) &#123; return ask(r) - ask(l - 1); &#125; void solve(int l, int r, int ql, int qr) &#123; if (ql > qr) return; if (l == r) &#123; for (int i = ql; i &lt;= qr; ++i) if (!Q[id[i]].type) ans[id[i]] = l; return; &#125; int mid = l + r >> 1, p = 0, q = 0; for (int i = ql; i &lt;= qr; ++i) &#123; int u = id[i]; if (Q[u].type) &#123; if (Q[u].r &lt;= mid) add(Q[u].l, Q[u].k), t1[++p] = u; else t2[++q] = u; &#125; else &#123; int tmp = ask(Q[u].l, Q[u].r); if (tmp >= Q[u].k) t1[++p] = u; else Q[u].k -= tmp, t2[++q] = u; &#125; &#125; int tot = ql - 1; for (int i = 1; i &lt;= p; ++i) id[++tot] = t1[i]; for (int i = 1; i &lt;= q; ++i) id[++tot] = t2[i]; for (int i = 1; i &lt;= p; ++i) &#123; int u = t1[i]; if (Q[u].type &amp;&amp; Q[u].r &lt;= mid) add(Q[u].l, -Q[u].k); &#125; solve(l, mid, ql, ql + p - 1), solve(mid + 1, r, ql + p, qr); &#125; int main(void) &#123; cin >> n >> m; int tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", w + i); Q[++tot] = &#123;1, i, w[i], 1&#125;; &#125; for (int i = 1; i &lt;= m; ++i) &#123; char s[2]; scanf(\"%s\", s); if (s[0] == 'Q') &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); Q[++tot] = &#123;0, l, r, k&#125;; &#125; else &#123; int x, k; scanf(\"%d%d\", &amp;x, &amp;k); Q[++tot] = &#123;1, x, w[x], -1&#125;; w[x] = k; Q[++tot] = &#123;1, x, w[x], 1&#125;; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) id[i] = i, ans[i] = -1; solve(0, 1e9, 1, tot); for (int i = 1; i &lt;= tot; ++i) if (ans[i] != -1) printf(\"%d\\n\", ans[i]); return 0; &#125; çº¿æ®µæ ‘åˆ†æ²» å¯ä»¥å¾ˆæ–¹ä¾¿åœ°æ”¯æŒæ’¤é”€ã€‚ [Luogu P5787] äºŒåˆ†å›¾ /ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘åˆ†æ²» Portal. åˆ¤æ–­äºŒåˆ†å›¾å¯ä»¥ä½¿ç”¨æ‰©å±•åŸŸå¹¶æŸ¥é›†ï¼ˆæ‹†æˆé»‘ç‚¹å’Œç™½ç‚¹ï¼‰ï¼Œè€Œä¸”éœ€è¦æ”¯æŒå¯æ’¤é”€ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨å¯å‘å¼åˆå¹¶åœ°å¹¶æŸ¥é›†ã€‚ç„¶åçº¿æ®µæ ‘åˆ†æ²»ç³Šä¸Šå»å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, k, f[200005], siz[200005]; struct edge &#123; int x, y; &#125; e[200005]; vector&lt;int> T[400005]; struct Node &#123; int x, y, s; &#125; st[200005]; int tot; int find(int x) &#123; if (f[x] == x) return x; return find(f[x]); &#125; void merge(int x, int y) &#123; x = find(x), y = find(y); if (x == y) return; if (siz[x] > siz[y]) swap(x, y); st[++tot] = &#123;x, y, siz[x]&#125;; f[x] = y; siz[y] += siz[x]; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].emplace_back(k), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); &#125; void solve(int o, int l, int r) &#123; bool flag = 1; int lst = tot; for (int i : T[o]) &#123; int x = find(e[i].x), y = find(e[i].y); if (x == y) &#123; // å±äºä¸€ä¸ªé›†åˆ for (int j = l; j &lt;= r; ++j) puts(\"No\"); flag = 0; break; &#125; merge(e[i].x, e[i].y + n); merge(e[i].y, e[i].x + n); &#125; if (flag) &#123; if (l == r) puts(\"Yes\"); else &#123; int mid = l + r >> 1; solve(o &lt;&lt; 1, l, mid); solve(o &lt;&lt; 1 | 1, mid + 1, r); &#125; &#125; while (tot > lst) &#123; f[st[tot].x] = st[tot].x; siz[st[tot].y] -= st[tot].s; --tot; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; ++i) &#123; int l, r; scanf(\"%d%d%d%d\", &amp;e[i].x, &amp;e[i].y, &amp;l, &amp;r); ++l; update(1, 1, k, l, r, i); &#125; for (int i = 1; i &lt;= n * 2; ++i) f[i] = i, siz[i] = 1; solve(1, 1, k); return 0; &#125; [CF576E] Painting Edges Portal. è·Ÿä¸Šä¸€é“é¢˜ä¼¼ä¹å¾ˆåƒï¼Œåªéœ€è¦ä½¿ç”¨ kkk ä¸ªå¯æ’¤é”€å¹¶æŸ¥é›†ç»´æŠ¤æ¯ä¸€ä¸ªé¢œè‰²å³å¯ã€‚ä½†æ˜¯å¦‚æœç­”æ¡ˆæ˜¯ NO ä¸æ‰§è¡Œæ­¤æ“ä½œå¦‚ä½•å¤„ç†ï¼Ÿ çº¿æ®µæ ‘åˆ†æ²»çš„ç‰¹æ€§æ˜¯ 1â†’q1\\rightarrow q1â†’q ä¾æ¬¡å¤„ç†ï¼Œç¬¬ iii æ¬¡è¯¢é—®çš„ç”Ÿæ•ˆåŒºé—´æ˜¯ [i+1,yâˆ’1][i+1,y-1][i+1,yâˆ’1]ï¼ˆyyy ä»£è¡¨ä¸‹ä¸€æ¬¡ä¿®æ”¹è¿™æ¡è¾¹çš„æ—¶é—´ï¼‰ã€‚å¯ä»¥åœ¨æ¯ä¸ªå¶å­ä¸Šå†è€ƒè™‘æ˜¯å¦æ»¡è¶³äºŒåˆ†å›¾çš„æ¡ä»¶ï¼ˆæ¯ä¸ªè¯¢é—®åªä¼šå¤šä¸€æ¡è¾¹ï¼‰ï¼Œç„¶åä¸æ»¡è¶³çš„è¯è¿™ä¸ªä¿®æ”¹çš„é¢œè‰²æ”¹ä¸ºè¾¹å½“å‰çš„é¢œè‰²ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, k, q, u[500005], v[500005]; int a[500005], c[500005], p[500005], tmp[500005]; int fa[55][1000005], siz[55][1000005], tot; struct Node &#123; int o, x, y, z; &#125; st[3000005]; inline int find(int o, int x) &#123; while (x != fa[o][x]) x = fa[o][x]; return x; &#125; inline void merge(int o, int x, int y) &#123; x = find(o, x); y = find(o, y); if (x == y) return; if (siz[o][x] > siz[o][y]) swap(x, y); st[++tot] = &#123;o, x, y, siz[o][x]&#125;; fa[o][x] = y; siz[o][y] += siz[o][x]; &#125; vector&lt;int> T[2000005]; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].emplace_back(k), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); &#125; void solve(int o, int l, int r) &#123; int lst = tot; for (int i : T[o]) if (c[i]) merge(c[i], u[a[i]], v[a[i]] + n), merge(c[i], v[a[i]], u[a[i]] + n); if (l == r) &#123; if (find(c[l], u[a[l]]) == find(c[l], v[a[l]])) // æ£€æŸ¥è¿™æ¬¡æ“ä½œæ˜¯å¦åˆæ³• puts(\"NO\"), c[l] = tmp[a[l]]; // ä¸åˆæ³•ï¼Œé˜»æ­¢æ¥ä¸‹æ¥çš„åˆå¹¶ else puts(\"YES\"), tmp[a[l]] = c[l]; &#125; else &#123; int mid = l + r >> 1; solve(o &lt;&lt; 1, l, mid); solve(o &lt;&lt; 1 | 1, mid + 1, r); &#125; for (; tot > lst; --tot) &#123; int x = st[tot].x, o = st[tot].o; fa[o][x] = x, siz[o][st[tot].y] -= st[tot].z; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;q); for (int i = 1; i &lt;= k; ++i) for (int j = 1; j &lt;= n * 2; ++j) fa[i][j] = j, siz[i][j] = 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", u + i, v + i), p[i] = q + 1; for (int i = 1; i &lt;= q; ++i) scanf(\"%d%d\", a + i, c + i); for (int i = q; i >= 1; --i) &#123; if (i &lt; p[a[i]] - 1) update(1, 1, q, i + 1, p[a[i]] - 1, i); // åœ¨æ­¤æ¬¡æ“ä½œä¹‹åå†ç”Ÿæ•ˆ p[a[i]] = i; &#125; return solve(1, 1, q), 0; &#125; [CF603E] Pastoral Oddities Portal. æ»¡è¶³é¢˜ç›®æ¡ä»¶æ„å‘³ç€æ‰€æœ‰è¿é€šå—çš„å¤§å°éƒ½æ˜¯å¶æ•°ã€‚å°†è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºï¼Œç„¶åçº¿æ®µæ ‘åˆ†æ²»ä»å³åˆ°å·¦ä¾æ¬¡å¤„ç†æ¯ä¸€æ¡è¾¹ï¼Œè®¡ç®—æ¯ä¸€æ¡è¾¹å¯ä»¥è¢«è®°å…¥ç­”æ¡ˆçš„èŒƒå›´ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, ans[300005]; struct edge &#123; int u, v, w, id; bool operator&lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[300005]; int fa[300005], siz[300005]; struct Node &#123; int x, y, s, t; &#125; st[300005]; int tot, odd; int find(int x) &#123; return fa[x] == x ? x : find(fa[x]); &#125; void merge(int x, int y) &#123; x = find(x); y = find(y); if (x == y) return; if (siz[x] > siz[y]) swap(x, y); st[++tot] = &#123;x, y, siz[x]&#125;; if (siz[x] % 2 &amp;&amp; siz[y] % 2) odd -= 2, st[tot].t += 2; fa[x] = y; siz[y] += siz[x]; &#125; vector&lt;int> T[1200005]; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].push_back(k), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); &#125; int pos; void solve(int o, int l, int r) &#123; int lst = tot; for (int i : T[o]) merge(e[i].u, e[i].v); if (l == r) &#123; while (1) &#123; if (odd == 0 || pos == m) break; if (e[pos + 1].id &lt;= l) &#123; merge(e[pos + 1].u, e[pos + 1].v); if (e[pos + 1].id &lt; l) update(1, 1, m, e[pos + 1].id, l - 1, pos + 1); &#125; ++pos; &#125; ans[l] = (odd ? -1 : e[pos].w); &#125; else &#123; int mid = l + r >> 1; solve(o &lt;&lt; 1 | 1, mid + 1, r); solve(o &lt;&lt; 1, l, mid); &#125; for (; tot > lst; --tot) &#123; int x = st[tot].x, y = st[tot].y, s = st[tot].s, t = st[tot].t; fa[x] = x, siz[y] -= s, odd += t; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); odd = n; for (int i = 1; i &lt;= n; ++i) fa[i] = i, siz[i] = 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w), e[i].id = i; sort(e + 1, e + m + 1); solve(1, 1, m); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; éšæœºåŒ–ç®—æ³• æ¯”è¾ƒæœ‰è¶£ã€‚ [CF1305F] Kuroni and the Punishment Portal. å‘ç°ç­”æ¡ˆè‡³å¤šä¸º nnnï¼Œå› æ­¤æ–¹æ¡ˆä¸­ä¸å˜ã€+1/âˆ’1+1/-1+1/âˆ’1 çš„æ•°è‡³å°‘æœ‰ä¸€åŠï¼Œéšæœºé’¦å®šè¿™äº›æ•°ï¼Œç­”æ¡ˆå¿…å®šæ˜¯å®ƒä»¬çš„è´¨å› æ•°çš„å€æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; i64 a[200005], ans = 1e18; mt19937 Rand(time(0)); void getAns(i64 x) &#123; // å…¨éƒ¨å˜ä¸º x çš„å€æ•° i64 res = 0; for (int i = 1; i &lt;= n; ++i) &#123; i64 t = x - a[i] % x; if (a[i] >= x) t = min(t, a[i] % x); res += t; &#125; ans = min(ans, res); &#125; void work(i64 x) &#123; // x çš„å…¨éƒ¨è´¨å› æ•°å¯èƒ½æˆä¸ºç­”æ¡ˆ for (i64 i = 2; i * i &lt;= x; ++i) if (x % i == 0) &#123; getAns(i); while (x % i == 0) x /= i; &#125; if (x > 1) getAns(x); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; shuffle(a + 1, a + n + 1, Rand); for (int i = 1; i &lt;= min(n, 50); ++i) &#123; if (a[i] > 1) work(a[i] - 1); work(a[i]); work(a[i] + 1); &#125; return cout &lt;&lt; ans &lt;&lt; \"\\n\", 0; &#125; [THUSCH2017] å·§å…‹åŠ› Portal. å¦‚æœé¢œè‰²æ•°æ¯”è¾ƒå°‘çš„è¯ç›´æ¥ç”¨æ–¯å¦çº³æ ‘åšï¼Œä½†æ˜¯é¢œè‰²æ•°å¾ˆå¤šï¼Œé’¦å®šçš„å¯èƒ½ä¹Ÿå¾ˆå¤šã€‚ è¿™ç§ NPC é—®é¢˜å¯ä»¥ç›´æ¥è€ƒè™‘ä¹±æï¼Œkkk å¾ˆå°ï¼Œå› æ­¤è€ƒè™‘å°†æ‰€æœ‰é¢œè‰²éšæœºæ˜ å°„åˆ° [0,k)[0,k)[0,k)ï¼Œç„¶åæ±‚æœ€å°æ–¯å¦çº³æ ‘å³å¯æ±‚å‡ºæœ€å°çš„å·§å…‹åŠ›ä¸ªæ•° wwwã€‚è¿™ kkk ä¸ªç‚¹è¢«åˆ†é…åˆ°ä¸åŒçš„é¢œè‰²æ—¶ç­”æ¡ˆåˆæ³•ï¼Œæ­£ç¡®æ¦‚ç‡æ˜¯ k!/kkk!/k^kk!/kkã€‚éšæœºåŒ–åš 200200200 æ¬¡å³å¯ã€‚ ç„¶åäºŒåˆ†å‡ºä¸­ä½æ•°ï¼Œå°†å°äºç­‰äºäºŒåˆ†å€¼çš„æƒå€¼éƒ½è®¾ä¸º infâˆ’1inf-1infâˆ’1ï¼Œå¤§äºçš„éƒ½è®¾ä¸º inf+1inf+1inf+1ï¼Œç„¶åæœ€å°æ–¯å¦çº³æ ‘è¦ â‰¤wÃ—inf\\le w\\times infâ‰¤wÃ—infï¼ˆinfinfinf è®¾ç½®ä¸ºä¸€ä¸ªä¸ä¼šå½±å“æ–¯å¦çº³æ ‘é€‰æ‹©çš„å·§å…‹åŠ›æ•°çš„ä¸€ä¸ªæ•°å³å¯ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; const int DX[] = &#123;-1, 1, 0, 0&#125;, DY[] = &#123;0, 0, 1, -1&#125;; int n, m, k, tot; int c[240][240], a[240][240], w[240][240]; int cc[240], f[240][240][32], to[240]; bool inq[240][240]; mt19937 Rand(time(0)); queue&lt;pair&lt;int, int>> q; void SPFA(int s) &#123; while (!q.empty()) &#123; auto u = q.front(); q.pop(); int x = u.first, y = u.second; inq[x][y] = 0; for (int i = 0; i &lt; 4; ++i) &#123; int tx = x + DX[i], ty = y + DY[i]; if (tx &lt; 1 || tx > n || ty &lt; 1 || ty > m || c[tx][ty] == -1) continue; if (f[tx][ty][s] > f[x][y][s] + w[tx][ty]) &#123; f[tx][ty][s] = f[x][y][s] + w[tx][ty]; if (!inq[tx][ty]) q.emplace(tx, ty), inq[tx][ty] = 1; &#125; &#125; &#125; &#125; int work(void) &#123; // é€‰æ‹© k ä¸ªç‚¹çš„æœ€å°ä»£ä»· int ans = INF; for (int opt = 1; opt &lt;= 200; ++opt) &#123; shuffle(cc + 1, cc + tot + 1, Rand); for (int i = 1; i &lt;= tot; ++i) to[cc[i]] = (i - 1) % k; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; for (int s = 1; s &lt; 1 &lt;&lt; k; ++s) f[i][j][s] = INF; if (c[i][j] != -1) f[i][j][1 &lt;&lt; to[c[i][j]]] = w[i][j]; &#125; for (int s = 1; s &lt; 1 &lt;&lt; k; ++s) &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (c[i][j] != -1) &#123; for (int t = s - 1 &amp; s; t; t = t - 1 &amp; s) f[i][j][s] = min(f[i][j][s], f[i][j][t] + f[i][j][s ^ t] - w[i][j]); if (f[i][j][s] &lt; INF) q.emplace(i, j), inq[i][j] = 1; &#125; SPFA(s); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) ans = min(ans, f[i][j][(1 &lt;&lt; k) - 1]); &#125; return ans; &#125; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); tot = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;c[i][j]); if (c[i][j] != -1) cc[++tot] = c[i][j]; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[i][j]), w[i][j] = 1; sort(cc + 1, cc + tot + 1); tot = unique(cc + 1, cc + tot + 1) - (cc + 1); int rec = work(); if (rec == INF) return puts(\"-1 -1\"), void(); int L = 0, R = 1000001; while (L + 1 != R) &#123; int mid = L + R >> 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) w[i][j] = (a[i][j] &lt;= mid ? 54289 : 54291); if (work() &lt;= rec * 54290) R = mid; else L = mid; &#125; printf(\"%d %d\\n\", rec, R); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; æ ¹å·åˆ†æ²» å°±æ˜¯é’ˆå¯¹æ ¹å·çš„åˆ†ç±»è®¨è®ºï¼Œæˆ–è€…é’ˆå¯¹ä¸¤ç§æ•°æ®èŒƒå›´ç»™å‡ºä¸åŒçš„è§£æ³•ã€‚ [CF797E] Array Queries Portal. å½“ kâ‰¥nk\\ge \\sqrt{n}kâ‰¥nâ€‹ æ—¶æš´åŠ›ï¼Œå¦åˆ™é¢„å¤„ç†å‡ºç­”æ¡ˆã€‚æ—¶é—´å¤æ‚åº¦ O(nn)O(n\\sqrt{n})O(nnâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int BLOCK_SIZE = 200; int n, m; int a[100005], f[205][100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int k = 1; k &lt; BLOCK_SIZE; ++k) for (int p = n; p >= 1; --p) f[k][p] = (p + a[p] + k > n ? 1 : f[k][p + a[p] + k] + 1); scanf(\"%d\", &amp;m); while (m--) &#123; int p, k; scanf(\"%d%d\", &amp;p, &amp;k); if (k >= BLOCK_SIZE) &#123; int res = 0; while (p &lt;= n) p += a[p] + k, ++res; printf(\"%d\\n\", res); &#125; else printf(\"%d\\n\", f[k][p]); &#125; return 0; &#125; [CF710F] String Set Queries Portal. ä¸åŒé•¿åº¦çš„å­—ç¬¦ä¸²æœ€å¤šåªæœ‰ n\\sqrt{n}nâ€‹ ä¸ªï¼Œå¯¹æ¯ä¸€ä¸ªå¼€ä¸€ä¸ª multiset ç»Ÿè®¡å‡ºç°æ¬¡æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 B = 10079, P = 110765311; const int N = 300000; int n, id[300005], tot, rev[300005]; char s[300005]; i64 b[300005], h[300005]; unordered_multiset&lt;i64> H[805]; int main(void) &#123; int m, op; scanf(\"%d\", &amp;m); for (int i = b[0] = 1; i &lt;= N; ++i) b[i] = b[i - 1] * B % P; while (m--) &#123; scanf(\"%d%s\", &amp;op, s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) h[i] = (h[i - 1] * B + s[i]) % P; if (op == 1) &#123; if (!id[n]) rev[id[n] = ++tot] = n; H[id[n]].insert(h[n]); &#125; else if (op == 2) H[id[n]].erase(h[n]); else &#123; int ans = 0; for (int i = 1, L; i &lt;= tot; ++i) for (int j = L = rev[i]; j &lt;= n; ++j) ans += H[i].count((h[j] - h[j - L] * b[L] % P + P) % P); printf(\"%d\\n\", ans); fflush(stdout); &#125; &#125; return 0; &#125; [CF1446D2] Frequency Problem (Hard Version) Portal. é¦–å…ˆä¸€ä¸ªç»“è®ºï¼šå…¶ä¸­ä¸€å®šæœ‰ä¸€ä¸ªä¼—æ•°æ˜¯å…¨å±€ä¼—æ•°ã€‚å¦åˆ™ä¸€å®šå¯ä»¥æ‰©å±•è¿™ä¸ªå­æ®µä½¿å¾—å…¨å±€ä¼—æ•°å˜ä¸ºå…¶ä¸­ä¹‹ä¸€ã€‚ é‡‡ç”¨æ ¹å·åˆ†æ²»ï¼Œå¦‚æœä¸€ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°å¤§äº n\\sqrt{n}nâ€‹ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥æ‰«æåºåˆ—ï¼Œè®°å½•ä¸€ä¸ª resresres ä»£è¡¨å…¨å±€ä¼—æ•°å’Œå½“å‰é€‰æ‹©æ•°çš„å·®å€¼ï¼Œè®°å½•å¯ä»¥å–åˆ°è¿™ä¸ªå·®å€¼çš„ä½ç½®æœ€å°å€¼å°±æ˜¯å€™é€‰ç­”æ¡ˆå­æ®µçš„å·¦ä¾§ã€‚ å¦åˆ™ï¼Œæšä¸¾å‡ºç°æ¬¡æ•° xxxï¼Œç„¶åç”¨åŒæŒ‡é’ˆæ‰«æåºåˆ—ï¼ŒRRR å¾€å³èµ°ï¼ŒLLL æ˜¯æ»¡è¶³æ‰€æœ‰æ•°çš„å‡ºç°æ¬¡æ•°éƒ½ â‰¤x\\le xâ‰¤x çš„æœ€å·¦ç«¯ï¼Œå¦‚æœå‡ºç°æ¬¡æ•°ä¸º xxx çš„æ•°çš„ä¸ªæ•°è‡³å°‘ä¸º 222ï¼Œé‚£ä¹ˆå½“å‰å­æ®µå¯ä»¥æˆä¸ºç­”æ¡ˆã€‚ æ—¶é—´å¤æ‚åº¦ O(nn)O(n\\sqrt{n})O(nnâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, t; int a[200005], cnt[200005]; int tmp[400005]; int main(void) &#123; scanf(\"%d\", &amp;n); t = sqrt(n); int ans = 0, mode = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i), ++cnt[a[i]]; if (cnt[a[i]] > cnt[mode]) mode = a[i]; &#125; for (int x = 1; x &lt;= n; ++x) if (cnt[x] > t) &#123; // å‡ºç°æ¬¡æ•°å¤§äº sqrt n if (x == mode) continue; int res = 0; memset(tmp, 0, sizeof tmp); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] == mode) ++res; else if (a[i] == x) --res; if (tmp[res + n] || res == 0) ans = max(ans, i - tmp[res + n]); else tmp[res + n] = i; &#125; &#125; for (int x = 1; x &lt;= t; ++x) &#123; // æšä¸¾å‡ºç°æ¬¡æ•° x int L = 1, res = 0; memset(tmp, 0, sizeof tmp); // i çš„å‡ºç°æ¬¡æ•° for (int R = 1; R &lt;= n; ++R) &#123; if (++tmp[a[R]] == x) ++res; for (; L &lt;= R &amp;&amp; tmp[a[R]] > x; ++L) if (tmp[a[L]]-- == x) --res; if (res >= 2) ans = max(ans, R - L + 1); &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; [Ynoi2011] åˆå§‹åŒ– Portal. å°†åŸåºåˆ—æŒ‰ç…§ BBB åˆ†å—ï¼Œå¯¹äº xâ‰¥Bx\\ge Bxâ‰¥B çš„æ—¶å€™å¯ä»¥ç›´æ¥æš´åŠ›ä¿®æ”¹ï¼Œå¦åˆ™å¯¹äºä¸åŒçš„ xxx å¯ä»¥æŒ‰ç…§ xxx åˆ†å—ï¼Œå¯¹äºä¸€ä¸ªå—å†…ä¿®æ”¹å‰åç¼€å’Œï¼ˆå•ç‚¹ä¿®æ”¹åŒºé—´æŸ¥è¯¢è½¬åŒ–æˆåŒºé—´ä¿®æ”¹å•ç‚¹æŸ¥è¯¢ï¼‰ã€‚ æ—¶é—´å¤æ‚åº¦ O(nn)O(n\\sqrt{n})O(nnâ€‹)ï¼Œä½†æ˜¯å—é•¿å¯ä»¥è°ƒå°ï¼Œå› ä¸ºæš´åŠ›å¸¸æ•°å¾ˆå°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int BLOCK_SIZE = 110; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; inline void del(int &amp;x, int t) &#123; x -= t; if (x &lt; 0) x += P; &#125; int n, m, a[200005], sum[3005]; int pos[200005], L[3005], R[3005]; int pre[155][155], suf[155][155]; int query(int l, int r) &#123; int p = pos[l], q = pos[r], res = 0; if (p == q) for (int i = l; i &lt;= r; ++i) add(res, a[i]); else &#123; for (int i = L[q]; i &lt;= r; ++i) add(res, a[i]); for (int i = R[p]; i >= l; --i) add(res, a[i]); for (int i = p + 1; i &lt; q; ++i) add(res, sum[i]); &#125; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int t = n / BLOCK_SIZE; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; if (R[t] &lt; n) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = n; &#125; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i, add(sum[i], a[j]); while (m--) &#123; int op; scanf(\"%d\", &amp;op); if (op == 1) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); if (x >= BLOCK_SIZE) for (int i = y; i &lt;= n; i += x) add(a[i], z), add(sum[pos[i]], z); else &#123; for (int i = 1; i &lt;= y; ++i) add(suf[x][i], z); for (int i = y; i &lt;= x; ++i) add(pre[x][i], z); &#125; &#125; else &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); int ans = query(l, r); for (int i = 1; i &lt; BLOCK_SIZE; ++i) &#123; int p = (l - 1) / i + 1, q = (r - 1) / i + 1; if (p == q) &#123; del(ans, pre[i][(l - 1) % i]); add(ans, pre[i][(r - 1) % i + 1]); &#125; else &#123; add(ans, 1ll * (q - p - 1) * pre[i][i] % P); add(ans, pre[i][(r - 1) % i + 1]); add(ans, suf[i][(l - 1) % i + 1]); &#125; &#125; printf(\"%d\\n\", (ans % P + P) % P); &#125; &#125; return 0; &#125; [CF1039D] You Are Given a Tree Portal. å¦‚æœ kkk ç»™å®šï¼Œé‚£ä¹ˆè€ƒè™‘ O(n)O(n)O(n) æ ‘å½¢ DPï¼ˆå› ä¸ºåªè¦èƒ½é€‰ä¸€å®šä¸åŠ£ï¼‰å°±å¯è§£å†³ã€‚ å‘ç°ç­”æ¡ˆçš„å–å€¼æ¯”è¾ƒå°‘ã€‚è€ƒè™‘æ ¹å·åˆ†æ²»ï¼Œå¯¹äºå°äºç­‰äºé˜ˆå€¼çš„éƒ¨åˆ†å¯ä»¥ç›´æ¥ O(n)O(n)O(n) æ ‘å½¢ DP è§£å†³ï¼ˆéœ€è¦å¡å¸¸ï¼Œè€ƒè™‘è½¬åˆ° DFS åºä¸Š DPï¼‰ã€‚ å¤§äºé˜ˆå€¼çš„éƒ¨åˆ†å‘ç°ç­”æ¡ˆåªæœ‰ nB\\cfrac{n}{B}Bnâ€‹ ç§ï¼Œè€ƒè™‘äºŒåˆ†å“ªäº›éƒ¨åˆ†çš„ç­”æ¡ˆæ˜¯ä¸€æ ·çš„ï¼Œåªä¼šè¿›è¡Œ nB\\cfrac n BBnâ€‹ æ¬¡äºŒåˆ†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nBnlogâ¡n)O(\\cfrac n B n\\log n)O(Bnâ€‹nlogn)ã€‚ å– B=nlogâ¡nB=\\sqrt{n\\log n}B=nlognâ€‹ï¼Œç†è®ºæœ€ä¼˜æ—¶é—´å¤æ‚åº¦ä¸º O(nnlogâ¡n)O(n\\sqrt{n\\log n})O(nnlognâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 600; int n, ans[100005]; int fa[100005], num, idx[100005]; int f[100005]; vector&lt;int> G[100005]; void dfs(int x, int fa) &#123; ::fa[x] = fa; for (int y : G[x]) if (y != fa) dfs(y, x); idx[++num] = x; &#125; int solve(int k) &#123; int res = 0; f[0] = -1; for (int i = 1; i &lt;= n; ++i) f[i] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int x = idx[i]; if (f[fa[x]] != -1 &amp;&amp; f[x] != -1) &#123; if (f[x] + f[fa[x]] >= k) ++res, f[fa[x]] = -1; else f[fa[x]] = max(f[fa[x]], f[x] + 1); &#125; &#125; return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; ans[1] = n; dfs(1, 0); for (int k = 2; k &lt;= BLOCK_SIZE; ++k) ans[k] = solve(k); for (int k = BLOCK_SIZE + 1; k &lt;= n; ) &#123; int L = k - 1, R = n + 1, res = solve(k); while (L + 1 != R) &#123; int mid = L + R >> 1; if (res == solve(mid)) L = mid; else R = mid; &#125; for (int i = k; i &lt;= L; ++i) ans[i] = res; k = R; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"ç½‘ç»œæµé—®é¢˜","slug":"notes/å›¾è®º/flow","date":"2022-12-07T00:00:00.000Z","updated":"2022-12-07T00:00:00.000Z","comments":true,"path":"ecebf309/","link":"","permalink":"https://james1badcreeper.github.io/ecebf309/","excerpt":"ç½‘ç»œæµæ˜¯ä¸ªå¾ˆæœ‰ç”¨çš„ä¸œè¥¿ï¼Œå¾ˆå¤šé—®é¢˜éƒ½å¯ä»¥è½¬åŒ–ä¸ºç½‘ç»œæµã€‚","text":"ç½‘ç»œæµæ˜¯ä¸ªå¾ˆæœ‰ç”¨çš„ä¸œè¥¿ï¼Œå¾ˆå¤šé—®é¢˜éƒ½å¯ä»¥è½¬åŒ–ä¸ºç½‘ç»œæµã€‚ ç›®å‰æœ¬æ–‡ä¼šå¾ˆå¿«åˆ‡å…¥å»ºå›¾ï¼Œè¯æ˜ä»€ä¹ˆæœ‰æ—¶é—´å†è¡¥ã€‚ æ¦‚è¿° ä¸€ä¸ªç½‘ç»œæ˜¯ä¸€å¼ æœ‰å‘å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œå¯¹äºæ¯æ¡æœ‰å‘è¾¹ (u,v)âˆˆE(u,v)\\in E(u,v)âˆˆE å­˜åœ¨å®¹é‡é™åˆ¶ c(u,v)c(u,v)c(u,v)ï¼Œå½“ (u,v)âˆˆÌ¸E(u,v)\\not\\in E(u,v)î€ âˆˆE æ—¶ï¼Œc(u,v)=0c(u,v)=0c(u,v)=0ã€‚ç½‘ç»œçš„å¯è¡Œæµåˆ†ä¸ºæœ‰æºæ±‡ï¼ˆæŒ‡å®šäº†ä¸¤ä¸ªèŠ‚ç‚¹ s,ts,ts,tï¼Œä»£è¡¨å›¾çš„æºç‚¹å’Œæ±‡ç‚¹ï¼‰å’Œæ— æºæ±‡ï¼Œä½†æ˜¯éƒ½å­˜åœ¨ä¸€ä¸ªå®šä¹‰åŸŸä¸ºèŠ‚ç‚¹äºŒå…ƒç»„çš„æµå‡½æ•° f(x,y)f(x,y)f(x,y)ï¼Œf(x,y)f(x,y)f(x,y) ä»£è¡¨è¾¹ xâ†’yx\\rightarrow yxâ†’y çš„æµé‡ï¼Œæ»¡è¶³ï¼š fff æ»¡è¶³å®¹é‡é™åˆ¶ï¼šf(x,y)â‰¤c(x,y)f(x,y)\\le c(x,y)f(x,y)â‰¤c(x,y)ï¼Œå½“ä¸¤è€…ç›¸ç­‰æ—¶ï¼Œxâ†’yx\\rightarrow yxâ†’y å°±æµæ»¡äº†ï¼› æ–œå¯¹ç§°æ€§è´¨ï¼šf(x,y)=âˆ’f(y,x)f(x,y)=-f(y,x)f(x,y)=âˆ’f(y,x)ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåå‘è¾¹å…¶å®æ˜¯è´Ÿçš„æµé‡[1]ï¼› æµé‡å®ˆæ’ï¼šé™¤æºç‚¹å’Œæ±‡ç‚¹å¤–ï¼ˆå½“ç„¶åªé™äºæœ‰æºæ±‡å¯ä»¥é™¤äº†è¿™ä¸¤ä¸ªèŠ‚ç‚¹ï¼‰ï¼Œä»æ¯ä¸ªèŠ‚ç‚¹æµå…¥å’Œæµå‡ºçš„æµé‡ç›¸ç­‰ï¼Œå³ âˆ€iâ‰ s,t,âˆ‘f(u,i)=âˆ‘f(i,v)\\forall i\\ne s,t,\\sum f(u,i)=\\sum f(i,v)âˆ€iî€ =s,t,âˆ‘f(u,i)=âˆ‘f(i,v)ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸å‚¨å­˜æµé‡ï¼Œè¿›å»å¤šå°‘å°±æµå‡ºæ¥å¤šå°‘ã€‚ ä»¥ä¸‹æ˜¯ä¸€äº›å®šä¹‰ï¼š å¯¹äºæœ‰æºæ±‡ï¼Œæœ‰ âˆ‘f(S,i)=âˆ‘f(i,T)\\sum f(S,i)=\\sum f(i,T)âˆ‘f(S,i)=âˆ‘f(i,T)ï¼Œæ­¤æ—¶è¿™ä¸ªç›¸ç­‰çš„å’Œæˆä¸ºå½“å‰æµ fff çš„æµé‡ã€‚ å®šä¹‰æµ fff åœ¨ç½‘ç»œ GGG ä¸Šçš„æ®‹é‡ç½‘ç»œ Gf=(V,Ef)G_f=(V,E_f)Gfâ€‹=(V,Efâ€‹) ä¸ºå®¹é‡å‡½æ•° cf=câˆ’fc_f=c-fcfâ€‹=câˆ’fã€‚æ ¹æ®å®¹é‡é™åˆ¶ï¼Œcf(x,y)â‰¥0c_f(x,y)\\ge 0cfâ€‹(x,y)â‰¥0ï¼Œå½“ cf(x,y)=0c_f(x,y)=0cfâ€‹(x,y)=0 æ—¶ï¼Œåˆ™è§†ä¸º xâ†’yx\\rightarrow yxâ†’y åœ¨æ®‹é‡ç½‘ç»œä¸Šä¸å­˜åœ¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æ®‹é‡ç½‘ç»œä¸­æˆ‘ä»¬è¦åˆ æ‰æ»¡æµè¾¹ã€‚ å®šä¹‰å¢å¹¿è·¯ PPP æ˜¯æ®‹é‡ç½‘ç»œ GfG_fGfâ€‹ ä¸Šæºç‚¹åˆ°æ±‡ç‚¹çš„ä¸€æ¡è·¯å¾„ï¼Œè€Œæ— æºæ±‡åˆ™æ²¡æœ‰å¢å¹¿è·¯ã€‚ å°†ç‚¹é›†åˆ†ä¸ºä¸¤ä¸ªäº’è¡¥ç›¸äº¤çš„ A,BA,BA,Bï¼Œä¸”æ»¡è¶³ SâˆˆA,TâˆˆBS\\in A, T\\in BSâˆˆA,TâˆˆBï¼Œè¿™ç§åˆ’åˆ†æ–¹å¼ç§°ä¸ºå‰²ï¼Œå‰²çš„å®¹é‡ä¸º âˆ‘uâˆˆAâˆ‘vâˆˆBc(u,v)\\sum_{u\\in A}\\sum_{v\\in B}c(u,v)âˆ‘uâˆˆAâ€‹âˆ‘vâˆˆBâ€‹c(u,v)ï¼Œæµé‡ä¸º âˆ‘uâˆˆAâˆ‘vâˆˆBf(u,v)\\sum_{u\\in A}\\sum_{v\\in B}f(u,v)âˆ‘uâˆˆAâ€‹âˆ‘vâˆˆBâ€‹f(u,v)ã€‚å¦‚æœ uâˆˆA,vâˆˆBu\\in A,v\\in BuâˆˆA,vâˆˆBï¼Œé‚£ä¹ˆ (u,v)(u,v)(u,v) æ˜¯å‰²è¾¹ï¼Œå¯ä»¥çœ‹å‡ºï¼Œå‰²è¾¹ä¸€èˆ¬ä¸æ­¢ä¸€æ¡ã€‚ æ¥ä¸‹æ¥è®¨è®ºçš„å†…å®¹é»˜è®¤éƒ½æ˜¯æœ‰æºæµï¼ æœ€å¤§æµé—®é¢˜ æœ€å¤§æµæ˜¯æ±‚ä¸€ä¸ªç½‘ç»œçš„æœ€å¤§æµé‡ã€‚ å¢å¹¿ æ‰¾åˆ°ä¸€æ¡æ®‹é‡ç½‘ç»œ GfG_fGfâ€‹ ä¸Šçš„å¢å¹¿è·¯ PPPï¼Œå¹¶ä¸º PPP ä¸Šçš„æ¯ä¸€æ¡è¾¹å¢åŠ  cf(P)=minâ¡(u,v)âˆˆPcf(u,v)c_f(P)=\\min_{(u,v)\\in P}c_f(u,v)cfâ€‹(P)=min(u,v)âˆˆPâ€‹cfâ€‹(u,v) çš„æµé‡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæµé‡èƒ½æµæ»¡å°±èƒ½æµæ»¡ã€‚è¿™ä¸€è¿‡ç¨‹ç§°ä¹‹ä¸ºå¢å¹¿ã€‚ æ€æ ·è¯æ˜è¿™ä¸ªè´ªå¿ƒç­–ç•¥ï¼Ÿä¸éœ€è¦ï¼å®é™…ä¸Šåœ¨å½“å‰è¾¹çš„æµé‡å¢åŠ  cf(x,y)c_f(x,y)cfâ€‹(x,y) æ—¶ï¼Œæˆ‘ä»¬è¦ç»™å®ƒçš„åå‘è¾¹çš„å®¹é‡å¢åŠ  cf(y,x)c_f(y,x)cfâ€‹(y,x)ï¼Œå…¶å®è¿™æ˜¯ä¸€ä¸ªåæ‚”è´ªå¿ƒçš„ç­–ç•¥ï¼Œå¯ä»¥å›æ”¶åŸæ¥çš„æµé‡ï¼Œæ­£ç¡®æ€§å¾—ä»¥ä¿è¯ã€‚ æœ€å¤§æµæœ€å°å‰²å®šç† å‰²ä¸­å‰²è¾¹å®¹é‡å’Œæœ€å°çš„åˆ’åˆ†æ–¹å¼ç§°ä¸ºæœ€å°å‰²ï¼Œè€Œä¸”æœ€å¤§æµç­‰äºæœ€å°å‰²ã€‚è¯æ˜å¦‚ä¸‹ï¼š å­˜åœ¨ä¸€ç»„æµçš„æµé‡ç­‰äºä¸€ç»„å‰²çš„å®¹é‡ï¼šåªéœ€è¦è®©å‰²è¾¹æµæ»¡å³å¯ï¼Œæœ€å¤§æµå­˜åœ¨çš„æ—¶å€™æ®‹é‡ç½‘ç»œä¸è¿é€šï¼Œä¹Ÿå°±æä¾›äº†ä¸€ç»„å‰²ã€‚ ä»»æ„ä¸€ç»„æµçš„æµé‡ä¸å¤§äºä»»æ„ä¸€ç»„å‰²çš„å®¹é‡ã€‚å¦‚æœå‰²æ‰è¿™äº›è¾¹ï¼Œé‚£ä¹ˆç½‘ç»œæµé‡å°šæœªæœ€å¤§åŒ–ï¼Œä»ç„¶å¯ä»¥æ‰¾åˆ°å¢å¹¿è·¯ï¼Œä¸æœ€å¤§æµçš„æ±‚è§£æ–¹å¼çŸ›ç›¾ã€‚ Dinic ç®—æ³• Edmonds-Karp å’Œå…¶ä»–é«˜çº§ç®—æ³•åœ¨æœ¬æ–‡ä¸­ä¸ä¼šå‡ºç°ï¼Œåªä¼šä»‹ç» Dinicã€‚ æ¨¡æ¿ã€‚ Dinic ä¼šä¸æ–­è¿›è¡Œ bfs æ¥åœ¨æ®‹é‡ç½‘ç»œä¸Šæ„é€ åˆ†å±‚å›¾ï¼ˆæ ¹æ®èŠ‚ç‚¹çš„å±‚æ¬¡ d[x]d[x]d[x]ï¼Œä» SSS åˆ° xxx æœ€å°‘éœ€è¦ç»è¿‡çš„è¾¹æ•°ï¼‰ï¼Œç„¶ååœ¨åˆ†å±‚å›¾ä¸Šè¿›è¡Œ dfs å¯»æ‰¾å¢å¹¿è·¯ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(n2m)O(n^2m)O(n2m)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 1e18; struct edge &#123; int u, v, w; edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; &#125;; int n, m, s, t, d[1205], cur[1205]; // cur ä¸ºå½“å‰å¼§ä¸‹æ ‡ vector&lt;int> G[1205]; vector&lt;edge> edges; inline void addedge(int u, int v, int w) &#123; edges.emplace_back(edge(u, v, w)); G[u].emplace_back(edges.size() - 1); &#125; bool bfs(void) &#123; memset(cur, 0, sizeof(cur)); memset(d, -1, sizeof(d)); queue&lt;int> q; q.push(s); d[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; q.push(e.v); d[e.v] = d[u] + 1; if (e.v == t) return true; &#125; &#125; &#125; return false; &#125; i64 dinic(int x, i64 res) &#123; if (x == t || res == 0) return res; i64 flow = 0; for (int i = cur[x]; i &lt; G[x].size() &amp;&amp; res; ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; i64 c = min(res, (i64)e.w); if (d[e.v] == d[x] + 1 &amp;&amp; c) &#123; i64 k = dinic(e.v, c); flow += k; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; return flow; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, 0); &#125; i64 flow = 0, maxflow = 0; while (bfs()) while (flow = dinic(s, INF)) maxflow += flow; printf(\"%lld\\n\", maxflow); return 0; &#125; æ— è´Ÿç¯è´¹ç”¨æµ æŒ‡çš„æ˜¯æœ€å°è´¹ç”¨æœ€å¤§æµï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨åŸæœ‰ç½‘ç»œçš„åŸºç¡€ä¸Šï¼Œæ¯ä¸€æ¡è¾¹å¤šäº†ä¸€ä¸ªæƒå€¼ w(x,y)w(x,y)w(x,y)ï¼Œè¦æ±‚åœ¨ä¿è¯æœ€å¤§æµå‰æä¸‹ï¼Œæ‰¾å‡º âˆ‘(x,y)âˆˆEf(x,y)Ã—w(x,y)\\sum_{(x,y)\\in E} f(x,y)\\times w(x,y)âˆ‘(x,y)âˆˆEâ€‹f(x,y)Ã—w(x,y) çš„æœ€å°å€¼ã€‚é€šå¸¸ä½¿ç”¨ SPP ç®—æ³•è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ SSP å®ç°æ—¶åªéœ€è¦å°† Dinic çš„ bfs æ›¿æ¢ä¸º SPFA å³å¯ï¼ˆæ¯æ¡è¾¹çš„é•¿åº¦ä¸ºæƒå€¼ wwwï¼‰ã€‚ç›¸åº”çš„åœ°æ–¹æ”¹ä¸€ä¸‹å³å¯ã€‚ç†è®ºä¸Šé™æ—¶é—´å¤æ‚åº¦å¾ˆé«˜ï¼Œä½†æ˜¯å®é™…è¡¨ç°ä¸é”™ï¼Œè€Œä¸”ä¸šç•Œå…¬çº¦ä¸å¡ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 1e18; struct edge &#123; int u, v, w, c; edge(int u = 0, int v = 0, int w = 0, int c = 0) : u(u), v(v), w(w), c(c) &#123;&#125; &#125;; int n, m, s, t, cur[5005], d[5005]; bool inq[5005]; vector&lt;int> G[5005]; vector&lt;edge> edges; inline void addedge(int u, int v, int w, int c) &#123; edges.emplace_back(edge(u, v, w, c)); G[u].emplace_back(edges.size() - 1); &#125; bool SPFA(void) &#123; memset(cur, 0, sizeof(cur)); memset(d, 0x3f, sizeof(d)); queue&lt;int> q; q.push(s); d[s] = 0; inq[s] = true; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] > d[u] + e.c) &#123; d[e.v] = d[u] + e.c; if (!inq[e.v]) q.push(e.v), inq[e.v] = true; &#125; &#125; &#125; return d[t] &lt; 0x3f3f3f3f; &#125; i64 cost; bool vis[5005]; i64 dinic(int x, i64 res) &#123; if (x == t) return res; i64 flow = 0; vis[x] = true; for (int i = cur[x]; i &lt; G[x].size() &amp;&amp; res; ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; i64 c = min(res, i64(e.w)); if (!vis[e.v] &amp;&amp; c &amp;&amp; d[e.v] == d[x] + e.c) &#123; i64 k = dinic(e.v, c); flow += k; cost += k * e.c; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = 0x3f3f3f3f; vis[x] = false; return flow; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); while (m--) &#123; int u, v, w, c; scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;w, &amp;c); addedge(u, v, w, c); addedge(v, u, 0, -c); &#125; i64 maxflow = 0, flow; while (SPFA()) while (flow = dinic(s, INF)) maxflow += flow; printf(\"%lld %lld\\n\", maxflow, cost); return 0; &#125; è§£é¢˜æ€è·¯ ç½‘ç»œæµæœ¬è´¨ä¸Šæ˜¯ä¸€ç§åæ‚”è´ªå¿ƒï¼Œå°†è´ªå¿ƒçš„åæ‚”ç­–ç•¥ç”¨ä¸€æ¡åå‘è¾¹ç®€å•çš„è¡¨ç¤ºã€‚åœ¨è§£é¢˜æ—¶ï¼Œå…³é”®åœ¨äºæ‰¾åˆ°é¢˜ç›®ä¸­çš„æ–¹æ¡ˆå’Œä¸€ç§æµæˆ–å‰²å¯¹åº”ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š [SHOI2007] å–„æ„çš„æŠ•ç¥¨ã€‚å¹¼å„¿å›­é‡Œæœ‰ nnn ä¸ªå°æœ‹å‹æ‰“ç®—é€šè¿‡æŠ•ç¥¨æ¥å†³å®šç¡ä¸ç¡åˆè§‰ã€‚è™½ç„¶æ¯ä¸ªäººéƒ½æœ‰è‡ªå·±çš„ä¸»è§ï¼Œä½†æ˜¯ä¸ºäº†ç…§é¡¾ä¸€ä¸‹è‡ªå·±æœ‹å‹çš„æƒ³æ³•ï¼Œä»–ä»¬ä¹Ÿå¯ä»¥æŠ•å’Œè‡ªå·±æœ¬æ¥æ„æ„¿ç›¸åçš„ç¥¨ã€‚æˆ‘ä»¬å®šä¹‰ä¸€æ¬¡æŠ•ç¥¨çš„å†²çªæ•°ä¸ºå¥½æœ‹å‹ä¹‹é—´å‘ç”Ÿå†²çªçš„æ€»æ•°åŠ ä¸Šå’Œæ‰€æœ‰å’Œè‡ªå·±æœ¬æ¥æ„æ„¿å‘ç”Ÿå†²çªçš„äººæ•°ã€‚ç»™å‡ºæ¯ä¸ªå°æœ‹å‹çš„æ„æ„¿å’Œæ¯ä¸€å¯¹å¥½æœ‹å‹ã€‚æˆ‘ä»¬çš„é—®é¢˜å°±æ˜¯ï¼Œæ¯ä½å°æœ‹å‹åº”è¯¥æ€æ ·æŠ•ç¥¨ï¼Œæ‰èƒ½ä½¿å†²çªæ•°æœ€å°ï¼Ÿè¾“å‡ºå¯èƒ½çš„æœ€å°å†²çªæ•°ã€‚å¯¹äº 100%100\\%100% çš„æ•°æ®ï¼Œ2â‰¤nâ‰¤3002\\le n\\le3002â‰¤nâ‰¤300ï¼Œ1â‰¤mâ‰¤n(nâˆ’1)21\\le m \\le \\frac{n(n-1)}21â‰¤mâ‰¤2n(nâˆ’1)â€‹ã€‚ è¿™çœ‹èµ·æ¥å¾ˆåƒä¸€ä¸ªæœ€å°å‰²çš„æ¨¡å‹ï¼Œè€ƒè™‘å¦‚ä½•ä½¿ç”¨ä¸€ç»„å‰²æ¥è¡¨ç¤ºä¸€ç§æ„è§æ–¹æ¡ˆã€‚æ¯å‰²æ‰ä¸€æ¡è¾¹éœ€è¦ä»˜å‡º 111 çš„ä»£ä»·ã€‚äºæ˜¯å°†æ”¯æŒçš„å°æœ‹å‹ä¸ SSS è¿è¾¹ï¼Œåå¯¹çš„å°æœ‹å‹ä¸ TTT è¿è¾¹ï¼Œæ¯å¯¹æœ‹å‹ä¹‹é—´è¿è¾¹ï¼Œæ±‚å‡ºå›¾çš„æœ€å°å‰²å³å¯ã€‚è¿™å…¶å®æ˜¯ä¸€ä¸ªé›†åˆåˆ’åˆ†æ¨¡å‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; struct edge &#123; int u, v, w; edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; &#125;; vector&lt;edge> edges; vector&lt;int> G[305]; int d[305], cur[305]; inline void addedge(int u, int v, int w) &#123; edges.emplace_back(edge(u, v, w)); G[u].emplace_back(edges.size() - 1); &#125; bool bfs(void) &#123; memset(d, -1, sizeof(d)); memset(cur, 0, sizeof(cur)); queue&lt;int> q; q.push(0); d[0] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; q.push(e.v); d[e.v] = d[u] + 1; if (e.v == n + 1) return true; &#125; &#125; &#125; return false; &#125; int dinic(int x, int res) &#123; if (x == n + 1 || res == 0) return res; int flow = 0; for (int i = cur[x]; i &lt; G[x].size(); ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; int c = min(res, e.w); if (d[e.v] == d[x] + 1 &amp;&amp; c) &#123; int k = dinic(e.v, c); flow += k; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; return flow; &#125; int type[305]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", type + i); if (type[i]) addedge(0, i, 1), addedge(i, 1, 0); else addedge(i, n + 1, 1), addedge(n + 1, i, 0); &#125; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (type[u] == 0 &amp;&amp; type[v] == 1) swap(u, v); addedge(u, v, 1); addedge(v, u, 0); &#125; int flow = 0, maxflow = 0; while (bfs()) while (flow = dinic(0, 1e9)) maxflow += flow; printf(\"%d\\n\", maxflow); return 0; &#125; å¦‚æœè¦æ±‚è¾“å‡ºé›†åˆåˆ’åˆ†æ¨¡å‹çš„ä¸€ç»„æ–¹æ¡ˆï¼Œé‚£ä¹ˆå°±çœ‹æ®‹ä½™ç½‘ç»œä¸Šçš„ sss åˆ°æ¯ä¸ªç‚¹çš„è·ç¦»ã€‚å¦‚æœèƒ½èµ°åˆ°å°±æ˜¯åœ¨ AAAï¼Œå¦åˆ™å°±æ˜¯åœ¨ BBBã€‚ ä¸Šä¸‹ç•Œç½‘ç»œæµ æœ‰çš„é¢˜ç›®çš„æµé‡é™åˆ¶é™¤äº†æœ‰ä¸Šç•Œï¼Œè¿˜æœ‰ä¸‹ç•Œã€‚ ç½‘ç»œæµå¸¸è§æ¨¡å‹ æˆ‘ä»¬æ¥çœ‹ä¸€äº›ç½‘ç»œæµçš„å¸¸è§æ¨¡å‹ã€‚ ç‚¹è¾¹è½¬åŒ– | æœ€å°å‰²ç‚¹ å¦‚æœåˆ å»ç‚¹ iii æœ‰ä»£ä»· wiw_iwiâ€‹ï¼Œæ±‚ä½¿å¾— S,TS,TS,T ä¸è¿é€šçš„æœ€å°ä»£ä»·ï¼Ÿ å°†æ¯ä¸ªç‚¹æ‹†æˆå…¥ç‚¹ iini_{in}iinâ€‹ å’Œå‡ºç‚¹ iouti_{out}ioutâ€‹ï¼Œåœ¨å®ƒä»¬ä¹‹é—´è¿ä¸€æ¡å®¹é‡ä¸º wiw_iwiâ€‹ çš„è¾¹ï¼Œè¡¨ç¤ºåˆ å»è¿™ä¸ªç‚¹ã€‚å¯¹äºåŸå›¾çš„æ¯ä¸€æ¡è¾¹ u,vu,vu,vï¼Œè¿æ¥ uoutâ†’vinu_{out}\\rightarrow v_{in}uoutâ€‹â†’vinâ€‹ ä¸€æ¡ +âˆ+\\infty+âˆ å®¹é‡çš„è¾¹ï¼Œè¿™æ ·æˆ‘ä»¬åªèƒ½åˆ ç‚¹è€Œä¸ä¼šå‰²è¾¹ã€‚ é›†åˆåˆ’åˆ†æ¨¡å‹ è¿™ä¸ªå†…å®¹éå¸¸å¸¸è§ã€‚ minâ¡x1,x2,â‹¯xnâˆˆ{0,1}âˆ‘(u,v)âˆˆEcu,vxuxvâ€¾+âˆ‘uauxu+buxuâ€¾\\min_{x_1,x_2,\\cdots x_n\\in\\{0,1\\}}\\sum_{(u,v)\\in E} c_{u,v}x_u\\overline{x_v}+\\sum_{u}a_ux_u+b_u\\overline{x_u} x1â€‹,x2â€‹,â‹¯xnâ€‹âˆˆ{0,1}minâ€‹(u,v)âˆˆEâˆ‘â€‹cu,vâ€‹xuâ€‹xvâ€‹â€‹+uâˆ‘â€‹auâ€‹xuâ€‹+buâ€‹xuâ€‹â€‹ è¯´çš„å°±æ˜¯ä¸º xix_ixiâ€‹ é€‰å®šåˆé€‚çš„å€¼ï¼Œä½¿å¾—å’Œå¼çš„å€¼æœ€å°ã€‚ è¿ Sâ†’iS\\rightarrow iSâ†’i çš„å®¹é‡ä¸º bib_ibiâ€‹ çš„è¾¹ï¼Œiâ†’Ti\\rightarrow Tiâ†’T çš„å®¹é‡ä¸º aia_iaiâ€‹ çš„è¾¹ã€‚å¦‚æœå‰²æ‰äº† iâ†’Ti\\rightarrow Tiâ†’Tï¼Œè¯´æ˜å°† iii åˆ’åˆ†åˆ°äº†é›†åˆ AAAï¼Œä»£ä»·ä¸º aia_iaiâ€‹ã€‚ ç»™ u,vu,vu,v è¿å®¹é‡é™åˆ¶ä¸º cu,vc_{u,v}cu,vâ€‹ çš„åŒå‘è¾¹ï¼Œè¿™æ ·å¦‚æœ u,vu,vu,v ä¸å±äºåŒä¸€é›†åˆï¼Œè‡³å°‘ä¼šå‰²æ‰å…¶ä¸­ä¸€æ¡è¾¹ã€‚ è¿™æ ·è¿™ä¸ªç½‘ç»œçš„æœ€å°å‰²å°±æ˜¯ç­”æ¡ˆã€‚ è¿˜æœ‰ä¸€ç§é™åˆ¶ï¼šxxx åœ¨é›†åˆ AAA ä¸” yyy åœ¨é›†åˆ BBB æ—¶æœ‰ä»£ä»· wwwï¼Œé‚£ä¹ˆè¿ xâ†’yx\\rightarrow yxâ†’y çš„å®¹é‡ä¸º www çš„è¾¹ï¼Œè¿™æ ·å¦‚æœ xxx å’Œ SSS ç›¸è¿ä¸” yyy å’Œ TTT ç›¸è¿ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹éœ€è¦è¢«å‰²æ‰ã€‚ å¦‚ä½•è¾“å‡ºæ–¹æ¡ˆï¼Ÿè¦æ³¨æ„ä»€ä¹ˆæ˜¯å‰²è¾¹ï¼šåœ¨æœ€åçš„æ®‹é‡ç½‘ç»œä¸Š d(x)d(x)d(x) æ˜¯å¦å­˜åœ¨ï¼Œå­˜åœ¨åˆ™å±äºé›†åˆ AAAï¼Œå¦åˆ™æ˜¯é›†åˆ BBBã€‚ æœ€å¤§æƒé—­åˆå­å›¾ ä¸€å¼ æœ‰å‘å›¾ G=(V,E)G=(V,E)G=(V,E) çš„é—­åˆå­å›¾ Gâ€²G&#x27;Gâ€² å®šä¹‰åœ¨ç‚¹é›† Vâ€²âŠ†VV&#x27;\\subseteq VVâ€²âŠ†V ä¸Šï¼Œä¸€ä¸ªç‚¹é›† Vâ€²V&#x27;Vâ€² ç¬¦åˆè¦æ±‚å½“ä¸”ä»…å½“ Vâ€²V&#x27;Vâ€² å†…éƒ¨æ¯ä¸ªç‚¹çš„æ‰€æœ‰å‡ºè¾¹ä»æŒ‡å‘ Vâ€²V&#x27;Vâ€²ï¼Œå³ç‚¹é›†å†…éƒ¨æ¯ä¸ªç‚¹åœ¨æœ‰å‘å›¾ä¸Šèƒ½å¤Ÿåˆ°è¾¾çš„ç‚¹ä»ç„¶å±äºè¯¥ç‚¹é›†ã€‚ è€Œæœ€å¤§æƒé—­åˆå­å›¾åˆ™æ˜¯æ¯ä¸ªç‚¹æœ‰ç‚¹æƒï¼Œæ±‚é—­åˆå­å›¾çš„æœ€å¤§æƒå€¼ã€‚ è€ƒè™‘é›†åˆåˆ’åˆ†æ¨¡å‹ï¼Œå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥å°†å…¶åˆ’åˆ†åˆ°é€‰æˆ–ä¸é€‰çš„é›†åˆä¸­ï¼Œä¹Ÿå°±æ˜¯ Sâ†’iS\\rightarrow iSâ†’i è¿ 000ï¼Œiâ†’Ti\\rightarrow Tiâ†’T è¿ wiw_iwiâ€‹ã€‚å¦‚æœ (u,v)âˆˆE(u,v)\\in E(u,v)âˆˆEï¼Œå°±æ˜¯å¦‚æœ uuu åˆ†åˆ°é€‰çš„é›†åˆä¸­ï¼Œvvv ä¹Ÿå¿…é¡»åˆ†åˆ°é€‰çš„é›†åˆä¸­ï¼Œå³ uâ†’vu\\rightarrow vuâ†’v æœ‰å®¹é‡ âˆ’âˆ-\\inftyâˆ’âˆï¼Œæ±‚ç½‘ç»œçš„æœ€å¤§å‰²å³å¯ã€‚ ä½†æ˜¯æœ€å¤§å‰²æ˜¯ NPH çš„ï¼Œå› æ­¤è€ƒè™‘å–ç›¸åæ•°æ±‚æœ€å°å‰²ã€‚ç„¶è€Œè¿™æ ·ä¼šå‡ºç°è´Ÿå®¹é‡çš„è¾¹ï¼å°†è´Ÿå®¹é‡çš„è¾¹æ”¹åˆ° Sâ†’iS\\rightarrow iSâ†’i æ¥è¿ã€‚è¿™æ ·ç­”æ¡ˆä¸ºæ‰€æœ‰æ­£æƒå€¼çš„å’Œå‡å»æœ€å°å‰²å³å¯ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int m, n, ans; struct edge &#123; int v, w; edge(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; struct Graph &#123; int S, T, cur[205], d[205]; vector&lt;edge> edges; vector&lt;int> G[205]; inline void addedge(int u, int v, int w) &#123; edges.emplace_back(edge(v, w)); G[u].emplace_back(edges.size() - 1); edges.emplace_back(edge(u, 0)); G[v].emplace_back(edges.size() - 1); &#125; bool bfs(void) &#123; memset(cur, 0, sizeof cur); memset(d, -1, sizeof d); queue&lt;int> q; q.push(S); d[S] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; d[e.v] = d[u] + 1; q.push(e.v); if (e.v == T) return true; &#125; &#125; &#125; return false; &#125; int dinic(int x, int res) &#123; if (x == T) return res; int flow = 0; for (int i = cur[x]; i &lt; G[x].size() &amp;&amp; res; ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; int c = min(res, e.w); if (d[e.v] == d[x] + 1 &amp;&amp; c) &#123; int k = dinic(e.v, c); flow += k; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; return flow; &#125; int maxFlow(int s, int t) &#123; S = s, T = t; int flow, maxflow = 0; while (bfs()) while (flow = dinic(S, 1e9)) maxflow += flow; return maxflow; &#125; &#125; G; int main(void) &#123; scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) &#123; int w, x; scanf(\"%d\", &amp;w); G.addedge(0, i, w); ans += w; while (scanf(\"%d\", &amp;x) == 1 &amp;&amp; x) G.addedge(i, x + m, 1e9); &#125; for (int i = 1, w; i &lt;= n; ++i) scanf(\"%d\", &amp;w), G.addedge(i + m, n + m + 1, w); printf(\"%d\\n\", ans - G.maxFlow(0, n + m + 1)); return 0; &#125; äºŒåˆ†å›¾ è®¾æ— å‘å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œè‹¥èƒ½å¤Ÿå°† VVV åˆ†æˆä¸¤ä¸ªç‚¹é›† V1,V2V_1,V_2V1â€‹,V2â€‹ æ»¡è¶³ V1âˆ©V2=âˆ…,V1âˆªV2=VV_1\\cap V_2=\\varnothing,V_1\\cup V_2=VV1â€‹âˆ©V2â€‹=âˆ…,V1â€‹âˆªV2â€‹=V ä¸” âˆ€(u,v)âˆˆE,uâˆˆV1,vâˆˆV2\\forall(u,v)\\in E,u\\in V_1,v\\in V_2âˆ€(u,v)âˆˆE,uâˆˆV1â€‹,vâˆˆV2â€‹ï¼ˆä¹Ÿå¯ä»¥åè¿‡æ¥ï¼‰ï¼Œè¿™æ · GGG æ˜¯ä¸€å¼ äºŒåˆ†å›¾ï¼ŒV1,V2V_1,V_2V1â€‹,V2â€‹ åˆ†åˆ«ç§°ä¸ºå·¦éƒ¨ç‚¹å’Œå³éƒ¨ç‚¹ã€‚ äºŒåˆ†å›¾çš„å……è¦æ¡ä»¶æ˜¯ä¸å­˜åœ¨å¥‡ç¯ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥ç»™äºŒåˆ†å›¾è¿›è¡Œé»‘ç™½æŸ“è‰²ã€‚ ä»æŸä¸ªç‚¹å¼€å§‹ DFSï¼Œéå†å½“å‰ç‚¹ uuu å’Œé‚»å±… vvvï¼Œå¦‚æœ vvv æœªè¢«è®¿é—®ï¼Œåˆ™ vvv çš„é¢œè‰²ä¸ uuu ç›¸åï¼›å¦‚æœè®¿é—®è¿‡ï¼Œè¯´æ˜å­˜åœ¨å¥‡ç¯ã€‚ äºŒåˆ†å›¾åŒ¹é… ç»™å®šäºŒåˆ†å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œè‹¥è¾¹é›† MâŠ†EM\\subseteq EMâŠ†E æ»¡è¶³ MMM ä¸­ä»»æ„ä¸¤æ¡è¾¹ä¸äº¤äºåŒä¸€ç«¯ç‚¹ï¼Œåˆ™ç§° MMM æ˜¯ GGG çš„ä¸€ç»„åŒ¹é…ï¼Œå…¶å¤§å°ä¸º âˆ£Mâˆ£|M|âˆ£Mâˆ£ã€‚ ç‰¹åˆ«çš„ï¼Œè‹¥ âˆ£V1âˆ£=âˆ£V2âˆ£,âˆ£Mâˆ£=âˆ£V1âˆ£|V_1|=|V_2|,|M|=|V_1|âˆ£V1â€‹âˆ£=âˆ£V2â€‹âˆ£,âˆ£Mâˆ£=âˆ£V1â€‹âˆ£ï¼Œåˆ™ç§° MMM ä¸ºå®Œç¾åŒ¹é…ã€‚ æœ€å¤§åŒ¹é… æˆ‘ä»¬å¸Œæœ›æ±‚å‡ºè¾¹é›† MMM çš„æœ€å¤§å¤§å°ã€‚ æ˜¾ç„¶ï¼Œæˆ‘ä»¬ä» SSS å‘ V1V_1V1â€‹ çš„æ‰€æœ‰ç‚¹è¿ä¸€æ¡ 111 çš„è¾¹ï¼ŒV2V_2V2â€‹ å‘ TTT è¿ä¸€æ¡ 111 çš„è¾¹ï¼Œæ ¹æ® EEE ä» V1V_1V1â€‹ å‘ V2V_2V2â€‹ è¿è¾¹ï¼Œè·‘æœ€å¤§æµå³å¯ã€‚åœ¨è¿™é‡Œ Dinic çš„æ—¶é—´å¤æ‚åº¦ä¸º O(mn)O(m\\sqrt{n})O(mnâ€‹)ã€‚ æœ€å¤§å¤šé‡åŒ¹é… å³èŠ‚ç‚¹ uuu ä¸èƒ½ä¸è¶…è¿‡ LuL_uLuâ€‹ æ¡è¾¹ç›¸è¿ï¼Œè¿™æ ·åªéœ€è¦å°†æ¯ä¸ªç‚¹ä¸æºç‚¹æˆ–æ±‡ç‚¹çš„å®¹é‡è®¾ä¸º LuL_uLuâ€‹ å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ­£ç¡®ã€‚ åŒˆç‰™åˆ©ç®—æ³• åŒˆç‰™åˆ©ç®—æ³•å¯ä»¥ä»¥ O(nm)O(nm)O(nm) çš„æ—¶é—´å¤æ‚åº¦è§£å†³äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…é—®é¢˜ã€‚ å·¥ä½œè¿‡ç¨‹å¦‚ä¸‹ï¼š åŠ å…¥ä¸€ä¸ªå·¦éƒ¨ç‚¹ uuuï¼Œç„¶åè®© uuu å»å°è¯•åŒ¹é…ã€‚ å¦‚æœ uuuï¼Œå·²ç»åŒ¹é…ï¼Œåˆ™å¢å¹¿å¤±è´¥ã€‚ éå† uuu èƒ½åˆ°è¾¾çš„æ‰€æœ‰å³éƒ¨ç‚¹ vvvï¼š yyy è¢«è®¿é—®è¿‡äº†ï¼Œé‚£ä¹ˆç›´æ¥å†è§ã€‚ yyy æ²¡è¢«åŒ¹é…ï¼Œè®© xxx åŒ¹é… yyyï¼Œå¢å¹¿æˆåŠŸã€‚ yyy è¢«åŒ¹é…ï¼Œè€ƒè™‘ yyy åŸæ¥åŒ¹é…çš„ xâ€²x&#x27;xâ€²ï¼Œå¦‚æœ xâ€²x&#x27;xâ€² è¿˜èƒ½å¤ŸæˆåŠŸåŒ¹é…ï¼Œé‚£ä¹ˆæ”¹ä¸ºè®© yyy åŒ¹é… xxxï¼Œå½¢æˆæ–°çš„å¢å¹¿è·¯ã€‚ å®é™…ä¸Šï¼Œå¦‚æœå½“å‰ç‚¹å¤±é…ï¼Œvis æ•°ç»„æ˜¯ä¸éœ€è¦æ¸…ç©ºçš„ï¼æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š int n, m, E, mch[505], vis[505]; vector&lt;int> G[505]; bool dfs(int x) &#123; if (vis[x]) return 0; vis[x] = 1; for (int y : G[x]) if (!mch[y] || dfs(mch[y])) return mch[y] = x, 1; return 0; &#125; int main(void) &#123; cin >> n >> m >> E; for(int i = 1; i &lt;= E; i++) &#123; int u, v; cin >> u >> v; G[u].push_back(v); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) if (dfs(i)) &#123; memset(vis, 0, sizeof(vis)); ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; äºŒåˆ†å›¾ç›¸å…³é—®é¢˜ äºŒåˆ†å›¾æœ‰ä¸€äº›å¸¸è§é—®é¢˜ã€‚æˆ‘ä»¬æ¥çœ‹ï¼š æœ€å°ç‚¹è¦†ç›–é›† ç»™å®šäºŒåˆ†å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œè‹¥ç‚¹é›† CâŠ†VC\\subseteq VCâŠ†V æ»¡è¶³å¯¹äºä»»æ„ (u,v)âˆˆE(u,v)\\in E(u,v)âˆˆE éƒ½æœ‰ uâˆˆCu\\in CuâˆˆC æˆ– vâˆˆCv\\in CvâˆˆCï¼Œåˆ™ç§° CCC æ˜¯ GGG çš„ç‚¹è¦†ç›–é›†ã€‚ è€ƒè™‘ä¸€ç»„ç‚¹è¦†ç›–é›†ï¼Œä¸å­˜åœ¨è¾¹ (u,v)âˆˆE(u,v)\\in E(u,v)âˆˆE ä½¿å¾— u,vu,vu,v åŒæ—¶ä¸å±äº CCCï¼Œè¿™æ˜¯é›†åˆåˆ’åˆ†æ¨¡å‹ï¼Ÿä½†æ˜¯æœ‰é—®é¢˜ï¼Œæˆ‘ä»¬è¦è®¾ç½®åœ¨åŒä¸€ä¸ªé›†åˆæ˜¯ä»£ä»·æ˜¯æ— ç©·çš„ï¼Œé›†åˆåˆ’åˆ†æ¨¡å‹æ²¡æœ‰è¿™æ ·çš„æ“ä½œã€‚ ä½†æ˜¯ GGG æ˜¯äºŒåˆ†å›¾ï¼Œä»»æ„ä¸€æ¡è¾¹è¿æ¥ä¸¤éƒ¨ç‚¹ï¼Œå› æ­¤è€ƒè™‘å°†ä¸€éƒ¨åˆ†ç‚¹çš„çŠ¶æ€å–åã€‚å³å·¦éƒ¨ç‚¹ä¸ SSS ä¸è¿é€šè¡¨ç¤ºå®ƒä¸å±äº CCCï¼Œä½†å³éƒ¨ç‚¹ä¸ SSS è¿é€šè¡¨ç¤ºå®ƒå±äº CCCã€‚è¿™æ ·é™åˆ¶å°±ä¼šå˜ä¸ºï¼Œå¦‚æœå·¦éƒ¨ç‚¹ uuu ä¸ SSS è¿é€šï¼Œu,vu,vu,v ä¹‹é—´æœ‰è¿è¾¹ï¼Œä½†æ˜¯å³éƒ¨ç‚¹ vvv ä¸ TTT è¿é€šï¼Œåˆ™ u,vu,vu,v åŒæ—¶ä¸å±äº CCCï¼Œä¸åˆæ³•ã€‚ æˆ‘ä»¬å°†ä¸¤éƒ¨ç‚¹ä¹‹é—´çš„è¿è¾¹å®¹é‡è®¾ä¸º +âˆ+\\infty+âˆï¼Œå¯¹è¯¥ç½‘ç»œæ±‚æœ€å¤§æµï¼Œå°±æ˜¯æœ€å°ç‚¹è¦†ç›–é›†å¤§å°ã€‚ç”±äºæ¯ä¸ªç‚¹æœ€å¤šæµå…¥æˆ–æµå‡º 111 çš„æµé‡ï¼Œå› æ­¤ä¸¤éƒ¨ç‚¹ä¹‹é—´çš„è¿è¾¹å®¹é‡å¯ä»¥è®¾ä¸º 111ï¼Œè¿™è¯æ˜äº†æœ€å°ç‚¹è¦†ç›–é›†å¤§å°ç­‰äºæœ€å¤§åŒ¹é…ã€‚ å®ƒå¯ä»¥æ±‚è§£è¿™æ ·çš„é—®é¢˜ï¼šå¯¹äºæ¯æ¡é™åˆ¶ limlimlim æ°æœ‰ä¸¤ç§æ–¹æ¡ˆ u,vu,vu,v èƒ½æ»¡è¶³ï¼Œæ±‚æœ€å°‘éœ€è¦é€‰æ‹©å¤šå°‘ç§æ–¹æ¡ˆæ»¡è¶³æ‰€æœ‰é™åˆ¶ã€‚ æœ€å¤§ç‹¬ç«‹é›† ç»™å®šäºŒåˆ†å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œè‹¥ç‚¹é›† IâŠ†VI\\subseteq VIâŠ†V æ»¡è¶³ä»»æ„ä¸¤ç‚¹ä¸ç›´æ¥ç›¸è¿ï¼Œåˆ™ç§° III æ˜¯ GGG çš„ç‹¬ç«‹é›†ã€‚äºŒåˆ†å›¾æœ€å¤§ç‹¬ç«‹é›†ç­‰äº VVV å‡å»æœ€å°ç‚¹è¦†ç›–é›†ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; struct edge &#123; int v, w; edge(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; struct Graph &#123; int s, t, cur[1005], d[1005]; vector&lt;edge> edges; vector&lt;int> G[1005]; inline void addedge(int u, int v, int w) &#123; edges.emplace_back(v, w); G[u].emplace_back(edges.size() - 1); edges.emplace_back(u, 0); G[v].emplace_back(edges.size() - 1); &#125; bool bfs(void) &#123; memset(cur, 0, sizeof cur); memset(d, -1, sizeof d); queue&lt;int> q; q.push(s); d[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; q.push(e.v); d[e.v] = d[u] + 1; if (e.v == t) return 1; &#125; &#125; &#125; return 0; &#125; int dinic(int x, int res) &#123; if (x == t) return res; int flow = 0; for (int i = cur[x]; i &lt; G[x].size(); ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; int c = min(res, e.w); if (d[e.v] == d[x] + 1 &amp;&amp; c) &#123; int k = dinic(e.v, c); flow += k; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; return flow; &#125; int maxflow(int S, int T) &#123; s = S, t = T; int maxflow = 0, flow = 0; while (bfs()) while (flow = dinic(s, 1e9)) maxflow += flow; return maxflow; &#125; &#125; G; int col[1005]; vector&lt;int> E[1005]; void dfs(int x) &#123; if (col[x]) G.addedge(0, x, 1); else G.addedge(x, n + 1, 1); for (int y : E[x]) &#123; if (col[y] == -1) col[y] = col[x] ^ 1, dfs(y); if (col[x]) G.addedge(x, y, 1); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); ++u; ++v; E[u].emplace_back(v); E[v].emplace_back(u); &#125; memset(col, -1, sizeof col); for (int i = 1; i &lt;= n; ++i) if (col[i] == -1) col[i] = 1, dfs(i); printf(\"%d\\n\", n - G.maxflow(0, n + 1)); return 0; &#125; Problemset æœ€é‡è¦çš„è¿˜æ˜¯é‚£äº›ç»å…¸æ¨¡å‹ï¼Œç„¶åè¿›è¡Œå¤§é‡é¢˜ç›®è®­ç»ƒã€‚ ç½‘ç»œæµ 24 é¢˜ æ²¡æœ‰å›ºå®šçš„é¡ºåºï¼ˆä½†åŸºæœ¬ä¸ŠæŒ‰ç…§éš¾åº¦æ’åºï¼‰ã€‚è™½ç„¶éå¸¸è€ï¼Œä½†æ˜¯å…¶ä¸­æœ‰äº›å»ºæ¨¡æ–¹å¼ç›¸å½“ç»å…¸ã€‚ è½¯ä»¶è¡¥ä¸é—®é¢˜ Portal. çŠ¶å‹æ¥è¡¨ç¤ºç‚¹å³å¯ï¼Œå‹æ ¹å°±ä¸æ˜¯ç½‘ç»œæµã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, d[1100005]; bool inq[1100005]; char s[25]; struct edge &#123; int u1, u2, v1, v2, t; &#125; e[105]; queue&lt;int> q; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%s\", &amp;e[i].t, s); for (int j = 0; j &lt; n; ++j) &#123; int t = (s[j] == '+' ? 1 : (s[j] == '-' ? 2 : 0)); if (t == 1) e[i].u1 |= (1 &lt;&lt; j); if (t == 2) e[i].u2 |= (1 &lt;&lt; j); &#125; scanf(\"%s\", s); for (int j = 0; j &lt; n; ++j) &#123; int t = (s[j] == '+' ? 2 : (s[j] == '-' ? 1 : 0)); if (t == 1) e[i].v1 |= (1 &lt;&lt; j); if (t == 2) e[i].v2 |= (1 &lt;&lt; j); &#125; &#125; q.push((1 &lt;&lt; n) - 1); inq[(1 &lt;&lt; n) - 1] = true; memset(d, 0x3f, sizeof(d)); d[(1 &lt;&lt; n) - 1] = 0; while (!q.empty()) &#123; int x = q.front(); q.pop(); inq[x] = false; for (int i = 1; i &lt;= m; ++i) if ((x &amp; e[i].u1) == e[i].u1 &amp;&amp; (x &amp; e[i].u2) == 0) &#123; int y = (x | e[i].v1 | e[i].v2) ^ e[i].v1; if (d[y] > d[x] + e[i].t) &#123; d[y] = d[x] + e[i].t; if (!inq[y]) q.push(y), inq[y] = true; &#125; &#125; &#125; if (d[0] == 0x3f3f3f3f) puts(\"0\"); else printf(\"%d\\n\", d[0]); return 0; &#125; å­¤å²›è¥æ•‘é—®é¢˜ å°†é’¥åŒ™çŠ¶å‹å bfs æœ€çŸ­è·¯å³å¯ï¼Œå‹æ ¹ä¸æ˜¯ç½‘ç»œæµã€‚ Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; const int DX[4] = &#123;-1, 0, 0, 1&#125;, DY[4] = &#123;0, -1, 1, 0&#125;; int n, m, p, k, S; int key[15][15], e[15][15][15][15], d[15][15][2050]; struct Node &#123; int x, y, msk, d; &#125;; int main(void) &#123; memset(e, -1, sizeof e); scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;p, &amp;k); for (int i = 1; i &lt;= k; ++i) &#123; int a, b, c, d, x; scanf(\"%d%d%d%d%d\", &amp;a, &amp;b, &amp;c, &amp;d, &amp;x); --a; --b; --c; --d; e[a][b][c][d] = e[c][d][a][b] = x; &#125; cin >> S; for (int i = 1; i &lt;= S; ++i) &#123; int a, b, x; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;x); key[a - 1][b - 1] |= 1 &lt;&lt; x - 1; &#125; queue&lt;Node> q; memset(d, 0x3f, sizeof(d)); d[0][0][key[0][0]] = 0; q.push(&#123;0, 0, key[0][0], 0&#125;); while (!q.empty()) &#123; Node u = q.front(); q.pop(); if (u.x == n - 1 &amp;&amp; u.y == m - 1) return printf(\"%d\\n\", u.d), 0; for (int dir = 0; dir &lt; 4; ++dir) &#123; int x = u.x + DX[dir], y = u.y + DY[dir]; if (x &lt; 0 || y &lt; 0 || x >= n || y >= m) continue; int v = e[u.x][u.y][x][y], msk = u.msk | key[x][y]; if (d[x][y][msk] &lt; INF) continue; if (!v || v > 0 &amp;&amp; !(u.msk >> v - 1 &amp; 1)) continue; q.push(&#123;x, y, msk, d[x][y][msk] = u.d + 1&#125;); &#125; &#125; puts(\"-1\"); return 0; &#125; è¯•é¢˜åº“é—®é¢˜ Portal. å°†è¯•é¢˜çœ‹ä½œå·¦éƒ¨ç‚¹ï¼Œç±»å‹çœ‹ä½œå³éƒ¨ç‚¹ï¼Œæ¯ä¸ªè¯•é¢˜å‘å¯¹åº”çš„ç±»å‹è¿è¾¹ã€‚æºç‚¹å‘è¯•é¢˜è¿è¾¹ï¼Œç±»å‹å‘æ±‡ç‚¹è¿è¾¹ã€‚ æœ‰è§£ä»…å½“æœ€å¤§æµä¸º mmmï¼Œæ–¹æ¡ˆçš„è¾“å‡ºå¯ä»¥æ ¹æ®å“ªäº›è¾¹æµæ»¡æ¥åˆ¤æ–­ã€‚ æŸ¥çœ‹ä»£ç  int k, n, m; int main(void) &#123; scanf(\"%d%d\", &amp;k, &amp;n); int T = n + k + 1; for (int i = 1, v; i &lt;= k; ++i) &#123; scanf(\"%d\", &amp;v); m += v; g.addedge(n + i, T, v); &#125; for (int i = 1; i &lt;= n; ++i) &#123; g.addedge(0, i, 1); int p, k; scanf(\"%d\", &amp;p); while (p--) scanf(\"%d\", &amp;k), g.addedge(i, n + k, 1); &#125; if (g.maxflow(0, T) != m) return puts(\"No Solution!\"), 0; for (int i = 1; i &lt;= k; ++i) &#123; printf(\"%d: \", i); for (int j = 0; j &lt; g.G[n + i].size(); ++j) &#123; int it = g.edges[g.G[n + i][j]].v; if (it &lt;= n &amp;&amp; g.edges[g.G[n + i][j]].w) printf(\"%d \", it); &#125; putchar('\\n'); &#125; return 0; &#125; é£è¡Œå‘˜é…å¯¹æ–¹æ¡ˆé—®é¢˜ Portal. äºŒåˆ†å›¾æœ€å¤§åŒ¹é…æ¨¡æ¿ã€‚ æŸ¥çœ‹ä»£ç  int n, m; int main(void) &#123; scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) G.addedge(0, i, 1); for (int i = m + 1; i &lt;= n; ++i) G.addedge(i, n + 1, 1); while (1) &#123; int x, y; cin >> x >> y; if (x == -1) break; G.addedge(x, y, 1); &#125; printf(\"%d\\n\", G.maxFlow(0, n + 1)); G.print(); return 0; &#125; åœ†æ¡Œé—®é¢˜ Portal. äºŒåˆ†å›¾æœ€å¤§å¤šé‡åŒ¹é…æ¨¡æ¿ã€‚ æŸ¥çœ‹ä»£ç  int m, n, s; int main(void) &#123; scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1, r; i &lt;= m; ++i) scanf(\"%d\", &amp;r), G.addedge(0, i, r), s += r; for (int i = 1, c; i &lt;= n; ++i) scanf(\"%d\", &amp;c), G.addedge(m + i, n + m + 1, c); for (int u = 1; u &lt;= m; ++u) for (int v = m + 1; v &lt;= m + n; ++v) G.addedge(u, v, 1); if (G.maxFlow(0, n + m + 1) != s) return puts(\"0\"), 0; G.print(); return 0; &#125; å¤ªç©ºé£è¡Œè®¡åˆ’é—®é¢˜ Portal. å°†ä»ªå™¨å’Œå®éªŒæŠ½è±¡æˆç‚¹ï¼Œå°±æ˜¯æœ€å¤§æƒé—­åˆå­å›¾æ¨¡æ¿ã€‚ æŸ¥çœ‹ä»£ç  int m, n; int main(void) &#123; cin >> m >> n; int t = m + n + 1, ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; int w, x; cin >> w; G.addedge(0, i, w); ans += w; string s; getline(cin, s); stringstream ss(s); while (ss >> x) G.addedge(i, x + m, 1e9); &#125; for (int i = 1, x; i &lt;= n; ++i) cin >> x, G.addedge(i + m, t, x); int flow = G.maxFlow(0, t); for (int i = 1; i &lt;= m; ++i) if (G.d[i] != -1) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\\n'; for (int i = 1; i &lt;= n; ++i) if (G.d[i + m] != -1) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\\n' &lt;&lt; ans - flow &lt;&lt; \"\\n\"; return 0; &#125; éª‘å£«å…±å­˜é—®é¢˜ Portal. å°†æ£‹ç›˜ä¸Šçš„ç‚¹åˆ’åˆ†ä¸ºå·¦éƒ¨ç‚¹å’Œå³éƒ¨ç‚¹ï¼Œä½¿å¾—éª‘å£«çš„ä½ç½®å’Œå…¶èƒ½èµ°åˆ°çš„ä½ç½®åœ¨ä¸åŒçš„ç‚¹éƒ¨ã€‚è¿™æ ·å°±æˆäº†äºŒåˆ†å›¾æœ€å¤§ç‹¬ç«‹é›†çš„æ¨¡æ¿ã€‚ æŸ¥çœ‹ä»£ç  const int DX[] = &#123;-2, -2, -1, -1, 1, 1, 2, 2&#125;; const int DY[] = &#123;-1, 1, -2, 2, -2, 2, -1, 1&#125;; int n, m; bool a[205][205]; int f(int i, int j) &#123; return (i - 1) * n + j; &#125; int main(void) &#123; cin >> n >> m; for (int i = 1, u, v; i &lt;= m; ++i) cin >> u >> v, a[u][v] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (!a[i][j]) &#123; if (i + j &amp; 1) &#123; G.addedge(0, f(i, j), 1); for (int k = 0; k &lt; 8; ++k) &#123; int x = i + DX[k], y = j + DY[k]; if (x > 0 &amp;&amp; y > 0 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n &amp;&amp; !a[x][y]) G.addedge(f(i, j), f(x, y), 1); &#125; &#125; else G.addedge(f(i, j), n * n + 1, 1); &#125; cout &lt;&lt; n * n - m - G.maxFlow(0, n * n + 1) &lt;&lt; \"\\n\"; return 0; &#125; æœ€é•¿ä¸ä¸‹é™å­åºåˆ—é—®é¢˜ Portal. é€šè¿‡ DP æ¥æ±‚è§£ç­”æ¡ˆï¼Œæ‹†ç‚¹é™åˆ¶ä¸€ä¸ªç‚¹çš„ä½¿ç”¨æ¬¡æ•°ã€‚ æŸ¥çœ‹ä»£ç  int n; int a[505], f[505]; int in(int x) &#123; return x * 2 - 1; &#125; int out(int x) &#123; return x * 2; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; i; ++j) if (a[i] >= a[j]) f[i] = max(f[i], f[j] + 1); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); if (ans == 1) return !printf(\"%d\\n%d\\n\", n, n); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) if (a[i] >= a[j] &amp;&amp; f[i] == f[j] + 1) G.addedge(out(j), in(i), 1); for (int i = 1; i &lt;= n; ++i) &#123; if (f[i] == 1) G.addedge(0, in(i), 1e9); if (f[i] == ans) G.addedge(out(i), n * 2 + 1, 1e9); &#125; E = G; for (int i = 1; i &lt;= n; ++i) &#123; G.addedge(in(i), out(i), 1); E.addedge(in(i), out(i), i == 1 || i == n ? n : 1); &#125; printf(\"%d\\n%d\\n\", G.maxFlow(0, n * 2 + 1), E.maxFlow(0, n * 2 + 1)); return 0; &#125; æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜ Portal. å°†ç‚¹æ‹†æˆå·¦ç‚¹å’Œå³ç‚¹ï¼Œè¿›è¡ŒäºŒåˆ†å›¾æœ€å¤§åŒ¹é…ã€‚æ¯æ¬¡å¤šæµä¸Šä¸€ä¸ªï¼Œå°±è¯´æ˜åˆæœ‰ä¸€å¯¹ç‚¹è¿åœ¨äº†ä¸€èµ·ã€‚æœ€å DFS è¾“å‡ºç­”æ¡ˆå³å¯ã€‚ æŸ¥çœ‹ä»£ç  int in[155], to[155]; void dfs(int x) &#123; printf(\"%d \", x); if (to[x]) dfs(to[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) G.addedge(0, i, 1); for (int i = 1; i &lt;= n; ++i) G.addedge(i + n, n * 2 + 1, 1); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G.addedge(u, v + n, 1); &#125; int ans = G.maxFlow(0, n * 2 + 1); for (int u = 1; u &lt;= n; ++u) for (int i : G.G[u]) &#123; int v = G.edges[i].v, w = G.edges[i].w; if (v > n &amp;&amp; w == 0) in[to[u] = v - n] = 1; &#125; for (int i = 1; i &lt;= n; ++i) if (!in[i]) dfs(i), putchar('\\n'); return !printf(\"%d\\n\", n - ans); &#125; é­”æœ¯çƒé—®é¢˜ Portal. æšä¸¾æ•°ï¼Œç„¶åè¿å¯ä»¥æ”¾åœ¨ä¸€èµ·çš„æ•°çš„è¾¹ï¼Œå‘ç°å°±æ˜¯æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜ã€‚ æŸ¥çœ‹ä»£ç  int in[100005], to[100005]; void dfs(int x) &#123; printf(\"%d \", x); if (to[x]) dfs(to[x]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); int t = 100001; for (int i = 1, flow = 0; ; ++i) &#123; G.addedge(0, i * 2 - 1, 1); G.addedge(i * 2, t, 1); for (int j = 1; j &lt; i; ++j) &#123; int d = sqrt(i + j); if (d * d == i + j) G.addedge(j * 2 - 1, i * 2, 1); &#125; flow += G.maxFlow(0, t); if (i - flow > n) &#123; printf(\"%d\\n\", i - 1); for (int u = 1; u &lt; i; ++u) for (int j : G.G[u * 2 - 1]) &#123; int v = G.edges[j].v / 2, w = G.edges[j].w; if (v &amp;&amp; v &lt; i &amp;&amp; w == 0) in[to[u] = v] = 1; &#125; for (int j = 1; j &lt; i; ++j) if (!in[j]) dfs(j), putchar('\\n'); return 0; &#125; &#125; return 0; &#125; ç®€å•ç½‘ç»œæµ æ²¡æœ‰ä»€ä¹ˆè¶£å‘³æ€§ã€‚ [USACO05NOV] Asteroids G Portal. å°†è¡ŒæŠ½è±¡æˆç¬¬ä¸€ä¸ªæ¡ä»¶ï¼Œåˆ—æŠ½è±¡æˆç¬¬äºŒä¸ªæ¡ä»¶ï¼Œå°±æ˜¯äºŒåˆ†å›¾çš„æœ€å°ç‚¹è¦†ç›–é›†ã€‚ æŸ¥çœ‹ä»£ç  int n, k; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) G.addedge(0, i, 1), G.addedge(i + n, n * 2 + 1, 1); for (int i = 1; i &lt;= k; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G.addedge(x, y + n, 1); &#125; printf(\"%d\\n\", G.maxflow(0, n * 2 + 1)); return 0; &#125; [THUPC2022 åˆèµ›] åˆ†ç»„ä½œä¸š Portal. è€ƒè™‘é›†åˆåˆ’åˆ†æ¨¡å‹ã€‚ å”¯ä¸€çŠ¯éš¾çš„æ˜¯è¿™ä¸ªå–œæ¬¢å…³ç³»ï¼Œè€ƒè™‘å°†æ¯ä¸ªç»„ä¹Ÿå†å»ºä¸ªç‚¹ã€‚å¦‚æœç»„ iii åœ¨æœ€ç»ˆçš„æ®‹é‡ç½‘ç»œä¸Šä¸ SSS ç›¸è¿åˆ™è¡¨ç¤ºåˆä½œï¼Œä¸ TTT ç›¸è¿åˆ™è¡¨ç¤ºä¸åˆä½œã€‚ä»»ä½•ä¸€ä¸ªäººä¸åŒæ„è¿™ä¸ªç»„å°±ä¸åˆä½œï¼Œå› æ­¤ç»„å‘å®ƒçš„ç»„å‘˜è¿ +âˆ+\\infty+âˆ çš„è¾¹ï¼Œè¡¨ç¤ºå¦‚æœ SSS ä¸ç»„è¿™ä¸ªç‚¹è¿é€šï¼Œè¯´æ˜åˆä½œï¼Œå°±åªèƒ½æ–­æ‰ç»„å‘˜ä¸ TTT çš„è¿æ¥ã€‚ å°† BBB å‘ AAA å¯¹åº”çš„ç»„è¿ aia_iaiâ€‹ çš„è¾¹ï¼Œè¿™æ ·å¦‚æœ BBB åŒæ„äº†ï¼ˆå®ƒè¿å‘äº† SSSï¼‰ï¼ŒAAA ç»„æ²¡æœ‰åˆä½œï¼ˆè¿å‘äº† TTTï¼‰ï¼Œåˆ™è¦å‰²æ‰ aia_iaiâ€‹ã€‚ç±»ä¼¼åœ°ï¼ŒBBB çš„ç»„å‘ AAA è¿ bib_ibiâ€‹ã€‚ æŸ¥çœ‹ä»£ç  int n, m; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n * 2; ++i) &#123; int c, d, e; scanf(\"%d%d%d\", &amp;c, &amp;d, &amp;e); G.addedge(0, i, d); G.addedge(i, n * 3 + 1, c); G.addedge(i, i % 2 == 0 ? i - 1 : i + 1, e); G.addedge(n * 2 + (i + 1) / 2, i, 1e18); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int A, B, a, b; scanf(\"%d%d%d%d\", &amp;A, &amp;B, &amp;a, &amp;b); G.addedge(B, n * 2 + (A + 1) / 2, a); G.addedge(n * 2 + (B + 1) / 2, A, b); &#125; printf(\"%lld\\n\", G.maxFlow(0, n * 3 + 1)); return 0; &#125; [Luogu P1402] é…’åº—ä¹‹ç‹ Portal. å…¶å®æ˜¯ä¸€ä¸ªä¸‰åˆ†å›¾åŒ¹é…çš„ç»“æ„ï¼Œå°†äººæ‹†æˆä¸¤ä¸ªç‚¹æ”¾åœ¨ä¸­é—´å³å¯ã€‚ æŸ¥çœ‹ä»£ç  int n, p, q; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> p >> q; int t = n + p + q + n + 1; for (int i = 1; i &lt;= p; ++i) G.addedge(0, i, 1); for (int i = 1; i &lt;= n; ++i) G.addedge(p + i, p + n + i, 1); for (int i = 1; i &lt;= q; ++i) G.addedge(p + n * 2 + i, t, 1); for (int i = 1, x; i &lt;= n; ++i) for (int j = 1; j &lt;= p; ++j) &#123; cin >> x; if (x) G.addedge(j, p + i, 1); &#125; for (int i = 1, x; i &lt;= n; ++i) for (int j = 1; j &lt;= q; ++j) &#123; cin >> x; if (x) G.addedge(p + n + i, p + n * 2 + j, 1); &#125; cout &lt;&lt; G.maxFlow(0, t) &lt;&lt; \"\\n\"; return 0; &#125; [Luogu P4313] æ–‡ç†åˆ†ç§‘ Portal. è€ƒè™‘ç”¨å…¨éƒ¨ä»·å€¼å‡å»æœ€å°çš„éœ€è¦å‰²æ‰çš„ä»·å€¼ã€‚å‰é¢ä¸¤ç§æ˜¯å®¹æ˜“å¤„ç†çš„ï¼Œåé¢ä¸¤ç§åªéœ€è¦å„å»ºç«‹ä¸€ä¸ªè™šç‚¹ï¼Œç„¶åä¸ä¸€ä¸ªç‚¹å…³è”çš„è™šç‚¹å‘è¿™ä¸ªç‚¹è¿ +âˆ+\\infty+âˆ çš„è¾¹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  int cal(int x, int y, int t) &#123; return (x - 1) * m + y + n * m * t; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int ans = 0, s = 0, t = n * m * 3 + 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;a[i][j]); ans += a[i][j]; G.addedge(s, cal(i, j, 0), a[i][j]); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;b[i][j]); ans += b[i][j]; G.addedge(cal(i, j, 0), t, b[i][j]); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;c[i][j]); ans += c[i][j]; G.addedge(s, cal(i, j, 1), c[i][j]); G.addedge(cal(i, j, 1), cal(i, j, 0), 1e9); if (i > 1) G.addedge(cal(i - 1, j, 1), cal(i, j, 0), 1e9); if (i &lt; n) G.addedge(cal(i + 1, j, 1), cal(i, j, 0), 1e9); if (j > 1) G.addedge(cal(i, j - 1, 1), cal(i, j, 0), 1e9); if (j &lt; m) G.addedge(cal(i, j + 1, 1), cal(i, j, 0), 1e9); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;d[i][j]); ans += d[i][j]; G.addedge(cal(i, j, 2), t, d[i][j]); G.addedge(cal(i, j, 0), cal(i, j, 2), 1e9); if (i > 1) G.addedge(cal(i - 1, j, 0), cal(i, j, 2), 1e9); if (i &lt; n) G.addedge(cal(i + 1, j, 0), cal(i, j, 2), 1e9); if (j > 1) G.addedge(cal(i, j - 1, 0), cal(i, j, 2), 1e9); if (j &lt; m) G.addedge(cal(i, j + 1, 0), cal(i, j, 2), 1e9); &#125; return !printf(\"%d\\n\", ans - G.maxFlow(s, t)); &#125; äºŒåˆ†å›¾ ä¸€äº›é¢˜ã€‚ ã€ŒWdoi-6ã€æœ€æ¾„æ¾ˆçš„ç©ºä¸æµ· Portal. å¿…è¦æ¡ä»¶æ˜¯æœ‰ä¸€ä¸ªèŠ‚ç‚¹å…¥åº¦ä¸º 111ï¼Œä»è¿™ä¸ªèŠ‚ç‚¹å¼€å§‹è·‘ bfs çœ‹æ˜¯å¦å­˜åœ¨å®Œç¾åŒ¹é…ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, in[2000005]; bool del[2000005]; vector&lt;int> G[2000005]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n * 2; ++i) G[i].clear(), in[i] = del[i] = 0; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); v += n; ++in[u]; ++in[v]; G[u].emplace_back(v); G[v].emplace_back(u); &#125; queue&lt;int> q; int cnt = 0; for (int i = 1; i &lt;= n * 2; ++i) if (in[i] == 1) q.push(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (del[u] || in[u] != 1) continue; del[u] = 1; ++cnt; int buf = 0; while (del[G[u][buf]]) ++buf; del[G[u][buf]] = 1; ++cnt; for (int v : G[G[u][buf]]) if (!del[v] &amp;&amp; (--in[v]) == 1) q.push(v); &#125; if (cnt == n * 2) puts(\"Renko\"); else puts(\"Merry\"); &#125; return 0; &#125; [CF1139E] Maximize Mex Portal. è€ƒè™‘é™æ€çš„æƒ…å†µæ€ä¹ˆåšã€‚å°†èƒ½åŠ›å€¼å®šä¹‰ä¸ºå·¦éƒ¨ç‚¹ï¼Œå­¦ç”Ÿå®šä¹‰ä¸ºå³éƒ¨ç‚¹ï¼Œåˆå§‹ä»¤ç­”æ¡ˆä¸º 000ï¼Œç„¶åçœ‹ 111 æ˜¯å¦èƒ½å¤Ÿå¢å¹¿ï¼Œèƒ½å¤Ÿå¢å¹¿å°±å†çœ‹ 222ã€‚ å€’ç€è€ƒè™‘è¿™ä¸ªè¿‡ç¨‹ï¼Œå°†åˆ è¾¹æ”¹ä¸ºåŠ è¾¹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  int n, m, q; int a[5005], c[5005], d[5005], ans[5005]; bool v[5005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) G.addedge(n + i, n + m + 1, 1); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", c + i); scanf(\"%d\", &amp;q); for (int i = 1; i &lt;= q; ++i) scanf(\"%d\", d + i), v[d[i]] = 1; for (int i = 1; i &lt;= n; ++i) if (!v[i]) if (a[i] &lt; n) G.addedge(a[i] + 1, n + c[i], 1); G.addedge(0, 1, 1); for (int i = q, cur = 0; i >= 1; --i) &#123; while (G.maxFlow(0, n + m + 1)) if (++cur &lt; n) G.addedge(0, cur + 1, 1); ans[i] = cur; if (a[d[i]] &lt; n) G.addedge(a[d[i]] + 1, n + c[d[i]], 1); &#125; for (int i = 1; i &lt;= q; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; [CF1592F] Alice and Recoloring F1ï¼ŒF2ã€‚ ä¸éš¾å‘ç° 2,32,32,3 æ“ä½œæ˜¯å°ä¸‘ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥ä½¿ç”¨ 111 æ“ä½œæ¥ä»£æ›¿ã€‚ å…ˆè€ƒè™‘ F1ã€‚å°† W çœ‹æˆ 000ï¼ŒB çœ‹æˆ 111ï¼Œç„¶åè€ƒè™‘ä»€ä¹ˆä¸œè¥¿è¦è¢«ç¿»è½¬ã€‚å¦‚æœå®ƒè‡ªå·±æ˜¯ 111 éœ€è¦ç¿»å—ï¼Ÿä¸ä¸€å®šï¼(i,j)(i,j)(i,j) æ˜¯ 111 éœ€è¦ç¿»ï¼Œå½“ä¸”ä»…å½“ (i+1,j),(i,j+1),(i+1,j+1)(i+1,j),(i,j+1),(i+1,j+1)(i+1,j),(i,j+1),(i+1,j+1) å½“ä¸­æœ‰ 000 æˆ– 222 ä¸ªæ˜¯ 111ã€‚å¦‚æœå®ƒè‡ªå·±ä¸æ˜¯ 111 å°±ä¸éœ€è¦ç¿»å—ï¼Ÿä¹Ÿä¸æ˜¯ï¼ŒåŒæ ·æ˜¯é‚£ä¸‰ä¸ªä½ç½®ï¼Œå¦‚æœå½“ä¸­æœ‰ 1,31,31,3 ä¸ª 111 å°±éœ€è¦ç¿»ã€‚ ä»¤ ai,j=si,jâŠ•si,j+1âŠ•si+1,jâŠ•si+1,j+1a_{i,j}=s_{i,j}\\oplus s_{i,j+1}\\oplus s_{i+1,j}\\oplus s_{i+1,j+1}ai,jâ€‹=si,jâ€‹âŠ•si,j+1â€‹âŠ•si+1,jâ€‹âŠ•si+1,j+1â€‹ï¼Œåªè€ƒè™‘ 111 æ“ä½œï¼Œç­”æ¡ˆå°±æ˜¯ âˆ‘ai,j\\sum a_{i,j}âˆ‘ai,jâ€‹ã€‚ 444 å¹²äº†ä»€ä¹ˆï¼Ÿç›¸å½“äºç¿»äº† ai,j,ai,m,an,j,an,ma_{i,j},a_{i,m},a_{n,j},a_{n,m}ai,jâ€‹,ai,mâ€‹,an,jâ€‹,an,mâ€‹ï¼Œæ˜¾ç„¶ï¼Œå®ƒåªèƒ½ä½¿ç”¨ 111 æ¬¡ã€‚ä»£ç ã€‚ å†è€ƒè™‘ F2ã€‚æˆ‘ä»¬è€ƒè™‘åœ¨åˆšæ‰çš„åŸºç¡€ä¸ŠåŠ ä¸€äº›é™åˆ¶ã€‚ é¦–å…ˆï¼ŒåŸºäºä¹‹å‰è¯´è¿‡çš„ 444 å¹²çš„äº‹æƒ…ï¼Œæˆ‘ä»¬åªä¼šæ“ä½œ ai,j,ai,m,an,ja_{i,j},a_{i,m},a_{n,j}ai,jâ€‹,ai,mâ€‹,an,jâ€‹ å‡ä¸º 111 çš„ï¼Œå¦åˆ™ä¸å¦‚æ¥ 111 æ“ä½œã€‚ç„¶åè¿™æ ·å°±å‘ç°äº†ä¸€ä¸ªäº‹æƒ…ï¼Œä¸€æ¬¡æ“ä½œ ai,ja_{i,j}ai,jâ€‹ ä¹‹åä¼šå°† ai,ma_{i,m}ai,mâ€‹ å’Œ an,ja_{n,j}an,jâ€‹ åºŸæ‰ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒåŒè¡ŒåŒåˆ—æœ€å¤šè¿›è¡Œä¸€æ¬¡ 444 æ“ä½œã€‚ è¿™çœ‹ä¸Šå»å¾ˆåƒä¸€ä¸ªäºŒåˆ†å›¾åŒ¹é…é—®é¢˜äº†ï¼å°†æ¯è¡ŒæŠ½è±¡ä¸ºå·¦éƒ¨ç‚¹ï¼Œæ¯åˆ—æŠ½è±¡ä¸ºå³éƒ¨ç‚¹ï¼ˆå‰ææ˜¯ 111ï¼‰ï¼Œç„¶åæ ¹æ® ai,ja_{i,j}ai,jâ€‹ è¿›è¡Œè¿è¾¹ã€‚ æŸ¥çœ‹ä»£ç  int n, m, a[505][505]; char s[505][505]; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; int ans = 0; for (int i = 1; i &lt;= n; ++i) cin >> s[i] + 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = (s[i][j] != 'W'); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] ^= a[i + 1][j] ^ a[i][j + 1] ^ a[i + 1][j + 1]; for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt; m; ++j) if (a[i][j] &amp;&amp; a[i][m] &amp;&amp; a[n][j]) G.addedge(i, n + j, 1); for (int i = 1; i &lt; n; ++i) if (a[i][m]) G.addedge(0, i, 1); for (int i = 1; i &lt; m; ++i) if (a[n][i]) G.addedge(i + n, n + m + 1, 1); int flow = G.maxFlow(0, n + m + 1); a[n][m] ^= (flow &amp; 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) ans += a[i][j]; return cout &lt;&lt; ans - flow &lt;&lt; \"\\n\", 0; &#125; ç»¼åˆåº”ç”¨ ä¸€äº›æ¯”è¾ƒå¥½ç©çš„é¢˜ã€‚ [CF1728F] Fishermen Portal. æˆ‘ä»¬éœ€è¦æ„é€ ä¸€ä¸ª aiâˆ£bia_i\\mid b_iaiâ€‹âˆ£biâ€‹ ä¸” bib_ibiâ€‹ äº’ä¸ç›¸åŒï¼Œè¿™æ ·è¿™ä¸ª bbb å°±ä¸€å®šæ˜¯æ»¡è¶³æ¡ä»¶çš„ã€‚ æ„é€ æ‰€æœ‰çš„ kÃ—ai,kâˆˆ[1,n]k\\times a_i,k\\in [1,n]kÃ—aiâ€‹,kâˆˆ[1,n]ï¼Œæˆ‘ä»¬ç”¨è¿™äº›æ•°æ¥åŒ¹é… aia_iaiâ€‹ã€‚è¿™æ ·ç‚¹æ•°å’Œè¾¹æ•°éƒ½æ˜¯ O(n2)O(n^2)O(n2) çš„ã€‚ è€ƒè™‘åŒˆç‰™åˆ©ç®—æ³•ï¼Œåœ¨æ‰¾åˆ°åŒ¹é…æ—¶æ¸…ç©º vis æ•°ç»„ï¼Œç”±äºåªæœ‰ O(n)O(n)O(n) ä¸ªåŒ¹é…ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ O(n3)O(n^3)O(n3)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, a[1005], b[1000005]; int buc[1000005], mch[1000005]; bool vis[1000005]; vector&lt;int> G[1000005]; bool dfs(int x) &#123; if (vis[x]) return 0; vis[x] = 1; for (int y : G[x]) if (!mch[y] || dfs(mch[y])) return mch[y] = x, 1; return 0; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); for (int j = 1; j &lt;= n; ++j) b[++m] = a[i] * j; &#125; sort(b + 1, b + m + 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; int p = lower_bound(b + 1, b + m + 1, a[i] * j) - b; G[p].emplace_back(i); &#125; i64 ans = 0; for (int i = 1; i &lt;= m; ++i) if (dfs(i)) ans += b[i], memset(vis, 0, sizeof vis); return !printf(\"%lld\\n\", ans); &#125; [WC2007] å‰ªåˆ€çŸ³å¤´å¸ƒ Portal. å¦‚æœä¸€ä¸ªä¸‰å…ƒç»„ä¸æ˜¯ä¸‰å…ƒç¯ï¼Œé‚£ä¹ˆæœ‰ä¸€ä¸ªç‚¹çš„å‡ºåº¦ä¸º 222ã€‚å‡å®šä¸€ä¸ªç‚¹çš„å‡ºåº¦ä¸º dddï¼Œé‚£ä¹ˆå®ƒä¼šä½¿å¾—ä¸‰å…ƒç¯å‡å°‘ d(dâˆ’1)2\\frac{d(d-1)}{2}2d(dâˆ’1)â€‹ï¼Œé‚£ä¹ˆæœ€ç»ˆç­”æ¡ˆä¸ºï¼š (n3)âˆ’âˆ‘i=1nd(dâˆ’1)2\\binom n 3 - \\sum_{i=1}^n \\frac{d(d-1)}{2} (3nâ€‹)âˆ’i=1âˆ‘nâ€‹2d(dâˆ’1)â€‹ è€ƒè™‘æœ€å°è´¹ç”¨æœ€å¤§æµã€‚æ¯ä¸ªäººå‘æ±‡ç‚¹è¿å®¹é‡ä¸º nnn çš„è¾¹ï¼Œæºç‚¹å‘æ¯ä¸ªä¸ç¡®å®šçš„è¾¹è¿è¾¹ã€è¾¹å‘ä¸¤ä¸ªäººè¿è¾¹ï¼Œå®¹é‡å‡ä¸º 111ã€‚ ä¸€ä¸ªäººçš„è´¡çŒ®å¯ä»¥çœ‹æˆ 0+1+â‹¯+diâˆ’10+1+\\cdots+d_i-10+1+â‹¯+diâ€‹âˆ’1ï¼Œè¿™æ˜¯ç­‰å·®æ•°åˆ—çš„è´¹ç”¨ã€‚å¥—è·¯åœ°ï¼Œè€ƒè™‘æ‹†ç‚¹ï¼Œæ‹†æˆ nnn ä¸ªï¼Œè´¹ç”¨ä¾æ¬¡ä¸º 0,1,â‹¯ ,nâˆ’10,1,\\cdots,n-10,1,â‹¯,nâˆ’1 å³å¯ã€‚ä»£ç ã€‚ è™½ç„¶åœ¨ã€Šç®—æ³•å¯¼è®ºã€‹ä¸­å¹¶æ²¡æœ‰è¿™ä¸ªå®šä¹‰ï¼Œä½†æ˜¯è¿™æ ·å¯ä»¥ç®€å•çš„æ”¯æŒåæ‚”ã€‚ â†©ï¸","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"å›¾è®º","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/å›¾è®º","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ç½‘ç»œæµ","slug":"ç½‘ç»œæµ","permalink":"https://james1badcreeper.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"éä¼ ç»Ÿé¢˜ç›®ä¸ç®—æ³•ç»¼åˆé¢˜","slug":"notes/æ‚é¡¹/special","date":"2022-12-07T00:00:00.000Z","updated":"2022-12-07T00:00:00.000Z","comments":true,"path":"26972790/","link":"","permalink":"https://james1badcreeper.github.io/26972790/","excerpt":"å¸¸è§„çš„ä¼ ç»Ÿé¢˜ç›®é‡‡ç”¨é»‘ç®±è¯„æµ‹ï¼Œè®©é€‰æ‰‹ç¨‹åºè¯»å…¥è¾“å…¥æ•°æ®ï¼Œå°†é€‰æ‰‹è¾“å‡ºä¸è¾“å‡ºæ•°æ®å…¨æ–‡æ¯”è¾ƒæˆ–è€…é‡‡ç”¨ Special Judge æ¯”è¾ƒã€‚ä½†æ¯”èµ›ä¸­è¿˜æœ‰ä¸€äº›éä¼ ç»Ÿé¢˜ç›®ã€‚å¯¹äºé¢˜ç›®è§£æ³•ä¹Ÿæœ‰ç‰¹æ®Šçš„æ‰‹æ®µï¼Œæ¯”å¦‚éšæœºåŒ–ç®—æ³•ã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥å°è¯•å„ç§æ–¹æ³•æ¥ä¹±æã€‚","text":"å¸¸è§„çš„ä¼ ç»Ÿé¢˜ç›®é‡‡ç”¨é»‘ç®±è¯„æµ‹ï¼Œè®©é€‰æ‰‹ç¨‹åºè¯»å…¥è¾“å…¥æ•°æ®ï¼Œå°†é€‰æ‰‹è¾“å‡ºä¸è¾“å‡ºæ•°æ®å…¨æ–‡æ¯”è¾ƒæˆ–è€…é‡‡ç”¨ Special Judge æ¯”è¾ƒã€‚ä½†æ¯”èµ›ä¸­è¿˜æœ‰ä¸€äº›éä¼ ç»Ÿé¢˜ç›®ã€‚å¯¹äºé¢˜ç›®è§£æ³•ä¹Ÿæœ‰ç‰¹æ®Šçš„æ‰‹æ®µï¼Œæ¯”å¦‚éšæœºåŒ–ç®—æ³•ã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥å°è¯•å„ç§æ–¹æ³•æ¥ä¹±æã€‚ æŠŠå®ƒä»¬æ”¾åœ¨ä¸€èµ·è®²çš„å¦ä¸€ä¸ªåŸå› æ˜¯å®ƒä»¬ä¹‹é—´æœ‰è”ç³»ã€‚ äº¤äº’é¢˜ è¿™æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå¤§æ¦‚å°±æ˜¯è¯´ï¼Œä½ è¦å†™ä¸€ä¸ªç¨‹åºå’Œè®¡ç®—æœºåšæ¸¸æˆï¼Œé€‰æ‰‹ç¨‹åºå‘æµ‹è¯„ç¨‹åºå‘å‡ºè¯¢é—®ï¼Œå¹¶å¾—åˆ°å…¶åé¦ˆï¼Œæœ€ç»ˆè¦è·å–ç­”æ¡ˆã€‚ äº¤äº’æ–¹å¼ äº¤äº’æ–¹å¼æ˜¯æŒ‡äº¤äº’é¢˜çš„å®ç°æ–¹å¼ï¼Œä¸€èˆ¬æœ‰ä¸¤ç§ã€‚ Grader äº¤äº’ NOIã€IOI ç³»åˆ—æ¯”èµ›çš„äº¤äº’é¢˜å‡é‡‡ç”¨äº† Grader äº¤äº’ï¼Œé€šå¸¸ä¸éœ€è¦é€‰æ‰‹å®ç° main å‡½æ•°ï¼Œåªéœ€è¦å®ç°ç‰¹å®šçš„å‡½æ•°ã€‚å®ƒä¼šä¸‹å‘ä¸€ä¸ª grader.cpp æ–‡ä»¶[1]ï¼Œä¾›é€‰æ‰‹æ£€éªŒè‡ªå·±çš„ç¨‹åºã€‚ å¸¸è§„æƒ…å†µä¸‹ä½ åªéœ€è¦åœ¨ç¨‹åºä¸­å¼•ç”¨ä¸€ä¸ªå¤´æ–‡ä»¶ï¼ˆé¢˜ç›®ä¼šç»™å®šï¼‰ï¼Œä½†æ˜¯å¸¸ç”¨ OJ æ´›è°·çš„äº¤äº’æ–¹å¼æ¯”è¾ƒå¥‡æ€ªï¼Œè¯·å‚è€ƒé¢˜ç›®è¯´æ˜ï¼ˆéƒ½ä¼šè¯´æ˜çš„ï¼‰ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;cstdio> using namespace std; extern \"C\" int Seniorious(int); extern \"C\" int Chtholly(int n, int c) &#123; int L = 0, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (Seniorious(mid) == 1) R = mid; else L = mid; &#125; return L; &#125; STDIO äº¤äº’ Codeforces å’Œ ATCoder é‡‡ç”¨çš„éƒ½æ˜¯è¿™ç§äº¤äº’æ–¹å¼ï¼ŒICPC ç³»åˆ—æ¯”èµ›ä¸­ä¹Ÿæ˜¯ã€‚è¿™ç§ç±»å‹å¯ä»¥æ­£å¸¸ç¼–å†™ç¨‹åºï¼Œåªéœ€è¦åˆ·æ–°ç¼“å†²åŒºå°±å¯ä»¥ä»æ ‡å‡†è¾“å…¥è¯»å–ç»“æœã€‚C++ çš„åˆ·æ–°æ–¹å¼æœ‰ä¸¤ç§ï¼šè°ƒç”¨ fflush(stdout) æˆ–è€…è¾“å‡ºä¸€ä¸ª endlã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int L = 0, R = 1e9 + 1; while (L + 1 != R) &#123; int mid = L + R >> 1, t; printf(\"%d\\n\", mid); fflush(stdout); scanf(\"%d\", &amp;t); if (t == 0) return printf(\"%d\\n\", mid), 0; else if (t == 1) R = mid; else L = mid; &#125; return 0; &#125; æ³¨æ„ï¼Œå½“ä½ çš„äº¤äº’æ–¹å¼æœ‰é—®é¢˜æ—¶ï¼Œå¯èƒ½ä¼šè·å¾— Idleness limit exceededï¼ˆILEï¼Œæ‡’æƒ°è¶…è¿‡é™åˆ¶ï¼‰çš„è¯„æµ‹ç»“æœã€‚ ç®€å•äº¤äº’é¢˜ æˆ‘ä»¬æ¥çœ‹å‡ é“ç®€å•çš„äº¤äº’é¢˜ï¼Œäº¤äº’é¢˜çš„å…·ä½“æ–¹æ³•è¯·è§æ„é€ ä¸€èŠ‚ã€‚ [CF843B] Interactive LowerBound Portal. ç”±äºå®Œå…¨ä¸çŸ¥é“é“¾è¡¨çš„æ„é€ ï¼Œå› æ­¤å”¯ä¸€çš„é€¼è¿‘æ–¹å¼å°±æ˜¯éšæœºæ’’ç‚¹ï¼Œæ‰¾å‡ºä¸€ä¸ªæœ€å¤§çš„å°äº xxx çš„ç„¶åå¼€å§‹æš´åŠ›æ‰¾ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; mt19937 Rand(time(0)); int n, start, x, m, ans = -1, p; int a[50005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;start, &amp;x); m = min(1000, n); p = start; printf(\"? %d\\n\", p); fflush(stdout); int val, nxt; scanf(\"%d%d\", &amp;val, &amp;nxt); ans = val; for (int i = 1; i &lt;= n; ++i) a[i] = i; shuffle(a + 1, a + n + 1, Rand); for (int i = 1; i &lt;= m; ++i) &#123; printf(\"? %d\\n\", a[i]); fflush(stdout); int val, nxt; scanf(\"%d%d\", &amp;val, &amp;nxt); if (val &lt; x &amp;&amp; val > ans) ans = val, p = a[i]; &#125; while (p != -1 &amp;&amp; ans &lt; x) &#123; printf(\"? %d\\n\", p); fflush(stdout); int val, nxt; scanf(\"%d%d\", &amp;val, &amp;nxt); ans = val; p = nxt; &#125; printf(\"! %d\\n\", ans &lt; x ? -1 : ans); return 0; &#125; [CF1592D] Hemose in ICPC ? Portal.ç»™å®šä¸€æ£µæ ‘ï¼Œä½†æ˜¯ä¸çŸ¥é“è¾¹æƒã€‚å®šä¹‰è·ç¦» d(u,v)d(u,v)d(u,v) ä¸ºè·¯å¾„ä¸Šçš„è¾¹æƒçš„ gcdâ¡\\gcdgcdã€‚ä½ å¯ä»¥è¯¢é—®äº¤äº’åº“ä¸€ä¸ªç‚¹é›†ï¼Œäº¤äº’åº“ä¼šå›ç­”è¿™äº›ç‚¹ä¸¤ä¸¤ç‚¹å¯¹çš„è·ç¦»çš„æœ€å¤§å€¼ã€‚ä½ æœ€å¤šå¯ä»¥è¯¢é—®äº¤äº’åº“ 121212 æ¬¡ï¼Œè¦æ‰¾å‡º d(u,v)d(u,v)d(u,v) æœ€å¤§çš„ (u,v)(u,v)(u,v)ã€‚å¯ä»¥è¾“å‡ºä»»æ„ä¸€ç»„è§£ï¼Œ2â‰¤nâ‰¤1032\\le n\\le 10^32â‰¤nâ‰¤103ã€‚ å¯ä»¥å‘ç°è·ç¦»å®šä¹‰ä¸º gcdâ¡\\gcdgcdï¼Œé‚£ä¹ˆæœ€å¤§è·ç¦»å°±ç›¸å½“äºæ‰¾å‡ºæœ€å¤§è¾¹æƒã€‚ é¦–å…ˆè¯¢é—®ä¸€æ¬¡æ‰€æœ‰ç‚¹æ¥æ‰¾å‡ºæœ€å¤§çš„è¾¹æƒï¼Œå«åšç­”æ¡ˆã€‚å¯¹æ ‘è¿›è¡Œä¸€æ¬¡ dfsï¼Œæ±‚å‡ºéå†çš„é¡ºåºï¼Œè¿™æ ·æ¯ä¸¤ä¸ªæ ‘ä¸Šç›¸é‚»çš„ç‚¹éƒ½å¯ä»¥åœ¨åºåˆ—ä¸­æ‰¾åˆ°ã€‚æˆ‘ä»¬å¯¹åºåˆ—è¿›è¡ŒäºŒåˆ†ï¼Œæœ€å¤§å€¼ç­‰äºç­”æ¡ˆçš„é‚£ä¸€åŠå°±æ˜¯ç­”æ¡ˆå‡ºç°çš„åœ°æ–¹ã€‚è¿™æ ·å°±å¯ä»¥æ±‚å‡ºç‚¹å¯¹äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, maxx, a[2005], tot = 0; vector&lt;int> G[1005]; void dfs(int x, int fa) &#123; a[++tot] = x; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); a[++tot] = x; &#125; &#125; int p[1005]; int check(int L, int R) &#123; memset(p, 0, sizeof(p)); int cnt = 0; for (int i = max(0, L); i &lt;= R; ++i) p[a[i]] = true; for (int i = 1; i &lt;= n; ++i) if (p[i]) ++cnt; printf(\"? %d \", cnt); for (int i = 1; i &lt;= n; ++i) if (p[i]) printf(\"%d \", i); cout &lt;&lt; endl; int t; scanf(\"%d\", &amp;t); return t; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v), G[v].emplace_back(u); &#125; printf(\"? %d \", n); for(int i = 1; i &lt;= n; ++i) printf(\"%d \", i); cout &lt;&lt; endl; scanf(\"%d\", &amp;maxx); dfs(1, 0); int L = 1, R = tot; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(L, mid) != maxx) L = mid; else R = mid; &#125; int x = a[L], y = a[R]; printf(\"! %d %d\\n\", a[L], a[R]); return 0; &#125; æ„é€ ä¸äº¤äº’ æ„é€ é¢˜æ˜¯æŒ‡æ„é€ æ»¡è¶³é¢˜ç›®è¦æ±‚çš„ç­”æ¡ˆï¼Œæ˜¯ä¸€ç§è€ƒå¯Ÿé€‰æ‰‹æ™ºåŠ›çš„éä¼ ç»Ÿé¢˜ç›®ã€‚è™½ç„¶äº¤äº’é¢˜æ˜¯äº¤äº’ï¼Œä½†æœ‰äº›äº¤äº’å°±æ˜¯æ„é€ æ–¹æ¡ˆï¼Œå› æ­¤è¿™é‡Œæœ‰çš„æ–¹æ³•ä¼šå‡ºç°ä¸€äº›äº¤äº’é¢˜ã€‚ å¦å¤–ï¼Œå¾ˆå¤šäº›é¢˜ç›®å¯èƒ½æ²¡æœ‰ç‰¹åˆ«çš„åŠæ³•ï¼Œéœ€è¦å‘æŒ¥â€œäººç±»æ™ºæ…§â€ï¼Œä¹Ÿå°±æ˜¯ Ad-Hoc ç±»é¢˜ç›®ï¼Œå¯èƒ½éœ€è¦ä»å¤šä¸ªè§’åº¦æ€è€ƒå¹¶å‘æŒ¥è‡ªå·±çš„æƒ³è±¡åŠ›ã€‚ é¸½ç¬¼åŸç† åœ¨æ„é€ æ—¶ï¼Œå¦‚æœé‡åˆ°äº† nÃ·kn\\div knÃ·k çš„é™åˆ¶æ“ä½œæ¬¡æ•°ï¼Œå¯ä»¥è€ƒè™‘å°†æ‰€æœ‰æ•°åˆ’åˆ†ä¸º kkk ä¸ªé›†åˆï¼Œè¿™æ ·æœ€å°çš„é‚£ä¸ªé›†åˆå°±ä¸€å®šå°äºç­‰äº nÃ·kn\\div knÃ·kã€‚ [CF1198C] Matching vs Independent Set Portal. æˆ‘ä»¬æš´åŠ›æŸ¥æ‰¾è¾¹çš„ç‹¬ç«‹é›†ï¼Œå¦‚æœæœ€åç‹¬ç«‹é›†ä¸­æœ‰ xxx æ¡è¾¹ï¼Œé‚£ä¹ˆç‚¹çš„ç‹¬ç«‹é›†è‡³å°‘æœ‰ 3nâˆ’2x3n-2x3nâˆ’2x ä¸ªç‚¹ï¼Œè¿™ä¸¤ä¸ªè‡³å°‘æœ‰ä¸€ä¸ª â‰¥n\\ge nâ‰¥nã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; bool a[300005]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); fill(a + 1, a + n * 3 + 1, 0); vector&lt;int> ans; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (!a[u] &amp;&amp; !a[v]) a[u] = a[v] = 1, ans.emplace_back(i); &#125; if (ans.size() >= n) &#123; puts(\"Matching\"); for (int i = 0; i &lt; n; ++i) printf(\"%d \", ans[i]); &#125; else &#123; puts(\"IndSet\"); for (int i = 1, cnt = 0; i &lt;= n * 3 &amp;&amp; cnt &lt; n; ++i) if (!a[i]) printf(\"%d \", i), ++cnt; &#125; putchar('\\n'); &#125; return 0; &#125; [CF1534D] Lost Tree Portal. ä»¤è¿™æ£µæ ‘çš„æ ¹ä¸º 111ï¼Œå…ˆæ±‚å‡ºæ‰€æœ‰ç‚¹çš„æ·±åº¦ï¼Œæ·±åº¦ä¸ºå¥‡æ•°çš„å’Œæ·±åº¦ä¸ºå¶æ•°çš„ç‚¹çš„ä¸ªæ•°ä¸­è‡³å°‘æœ‰ä¸€ä¸ªä¸å¤§äº nÃ·2n\\div 2nÃ·2ï¼Œå› æ­¤è¯¢é—®é‚£ä¸ªå°çš„ï¼Œæ‰€æœ‰è·ç¦»ä¸º 111 çš„ç‚¹å¯¹é—´éƒ½æœ‰ä¸€æ¡è¾¹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, dep[2005], c[2]; vector&lt;pair&lt;int, int>> e; int main(void) &#123; scanf(\"%d\", &amp;n); puts(\"? 1\"); fflush(stdout); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", dep + i), ++c[dep[i] &amp; 1]; if (c[1] &lt; c[0]) &#123; for (int i = 1; i &lt;= n; ++i) if (dep[i] &amp; 1) &#123; printf(\"? %d\\n\", i); fflush(stdout); for (int j = 1, x; j &lt;= n; ++j) &#123; scanf(\"%d\", &amp;x); if (x == 1) e.emplace_back(i, j); &#125; &#125; &#125; else &#123; for (int i = 1; i &lt;= n; ++i) if (dep[i] == 1) e.emplace_back(1, i); for (int i = 2; i &lt;= n; ++i) if (!(dep[i] &amp; 1)) &#123; printf(\"? %d\\n\", i); fflush(stdout); for (int j = 1, x; j &lt;= n; ++j) &#123; scanf(\"%d\", &amp;x); if (x == 1) e.emplace_back(i, j); &#125; &#125; &#125; puts(\"!\"); for (auto [u, v] : e) printf(\"%d %d\\n\", u, v); return 0; &#125; [CF1450C2] Errich-Tac-Toe Portal. æ ¹æ®åæ ‡ (x+y) mod 3(x+y)\\bmod 3(x+y)mod3 å°†æ ¼å­åˆ†æˆä¸‰ç±»ï¼Œåªéœ€è¦å°†å…¶ä¸­ä¸¤ç±»åˆ†åˆ«æ”¹æˆ Xï¼ŒO å°±èƒ½æ»¡è¶³æ¡ä»¶ã€‚è¿™æ ·æ€»ä¿®æ”¹æ¬¡æ•°æ˜¯ kkkï¼Œæœ€å°çš„ä¿®æ”¹æ¬¡æ•°å¿…å®š â‰¤âŒŠk3âŒ‹\\le \\left\\lfloor\\frac{k}{3}\\right\\rfloorâ‰¤âŒŠ3kâ€‹âŒ‹ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, k1, k2, k3; char a[305][305]; char a1[305][305], a2[305][305], a3[305][305]; void print(char s[][305]) &#123; for (int i = 1; i &lt;= n; ++i) printf(\"%s\\n\", s[i] + 1); &#125; void solve(void) &#123; scanf(\"%d\", &amp;n); k1 = k2 = k3 = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", a[i] + 1); memcpy(a1, a, sizeof(a)); memcpy(a2, a, sizeof(a)); memcpy(a3, a, sizeof(a)); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; int t = (i + j) % 3; if (t == 0) &#123; if (a[i][j] == 'O') a1[i][j] = 'X', ++k1; if (a[i][j] == 'X') a3[i][j] = 'O', ++k3; &#125; else if (t == 1) &#123; if (a[i][j] == 'O') a2[i][j] = 'X', ++k2; if (a[i][j] == 'X') a1[i][j] = 'O', ++k1; &#125; else &#123; if (a[i][j] == 'O') a3[i][j] = 'X', ++k3; if (a[i][j] == 'X') a2[i][j] = 'O', ++k2; &#125; &#125; if (k1 &lt;= k2 &amp;&amp; k1 &lt;= k3) print(a1); else if (k2 &lt;= k3 &amp;&amp; k2 &lt;= k1) print(a2); else print(a3); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; é—®é¢˜åŒ–ç®€ | [CF618F] Double Knapsack Portal.ç»™å®šä¸¤ä¸ªé•¿åº¦ä¸º n(nâ‰¤106)n(n\\le 10^6)n(nâ‰¤106) çš„åºåˆ— A,BA,BA,Bï¼Œå½“ä¸­æ¯ä¸ªå…ƒç´ éƒ½åœ¨ [1,n][1,n][1,n] ä¸­ã€‚è¯·åˆ†åˆ«é€‰å‡º A,BA,BA,B çš„ä¸€ä¸ªå­åºåˆ—ï¼Œä½¿å¾—è¿™ä¸¤ä¸ªå­åºåˆ—çš„å…ƒç´ ä¹‹å’Œç›¸ç­‰ï¼Œæ— è§£è¾“å‡º âˆ’1-1âˆ’1ã€‚ æœ¬é¢˜ä¼šåˆæ­¥å‘Šè¯‰ä½ ä»€ä¹ˆå«åšâ€œäººç±»æ™ºæ…§â€ã€‚ äº‹å®ä¸Šï¼Œä¸€å®šæœ‰è§£ï¼Œè€Œä¸”ä¸éœ€è¦æ‰¾å­åºåˆ—ï¼Œæ‰¾å­æ®µå°±å¯ä»¥äº†ã€‚ æ€ä¹ˆæƒ³çš„ï¼Ÿæˆ‘ä¹Ÿä¸çŸ¥é“ã€‚äº‹å®ä¸Šï¼Œæ„é€ é¢˜æœ‰ä¸€ç§è§£æ³•æ˜¯ä¸»åŠ¨åŠ å¼ºæ¡ä»¶æ¥å‡å°‘å†³ç­–é‡ï¼Œå°½é‡ç®€åŒ–é—®é¢˜ã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥è€ƒè™‘å¼±åŒ–æ¡ä»¶ï¼ˆç»å¯¹å€¼æ‹†å¼€ï¼Œmaxâ¡(x,y)\\max(x,y)max(x,y) æ”¹æˆä¸»åŠ¨é€‰æ‹©æ˜¯ xxx æˆ– yyyï¼‰ã€‚ ç°åœ¨æˆ‘ä»¬æ¥è¯æ˜ä¸ºä»€ä¹ˆåªéœ€è¦æ‰¾å­æ®µå°±æœ‰è§£ã€‚è®¾åŸåºåˆ—ä¸º a,ba,ba,bï¼Œå…¶å‰ç¼€å’Œåºåˆ—ä¸º A,BA,BA,Bï¼Œå¹¶ä»¤ A[n]â‰¤B[n]A[n]\\le B[n]A[n]â‰¤B[n]ï¼ˆåä¹‹åŒç†ï¼‰ã€‚ å®šä¹‰ jij_ijiâ€‹ ä»£è¡¨æ»¡è¶³ A[i]â‰¥B[ji]A[i]\\ge B[j_i]A[i]â‰¥B[jiâ€‹] çš„æœ€å¤§æ•°ï¼Œé‚£ä¹ˆ A[i]&lt;B[ji]+b[ji+1]â‡’A[i]âˆ’B[ji]&lt;b[ji+1]â‡’0â‰¤A[i]âˆ’B[ji]&lt;nA[i]&lt;B[j_i]+b[j_i+1]\\Rightarrow A[i]-B[j_i]&lt;b[j_i+1]\\Rightarrow 0\\le A[i]-B[j_i]&lt;nA[i]&lt;B[jiâ€‹]+b[jiâ€‹+1]â‡’A[i]âˆ’B[jiâ€‹]&lt;b[jiâ€‹+1]â‡’0â‰¤A[i]âˆ’B[jiâ€‹]&lt;nï¼Œæœ‰ nnn ç§å–å€¼ï¼Œä½†æ˜¯è¿™ä¸ªä¸‹æ ‡æœ‰ 0âˆ¼n0\\sim n0âˆ¼n å…± n+1n+1n+1 ç§å–å€¼ã€‚æ ¹æ®é¸½ç¬¼åŸç†ï¼ŒA[i]âˆ’B[ji]A[i]-B[j_i]A[i]âˆ’B[jiâ€‹] ä¸€å®šæœ‰ä¸€ç»„ç›¸ç­‰çš„ã€‚ æ‰¾å‡ºè¿™ä¸ª A[p0]âˆ’B[q0]=A[p1]âˆ’B[q1]â‡’A[p1]âˆ’A[p0]=B[p1]âˆ’B[p0]A[p_0]-B[q_0]=A[p_1]-B[q_1]\\Rightarrow A[p_1]-A[p_0]=B[p_1]-B[p_0]A[p0â€‹]âˆ’B[q0â€‹]=A[p1â€‹]âˆ’B[q1â€‹]â‡’A[p1â€‹]âˆ’A[p0â€‹]=B[p1â€‹]âˆ’B[p0â€‹]ï¼Œç›´æ¥è¾“å‡ºå°±å¥½ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define i64 long long using namespace std; int n; int a[1000005], b[1000005]; i64 A[1000005], B[1000005]; int j[1000005], cnt[1000005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), A[i] = A[i - 1] + a[i]; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i), B[i] = B[i - 1] + b[i]; int is_swap = 0; if (A[n] > B[n]) &#123; for (int i = 1; i &lt;= n; ++i) swap(a[i], b[i]), swap(A[i], B[i]); is_swap = 1; &#125; for (int i = 0, q = 0; i &lt;= n; ++i) &#123; while (q &lt; n &amp;&amp; B[q + 1] &lt;= A[i]) ++q; j[i] = q; &#125; int finder = -1, p[2], q[2]; for (int i = 0; i &lt;= n; ++i) &#123; if (cnt[A[i] - B[j[i]]]) &#123; finder = A[i] - B[j[i]]; p[1] = i, q[1] = j[i]; break; &#125; ++cnt[A[i] - B[j[i]]]; &#125; for (int i = 0; i &lt;= n; ++i) if (A[i] - B[j[i]] == finder) &#123; p[0] = i, q[0] = j[i]; break; &#125; if (is_swap) swap(p[0], q[0]), swap(p[1], q[1]); cout &lt;&lt; p[1] - p[0] &lt;&lt; \"\\n\"; for (int i = p[0] + 1; i &lt;= p[1]; ++i) printf(\"%d \", i); putchar('\\n'); cout &lt;&lt; q[1] - q[0] &lt;&lt; \"\\n\"; for (int i = q[0] + 1; i &lt;= q[1]; ++i) printf(\"%d \", i); putchar('\\n'); return 0; &#125; å½’çº³æ³• è€ƒè™‘æ‰¾åˆ°æœ‰è§£çš„å……è¦æ¡ä»¶æ¥åˆ¤æ‰æ— è§£ï¼Œç„¶åå°†åŸæ–‡é¢˜è½¬åŒ–æˆè§„æ¨¡å‡ä¸€çš„ä¸€å®šæœ‰è§£çš„å­é—®é¢˜ã€‚ [CF1470D] Strange Housing Portal. n=1n=1n=1 æ—¶ä¸€å®šæœ‰è§£ï¼Œè€Œä¸”æŸ“ä¸æŸ“éƒ½æ— æ‰€è°“ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰æŸ“è‰²çŠ¶å†µå–åã€‚ è‹¥ nâˆ’1n-1nâˆ’1 æœ‰è§£ï¼Œåˆ™è€ƒè™‘å°†ç‚¹ nnn åŠ å…¥ã€‚å¦‚æœç‚¹ nnn è¿æ¥çš„ç‚¹éƒ½æ²¡æœ‰è¢«æŸ“è‰²é‚£ä¹ˆå®ƒå¿…é¡»æŸ“è‰²ï¼Œå¦åˆ™ä¸èƒ½æŸ“è‰²ã€‚ æœ€åå¦‚æœæœ‰ç‚¹æ²¡æœ‰åŠ å…¥ï¼Œé‚£ä¹ˆæ˜¯æ— è§£çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; bool v[300005]; int tag[300005]; // -1 æœªéå†ï¼Œ0 ä¸æŸ“ï¼Œ1 æŸ“ vector&lt;int> G[300005]; queue&lt;int> q; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) G[i].clear(), v[i] = 0, tag[i] = -1; while (!q.empty()) q.pop(); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; q.emplace(1); v[1] = 1; tag[1] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); bool flag = true; for (int y : G[x]) if (tag[y] != -1) flag &amp;= !tag[y]; tag[x] = flag; for (int y : G[x]) if (!v[y]) v[y] = 1, q.emplace(y); &#125; for (int i = 1; i &lt;= n; ++i) if (!v[i]) return puts(\"NO\"), void(); puts(\"YES\"); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += tag[i]; printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (tag[i]) printf(\"%d \", i); putchar('\\n'); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [CF1515F] Phoenix and Earthquake Portal. é¦–å…ˆå›¾å¿…é¡»è¿é€šï¼Œç‚¹æƒä¹‹å’Œéœ€è¦å¤§äºç­‰äº x(nâˆ’1)x(n-1)x(nâˆ’1)ï¼Œå¦åˆ™å¿…å®šæ— è§£ã€‚ å¯ä»¥è¯æ˜ä»»æ„ä¸€æ£µç”Ÿæˆæ ‘éƒ½æ˜¯æœ‰è§£çš„ï¼Œè¯æ˜ï¼š è‹¥ auâ‰¥xa_u\\ge xauâ€‹â‰¥xï¼Œé‚£ä¹ˆç›´æ¥ä¿®å»ºå’Œå®ƒçˆ¶äº²çš„è¾¹ï¼Œè¿™æ ·ä»ç„¶æ»¡è¶³æ¡ä»¶ï¼› au&lt;xa_u&lt;xauâ€‹&lt;xï¼Œä¿®å»ºäº†ä¹‹åç‚¹æƒä¹‹å’Œçš„å‡å°é‡å°äº xxxï¼Œè¿™æ ·åªéœ€è¦æœ€åä¿®å»ºè¿™ä¸ªå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, x; i64 a[300005], sum; int fa[300005], ans[300005], tot1, tot2; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; pair&lt;int, int> e[300005]; vector&lt;pair&lt;int, int>> G[300005]; void dfs(int u, int fa, int id) &#123; for (auto [v, p] : G[u]) if (v != fa) dfs(v, u, p); if (u == 1) return; if (a[u] >= x) a[fa] += a[u] - x, ans[++tot1] = id; else ans[--tot2] = id; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;x); tot2 = n; for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i), fa[i] = i, sum += a[i]; if (sum &lt; 1ll * (n - 1) * x) return puts(\"NO\"), 0; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", &amp;e[i].first, &amp;e[i].second); if (find(e[i].first) == find(e[i].second)) continue; fa[find(e[i].first)] = find(e[i].second); G[e[i].first].emplace_back(e[i].second, i); G[e[i].second].emplace_back(e[i].first, i); &#125; for (int i = 1; i &lt;= n; ++i) if (find(i) != find(1)) return puts(\"NO\"), 0; puts(\"YES\"); dfs(1, 0, 0); for (int i = 1; i &lt; n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; [ARC122E] Increasing LCMs Portal. è€ƒè™‘å½’çº³æ„é€ ã€‚ n=1n=1n=1 æ—¶æ˜¾ç„¶æˆç«‹ã€‚ å¯¹äº n&gt;1n&gt;1n&gt;1ï¼Œæˆ‘ä»¬è€ƒè™‘æ‰¾å‡ºè¿™ä¸ªåºåˆ—çš„æœ€åä¸€ä¸ªæ•°ã€‚è¿™æœ€åä¸€ä¸ªæ•°éœ€è¦æ»¡è¶³å‰é¢æ•°çš„ lcmâ¡\\operatorname{lcm}lcm ä¸æ˜¯å®ƒçš„å€æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´ gcdâ¡(lcmâ¡jâ‰ i{aj},ai)&lt;ai\\gcd(\\operatorname{lcm}_{j\\ne i}\\{a_j\\},a_i)&lt;a_igcd(lcmjî€ =iâ€‹{ajâ€‹},aiâ€‹)&lt;aiâ€‹ã€‚è¿™ä¸ªå¼å­ç›¸å½“äº lcmâ¡jâ‰ i{gcdâ¡(aj,ai)}&lt;ai\\operatorname{lcm}_{j\\ne i}\\{\\gcd(a_j,a_i)\\}&lt;a_ilcmjî€ =iâ€‹{gcd(ajâ€‹,aiâ€‹)}&lt;aiâ€‹ï¼Œè¿™æ ·å°±å¯ä»¥è½¬åŒ–ä¸ºè§„æ¨¡ä¸º nâˆ’1n-1nâˆ’1 çš„é—®é¢˜ã€‚ ç”±äº lcmâ¡\\operatorname{lcm}lcm éšç€é—®é¢˜è§„æ¨¡çš„å‡å°ä¸ä¼šä¸Šå‡ï¼Œå¯ä»¥æ”¾åœ¨æœ€åä¸€ä¸ªçš„ aaa è¶Šæ¥è¶Šå¤šï¼Œå› æ­¤æ‰¾åˆ°ä¸€ä¸ªå°±æ”¾å…¥ç­”æ¡ˆä¸ä¼šä½¿å°‘æ‰å¯èƒ½çš„è§£ã€‚å› æ­¤å¦‚æœæ‰¾ä¸åˆ°è¿™æœ€åä¸€ä¸ª aaa å°±æ— è§£ã€‚ æ—¶é—´å¤æ‚åº¦ O(n3logâ¡V)O(n^3\\log V)O(n3logV)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; vector&lt;i64> ans; i64 gcd(i64 x, i64 y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; i64 lcm(i64 x, i64 y) &#123; return x / gcd(x, y) * y; &#125; void solve(vector&lt;i64> a) &#123; if (a.size() == 1) return ans.emplace_back(a[0]), void(); for (int i = 0; i &lt; a.size(); ++i) &#123; bool flag = 1; i64 l = 1; for (int j = 0; j &lt; a.size(); ++j) if (i != j) l = lcm(l, gcd(a[j], a[i])); if (l &lt; a[i]) &#123; ans.emplace_back(a[i]); vector&lt;i64> tmp; for (int j = 0; j &lt; a.size(); ++j) if (i != j) tmp.emplace_back(a[j]); solve(tmp); return; &#125; &#125; &#125; int main(void) &#123; cin >> n; vector&lt;i64> a(n); for (int i = 0; i &lt; n; ++i) cin >> a[i]; solve(a); if (ans.size() != n) puts(\"No\"); else &#123; puts(\"Yes\"); reverse(ans.begin(), ans.end()); for (i64 x : ans) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; '\\n'; &#125; return 0; &#125; [CF963B] Destruction of a Tree Portal. nnn ä¸ºå¶æ•°æ—¶åº¦æ•°æ˜¯ä¸å¯¹çš„ï¼Œå¥‡æ•°æ—¶è€ƒè™‘å½’çº³æ„é€ ã€‚ æ‰¾ä¸€ä¸ª DFS åºæœ€å°çš„æ¥æ€ï¼Œè¿™æ ·å¯ä»¥å°†åŸé—®é¢˜åˆ†è£‚æˆè§„æ¨¡æ›´å°çš„å­é—®é¢˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> using namespace std; int n, root, deg[200005]; int f[200005]; int st[200005], tot; bool del[200005]; vector&lt;int> G[200005], ans; void dfs(int x) &#123; st[++tot] = x; for (int y : G[x]) if (y != f[x]) dfs(y); &#125; void dfs2(int x) &#123; del[x] = 1; ans.emplace_back(x); for (int y : G[x]) &#123; --deg[y]; if (y == f[x] || del[y]) continue; if (deg[y] % 2 == 0) dfs2(y); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i); if (!f[i]) root = i; else &#123; ++deg[i]; ++deg[f[i]]; G[i].emplace_back(f[i]); G[f[i]].emplace_back(i); &#125; &#125; dfs(root); while (tot) &#123; int u = st[tot--]; if (deg[u] % 2 == 0) dfs2(u); &#125; if (ans.size() == n) &#123; puts(\"YES\"); for (int x : ans) printf(\"%d\\n\", x); &#125; else puts(\"NO\"); return 0; &#125; DFS æ ‘ DFS æ ‘å¯ä»¥å¤„ç†ä¸€äº›ä¸å›¾è®ºç›¸å…³çš„é—®é¢˜ã€‚ [CF1364D] Ehabâ€™s Last Corollary Portal. æ‰¾ç¯ï¼å¦‚æœç¯çš„å¤§å° â‰¤k\\le kâ‰¤k å¯ä»¥ç›´æ¥è¾“å‡ºï¼Œå¦åˆ™å°±åœ¨ç¯ä¸Šæ¯éš”ä¸€ä¸ªç‚¹è¾“å‡ºä¸€ä¸ªæ¥è¾“å‡ºç‹¬ç«‹é›†ã€‚å½“ç„¶å›¾æœ‰å¯èƒ½æ˜¯æ ‘ï¼Œè¦åˆ¤æ‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, k, S, T, mx = 1e9; int dep[100005], cnt[100005]; vector&lt;int> G[100005], ans; void dfs(int x) &#123; ans.emplace_back(x); dep[x] = ans.size(); for (int y : G[x]) &#123; if (!dep[y]) dfs(y); if (dep[y] &lt; dep[x] - 1) &#123; // å›åˆ°éçˆ¸çˆ¸ç¥–å…ˆï¼Œæˆ–è€…æ˜¯ int t = dep[x] - dep[y] + 1; if (t &lt;= k) &#123; printf(\"2\\n%d\\n\", t); for (int i = dep[y] - 1; i &lt;= dep[x] - 1; ++i) printf(\"%d \", ans[i]); putchar('\\n'); exit(0); &#125; if (t &lt;= mx) &#123; mx = t; S = x; T = y; &#125; &#125; &#125; ans.pop_back(); &#125; void print(int x) &#123; ans.emplace_back(x); dep[x] = ans.size(); if (x == T) &#123; puts(\"1\"); for (int i = 0; i &lt; k; i += 2) printf(\"%d \", ans[i]); putchar('\\n'); &#125; for (int y : G[x]) &#123; if (x == S &amp;&amp; y == T) continue; if (!dep[y]) print(y); &#125; ans.pop_back(); &#125; int col[100005]; vector&lt;int> res[2]; void dfs2(int x) &#123; res[col[x]].emplace_back(x); for (int y : G[x]) if (col[y] == -1) &#123; col[y] = !col[x]; dfs2(y); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1); if (S) return memset(dep, 0, sizeof dep), print(S), 0; memset(col, -1, sizeof col); col[1] = 0; int t = (k + 1) / 2; dfs2(1); puts(\"1\"); if (res[0].size() >= t) &#123; for (int i = 0; i &lt; t; ++i) printf(\"%d \", res[0][i]); putchar('\\n'); &#125; else &#123; for (int i = 0; i &lt; t; ++i) printf(\"%d \", res[1][i]); putchar('\\n'); &#125; return 0; &#125; ä¸å›¾è®ºç›¸å…³çš„é—®é¢˜ æœ€ä¼˜åŒ–é—®é¢˜ äºŒè¿›åˆ¶åˆ†ç»„ è°ƒæ•´æ³• æäº¤ç­”æ¡ˆé¢˜ å¾ˆè°”è°”çš„ä¸€ç±»é¢˜ç›®ã€‚æ­£å¸¸çš„é¢˜ç›®æ˜¯é»‘ç®±è¯„æµ‹ï¼Œä½†æ˜¯æäº¤ç­”æ¡ˆé¢˜ä¼šå°†è¾“å…¥æ•°æ®ä¸‹å‘ç»™ä½ ï¼ˆä½†æ˜¯åœ¨ Problemset ä¸­æœ‰æ›´ç¦»è°±çš„ï¼ï¼‰ï¼Œç„¶åè®©ä½ æ±‚å‡ºè¾“å‡ºï¼Œç›´æ¥æäº¤ã€‚ é€šå¸¸ä»¥ä¸‹ç±»å‹çš„æ•°æ®ç‚¹ä¼šè¢«ç»„åˆæˆæäº¤ç­”æ¡ˆé¢˜ï¼š å¯ä»¥è¢«æ‰‹ç©æˆ–è€…è¶…çº§å¤§æš´åŠ›è§£å‡ºæ¥çš„æ•°æ®ç‚¹ï¼› ç‰¹æ®Šæ„é€ çš„æ•°æ®ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨ç‰¹åˆ«çš„è§£æ³•ï¼› éœ€è¦ä½¿ç”¨ä¹±ææ–¹æ³•è§£å†³çš„æ•°æ®ç‚¹ã€‚ è¿™ç§é¢˜å¦‚æœå‡ºç°ä¸€èˆ¬å°±å¾ˆç¦»è°±ï¼Œæˆ‘ä»¬æ¥çœ‹å‡ é“ç›¸å¯¹æ­£å¸¸çš„ã€‚ ä¸æ˜¯é‚£ä¹ˆç¦»è°±çš„é¢˜ å¾ˆæ­£å¸¸çš„é¢˜ã€‚ [eJOI2018] äº’ç´ æ ‘ Portal. ç”±äºé¢˜ç›®ä¸­ä¿è¯å­˜åœ¨ X=0X=0X=0ï¼Œéšæœºä¸€ä¸ªæ’åˆ—ç„¶åæŒ‰ç…§æ¡ä»¶è´ªå¿ƒå¾€æ ‘é‡Œå¡«éƒ½æ˜¯å¾ˆå®¹æ˜“å‡ºè§£çš„ï¼Œå› æ­¤ç›´æ¥éšæœºåŒ–åŠ è´ªå¿ƒå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, id[100005], a[100005], tmp[100005], res; vector&lt;int> G[100005]; mt19937 Rand(time(0)); set&lt;int> s; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; void dfs(int x, int fa) &#123; if (res) return; for (int i : s) if (!fa || gcd(tmp[fa], id[i]) == 1) &#123; // ç»™å½“å‰ç‚¹å¡«æ•° tmp[x] = id[i]; s.erase(i); break; &#125; if (!tmp[x]) return ++res, void(); for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; vector&lt;int> tmp; G[i].swap(tmp); id[i] = i; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v), G[v].emplace_back(u); &#125; int ans = n; for (int op = 1;; ++op) &#123; shuffle(id + 1, id + n + 1, Rand); s.clear(); for (int i = 1; i &lt;= n; ++i) tmp[i] = 0, s.insert(i); res = 0; dfs(1, 0); if (res &lt; ans) &#123; ans = res; for (int i = 1; i &lt;= n; ++i) a[i] = tmp[i]; &#125; if (!ans) break; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); &#125; return 0; &#125; [JRKSJ R2] Dark Forest Portal. O(1)O(1)O(1) è®¡ç®—äº¤æ¢ä½ç½®çš„è´¡çŒ®ï¼Œç„¶åéšæœºæ¥å—æ—¶æŠŠç­”æ¡ˆä¹Ÿç»™æ¥å—äº†å°±è¡Œï¼ˆå› ä¸ºæ–¹æ¡ˆä¸å¥½å­˜å‚¨ï¼‰ã€‚æ³¨æ„ç‰¹åˆ¤ #3ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, p[1005]; i64 a[1005], ans; mt19937 Rand(time(0)); inline int rndint(int l, int r) &#123; return uniform_int_distribution&lt;>(l, r)(Rand); &#125; inline double rnddb(double l, double r) &#123; return uniform_real_distribution&lt;>(l, r)(Rand); &#125; inline int P(int x) &#123; if (x &lt;= 0) return x + n; if (x > n) return x - n; return x; &#125; void calc(int x, int y) &#123; // å°† p[x] èµ‹å€¼ä¸º y æ—¶ç­”æ¡ˆæ”¹å˜ int A = p[P(x - 2)], B = p[P(x - 1)], &amp;C = p[x], D = p[P(x + 1)], E = p[P(x + 2)]; ans -= (B * a[A] * a[B] + C * a[B] * a[D] + D * a[D] * a[E]) * a[C]; C = y; ans += (B * a[A] * a[B] + C * a[B] * a[D] + D * a[D] * a[E]) * a[C]; &#125; void SA(double T, const double ET, const double delta) &#123; for (int i = 1; i &lt;= n; ++i) calc(i, i); while (T > ET) &#123; int x = rndint(1, n), y = rndint(1, n), px = p[x], py = p[y]; i64 tmp = ans; calc(x, py); calc(y, px); if (ans &lt;= tmp &amp;&amp; exp((ans - tmp) / T) &lt; rnddb(0, 1)) // å›é€€ç­”æ¡ˆ ans = tmp, swap(p[x], p[y]); T *= delta; &#125; cerr &lt;&lt; \"ans = \" &lt;&lt; ans &lt;&lt; \"\\n\"; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", p[i]); putchar('\\n'); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); return SA(1e15, 1e-15, 0.99999), 0; &#125; Problemset Problemset ä¸å€’ï¼Œé™ªä½ åˆ°è€ï¼ ç®€å•æ„é€  éƒ½éå¸¸çš„æœ‰è¶£ï¼ [CF1278E] Tests for problem D Portal. ä½¿ç”¨å¦‚ä¸‹çš„æ„é€ æ–¹å¼ï¼šå¯¹äºä¸€ä¸ªèŠ‚ç‚¹ xxx çš„æ‰€æœ‰å„¿å­ yyy éƒ½åœ¨å³è¾¹å’Œ xxx ç›¸äº¤ï¼Œå¹¶ä¸”äº’ç›¸åŒ…å«ï¼Œçˆ¶äº²åˆ™åœ¨å·¦è¾¹å’Œ xxx ç›¸äº¤ã€‚ æ˜¾ç„¶æ˜¯å¯¹çš„ï¼Œå¦‚ä½•æ„é€ å‘¢ï¼Ÿè®¡ç®—å½“å‰çº¿æ®µçš„å³ç«¯ç‚¹ä¼šåˆ°å“ªé‡Œï¼Œç„¶åè®©å„¿å­çš„å·¦ç«¯ç‚¹ä»å³ç«¯ç‚¹å¼€å§‹ä»å³å¾€å·¦æ’ï¼Œå¹¶é€’å½’éå†å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, l[500005], r[500005], num; vector&lt;int> G[500005]; void dfs(int x, int fa) &#123; num += G[x].size() + (fa == 0); r[x] = num; int cnt = 1; for (int y : G[x]) if (y != fa) &#123; l[y] = r[x] - cnt; ++cnt; dfs(y, x); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); num = 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; l[1] = 1; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d %d\\n\", l[i], r[i]); return 0; &#125; æ·±å…¥åˆ†æé—®é¢˜ æŒ–æ˜é¢˜ç›®çš„æ€§è´¨ï¼Œæ ¹æ®æ­¤è®¾è®¡è§£æ³•ã€‚æ­¤ç±»é—®é¢˜çš„æ€ç»´éš¾åº¦å¯èƒ½ä¼šå¾ˆå¤§ã€‚ [NOIP2022] å–µäº†ä¸ªå–µ Portal. k=2nâˆ’2k=2n-2k=2nâˆ’2 æ˜¾ç„¶æ˜¯å¥½åšçš„ï¼Œæˆ‘ä»¬ç•™ä¸€ä¸ªç©ºæ ˆï¼Œå¦‚æœæ¥çš„ç‰Œä¸æ ˆé¡¶æœ‰ç›¸åŒå°±æ¶ˆé™¤ï¼Œå¦åˆ™å°±ä¸æ ˆåº•ç›¸åŒï¼Œæ”¾åˆ°ç©ºæ ˆæ¥æ¶ˆé™¤æ ˆåº•ã€‚ ç°åœ¨æ¥çœ‹å¤šçš„é‚£ç§ç‰Œæ€ä¹ˆå®‰æ”¾ã€‚å¦‚æœä¸‹ä¸€å¼ ç‰Œæ˜¯å®ƒè‡ªå·±é‚£ä¹ˆéšä¾¿æ‰¾ä¸€ä¸ªä½ç½®æ”¾ï¼Œå¦‚æœä¸‹ä¸€å¼ ç‰Œæ˜¯ä¸€ä¸ªæ ˆåº•ç‰Œé‚£ä¹ˆæŠŠå®ƒæ”¾åˆ°é‚£ä¸ªæ ˆä¸Šï¼Œç„¶åæ¶ˆæ‰æ ˆåº•å®ƒå°±æˆä¸ºäº†æ–°çš„æ ˆé¡¶ã€‚ è€Œå¦‚æœä¸‹ä¸€å¼ ç‰Œæ˜¯æ ˆé¡¶ç‰Œå‘¢ï¼Ÿè°”è°”çš„äº‹æƒ…å‘ç”Ÿäº†ï¼Œä¼¼ä¹ä¸èƒ½ç®€å•å¤„ç†ã€‚æˆ‘ä»¬å°†ç©ºæ ˆè®¾ä¸º spspspï¼Œå½“å‰è¿™ä¸ªç¥ç§˜çš„ç‰Œä¸º xxxã€‚ä¸åƒç¾Šäº†ä¸ªç¾Šï¼Œè¿™é¢˜ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°åé¢æ‰€æœ‰çš„ç‰Œã€‚æˆ‘ä»¬æ‰¾åˆ°ä¸‹ä¸€ä¸ª xxx æˆ–æ ˆåº•å…ƒç´  bbbï¼ˆçœ‹å“ªä¸ªå…ˆå‡ºç°ï¼‰ã€‚ æ‰¾åˆ°äº† xxxï¼å°† xxx åŠ å…¥ç©ºæ ˆï¼Œç”±äºæ¥ä¸‹æ¥è¿˜æ²¡æœ‰æ ˆåº•å…ƒç´ è¿›æ¥ï¼Œå› æ­¤ä¸éœ€è¦è¿™ä¸ªç©ºæ ˆå¹²æ´»ã€‚æœŸé—´å‡ºç°çš„æ‰€æœ‰æ ˆé¡¶å…ƒç´ éƒ½å¯ä»¥ç›´æ¥æ¶ˆæ‰ã€‚ æ²¡æœ‰ xxxï¼Œæ‚²ã€‚è®¾è¿™ä¸ªæ ˆåº•å…ƒç´  bbb å¯¹åº”çš„æ ˆé¡¶å…ƒç´ ä¸º tttã€‚ è¿™ä¸ª ttt åœ¨ bbb ä¹‹å‰å‡ºç°äº†å¥‡æ•°æ¬¡ï¼Œé‚£ä¹ˆå°† xxx åŠ å…¥ spspspï¼Œå¤„ç†å®Œä¹‹åä¼šå‘ç° ttt è¢«æ¶ˆæ‰äº†ï¼Œè¿™æ · bbb æ”¾è¿›å»å³å¯ã€‚è¿™æ ·ä¼šå‘ç°å…¶æˆä¸ºäº†æ–°çš„ç©ºæ ˆã€‚ è¿™ä¸ª ttt åœ¨ bbb ä¹‹å‰å‡ºç°äº†å¶æ•°æ¬¡ï¼Œåˆ™å°† xxx æ”¾å…¥ bbb æ‰€åœ¨çš„æ ˆã€‚è¿™æ ·æˆ‘ä»¬å¯ä»¥åœ¨ spspsp å°† ttt æ€å¹²å‡€ï¼ˆç”šè‡³ä¸ç”¨ç©ºæ ˆï¼Œåœ¨åŸæ¥çš„æ ˆä¸Šæ–¹ä¹Ÿå¯ï¼‰ï¼Œç„¶å bbb æ¥äº†ï¼Œæ¶ˆæ‰æ ˆåº•ï¼Œttt å°±æˆä¸ºäº†æ ˆåº•ï¼Œè€Œ xxx æˆä¸ºäº†æ–°çš„æ ˆé¡¶ã€‚ å®ç°ä¹Ÿæ˜¯ä¸ªé—®é¢˜ï¼Œä¸Šè¿°è¿‡ç¨‹å¯èƒ½ç»†èŠ‚å¾ˆå¤šï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªé«˜æ•ˆçš„å®ç°ï¼ˆå› ä¸ºæ•°æ®ä¸å°ï¼‰ã€‚è®°å½•ä¸€ä¸‹æ¯ä¸ªæ•°åœ¨æ ˆçš„ä½ç½®ä½äºçš„ç¼–å·ï¼Œæ¯ä¸ªæ ˆçš„å€¼ã€‚å¹¶ä¸”æ³¨æ„å¤šæµ‹æ¸…ç©ºã€‚ è¿™æ ·å¯ä»¥åšåˆ° O(n+m)O(n+m)O(n+m)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, k, a[2000005]; int up[605], down[605]; // å…ƒç´ ä½œä¸ºæ ˆé¡¶ã€æ ˆåº•ï¼Œæ ˆçš„ç¼–å· int val[605][2], siz[605]; // æ ˆ x ä¸Šé¢(0)å’Œä¸‹é¢(1)çš„å…ƒç´  int cnt[605]; // è®°å½•å¡ç‰Œå‡ºç°æ¬¡æ•° vector&lt;pair&lt;int, int>> ans; vector&lt;int> L; void solve(void) &#123; for (int i = 1; i &lt; n; ++i) L.emplace_back(i); int sp = n; // ç©ºæ ˆ for (int l = 1, r = 0; l &lt;= m; l = r + 1) &#123; r = l; int i = l; if (down[a[i]]) &#123; // æœ‰ a[i] ä½œä¸ºæ ˆåº• int u = down[a[i]]; ans.emplace_back(sp, 0); ans.emplace_back(sp, u); if (siz[u] == 2) &#123; int v = val[u][0]; siz[u] = 1; val[u][1] = val[u][0]; val[u][0] = 0; down[v] = u; up[v] = 0; L.emplace_back(u); &#125; else &#123; siz[u] = 0; val[u][1] = 0; &#125; down[a[i]] = 0; &#125; else if (up[a[i]]) &#123; // ä½œä¸ºæ ˆé¡¶ int u = up[a[i]]; ans.emplace_back(u, 0); up[a[i]] = 0; siz[u] = 1; val[u][0] = 0; L.emplace_back(u); &#125; else if (!L.empty()) &#123; // è¿˜æœ‰ç©ºæ ˆ int u = L.back(); L.pop_back(); ans.emplace_back(u, 0); if (siz[u] == 0) &#123; siz[u] = 1; val[u][1] = a[i]; down[a[i]] = u; L.emplace_back(u); &#125; else &#123; siz[u] = 2; val[u][0] = a[i]; up[a[i]] = u; &#125; &#125; else &#123; // è°”è°”ï¼Œæ­¤æ—¶ä¸€å®šé™¤äº†ç©ºæ ˆå…¨æ»¡ï¼Œå¹¶ä¸”å½“å‰æ˜¯è°”è°”ç‰Œ while (r + 1 &lt;= m) &#123; ++r; if (a[r] == a[i]) &#123; // æ‰¾åˆ°äº† xï¼ ans.emplace_back(sp, 0); for (int j = l + 1; j &lt; r; ++j) ans.emplace_back(up[a[j]], 0); for (int j = l + 1; j &lt; r; ++j) if (up[a[j]] &amp;&amp; cnt[up[a[j]]]) &#123; int u = up[a[j]]; cnt[u] = 0; up[a[j]] = 0; siz[u] = 1; val[u][0] = 0; L.emplace_back(u); &#125; ans.emplace_back(sp, 0); break; &#125; if (down[a[r]]) &#123; // è¿™æ˜¯ä¸ªæ ˆåº•ï¼Œæ‚² int u = down[a[r]]; if (cnt[u]) ans.emplace_back(sp, 0); else ans.emplace_back(u, 0); for (int j = l + 1; j &lt; r; ++j) ans.emplace_back(up[a[j]], 0); for (int j = l + 1; j &lt; r; ++j) if (up[a[j]] &amp;&amp; cnt[up[a[j]]] &amp;&amp; up[a[j]] != u) &#123; int u = up[a[j]]; cnt[u] = 0; up[a[j]] = 0; siz[u] = 1; val[u][0] = 0; L.emplace_back(u); &#125; if (cnt[u]) &#123; ans.emplace_back(u, 0); cnt[u] = 0; down[val[u][1]] = up[val[u][0]] = 0; val[u][1] = val[u][0] = 0; down[a[l]] = sp; val[sp][1] = a[l]; siz[sp] = 1; L.emplace_back(sp); sp = u; &#125; else &#123; ans.emplace_back(sp, 0); ans.emplace_back(sp, u); down[val[u][1]] = 0; up[val[u][0]] = 0; down[val[u][0]] = u; up[a[l]] = u; val[u][1] = val[u][0]; val[u][0] = a[l]; siz[u] = 2; &#125; break; &#125; cnt[up[a[r]]] ^= 1; &#125; &#125; &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", a + i); L.clear(); ans.clear(); memset(down, 0, sizeof down); memset(up, 0, sizeof up); memset(val, 0, sizeof val); memset(siz, 0, sizeof siz); memset(cnt, 0, sizeof cnt); solve(); printf(\"%d\\n\", ans.size()); for (auto [x, y] : ans) if (!y) printf(\"1 %d\\n\", x); else printf(\"2 %d %d\\n\", x, y); &#125; return 0; &#125; [eJOI2018] å¾ªç¯æ’åº Portal. å®é™…ä¸Šå¯ä»¥å¥—è·¯åœ°åˆ†æã€‚ å¼±åŒ–é¢˜ç›®æ¡ä»¶ã€‚æœ€ä¼˜è§£ï¼Ÿæˆ‘ä¸ç®¡ï¼æˆ‘ä»¬å¯ä»¥åªäº¤æ¢ä¸¤ä¸ªæ•°ï¼Œä½†æ˜¯è¿™æ ·è¿˜æ˜¯å¾ˆéš¾åŠï¼Œæ•°æ²¡æœ‰æ”¾çš„å”¯ä¸€ä½ç½®ï¼Œé‚£ä¹ˆå°±å…ˆåšæ’åˆ—ï¼ è§‚å¯Ÿæ ·ä¾‹ã€‚æ¯”å¦‚æ ·ä¾‹ 555ï¼Œå®ƒåˆå¹¶äº†ä¸¤ä¸ªæ“ä½œï¼Œä½†æ˜¯åé¢å¤šå‡ºäº†ä¸€ä¸ªæ“ä½œã€‚æ‰‹ç©åå‘ç°æ“ä½œæ˜¯å¯ä»¥åˆå¹¶çš„ï¼Œä½†æ˜¯æœ€åè¦å¤šå‡ºæ¥ä¸€ä¸ªé•¿åº¦ä¸ºåˆå¹¶çš„æ“ä½œæ•°çš„æ“ä½œã€‚ ç°åœ¨è€ƒè™‘æ€ä¹ˆå°†è¿™ä¸ªåšæ³•æ‰©å±•åˆ°å¯ä»¥é‡å¤çš„æ•°ä¸Šã€‚æ’åˆ—ç»™äº†ä»€ä¹ˆä¾¿åˆ©ï¼Ÿæ¯ä¸ªç‚¹çš„å…¥åº¦å‡ºåº¦éƒ½ä¸º 111ï¼Œä½†å¦‚æœå®ƒä¸æ˜¯æ’åˆ—ï¼Œå®ƒåªä¼šæ»¡è¶³å…¥åº¦å‡ºåº¦ç›¸ç­‰ã€‚ å¯ä»¥ä½¿ç”¨æœ‰å‘å›¾çš„æ–¹å¼åˆ»ç”»è¿™ä¸ªè¿‡ç¨‹ï¼šå°† aia_iaiâ€‹ çš„æœ€ç»ˆä½ç½®å‘ aia_iaiâ€‹ è¿è¾¹ï¼Œç„¶ååœ¨è¿™ä¸ªå›¾ä¸Šæ‰¾ç¯ï¼Œå¹¶ä¸”æ¯æ¡è¾¹ç»è¿‡æ°å¥½ä¸€æ¬¡ã€‚è¿™æ˜¯æ¬§æ‹‰è·¯ï¼åœ¨å­˜è¾¹çš„æ—¶å€™è®°å½•ä¸€ä¸‹ iiiï¼Œå› ä¸ºè¿™å°±æ˜¯æ–¹æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, s, m; int a[200005], b[200005], to[200005]; bool vis[200005]; vector&lt;pair&lt;int, int>> G[200005]; vector&lt;bool> ban[200005]; vector&lt;vector&lt;int> > ans; vector&lt;int> road; int cur[200005]; void dfs(int x) &#123; vis[x] = 1; for (; cur[x] &lt; G[x].size(); ++cur[x]) if (!ban[x][cur[x]]) &#123; int y = G[x][cur[x]].first, w = G[x][cur[x]].second; ban[x][cur[x]] = 1; dfs(y); road.emplace_back(w); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;s); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) to[i] = a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; sort(to + 1, to + n + 1); // to ä¸ºæœ€ç»ˆçš„ a for (int i = 1; i &lt;= n; ++i) if (a[i] != to[i]) &#123; ++m; G[to[i]].emplace_back(a[i], i); ban[to[i]].emplace_back(0); &#125; if (m > s) return puts(\"-1\"), 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i] &amp;&amp; G[i].size()) &#123; road.clear(); dfs(i); ans.push_back(road); &#125; for (int i = 0; i &lt; ans.size(); ++i) reverse(ans[i].begin(), ans[i].end()); if (min(int(ans.size()), s - m) > 1) &#123; int t = min(int(ans.size()), s - m); road.clear(); road.emplace_back(ans[0][0]); for (int i = ans.size() - t + 1; i &lt; ans.size(); ++i) &#123; for (int x : ans[i]) ans[0].emplace_back(x); road.emplace_back(ans[i][0]); ans[i].clear(); &#125; for (int i = 1; i &lt; t; ++i) ans.pop_back(); reverse(road.begin(), road.end()); ans.push_back(road); &#125; printf(\"%u\\n\", ans.size()); for (int i = 0; i &lt; ans.size(); ++i) &#123; printf(\"%u\\n\", ans[i].size()); for (int x : ans[i]) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; [CF1764G] Doremyâ€™s Perfect DS Class G1ï¼ŒG2ï¼ŒG3ã€‚ç»™å®šä¸€ä¸ª 1âˆ¼n1\\sim n1âˆ¼n çš„æ’åˆ— pppï¼ˆnâ‰¤1024n \\le 1024nâ‰¤1024ï¼Œæ³¨æ„ 210=10242^{10}=1024210=1024ï¼‰ï¼Œæ¯æ¬¡ä½ å¯ä»¥è¯¢é—® l,r,kl,r,kl,r,kï¼Œäº¤äº’åº“ä¼šè¿”å› âŒŠplkâŒ‹,âŒŠpl+1kâŒ‹,â‹¯ ,âŒŠprkâŒ‹\\left\\lfloor\\cfrac{p_l}k\\right\\rfloor,\\left\\lfloor\\cfrac{p_{l+1}}k\\right\\rfloor,\\cdots,\\left\\lfloor\\cfrac{p_r}k\\right\\rfloorâŒŠkplâ€‹â€‹âŒ‹,âŒŠkpl+1â€‹â€‹âŒ‹,â‹¯,âŒŠkprâ€‹â€‹âŒ‹ ä¸­ä¸åŒæ•°çš„ä¸ªæ•°ï¼Œéœ€è¦æ‰¾åˆ° 111 çš„ä½ç½®ã€‚äº¤äº’æ¬¡æ•°åˆ†åˆ«é™åˆ¶åœ¨ 30,25,2030,25,2030,25,20 æ¬¡ã€‚ è¯¢é—®èƒ½å‘Šè¯‰æˆ‘ä»¬ä»€ä¹ˆï¼Ÿå¥½å¥‡æ€ªå•Šï¼Œä¸çŸ¥é“ã€‚å°è¯•ä»ç»™å®šçš„ kkk å€¼å¼€å§‹åˆ†æã€‚k=1k=1k=1 æ²¡ä»€ä¹ˆæ„ä¹‰ï¼Œç„¶åå°è¯•ä»ç‰¹æ®Šçš„ï¼Œæ¯”å¦‚ k=2,nk=2,nk=2,n å¼€å§‹åˆ†æã€‚k=nk=nk=n æ¯”è¾ƒå¥½è¯´ï¼Œåªæœ‰ nnn å¯ä»¥è¢«è®°å…¥ç­”æ¡ˆï¼Œå¯ä»¥æ ¹æ®æ­¤æ‰¾å‡º nnn çš„ä½ç½®ã€‚k=2k=2k=2 åˆ™å¯ä»¥å°†æ•°åˆ†ä¸ºä¸¤ç»„ï¼Œåœ¨ nnn ä¸ºå¥‡æ•°æ—¶åªæœ‰ 111 æ˜¯å•ç‹¬ä¸€ç»„ï¼Œnnn ä¸ºå¶æ•°æ—¶åªæœ‰ 1,n1,n1,n æ˜¯å•ç‹¬ä¸€ç»„ã€‚ ä»åˆ«çš„åœ°æ–¹å†æƒ³ä¸€æƒ³ï¼Œéƒ½è¦æ±‚ logâ¡\\loglog çº§åˆ«çš„è¯¢é—®ï¼Œä¸éš¾æƒ³åˆ°äºŒåˆ†ã€‚è®¾ solve(l, r) ä»£è¡¨ç­”æ¡ˆåœ¨ [l,r][l,r][l,r] çš„ä½ç½®ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ç¡®å®š 111 åœ¨ [l,mid][l,mid][l,mid] è¿˜æ˜¯ [mid+1,r][mid+1,r][mid+1,r] é‡Œã€‚å’¦ï¼Œæ„Ÿè§‰ä¸å¤ªå¯¹ï¼Œä¸æ˜¯ä¸¥æ ¼çš„å­é—®é¢˜ï¼ä½†æ˜¯æˆ‘ä»¬åªéœ€è¦å¯»æ‰¾ç­”æ¡ˆåœ¨å“ªé‡Œï¼Œå› æ­¤åªéœ€è¦åˆ†åˆ«ç­”æ¡ˆåœ¨ [1,mid][1,mid][1,mid] è¿˜æ˜¯ [mid+1,n][mid+1,n][mid+1,n] å°±å¥½äº†ã€‚ é€‰æ‹©ä» k=2k=2k=2 å…¥æ‰‹ï¼Œx,yx,yx,y åˆ†ä¸ºä¸€ç»„ä»…å½“å®ƒä»¬é™¤ä»¥äºŒä¸‹å–æ•´åçš„å€¼ç›¸ç­‰ã€‚æˆ‘ä»¬å¯ä»¥æ±‚å‡ºä¸¤ä¸ªåŒºé—´ä¸­åœ¨è‡ªå·±åŒºé—´å†…æ²¡æœ‰åŒ¹é…çš„æ•°çš„æ•°é‡ï¼Œç„¶åè¿™ä¸ªæ•°é‡å¤§çš„ï¼Œç­”æ¡ˆå°±åœ¨é‚£é‡Œï¼ˆå› ä¸ºå‰©ä¸‹çš„æ¯æœ‰ä¸€ä¸ªéƒ½æ˜¯æˆå¯¹çš„ï¼‰ã€‚ nnn æ˜¯å¶æ•°æ€ä¹ˆåŠå‘¢ï¼Ÿæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ° nnn å°±è¡Œï¼Œä¸éš¾å‘ç° k=nk=nk=n å¯ä»¥å¾ˆå¥½çš„å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚å½“ä¸¤ä¸ªåŒºé—´çš„å€¼ç›¸ç­‰æ—¶ï¼Œè¯´æ˜ 1,n1,n1,n å„å ä¸€ä¸ªï¼Œæˆ‘ä»¬ä»¤ k=nk=nk=nï¼Œè¯¢é—®å…¶ä¸­ä¸€ä¸ªï¼Œçœ‹ nnn æ˜¯å¦åœ¨å…¶ä¸­ã€‚æ‰¾åˆ° nnn çš„ä½ç½®ä¹‹åå‘ç°ä¹‹åçš„é€’å½’ä¸ä¼šå—åˆ°å½±å“ï¼ˆå¦‚æœ pn&gt;midp_n&gt; midpnâ€‹&gt;midï¼Œæˆ‘ä»¬ä¼šé€’å½’åˆ° [l,mid][l,mid][l,mid]ï¼Œå¿…å®šæœ‰ pn&gt;midâ€²p_n&gt;mid&#x27;pnâ€‹&gt;midâ€²ï¼‰ã€‚ è¿™ä¸ªåšæ³•å¯ä»¥é€šè¿‡ G2ï¼Œä»£ç ã€‚æƒ³è¿‡æ‰ G3ï¼Œæˆ‘ä»¬éœ€è¦æƒ³æ–¹æ³•æ€æ‰é‚£ä¸€æ¬¡å¤šä½™çš„è¯¢é—®ã€‚ æ€ä¹ˆæ€ï¼Ÿå¯¹äº râˆ’l+1=2r-l+1=2râˆ’l+1=2 çš„æƒ…å†µï¼Œä½¿ç”¨ä¸¤æ¬¡è¯¢é—®æœ‰ç‚¹æ‰¯çš®ï¼Œæˆ‘ä»¬çœ‹èƒ½ä¸èƒ½åªç”¨ä¸€æ¬¡è¯¢é—®æ€æ‰å®ƒã€‚æ ¸å¿ƒæ€æƒ³æ˜¯ï¼Œå……åˆ†åˆ©ç”¨æˆ‘ä»¬ä¹‹å‰é—®å‡ºæ¥çš„ä¿¡æ¯ã€‚å½“æˆ‘ä»¬é€’å½’åˆ° [l,r][l,r][l,r] æ—¶ï¼Œæ›¾ä»¤ä¸€ä¸ª mid=lâˆ’1mid=l-1mid=lâˆ’1ï¼Œä¹Ÿä»¤äº†ä¸€ä¸ª mid=rmid=rmid=rï¼Œå› æ­¤æˆ‘ä»¬çŸ¥é“ Q(1,lâˆ’1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l-1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,lâˆ’1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2) çš„ç­”æ¡ˆã€‚ç°åœ¨ l,rl,rl,r ä¸­ä¸€ä¸ªæ˜¯ 111ï¼Œä¸€ä¸ªæ˜¯å’Œå…¶ä»–æ•°èƒ½åŒ¹é…ä¸Šçš„æŸä¸ªå¥‡æ€ªçš„ä¸œè¥¿ï¼Œå—ï¼Ÿæ³¨æ„ï¼Œå¦ä¸€ä¸ªå¯èƒ½æ˜¯ nnnï¼Œå¦‚æœæˆ‘ä»¬è¿˜æ²¡æœ‰ç¡®å®š nnn çš„ä½ç½®ï¼Œé‚£ä¹ˆé€šè¿‡è¯¢é—® Q(r,n,n)Q(r,n,n)Q(r,n,n) æˆ– Q(1,l,n)Q(1,l,n)Q(1,l,n) å°†å…¶åˆ¤æ‰ã€‚ ç°åœ¨å†çœ‹æ€ä¹ˆæ l,rl,rl,r ä¸€ä¸ªæ˜¯ 111ï¼Œå¦ä¸€ä¸ªæ˜¯å¯åŒ¹é…æ•°ã€‚å¯åŒ¹é…æ•°åªèƒ½é…åœ¨ [1,lâˆ’1][1,l-1][1,lâˆ’1] æˆ– [r+1,n][r+1,n][r+1,n]ï¼Œå¦‚æœ Q(1,lâˆ’1,2)+1=Q(1,r,2)Q(1,l-1,2)+1=Q(1,r,2)Q(1,lâˆ’1,2)+1=Q(1,r,2)ï¼Œé‚£ä¹ˆè¯´æ˜å¯åŒ¹é…æ•°çš„åŒ¹é…æ•°æ˜¯å¼€åœ¨ [1,lâˆ’1][1,l-1][1,lâˆ’1] çš„ï¼ˆè¿™ä¸ªæ•°é™¤ä»¥äºŒä¸‹å»æ•´çš„å€¼ä¸ [1,lâˆ’1][1,l-1][1,lâˆ’1] ä¸­çš„æŸä¸ªæ•°æ’äº†ï¼‰ï¼Œå¦åˆ™å¼€åœ¨ [r+1,n][r+1,n][r+1,n]ã€‚ç¡®å®šäº†è¿™ä¸€ç‚¹ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥é”å®š 111 çš„ä½ç½®äº†ï¼ä»¥å¼€åœ¨ [1,lâˆ’1][1,l-1][1,lâˆ’1] ä¸ºä¾‹ï¼Œå¦‚æœ Q(1,lâˆ’1,2)=Q(1,l,2)Q(1,l-1,2)=Q(1,l,2)Q(1,lâˆ’1,2)=Q(1,l,2)ï¼Œè¯´æ˜ lll å¤„å¼€å¯åŒ¹é…æ•°ï¼Œä¸ [1,lâˆ’1][1,l-1][1,lâˆ’1] ä¸­çš„æŸä¸ªæ•°åŒ¹é…ï¼Œ111 å°±å¼€åœ¨ rrr å¤„ã€‚ è¿™æ ·åœ¨ râˆ’l+1=2r-l+1=2râˆ’l+1=2 æ—¶æˆ‘ä»¬åªèŠ±è´¹äº†ä¸€æ¬¡è¯¢é—®ï¼Œå¯ä»¥é€šè¿‡ G3ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, flag; map&lt;pair&lt;int, int>, int> f; int query(int l, int r, int k) &#123; if (l >= r) return l == r; if (l == 1 &amp;&amp; r == n) return n / k + 1; if (k == 2 &amp;&amp; f.find(&#123;l, r&#125;) != f.end()) return f[&#123;l, r&#125;]; printf(\"? %d %d %d\\n\", l, r, k); fflush(stdout); int ans; scanf(\"%d\", &amp;ans); if (k == 2) f[&#123;l, r&#125;] = ans; return ans; &#125; int solve(int l, int r) &#123; if (l == r) return l; if (n % 2 == 0 &amp;&amp; r - l + 1 == 2) &#123; if (!flag) &#123; if (r &lt; n) return query(r, n, n) == 2 ? l : r; return query(1, l, n) == 2 ? r : l; &#125; if (query(1, r, 2) - query(1, l - 1, 2) == 1) &#123; // ä¸é 1 æ•°çš„åŒ¹é…åœ¨ [1, l-1] int x = query(1, l - 1, 2), y = query(1, l, 2); if (x + 1 == y) return l; return r; &#125; else &#123; int x = query(r + 1, n, 2), y = query(r, n, 2); if (x + 1 == y) return r; return l; &#125; &#125; int mid = l + r >> 1; int L = 2 * query(1, mid, 2) - mid; int R = 2 * query(mid + 1, n, 2) - (n - mid); if (n % 2 == 0) &#123; if (!flag) &#123; if (L == R) &#123; bool con = 0; if (mid > 1 &amp;&amp; query(1, mid, n) == 2) con = 1; if (con) flag = 1, --L; else flag = -1, --R; &#125; &#125; else &#123; if (flag == 1) --L; else --R; &#125; &#125; return L > R ? solve(l, mid) : solve(mid + 1, r); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); return !printf(\"! %d\\n\", solve(1, n)); &#125; [CF1764E] Joking E1ï¼ŒE2ã€‚ç»™å®š nnnï¼ŒçŒœå‡ºä¸€ä¸ªæ•´æ•° xxxã€‚å¯ä»¥è¯¢é—®ä¸€ä¸ªé›†åˆ SSSï¼Œäº¤äº’åº“ä¼šå›ç­” xxx æ˜¯å¦å±äº SSSã€‚ä½†äº¤äº’åº“æ˜¯ä¸ªéª—å­ï¼Œå®ƒåªä¿è¯è¿ç»­ä¸¤æ¬¡è¯¢é—®çš„å›ç­”åªè‡³å°‘æœ‰ä¸€æ¬¡æ˜¯çœŸçš„ã€‚æœ€å¤šå¯ä»¥çŒœæµ‹ä¸¤æ¬¡ç­”æ¡ˆï¼Œnâ‰¤105n\\le 10^5nâ‰¤105ï¼Œäº¤äº’æ¬¡æ•°åˆ†åˆ«é™åˆ¶åœ¨ 82,5382,5382,53 æ¬¡ã€‚äº¤äº’åº“è‡ªé€‚åº”ã€‚ ä¸€ä¸ªç¬¨è›‹åšæ³•æ˜¯ï¼Œä¸€ä¸ªè¯¢é—®è¿ç»­è¯¢é—®ä¸¤æ¬¡ã€‚å›ç­”ç›¸åŒåˆ™ä¸€å®šæ˜¯çœŸçš„ï¼Œä½†æ˜¯ä¸åŒå°±æ­»äº†ã€‚ å› æ­¤è€ƒè™‘å°†å›ç­”å…¨éƒ¨å˜æˆ YESã€‚å¾ˆç®€å•ï¼Œå¦‚æœå›ç­”çš„æ˜¯ NOï¼Œé‚£ä¹ˆç›¸å½“äºæˆ‘ä»¬è¯¢é—®äº†ä¸€ä¸ªè¡¥é›†ã€‚ ç”±äºè¿ç»­ä¸¤æ¬¡è¯¢é—® S,TS,TS,Tï¼Œä¸å¯èƒ½éƒ½ä¸ºå‡ï¼Œå› æ­¤ xxx åœ¨ SâˆªTS\\cup TSâˆªT é‡Œã€‚ é—®é¢˜æ˜¯å¦‚ä½•é€‰æ‹©åˆé€‚çš„ S,TS,TS,Tï¼Œæœ€å°åŒ–å¹¶é›†çš„æœ€å¤§å€¼ï¼Œä¹Ÿå°±æ˜¯æœ€å¤§åŒ– Sâˆ©T,Sâ€¾âˆ©T,Sâˆ©Tâ€¾,Sâ€¾âˆ©Tâ€¾S\\cap T, \\overline{S}\\cap T,S\\cap \\overline{T},\\overline{S}\\cap \\overline{T}Sâˆ©T,Sâˆ©T,Sâˆ©T,Sâˆ©T çš„æœ€å°å€¼ã€‚ é‚£ä¹ˆæˆ‘ä»¬å°† UUU å¹³å‡åˆ†æˆ U1,U2,U3,U4U_1,U_2,U_3,U_4U1â€‹,U2â€‹,U3â€‹,U4â€‹ï¼Œä»¤ S=U1âˆªU2,T=U3âˆªU4S=U_1\\cup U_2,T=U_3\\cup U_4S=U1â€‹âˆªU2â€‹,T=U3â€‹âˆªU4â€‹ å³å¯ã€‚ æœ€åéœ€è¦ç‰¹åˆ¤ n=3n=3n=3ï¼Œå¾—ç›Šäºæˆ‘ä»¬å¯ä»¥çŒœæµ‹ä¸¤æ¬¡ï¼Œå› æ­¤åªè¦ä½¿ç”¨ä¸¤æ¬¡æˆ–ä¸‰æ¬¡è¯¢é—®åˆ¤æ‰ä¸€ä¸ªæˆ–è€…ä¸¤ä¸ªåé—®ä¸¤æ¬¡å³å¯ã€‚å¯ä»¥é€šè¿‡ E1ã€‚ é—®é¢˜å‡ºåœ¨äº†å“ªé‡Œï¼Ÿä¸Šä¸€è½®çš„ TTT å’Œè¿™ä¸€è½®çš„ SSS çš„æ€§è´¨æˆ‘ä»¬æ²¡æœ‰ç”¨åˆ°ã€‚ å‡å®šå…¨é›†ä¸º UUUï¼Œä¸Šä¸€æ¬¡äº¤äº’åº“å‘Šè¯‰æˆ‘ä»¬ xâˆˆSx\\in SxâˆˆSï¼Œä»¤ T=âˆUST=\\complement_{U}ST=âˆUâ€‹Sï¼Œé‚£ä¹ˆæˆ‘ä»¬è¯¢é—®çš„æ˜¯ S0âˆªT0S_0\\cup T_0S0â€‹âˆªT0â€‹ æ»¡è¶³ S0âŠ‚S,T0âŠ‚T,S1=âˆSS0,T1=âˆTT0S_0\\subset S,T_0\\subset T,S_1=\\complement_{S}S_0,T_1=\\complement_{T}T_0S0â€‹âŠ‚S,T0â€‹âŠ‚T,S1â€‹=âˆSâ€‹S0â€‹,T1â€‹=âˆTâ€‹T0â€‹ï¼Œå¦‚æœå›ç­”äº† YESï¼Œé‚£ä¹ˆ UUU å°±å–ä¸åˆ° T1T_1T1â€‹ äº†ã€‚ è€ƒè™‘ DP è®¡ç®—å‡ºæœ€ä¼˜çš„åˆ’åˆ†æ–¹å¼ã€‚è®¾ fi,jf_{i,j}fi,jâ€‹ ä»£è¡¨ âˆ£Sâˆ£=i,âˆ£Tâˆ£=j|S|=i,|T|=jâˆ£Sâˆ£=i,âˆ£Tâˆ£=j çš„æ¬¡æ•°ï¼Œåˆå§‹ âˆ€i+jâ‰¤2,fi,j=0\\forall i+j\\le 2, f_{i,j}=0âˆ€i+jâ‰¤2,fi,jâ€‹=0ï¼ˆç›´æ¥é—®ç­”æ¡ˆå°±è¡Œäº†ï¼‰ï¼Œè½¬ç§»ï¼š fi,j=1+minâ¡0â‰¤xâ‰¤i,0â‰¤yâ‰¤jmaxâ¡{fx+y,iâˆ’c,fi+jâˆ’xâˆ’y,x}f_{i,j}=1+\\min_{0\\le x\\le i,0\\le y\\le j}\\max\\{f_{x+y,i-c},f_{i+j-x-y,x}\\} fi,jâ€‹=1+0â‰¤xâ‰¤i,0â‰¤yâ‰¤jminâ€‹max{fx+y,iâˆ’câ€‹,fi+jâˆ’xâˆ’y,xâ€‹} å‰è€…æ˜¯å›ç­” YES æ—¶æ–°çš„ SSS ä¸º S0âˆªT0S_0\\cup T_0S0â€‹âˆªT0â€‹ï¼Œæ–°çš„ TTT ä¸º S1S_1S1â€‹ï¼›åè€…æ˜¯å›ç­” NO æ—¶æ–°çš„ SSS ä¸º S1âˆªT1S_1\\cup T_1S1â€‹âˆªT1â€‹ï¼Œæ–°çš„ TTT ä¸º S0S_0S0â€‹ã€‚ æ¯”è¾ƒå¤§çš„æ—¶å€™ç›´æ¥æŠ˜åŠæ˜¯å¾ˆä¼˜ç§€çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef vector&lt;int> VI; const int N = 100; int n; int f[105][105], x[105][105], y[105][105]; int main(void) &#123; ios::sync_with_stdio(0); memset(f, 0x3f, sizeof(f)); for (int s = 0; s &lt;= N; ++s) for (int i = 0; i &lt;= s; ++i) &#123; int j = s - i; if (s &lt;= 2) &#123; f[i][j] = 0; continue; &#125; for (int x = 0; x &lt;= i; ++x) for (int y = 0; y &lt;= j; ++y) &#123; int v = max(f[x + y][i - x], f[s - x - y][x]) + 1; if (v &lt; f[i][j]) f[i][j] = v, ::x[i][j] = x, ::y[i][j] = y; &#125; &#125; cin >> n; VI S, T; for (int i = 1; i &lt;= n; ++i) S.push_back(i); while (S.size() + T.size() > 2) &#123; int x = S.size() / 2, y = T.size() / 2; if (S.size() + T.size() &lt;= N) x = ::x[S.size()][T.size()], y = ::y[S.size()][T.size()]; VI S0(S.begin(), S.begin() + x); VI S1(S.begin() + x, S.end()); VI T0(T.begin(), T.begin() + y); VI T1(T.begin() + y, T.end()); cout &lt;&lt; \"? \" &lt;&lt; S0.size() + T0.size() &lt;&lt; \" \"; for (int i : S0) cout &lt;&lt; i &lt;&lt; \" \"; for (int i : T0) cout &lt;&lt; i &lt;&lt; \" \"; cout &lt;&lt; endl; string res; cin >> res; S.clear(), T.clear(); if (res == \"YES\") &#123; for (int i : S0) S.push_back(i); for (int i : T0) S.push_back(i); for (int i : S1) T.push_back(i); &#125; else &#123; for (int i : S1) S.push_back(i); for (int i : T1) S.push_back(i); for (int i : S0) T.push_back(i); &#125; &#125; for (int i : T) S.emplace_back(i); for (int i : S) &#123; cout &lt;&lt; \"! \" &lt;&lt; i &lt;&lt; endl; string res; cin >> res; if (res == \":)\") return 0; &#125; return 0; &#125; è¿™ä¸€ç‚¹ä¸ä¸€å®šï¼Œåœ¨ NOI2022 D1T3 ä¸­ï¼Œå°±åªä¸‹å‘äº†ä¸€ä¸ª grader.cpp ç¼–è¯‘åçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œè¿™æ ·ä¼šæ˜¾è‘—å¢åŠ éš¾åº¦ï¼Œå› ä¸ºä½ ä¸å†èƒ½æ‰“å¼€ grader æºæ–‡ä»¶æ¥è°ƒè¯•æˆ–è€…å¯»æ‰¾æ€è·¯äº†ã€‚ â†©ï¸","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"æäº¤ç­”æ¡ˆ","slug":"æäº¤ç­”æ¡ˆ","permalink":"https://james1badcreeper.github.io/tags/%E6%8F%90%E4%BA%A4%E7%AD%94%E6%A1%88/"},{"name":"äº¤äº’é¢˜","slug":"äº¤äº’é¢˜","permalink":"https://james1badcreeper.github.io/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/"},{"name":"æ„é€ ","slug":"æ„é€ ","permalink":"https://james1badcreeper.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"éšæœºåŒ–","slug":"éšæœºåŒ–","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"}]},{"title":"å­—ç¬¦ä¸²ä¸è‡ªåŠ¨æœº","slug":"notes/å­—ç¬¦ä¸²/string-dfa","date":"2022-12-06T00:00:00.000Z","updated":"2022-12-06T00:00:00.000Z","comments":true,"path":"71e30681/","link":"","permalink":"https://james1badcreeper.github.io/71e30681/","excerpt":"é«˜çº§çš„å­—ç¬¦ä¸²ç®—æ³•å‡ ä¹éƒ½ä¸ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µï¼šç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼ˆDFAï¼‰æœ‰å…³ã€‚è¿™æ˜¯ä¸€ç§é‡è¦çš„æ•°å­¦æ¨¡å‹ã€‚","text":"é«˜çº§çš„å­—ç¬¦ä¸²ç®—æ³•å‡ ä¹éƒ½ä¸ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µï¼šç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼ˆDFAï¼‰æœ‰å…³ã€‚è¿™æ˜¯ä¸€ç§é‡è¦çš„æ•°å­¦æ¨¡å‹ã€‚ æ¦‚è¿° è¿™é‡Œåªè®²ä¸€äº›æ¦‚å¿µï¼Œä½†æ˜¯éå¸¸æœ‰ç”¨ã€‚ OI ä¸­çš„è‡ªåŠ¨æœºä¸€èˆ¬æŒ‡ç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼ˆDFAï¼‰ã€‚è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªå¯¹ä¿¡å·åºåˆ—è¿›è¡Œåˆ¤å®šçš„æ•°å­¦æ¨¡å‹ã€‚â€œä¿¡å·åºåˆ—â€æŒ‡çš„æ˜¯ä¸€è¿ä¸²æœ‰é¡ºåºçš„ä¿¡å·ï¼Œæ¯”å¦‚å­—ç¬¦ä¸²ä»å‰åˆ°åçš„æ¯ä¸€ä¸ªå­—ç¬¦ã€‚â€œåˆ¤å®šâ€æ˜¯å¯¹å‘½é¢˜åšå‡ºçœŸå‡å›ç­”ï¼Œæ¯”å¦‚åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²ã€‚ ä¸€ä¸ª DFA å¯ä»¥è¢«æŠ½è±¡æˆä¸€å¼ æœ‰å‘å›¾ï¼Œç”±äº”å…ƒç»„ (Î£,Q,s,F,Î´)(\\Sigma, Q, s, F, \\delta)(Î£,Q,s,F,Î´) æ„æˆï¼š å­—ç¬¦é›† Î£\\SigmaÎ£ï¼Œè¯¥è‡ªåŠ¨æœºåªèƒ½è¾“å…¥è¿™äº›å­—ç¬¦ï¼› çŠ¶æ€é›†åˆ QQQï¼ŒçŠ¶æ€ç›¸å½“äºå›¾ä¸Šçš„é¡¶ç‚¹ï¼› èµ·å§‹çŠ¶æ€ sssï¼ˆä¹Ÿå¯ä»¥è®°ä½œ startstartstartï¼‰ï¼ŒstartâˆˆQstart\\in QstartâˆˆQï¼› æ¥å—çŠ¶æ€é›†åˆ FFFï¼ŒFâŠ†QF\\subseteq QFâŠ†Qï¼› è½¬ç§»å‡½æ•° Î´\\deltaÎ´ï¼ŒÎ´\\deltaÎ´ æ¥å—ä¸€ä¸ªçŠ¶æ€å’Œä¸€ä¸ªå­—ç¬¦ï¼Œè¿”å›ä¸€ä¸ªçŠ¶æ€ï¼Œè½¬ç§»å‡½æ•°ç›¸å½“äºæœ‰å‘å›¾ä¸Šçš„è¾¹ï¼Œè¾¹çš„æƒå€¼æ˜¯å­—ç¬¦ã€‚ DFA å¯ä»¥è¯†åˆ«å­—ç¬¦ä¸²ã€‚è‡ªåŠ¨æœº AAA å¦‚æœèƒ½è¯†åˆ« SSSï¼Œé‚£ä¹ˆ A(S)=TrueA(S)=TrueA(S)=Trueã€‚DFA è¯»å…¥å­—ç¬¦ä¸²æ—¶ï¼Œä»åˆå§‹çŠ¶æ€èµ·æŒ‰ç…§è½¬ç§»å‡½æ•°ä¸€ä¸ªä¸€ä¸ªå­—ç¬¦åœ°è½¬ç§»ã€‚å¦‚æœæœæ›¼ä¸€ä¸ªå­—ç¬¦ä¸²åœ°æ‰€æœ‰å­—ç¬¦ååˆ°è¾¾äº† FFF ä¸­çš„ä¸€ä¸ªç‚¹ï¼Œé‚£ä¹ˆ DFA å°±è¯†åˆ«äº†è¿™ä¸ªå­—ç¬¦ä¸²ã€‚ æ¯”å¦‚è¯´ Trie å°±æ˜¯ä¸€ä¸ªè‡ªåŠ¨æœºï¼Œæ¯ä¸€æ¡è¾¹éƒ½æ˜¯è½¬ç§»å‡½æ•°ï¼ŒFFF æ˜¯æ ‡è®°ä¸ºå­—ç¬¦ä¸²çš„èŠ‚ç‚¹é›†åˆã€‚ KMP è‡ªåŠ¨æœº KMP è‡ªåŠ¨æœºçš„çŠ¶æ€é›†åˆ QQQ ä¸º 0âˆ¼âˆ£Sâˆ£0\\sim |S|0âˆ¼âˆ£Sâˆ£ï¼Œå¦‚æœå½“å‰è¯†åˆ«çš„å­—ç¬¦ä¸²ä¸º tttï¼Œé‚£ä¹ˆæ¯ä¸ªèŠ‚ç‚¹ iii è¡¨ç¤ºå·²ç»è¾“å…¥çš„æ‰€æœ‰å­—ç¬¦ t[1â€¦p]t[1\\dots p]t[1â€¦p] ä¸ sss çš„æœ€å¤§åŒ¹é…é•¿åº¦ä¸º iiiï¼Œå³æ»¡è¶³ s[pâˆ’i+1,p]=s[1,i]s[p-i+1,p]=s[1,i]s[pâˆ’i+1,p]=s[1,i]ï¼Œè½¬ç§»å‡½æ•°ä¸ºï¼š Î´(i,c)={i+1,si+1=c,0,si+1â‰ câˆ§i=0,Î´(nxti,c),si+1â‰ câˆ§iâ‰ 0.\\delta(i, c) = \\begin{cases} i+1 ,&amp; s_{i + 1} = c, \\\\ 0 ,&amp; s_{i + 1} \\neq c \\land i = 0, \\\\ \\delta(nxt_i, c) ,&amp; s_{i + 1} \\neq c \\land i \\neq 0. \\\\ \\end{cases} Î´(i,c)=â©â¨â§â€‹i+1,0,Î´(nxtiâ€‹,c),â€‹si+1â€‹=c,si+1â€‹î€ =câˆ§i=0,si+1â€‹î€ =câˆ§iî€ =0.â€‹ int tr[1005][26]; for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt; 26; ++j) &#123; if (i &lt; n &amp;&amp; s[i + 1] == j + 'a') tr[i][j] = i + 1; else if (i) tr[i][j] = tr[nxt[i]][j]; &#125; AC è‡ªåŠ¨æœºï¼ˆACAMï¼‰ å®ƒç”¨äºè§£å†³å¤šæ¨¡å¼ä¸² åç¼€è‡ªåŠ¨æœºï¼ˆSAMï¼‰ å›æ–‡è‡ªåŠ¨æœºï¼ˆPAMï¼‰","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"å­—ç¬¦ä¸²","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/å­—ç¬¦ä¸²","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"https://james1badcreeper.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"é¢˜ç›®é€‰åš","slug":"default/old/11problems","date":"2022-12-01T00:00:00.000Z","updated":"2022-12-01T00:00:00.000Z","comments":true,"path":"75849b25/","link":"","permalink":"https://james1badcreeper.github.io/75849b25/","excerpt":"é¢“ä¸€ç‚¹é¢˜ï¼","text":"é¢“ä¸€ç‚¹é¢˜ï¼ æ¨¡æ‹Ÿ æ¨¡æ‹Ÿã€‚ æ•°å­¦æ¨¡æ‹Ÿ æœ‰æ•°çš„æ¨¡æ‹Ÿã€‚ [UVA11582] Colossal Fibonacci Numbers! Portal. å¯»æ‰¾å¾ªç¯èŠ‚ï¼ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef unsigned long long u64; int poww(u64 a, u64 b, int MOD) &#123; a %= MOD; int res = 1; while (b) &#123; if (b &amp; 1) res = res * a % MOD; a = a * a % MOD; b >>= 1; &#125; return res % MOD; &#125; int n, f[1000010] = &#123;0, 1, 1&#125;; u64 a, b; void MAIN(void) &#123; scanf(\"%llu%llu%d\", &amp;a, &amp;b, &amp;n); if (n == 1 || a == 0) return puts(\"0\"), void(); for (int i = 3;; ++i) &#123; f[i] = (f[i - 1] + f[i - 2]) % n; if (f[i] == 1 &amp;&amp; f[i - 1] == 1) &#123; printf(\"%d\\n\", f[poww(a, b, i - 2)]); return; &#125; &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) MAIN(); return 0; &#125; [UVA12716] GCD XOR Portal. æ‰“è¡¨æ‰¾è§„å¾‹å‘ç° gcdâ¡(a,b)=a xor b=câŸ¹c=aâˆ’b\\gcd(a,b)=a\\text{ xor } b=c\\Longrightarrow c=a-bgcd(a,b)=a xor b=câŸ¹c=aâˆ’bï¼Œå› æ­¤æšä¸¾ a,ca,ca,cï¼ŒéªŒè¯ bbb å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int N = 3e7; int f[N + 5]; int main(void) &#123; for (int c = 1; c &lt;= N / 2; ++c) for (int a = 2 * c; a &lt;= N; a += c) &#123; int b = a - c; if ((a ^ b) == c) ++f[a]; &#125; for (int i = 2; i &lt;= N; ++i) f[i] += f[i - 1]; int T; scanf(\"%d\", &amp;T); for (int kase = 1; kase &lt;= T; ++kase) &#123; int x; scanf(\"%d\", &amp;x); printf(\"Case %d: %d\\n\", kase, f[x]); &#125; return 0; &#125; [è“æ¡¥æ¯ 2022 å›½ C] å–æ¨¡ Portal. ç»™å®š n,m(â‰¤109)n, m(\\le 10^9)n,m(â‰¤109)ï¼Œé—®æ˜¯å¦å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„æ•° x,yx,yx,y ä½¿å¾— 1â‰¤x&lt;yâ‰¤m1 \\le x &lt; y \\le m1â‰¤x&lt;yâ‰¤m ä¸” n mod x=n mod â¡yn \\bmod x = n \\bmod â¡ynmodx=nmodâ¡yã€‚ å®é™…ä¸Šç›´æ¥æšä¸¾å³å¯ï¼Œå¯ä»¥è¯æ˜ç­”æ¡ˆä¸ä¼šå¾ˆå¤§ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;set> using namespace std; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); bool flag = false; set &lt;int> s; for (int i = 1; i &lt;= m; ++i) if (s.count(n % i)) &#123; flag = true; break; &#125; else s.insert(n % i); puts(flag ? \"Yes\" : \"No\"); &#125; return 0; &#125; [UVA11489] Interger Game Portal. å’Œæ˜¯ 333 çš„å€æ•°ï¼ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int main(void) &#123; int T, n; static char s[1005]; scanf(\"%d\", &amp;T); for (int kase = 1; kase &lt;= T; ++kase) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); if (n == 1) &#123; printf(\"Case %d: S\\n\", kase); continue; &#125; int cnt = 0, res = 0; for (int i = 1; i &lt;= n; ++i) &#123; s[i] -= '0'; res += s[i]; cnt += (s[i] % 3 == 0); &#125; bool flag = false; for (int i = 1; i &lt;= n; ++i) if ((res - s[i]) % 3 == 0) &#123; if (s[i] % 3 == 0) cnt -= 1; flag = true; break; &#125; if (!flag || cnt % 2) printf(\"Case %d: T\\n\", kase); else printf(\"Case %d: S\\n\", kase); &#125; return 0; &#125; å¥‡æ€ªçš„æ¨¡æ‹Ÿ æ— æ³•åˆ†ç±»ã€‚ [CSP-S 2022] ç­–ç•¥æ¸¸æˆ Portal. å¤§å‹åˆ†ç±»è®¨è®ºç°åœºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const i64 INF = 2e18; int n, m, q; int a[100005], b[100005]; namespace Subtask2 &#123; const int INF = 2e9; struct Node &#123; int minn, maxx; int maxmi, minp; Node() : minn(INF), maxx(-INF), maxmi(-INF), minp(INF) &#123;&#125; &#125;; inline Node hb(const Node &amp;a, const Node &amp;b) &#123; Node c; c.minn = min(a.minn, b.minn); c.maxx = max(a.maxx, b.maxx); c.maxmi = max(a.maxmi, b.maxmi); c.minp = min(a.minp, b.minp); return c; &#125; struct SegmentTree &#123; Node T[400005]; int *v; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].minn = T[o].maxx = v[l]; if (v[l] >= 0) T[o].minp = v[l]; if (v[l] &lt;= 0) T[o].maxmi = v[l]; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; Node res; if (x &lt;= mid) res = hb(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = hb(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; &#125;A, B; void MAIN(void) &#123; A.v = a, B.v = b; A.build(1, 1, n); B.build(1, 1, n); while (q--) &#123; int l1, r1, l2, r2; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); Node x = A.query(1, 1, n, l1, r1), y = B.query(1, 1, n, l2, r2); i64 ans = -2e18; ans = max(ans, 1ll * x.maxx * (x.maxx >= 0 ? y.minn : y.maxx)); ans = max(ans, 1ll * x.minn * (x.minn >= 0 ? y.minn : y.maxx)); if (x.minp != INF) ans = max(ans, 1ll * x.minp * y.minn); if (x.maxmi != -INF) ans = max(ans, 1ll * x.maxmi * y.maxx); printf(\"%lld\\n\", ans); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", b + i); Subtask2::MAIN(); return 0; &#125; [EER2] è°”è¿ç®— Portal. ä½è¿ç®—å¯ä»¥æŒ‰ä½è¿›è¡Œè®¨è®ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; uint n, x, ans = 0; uint a[35]; int main(void) &#123; scanf(\"%u\", &amp;n); uint tot = n * n; for (uint i = 1; i &lt;= n; ++i) &#123; scanf(\"%u\", &amp;x); for (int j = 0; j &lt; 32; ++j) if ((x >> j) &amp; 1) ++a[j]; &#125; for (uint i = 0; i &lt; 32; ++i) &#123; uint x = a[i] * a[i], y = (n - a[i]) * (n - a[i]); ans += (x * y + (tot - x) * (tot - y)) &lt;&lt; i; &#125; printf(\"%u\\n\", ans); return 0; &#125; DP åŠ¨æ€è§„åˆ’ã€‚ ç®€å• DP å¤§æ¦‚æ˜¯ KH 114514âˆ’1919810ms114514^{-1919810}\\text{ms}114514âˆ’1919810ms ä¸€é“çš„éš¾åº¦ã€‚ [UVA10003] Cutting Sticks Portal. åŒºé—´ DP æ¨¡æ¿ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int l, n; int a[55], f[55][55]; int main(void) &#123; while (scanf(\"%d\", &amp;l) == 1 &amp;&amp; l) &#123; scanf(\"%d\", &amp;n); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); a[n + 1] = l; for (int len = 2; len &lt;= n + 2; ++len) for (int i = 0; i &lt;= n - len + 2; ++i) &#123; int j = i + len - 1; if (len == 2) &#123; f[i][j] = 0; continue; &#125; for (int k = i + 1; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k][j]); f[i][j] += a[j] - a[i]; &#125; printf(\"The minimum cutting is %d.\\n\", f[0][n + 1]); &#125; return 0; &#125; [UVA1626] Brackets sequence Portal. è¿˜æ˜¯åŒºé—´ DP æ¨¡æ¿ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; char s[110]; int f[105][105]; bool check(int i, int j) &#123; if (s[i] == '(' &amp;&amp; s[j] == ')') return true; return s[i] == '[' &amp;&amp; s[j] == ']'; &#125; void print(int i, int j) &#123; if (i > j) return; if (i == j) &#123; if (s[i] == '(' || s[i] == ')') printf(\"()\"); else printf(\"[]\"); return; &#125; int ans = f[i][j]; if (check(i, j) &amp;&amp; ans == f[i + 1][j - 1]) &#123; printf(\"%c\", s[i]); print(i + 1, j - 1); printf(\"%c\", s[j]); return; &#125; for (int k = i; k &lt; j; ++k) if (ans == f[i][k] + f[k + 1][j]) &#123; print(i, k); print(k + 1, j); return; &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); fgets(s, 105, stdin); while (T--) &#123; fgets_unlocked(s + 1, 105, stdin); fgets_unlocked(s + 1, 105, stdin); n = strlen(s + 1) - 1; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) f[i][i] = 1, f[i + 1][i] = 0; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = len; if (check(i, j)) f[i][j] = min(f[i][j], f[i + 1][j - 1]); for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); &#125; print(1, n); putchar('\\n'); if (T) putchar('\\n'); &#125; return 0; &#125; [EER2] ç›´æ¥è‡ªç„¶æº¢å‡ºå•¥äº‹æ²¡æœ‰ Portal. ä¾ç…§é¢˜æ„è®¡æ•°å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef unsigned long long ull; int n; ull f[10005][5]; // 0: è¯­å¥ // 1: ç¨‹åºç‰‡æ®µ // 2: è¯­å¥å— // 3: å‡½æ•° // 4: å€¼ int main(void) &#123; scanf(\"%d\", &amp;n); f[0][1] = f[1][0] = f[1][1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; f[i][2] = f[i - 2][1]; f[i][3] = f[i - 2][2] + f[i - 2][3]; if (i >= 4) f[i][3] += f[i - 4][2]; f[i][4] = f[i][3] + f[i - 2][4]; f[i][0] = f[i][2] + f[i - 1][4]; for (int j = 0; j &lt; i; ++j) f[i][1] += f[j][1] * f[i - j][0]; &#125; printf(\"%llu\\n\", f[n][1]); return 0; &#125; å›¾è®º å›¾è®ºã€‚ æ ‘ æ ‘å½¢é—®é¢˜ã€‚ [APIO2007] é£é“ƒ Portal. æ ‘ä¸Šæ·±åº¦ä¼˜å…ˆéå†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int INF = 1e9; int n, maxdep = -INF, mindep = INF; int a[100005][2]; void dfs(int x, int dep) &#123; if (x == -1) return mindep = min(dep, mindep), maxdep = max(dep, maxdep), void(); dfs(a[x][0], dep + 1); dfs(a[x][1], dep + 1); &#125; bool flag = false; int ans = 0; int solve(int o, int dep) &#123; // 0 å…¨æµ…ï¼Œ1 å…¨æ·±ï¼Œ2 éƒ½æœ‰ if (o == -1) return dep != mindep; int x = solve(a[o][0], dep + 1), y = solve(a[o][1], dep + 1); ans += ((x == 0 &amp;&amp; y) || (x == 2 &amp;&amp; y == 1)); // å¦‚æœå·¦é¢å…¨æµ…ï¼Œæˆ–è€…å³é¢å…¨èº«ï¼Œéœ€è¦ä¸€æ¬¡ if (x == 2 &amp;&amp; y == 2) exit((puts(\"-1\"), 0)); // ä¸¤ä¸ªéƒ½æ˜¯éƒ½æœ‰ï¼ŒGG if (x == 2 || y == 2 || x + y == 1) return 2; if (x + y == 0) return 0; return 1; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;a[i][0], &amp;a[i][1]); dfs(1, 0); if (maxdep == mindep) return puts(\"0\"), 0; if (maxdep - mindep > 1) return puts(\"-1\"), 0; solve(1, 0); printf(\"%d\\n\", ans); return 0; &#125; æ•°å­¦ æ•°å­¦é¢˜ã€‚ æ•°è®º ç”¨åˆ°æ•°è®ºçŸ¥è¯†çš„ç®€å•é¢˜ã€‚ [UVA10791] Minimum Sum LCM Portal. å”¯ä¸€åˆ†è§£å®šç†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef unsigned long long u64; u64 n, kase = 0; u64 calc(void) &#123; if (n == 1) return 2; u64 ans = 0, flag = 0; for (u64 i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; u64 res = 1; while (n % i == 0) res *= i, n /= i; ans += res; flag++; &#125; if (n > 1) ans += n, ++flag; return ans + (flag == 1); &#125; int main(void) &#123; while (scanf(\"%llu\", &amp;n) == 1 &amp;&amp; n) printf(\"Case %llu: %llu\\n\", ++kase, calc()); return 0; &#125; æ•°å­¦æ¨å¯¼ æ•°å­¦æ¨å¯¼ã€‚ ã€ŒSWTR-6ã€GCDs &amp; LCMs Portal. æœ‰ y&lt;x+y+(x,y)=[x,y]=2y&lt;3yy&lt;x+y+(x,y)=[x,y]=2y&lt;3yy&lt;x+y+(x,y)=[x,y]=2y&lt;3yï¼Œå› æ­¤ 2y(x,y)=xy2y(x,y)=xy2y(x,y)=xyï¼Œæ‰€ä»¥ y=1.5xy=1.5xy=1.5xï¼Œæ ¹æ®æ­¤æ¨¡æ‹Ÿå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;map> using namespace std; typedef long long i64; int n; int a[300005]; map&lt;int, int> s; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), s[a[i]] += 1; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int tmp = a[i]; i64 cnt = 0; while (s[tmp]) &#123; cnt += 1ll * tmp * s[tmp]; if (tmp % 2 == 0) tmp = tmp / 2 * 3; else break; &#125; ans = max(ans, cnt); &#125; printf(\"%lld\\n\", ans); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"åˆ·","slug":"åˆ·","permalink":"https://james1badcreeper.github.io/tags/%E5%88%B7/"}]},{"title":"ç®€å•å­—ç¬¦ä¸²","slug":"notes/å­—ç¬¦ä¸²/string","date":"2022-11-28T00:00:00.000Z","updated":"2022-11-28T00:00:00.000Z","comments":true,"path":"f51e608c/","link":"","permalink":"https://james1badcreeper.github.io/f51e608c/","excerpt":"å­—ç¬¦ä¸²ï¼Œå°±æ˜¯ç”±å­—ç¬¦è¿æ¥è€Œæˆçš„åºåˆ—ã€‚å¸¸è§çš„å­—ç¬¦ä¸²é—®é¢˜åŒ…æ‹¬å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜ã€å­ä¸²ç›¸å…³é—®é¢˜ã€å‰ç¼€/åç¼€ç›¸å…³é—®é¢˜ã€å›æ–‡ä¸²ç›¸å…³é—®é¢˜ã€å­åºåˆ—ç›¸å…³é—®é¢˜ç­‰ã€‚å…·æœ‰å¾ˆé«˜çš„å·¥ç¨‹ä»·å€¼ï¼Œæ¯”å¦‚æœç´¢å¼•æ“ã€‚æœ¬æ–‡å°†ä»‹ç»ç®€å•çš„å­—ç¬¦ä¸²çŸ¥è¯†ã€‚","text":"å­—ç¬¦ä¸²ï¼Œå°±æ˜¯ç”±å­—ç¬¦è¿æ¥è€Œæˆçš„åºåˆ—ã€‚å¸¸è§çš„å­—ç¬¦ä¸²é—®é¢˜åŒ…æ‹¬å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜ã€å­ä¸²ç›¸å…³é—®é¢˜ã€å‰ç¼€/åç¼€ç›¸å…³é—®é¢˜ã€å›æ–‡ä¸²ç›¸å…³é—®é¢˜ã€å­åºåˆ—ç›¸å…³é—®é¢˜ç­‰ã€‚å…·æœ‰å¾ˆé«˜çš„å·¥ç¨‹ä»·å€¼ï¼Œæ¯”å¦‚æœç´¢å¼•æ“ã€‚æœ¬æ–‡å°†ä»‹ç»ç®€å•çš„å­—ç¬¦ä¸²çŸ¥è¯†ã€‚ ç®€å•å†…å®¹ è¿™é‡Œæ˜¯ä¸€äº›æ¦‚å¿µã€‚ å®šä¹‰ ä¸€ä¸ªå­—ç¬¦é›† Î£\\SigmaÎ£ æ˜¯ä¸€ä¸ªå»ºç«‹äº†å…¨åºå…³ç³»çš„é›†åˆï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒÎ£\\SigmaÎ£ ä¸­çš„ä»»æ„ä¸¤ä¸ªä¸åŒå…ƒç´  Î±,Î²\\alpha,\\betaÎ±,Î² éƒ½å¯ä»¥æ¯”è¾ƒå¤§å°ï¼Œå…¶ä¸­çš„å…ƒç´ ç§°ä¹‹ä¸ºå­—ç¬¦ã€‚ ä¸€ä¸ªå­—ç¬¦ä¸² SSS æ˜¯å°† nnn ä¸ªå­—ç¬¦é¡ºæ¬¡æ’åˆ—å½¢æˆçš„åºåˆ—ï¼Œnnn è¡¨ç¤ºå­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œè®°ä¸º âˆ£Sâˆ£|S|âˆ£Sâˆ£ã€‚å­—ç¬¦çš„ç¼–å·ä» 000 å¼€å§‹ï¼ˆå°½å¯èƒ½è¿™æ ·ç¼–å·ï¼Œè¿™æ ·æ˜¯ä¸æ ‡å‡†ä¸€è‡´çš„ï¼‰ã€‚ å­—å…¸åºæ˜¯ä»¥ç¬¬ iii ä¸ªå­—ç¬¦ä½œä¸ºå…³é”®å­—ç¬¦è¿›è¡Œæ¯”è¾ƒï¼Œç‰¹åˆ«æ³¨æ„ï¼Œç©ºå­—ç¬¦æ˜¯æœ€å°çš„ï¼š&quot;a&quot; &lt; &quot;aa&quot;ã€‚ å­ä¸²ã€å­åºåˆ—ã€å‰ç¼€åç¼€å’Œå›æ–‡ä¸²å°±ä¸å†èµ˜è¿°äº†ã€‚ char æ•°ç»„ char s[1005]; // å£°æ˜å­—ç¬¦æ•°ç»„ const char S[] = \"abab\"; // å¸¸é‡å­—ç¬¦æ•°ç»„ printf(\"%s\", s); scanf(\"%s\", s); // è¯»å…¥å’Œè¾“å‡º sprintf(s, \"%d \", a[i]); sscanf(s, \"%d\", &amp;x); // å‘å­—ç¬¦ä¸²è¾“å‡ºæˆ–ä»å­—ç¬¦ä¸²è¯»å…¥ C++ string ç±» #include &lt;string> std::string s; string å¯¹ char æ•°ç»„å…¼å®¹ï¼Œä¸Šè¿°å†…å®¹éƒ½å¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒè¿˜æœ‰è®¸å¤šç‰¹æœ‰å†…å®¹ã€‚ string å¾ˆæ–¹ä¾¿ï¼Œä½†ä¹Ÿå¾ˆæ…¢ï¼Œé‡åˆ°æ•°æ®è§„æ¨¡å¤§çš„é¢˜åº”å½“æ…é‡ä½¿ç”¨ã€‚ å»ºè®®å¤§å®¶ç†Ÿç»ƒæŒæ¡å­—ç¬¦æ•°ç»„ã€string å’Œ sstreamï¼Œéƒ½æ˜¯å¾ˆæœ‰ç”¨çš„ã€‚ å­—ç¬¦ä¸²ç®—æ³• å­—ç¬¦ä¸²ç®—æ³•åŸºæœ¬ä¸Šéƒ½åŸºäºæ‰€æ±‚ä¿¡æ¯çš„ç‰¹æ®Šæ€§è´¨å’Œå·²ç»æ±‚å‡ºçš„ä¿¡æ¯ï¼Œç±»ä¼¼äºåŠ¨æ€è§„åˆ’ã€‚ Trie æ ‘ Trieï¼Œåˆç§°å­—å…¸æ ‘æˆ–è€…å‰ç¼€æ ‘ï¼Œå¯ä»¥ç”¨æ¥ä¿å­˜å­—ç¬¦ä¸²çš„é›†åˆï¼Œæ˜¯ä¸€ç§æ ‘å½¢æ•°æ®ç»“æ„ã€‚ å¼•å…¥ ä¸€æ£µç®€å•çš„ Trie é‡‡ç”¨ç±»ä¼¼äºæ ‘ä¸Šå‰ç¼€å’Œçš„è®¡ç®—æ–¹å¼ï¼Œå¯ä»¥å¾—å‡º 222 å·èŠ‚ç‚¹ä»£è¡¨å­—ç¬¦ä¸² aï¼Œ666 å·ä»£è¡¨ aaaã€‚ å®ç° å®ç°æ—¶ï¼Œæˆ‘ä»¬ä¸€èˆ¬æŠŠæ ¹èŠ‚ç‚¹è®°ä¸º 000 å·èŠ‚ç‚¹ï¼Œå› ä¸ºå®ƒä¸ä»£è¡¨ä»»ä½•å­—ç¬¦ä¸²ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰ ch[i][sigma_size]ï¼Œå…¶ä¸­ sigma_size ä»£è¡¨ Trie æ ‘çš„å­—ç¬¦é›†å¤§å°ï¼ˆä¸ç”¨ vector ä¹‹ç±»çš„æ˜¯ä¸ºäº†ä¿è¯æ—¶é—´æ•ˆç‡ï¼Œç”¨ç©ºé—´æ¢æ—¶é—´ï¼‰ï¼Œè¡¨ç¤ºæ˜¯å¦æœ‰è¿™ä¸ªå„¿å­ã€‚è¿˜æœ‰ä¸€ä¸ª val[i]ï¼Œå¯ä»¥ç”¨äºè®°å½•è¿™ä¸ªå­—ç¬¦ä¸²çš„æƒå€¼ï¼Œæ¯”å¦‚è®°å½•è¿™ä¸ªèŠ‚ç‚¹æ˜¯ä¸æ˜¯å­—ç¬¦ä¸²ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, q, tot = 0; int ch[3000005][62], val[3000005]; int f(char x) &#123; if (x >= 'A' &amp;&amp; x &lt;= 'Z') return x - 'A'; if (x >= 'a' &amp;&amp; x &lt;= 'z') return x - 'a' + 26; return x - '0' + 52; &#125; void insert(char *s) &#123; int x = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) &#123; int c = f(s[i]); if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; val[x] += 1; &#125; &#125; int find(char *s) &#123; int x = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) &#123; int c = f(s[i]); if (!ch[x][c]) return 0; x = ch[x][c]; &#125; return val[x]; &#125; char s[3000005]; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 0; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; 62; ++j) ch[i][j] = 0; val[i] = 0; &#125; while (n--) &#123; scanf(\"%s\", s); insert(s); &#125; while (q--) &#123; scanf(\"%s\", s); printf(\"%d\\n\", find(s)); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; å­—ç¬¦ä¸² Hash æˆ‘ä»¬å¯ä»¥å°†ä¸€ä¸ªå­—ç¬¦ä¸²é€šè¿‡ä¸€ä¸ªå‡½æ•° fff æ˜ å°„ä¸ºä¸€ä¸ªæ•´æ•°ã€‚ å®ç° æˆ‘ä»¬é€šå¸¸è¿™æ ·å®šä¹‰ Hash å‡½æ•°ï¼šf(s)=âˆ‘i=0lâˆ’1s[i]Ã—blâˆ’i(modM)f(s) = \\sum_{i=0}^{l-1} s[i] \\times b^{l-i} \\pmod Mf(s)=âˆ‘i=0lâˆ’1â€‹s[i]Ã—blâˆ’i(modM)ã€‚æœ‰çš„æ—¶å€™æ˜¯åè¿‡æ¥çš„ï¼šf(s)=âˆ‘i=0lâˆ’1s[i]Ã—biâˆ’1(modM)f(s) = \\sum_{i=0}^{l-1} s[i] \\times b^{i-1} \\pmod Mf(s)=âˆ‘i=0lâˆ’1â€‹s[i]Ã—biâˆ’1(modM)ã€‚ä¸è¿‡ç›¸æ¯”ä¹‹ä¸‹ï¼Œå‰è€…æ›´ä¸ºå¸¸ç”¨ã€‚å…¶ä¸­çš„ bbb å¯ä»¥æ ¹æ®å¿ƒæƒ…å†³å®šå…¶å€¼ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define LL long long using namespace std; int n, ans = 0; vector &lt;string> v[23333]; void calc(const string &amp;s) &#123; LL hash = 0; for (int i = s.length() - 1; i >= 0; --i) hash = (hash * 130 + s[i]) % 233; for (int i = 0; i &lt; v[hash].size(); ++i) if (v[hash][i] == s) return; v[hash].push_back(s); ++ans; &#125; int main(void) &#123; cin >> n; while (n--) &#123; string s; cin >> s; calc(s); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; ä¸Šè¿°ä»£ç é‡‡ç”¨äº†æ‹‰é“¾æ³•å®ç°ï¼Œæ•ˆç‡ç›¸å¯¹æ¥è¯´æ¯”è¾ƒä½ä¸‹ï¼Œç°åœ¨æˆ‘ä»¬æ¥ä»‹ç»ä¸€ç§æ›´ä¸ºå¸¸ç”¨çš„æ–¹æ³•ï¼š æˆ‘ä»¬é‡‡ç”¨ä¸¤ä¸ªæ¨¡æ•°åšä¸¤æ¬¡ Hashï¼Œå¦‚æœ Hash å€¼éƒ½ç›¸åŒæ‰åˆ¤å®šå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚ä¸¤ä¸ªå­—ç¬¦ä¸² Hash ç›¸åŒçš„æ¦‚ç‡æœ¬èº«å°±å¾ˆå°ï¼ŒåŒæ¨¡æ•°ä¹‹åæ›´å°ï¼Œå› æ­¤å‡ ä¹ä¸ä¼šå‡ºé”™ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD1 = 998244853; const int MOD2 = 1011000007; i64 H1(const string &amp;s) &#123; i64 hash = 0; for (int i = s.length() - 1; i >= 0; --i) hash = (hash * 233 + s[i]) % MOD1; return hash; &#125; i64 H2(const string &amp;s) &#123; i64 hash = 0; for (int i = s.length() - 1; i >= 0; --i) hash = (hash * 233 + s[i]) % MOD2; return hash; &#125; pair&lt;i64, i64> a[10005]; int main(void) &#123; ios::sync_with_stdio(0); int n; cin >> n; string s; for (int i = 1; i &lt;= n; ++i) &#123; cin >> s; a[i] = make_pair(H1(s), H2(s)); &#125; sort(a + 1, a + n + 1); int ans = 1; for (int i = 2; i &lt;= n; ++i) if (a[i].first != a[i - 1].first &amp;&amp; a[i].second != a[i - 1].second) ++ans; printf(\"%d\\n\", ans); return 0; &#125; å­ä¸² Hash å½“å“ˆå¸Œå‡½æ•°è¿™æ ·å®šä¹‰æ—¶ï¼šf(s)=âˆ‘i=1ls[i]Ã—blâˆ’i(modM)f(s) = \\sum_{i=1}^{l} s[i] \\times b^{l-i} \\pmod Mf(s)=âˆ‘i=1lâ€‹s[i]Ã—blâˆ’i(modM)ã€‚æˆ‘ä»¬å¯ä»¥é‡‡ç”¨ç±»ä¼¼äºå‰ç¼€å’Œçš„æ–¹å¼æ¥å¿«é€Ÿæ±‚è§£å­ä¸²çš„å“ˆå¸Œï¼ˆä» 111 å¼€å§‹ç¼–å·ï¼‰ã€‚ ä»¤ fj(s)f_j(s)fjâ€‹(s) ä»£è¡¨ f(s[1â€¦j])f(s[1\\dots j])f(s[1â€¦j])ï¼Œé‚£ä¹ˆæœ‰ fj(s)=âˆ‘i=1js[i]Ã—brâˆ’i(modM)f_j(s)=\\sum_{i=1}^{j} s[i] \\times b^{r-i} \\pmod Mfjâ€‹(s)=âˆ‘i=1jâ€‹s[i]Ã—brâˆ’i(modM)ï¼Œè€Œ f(s[lâ€¦r])=s[l]Ã—brâˆ’l+â‹¯+s[r]f(s[l\\dots r])=s[l]\\times b^{r-l}+\\cdots+s[r]f(s[lâ€¦r])=s[l]Ã—brâˆ’l+â‹¯+s[r]ï¼Œè¿›è€Œæœ‰ f(s[lâ€¦r])=fr(s)âˆ’flâˆ’1(s)Ã—brâˆ’l+1f(s[l\\dots r])=f_r(s)-f_{l-1}(s)\\times b^{r-l+1}f(s[lâ€¦r])=frâ€‹(s)âˆ’flâˆ’1â€‹(s)Ã—brâˆ’l+1ã€‚ Hash çš„åº”ç”¨ å­—ç¬¦ä¸²å“ˆå¸Œèƒ½è§£å†³å¾ˆå¤šé—®é¢˜ã€‚ å­—ç¬¦ä¸²åŒ¹é… æ±‚å‡ºæ¨¡å¼ä¸²çš„å“ˆå¸Œå€¼ï¼Œç„¶åæŸ¥æ‰¾æ¯ä¸€ä¸ªå­—ä¸²çš„å“ˆå¸Œå€¼ï¼Œæ¯”è¾ƒæ˜¯å¦ç›¸ç­‰ã€‚ å…è®¸å¤±é…çš„å­—ç¬¦ä¸²åŒ¹é… æ¯”å¦‚è¯´å…è®¸å¤±é… kkk æ¬¡ã€‚è¿™ä¸ªé—®é¢˜å¯ä»¥ä½¿ç”¨ Hash + äºŒåˆ†æ¥è§£å†³ï¼Œè®¾å½“å‰æšä¸¾çš„å­ä¸²ä¸º sâ€²s&#x27;sâ€²ï¼Œå¯ä»¥äºŒåˆ†å‡º sâ€²s&#x27;sâ€² ç¬¬ä¸€ä¸ªä¸æ¨¡å¼ä¸²ä¸åŒçš„åœ°æ–¹ï¼Œç„¶åå°†è¿™ä¸ªå¤±é…çš„ä½ç½®ä»¥å‰çš„å†…å®¹åˆ å»ï¼Œå†æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå¤±é…çš„ä½ç½®ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(knlogâ¡m)O(kn\\log m)O(knlogm)ã€‚ æœ€é•¿å›æ–‡å­ä¸² è®° RiR_iRiâ€‹ ä»£è¡¨ä»¥ iii ç»“å°¾çš„æœ€é•¿å›æ–‡é•¿åº¦ã€‚ç”±äº Riâ‰¤Riâˆ’1+2R_i\\le R_{i-1}+2Riâ€‹â‰¤Riâˆ’1â€‹+2ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦ä» Riâˆ’1+2R_{i-1}+2Riâˆ’1â€‹+2 çš„é•¿åº¦å¼€å§‹é€’å‡ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå›æ–‡ä¸²å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ Manacher ç®—æ³• å®ƒå¯ä»¥é«˜æ•ˆè§£å†³å›æ–‡é—®é¢˜ã€‚ æ¦‚è¿° Manacher ä»…èƒ½æ‰¾åˆ°é•¿åº¦ä¸ºå¥‡æ•°çš„å›æ–‡ä¸²ï¼Œå› æ­¤åœ¨å®ƒå·¥ä½œå‰ï¼Œæˆ‘ä»¬è¦åœ¨å®ƒçš„æ¯ä¸ªå­—ç¬¦é—´éƒ½æ’å…¥ä¸€ä¸ªç›¸åŒçš„åˆ†å‰²ç¬¦ã€‚åŒæ—¶è¿˜è¦åœ¨å­—ç¬¦ä¸²å‰åæ’å…¥ä¸€å¯¹ä¸åŒçš„å­—ç¬¦é˜²æ­¢è¶Šç•Œã€‚ è®¾ä»¥ sis_isiâ€‹ ä¸ºå¯¹ç§°ä¸­å¿ƒçš„å›æ–‡ä¸²ä¸­æœ€é•¿çš„å›æ–‡åŠå¾„ï¼ˆä»¥ iii ä¸ºå¯¹ç§°ä¸­å¿ƒï¼Œå›æ–‡ä¸²çš„é•¿åº¦ä¸ºå¥‡æ•°ï¼ŒåŠå¾„æ˜¯æŒ‡ä»å¯¹ç§°ä¸­å¿ƒåˆ°ä¸€æ®µçš„å­—ç¬¦ä¸²é•¿åº¦ï¼‰ä¸º pip_ipiâ€‹ã€‚é‚£ä¹ˆå¦‚æœ xxx æ˜¯ iii çš„å›æ–‡åŠå¾„ï¼Œåˆ™ 0âˆ¼x0\\sim x0âˆ¼x éƒ½æ˜¯ã€‚ Manacher ä¼šè®°å½•åœ¨éå†è¿‡çš„ 1âˆ¼iâˆ’11\\sim i-11âˆ¼iâˆ’1 ä¸­ï¼Œä»¥ä»»æ„ä¸€ç‚¹ä¸ºå¯¹ç§°ä¸­å¿ƒçš„å›æ–‡ä¸²æœ€å¤§å³ç«¯ç‚¹ rrrï¼Œå¹¶è®°å½•æ­¤æ—¶çš„å¯¹ç§°ä¸­å¿ƒ dddã€‚è‹¥å½“å‰ i&gt;ri&gt;ri&gt;rï¼Œåˆ™è®© pi=1p_i=1piâ€‹=1 ç›´æ¥å¼€ç®—ï¼›å¦åˆ™å°† pip_ipiâ€‹ å…ˆèµ‹å€¼æˆ minâ¡{p2dâˆ’i,râˆ’i+1}\\min\\{p_{2d-i},r-i+1\\}min{p2dâˆ’iâ€‹,râˆ’i+1} å†å°è¯•æ›´æ–°ã€‚å› ä¸º 2dâˆ’i2d-i2dâˆ’i ä¸ iii å…³äº ddd å¯¹ç§°ï¼Œå› æ­¤åœ¨ [dâˆ’r+1,d+râˆ’1][d-r+1,d+r-1][dâˆ’r+1,d+râˆ’1] å†…ï¼Œä»¥ 2dâˆ’i2d-i2dâˆ’i ä¸ºå¯¹ç§°ä¸­å¿ƒçš„å›æ–‡ä¸²ä¹Ÿæ˜¯ä»¥ iii ä¸ºå¯¹ç§°ä¸­å¿ƒçš„å›æ–‡ä¸²ã€‚å½“ p2dâˆ’i&lt;râˆ’i+1p_{2d-i}&lt;r-i+1p2dâˆ’iâ€‹&lt;râˆ’i+1 æ—¶ï¼Œpip_ipiâ€‹ å·²ç»æœ€å¤§ï¼ˆå¦åˆ™ p2dâˆ’ip_{2d-i}p2dâˆ’iâ€‹ ä¹Ÿå¯ä»¥æ›´å¤§ï¼‰ï¼›å¦åˆ™ pip_ipiâ€‹ è¢«åˆå§‹åŒ–ä¸º râˆ’i+1r-i+1râˆ’i+1ï¼ˆä¸èƒ½è¶…è¿‡ ddd çš„åŠ¿åŠ›èŒƒå›´ï¼Œå› ä¸ºè¿™ä¸ªå¯¹ç§°æ€§å°½åœ¨ [dâˆ’r+1,d+râˆ’1][d-r+1,d+r-1][dâˆ’r+1,d+râˆ’1] å†…ç”Ÿæ•ˆï¼Œéœ€è¦æ»¡è¶³ i+piâˆ’1â‰¤ri+p_i-1\\le ri+piâ€‹âˆ’1â‰¤rï¼‰ã€‚ç”±äºæ¯æ¬¡æ‰©å±•éƒ½ä¼šä½¿ rrr å˜å¤§ï¼Œæ•…å‡æ‘Šæ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int m, n, p[22000010]; char s[22000010], t[11000005]; int main(void) &#123; scanf(\"%s\", t + 1); m = strlen(t + 1); s[0] = '#'; s[n = 1] = '@'; for (int i = 1; i &lt;= m; ++i) s[++n] = t[i], s[++n] = '@'; s[n + 1] = '!'; int ans = 0; for (int i = 1, r = 0, d = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, p[2 * d - i]); while (s[i - p[i]] == s[i + p[i]]) ++p[i]; if (i + p[i] - 1 > r) d = i, r = i + p[i] - 1; ans = max(ans, p[i] - 1); &#125; printf(\"%d\\n\", ans); return 0; &#125; åº”ç”¨ æˆ‘ä»¬æˆç§° Manacher ç®—æ³•ä¸ºé©¬æ‹‰è½¦ï¼Œå®ƒå¯ä»¥æ±‚å‡ºä»¥æŸä¸ªå­—ç¬¦å¼€å¤´æˆ–ç»“å°¾çš„æœ€é•¿å›æ–‡å­ä¸²ã€‚ ä»¥å›ºå®šç»“å°¾ä¸ºä¾‹ã€‚è€ƒè™‘æ¯ä¸€ä¸ªä½ç½® iiiï¼Œè‹¥æˆ‘ä»¬æ›´æ–°äº† rrrï¼Œé‚£ä¹ˆåœ¨æ›´æ–° rrr å‰è¦å¯¹ [r+1,i+piâˆ’1][r+1,i+p_i-1][r+1,i+piâ€‹âˆ’1] çš„ç­”æ¡ˆæ›´æ–°ä¸º jâˆ’i+1j-i+1jâˆ’i+1ï¼ˆjjj ä¸æ˜¯åˆ†éš”ç¬¦çš„æ—¶å€™è¿›è¡Œï¼‰ã€‚ å‡æ‘Šä¹‹åæ—¶é—´å¤æ‚åº¦ä¾ç„¶ä¸º O(n)O(n)O(n)ã€‚ [å›½å®¶é›†è®­é˜Ÿ]æœ€é•¿åŒå›æ–‡ä¸²ã€‚æˆ‘ä»¬æ­£åè·‘ä¸¤è¾¹ Manacherï¼Œæ‰¾å‡ºä»¥æŸä¸ªå­—ç¬¦å¼€å§‹æˆ–ç»“æŸçš„æœ€é•¿å›æ–‡ä¸²ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int m, n, p[200010]; int L[100010], R[100010]; char t[100005], s[200010]; int P(int x) &#123; if (x >= 1 &amp;&amp; x &lt;= n) return p[x]; return 0; &#125; int main(void) &#123; scanf(\"%s\", t + 1); m = strlen(t + 1); s[0] = '#'; s[n = 1] = '@'; for (int i = 1; i &lt;= m; ++i) s[++n] = t[i], s[++n] = '@'; s[n + 1] = '!'; for (int i = 1, d = 0, r = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, P(2 * d - i)); while (s[i + p[i]] == s[i - p[i]]) ++p[i]; if (i + p[i] - 1 > r) &#123; for (int j = r + 1; j &lt;= i + p[i] - 1; ++j) if (j % 2 == 0) R[j / 2] = j - i + 1; d = i, r = i + p[i] - 1; &#125; &#125; for (int i = n, d = 0, r = n; i >= 1; --i) &#123; if (i &lt; r) p[i] = 1; else p[i] = min(i - r + 1, P(2 * d - i)); while (s[i + p[i]] == s[i - p[i]]) ++p[i]; if (i - p[i] + 1 &lt; r) &#123; for (int j = r - 1; j >= i - p[i] + 1; --j) if (j % 2 == 0) L[j / 2] = i - j + 1; d = i, r = i - p[i] + 1; &#125; &#125; int ans = 0; for (int i = 1; i &lt; m; ++i) if (R[i] &amp;&amp; L[i + 1]) ans = max(ans, R[i] + L[i + 1]); printf(\"%d\\n\", ans); return 0; &#125; KMP æ¨¡å¼åŒ¹é… è™½ç„¶è¯´è¿™æ˜¯ä¸ªåŸºç¡€ç®—æ³•ï¼Œä½†æ˜¯æ€æƒ³éå¸¸æ£’ã€‚ KMP ç®—æ³•èƒ½å¤Ÿåœ¨çº¿æ€§æ—¶é—´å†…åˆ¤å®šä¸€ä¸ªå­—ç¬¦ä¸²åœ¨å¦ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰å‡ºç°ä½ç½®ï¼Œè€Œä¸”ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€äº›éå¸¸æœ‰ç”¨çš„é™„åŠ ä¿¡æ¯ã€‚ æ¦‚è¿° æ¨¡æ¿ã€‚ ç°åœ¨æˆ‘ä»¬è¦å¯¹å­—ç¬¦ä¸² AAA è®¡ç®—å…¶åœ¨ BBB ä¸­çš„å‡ºç°ä½ç½®ï¼Œè¿‡ç¨‹åˆ†ä¸ºä¸¤æ­¥ï¼š å¯¹ AAA è‡ªå·±è¿›è¡ŒåŒ¹é…ï¼Œæ±‚å‡º nxtnxtnxt æ•°ç»„ï¼Œnxt[i]nxt[i]nxt[i] ä»£è¡¨ A ä¸­ä»¥ iii ç»“å°¾çš„éå‰ç¼€å­ä¸²ä¸ A çš„å‰ç¼€èƒ½å¤ŸåŒ¹é…çš„æœ€å¤§é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯è¯´ nxt[i]=maxâ¡{jâˆ£j&lt;i,A[iâˆ’j+1âˆ¼i]=A[1âˆ¼j]}nxt[i]=\\max\\{j\\mid j&lt;i,A[i-j+1\\sim i]=A[1\\sim j]\\}nxt[i]=max{jâˆ£j&lt;i,A[iâˆ’j+1âˆ¼i]=A[1âˆ¼j]}ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ nxt[i]=0nxt[i]=0nxt[i]=0ã€‚ å¯¹ AAA å’Œ BBB è¿›è¡ŒåŒ¹é…ï¼Œæ±‚å‡ºæ•°ç»„ fffï¼Œf[i]f[i]f[i] ä»£è¡¨ BBB ä¸­ä»¥ iii ç»“å°¾çš„å­ä¸²ä¸ AAA çš„å‰ç¼€èƒ½å¤ŸåŒ¹é…çš„æœ€å¤§é•¿åº¦ã€‚ è¿™ä¸¤æ­¥çš„å®ç°æ–¹å¼å‡ ä¹ä¸€æ ·ï¼Œæˆ‘ä»¬ä»¥ç¬¬ 111 æ­¥ä¸ºä¾‹å­ã€‚ æ ¹æ®å®šä¹‰ï¼Œnxt[1]=0nxt[1]=0nxt[1]=0ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬æ‰«æå­—ç¬¦ä¸²ä¾æ¬¡è®¡ç®— nxtnxtnxtã€‚å‡å®š nxt[1âˆ¼iâˆ’1]nxt[1\\sim i-1]nxt[1âˆ¼iâˆ’1] å·²ç»è®¡ç®—å®Œæ¯•ï¼Œè®° ppp ä¸ºå½“å‰æ‰©å±•çš„é•¿åº¦ï¼Œå¹¶å°è¯•ç»§ç»­æ‰©å±•ã€‚å¦‚æœæ‰©å±•å¤±è´¥ï¼Œé‚£ä¹ˆä»¤ p=nxt[p]p=nxt[p]p=nxt[p]ï¼Œç›´åˆ° ppp å˜ä¸º 000ã€‚å¦‚æœèƒ½å¤ŸåŒ¹é…æˆåŠŸï¼Œppp å°±åŠ ä¸€ï¼Œæ­¤æ—¶ nxt[i]nxt[i]nxt[i] å°±ä¸º pppã€‚ å‡æ‘Šæ—¶é—´å¤æ‚åº¦ä¸º O(n+m)O(n+m)O(n+m)ï¼Œè¿™é‡Œä¸ä½œè¯æ˜[1]ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, nxt[1000005], f[1000005]; char s1[1000005], s2[1000005]; int main(void) &#123; scanf(\"%s%s\", s1 + 1, s2 + 1); n = strlen(s1 + 1), m = strlen(s2 + 1); for (int i = 2, p = 0; i &lt;= m; ++i) &#123; while (p &amp;&amp; s2[i] != s2[p + 1]) p = nxt[p]; // æ‰©å±•å¤±è´¥ if (s2[i] == s2[p + 1]) ++p; // å°è¯•æ‰©å±•åŒ¹é…é•¿åº¦ nxt[i] = p; &#125; for (int i = 1, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s1[i] != s2[p + 1]) p = nxt[p]; if (s1[i] == s2[p + 1]) ++p; f[i] = p; if (f[i] == m) printf(\"%d\\n\", i - m + 1); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d \", nxt[i]); putchar('\\n'); return 0; &#125; Border ç†è®º å®šä¹‰é•¿åº¦ä¸º nnn çš„å­—ç¬¦ä¸² sss çš„ Border(s)\\text{Border}(s)Border(s) è¡¨ç¤º sss æ‰€æœ‰ç›¸ç­‰çš„çœŸå‰ç¼€åç¼€é›†åˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯ Borderï¼Œé‚£ä¹ˆå®ƒåŒæ—¶æ˜¯ sss çš„å‰ç¼€å’Œåç¼€ã€‚è€Œ sss ä¸­æœ€é•¿çš„ä¸€ä¸ª Border å°±æ˜¯ nxt[n]nxt[n]nxt[n]ã€‚ å¦‚æœè¯´ ppp æ˜¯ sss çš„å‘¨æœŸï¼Œé‚£ä¹ˆ si=si+p(1â‰¤iâ‰¤nâˆ’p)s_i=s_{i+p}(1\\le i\\le n-p)siâ€‹=si+pâ€‹(1â‰¤iâ‰¤nâˆ’p)ã€‚ Border æ‹¥æœ‰ä»¥ä¸‹æ€§è´¨ï¼š è‹¥ ppp ä¸º sss çš„å‘¨æœŸï¼Œåˆ™ s[1â€¦nâˆ’p]s[1\\dots n-p]s[1â€¦nâˆ’p] ä¸º sss çš„ Borderã€‚ç”±å‘¨æœŸçš„å®šä¹‰å³å¯è¯æ˜ã€‚ å¦‚æœ sss å­˜åœ¨ Borderï¼Œé‚£ä¹ˆæœ€çŸ­çš„é•¿åº¦ä¸è¶…è¿‡å­—ç¬¦ä¸²çš„ä¸€åŠã€‚ å­—ç¬¦ä¸² sss çš„æœ€å°å‘¨æœŸä¸º âˆ£Sâˆ£âˆ’nxt[âˆ£Sâˆ£]|S| - nxt[|S|]âˆ£Sâˆ£âˆ’nxt[âˆ£Sâˆ£]ã€‚ å¤±é…æ ‘ å¦‚æœæˆ‘ä»¬ä» nxt[i]nxt[i]nxt[i] å‘ iii è¿è¾¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€æ£µä»¥ 111 ä¸ºæ ¹çš„æœ‰æ ¹æ ‘ï¼Œè¿™å°±æ˜¯å¤±é…æ ‘ã€‚ å¤±é…æ ‘å…·æœ‰ä¸€ä¸ªå¾ˆå¥½çš„æ€§è´¨ï¼šå¯¹äºæ ‘ä¸Šä»»æ„ä¸¤ä¸ªå…·æœ‰ç¥–å…ˆåä»£å…³ç³»çš„èŠ‚ç‚¹ x,yx,yx,yï¼Œs[1â€¦x]s[1\\dots x]s[1â€¦x] æ˜¯ s[1â€¦y]s[1\\dots y]s[1â€¦y] çš„ Borderã€‚å› æ­¤è¦æŸ¥è¯¢ä¸¤ä¸ªå‰ç¼€å­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…± Borderï¼Œåªéœ€è¦æŸ¥æ‰¾ä¸¤ä¸ªç‚¹åœ¨å¤±é…æ ‘ä¸Šçš„ LCA å³å¯ï¼ˆç”±äº Border ä¸èƒ½æ˜¯è‡ªå·±ï¼Œå› æ­¤ä¸è¦ç‰¹åˆ¤ x=yx=yx=yï¼‰ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, f[20][1000005], dep[1000005]; char s[1000005]; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 19; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; for (int i = 19; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; int main(void) &#123; scanf(\"%s%d\", s + 1, &amp;m); n = strlen(s + 1); dep[1] = 1; for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = f[0][p]; if (s[i] == s[p + 1]) ++p; dep[i] = dep[f[0][i] = p] + 1; &#125; for (int i = 1; i &lt;= 19; ++i) for (int j = 1; j &lt;= n; ++j) f[i][j] = f[i - 1][f[i - 1][j]]; while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", LCA(x, y)); &#125; return 0; &#125; Z å‡½æ•° åç¼€æ•°ç»„ Problemset å­—ç¬¦ä¸²çš„é¢˜å¾ˆå¤šï¼Œä¹Ÿå¾ˆæœ‰è¶£ã€‚ Trie Trie æ ‘çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œä½†çœŸçš„å¾ˆæœ‰ç”¨ã€‚ [TJOI2010] é˜…è¯»ç†è§£ Portal. ç©ºé—´é™åˆ¶å¾ˆç´§å¼ ï¼Œé‚£ä¹ˆå°±å¯¹è¯¢é—®å»ºç«‹ Trieï¼Œç„¶åä¾æ¬¡æ£€ç´¢æ–‡ç« ï¼Œæœ€åç»Ÿä¸€è¾“å‡ºç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;string> #include &lt;set> using namespace std; int n, m; int ch[200005][26], tot = 0; string tmp; vector&lt;string> a[1005]; vector&lt;int> ret[200005]; set&lt;int> ans[100005]; void insert(int p) &#123; cin >> tmp; int x = 0; for (int i = 0; i &lt; tmp.length(); ++i) &#123; int c = tmp[i] - 'a'; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; ret[x].emplace_back(p); &#125; void check(int p, int y) &#123; int x = 0; string &amp;s = a[p][y]; for (int i = 0; i &lt; s.length(); ++i) &#123; int c = s[i] - 'a'; if (!ch[x][c]) return; x = ch[x][c]; &#125; for (int i = 0; i &lt; ret[x].size(); ++i) ans[ret[x][i]].insert(p); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int l; scanf(\"%d\", &amp;l); while (l--) &#123; cin >> tmp; a[i].push_back(tmp); &#125; &#125; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) insert(i); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; a[i].size(); ++j) check(i, j); for (int i = 1; i &lt;= m; ++i) &#123; for (int x : ans[i]) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; [USACO08DEC] Secret Message G Portal. ç›´æ¥å»º Trie ç»Ÿè®¡å³å¯ï¼Œæ³¨æ„ä¸è¦ç®—é‡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; int m, n; int ch[500005][2], tot = 0; int s[500005], e[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) &#123; int len, x = 0; scanf(\"%d\", &amp;len); for (int j = 0; j &lt; len; ++j) &#123; int c; scanf(\"%d\", &amp;c); if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; ++s[x]; &#125; ++e[x]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int len, x = 0, ans = 0; scanf(\"%d\", &amp;len); bool flag = false; for (int j = 0; j &lt; len; ++j) &#123; int c; scanf(\"%d\", &amp;c); if (flag) continue; if (!ch[x][c]) flag = true; x = ch[x][c]; ans += e[x]; &#125; if (!flag) ans += s[x] - e[x]; printf(\"%d\\n\", ans); &#125; return 0; &#125; [USACO12DEC] First! G Portal.æœ‰ nnn ä¸ªä»…æœ‰å°å†™å­—æ¯æ„æˆçš„å­—ç¬¦ä¸²ï¼Œä½ å¯ä»¥ä»»æ„æ”¹å˜å­—ç¬¦çš„é¡ºåºï¼ˆæ¯”å¦‚è§„å®š b æ¯” a å°ï¼‰ï¼Œé—®å“ªäº›å­—ç¬¦ä¸²å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼å˜æˆå­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²ã€‚ æƒ³ä¸€æƒ³ï¼Œå­—å…¸åºçš„æ¯”è¾ƒæ˜¯ä»å‰åˆ°åçš„ã€‚é¦–å…ˆå¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸€ä¸ªçš„å‰ç¼€ï¼Œé‚£ä¹ˆä¸ä½œä¸ºå‰ç¼€çš„é‚£ä¸ªä¸€å®šä¸å¯ä»¥ã€‚è¿™æ ·ä»¥æ¥ï¼Œæˆ‘ä»¬å»ºç«‹ Trie æ ‘ï¼Œåœ¨ Trie ä¸ŠåŒä¸€çˆ¶äº²ï¼ŒåŒä¸€å±‚çš„èŠ‚ç‚¹ä¼šè¿›è¡Œå­—å…¸åºæ¯”è¾ƒï¼Œæˆ‘ä»¬åªéœ€è¦ç»™è¿™äº›å­—ç¬¦è¿ä¸€æ¡æœ‰å‘è¾¹ï¼Œä»£è¡¨å¤§å°å…³ç³»ï¼Œæœ€åä¼šå¾—åˆ°ä¸€å¼ å›¾ã€‚æ”¹å˜çš„å­—ç¬¦é¡ºåºå°±æ˜¯è¿™ä¸ªå›¾çš„æ‹“æ‰‘åºã€‚å¦‚æœè¿™ä¸ªå›¾ä¸æ˜¯ DAGï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦ä¸²ä¸èƒ½ä½œä¸ºç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;queue> using namespace std; int n; int ch[300005][26], tot = 0; bool e[300005], is_ans[30005]; string s[30005]; void insert(int p) &#123; int x = 0; cin >> s[p]; for (int i = 0; i &lt; s[p].length(); ++i) &#123; int c = s[p][i] - 'a'; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; e[x] = true; &#125; int in[30]; bool G[30][30]; void Kahn(void) &#123; queue&lt;int> q; for (int i = 0; i &lt; 26; ++i) if (in[i] == 0) q.push(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v = 0; v &lt; 26; ++v) if (G[u][v]) &#123; --in[v]; if (in[v] == 0) q.push(v); &#125; &#125; &#125; bool check(int p) &#123; string &amp;t = s[p]; int x = 0; memset(G, 0, sizeof(G)); memset(in, 0, sizeof(in)); for (int i = 0; i &lt; t.length(); ++i) &#123; if (e[x]) return false; int c = t[i] - 'a'; for (int j = 0; j &lt; 26; ++j) if (c != j &amp;&amp; ch[x][j] &amp;&amp; !G[c][j]) &#123; G[c][j] = true; // o->m m->o ++in[j]; &#125; x = ch[x][c]; &#125; Kahn(); for (int i = 0; i &lt; 26; ++i) if (in[i]) return false; return true; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) insert(i); int ans = 0; for (int i = 1; i &lt;= n; ++i) if (check(i)) &#123; ++ans; is_ans[i] = true; &#125; printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (is_ans[i]) cout &lt;&lt; s[i] &lt;&lt; '\\n'; return 0; &#125; [SCOI2016] èƒŒå•è¯ Portal.ä¸€å…±è¦å­¦ä¹  nnn ä¸ªå•è¯ï¼Œå¯ä»¥è‡ªè¡Œå†³å®šå­¦ä¹ å•è¯çš„é¡ºåºï¼Œå­¦ä¹ ç¬¬ xxx ä¸ªå•è¯è¦åƒçš„é“è½¨æ•°é‡æ˜¯ï¼šå¦‚æœå­˜åœ¨ä¸€ä¸ªå•è¯æ˜¯å®ƒçš„åç¼€ï¼Œå¹¶ä¸”å½“å‰æ²¡æœ‰è¢«å¡«å…¥è¡¨å†…ï¼Œé‚£ä»–éœ€è¦åƒ nÃ—nn \\times nnÃ—n ä¸ªé“è½¨æ‰èƒ½å­¦ä¼šï¼›å½“å®ƒçš„æ‰€æœ‰åç¼€éƒ½è¢«å¡«å…¥è¡¨å†…çš„æƒ…å†µä¸‹ï¼Œå¦‚æœåœ¨ 1â‹¯xâˆ’11 \\cdots x-11â‹¯xâˆ’1 çš„ä½ç½®ä¸Šçš„å•è¯éƒ½ä¸æ˜¯å®ƒçš„åç¼€ï¼Œé‚£ä¹ˆä»–åƒ xxx ä¸ªé“è½¨å°±èƒ½è®°ä½å®ƒï¼›å½“å®ƒçš„æ‰€æœ‰åç¼€éƒ½è¢«å¡«å…¥è¡¨å†…çš„æƒ…å†µä¸‹ï¼Œå¦‚æœ 1â‹¯xâˆ’11 \\cdots x-11â‹¯xâˆ’1 çš„ä½ç½®ä¸Šå­˜åœ¨æ˜¯å®ƒåç¼€çš„å•è¯ï¼Œæ‰€æœ‰æ˜¯å®ƒåç¼€çš„å•è¯ä¸­ï¼Œåºå·æœ€å¤§ä¸º yyyï¼Œé‚£ä¹ˆä»–åªè¦åƒ xâˆ’yx-yxâˆ’y ä¸ªé“è½¨å°±èƒ½æŠŠå®ƒè®°ä½ã€‚ åç¼€ç›¸åŒå¯ä»¥è½¬åŒ–ä¸ºå‰ç¼€ç›¸åŒï¼ˆå¯ä»¥ç¿»è½¬å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥åç€å»º Trieï¼‰ï¼Œ111 å†³ç­–æ˜¾ç„¶æ˜¯ä¸ä¼˜çš„ï¼Œåˆ©ç”¨å®ƒçœæ“ä½œæ€ä¹ˆéƒ½çœä¸ä¸‹æ¥ï¼Œè€Œä¸”ä¸å­˜åœ¨ä¸¤ä¸ªå•è¯äº’ä¸ºå‰ç¼€ï¼Œæ‰€ä»¥ 111 å†³ç­–ä¸€å®šå¯ä»¥é¿å…ã€‚ 222 çš„è¯å…¶å®æ˜¯ 333 ä¸­ y=0y=0y=0 çš„æƒ…å†µã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å½“ä½œåªæœ‰ 333 æ“ä½œã€‚ å»ºç«‹å¥½ Trie æ ‘åï¼Œä¸ºäº†é˜²æ­¢ 111 æ“ä½œçš„å‡ºç°ï¼Œæˆ‘ä»¬ä¸€å®šè¦æŒ‰ç…§ DFS åºè¿›è¡Œéå†ï¼ˆå…¶å®ƒæ–¹å¼å¹¶ä¸ä¼˜ï¼‰ã€‚ç”±äºéå­—ç¬¦ä¸²çš„èŠ‚ç‚¹æ˜¯æ²¡æœ‰è´¡çŒ®çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠå®ƒä»¬å»æ‰ï¼Œå°†å‰©ä¸‹çš„ç‚¹ä½œä¸ºå¯¼å‡ºå­æ ‘è¿›è¡Œ DFS åºéå†ï¼Œè€Œä¸”æ˜¯è¶Šé‡çš„è¶Šé åéå†ã€‚ä¸ºä»€ä¹ˆï¼Ÿé‡‡ç”¨å¾®æ‰°æ³•æ¥è¯æ˜è´ªå¿ƒï¼Œä¸€ä¸ªé‡çš„å­æ ‘å’Œè½»çš„å­æ ‘äº¤æ¢éå†é¡ºåºï¼Œé‚£ä¹ˆåªæœ‰é‡çš„å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„ä»£ä»·å’Œè½»çš„å­æ ‘çš„æ ¹èŠ‚ç‚¹ä»£ä»·ä¼šæ”¹å˜ï¼Œäº¤æ¢å‰ä»£ä»·æ˜¯è½»å­æ ‘çš„å¤§å°ï¼Œäº¤æ¢åä»£ä»·æ˜¯é‡å­æ ‘çš„å¤§å°ï¼Œå› æ­¤ä¸äº¤æ¢æ›´ä¼˜ã€‚ ä¸ºä»€ä¹ˆè¦æŒ‰ç…§ DFS åºè¿›è¡Œéå†ï¼ŸåŒæ ·å¯ä»¥ä½¿ç”¨å¾®æ‰°æ³•æ¥è¯æ˜ï¼Œå¯ä»¥å‘ç°ä»»æ„äº¤æ¢ä¸¤ä¸ªä¹‹åå®ƒä»¬çš„è´¡çŒ®éƒ½ä¼šå˜å¤§ï¼ˆè·ç¦»çˆ¶äº²çš„éå†åºå·æ›´è¿œäº†ï¼Œåƒçš„é“è½¨æ•°é‡æ›´å¤šäº†ï¼‰ï¼Œå› æ­¤ä¸€å®šä¸ä¼˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> #include &lt;vector> using namespace std; typedef long long i64; i64 ans = 0; int n, ch[510005][26], tot = 0, cnt = 0; int siz[500005], dfn[500005], lst[500005]; char s[500005]; bool e[510005]; vector&lt;int> G[500005]; bool cmp(int x, int y) &#123; return siz[x] &lt; siz[y]; &#125; void dfs(int x) &#123; if (e[x]) G[lst[x]].emplace_back(x), lst[x] = x; for (int i = 0; i &lt; 26; ++i) if (ch[x][i]) lst[ch[x][i]] = lst[x], dfs(ch[x][i]); &#125; void dfs2(int x, int fa) &#123; siz[x] = 1; for (int y : G[x]) &#123; dfs2(y, x); siz[x] += siz[y]; &#125; sort(G[x].begin(), G[x].end(), cmp); &#125; void dfs3(int x, int fa) &#123; dfn[x] = ++cnt; ans += dfn[x] - dfn[fa]; for (int y : G[x]) dfs3(y, x); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", s); reverse(s, s + strlen(s)); int x = 0; for (int i = 0; s[i]; ++i) &#123; int c = s[i] - 'a'; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; e[x] = true; &#125; dfs(0); dfs2(0, 0); dfs3(0, 0); printf(\"%lld\\n\", ans); return 0; &#125; [JSOI2009] ç”µå­è¯å…¸ Portal.æœ‰ n(nâ‰¤104)n(n\\le 10^4)n(nâ‰¤104) ä¸ªå•è¯çš„è¯å…¸å’Œ m(mâ‰¤104)m(m\\le 10^4)m(mâ‰¤104) æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®è¯å…¸ä¸­æœ‰å¤šå°‘ä¸ªå•è¯ä¸æŸ¥è¯¢çš„å•è¯å¯ä»¥æ¨¡ç³ŠåŒ¹é…ï¼ˆæŒ‡å¯ä»¥é€šè¿‡ä¸€æ¬¡ä¿®æ”¹ã€åˆ é™¤æˆ–æ·»åŠ å­—ç¬¦å˜æˆä¸€æ ·çš„å­—ç¬¦ä¸²ï¼‰ï¼Œå¦‚æœæœ¬æ¥å°±æœ‰è¿™ä¸ªå•è¯åˆ™è¾“å‡º -1ã€‚ä¿è¯ âˆ£sâˆ£â‰¤20|s|\\le 20âˆ£sâˆ£â‰¤20ã€‚ å¯¹è¯å…¸æ„å»º Trie æ ‘ï¼Œå¯¹äºæ¯ä¸ªè¯¢é—®åˆ™ç›´æ¥ä½¿ç”¨ DFS æš´åŠ›æŸ¥æ‰¾ï¼Œè®°å½•ä¸€ä¸ª flag è¡¨ç¤ºæ˜¯å¦ç¼–è¾‘è¿‡å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;set> using namespace std; int n, m, len, ans; int ch[200000][26], tot = 0; char s[25]; bool e[200000], vis[200000], is_word; set&lt;int> S; void dfs(int x, int p, bool flag) &#123; if (p == len &amp;&amp; e[x]) &#123; if (!flag) is_word = true; else S.insert(x); return; &#125; int c = s[p] - 'a'; if (ch[x][c]) dfs(ch[x][c], p + 1, flag); // æ­£å¸¸å†™ if (!flag) &#123; if (p &lt; len) dfs(x, p + 1, true); // åˆ é™¤ for (int i = 0; i &lt; 26; ++i) if (ch[x][i]) &#123; dfs(ch[x][i], p, true); // æ·»åŠ  if (p &lt; len &amp;&amp; i != c) dfs(ch[x][i], p + 1, true); // ä¿®æ”¹ &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (n--) &#123; scanf(\"%s\", s); int x = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) &#123; int c = s[i] - 'a'; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; e[x] = true; &#125; while (m--) &#123; is_word = false; ans = 0; scanf(\"%s\", s); len = strlen(s); S.clear(); dfs(0, 0, 0); if (is_word) puts(\"-1\"); else printf(\"%d\\n\", S.size()); &#125; return 0; &#125; å­—ç¬¦ä¸² Hash Hash ç®—æ³•å¾ˆç®€å•ï¼Œå¯ä»¥å®Œæˆè®¸å¤šéœ€è¦é«˜çº§ç®—æ³•æ‰èƒ½å®Œæˆçš„ä»»åŠ¡ã€‚ [NOI Online 2021 æé«˜ç»„] ç§¯æœ¨å°èµ› Portal. æˆ‘ä»¬æšä¸¾ Bob å­—ç¬¦ä¸²ï¼Œçœ‹æ˜¯å¦èƒ½åŒ¹é…ï¼Œå¹¶è®¡ç®—å…¶ Hash å€¼ï¼Œç„¶åå»é‡å°±æ˜¯ç­”æ¡ˆã€‚è¿™ä¸æ˜¯æ­£è§£ï¼Œéœ€è¦å¸æ°§ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef unsigned long long u64; int n, tot = 0; char a[3010], b[3010]; u64 t[9000005]; int main(void) &#123; scanf(\"%d\", &amp;n); fgets_unlocked(a + 1, 5, stdin); fgets_unlocked(a + 1, 3002, stdin); fgets_unlocked(b + 1, 3002, stdin); for (int i = 1; i &lt;= n; ++i) &#123; u64 v = 0; int p = 1; for (int j = i; j &lt;= n; ++j) &#123; while (p &lt;= n &amp;&amp; a[p] != b[j]) ++p; if (p > n) break; ++p; v = v * 233 + b[j]; t[++tot] = v; &#125; &#125; sort(t + 1, t + tot + 1); int ans = 1; for (int i = 2; i &lt;= tot; ++i) if (t[i] != t[i - 1]) ++ans; printf(\"%d\\n\", ans); return 0; &#125; [CF1200E] Compress Words Portal. ä½¿ç”¨å­—ç¬¦ä¸²å“ˆå¸Œæ±‚å‡ºæœ€é•¿çš„ç›¸ç­‰å‰åç¼€ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int B1 = 233, B2 = 479; const int M1 = 957657979, M2 = 996987653; int n, m, l, b1[1000005], b2[1000005]; char s[100005], ans[1000005]; int ash1[1000005], ash2[1000005]; int main(void) &#123; int n; scanf(\"%d\", &amp;n); b1[0] = b2[0] = 1; for (int i = 1; i &lt;= 1000000; ++i) b1[i] = 1ll * b1[i - 1] * B1 % M1; for (int i = 1; i &lt;= 1000000; ++i) b2[i] = 1ll * b2[i - 1] * B2 % M2; for (int op = 1; op &lt;= n; ++op) &#123; scanf(\"%s\", s + 1); m = strlen(s + 1); int h1 = 0, h2 = 0, len = 0; for (int i = 1; i &lt;= m &amp;&amp; i &lt;= l; ++i) &#123; h1 = (1ll * h1 * B1 + s[i]) % M1; h2 = (1ll * h2 * B2 + s[i]) % M2; if (ash1[l] == (h1 + 1ll * ash1[l - i] * b1[i]) % M1 &amp;&amp; ash2[l] == (h2 + 1ll * ash2[l - i] * b2[i]) % M2) len = i; &#125; for (int i = len + 1; i &lt;= m; ++i) &#123; ans[++l] = s[i]; ash1[l] = (1ll * ash1[l - 1] * B1 + s[i]) % M1; ash2[l] = (1ll * ash2[l - 1] * B2 + s[i]) % M2; &#125; &#125; printf(\"%s\\n\", ans + 1); return 0; &#125; Manacher ç®—æ³• å°±æ˜¯å›æ–‡ã€‚ [å›½å®¶é›†è®­é˜Ÿ] æ‹‰æ‹‰é˜Ÿæ’ç»ƒ Portal. ç›´æ¥ Manacherï¼Œåˆ©ç”¨å‰ç¼€å’Œç»Ÿè®¡ä¸åŒé•¿åº¦çš„å›æ–‡ä¸²å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 19930726; int n, p[1000005], cnt[1000005]; i64 k; char s[1000005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int main(void) &#123; scanf(\"%d%lld%s\", &amp;n, &amp;k, s + 1); s[0] = '$', s[n + 1] = '%'; for (int i = 1, r = 0, d = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, p[2 * d - i]); while (s[i - p[i]] == s[i + p[i]]) ++p[i]; if (i + p[i] - 1 > r) d = i, r = i + p[i] - 1; ++cnt[p[i]]; &#125; int ans = 1; for (int i = (n + 1) / 2; i >= 1 &amp;&amp; k > 0; --i) &#123; cnt[i] += cnt[i + 1]; ans = 1ll * ans * poww(i * 2 - 1, min(k, (i64)cnt[i])) % MOD; k -= cnt[i]; &#125; if (k > 0) puts(\"-1\"); else printf(\"%d\\n\", ans); return 0; &#125; [UVA11475] Extend to Palindrome Portal. ç”¨ Manacher æ±‚å‡ºç¬¬ä¸€ä¸ªå¯ä»¥æ‰©å±•åˆ°ç»“å°¾çš„å­ä¸²ï¼Œç„¶åæ ¹æ®å®ƒæ‰©å±•å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; const int MOD = 19930726; int n, p[1000005]; char t[1000005], s[2000005]; int main(void) &#123; while (scanf(\"%s\", t + 1) == 1) &#123; s[0] = '$'; s[n = 1] = '@'; int m = strlen(t + 1), pos; for (int i = 1; i &lt;= m; ++i) s[++n] = t[i], s[++n] = '@'; s[n + 1] = '%'; for (int i = 1, d = 0, r = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, p[2 * d - i]); while (s[i - p[i]] == s[i + p[i]]) ++p[i]; if (i + p[i] - 1 > r) d = i, r = i + p[i] - 1; if (i + p[i] - 1 == n) &#123; pos = (i - p[i] + 1) / 2; break; &#125; &#125; printf(\"%s\", t + 1); for (int i = pos; i >= 1; --i) putchar(t[i]); putchar('\\n'); &#125; return 0; &#125; [THUPC2018] ç»¿ç»¿å’Œä¸²ä¸² Portal.ç»¿ç»¿æœ‰ä¸€ä¸ªç”±å°å†™å­—æ¯ç»„æˆçš„éç©ºå­—ç¬¦ä¸² RRRï¼Œä½† Yazid ä¸çŸ¥é“å®ƒå…·ä½“æ˜¯ä»€ä¹ˆã€‚æˆ‘ä»¬å®šä¹‰ç¿»è½¬çš„æ“ä½œï¼šæŠŠä¸€ä¸ªä¸²ä»¥æœ€åä¸€ä¸ªå­—ç¬¦ä½œå¯¹ç§°è½´è¿›è¡Œç¿»è½¬å¤åˆ¶ã€‚å½¢å¼åŒ–åœ°æè¿°å°±æ˜¯ï¼Œå¦‚æœä»–ç¿»è½¬çš„ä¸²ä¸º RRRï¼Œé‚£ä¹ˆä»–ä¼šå°†å‰ âˆ£Râˆ£âˆ’1\\left| R\\right|-1âˆ£Râˆ£âˆ’1 ä¸ªå­—ç¬¦å€’åºæ’åˆ—åï¼Œæ’å…¥åˆ°ä¸²çš„æœ€åã€‚ä¸¾ä¾‹è€Œè¨€ï¼Œä¸² abcd è¿›è¡Œç¿»è½¬æ“ä½œåï¼Œå°†å¾—åˆ° abcdcbaï¼›ä¸² qw è¿ç»­è¿›è¡Œ 222 æ¬¡ç¿»è½¬æ“ä½œåï¼Œå°†å¾—åˆ° qwqwqï¼›ä¸² z æ— è®ºè¿›è¡Œå¤šå°‘æ¬¡ç¿»è½¬æ“ä½œï¼Œéƒ½ä¸ä¼šè¢«æ”¹å˜ã€‚è´ªç©çš„ç»¿ç»¿è¿›è¡Œäº†è‹¥å¹²æ¬¡ï¼ˆå¯èƒ½ä¸º 000 æ¬¡ï¼‰ç¿»è½¬æ“ä½œã€‚æ·˜æ°”çš„ç»¿ç»¿åˆå±•ç¤ºå‡ºäº†ä¸€ä¸ªéç©ºä¸² SSSï¼Œå¹¶è¡¨ç¤º SSS æ˜¯æœ€ç»ˆçš„ä¸² RRR çš„å‰ç¼€ã€‚ç°åœ¨ï¼Œä»–æƒ³è€ƒè€ƒ Yazidï¼Œåˆå§‹çš„ä¸² RRR çš„é•¿åº¦å¯èƒ½æ˜¯å¤šå°‘ã€‚Yazid æ‰¾åˆ°äº†æ­£åœ¨å‚åŠ æ¸…åæ ¡èµ›çš„ä½ ï¼Œè¯·ä½ æ¥å¸®ä»–è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä½†èªæ˜çš„ Yazid å‘ç°ï¼Œæ‰€æœ‰è¶…è¿‡ âˆ£Sâˆ£\\left| S\\right|âˆ£Sâˆ£ çš„æ•´æ•°éƒ½ä¸€å®šæ˜¯ RRR çš„å¯èƒ½é•¿åº¦ï¼Œå› æ­¤ä½ åªéœ€è¦å‘Šè¯‰ä»–ä¸è¶…è¿‡çš„ âˆ£Sâˆ£\\left| S\\right|âˆ£Sâˆ£ çš„ RRR çš„å¯èƒ½é•¿åº¦å³å¯ã€‚ä¿è¯ âˆ£Sâˆ£â‰¤106\\left| S\\right|\\leq 10^6âˆ£Sâˆ£â‰¤106ï¼Œâˆ‘âˆ£Sâˆ£â‰¤5Ã—106\\sum\\left| S\\right|\\leq 5\\times 10^6âˆ‘âˆ£Sâˆ£â‰¤5Ã—106ã€‚ ä»€ä¹ˆæ ·çš„å­—ç¬¦ä¸²å¯ä»¥æ»¡è¶³ï¼Ÿä»¥ nnn ç»“å°¾çš„å›æ–‡ä¸²ä¸€å®šå¯ä»¥ã€‚ç„¶åå‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹ qwqwq è¿™ä¸ªæ ·ä¾‹ã€‚ æ˜¾ç„¶ qwq æ˜¯å¯ä»¥çš„ï¼Œé‚£ä¹ˆ qw ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœ 1âˆ¼2iâˆ’11\\sim 2i-11âˆ¼2iâˆ’1 æ˜¯ä¸€ä¸ªä»¥ iii ä¸ºå›æ–‡ä¸­å¿ƒçš„å›æ–‡ä¸²ï¼Œé‚£ä¹ˆè¿™éƒ¨åˆ†å°±å¯ä»¥ç”± 1âˆ¼i1\\sim i1âˆ¼i å¤åˆ¶å‡ºæ¥ï¼Œåªéœ€è¦ 1âˆ¼2iâˆ’11\\sim 2i-11âˆ¼2iâˆ’1 æ¡ä»¶å³å¯ã€‚è¿™æ ·å°±æˆäº†ä¸€ä¸ªé€’å½’é—®é¢˜ï¼Œé€’æ¨æ±‚è§£å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;set> using namespace std; int m, n, p[10000010]; char t[5000005]; char s[10000010]; bool vis[10000010]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", t + 1); m = strlen(t + 1); s[0] = '$'; s[n = 1] = '@'; for (int i = 1; i &lt;= m; ++i) s[++n] = t[i], s[++n] = '@'; s[n + 1] = '!'; fill(vis + 1, vis + n + 1, 0); for (int i = 1, d = 0, r = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, p[d * 2 - i]); while (s[i - p[i]] == s[i + p[i]]) ++p[i]; if (i + p[i] - 1 > r) d = i, r = i + p[i] - 1; &#125; for (int i = n; i >= 1; --i) &#123; if (i + p[i] - 1 == n) vis[i] = 1; else if (i == p[i] &amp;&amp; vis[i + p[i] - 2]) vis[i] = 1; &#125; for (int i = 2; i &lt;= n; i += 2) if (vis[i]) printf(\"%d \", i / 2); putchar('\\n'); &#125; return 0; &#125; KMP æ¨¡å¼åŒ¹é… å¾ˆå¤šæ—¶å€™æˆ‘ä»¬ä½¿ç”¨ KMP å¹¶ä¸æ˜¯ä¸ºäº†æ±‚è§£å­—ç¬¦ä¸²åŒ¹é…ï¼Œè€Œæ˜¯ä¸ºäº†ä½¿ç”¨ nxtnxtnxt æ•°ç»„ï¼šä»¥ iii ç»“å°¾çš„éå‰ç¼€å­ä¸²ä¸ A çš„å‰ç¼€èƒ½å¤ŸåŒ¹é…çš„æœ€å¤§é•¿åº¦ã€‚ [CF126B] Password Portal. æ­£ååšä¸¤æ¬¡ KMPï¼Œç„¶åå°è¯•å°†å®ƒä»¬åˆå¹¶å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int n, nxt1[1000005], nxt2[1000005]; char s[1000005]; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt1[p]; if (s[i] == s[p + 1]) ++p; nxt1[i] = p; &#125; reverse(s + 1, s + n + 1); for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt2[p]; if (s[i] == s[p + 1]) ++p; nxt2[i] = p; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) if (nxt1[i] == nxt2[n - i + nxt1[i]]) ans = max(ans, nxt1[i]); if (ans == 0) puts(\"Just a legend\"); else &#123; for (int i = ans; i >= 1; --i) putchar(s[i]); putchar('\\n'); &#125; return 0; &#125; [CF808G] Anthem of Berland Portal.ç»™å®šå­—ç¬¦ä¸² sss å’Œ tttï¼Œä½†æ˜¯ sss ä¸­çš„ä¸€äº›å­—ç¬¦ä¸¢å¤±äº†ã€‚é—® ttt åœ¨ sss ä¸­æœ€å¤šå‡ºç°å¤šå°‘æ¬¡ã€‚ä¸¤ä¸ªå­—ç¬¦ä¸²é•¿åº¦çš„ä¹˜ç§¯åœ¨ 10710^7107 çº§åˆ«ã€‚ è€ƒè™‘ DPã€‚è®¾ f(i)f(i)f(i) ä»£è¡¨è€ƒè™‘åˆ°ç¬¬ iii ä½çš„æœ€å¤šå‡ºç°æ¬¡æ•°ï¼Œåˆå§‹ f(i)=f(iâˆ’1)f(i)=f(i-1)f(i)=f(iâˆ’1)ã€‚é™¤äº†èƒ½ç›´æ¥è½¬ç§» f(i)=f(iâˆ’m)+1f(i)=f(i-m)+1f(i)=f(iâˆ’m)+1ï¼Œä¸­é—´å¯èƒ½è¿˜æœ‰ tttã€‚è€ƒè™‘å¯¹ ttt è¿›è¡Œæ¨¡å¼åŒ¹é…ï¼Œåœ¨ä¸­é—´å¯»æ‰¾èƒ½å¤Ÿè¿›è¡Œçš„è½¬ç§»å³å¯ã€‚æ³¨æ„ä»è¿™ä¸ªè½¬ç§»è¿‡æ¥çš„ä¸èƒ½è¿›è¡Œè½¬ç§» f(i)=f(iâˆ’m)+1f(i)=f(i-m)+1f(i)=f(iâˆ’m)+1ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, nxt[100005], f[100005], g[100005]; char s[100005], t[100005]; bool check(int p) &#123; if (p - m + 1 &lt; 1) return false; for (int i = 1; i &lt;= m; ++i) if (s[p - m + i] != '?' &amp;&amp; s[p - m + i] != t[i]) return false; return true; &#125; int main(void) &#123; scanf(\"%s%s\", s + 1, t + 1); n = strlen(s + 1), m = strlen(t + 1); for (int i = 2, p = 0; i &lt;= m; ++i) &#123; while (p &amp;&amp; t[i] != t[p + 1]) p = nxt[p]; if (t[i] == t[p + 1]) ++p; nxt[i] = p; &#125; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = f[i - 1]; if (check(i)) &#123; g[i] = f[i - m] + 1; for (int j = nxt[m]; j; j = nxt[j]) g[i] = max(g[i], g[i - m + j] + 1); f[i] = max(f[i], g[i]); &#125; &#125; printf(\"%d\\n\", f[n]); return 0; &#125; [NOI2014] åŠ¨ç‰©å›­ Portal. åœ¨ nxtnxtnxt æ•°ç»„ä¸Šå€å¢å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int MOD = 1000000007; int nxt[22][1000005]; char s[1000005]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); int ans, n; while (T--) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1), ans = 1; for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt[0][p]; if (s[i] == s[p + 1]) ++p; nxt[0][i] = p; &#125; for (int j = 1; j &lt;= 19; ++j) for (int i = 1; i &lt;= n; ++i) nxt[j][i] = nxt[j - 1][nxt[j - 1][i]]; for (int i = 1; i &lt;= n; ++i) &#123; int p = i, cnt = 0; for (int j = 19; j >= 0; --j) if (nxt[j][p] * 2 > i) p = nxt[j][p]; for (int j = 19; j >= 0; --j) if (nxt[j][p]) p = nxt[j][p], cnt += (1 &lt;&lt; j); ans = 1ll * (cnt + 1) * ans % MOD; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [NOIP2020] å­—ç¬¦ä¸²åŒ¹é… Portal. æˆ‘ä»¬æšä¸¾ (AB)(AB)(AB) çš„é•¿åº¦å’Œ iiiï¼Œæ±‚å‡º nxtnxtnxt æ•°ç»„ç”¨äºåˆ¤æ–­è¿™ä¸ª iii æ˜¯å¦åˆæ³•ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 1048580; int n, nxt[N]; int pre[N], suf[N], cnt[26], tmp[27]; // tmp[i] è®°å½• A ä¸­å‡ºç° 0~i ä¸ªå¥‡æ•°å­—ç¬¦çš„æ–¹æ¡ˆæ•° // pre[i] è®°å½• s[1...i] ä¸­å‡ºç°å¥‡æ•°å­—ç¬¦çš„ä¸ªæ•° char s[N]; void solve(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); suf[n + 1] = 0; for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt[p]; if (s[i] == s[p + 1]) ++p; nxt[i] = p; &#125; memset(cnt, 0, sizeof cnt); for (int i = n; i >= 1; --i) &#123; ++cnt[s[i] - 'a']; if (cnt[s[i] - 'a'] &amp; 1) suf[i] = suf[i + 1] + 1; else suf[i] = suf[i + 1] - 1; &#125; memset(cnt, 0, sizeof cnt); for (int i = 1; i &lt;= n; ++i) &#123; ++cnt[s[i] - 'a']; if (cnt[s[i] - 'a'] &amp; 1) pre[i] = pre[i - 1] + 1; else pre[i] = pre[i - 1] - 1; &#125; long long ans = 0; memset(tmp, 0, sizeof tmp); for (int i = 1; i &lt; n; ++i) &#123; // |AB| çš„é•¿åº¦ if (i >= 2) &#123; ans += tmp[suf[i + 1]]; for (int j = i + i; j &lt; n &amp;&amp; i % (j - nxt[j]) == 0; j += i) ans += tmp[suf[j + 1]]; &#125; for (int j = pre[i]; j &lt;= 26; ++j) ++tmp[j]; &#125; printf(\"%lld\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; å®é™…ä¸Šè¿™æ˜¯ MP ç®—æ³•ï¼ˆKMP åœ¨ä¸¤ä¸ªå­—ç¬¦ç›¸ç­‰æ—¶ä¼šç›´æ¥è·³è¿‡ï¼‰ï¼Œä¸è¿‡ MP å·²ç»è¾¾åˆ°äº†ç†è®ºæ—¶é—´å¤æ‚åº¦ä¸‹é™ã€‚ â†©ï¸","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"https://james1badcreeper.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"2022~2023 çœé€‰æ—¥å¿—","slug":"summaries/æ¸¸è®°/SX2022","date":"2022-11-27T00:00:00.000Z","updated":"2022-11-27T00:00:00.000Z","comments":false,"path":"da8ee41/","link":"","permalink":"https://james1badcreeper.github.io/da8ee41/","excerpt":"Burn everything with Raging Hellfire.","text":"Burn everything with Raging Hellfire. 2022 å°¾å£°ã€‚ 11 æœˆ NOIP æ²¡æœ‰äº†ï¼å˜å˜ï¼é€€é’±ï¼ å¾—å‡ºçš„ç»“è®ºï¼šå‚åŠ  NOIP-Spring 2023 éœ€è¦äº¤é’±ï¼å˜å˜ï¼ è¿™å‡ ä¸ªæœˆæ²¡ä»€ä¹ˆäº‹æƒ…ï¼Œè¯¥å¹²ä»€ä¹ˆå¹²ä»€ä¹ˆå§ã€‚ æ–°å† æ„Ÿå†’ï¼ˆ12.13ï¼‰ å‘œå“‡ï¼ç¾Šäº†ä¸ªé˜³ï¼ å¤§æ¦‚æ˜¯è¿™ä¸€å¤©æ™šä¸Šåœ¨æœºæˆ¿æ„Ÿè§‰æœ‰ç‚¹ä¸å¯¹åŠ²ï¼Œç¬¬äºŒå¤©èµ·æ¥çœŸçš„ä¸å¯¹åŠ²äº†ã€‚äºæ˜¯å°±è¯·å‡äº†ã€‚ å­¦æ ¡å·²ç»å¾ˆå¯æ€•ï¼Œæ‰€ä»¥æˆ‘è¯·å‡çš„æ¬¡æ—¥æ•™ç»ƒè®©å¤§å®¶éƒ½å±…å®¶äº†ã€‚ äº²èº«ç»éªŒå¾—å‡ºï¼Œæ„Ÿè§‰å¥¥å¯†å…‹æˆçœŸçš„å¾ˆå¼±ï¼Œå°±è·Ÿæ™®é€šæ„Ÿå†’ä¸€æ ·ï¼Œä¸ªäººæ²¡ä»€ä¹ˆå¤§ç¢ï¼Œå±…å®¶å³å¯ã€‚ æ‰€ä»¥è¯´ï¼Œå­¦æ ¡é˜³çš„å¤ªå¤šäº†ï¼Œåº”è¯¥æ”¾å‡ åªç‹¼è¿›å»ã€‚ ã€ŠCharlotteã€‹è§‚åæ„Ÿï¼ˆ12.16 æ—¥ä¸‹åˆ ~ 12.17 11:40 PMï¼‰ æˆ‘ä¸çŸ¥é“ä¸ºå¾ˆä¹ˆæˆ‘ä¸€å£æ°”åˆ·äº†ä¸€éƒ¨ç•ªï¼Œç„¶ååœ¨æ¬¡æ—¥åˆå¯¹ä¸€äº›å†…å®¹è¿›è¡Œäº†äºŒåˆ·å¹¶è¡¥äº† SPã€çœ‹äº†æ¼«ç”»çš„å°¾å£°ã€‚ä»”ç»†æƒ³æƒ³æˆ‘åº”è¯¥æ˜¯åœ¨ä¸­è€ƒä¹‹åç¬¬ä¸€æ¬¡çœ‹ç•ªï¼ˆæœŸé—´ä¸ ACG å”¯ä¸€æœ‰å…³çš„æ´»åŠ¨å°±æ˜¯æ¨äº† Summer Pockets RB çš„ä¸€æ¡çº¿ï¼‰ï¼Œè¿™ä¹Ÿæ˜¯ç¬¬äºŒæ¬¡æ¥è§¦ä¸ key çš„ä½œå“ã€‚ åŒå‘æ•‘èµï¼Œçº¦å®šï¼Œéå¸¸æ„Ÿäººã€‚ä½†æ˜¯æˆ‘ä¼šç¢°åˆ°å—ï¼Ÿè™½ç„¶è¯´æ˜¯æŒºç¾¡æ…•çš„ï¼Œä½†æ˜¯è¿™ç§äº‹æƒ…å¯é‡ä¸å¯æ±‚ã€‚ç°åœ¨ï¼Œæˆ‘åªæœ‰è‡ªæˆ‘æ•‘èµï¼ˆRedemption Zeroï¼‰ã€‚ è¿˜æœ‰ä¸€ç‚¹ï¼Œå›½ç‹æ’åï¼ˆè™½ç„¶å¯èƒ½ç¡®å®æœ‰ä¸€ç‚¹é™æ™ºæ‰“å‡»ï¼‰ã€sprb å’Œ Charlotte éƒ½æœ‰äººæŒ‡å‡ºæœ‰ä¸å°‘ç¼ºç‚¹ï¼Œä½†æˆ‘åœ¨çœ‹çš„æ—¶å€™çœŸçš„æ¯æ„Ÿè§‰å‡ºæ¥ã€‚å¯èƒ½æ˜¯æˆ‘æ²¡æœ‰å®¡ç¾æˆ–è€…æ¯”è¾ƒåŸºæ•°å¤ªå°‘ï¼Œè€Œæ›´é‡è¦çš„åº”è¯¥æ˜¯æˆ‘ä¸æ³¨é‡ç»†èŠ‚ã€‚ç°åœ¨ OI çš„å­¦ä¹ æœ‰æ—¶å€™ä¸ºäº†â€œèµ¶è¿›åº¦â€ï¼ŒDinic éƒ½æ˜¯èƒŒçš„ï¼ˆç›®å‰çœ‹æ¥ç¡®å®æ— ä¼¤å¤§é›…ï¼Œè€Œä¸”ç”±äºæ‰¾çš„èµ„æ–™ä¸€èˆ¬éƒ½æ¯”è¾ƒé è°±æ‰€ä»¥ä¸ç”¨å¤ªåœ¨æ„æ­£ç¡®æ€§ï¼‰ï¼Œèƒ½å¤Ÿä¸¥è°¨å¯¹å¾…çš„äº‹æƒ…ä¼¼ä¹æ²¡æœ‰äº†ã€‚åœ¨æˆ‘å¼€æ¥ï¼Œå”¯ä¸€å€¼å¾—æˆ‘åº”è¯¥ä¸¥è°¨å¯¹å¾…çš„åªå‰©ä¸‹å‰æ²¿ç§‘å­¦çš„ç ”ç©¶äº†ã€‚è™½ç„¶è¿™ä¸ªäº‹ç°åœ¨çœ‹èµ·æ¥ä¸æˆ‘æ— å…³ï¼Œä½†æ˜¯æˆ‘è¿Ÿæ—©ä¼šç¢°ä¸Šè¿™äº›çš„ã€‚ æœ€åè¯´ä¸€å¥ï¼Œå¥ˆç»ªçœŸå¯çˆ±ã€‚ pixiv: 51873061 æ—¶é—´äº¤æ¢å¾‹ &amp; ç¬¬ä¸€æ¬¡çœé€‰æ¨¡æ‹Ÿï¼ˆ12.18ï¼‰ å®é™…ä¸Šæ˜¯è¿™æ ·çš„ï¼Œæƒ³å¹²çš„äº‹æƒ…ä»»ä½•æ—¶å€™éƒ½å¯ä»¥å¹²ï¼Œä½†æ˜¯è€ƒè¯•æ—¶é—´æ˜¯å®šçš„ï¼Œè¯´ç™½äº†å°±æ˜¯å…ˆå­¦ä¹ åå¨±ä¹ã€‚ æ¨¡æ‹Ÿèµ›çˆ†é›¶äº†ï¼Œç”šè‡³ä¸å¦‚ 2019 å¹´è”åˆçœé€‰è€ƒåœºä¸Šçš„è¡¨ç°ï¼Œæ·±æ·±è®¤è¯†åˆ°äº†è‡ªå·±çš„å·®è·ã€‚æ¥ä¸‹æ¥ï¼Œé˜³äº†å…ˆå†™å®Œä½œä¸šï¼Œå†ä»¥å…»ç—…ä¸ºä¸»ã€‚ æˆ‘æ˜¯åƒåœ¾ æ–°çš„å¼€å§‹ï¼ˆ12.19ï¼‰ ä¸ç®¡æ€æ ·ï¼Œè£…ä½œè‡ªå·±ç—…å¥½äº†ã€‚ è¿™å‘¨æ˜¯æ•°æ•°ï¼Œå•Šï¼Œå¤§çš„æ¥çš„è¿™ä¹ˆå¿«å—ã€‚ å¹´ç»ˆ 2022 å¹´çš„æœ€åä¸€å¤©ï¼ ç°åœ¨å†³å®šæ”¹å˜å­¦ä¹ æ–¹å¼ï¼Œä½œä¸šé‡Œå¤šæ”¾äº†ä¸€ä¸ª CFã€AT çš„æ¿åˆ·é¢˜å•ã€‚ 2023 å®é™…ä¸Šåªæœ‰ä¸¤ä¸ªæœˆäº†ï¼Œå·²ç»è¿‡åŠäº†ã€‚ æš´èµ°ï¼ˆ1.2ï¼‰ å¤§æ¦‚è¯´çš„æ„æ€æ˜¯è°ä¸å·å°±æ–©æ‰ç¤ºä¼—ã€‚ ã€Šé­”å¥³ã®æ—…ã€…ã€‹è§‚åæ„Ÿï¼ˆ1.3ï¼‰ çœ‹å®Œä¹‹ååˆçœ‹äº†å‡ ç« å°è¯´ï¼Œå¤§æ¦‚æ¥å†™ä¸€ä¸‹ã€‚ å•å…ƒå‰§ï¼å¹¶ä¸åƒä¼ ç»Ÿçš„è½»å°è¯´ï¼Œè€Œæ˜¯æ•´æˆäº†ä¸€åƒé›¶ä¸€å¤œ+ä¼Šç´¢å¯“è¨€ï¼ŒåŠ ä¸Šå¯çˆ±çš„ä¼Šé›·å¨œï¼Œéå¸¸å¥½çœ‹ï¼ˆè‡³å°‘å¯¹äºæˆ‘æ¥è¯´ï¼‰ï¼ æ–°å¹´å¿«ä¹ï¼ˆé›¾ï¼‰ï¼ WC æµ‹è¯•ï¼ˆ1.17ï¼‰ éš¾å¾—å›ä¸€æ¬¡å­¦æ ¡ï¼Œæ‰¾æ‰¾æ„Ÿè§‰ã€‚WC æ­£å¸¸æ‰“ã€‚ ç„¶åé“äº†ã€‚çœ¼ç›çä»¥ä¸º T1 è¾“å‡ºä¸€ä¸ª -1ï¼Œä¸çŸ¥é“çº¦æ•°æœ‰ä»€ä¹ˆç”¨ã€‚ æ‰€ä»¥å‘¢ï¼Ÿè¿˜æ˜¯å¾—å‘å‰å•Šã€‚ æ€ä¹ˆç¾¤å‹éƒ½è¯´ T1 é‚£ä¸ªçº¦æ•°å¾ˆå®¹æ˜“çœ‹å‡ºæ¥çš„ï¼Œç ´é˜²ã€‚ 1.18 ä¸ºä»€ä¹ˆï¼Œæˆ‘ä¼šå¦‚æ­¤ä¼¤æ„Ÿå‘¢â€¦â€¦ 1.24 æ„Ÿè§‰è‡ªå·±éœ€è¦å†™ä¸€ç‚¹ä¸œè¥¿é™é™ã€‚WCã€æ˜¥èŠ‚ä¹‹åï¼Œæ•´ä¸ªäººæ›´åŠ æ‚ä¹±ï¼Œä¼šå¯¹ç€é»‘å¤©æˆ–ç°ç™½çš„å¤©å¤§å–Šâ€œå¤©è“å•Šï¼â€ã€‚å…¶å®æ²¡ä»€ä¹ˆå¤§ä¸äº†çš„ï¼Œäººæœ¬æ¥å°±æ˜¯è¿™æ ·ï¼Œå°±æ˜¯ä¸€ç§æ„šè ¢çš„åŠ¨ç‰©ã€‚ åªè¦æˆ‘çœ¼é‡Œçš„æ˜Ÿå…‰ä»åœ¨é—ªçƒï¼Œæˆ‘ä¾¿èƒ½ä¸€å¾€æ— å‰ï¼ 1.27 æœºæˆ¿å›¢å»ºï¼ç‹¼äººæ€å¾ˆå¥½ç©ï¼ ç„¶åå°è¯•äº†è¡€æŸ“é’Ÿæ¥¼ï¼éå¸¸å¼ºå¤§ï¼ä½†æ˜¯æˆ‘çœŸæ²¡æƒ³åˆ°æ¨±é›ªæ˜¯å¤§ç‹¼ï¼æä¸æ‡‚æ€ä¹ˆæ¼”çš„è¿™ä¹ˆåƒçš„ï¼ æ„Ÿè§‰å¤šå“¥è¯´çš„æœ‰é“ç†ï¼Œå½“åäººçš„å‹åŠ›çœŸçš„å¾ˆå¤§ï¼è¿˜æ˜¯å¥½äººèˆ’æœï¼ 2.12 çœé€‰è®¡åˆ’æ¨¡æ‹Ÿèµ›ç»ˆäºè¿‡é¢˜äº†ï¼ˆå‰æœŸ #7ï¼‰ï¼æ„ŸåŠ¨å•Šè€å“¥ï¼æ„Ÿè°¢ CYJï¼ä»¥åä¹Ÿè¦ç»§ç»­åŠªåŠ›å‘¢ï¼ 2.19 çœé€‰è®¡åˆ’å‰æœŸæœ€åä¸€åœºï¼ å†™äº† T2 çš„æ ¹å·åˆ†æ²»ï¼Œæ‹¿åˆ°äº† 505050 çš„å¥½æˆç»©ï¼æ­£è§£æ˜¯åˆ©ç”¨ bitset ä»£æ›¿æ‰ unordered_setï¼Œæ—¶é—´å¤æ‚åº¦å¯ä»¥åšåˆ° O(nnw)O\\left(n\\sqrt{\\frac{n}{w}}\\right)O(nwnâ€‹â€‹)ï¼Œç›´å‘¼ orzï¼ è½å¹• ã€‚ 3.4 æœ‰ç‚¹å¯„ï¼Œå†™ä¸€äº›éœ€è¦ç‰¢è®°çš„äº‹æƒ…ï¼š å‘†å‘†é¢˜ä¸è¦æµªè´¹æ—¶é—´ï¼ ä¸è¦å¿˜è®°ä½ è¿˜ä¼š DPï¼æ€§è´¨å¯ä»¥æä¸€æï¼ éšæœºåŒ–ï¼å°½å¯èƒ½æåˆ†ï¼ç»“è®ºï¼è´ªå¿ƒï¼ æ„Ÿè§‰ hack æ‰è‡ªå·±çœ‹èµ·æ¥å¾ˆæ­£ç¡®çš„æƒ³æ³•çš„æ—¶å€™æƒ³ä¸€æƒ³æ˜¯å¦æ˜¯ hack é”™äº†ã€‚ æ„Ÿè§‰å¥½åƒä¼šäº†çš„æ—¶å€™ä¸è¦ç«‹åˆ»å¼€å§‹å†™ä»£ç ï¼Œé‡æ–°ç†ä¸€ä¸‹æ€è·¯ã€‚å†™ä»£ç ä¹‹å‰ä»”ç»†åœ°ç¡®è®¤ä¸€ä¸‹æ¯ä¸€æ­¥è½¬åŒ–å’Œç»“è®ºæ˜¯å¦æ­£ç¡®ã€‚ æ¿å­ä¸è¦å†™é”™ï¼ï¼ï¼ æ•°æ®çš„å„ç±»æé™æƒ…å†µéƒ½è¦è€ƒè™‘åˆ°ï¼åŒ…æ‹¬è´Ÿæ•°å’Œé›¶ï¼Œå¾ˆå¤§çš„æ­£æ•°ï¼ 3.5 å‰å¾€æ­å·ï¼é£æœºä¸Šå¼€å§‹å†™é¢˜ï¼ˆå‘†å‘†é¢˜ï¼Œè€Œä¸”ä¸ä¼šï¼‰ã€‚ æµ·äº®å­¦æ ¡å¾ˆå¤§ï¼Œä½†æ˜¯æœºæˆ¿å¾ˆè°”è°”ï¼Œä¸å¦‚ 24ï¼è¿˜æ˜¯åœ¨ 24 å·çš„èˆ’æœã€‚ 3.12 å‘¨æ—¥æ”¾å‡ï¼Œå›¢å»ºï¼Œé¹…é¸­æ€ï¼ ä½†æ˜¯æ‰“å®Œä¹‹ååˆå¾ˆåæ‚”ï¼Œæ„Ÿè§‰è‡ªå·±æµªè´¹äº†å‡ ä¸ªå°æ—¶ï¼Œå…³é”®æ˜¯è‡ªå·±ä¹Ÿæ²¡æœ‰æ‘†çš„èµ„æœ¬ã€‚ 3.17 ä»Šå¤©æ™šä¸Šåˆæœ‰é¹…é¸­æ€ï¼å½“é¸­å­èµ¢äº†ä¸¤å›ï¼Œä½†æ˜¯å½“é¹ˆé¹•åªåƒäº†ä¸€ä¸ªäººï¼ ç„¶åæ€»ç»“äº†ä¸€äº›é—®é¢˜ï¼Œå‰©ä¸‹å‡ å¤©çŸ¥é“è¯¥å¹²ä»€ä¹ˆäº†å—ï¼Ÿ 3.19 å‘ç°æ•°ä½ DP ç»å¸¸å¯ä»¥å’Œè‡ªåŠ¨æœºç»“åˆï¼ˆä¸¤é“æ¨¡æ‹Ÿèµ›é¢˜ï¼‰ï¼ 3.25 å¤ªå›°éš¾äº†ï¼Œè¿™æ˜¯ä»€ä¹ˆä¿¡å¿ƒèµ›ï¼ T1 GFï¼ŒT2 wqsï¼ŒT3 DDPã€‚è¢«åˆ›æ­»ã€‚ çªç„¶å‘ç°è‡ªå·±ä¸€å †ä¸ä¼šçš„ï¼Œè¿™å‡ å¤©éœ€è¦å­¦ä¹ æ•°å­¦ III å’Œ åŠ¨æ€è§„åˆ’ IIï¼Œè¦åšä¸€ç‚¹æ•°æ•°å’Œæ•°æ®ç»“æ„ï¼Œå¯èƒ½è¿˜è¦å­¦ä¸€ç‚¹ä¸²ä¸²ï¼ˆä½†æ˜¯åˆæ„Ÿè§‰ä¸ç”¨ï¼‰ã€‚ 3.26 è€ƒåœºä¸Šç®€å•é¢˜è¦å¿«é€Ÿåˆ‡æ‰ï¼Œæ¡ä»¶è½¬åŒ–æ—¶çœ‹é—®é¢˜æ˜¯å¦å˜å¾—æ›´ç®€å•ï¼Œç»å…¸æ•°æ®ç»“æ„åº”è¯¥å¿«é€Ÿæƒ³å‡ºæ¥ã€‚ æ„é€ é¢˜æƒ³ä¸€æƒ³å¦‚ä½•è½¬åŒ–ï¼Œæ˜¯å¯ä»¥æ€è€ƒçš„ã€‚ æœ€ä¼˜åŒ–é—®é¢˜æ²¡æ€è·¯æ—¶å¯ä»¥æƒ³ä¸€æƒ³ DPï¼Œè€Œä¸æ˜¯çè´ªå¿ƒã€‚ å½“å®Œæ•´æƒ³å‡ºä¸€é“é¢˜çš„åšæ³•æ—¶å¯ä»¥ä¼°è®¡ä¸€ä¸‹å†™è¿™ç©æ„çš„æ—¶é—´ï¼Œç„¶åå¹³è¡¡ä¸€ä¸‹ï¼Œæœ‰æ—¶é—´å°½é‡å…ˆå»çœ‹åé¢çš„é¢˜ã€‚ ç†è®ºä¸Šæ¥è¯´ä»Šå¤©ä¸Šåˆæœºæˆ¿å›¢å»ºè¦å»çœ‹ã€Šé“ƒèŠ½ä¹‹æ—…ã€‹ï¼Œä½†æ˜¯å› ä¸ºæˆ‘ä¸‹åˆæœ‰æ¨¡æ‹Ÿèµ›æ‰€ä»¥å°±æ‘†çƒ‚äº†ã€‚yurzhang è¿™ä¹ˆå¿ƒé‡Œæœ‰ç‚¹å¹³è¡¡äº†ï¼Œæ¯•ç«Ÿçœé€‰å‰æœ€å¥½ä¸è¦æ‘†çƒ‚ï¼Œè€Œä¸”æœºæˆ¿é‡Œè¿˜æœ‰å¦ä¸€ä½æœºå™¨äººä¹Ÿæ²¡æœ‰å»ã€‚ å—“å­æœ‰ç‚¹ç–¼ï¼Œä¿é™©èµ·è§è¿˜æ˜¯è¯·äº†ä¸ªå‡ï¼Œæ˜å¤©ä¸å»ä¸Šå­¦äº†ã€‚è¦æ˜¯æ˜¯å¹³æ—¶æˆ‘å°±å¤´é“ç›´æ¥å»äº†ï¼Œä½†æ˜¯çœé€‰å‰æˆ‘å¯ä¸æƒ³å‡ºäº‹ã€‚ To the crazy ones, wish us good luck. 4.2 é€€å½¹ã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"Codeforces Div.2 VP è®°å½•","slug":"default/old/cf-constest1","date":"2022-11-14T00:00:00.000Z","updated":"2022-11-14T00:00:00.000Z","comments":true,"path":"d71fa5a7/","link":"","permalink":"https://james1badcreeper.github.io/d71fa5a7/","excerpt":"æˆ‘ä¸ä¼šåšæ™®åŠé¢˜äº†ã€‚","text":"æˆ‘ä¸ä¼šåšæ™®åŠé¢˜äº†ã€‚ åªæœ‰æœ‰æ„æ€çš„é¢˜ç›®æ‰ä¼šå†™é¢˜è§£ï¼ˆå½“ç„¶å¯¹ç¬”è€…è¿™ç§æ™®åŠç»„é€‰æ‰‹æ¥è¯´ï¼Œå¯èƒ½æ‰€æœ‰é¢˜éƒ½æœ‰æ„æ€ï¼‰ã€‚ 11 æœˆè®°å½• æ–°å¾é€”ã€‚ Codeforces Round #830 (Div.2) Portal. A. Bestie Portal. (n,nâˆ’1)=1(n,n-1)=1(n,nâˆ’1)=1ï¼Œæ‰€ä»¥æœ€å¤šåªéœ€è¦æ”¹ n,nâˆ’1n,n-1n,nâˆ’1 ä¸¤æ¬¡ï¼Œè®¨è®ºä¸€ä¸‹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; int n, a[25], g = 0; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i], g = gcd(g, a[i]); if (g == 1) puts(\"0\"); else if (gcd(g, n) == 1) puts(\"1\"); else if (gcd(g, n - 1) == 1) puts(\"2\"); else puts(\"3\"); &#125; return 0; &#125; B. Ugu Portal. æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; int main(void) &#123; int T, n; cin >> T; while (T--) &#123; string s; cin >> n >> s; bool rev = 0; int ans = 0; for (int i = 1; i &lt; n; ++i) &#123; int a = s[i] - '0', b = s[i - 1] - '0'; if (a == rev &amp;&amp; b != rev) ++ans, rev = !rev; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; C. Sheikh (Hard Version) Portal.ä¸€ä¸ªæ•°åˆ—çš„ä»·å€¼æ˜¯æ•°åˆ—çš„æ€»å’Œå‡å»æ‰€æœ‰å…ƒç´ çš„å¼‚æˆ–å’Œã€‚æ¯ä¸ªè¯¢é—®å½¢å¦‚ Li,RiL_i,R_iLiâ€‹,Riâ€‹ï¼Œå«ä¹‰æ˜¯å¸Œæœ›æ‰¾åˆ°ä¸€ä¸ªåŒºé—´ [l,r][l,r][l,r]ï¼Œæ»¡è¶³ Liâ‰¤lâ‰¤râ‰¤RiL_i\\le l\\le r\\le R_iLiâ€‹â‰¤lâ‰¤râ‰¤Riâ€‹ï¼Œä½¿å¾—è¿™ä¸ªåŒºé—´çš„ä»·å€¼æœ€å¤§ã€‚è¾“å‡ºæ‰€æœ‰ä»·å€¼æœ€å¤§çš„åŒºé—´ä¸­æœ€çŸ­çš„ä¸€ä¸ªï¼ˆå¤šè§£åˆ™ä»»æ„ï¼‰ã€‚n,qâ‰¤2Ã—105n,q\\le 2\\times 10^5n,qâ‰¤2Ã—105 ç”±äºå¼‚æˆ–æ˜¯ä¸è¿›ä½çš„ï¼Œæ‰€ä»¥å½“åŒºé—´é•¿åº¦å˜é•¿çš„æ—¶å€™ï¼Œä»·å€¼å¿…ç„¶ä¸ä¼šå˜å°ã€‚ å¦‚æœä¸€ä¸ªæ•°æ˜¯é›¶ï¼Œé‚£ä¹ˆæ˜¾ç„¶å®ƒå¯¹ç­”æ¡ˆæ˜¯æ²¡æœ‰è´¡çŒ®çš„ï¼Œæ‰€ä»¥å¯ä»¥åˆ æ‰å·¦å³ä¸¤ç«¯çš„é›¶ï¼Œä¸­é—´çš„ä¹Ÿå¯ä»¥åˆ æ‰ã€‚ç”±äºæœ€å¤šæœ‰ 323232 ä½ä¼šå¯¼è‡´å¼‚æˆ–ä¸åŠ æ³•ç­‰ä»·ï¼Œæ‰€ä»¥å»æ‰ 000 ä¹‹åå¯ä»¥æš´åŠ›è®¡ç®—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef long long i64; int n, q; int a[100005]; int pre[100005], nxt[100005]; i64 sum[100005], xxor[100005]; i64 calc(int l, int r) &#123; return (sum[r] - sum[l - 1]) - (xxor[r] ^ xxor[l - 1]); &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; cin >> n >> q; for (int i = 1; i &lt;= n; ++i) cin >> a[i], sum[i] = sum[i - 1] + a[i], xxor[i] = (xxor[i - 1] ^ a[i]); for (int i = 1; i &lt;= n; ++i) if (a[i]) pre[i] = i; else pre[i] = pre[i - 1]; nxt[n + 1] = n + 1; for (int i = n; i >= 1; --i) if (a[i]) nxt[i] = i; else nxt[i] = nxt[i + 1]; while (q--) &#123; int l, r; cin >> l >> r; l = min(r, nxt[l]); r = max(l, pre[r]); if (l == r) &#123; cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; l &lt;&lt; '\\n'; continue; &#125; int u = l, v = r, ans = r - l + 1; i64 res = calc(l, r); for (int i = l; i &lt;= r &amp;&amp; calc(i, r) == res; i = nxt[i + 1]) for (int j = r; j >= i &amp;&amp; calc(i, j) == res; j = pre[j - 1]) if (j - i + 1 &lt; ans) ans = j - i + 1, u = i, v = j; cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; '\\n'; &#125; &#125; return 0; &#125; D. Balance (Hard version) Portal.æœ€åˆä½ æœ‰ä¸€ä¸ªé›†åˆï¼Œè¯¥é›†åˆä»…åŒ…æ‹¬ä¸€ä¸ªå…ƒç´  000ï¼Œè€Œä¸”å®ƒä¼šä¸€ç›´å­˜åœ¨ã€‚ä½ éœ€è¦å¤„ç† q(â‰¤2Ã—105)q(\\le 2\\times 10^5)q(â‰¤2Ã—105) ä¸ªä¸‹è¿°ç±»å‹çš„æ“ä½œï¼š+ x å‘é›†åˆä¸­æ·»åŠ ä¸€ä¸ªæ•´æ•° xxx ã€‚æ•°æ®ä¿è¯é›†åˆä¸­åŸæ¥æ²¡æœ‰è¿™ä¸ªæ•´æ•°ã€‚- x ä»é›†åˆä¸­ç§»é™¤æ•´æ•° xxx ã€‚æ•°æ®ä¿è¯é›†åˆåŒ…å«è¿™ä¸ªå°±è¦åˆ é™¤çš„æ•´æ•°ã€‚? k æ‰¾å‡ºå½“å‰æ˜¯ kkk çš„å€æ•°ä¸”ä¸è¢«åŒ…å«åœ¨é›†åˆä¸­çš„æœ€å°éè´Ÿæ•´æ•° xxxã€‚ è€ƒè™‘ä¹±æï¼Œç”¨å››ä¸ª map åˆ†åˆ«è®°å½•ï¼šsï¼Œæ•°æ˜¯å¦åœ¨é›†åˆå†…ï¼›ansï¼Œç”¨äºç±»ä¼¼ç¦»çº¿ç›´æ¥è·³åˆ°ä¹‹å‰æšä¸¾çš„æœ€å¤§ä½ç½®çš„ ansansansï¼ˆå³å¯¹äºæŸ¥è¯¢è¿‡çš„ kkk æ‰€æŸ¥è¯¢åˆ°çš„ ansansansï¼‰ï¼›delï¼Œæœ‰å“ªäº›æ˜¯è¢«æŸ¥è¯¢è¿‡çš„ï¼Œä½†æ˜¯åæ¥è¢«æ— æƒ…åˆ é™¤çš„ï¼›visï¼Œæœ‰å“ªäº›æ•°å¯ä»¥è¢«ä½œä¸º kkk çš„ç­”æ¡ˆï¼ˆæŸ¥è¯¢çš„æ—¶å€™é¡ºå¸¦ç»Ÿè®¡ï¼‰ã€‚ ä¿®æ”¹çš„æ—¶å€™è¦åˆ©ç”¨ vis æ¥æ›´æ–° delã€‚æŸ¥è¯¢çš„æ—¶å€™ä¸€å¼€å§‹ç›´æ¥æ‹¿ 000 æï¼Œä¹‹åå†æŸ¥å°±ä» ans[x]ans[x]ans[x] å¼€å§‹æš´åŠ›è·³ï¼Œå¹¶ä¸”åœ¨ visvisvis ä¸­æ’å…¥ï¼›æœ€åå†ä¸è¢«åˆ é™¤çš„å½“ä¸­ï¼ˆå› ä¸ºåˆ é™¤äº†ï¼Œåˆå¯ä»¥å–äº†ï¼‰å–ä¸ªæœ€å°å€¼ã€‚ æ—¶é—´å¤æ‚åº¦çš„ä¸¥æ ¼è¯æ˜å¾ˆå›°éš¾ï¼Œä¸æ‰“ç®—ç ”ç©¶äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;set> #include &lt;map> using namespace std; typedef long long i64; map &lt;i64, i64> s, ans; map &lt;i64, set&lt;i64>> del, vis; int main(void) &#123; int q; cin >> q; s[0] = 1; while (q--) &#123; char opt; i64 x; cin >> opt >> x; if (opt == '+') &#123; s[x] = true; for (auto i : vis[x]) del[i].erase(x); &#125; else if (opt == '-') &#123; s[x] = false; for (auto i : vis[x]) del[i].insert(x); &#125; else &#123; while (s[ans[x]]) &#123; vis[ans[x]].insert(x); ans[x] += x; &#125; i64 res = ans[x]; if (!del[x].empty()) res = min(res, *del[x].begin()); cout &lt;&lt; res &lt;&lt; '\\n'; &#125; &#125; return 0; &#125; E. Location Portal.åˆå§‹ç»™å®šåºåˆ— a,ba,ba,bï¼Œéœ€è¦ç»´æŠ¤ä»¥ä¸‹æ“ä½œï¼šç»™å®š l,r,xl,r,xl,r,xï¼Œå¯¹äº âˆ€iâˆˆ[l,r]\\forall i\\in[l,r]âˆ€iâˆˆ[l,r]ï¼Œä»¤ ai=xa_i=xaiâ€‹=xã€‚ç»™å®š l,rl,rl,rï¼Œæ±‚ minâ¡iâˆˆ[l,r]lcmâ¡(ai,bi)gcdâ¡(ai,bi)\\min_{i\\in[l,r]}\\frac{\\operatorname{lcm}(a_i,b_i)}{\\gcd(a_i,b_i)}miniâˆˆ[l,r]â€‹gcd(aiâ€‹,biâ€‹)lcm(aiâ€‹,biâ€‹)â€‹ã€‚æ•°æ®èŒƒå›´ 1â‰¤n,q,aiâ‰¤5Ã—1041\\leq n,q,a_i\\leq 5\\times 10^41â‰¤n,q,aiâ€‹â‰¤5Ã—104ã€‚ è¯´ç‚¹é¢˜å¤–è¯ï¼Œè¿™é“é¢˜å¯¹æˆ‘æ¥è¯´å¾ˆæœ‰å®åŠ›ï¼Œä¹Ÿè®©æˆ‘æ›´åŠ æœŸå¾… NOIP ç»“æŸåå­¦ä¹ æ•°æ®ç»“æ„çš„ç”Ÿæ´»äº†ã€‚ çœ‹åˆ°è¿™ä¹ˆè¯¡å¼‚çš„æŸ¥è¯¢å½“ç„¶åˆ†å—ã€‚ è¿™ç©æ„ç›¸å½“äºæ˜¯æ±‚ f(i)=aiÃ—bigcdâ¡(ai,bi)2f(i)=\\cfrac{a_i\\times b_i}{\\gcd(a_i,b_i)^2}f(i)=gcd(aiâ€‹,biâ€‹)2aiâ€‹Ã—biâ€‹â€‹ï¼Œæ˜¾ç„¶ä¸€å¼€å§‹è¿™ç©æ„çš„å€¼å¯ä»¥é¢„å¤„ç†å‡ºæ¥ã€‚ ç°åœ¨è€ƒè™‘å¦‚ä½•ä¿®æ”¹ï¼Œé›¶æ•£å—å½“ç„¶æš´åŠ›ç»´æŠ¤ï¼Œä½†æ˜¯æ•´å—æ€ä¹ˆåŠï¼Ÿæ³¨æ„è¿™é‡Œä¿®æ”¹æ“ä½œçš„ç‰¹æ®Šæ€§ï¼Œæ˜¯åŒºé—´èµ‹å€¼ï¼Œè€Œä¸”æ•°çš„å€¼åŸŸä¹Ÿå¾ˆå°ï¼Œå› æ­¤å¯ä»¥é¢„å¤„ç† vi,jv_{i,j}vi,jâ€‹ ä»£è¡¨ iii å—ä¿®æ”¹ä¸º jjj ä¹‹åçš„ç­”æ¡ˆã€‚ ä½†æ˜¯è¿™æ ·é¢„å¤„ç†çš„å¤æ‚åº¦å°±å¤ªé«˜äº†ï¼Œéœ€è¦è€ƒè™‘ä¼˜åŒ–ã€‚æ–¹æ³•æ˜¯å¼€ä¸€ä¸ªæ¡¶ tttï¼Œt[x]t[x]t[x] è®°å½•å«æœ‰å› å­ xxx çš„æœ€å° bbbï¼Œç„¶åæšä¸¾æ¯ä¸ª aaa çš„å› æ•°ï¼Œå¦‚æœ t[x]t[x]t[x] å­˜åœ¨ aaa å°±å¯èƒ½æ˜¯æœ€å¤§å…¬çº¦æ•°ï¼Œå°è¯•æ›´æ–°ã€‚ åŸºæœ¬ä¸Šä¸å¡å¸¸ï¼Œåªè¦å—é•¿ä¸ç¦»è°±å°±å¾ˆå®¹æ˜“è¿‡çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;vector> #include &lt;cstring> #pragma GCC optimize(3, \"Ofast\") using namespace std; typedef unsigned int uint; const uint BLOCK_SIZE = 160; const uint INF = 0x9f9f9f9f; uint read(void) &#123; uint x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x; &#125; void print(uint x) &#123; if (x > 9) print(x / 10); putchar(x % 10 ^ 48); &#125; uint n, q; uint a[50005], b[50005]; uint L[334], R[334], minn[334]; uint setv[334], v[334][50005]; uint pos[50005]; vector&lt;uint> d[50005]; uint gcd(uint x, uint y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; inline uint F(uint x) &#123; uint g = gcd(a[x], b[x]); return a[x] * b[x] / (g * g); &#125; inline void pushdown(uint o) &#123; if (!setv[o]) return; for (uint i = L[o]; i &lt;= R[o]; ++i) a[i] = setv[o]; setv[o] = 0; &#125; inline void maintain(uint l, uint r, uint x) &#123; uint p = pos[l]; pushdown(p); for (uint i = l; i &lt;= r; ++i) a[i] = x; minn[p] = INF; for (uint i = L[p]; i &lt;= R[p]; ++i) minn[p] = min(minn[p], F(i)); &#125; void update(uint l, uint r, uint x) &#123; uint p = pos[l], q = pos[r]; if (p == q) &#123; maintain(l, r, x); return; &#125; for (uint i = p + 1; i &lt; q; ++i) setv[i] = x, minn[i] = v[i][x]; maintain(l, R[p], x); maintain(L[q], r, x); &#125; uint Query(uint l, uint r) &#123; uint p = pos[l]; pushdown(p); uint ans = INF; for (uint i = l; i &lt;= r; ++i) ans = min(ans, F(i)); return ans; &#125; uint query(uint l, uint r) &#123; uint p = pos[l], q = pos[r]; if (p == q) return Query(l, r); uint ans = INF; for (uint i = p + 1; i &lt; q; ++i) ans = min(ans, minn[i]); ans = min(ans, Query(l, R[p])); ans = min(ans, Query(L[q], r)); return ans; &#125; int main(void) &#123; n = read(), q = read(); for (uint i = 1; i &lt;= n; ++i) a[i] = read(); for (uint i = 1; i &lt;= n; ++i) b[i] = read(); uint t = n / BLOCK_SIZE; for (uint i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; if (R[t] &lt; n) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = n; &#125; for (uint i = 1; i &lt;= t; ++i) &#123; minn[i] = INF; for (uint j = L[i]; j &lt;= R[i]; ++j) pos[j] = i, minn[i] = min(minn[i], F(j)); &#125; for (uint i = 1; i &lt;= 50000; ++i) // é¢„å¤„ç†çº¦æ•° for (uint j = 1; j * j &lt;= i; ++j) if (i % j == 0) &#123; d[i].emplace_back(j); if (j * j != i) d[i].emplace_back(i / j); &#125; static uint tmp[50005]; // tmp[x] è®°å½•å«æœ‰å› å­ x çš„æœ€å° b memset(v, 0x9f, sizeof(v)); for (uint i = 1; i &lt;= t; ++i) &#123; // é¢„å¤„ç†ä¿®æ”¹åçš„ç­”æ¡ˆ memset(tmp, 0x9f, sizeof(tmp)); for (uint j = L[i]; j &lt;= R[i]; ++j) for (uint a : d[b[j]]) tmp[a] = min(tmp[a], b[j]); for (uint j = 1; j &lt;= 50000; ++j) for (uint a : d[j]) // æšä¸¾ a æ˜¯ j çš„å› å­ if (tmp[a] != INF) v[i][j] = min(v[i][j], j * tmp[a] / (a * a)); // a å¯èƒ½æ˜¯æœ€å¤§å…¬çº¦æ•°ï¼Œå°è¯•æ›´æ–° &#125; while (q--) &#123; uint op = read(), l = read(), r = read(), x; if (op == 1) &#123; x = read(); update(l, r, x); &#125; else &#123; print(query(l, r)); putchar('\\n'); &#125; &#125; return 0; &#125; Codeforces Round #822 (Div.2) Portal. A. Select Three Sticks Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; int n; int a[305]; inline void solve(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); int ans = 2e9; for (int i = 2; i &lt; n; ++i) ans = min(ans, a[i + 1] - a[i - 1]); cout &lt;&lt; ans &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; B. Bright, Nice, Brilliant GNU Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; inline void solve(void) &#123; int n; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) if (j == 1 || j == i) cout &lt;&lt; \"1 \"; else cout &lt;&lt; \"0 \"; putchar('\\n'); &#125; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; C. Removing Smallest Multiples Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; char s[1000005]; inline void solve(void) &#123; int n; i64 ans = 0; scanf(\"%d%s\", &amp;n, s + 1); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i; j &lt;= n; j += i) if (s[j] != '1') &#123; if (s[j] == '0') ans += i; s[j] = '2'; &#125; else break; &#125; printf(\"%lld\\n\", ans); &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; D. Slime Escape Portal. è´ªå¿ƒçš„å‘å·¦å³èµ°ï¼Œåªè¦æ˜¯æ­£çš„ï¼Œå°±å¯ä»¥èµ°ï¼ŒåŒæ—¶è®°å½•å·¦å³æœ€å¤§çš„å’Œç”¨ä»¥è®¡ç®—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k; int a[200005]; i64 s[200005]; void solve(void) &#123; cin >> n >> k; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; if (a[k] &lt; 0) return puts(\"NO\"), void(); s[k] = 0; for (int i = k - 1; i >= 1; --i) s[i] = s[i + 1] + a[i]; for (int i = k + 1; i &lt;= n; ++i) s[i] = s[i - 1] + a[i]; int l = k - 1, r = k + 1; i64 sl = a[k], sr = a[k]; while (l > 0 &amp;&amp; r &lt;= n) &#123; int ll = l, rr = r; while (s[l] + sr >= 0 &amp;&amp; l > 0) sl = max(sl, a[k] + s[l]), l -= 1; while (s[r] + sl >= 0 &amp;&amp; r &lt;= n) sr = max(sr, a[k] + s[r]), r += 1; if (ll == l &amp;&amp; rr == r) return puts(\"NO\"), void(); &#125; puts(\"YES\"); &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; E. Rectangular Congruence Portal.ç»™å®šä¸€ä¸ªè´¨æ•° nnnï¼ˆnâ‰¤350n \\leq 350nâ‰¤350ï¼‰ å’Œä¸€ä¸ªåºåˆ— b1,b2,...,bnb_1, b_2, ..., b_nb1â€‹,b2â€‹,...,bnâ€‹ï¼ˆå¯¹äº âˆ€i\\forall iâˆ€i æœ‰ 0â‰¤bi&lt;n0 \\leq b_i &lt; n0â‰¤biâ€‹&lt;nï¼‰ï¼Œä½ éœ€è¦æ„é€ ä¸€ä¸ª nÃ—nn \\times nnÃ—n çš„çŸ©é˜µ aaaï¼Œæ»¡è¶³ï¼šå¯¹äº âˆ€i,jâ‰¤n\\forall i, j \\leq nâˆ€i,jâ‰¤n æœ‰ 0â‰¤ai,j&lt;n0 \\leq a_{i, j} &lt; n0â‰¤ai,jâ€‹&lt;nã€‚å¯¹äº âˆ€1â‰¤r1&lt;r2â‰¤n,1â‰¤c1&lt;c2â‰¤n\\forall 1 \\leq r_1 &lt; r_2 \\leq n, 1 \\leq c_1 &lt; c_2 \\leq nâˆ€1â‰¤r1â€‹&lt;r2â€‹â‰¤n,1â‰¤c1â€‹&lt;c2â€‹â‰¤n æœ‰ ar1,c1+ar2,c2â‰¡Ì¸ar1,c2+ar2,c1(modn)a_{r1, c1} + a_{r2, c2} \\not\\equiv a_{r1, c2} + a_{r2, c1} \\pmod nar1,c1â€‹+ar2,c2â€‹î€ â‰¡ar1,c2â€‹+ar2,c1â€‹(modn)ã€‚å¯¹äº âˆ€1â‰¤iâ‰¤n\\forall 1 \\le i \\le nâˆ€1â‰¤iâ‰¤n æœ‰ ai,i=bia_{i,i}=b_iai,iâ€‹=biâ€‹ã€‚ å°†æ¡ä»¶äºŒè½¬åŒ–ä¸º ar2,c2âˆ’ar2,c1â‰¡Ì¸ar1,c2âˆ’ar1,c1(modn)a_{r_2,c_2}-a_{r_2,c_1}\\not\\equiv a_{r_1,c_2}-a_{r_1,c_1}\\pmod nar2â€‹,c2â€‹â€‹âˆ’ar2â€‹,c1â€‹â€‹î€ â‰¡ar1â€‹,c2â€‹â€‹âˆ’ar1â€‹,c1â€‹â€‹(modn)ï¼Œè¿™å°±ç›¸å½“äºæ„é€ æ¯ä¸€è¡Œçš„å·®ä¸ä¸€æ ·å³å¯ï¼Œåˆ†åˆ«ä¸º 0âˆ¼nâˆ’10\\sim n-10âˆ¼nâˆ’1ï¼Œç„¶åæ ¹æ® bbb åšç›¸åº”è°ƒæ•´å³å¯ã€‚ å› ä¸º nnn æ˜¯è´¨æ•°ï¼Œæ‰€ä»¥åˆ—å‡ºåŒä½™æ–¹ç¨‹ä¹‹åå‘ç°æ— è§£ï¼Œè¿™æ ·æ„é€ æ˜¯æˆç«‹çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, b; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;b); int diff = ((i - 1) * (i - 1) % n - b + n) % n; for (int j = 1; j &lt;= n; ++j) printf(\"%d \", ((i - 1) * (j - 1) % n - diff + n) % n); putchar('\\n'); &#125; return 0; &#125; F. Zeros and Ones Portal.SSS æ˜¯ä¸€ä¸ªç”±ä»¥ä¸‹æ–¹å¼ç”Ÿæˆçš„æ— é™é•¿ 01 å­—ç¬¦ä¸²ï¼šæœ€åˆï¼Œä»¤ SSS ä¸º â€œ0â€ã€‚éšåè¿›è¡Œä»¥ä¸‹æ“ä½œæ— ç©·å¤šæ¬¡ï¼šå°† SSS ä¸å„ä½å–ååçš„ SSS è¿æ¥ã€‚ä»¥å‰ 4 æ¬¡æ“ä½œä¸ºä¾‹ï¼šæ¬¡æ•°SSSå–ååçš„ SSSæ“ä½œåå¾—åˆ°çš„ SSS1010120110011030110100101101001401101001100101100110100110010110ç»™å®š T(1â‰¤Tâ‰¤100)T(1\\le T \\le 100)T(1â‰¤Tâ‰¤100) ç»„ 222 ä¸ªæ­£æ•´æ•° n,m(1â‰¤n,mâ‰¤1018)n,m(1\\le n,m\\le 10^{18})n,m(1â‰¤n,mâ‰¤1018)ï¼Œæ±‚ S0S1â‹¯Smâˆ’1S_0S_1 \\cdots S_{m-1}S0â€‹S1â€‹â‹¯Smâˆ’1â€‹ å’Œ SnSn+1â‹¯Sn+mâˆ’1S_{n}S_{n+1} \\cdots S_{n+m-1}Snâ€‹Sn+1â€‹â‹¯Sn+mâˆ’1â€‹ æœ‰å‡ ä½ä¸åŒã€‚ ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬è¦æ±‚è§£å¯¹äºå¤šå°‘ä¸ª 0â‰¤i&lt;m0\\le i&lt;m0â‰¤i&lt;m æœ‰ Siâ‰ Si+nS_i\\ne S_{i+n}Siâ€‹î€ =Si+nâ€‹ã€‚å¯ä»¥å‘ç° SiS_iSiâ€‹ ä»£è¡¨ iii çš„äºŒè¿›åˆ¶ä¸­ 111 çš„ä¸ªæ•°çš„å¥‡å¶æ€§ã€‚ è®° dfs(n, m, flag) ä»£è¡¨ n,mn,mn,m æ—¶ï¼Œflagflagflag ä¸ºçœŸä»£è¡¨ç›¸åŒï¼Œå‡ä¸ºä¸åŒã€‚ å½“ 2âˆ£i2\\mid i2âˆ£i æ—¶è®¾ i=2ki=2ki=2kï¼Œé‚£ä¹ˆ Si=Sk,Si+n=Sk+âŒŠn/2âŒ‹âŠ•(n mod 2)S_i=S_k,S_{i+n}=S_{k+\\lfloor n/2\\rfloor}\\oplus (n\\bmod 2)Siâ€‹=Skâ€‹,Si+nâ€‹=Sk+âŒŠn/2âŒ‹â€‹âŠ•(nmod2)ã€‚å‰è€…æ˜¾ç„¶æˆç«‹ï¼Œåè€…åˆ†ç±»è®¨è®ºï¼š å½“ 2âˆ£n2\\mid n2âˆ£n æ—¶ï¼Œæœ‰ Si+n=S(i+n)/2S_{i+n}=S_{(i+n)/2}Si+nâ€‹=S(i+n)/2â€‹ï¼ŒäºŒè¿›åˆ¶æœ€åä¸€ä½æ˜¯ 000ï¼Œæ‰€ä»¥æˆç«‹ã€‚ å½“ 2âˆ¤n2\\nmid n2âˆ¤n æ—¶ï¼Œæœ‰ Si+nâ‰ SâŒŠ(i+n)/2âŒ‹S_{i+n}\\ne S_{\\lfloor(i+n)/2\\rfloor}Si+nâ€‹î€ =SâŒŠ(i+n)/2âŒ‹â€‹ï¼Œå‰è€…æ˜¯å¥‡æ•°ï¼Œæœ€åä¸€ä½ 111 è¢«ææ‰äº†ï¼Œæ‰€ä»¥ä¹Ÿæˆç«‹ã€‚ æˆ‘ä»¬å¯ä»¥å°†æ±‚è§£ Siâ‰ Si+nS_{i}\\ne S_{i+n}Siâ€‹î€ =Si+nâ€‹ è½¬æ¢ä¸ºæ±‚è§£ SkS_{k}Skâ€‹ ä¸ Sk+âŒŠn/2âŒ‹S_{k+\\lfloor n/2\\rfloor}Sk+âŒŠn/2âŒ‹â€‹ çš„å…³ç³»ã€‚ä¹Ÿå°±æ˜¯ dfs(n, m, flag) ä¸­ 2âˆ£i2\\mid i2âˆ£i çš„ä¸€éƒ¨åˆ†ï¼Œç­”æ¡ˆæ˜¯ dfs(n &gt;&gt; 1, m + 1 &gt;&gt; 1, n &amp; 1)ï¼ˆæœ€å¤§åˆ° âŒŠn/2âŒ‹\\lfloor n/2\\rfloorâŒŠn/2âŒ‹ï¼Œæ»¡è¶³ 2âˆ£i2\\mid i2âˆ£i çš„ä¸€å…±æœ‰ âŒŠ(m+1)/2âŒ‹\\lfloor(m+1)/2\\rfloorâŒŠ(m+1)/2âŒ‹ ä¸ªï¼‰ã€‚ å½“ 2âˆ¤i2\\nmid i2âˆ¤i æ—¶ä¹Ÿå¯ä»¥é€šè¿‡ç›¸åº”çš„æ–¹å¼è®¨è®ºå‡ºæ¥ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;map> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; int bitcount(i64 x) &#123; int ans = 0; while (x) &#123; x -= lowbit(x); ++ans; &#125; return ans; &#125; map&lt;pair&lt;i64, i64>, i64> f; i64 calc(i64 n, i64 m, bool flag) &#123; if (m == 0) return 0; if (flag) return m - calc(n, m, 0); if (m == 1) return bitcount(n) % 2 != 0; if (f.count(&#123;n, m&#125;)) return f[&#123;n, m&#125;]; i64 ans = calc(n >> 1, m + 1 >> 1, n &amp; 1) + calc(n + 1 >> 1, m >> 1, n &amp; 1); return f[&#123;n, m&#125;] = ans; &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; i64 n, m; cin >> n >> m; cout &lt;&lt; calc(n, m, 0) &lt;&lt; \"\\n\"; &#125; return 0; &#125; Codeforces Round #833 (Div.2) Portal. A. The Ultimate Square Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n; cin >> n; cout &lt;&lt; (n + 1) / 2 &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; B. Diverse Substrings Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int a[15]; void solve(void) &#123; int n, ans = 0; static char s[100005]; cin >> n >> s; for (int i = 0; i &lt; n; ++i) &#123; memset(a, 0, sizeof(a)); int maxx = 0, flag = 0; for (int j = i; j &lt; n; ++j) &#123; int x = s[j] - '0'; if (a[x] == 0) ++flag; a[x] += 1; maxx = max(a[x], maxx); if (maxx &lt;= flag) ++ans; if (a[s[j] - '0'] > 10) break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; C. Zero-Sum Prefixes Portal.ç»™å®šä¸€ä¸ªé•¿ä¸º nnn çš„æ•°åˆ— aaaï¼Œä½ å¯ä»¥å°†å…¶ä¸­çš„æ¯ä¸ª 000 åˆ†åˆ«æ”¹æˆä»»æ„æ•´æ•°ã€‚æ±‚å‡ºä½ æœ€å¤šèƒ½è®©å¤šå°‘ä¸ª kkk æ»¡è¶³ a1+â‹¯+ak=0a_1+\\dots+a_k=0a1â€‹+â‹¯+akâ€‹=0ã€‚ è€ƒè™‘ 000 å¹²äº†ä»€ä¹ˆï¼Œå¯ä»¥å˜åŠ¨åé¢ä¸€æ®µçš„å‰ç¼€å’Œï¼Œè¿™æ ·ç”¨ä¸€ä¸ª STL map è®°å½•ä¸€ä¸‹å“ªä¸€ä¸ªå‰ç¼€å’Œæœ€å¤šï¼Œç„¶åå°±æŠŠè¿™ä¸ª 000 å˜æˆè¿™ä¸ªçš„ç›¸åæ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[200005]; i64 s[200005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; int ans = 0, maxt = 0; bool fs = true; map&lt;i64, int> se; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] == 0) &#123; if (fs) fs = false; else &#123; ans += maxt; maxt = 0; se.clear(); s[i] = 0; &#125; &#125; s[i] = s[i - 1] + a[i]; if (fs) ans += (s[i] == 0); else maxt = max(maxt, se[s[i]] += 1); &#125; if (!fs) ans += maxt; cout &lt;&lt; ans &lt;&lt; '\\n'; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; D. ConstructOR Portal.ç»™å®š a,b,d(&lt;230)a,b,d(&lt;2^{30})a,b,d(&lt;230)ï¼Œè¦æ±‚æ„é€ ä¸€ä¸ª x(x&lt;260)x(x&lt;2^{60})x(x&lt;260) ä½¿å¾— dâˆ£(aorâ¡x),dâˆ£(borâ¡x)d\\mid (a\\operatorname{or} x),d\\mid(b\\operatorname{or} x)dâˆ£(aorx),dâˆ£(borx)ã€‚ å½“ lowbit(aorâ¡b)&lt;lowbit(d)\\text{lowbit}(a\\operatorname{or}b)&lt;\\text{lowbit}(d)lowbit(aorb)&lt;lowbit(d)ï¼Œæ˜¾ç„¶æ— è§£ã€‚ å¦åˆ™å¯ä»¥è€ƒè™‘æ„é€ ä¸€ä¸ª xxx ä½¿å¾— aorâ¡x=borâ¡x=xa\\operatorname{or} x=b\\operatorname{or} x=xaorx=borx=xã€‚ä¸ºäº†ä½¿å¾— dâˆ£xd\\mid xdâˆ£xï¼Œxxx éœ€è¦ç”±è‹¥å¹² ddd æ„æˆã€‚ æšä¸¾ aorâ¡ba\\operatorname{or} baorb äºŒè¿›åˆ¶ä¸‹çš„æ¯ä¸€ä½ï¼Œå¦‚æœå½“å‰ä½æ˜¯ 111ï¼Œè€Œä¸”å·²ç»æ„é€ å‡ºæ¥çš„ç­”æ¡ˆçš„å½“å‰ä½æ˜¯ 000ï¼Œé‚£ä¹ˆè¿™ä¸€ä½å°±éœ€è¦å˜æˆ 111ï¼ŒåŒæ—¶æ»¡è¶³åŠ è¿›å»çš„æ˜¯ç”±è‹¥å¹² ddd æ„æˆçš„ï¼Œå› æ­¤åŠ ä¸Šçš„å†…å®¹å¿…é¡»æ˜¯ç”± ddd å·¦ç§»å¾—åˆ°çš„ã€‚å·¦ç§»å¤šå°‘ä½å‘¢ï¼Ÿè¦æƒ³è®©ç¬¬ iii ä½æ°å¥½ä¸º 111ï¼Œé‚£ä¹ˆä»¤ ddd ç¬¬ä¸€ä¸ª 111 å‡ºç°åœ¨ç¬¬ kkk ä½ï¼Œå°±éœ€è¦è®©å®ƒå·¦ç§» iâˆ’ki-kiâˆ’k ä½ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; inline int lowbit(int x) &#123; return x &amp; -x; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) &#123; i64 a, b, d; cin >> a >> b >> d; if (lowbit(a | b) &lt; lowbit(d)) cout &lt;&lt; \"-1\\n\"; else &#123; i64 x = 0, k = 0; while ((d >> k &amp; 1) ^ 1) ++k; for (int i = 0; i &lt; 30; ++i) if (((a | b) >> i &amp; 1) &amp;&amp; (x >> i &amp; 1) == 0) if (i >= k) x += (d &lt;&lt; i - k); cout &lt;&lt; x &lt;&lt; \"\\n\"; &#125; &#125; return 0; &#125; Codeforces Round #802 (Div.2) Portal. A. Optimal Path Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; i64 n, m; cin >> m >> n; cout &lt;&lt; n * (n - 1) / 2 + (n + n * m) * m / 2 &lt;&lt; \"\\n\"; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; B. Palindromic Numbers Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n; static char a[100005], b[100005], c[100005]; cin >> n >> b; if (b[0] == '9') &#123; for (int i = 0; i &lt;= n; ++i) a[i] = 1; for (int i = 0; i &lt; n; ++i) b[i] -= '0'; for (int i = n - 1; i >= 0; --i) if (a[i] &lt; b[i]) &#123; a[i] += 10; a[i - 1] -= 1; c[i] = a[i] - b[i]; &#125; else c[i] = a[i] - b[i]; for (int i = 0; i &lt; n; ++i) putchar(c[i] + '0'); return; &#125; for (int i = 0; i &lt; n; ++i) putchar('9' - b[i] + '0'); &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; solve(); puts(\"\"); &#125; return 0; &#125; C. Helping the Nature Portal.ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— AAAï¼Œæ”¯æŒä»¥ä¸‹ä¸‰ç§æ“ä½œï¼šå°† A1,â€¦,AiA_1,\\dots,A_iA1â€‹,â€¦,Aiâ€‹ éƒ½å‡å»ä¸€ï¼›å°† Ai,â€¦,AnA_i,\\dots,A_nAiâ€‹,â€¦,Anâ€‹ éƒ½å‡å»ä¸€ï¼›å…¨å±€åŠ ä¸Šä¸€ã€‚ å°†åºåˆ—å·®åˆ†ï¼Œé‚£ä¹ˆå‰ä¸¤ç§æ“ä½œå¯¹åº”ï¼š Bi+1B_{i+1}Bi+1â€‹ åŠ ä¸Šä¸€ï¼› BiB_{i}Biâ€‹ å‡å»ä¸€ã€‚ é‚£ä¹ˆé™¤äº†ç¬¬ä¸€ä¸ªæ•°ï¼Œå‰©ä¸‹çš„æ‰€æœ‰æ•°æˆ‘ä»¬éƒ½å¯ä»¥å°†å…¶å˜æˆ 000ï¼Œè¿™æ ·åºåˆ—ä¸­çš„æ‰€æœ‰æ•°éƒ½ç›¸ç­‰ï¼ŒæŠŠç¬¬ä¸€ä¸ªæ•°ä½œä¸ºâ€œæ ‡å‡†â€è¿›è¡Œç»´æŠ¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[200005], b[200005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; b[i] = a[i] - a[i - 1]; &#125; i64 ans = 0, h = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; ans += abs(b[i]); if (b[i] &lt; 0) h += b[i]; &#125; cout &lt;&lt; ans + abs(h) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; D. River Locks Portal.æœ‰ nnn ä¸ªå®¹å™¨ï¼Œç¬¬ iii ä¸ªå®¹å™¨å®¹é‡ä¸º viv_iviâ€‹ å‡ï¼Œå¯ä»¥å®¹çº³ [0,vi][0,v_i][0,viâ€‹] å‡çš„æ°´ã€‚æ»¡å‡ºå»çš„æ°´ä¼šå°†ä»å®¹å™¨ iii è½¬ç§»åˆ°å®¹å™¨ i+1i+1i+1ï¼Œå¦‚æœ i+1i+1i+1 ä¹Ÿæ»¡äº†ä¼šè½¬ç§»å¾—æ›´è¿œã€‚æ»¡å‡ºæœ€åä¸€ä¸ªå®¹å™¨çš„æ°´ä¼šå€’åˆ°æ²³ä¸­ã€‚ç°åœ¨è¦å°†æ‰€æœ‰å®¹å™¨å¡«æ»¡ã€‚ä½ å¯ä»¥é€‰æ‹©ä¸€äº›å®¹å™¨æ³¨æ°´ï¼Œè®©è¿™äº›å®¹å™¨æ¯ç§’è¿›å…¥ä¸€å‡æ°´ã€‚qqq æ¬¡è¯¢é—®ï¼Œé—®æœ€åˆæ‰€æœ‰å®¹å™¨éƒ½æ˜¯ç©ºçš„ï¼Œæœ€å°‘é€‰æ‹©å¤šå°‘ä¸ªå®¹å™¨æ³¨æ°´ä½¿å¾— tit_itiâ€‹ ç§’å†…èƒ½å¡«æ»¡æ‰€æœ‰å®¹å™¨ã€‚1â‰¤n,qâ‰¤2Ã—1051\\leq n,q\\leq 2\\times 10^51â‰¤n,qâ‰¤2Ã—105ï¼Œ1â‰¤vi,tiâ‰¤1091\\leq v_i,t_i\\leq 10^91â‰¤viâ€‹,tiâ€‹â‰¤109ã€‚ å®¹å™¨ä¸€å®šæ˜¯è¦ä» 111 å¾€ nnn å¼€çš„ï¼Œè¿™æ ·å¦‚æœèƒ½è£…æ»¡ï¼Œç­”æ¡ˆå°±æ˜¯ âŒˆâˆ‘vnâŒ‰\\left\\lceil\\frac{\\sum v}{n}\\right\\rceilâŒˆnâˆ‘vâ€‹âŒ‰ï¼Œä¸èƒ½è£…æ»¡å½“ä¸”ä»…å½“æ— æ³•å°†å‰ iii ä¸ªå®¹å™¨åœ¨ ttt çš„æ—¶é—´å†…è£…æ»¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, q; i64 a[200005], res = 0; int main(void) &#123; ios::sync_with_stdio(false); cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; a[i] += a[i - 1]; res = max(res, a[i] / i + (a[i] % i == 0 ? 0 : 1)); &#125; cin >> q; while (q--) &#123; int t; cin >> t; cout &lt;&lt; (t &lt; res ? -1 : a[n] / t + (a[n] % t == 0 ? 0 : 1)) &lt;&lt; '\\n'; &#125; return 0; &#125; E. Serega the Pirate Portal.ä¸€ä¸ª nÃ—mn \\times mnÃ—m çš„è¡¨æ ¼ä¸­å¡«å…¥äº† 1,2,...,nÃ—m1,2,...,n \\times m1,2,...,nÃ—m çš„æ‰€æœ‰æ•°æ°ä¸€æ¬¡ã€‚ç§°ä¸€ç§å¡«æ³•å¯è§£ï¼Œå½“å¯ä»¥æ‰¾å‡ºä¸€æ¡è·¯å¾„ï¼Œå®ƒç¬¬ä¸€æ¬¡åˆ°è¾¾æ¯ä¸ªæ ¼å­çš„é¡ºåºä¸æ ¼å†…æ‰€å¡«çš„æ•°åŒåºã€‚æ¢è¨€ä¹‹ï¼Œè¿™æ¡è·¯å¾„åº”è¯¥å…ˆç»è¿‡ xxxï¼Œå†ç»è¿‡ x+1x+1x+1ã€‚è·¯å¾„çš„èµ·ç‚¹ï¼Œç»ˆç‚¹ï¼Œé•¿åº¦ä»»æ„ï¼Œå¯ä»¥é‡å¤ç»è¿‡åŒä¸€ä¸ªæ ¼å­ã€‚é—®å¯¹ç»™å®šçš„å¡«æ³•ï¼Œè‡³å°‘éœ€è¦äº¤æ¢å‡ å¯¹æ ¼å­ï¼Œæ‰èƒ½ä½¿å¡«æ³•å¯è§£ã€‚è‹¥æœ€å°å€¼ä¸º 000ï¼Œè¾“å‡º 000ï¼›è‹¥æœ€å°å€¼ä¸º 111ï¼Œè¾“å‡º 111 å’Œäº¤æ¢æ–¹æ³•æ•°ï¼›è‹¥æœ€å°å€¼å¤§äº 111ï¼Œè¾“å‡º 222ã€‚nÃ—mâ‰¤400000n \\times m \\le 400000nÃ—mâ‰¤400000ã€‚ å•Šè¿™é¢˜ä¸éš¾ï¼Œå°±æ˜¯å¾ˆæ¶å¿ƒï¼ˆå½“ç„¶ä»…å¯¹äºç¬”è€…ï¼‰ï¼ é¦–å…ˆçœ‹çœ‹ä»€ä¹ˆæ—¶å€™ç­”æ¡ˆæ˜¯ 000ï¼šä¸€ä¸ªç‚¹èƒ½å¤Ÿèµ°åˆ°ï¼Œè¦ä¹ˆå®ƒæ˜¯ 111ï¼Œè¦ä¹ˆåœ¨ä¸€ä¸ªå››è”é€šå—ä¸­æœ‰ç‚¹å¯ä»¥èµ°åˆ°å®ƒï¼Œä¹Ÿå°±æ˜¯ä¸Šä¸‹å·¦å³æœ‰ä¸€ä¸ªæ•°æ¯”å®ƒå°ã€‚ å½“æœ‰ä¸€äº›ç‚¹ä¸æ»¡è¶³ä¸Šè¿°æ¡ä»¶æ—¶ï¼Œå°±å¿…é¡»è¦æ‰§è¡Œäº¤æ¢æ“ä½œäº†ã€‚äº¤æ¢ä»€ä¹ˆï¼Ÿåªæœ‰äº¤æ¢è¿™ä¸ªå››è”é€šå—ä¸­çš„ç‚¹å’Œå±€å¤–çš„ä¸€ä¸ªç‚¹æ‰å¯èƒ½è®©è¿™ä¸ªç‚¹å˜å¾—åˆæ³•ã€‚ä½†æ˜¯è¿™é“é¢˜å¹¶ä¸éœ€è¦æˆ‘ä»¬è¾“å‡ºæ“ä½œæ•°ï¼Œåªæœ‰åœ¨æ“ä½œæ•°ä¸º 111 çš„æ—¶å€™æ‰è¦æ±‚æˆ‘ä»¬è¾“å‡ºæ–¹æ¡ˆæ•°ï¼Œå› æ­¤å¯ä»¥æš´åŠ›æšä¸¾ï¼šé€‰æ‹©å…¶ä¸­ä»»æ„ä¸€ä¸ªä¸èƒ½è¢«èµ°åˆ°çš„ç‚¹ï¼Œæšä¸¾ä¸å®ƒäº¤æ¢çš„ç‚¹ï¼Œäº¤æ¢åçœ‹èƒ½å½±å“åˆ°çš„ 101010 ä¸ªç‚¹ï¼ˆç›¸å½“äºæ”¹å˜äº†ä¸¤ä¸ªå››è”é€šå—ï¼Œå…± 101010 ä¸ªç‚¹ï¼‰å’Œå‰©ä¸‹çš„åŸæœ¬å°±ä¸èƒ½åˆ°çš„ç‚¹æ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼Œæ»¡è¶³æ¡ä»¶å°±æ˜¯ä¸€ç§æ–¹æ¡ˆã€‚ å¦‚æœä¸€å¼€å§‹å°±ä¸èƒ½åˆ°è¾¾çš„èŠ‚ç‚¹è¶…è¿‡äº† 101010 ä¸ªï¼Œé‚£ä¹ˆä¸€æ¬¡äº¤æ¢æ“ä½œå°±è‚¯å®šä¸èƒ½å®Œæˆäº†ï¼ˆä¸€æ¬¡äº¤æ¢åªèƒ½å½±å“è‡³å¤š 101010 ä¸ªç‚¹ï¼‰ã€‚ æ—¶é—´å¤æ‚åº¦ O(nm)O(nm)O(nm)ï¼Œå› ä¸ºéœ€è¦æšä¸¾æ–¹å‘å¸¦ä¸€ä¸ªçº¦ç™¾å€çš„å¸¸æ•°ã€‚ä½†å®é™…ä¸Šå¾ˆå¿«å°±ä¼šå› ä¸ºä¸ç¬¦åˆæ¡ä»¶è€Œè·³å‡ºå¾ªç¯ï¼Œæ ¹æœ¬è·‘ä¸æ»¡ï¼Œå¯ä»¥è½»æ¾é€šè¿‡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;set> using namespace std; const int dx[] = &#123;0, 1, -1, 0, 0&#125;, dy[] = &#123;0, 0, 0, 1, -1&#125;; int n, m, X[400005], Y[400005]; vector&lt;vector&lt;int> > a; vector&lt;int> v; bool check(int x, int y) &#123; if (a[x][y] == 1) return true; for (int i = 1; i &lt;= 4; ++i) &#123; int tx = x + dx[i], ty = y + dy[i]; if (tx >= 1 &amp;&amp; tx &lt;= n &amp;&amp; ty >= 1 &amp;&amp; ty &lt;= m &amp;&amp; a[tx][ty] &lt; a[x][y]) return true; &#125; return false; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); a.resize(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i].resize(m + 1); for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;a[i][j]); X[a[i][j]] = i, Y[a[i][j]] = j; &#125; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (!check(i, j)) v.push_back(a[i][j]); if (v.empty()) return puts(\"0\"), 0; if (v.size() >= 10) return puts(\"2\"), 0; set&lt;pair&lt;int, int>> s; for (int i = 0; i &lt; 5; ++i) &#123; int x = X[v[0]] + dx[i], y = Y[v[0]] + dy[i]; if (x &lt; 1 || x > n || y &lt; 1 || y > m) continue; for (int xx = 1; xx &lt;= n; ++xx) for (int yy = 1; yy &lt;= m; ++yy) &#123; swap(a[x][y], a[xx][yy]); bool ok = true; for (int j = 0; j &lt; v.size() &amp;&amp; ok; ++j) if (!check(X[v[j]], Y[v[j]])) ok = false; for (int j = 0; j &lt; 5 &amp;&amp; ok; ++j) &#123; int tx = x + dx[j], ty = y + dy[j]; if (tx >= 1 &amp;&amp; tx &lt;= n &amp;&amp; ty >= 1 &amp;&amp; ty &lt;= m &amp;&amp; !check(tx, ty)) ok = false; &#125; for (int j = 0; j &lt; 5 &amp;&amp; ok; ++j) &#123; int tx = xx + dx[j], ty = yy + dy[j]; if (tx >= 1 &amp;&amp; tx &lt;= n &amp;&amp; ty >= 1 &amp;&amp; ty &lt;= m &amp;&amp; !check(tx, ty)) ok = false; &#125; if (ok) &#123; int u = a[x][y], v = a[xx][yy]; if (u > v) swap(u, v); s.insert(make_pair(u, v)); &#125; swap(a[x][y], a[xx][yy]); &#125; &#125; if (s.empty()) puts(\"2\"); else printf(\"1 %d\\n\", s.size()); return 0; &#125; Codeforces Round #813 (Div. 2) Portal. A. Wonderful Permutation Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k; int p[105]; bool a[105]; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", p + i); memset(a, 0, sizeof(a)); for (int i = 1; i &lt;= k; ++i) a[p[i]] = true; int ans = 0; for (int i = 1; i &lt;= k; ++i) if (!a[i]) ++ans; cout &lt;&lt; ans &lt;&lt; endl; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; B. Woeful Permutation Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[100005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) a[i] = i; for (int i = n; i >= 1; i -= 2) if (i > 1) swap(a[i], a[i - 1]); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; C. Sort Zero Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[100005]; bool b[100005]; void solve(void) &#123; scanf(\"%d\", &amp;n); memset(b, 0, sizeof(b)); set&lt;int> s; int maxx = 0, ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (b[a[i]]) a[i] = 0; if (a[i] &lt; maxx) &#123; ans += s.size(); for (auto x : s) b[x] = true; s.clear(); maxx = 0; &#125; if (b[a[i]]) a[i] = 0; if (a[i] != 0) s.insert(a[i]); maxx = max(maxx, a[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\\n'; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; D. Empty Graph Portal.ç»™å®šä¸€ä¸ªé•¿ä¸º nnn çš„åºåˆ— aaaã€‚å®šä¹‰ä¸€ nnn ä¸ªç‚¹çš„æ— å‘å®Œå…¨å›¾ï¼Œç‚¹ lll å’Œç‚¹ rrr ä¹‹é—´çš„è·ç¦»ä¸º minâ¡iâˆˆ[l,r]{ai}\\min\\limits_{i\\in[l,r]}\\{a_i\\}iâˆˆ[l,r]minâ€‹{aiâ€‹}ã€‚ä½ å¯ä»¥è¿›è¡Œ kkk æ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥é€‰å®š âˆ€iâˆˆ[1,n]\\forall i \\in [1,n]âˆ€iâˆˆ[1,n] å¹¶å°† aia_iaiâ€‹ èµ‹å€¼ä¸ºä¸€ä¸ª [1,109][1,10^9][1,109] çš„æ•´æ•°ã€‚è¯·æœ€å¤§åŒ–è¿™ä¸ªå›¾çš„ç›´å¾„ã€‚è®¾ d(u,v)d(u,v)d(u,v) è¡¨ç¤º uuu åˆ° vvv çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œå›¾çš„ç›´å¾„å®šä¹‰ä¸º maxâ¡1â‰¤u&lt;vâ‰¤nd(u,v)\\max\\limits_{1\\leq u &lt; v \\leq n} d(u,v)1â‰¤u&lt;vâ‰¤nmaxâ€‹d(u,v)ã€‚ äºŒåˆ†ç­”æ¡ˆã€‚ç›´å¾„æ˜¾ç„¶åªèƒ½æ˜¯ d(ai,ai+1)d(a_i,a_{i+1})d(aiâ€‹,ai+1â€‹)ï¼Œè·ç¦»è¦ä¹ˆæ˜¯ç›´æ¥èµ°ï¼Œè¦ä¹ˆæ˜¯äºŒå€å…¨å±€æœ€å°ï¼Œæ ¹æ®æ­¤ check å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; const int INF = 1e9; int n, k; int a[100005], b[100005]; bool P(int x) // æœ€å°å€¼æœ€å¤§ï¼Œç°åœ¨æœ€å°å€¼ä¸º x &#123; int res = 0; for (int i = 1; i &lt;= n; ++i) b[i] = a[i]; for (int i = 1; i &lt;= n; ++i) if (2 * b[i] &lt; x) ++res, b[i] = INF; int t = 2; for (int i = 1; i &lt; n; ++i) t = min(t, (b[i] &lt; x) + (b[i + 1] &lt; x)); return res + t &lt;= k; &#125; void solve(void) &#123; cin >> n >> k; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; int L = 0, R = INF + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) L = mid; else R = mid; &#125; cout &lt;&lt; L &lt;&lt; '\\n'; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; 12 æœˆè®°å½• sto KH. Codeforces Round #825 (Div. 2) Portal. æ‰“çš„è€åƒåœ¾äº†ã€‚ A. Make A Equal to B Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[105], b[105]; void solve(void) &#123; cin >> n; int acnt = 0, bcnt = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) cin >> a[i], acnt += a[i]; for (int i = 1; i &lt;= n; ++i) cin >> b[i], bcnt += b[i]; for (int i = 1; i &lt;= n; ++i) if (a[i] != b[i]) ++cnt; int t = abs(acnt - bcnt); if (cnt > t) ++t; cout &lt;&lt; t &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Playing with GCD Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[100005]; int b[100005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; b[1] = a[1]; b[n + 1] = a[n]; for (int i = 2; i &lt;= n; ++i) b[i] = a[i - 1] / __gcd(a[i - 1], a[i]) * a[i]; for (int i = 1; i &lt;= n; ++i) if (__gcd(b[i], b[i + 1]) != a[i]) &#123; cout &lt;&lt; \"NO\\n\"; return; &#125; cout &lt;&lt; \"YES\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; C2. Good Subarrays (Hard Version) Portal.æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªåºåˆ— bbb æ˜¯å¥½çš„å½“ä¸”ä»…å½“æ‰€æœ‰çš„ biâ‰¥ib_i \\ge ibiâ€‹â‰¥iã€‚ç°åœ¨ç»™ä½  qqq æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®æœ‰ä¸¤ä¸ªæ•° ppp å’Œ xxxï¼Œé—®æŠŠ apa_papâ€‹ èµ‹å€¼æˆ xxx å aaa æ•°ç»„å¥½çš„å­æ®µçš„ä¸ªæ•°ï¼Œè¯¢é—®ä¹‹é—´ç›¸äº’ç‹¬ç«‹ã€‚1â‰¤nâ‰¤2Ã—1051\\le n \\le 2 \\times 10^51â‰¤nâ‰¤2Ã—105ï¼Œ1â‰¤qâ‰¤2Ã—1051 \\le q \\le 2 \\times 10^51â‰¤qâ‰¤2Ã—105ã€‚1â‰¤aiâ‰¤n1\\le a_i \\le n1â‰¤aiâ€‹â‰¤nï¼Œ1â‰¤pj,xjâ‰¤n1 \\le p_j,x_j \\le n1â‰¤pjâ€‹,xjâ€‹â‰¤nã€‚ æŸ¥çœ‹ä»£ç  // D. Equal Binary Subsequences Portal.ç»™ä½ ä¸€ä¸ªé•¿ä¸º 2n2n2n çš„01ä¸² sss ï¼Œä½ éœ€è¦å°†å…¶åˆ†æˆä¸¤ä¸ªç›¸ç­‰çš„å­åºåˆ—ã€‚åœ¨æ­¤ä¹‹å‰ä½ éœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œä¸€æ¬¡ï¼šé€‰ä¸€ä¸ª sss çš„å­åºåˆ—ï¼ˆå¯èƒ½ä¸ºç©ºï¼‰ï¼Œç„¶åå°†å…¶å‘å³å¾ªç¯ç§»ä½ä¸€ä½ã€‚ä½ èƒ½åœ¨æ‰§è¡Œä»¥ä¸Šæ“ä½œä¸€æ¬¡åæŠŠ sss åˆ†æˆä¸¤ä¸ªç›¸ç­‰çš„å­åºåˆ—å—ï¼Ÿè¦æ±‚ç»™å‡ºæ–¹æ¡ˆã€‚1â‰¤nâ‰¤1051\\le n\\le 10^51â‰¤nâ‰¤105 ã€‚ å…ƒç´ å‡ºç°æ¬¡æ•°å¿…é¡»æ˜¯å¶æ•°ï¼Œç„¶åå‘¢ï¼Ÿæˆ‘ä»¬å°†ä¸¤ä¸ªæ•°åˆ†ä¸ºä¸€ç»„ï¼Œå¦‚æœä¸€æ ·é‚£è‚¯å®šæ˜¯ä¸€ä¸ªå­åºåˆ—ä¸€ä¸ªï¼Œå¦åˆ™å°±æŒ‰ç…§é¡ºåºæ’åˆ—æˆä¸€ä¸ª 0101...01 çš„å­åºåˆ—ï¼Œä¸€ä¸ª 1010...10 çš„å­åºåˆ—ï¼Œç„¶åç¿»è½¬å…¶ä¸­ä¸€ä¸ªå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int p[200005]; bool d[200005]; char s[200005]; void solve(void) &#123; cin >> n >> s + 1; int res = 0; for (int i = 1; i &lt;= n * 2; ++i) &#123; s[i] -= '0'; if (s[i] == 0) ++res; &#125; if (res &amp; 1) return cout &lt;&lt; \"-1\\n\", void(); memset(d, 1, sizeof(d)); int ans = n, t = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x = i * 2 - 1, y = i * 2; if (s[x] == s[y]) &#123; p[i] = x; --ans; d[i] = 0; &#125; else &#123; t ^= 1; if (s[x] == t) p[i] = x; else p[i] = y; &#125; &#125; cout &lt;&lt; ans &lt;&lt; ' '; for (int i = 1; i &lt;= n; ++i) if (d[i]) &#123; int x = i * 2 - 1, y = i * 2; int t = (p[i] == x ? y : x); cout &lt;&lt; t &lt;&lt; ' '; &#125; cout &lt;&lt; '\\n'; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; p[i] &lt;&lt; ' '; cout &lt;&lt; '\\n'; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; E. Swap and Take Portal.ç»™å®šä¸€ä¸ªé•¿ä¸º n(1â‰¤nâ‰¤500)n(1\\le n \\le 500)n(1â‰¤nâ‰¤500) çš„æ­£æ•´æ•°åºåˆ— aaaã€‚åˆå§‹ä½ çš„åˆ†æ•°ä¸º 000ï¼Œéœ€è¦è¿›è¡Œ nnn è½®æ“ä½œã€‚åœ¨ç¬¬ iii è½®ï¼Œä½ å¯ä»¥é€‰æ‹©äº¤æ¢ä¸¤ä¸ªç›¸é‚»çš„æ•°å¹¶å°†å…¶ä¸­ä¸€ä¸ªå˜ä¸º 000ï¼Œä¹Ÿå¯ä»¥å•¥éƒ½ä¸å¹²ã€‚æ— è®ºæ˜¯å¦äº¤æ¢ï¼Œç¬¬ iii è½®ç»“æŸåä½ çš„åˆ†æ•°ä¼šå¤š aia_iaiâ€‹ã€‚æ±‚ä½ æœ€å¤§èƒ½å¾—åˆ°çš„åˆ†æ•°ã€‚ å…ˆè€ƒè™‘ä¸€ä¸‹äº¤æ¢çš„æ„ä¹‰ã€‚è´¡çŒ®çš„æŒ‡é’ˆæ˜¯ä»å·¦è·‘åˆ°å³ï¼Œä¸”é€Ÿåº¦ä¸º 111ï¼Œè€Œæˆ‘ä»¬çš„äº¤æ¢ä¹Ÿåªèƒ½ä¸€æ¬¡äº¤æ¢ç›¸é‚»çš„ä¸€å¯¹ï¼Œè‚¯å®šä¸èƒ½è·‘è¿‡è¿™ä¸ªæŒ‡é’ˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæŠŠè´¡çŒ®çš„æ•°å­—åœ¨åŸåºåˆ—ä¸­çš„ä¸‹æ ‡å†™å‡ºæ¥è®°ä½œåºåˆ— pppï¼Œé‚£ä¹ˆä¸€å®šæœ‰ p1â‰¤p2â‰¤â‹¯â‰¤pnp_1\\le p_2\\le\\cdots\\le p_np1â€‹â‰¤p2â€‹â‰¤â‹¯â‰¤pnâ€‹ã€‚è‹¥æšä¸¾è¿™ä¸€è½®è¦è·å¾—çš„åˆ†æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªäº¤æ¢æ¬¡æ•° kkk å°±å¯ä»¥ç”¨æ¥ç®€å•åœ°åˆ¤æ–­å½“å‰è¿™ä¸ªåˆ†æ•°æ˜¯å¦å¯ä»¥æ‹¿åˆ°ã€‚ è®¾ fi,j,kf_{i,j,k}fi,j,kâ€‹ ä»£è¡¨å½“å‰ä¸ºç¬¬ iii è½®ï¼Œè¦è·å–çš„è´¡çŒ®æ˜¯ aja_jajâ€‹ï¼Œè¿™ä¸€è½®ä¹‹åæœ‰ kkk æ¬¡æ“ä½œæ²¡æœ‰ä½¿ç”¨èƒ½å¤Ÿè·å¾—çš„æœ€å¤§ä»·å€¼ï¼Œåˆå§‹æ—¶æœ‰ f1,1,1=a1,f1,2,0=a2f_{1,1,1}=a_1,f_{1,2,0}=a_2f1,1,1â€‹=a1â€‹,f1,2,0â€‹=a2â€‹ã€‚è¿™æ ·æˆ‘ä»¬çš„äº¤æ¢æœ‰ä¸¤ç§é€‰æ‹©ï¼šä¸€ç§æ˜¯å°† iii å‰é¢çš„äº¤æ¢åˆ° iii æ¥è·å–å…¶ä»·å€¼ï¼ŒäºŒæ˜¯åœ¨ iii åé€‰æ‹©ä¸¤ä¸ªæ•°è¿›è¡Œäº¤æ¢ï¼Œä¸ºç¬¬ iii è½®ä»¥ååšâ€œå‡†å¤‡â€œã€‚å› æ­¤æœ‰è½¬ç§»ï¼š å°†ä¸Šä¸€è½®çš„ jjj è½¬è¿‡æ¥ï¼Œfi,j,k=fiâˆ’1,j,k+ajf_{i,j,k}=f_{i-1,j,k}+a_jfi,j,kâ€‹=fiâˆ’1,j,kâ€‹+ajâ€‹ï¼› å°† aja_jajâ€‹ ä» jjj æ¢åˆ° iiiï¼Œéœ€è¦æ¶ˆè€— jâˆ’ij-ijâˆ’i æ¬¡æ“ä½œï¼Œé‚£ä¹ˆ fi,j,k=fiâˆ’1,t,kâˆ’1+jâˆ’i(jâ‰¥i,t&lt;j)f_{i,j,k}=f_{i-1,t,k-1+j-i}(j\\ge i,t&lt;j)fi,j,kâ€‹=fiâˆ’1,t,kâˆ’1+jâˆ’iâ€‹(jâ‰¥i,t&lt;j)ï¼Œt&lt;jt&lt;jt&lt;j çš„åŸå› æ˜¯è´¡çŒ®ä¸‹æ ‡å•è°ƒä¸é™ï¼Œç›¸ç­‰æ˜¯ä¸Šä¸€ç§è½¬ç§»ï¼›jâ‰¥ij\\ge ijâ‰¥i çš„åŸå› æ˜¯æˆ‘ä»¬ä¹‹å‰è¯´çš„â€œé€Ÿåº¦â€ã€‚ ç°åœ¨çš„é—®é¢˜å°±æˆäº†å¦‚ä½•å¿«é€Ÿæ‰¾åˆ°è¿™ä¸ªæœ€å¤§çš„ f[i-1][t][k-1+j-i]ã€‚æˆ‘ä»¬å•ç‹¬è®°å½•ä¸€ä¸ªæ•°ç»„ gggï¼Œç”¨ gi,j,kg_{i,j,k}gi,j,kâ€‹ ä»£è¡¨ maxâ¡{fi,t,kâˆ£1â‰¤t&lt;j}\\max\\{f_{i,t,k}\\mid 1\\le t &lt; j\\}max{fi,t,kâ€‹âˆ£1â‰¤t&lt;j} å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, a[505], INF; int f[2][505][505]; // è¿›è¡Œ i è½®ï¼Œç¬¬ i è½®è·å¾—çš„åˆ†æ•°æ˜¯ a[j]ï¼Œk æ¬¡æ²¡ç”¨ int g[2][505][505]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0xbf, sizeof(f)); INF = -f[0][0][0]; memset(g, 0xbf, sizeof(g)); f[1][1][1] = a[1]; f[1][2][0] = a[2]; for (int i = 2; i &lt;= n; ++i) g[1][i][1] = a[1]; for (int i = 3; i &lt;= n; ++i) g[1][i][0] = a[2]; for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int k = 0; k &lt;= n; ++k) &#123; int &amp;dp = f[i &amp; 1][j][k]; dp = -INF; if (f[(i - 1) &amp; 1][j][k] != -INF) dp = f[(i - 1) &amp; 1][j][k] + a[j]; if (j >= i &amp;&amp; k - 1 + j - i >= 0 &amp;&amp; k - 1 + j - i &lt;= n) &#123; if (g[(i - 1) &amp; 1][j][k - 1 + j - i] != -INF) dp = max(dp, g[(i - 1) &amp; 1][j][k - 1 + j - i] + a[j]); &#125; g[i &amp; 1][j + 1][k] = max(g[i &amp; 1][j][k], dp); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= n; ++j) ans = max(ans, f[n &amp; 1][i][j]); printf(\"%d\\n\", ans); return 0; &#125; Educational Codeforces Round 67 (Rated for Div. 2) Portal. æ‰“çš„è¶Šæ¥è¶Šåƒåœ¾ï¼Œæ²¡æ•‘äº†ã€‚ A. Stickers and Toys Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n, s, t; cin >> n >> s >> t; cout &lt;&lt; max(s, t) - (s + t - n) + 1 &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Letters Shop Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int sum[26][200005]; string s, t; void solve(void) &#123; cin >> n >> s; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; 26; ++j) sum[j][i] = (i == 0 ? 0 : sum[j][i - 1]); sum[s[i] - 'a'][i]++; &#125; cin >> m; static int c[26]; while (m--) &#123; memset(c, 0, sizeof(c)); int ans = 0; cin >> t; for (int i = 0; i &lt; t.length(); ++i) c[t[i] - 'a']++; for (int op = 0; op &lt; 26; ++op) &#123; int res = lower_bound(sum[op], sum[op] + n, c[op]) - sum[op]; ans = max(ans, res); &#125; cout &lt;&lt; ans + 1 &lt;&lt; \"\\n\"; &#125; &#125; int main(void) &#123; ios::sync_with_stdio(false); solve(); return 0; &#125; C. Vasya And Array Portal.ç»™å®š m(1â‰¤mâ‰¤1000)m(1\\le m\\le 1000)m(1â‰¤mâ‰¤1000) æ¡é™åˆ¶ä¿¡æ¯ï¼Œå½¢å¦‚ op l rï¼Œä»£è¡¨ [l,r][l,r][l,r] æ˜¯å¦ä¸é™æ’åºã€‚é—®æ˜¯å¦èƒ½æ„é€ å‡ºåˆæ³•çš„é•¿åº¦ä¸º nnn çš„åºåˆ—ï¼Œå¹¶ç»™å‡ºæ–¹æ¡ˆã€‚ æˆ‘ä»¬å…ˆçœ‹ä¸€çœ‹æ’å¥½åºæ„å‘³ç€ä»€ä¹ˆã€‚æˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ªæ•°ç»„ cccï¼Œc[i]c[i]c[i] ä¸ºçœŸä»£è¡¨éœ€è¦æ»¡è¶³ aiâ‰¥aiâˆ’1a_i\\ge a_{i-1}aiâ€‹â‰¥aiâˆ’1â€‹ï¼ˆå®é™…ä¸Šç›¸ç­‰å°±å¯ä»¥äº†ï¼‰ã€‚ç„¶åæˆ‘ä»¬çœ‹æ²¡æœ‰æ’å¥½åºçš„ï¼Œå¦‚æœèƒ½å¤Ÿè®©å®ƒæ²¡æ’å¥½çš„åŒºé—´ (l,r](l,r](l,r] éƒ½éœ€è¦æ’å¥½åºï¼Œé‚£ä¹ˆå°±å®Œè›‹äº†ã€‚è¾“å‡ºçš„æ—¶å€™ä¸éœ€è¦æ’åºçš„ç›´æ¥ä»¤è¾“å‡ºçš„æ•°å‡ä¸€å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, c[1005], s[1005]; int l[1005], r[1005], tot = 0; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= m; ++i) &#123; int t, x, y; cin >> t >> x >> y; if (t) ++c[x + 1], --c[y + 1]; else l[++tot] = x, r[tot] = y; &#125; for (int i = 1; i &lt;= n; ++i) c[i] += c[i - 1]; for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + (c[i] != 0); for (int i = 1; i &lt;= tot; ++i) if (s[r[i]] - s[l[i]] == r[i] - l[i]) return cout &lt;&lt; \"NO\\n\", 0; cout &lt;&lt; \"YES\\n\"; for (int i = 1, p = n + 2; i &lt;= n; ++i) &#123; if (!c[i]) --p; cout &lt;&lt; p &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n\"; return 0; &#125; D. Subarray Sorting Portal.ç»™å®šé•¿åº¦ä¸º nnn çš„æ•°ç»„ aaa å’Œ bbbã€‚ä½ æ¯æ¬¡å¯ä»¥é€‰æ‹©ä¸€æ®µåŒºé—´ [l,r][l,r][l,r]ï¼Œä»¤ alâˆ¼ara_l\\sim a_ralâ€‹âˆ¼arâ€‹ çš„å…ƒç´ ä»å°åˆ°å¤§æ’åºã€‚ä½ å¯ä»¥è¿›è¡Œä»»æ„æ¬¡æ“ä½œã€‚é—®èƒ½å¦ä½¿ aaa ä¸ bbb å®Œå…¨ç›¸ç­‰ã€‚ å¼ºå¤§çš„é¢˜ï¼ é¦–å…ˆå®ƒä»¬çš„æ•°çš„é›†åˆå¿…é¡»ç›¸ç­‰ï¼Œå¦åˆ™è‚¯å®šæ— è§£ã€‚ æˆ‘ä»¬ä¾æ¬¡æ‰«æ bbbï¼Œå°è¯•æ‰¾åˆ°ä¸€ä¸ª aaa ä¸å®ƒç›¸ç­‰ã€‚æœ‰æœ€å¤§å¯èƒ½å‡ºè§£çš„æ–¹å¼æ˜¯æ‰¾ç¬¬ä¸€ä¸ªå¯ä»¥åŒ¹é…çš„ aaa ä¸å®ƒåŒ¹é…ï¼ˆå¦åˆ™è¦æ’åºçš„å†…å®¹æ›´å¤šï¼Œå¯èƒ½é€ æˆå®ƒä¸æ˜¯æœ€å°å€¼ï¼‰ã€‚åŒ¹é…æˆåŠŸçš„æ¡ä»¶æ˜¯ä»¤å®ƒçš„ä½ç½®ä¸º pppï¼Œå®ƒå¿…é¡»æ˜¯ [1,p][1,p][1,p] çš„æœ€å°å€¼ï¼ˆå°† [i,p][i,p][i,p] æ’åºæ˜¯æ“ä½œï¼‰ï¼Œè¿™æ ·æ’åºä¹‹ååºåˆ—å‰©ä¸‹å…ƒç´ çš„ç›¸å¯¹ä½ç½®ä¸ä¼šæ”¹å˜ï¼Œä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;queue> using namespace std; const int INF = 1e9; int n; int a[300005], b[300005]; int cnt[300005], pos[300005]; queue&lt;int> Q[300005]; int T[1200005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = min(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o] = INF, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = min(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = INF; if (x &lt;= mid) res = min(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = min(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); fill(cnt + 1, cnt + n + 1, 0); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), ++cnt[a[i]]; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i), --cnt[b[ i]]; bool flag = true; for (int i = 1; i &lt;= n; ++i) if (cnt[i]) &#123; puts(\"NO\"); flag = false; break; &#125; if (!flag) continue; for (int i = 1; i &lt;= n; ++i) Q[a[i]].push(i); for (int i = 1; i &lt;= n; ++i) pos[i] = Q[b[i]].front(), Q[b[i]].pop(); build(1, 1, n); for (int i = 1; i &lt;= n; ++i) &#123; if (query(1, 1, n, 1, pos[i]) != b[i]) &#123; flag = false; break; &#125; update(1, 1, n, pos[i]); &#125; puts(flag ? \"YES\" : \"NO\"); &#125; return 0; &#125; E. Tree Painting Portal. æ¿å­ï¼å‘ç°å½“ç¬¬ä¸€ä¸ªç‚¹é€‰å®šä¹‹åï¼Œå‰©ä¸‹çš„å°±æ— æ‰€è°“äº†ï¼é‚£ä¹ˆä½¿ç”¨æ¢æ ¹ DPï¼å¤šçš„ä»·å€¼æ˜¯çˆ¶äº²æ‰€å¯¹åº”çš„å­æ ‘ï¼Œå°‘çš„ä»·å€¼æ˜¯å½“å‰å­æ ‘ï¼ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; int n, siz[200005]; i64 f[200005], g[200005]; vector&lt;int> G[200005]; void dp(int x, int fa) &#123; siz[x] = 1; for (int y : G[x]) if (y != fa) &#123; dp(y, x); siz[x] += siz[y]; f[x] += f[y]; &#125; f[x] += siz[x]; &#125; void dfs(int x, int fa) &#123; if (x != 1) g[x] = g[fa] + n - siz[x] * 2; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dp(1, 0); g[1] = f[1]; dfs(1, 0); i64 ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, g[i]); printf(\"%lld\\n\", ans); return 0; &#125; Educational Codeforces Round 126 (Rated for Div. 2) Portal. å‘œå‘œå‘œã€‚ A. Array Balancing Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[30], b[30]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1; i &lt;= n; ++i) cin >> b[i]; i64 ans = 0; for (int i = 2; i &lt;= n; ++i) &#123; i64 x = abs(a[i] - a[i - 1]) + abs(b[i] - b[i - 1]); i64 y = abs(a[i] - b[i - 1]) + abs(b[i] - a[i - 1]); ans += min(x, y); &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Getting Zero Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int INF = 1e9; int calc(int x) &#123; if (x % 32768 == 0) return 0; if (x % 2) return INF; int res = 15, ans = 0; while (x % 2 == 0) &#123; x /= 2; --res; &#125; return ans + res; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) &#123; int a; cin >> a; int ans = 1e9; for (int i = 0; i &lt; 24; ++i) ans = min(ans, calc(a + i) + i); cout &lt;&lt; ans &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n\"; return 0; &#125; C. Water the Trees Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int h[300005]; i64 calc(int x) &#123; i64 a = 0, b = 0; // 1day, 2day for (int i = 1; i &lt;= n; ++i) a += (x - h[i]) % 2, b += (x - h[i]) / 2; if (a == b) return a * 2; if (a > b) return a * 2 - 1; // a &lt; b i64 t = (b - a) * 2; i64 ans = a * 2 + t / 3 * 2; return ans + t % 3; &#125; void solve(void) &#123; cin >> n; int maxn = 0; for (int i = 1; i &lt;= n; ++i) cin >> h[i], maxn = max(maxn, h[i]); cout &lt;&lt; min(calc(maxn), calc(maxn + 1)) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; D. Progressions Covering Portal.ä½ æœ‰ä¸¤ä¸ªé•¿åº¦ä¸º nnn çš„æ•°ç»„ aaaï¼Œbbbã€‚aaa æ•°ç»„åˆå§‹ä¸º 000ã€‚ä½ æ¯æ¬¡å¯ä»¥æ‰§è¡Œä¸€ä¸ªæ“ä½œï¼Œé€‰å®šä¸€æ®µé•¿åº¦ä¸º kkk çš„åŒºé—´ï¼ˆè®¾åŒºé—´å·¦ç«¯ç‚¹ä¸º lllï¼Œåˆ™æœ‰ 1â‰¤lâ‰¤l+kâˆ’1â‰¤n1\\leq l\\leq l+kâˆ’1 \\leq n1â‰¤lâ‰¤l+kâˆ’1â‰¤n ï¼‰ï¼ŒæŠŠç¬¬ä¸€ä¸ªå…ƒç´ åŠ  111ï¼Œç¬¬äºŒä¸ªå…ƒç´ åŠ  222ï¼Œä»¥æ­¤ç±»æ¨ã€‚ç»™å®š nnnï¼Œkkk ä¸ bbbï¼Œæ±‚ä»¤ âˆ€iâˆˆ[1,n]\\forall i \\in [1, n]âˆ€iâˆˆ[1,n]ï¼Œæ»¡è¶³ aiâ‰¥bia_i \\ge b_iaiâ€‹â‰¥biâ€‹ çš„æœ€å°æ“ä½œæ•°ã€‚ å¥½é¢˜ï¼æˆ‘ä»¬ä»åå¾€å‰æ‰«ææ•°ç»„ï¼Œè¿™æ ·å°±å¯ä»¥å‘ç°è´ªå¿ƒåŠ å°±å¯ä»¥äº†ï¼Œå› ä¸ºåŠ çš„æ˜¯æœ€å¤§çš„è¿˜ä¸ä¼šæµªè´¹ã€‚é‚£ä¹ˆè®°å½•æ€»æ“ä½œæ•° opopop å’Œå½“å‰åŠ çš„å’Œ sssã€‚å¯¹äºå½“å‰çš„æ•°ï¼Œæ“ä½œæ•°æ˜¯ âŒˆb[i]âˆ’skâŒ‰\\left\\lceil \\cfrac{b[i]-s}{k}\\right\\rceilâŒˆkb[i]âˆ’sâ€‹âŒ‰ï¼ˆå®é™…è¿™ä¸ª kkk éœ€è¦æ ¹æ® iii è°ƒæ•´ï¼‰ï¼Œå¾€å‰æ‰«ä¸€ä¸ªï¼Œå½“å‰çš„å’Œå°±å‡å°‘äº†æ“ä½œæ•°ï¼Œæ“ä½œæ•°ä¼šå‡å°‘ i+kâˆ’1i+k-1i+kâˆ’1 æ—¶å¢åŠ çš„æ“ä½œæ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, k; i64 a[300005], b[300005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", b + i); i64 ans = 0, s = 0, op = 0; for (int i = n; i >= 1; --i) &#123; if (b[i] > s) &#123; int t = (i >= k ? k : i); a[i] = (b[i] - s + t - 1) / t; ans += a[i]; op += a[i]; s += a[i] * t; &#125; s -= op; if (i + k - 1 &lt;= n) op -= a[i + k - 1]; &#125; printf(\"%lld\\n\", ans); return 0; &#125; Codeforces Round #746 (Div. 2) Portal. å¥½æ£’ï¼ï¼ï¼ A. Gamer Hemose Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, H; int a[1005]; void solve(void) &#123; cin >> n >> H; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; sort(a + 1, a + n + 1); if (H &lt;= a[n]) return cout &lt;&lt; \"1\\n\", void(); int t = H / (a[n] + a[n - 1]) * 2; H = H % (a[n] + a[n - 1]); if (H == 0) cout &lt;&lt; t &lt;&lt; \"\\n\"; else if (a[n] >= H) cout &lt;&lt; t + 1 &lt;&lt; \"\\n\"; else cout &lt;&lt; t + 2 &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Hemose Shopping Portal. åªè¦èƒ½æ¢åˆ° 111 å’Œ nnn å°±å¯ä»¥éšä¾¿æ¢äº†ã€‚æ‰€ä»¥å½“ 2x&gt;n2x&gt;n2x&gt;n æ—¶ï¼Œ[nâˆ’x+1,x][n-x+1,x][nâˆ’x+1,x] ä¼šæ— æ³•è¿›è¡Œäº¤æ¢æ“ä½œï¼Œå› æ­¤å®ƒä»¬æ’å¥½åºå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, x; int a[100005], b[100005]; void solve(void) &#123; cin >> n >> x; for (int i = 1; i &lt;= n; ++i) cin >> a[i], b[i] = a[i]; sort(b + 1, b + n + 1); for (int i = n - x + 1; i &lt;= x; ++i) if (b[i] != a[i]) return puts(\"NO\"), void(); puts(\"YES\"); &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; C. Bakry and Partitioning Portal. æ˜¾ç„¶åªæœ‰æ–­ä¸€æ¡è¾¹æˆ–è€…ä¸¤æ¡è¾¹æœ‰ç”¨ã€‚ä¸€æ¡è¾¹æ˜¯æ•´æ£µæ ‘å¼‚æˆ–å’Œä¸º 000ï¼›ä¸¤æ¡è¾¹è¦æ‰¾å‡ºä¸‰éƒ¨åˆ†çš„å¼‚æˆ–å’Œç›¸ç­‰ï¼Œç›¸å½“äºæ‰¾ä¸¤æ£µå­æ ‘å¼‚æˆ–å’Œç›¸ç­‰ï¼ˆè®¡å…¥ç­”æ¡ˆçš„å­æ ‘è¦æ–­æ‰å†ç»§ç»­è®¡ç®—ï¼‰ï¼Œdfs æ£€æŸ¥ä¸€ä¸‹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k, xc, flag; int a[100005], s[100005]; vector&lt;int> G[100005]; void dfs(int x, int fa) &#123; s[x] = a[x]; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); if (s[y] == xc) ++flag; else s[x] ^= s[y]; &#125; &#125; void solve(void) &#123; cin >> n >> k; xc = flag = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; xc ^= a[i]; G[i].clear(); &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].push_back(v); G[v].push_back(u); &#125; if (xc == 0) return cout &lt;&lt; \"YES\\n\", void(); if (k == 2) return cout &lt;&lt; \"NO\\n\", void(); //cout &lt;&lt; xc &lt;&lt; endl; dfs(1, 0); cout &lt;&lt; (flag >= 2 ? \"YES\" : \"NO\") &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; D. Hemose in ICPC ? Portal.ç»™å®šä¸€æ£µæ ‘ï¼Œä½†æ˜¯ä¸çŸ¥é“è¾¹æƒã€‚å®šä¹‰è·ç¦» d(u,v)d(u,v)d(u,v) ä¸ºè·¯å¾„ä¸Šçš„è¾¹æƒçš„ gcdâ¡\\gcdgcdã€‚ä½ å¯ä»¥è¯¢é—®äº¤äº’åº“ä¸€ä¸ªç‚¹é›†ï¼Œäº¤äº’åº“ä¼šå›ç­”è¿™äº›ç‚¹ä¸¤ä¸¤ç‚¹å¯¹çš„è·ç¦»çš„æœ€å¤§å€¼ã€‚ä½ æœ€å¤šå¯ä»¥è¯¢é—®äº¤äº’åº“ 121212 æ¬¡ï¼Œè¦æ‰¾å‡º d(u,v)d(u,v)d(u,v) æœ€å¤§çš„ (u,v)(u,v)(u,v)ã€‚å¯ä»¥è¾“å‡ºä»»æ„ä¸€ç»„è§£ï¼Œ2â‰¤nâ‰¤1032\\le n\\le 10^32â‰¤nâ‰¤103ã€‚ åˆåšäº¤äº’é¢˜ï¼éå¸¸å¼€å¿ƒï¼ å¯ä»¥å‘ç°è·ç¦»å®šä¹‰ gcdâ¡\\gcdgcdï¼Œé‚£ä¹ˆè·ç¦»å°±ç›¸å½“äºæ‰¾å‡ºæœ€å¤§è¾¹æƒï¼ é¦–å…ˆè¯¢é—®ä¸€æ¬¡æ‰€æœ‰ç‚¹æ¥æ‰¾å‡ºæœ€å¤§çš„è¾¹æƒï¼å¯¹æ ‘è¿›è¡Œä¸€æ¬¡ dfsï¼Œæ±‚å‡ºéå†çš„é¡ºåºï¼è¿™æ ·æ¯ä¸¤ä¸ªæ ‘ä¸Šç›¸é‚»çš„ç‚¹éƒ½å¯ä»¥åœ¨åºåˆ—ä¸­æ‰¾åˆ°ï¼äºæ˜¯å°±å¯ä»¥å¯¹åºåˆ—äºŒåˆ†ï¼è¿™æ ·å°±å¯ä»¥æ‰¾åˆ°æœ€å¤§å€¼ï¼ ä¸ºä»€ä¹ˆæˆ‘å†™è¿™é¢˜è§£çš„æ—¶å€™è¿™ä¹ˆå–œæ¬¢æ„Ÿå¹å·ï¼ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, maxx, a[2005], tot = 0; vector&lt;int> G[1005]; void dfs(int x, int fa) &#123; a[++tot] = x; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); a[++tot] = x; &#125; &#125; int p[1005]; int check(int L, int R) &#123; memset(p, 0, sizeof(p)); int cnt = 0; for (int i = max(0, L); i &lt;= R; ++i) p[a[i]] = true; for (int i = 1; i &lt;= n; ++i) if (p[i]) ++cnt; printf(\"? %d \", cnt); for (int i = 1; i &lt;= n; ++i) if (p[i]) printf(\"%d \", i); cout &lt;&lt; endl; int t; scanf(\"%d\", &amp;t); return t; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v), G[v].emplace_back(u); &#125; printf(\"? %d \", n); for(int i = 1; i &lt;= n; ++i) printf(\"%d \", i); cout &lt;&lt; endl; scanf(\"%d\", &amp;maxx); dfs(1, 0); int L = 1, R = tot; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(L, mid) != maxx) L = mid; else R = mid; &#125; int x = a[L], y = a[R]; printf(\"! %d %d\\n\", a[L], a[R]); return 0; &#125; Codeforces Round #836 (Div. 2) Portal. è¿™åº”è¯¥æ˜¯è¿‘æœŸæ‰“çš„æœ€åä¸€åœºäº†ï¼Œæ¥ä¸‹æ¥ä¼šæŠŠå‰é¢çš„è¡¥æ‰ã€‚ A. SSeeeeiinngg DDoouubbllee Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; char s[200005]; void solve(void) &#123; cin >> s; n = strlen(s); cout &lt;&lt; s; reverse(s, s + n); cout &lt;&lt; s &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. XOR = Average Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n; cin >> n; if (n % 2) &#123; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; \"1 \"; cout &lt;&lt; \"\\n\"; return; &#125; for (int i = 1; i &lt;= n - 2; ++i) cout &lt;&lt; n + 1 &lt;&lt; ' '; cout &lt;&lt; \"1 \" &lt;&lt; n + 1 &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; Codeforces Round #838 (Div. 2) Portal. ä»Šå¹´æœ€åä¸€åœºï¼ A. Divide and Conquer Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int d = 1e9, s = 0, n, x; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> x; s += x; bool flag = (x &amp; 1); int ret = 0; while (1) &#123; x >>= 1; ++ret; if ((x &amp; 1) != flag) &#123; d = min(d, ret); break; &#125; &#125; &#125; if (s % 2 == 0) cout &lt;&lt; \"0\\n\"; else cout &lt;&lt; d &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Make Array Good Portal. æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n, x; cin >> n; cout &lt;&lt; n &lt;&lt; \"\\n\"; for (int i = 1; i &lt;= n; ++i) &#123; cin >> x; int t = ceil(log2(x)); cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; int(pow(2, t) - x) &lt;&lt; '\\n'; &#125; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"æ¯”èµ›è®°å½•","slug":"ç®—æ³•ç«èµ›/æ¯”èµ›è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Div.2","slug":"Div-2","permalink":"https://james1badcreeper.github.io/tags/Div-2/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"},{"name":"æ¯”èµ›","slug":"æ¯”èµ›","permalink":"https://james1badcreeper.github.io/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"å¹¶æŸ¥é›†","slug":"notes/DS/UnionFind","date":"2022-11-13T00:00:00.000Z","updated":"2022-11-13T00:00:00.000Z","comments":true,"path":"c517589e/","link":"","permalink":"https://james1badcreeper.github.io/c517589e/","excerpt":"å¹¶æŸ¥é›†ï¼ˆUnionFind-Set æˆ– Disjoint-Setï¼‰æ˜¯ä¸€ç§å¯ä»¥åŠ¨æ€ç»´æŠ¤è‹¥å¹²ä¸ªä¸é‡å çš„é›†åˆçš„æ•°æ®ç»“æ„ï¼Œæ”¯æŒåˆå¹¶å’ŒæŸ¥è¯¢ä¸¤ä¸ªæ“ä½œã€‚æœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ å¹¶æŸ¥é›†ï¼Œå¹¶æŸ¥é›†çš„è·¯å¾„å‹ç¼©å’ŒæŒ‰ç§©åˆå¹¶ä¼˜åŒ–ï¼Œä»¥åŠä¸€ç§ç‰¹æ®Šçš„å¹¶æŸ¥é›†â€”â€”å¸¦æƒå¹¶æŸ¥é›†ï¼Œå’Œç”¨å¹¶æŸ¥é›†è§£å†³å›¾è¿é€šæ€§é—®é¢˜ã€‚","text":"å¹¶æŸ¥é›†ï¼ˆUnionFind-Set æˆ– Disjoint-Setï¼‰æ˜¯ä¸€ç§å¯ä»¥åŠ¨æ€ç»´æŠ¤è‹¥å¹²ä¸ªä¸é‡å çš„é›†åˆçš„æ•°æ®ç»“æ„ï¼Œæ”¯æŒåˆå¹¶å’ŒæŸ¥è¯¢ä¸¤ä¸ªæ“ä½œã€‚æœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ å¹¶æŸ¥é›†ï¼Œå¹¶æŸ¥é›†çš„è·¯å¾„å‹ç¼©å’ŒæŒ‰ç§©åˆå¹¶ä¼˜åŒ–ï¼Œä»¥åŠä¸€ç§ç‰¹æ®Šçš„å¹¶æŸ¥é›†â€”â€”å¸¦æƒå¹¶æŸ¥é›†ï¼Œå’Œç”¨å¹¶æŸ¥é›†è§£å†³å›¾è¿é€šæ€§é—®é¢˜ã€‚ å¹¶æŸ¥é›† å¹¶æŸ¥é›†ç»´æŠ¤çš„æ˜¯ nnn ä¸ªç‚¹çš„é›†åˆã€‚æ­£å¸¸çš„å¹¶æŸ¥é›†æœ‰ä¸¤ç§æ“ä½œï¼š åˆå¹¶ï¼ˆMergeï¼‰ï¼Œå°†ä¸¤ä¸ªç‚¹æ‰€åœ¨çš„é›†åˆåˆå¹¶ã€‚ æŸ¥è¯¢ï¼ˆFindï¼‰ï¼ŒæŸ¥è¯¢ä¸€ä¸ªç‚¹å±äºå“ªä¸ªé›†åˆã€‚ æ¨¡æ¿ã€‚ æˆ‘ä»¬é¦–å…ˆéœ€è¦å®šä¹‰é›†åˆçš„è¡¨ç¤ºæ–¹æ³•ã€‚æˆ‘ä»¬ä¸ºæ¯ä¸€ä¸ªç‚¹åˆ†é…ä¸€ä¸ªæ•°å€¼ï¼Œä»£è¡¨å®ƒæ‰€å±çš„é›†åˆçš„ç¼–å·ã€‚ä½†è¿™æ ·åšä¸è¡Œï¼Œåœ¨åˆå¹¶æ—¶ä¼šä¿®æ”¹å¤§é‡ç‚¹çš„ç¼–å·ã€‚æ­£ç¡®çš„æ–¹æ³•æ˜¯è¿™æ ·çš„ï¼šä½¿ç”¨æ£®æ—ç»“æ„ï¼Œæ¯æ£µæ ‘ä»£è¡¨ä¸€ä¸ªé›†åˆï¼Œæ ‘æ ¹æ˜¯é›†åˆä»£è¡¨çš„å…ƒç´ ã€‚äºæ˜¯æˆ‘ä»¬ç”¨ fa[x] è®°å½• xxx çš„çˆ¶äº²èŠ‚ç‚¹ã€‚ å¦‚æœçˆ¶äº²èŠ‚ç‚¹æ˜¯è‡ªå·±åˆ™ä»£è¡¨å®ƒæ˜¯è¿™ä¸ªé›†åˆçš„æ ¹èŠ‚ç‚¹ï¼Œåˆå§‹åŒ–æ—¶èµ‹å€¼ fa[x] = xï¼Œç°åœ¨æˆ‘ä»¬æ¥çœ‹æ“ä½œå¦‚ä½•å®ç°ï¼Œæ¯”å¦‚è¿™æ ·ä¸€ä¸ªå¹¶æŸ¥é›†ï¼š ä¸€ä¸ªå¹¶æŸ¥é›† ç°åœ¨æˆ‘ä»¬è¦æŸ¥è¯¢ 777 æ‰€åœ¨çš„é›†åˆã€‚å®ƒçš„çˆ¶äº²æ˜¯ 666ï¼Œä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œå†æ‰¾åˆ° 222ï¼Œæ˜¯æ ¹èŠ‚ç‚¹ï¼Œè¿”å› 222ï¼Œä»£ç å¦‚ä¸‹ï¼š // æŸ¥è¯¢ x æ‰€åœ¨çš„é›†åˆ int find(int x) &#123; if (fa[x] == x) return x; // æ˜¯æ ¹èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å› return find(fa[x]); // ä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼ŒæŸ¥è¯¢çˆ¶äº² &#125; ç°åœ¨æ¥çœ‹åˆå¹¶å¦‚ä½•å®ç°ã€‚æ¯”å¦‚æˆ‘ä»¬è¦æŠŠ 999 æ‰€åœ¨çš„é›†åˆåˆå¹¶åˆ° 333 æ‰€åœ¨çš„é›†åˆï¼Œæˆ‘ä»¬ç›´æ¥æŠŠ 999 çš„æ ¹èŠ‚ç‚¹è®¾ç½®æˆ 333 çš„é›†åˆç¼–å·å³å¯ï¼Œåƒè¿™æ ·ï¼š åˆå¹¶ä¹‹å ä»£ç å¦‚ä¸‹ï¼š inline void uni(int x, int y) // å°† x åˆå¹¶åˆ° y &#123; fa[find(x)] = find(y); &#125; ä»¥ä¸‹ä»£ç å¯ä»¥é€šè¿‡åˆšæ‰çš„æ¨¡æ¿ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; class UnionFind_Set &#123; private: int fa[10005]; public: inline void init(int n) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i; &#125; int find(int x) &#123; if (fa[x] == x) return x; return find(fa[x]); &#125; inline void uni(int x, int y) &#123; fa[find(x)] = find(y); &#125; inline bool ask(int x, int y) &#123; if (find(x) == find(y)) return 1; else return 0; &#125; &#125;U; int main(void) &#123; int n = read(), m = read(), p = read(); U.init(n); while (m--) U.uni(read(), read()); while (p--) puts(U.ask(read(), read()) ? \"Yes\" : \"No\"); return 0; &#125; å¹¶æŸ¥é›†çš„ä¼˜åŒ– å®é™…ä¸Šä¸Šè¿°åšæ³•æ˜¯å¾ˆæ…¢çš„ï¼Œæ¯”å¦‚è¿˜æ˜¯è¿™å¼ å›¾ï¼š å¦‚æœæˆ‘è¦æŸ¥ 13ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šé€’å½’ä¸‰æ¬¡ã€‚ä¸‡ä¸€æœ‰ 10510^5105 ä¸ªæ•°ç»„æˆçš„é“¾ï¼Œæ€ä¹ˆåŠï¼Ÿ çœ‹ä¼¼å¾ˆæ£˜æ‰‹çš„é—®é¢˜ï¼Œå®é™…ä¸Šèƒ½é€šè¿‡å¾ˆç®€å•çš„æ–¹æ³•è§£å†³ã€‚æ¨¡æ¿ã€‚ è·¯å¾„å‹ç¼© è§£å†³è¿™ä¸ªé—®é¢˜çš„ç¬¬ä¸€ç§æ–¹å¼æ˜¯è·¯å¾„å‹ç¼©ï¼Œä¹Ÿæ˜¯ç«èµ›ä¸­æœ€å¸¸ç”¨çš„åšæ³•ï¼šå› ä¸ºå®ƒçš„ä»£ç é‡æå°ï¼Œåªæ¯”åˆšæ‰å¤šäº†å…­ä¸ªå¯è§å­—ç¬¦ï¼ æ€ä¹ˆåšå‘¢ï¼Ÿç”±äºåªè¦åœ¨åŒä¸€é›†åˆçš„å…ƒç´ åœ¨åŒä¸€æ£µæ ‘é‡Œï¼Œé‚£ä¹ˆæ ‘çš„å½¢æ€æ˜¯æ— æ‰€è°“çš„ï¼Œæ¯”å¦‚ä»¥ä¸‹ä¸¤æ£µæ ‘ï¼š æ–¹ä¾¿æŸ¥è¯¢æŸ¥è¯¢å›°éš¾ å®ƒä»¬çš„æ„ä¹‰æ˜¯ç›¸åŒçš„ï¼Œè€Œä¸”ç¬¬ä¸€ç§æŸ¥è¯¢æå¿«ã€‚é‚£æˆ‘ä»¬åªéœ€è¦åœ¨æŸ¥è¯¢æ—¶å°†æŸ¥è¯¢çš„ç‚¹ç›´æ¥æŒ‡å‘å®ƒçš„æ ‘æ ¹å°±å¥½ã€‚åªéœ€åšå¦‚ä¸‹ä»£ç æ›´æ”¹ï¼š int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; å¯ä»¥è¯æ˜ï¼Œé‡‡ç”¨è·¯å¾„å‹ç¼©çš„å¹¶æŸ¥é›†ï¼Œæ¯æ¬¡ find æ“ä½œçš„å‡æ‘Šå¤æ‚åº¦éƒ½æ˜¯ O(logâ¡n)\\mathcal{O}(\\log n)O(logn)ã€‚ æŒ‰ç§©åˆå¹¶ æŒ‰ç§©åˆå¹¶çš„æ ¹æœ¬æ€è·¯æ˜¯åœ¨åˆå¹¶æ—¶å°±å‡å°æ ‘çš„æ·±åº¦ï¼Œè¿™æ ·ä½¿å¾—æ ‘çš„æ·±åº¦æœ¬èº«å°±å‡å°ï¼Œä»è€Œé™ä½æŸ¥è¯¢çš„ä»£ä»·ã€‚ æŒ‰ç§©åˆå¹¶æœ‰ä¸¤ç§ä¸åŒçš„æ–¹æ³•ã€‚å…·ä½“å–å†³äºç§©çš„å®šä¹‰ã€‚ç§©å¯å®šä¹‰ä¸ºæ ‘çš„æ·±åº¦ï¼ˆæœªè·¯å¾„å‹ç¼©æ—¶ï¼‰ã€‚å®šä¹‰ int rank[MAXN]; /* åˆå§‹åŒ–ä¸º 1ï¼Œè¡¨ç¤ºå­æ ‘å¤§å° */ã€‚è¿™ç§æ–¹æ³•é€šå¸¸æ¯”å¯å‘å¼åˆå¹¶å¿«ï¼Œä»£ç å¦‚ä¸‹ï¼š inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); if (xx == yy) return; if (rank[xx] > rank[yy]) fa[yy] = xx; // æŒ‡å‘å¤§çš„ else fa[xx] = yy; if (rank[xx] == rank[yy]) ++rank[yy]; // ç›¸åŒï¼Œçˆ¶äº² +1 &#125; å¦ä¸€ç§ï¼Œå½“ç§©å®šä¹‰ä¸ºé›†åˆçš„å¤§å°æ—¶ï¼Œæˆ‘ä»¬æ¯æ¬¡éƒ½ä¼šæŠŠå°çš„é›†åˆåˆå¹¶åˆ°å¤§çš„é›†åˆå½“ä¸­ï¼Œåªä¼šå¢åŠ å°é›†åˆçš„æŸ¥è¯¢ä»£ä»·ã€‚è¿™æ ·çš„åˆå¹¶æ–¹å¼ç§°ä¹‹ä¸ºå¯å‘å¼åˆå¹¶ï¼Œåœ¨è®¸å¤šæ•°æ®ç»“æ„ä¸­éƒ½èƒ½è§åˆ°å®ƒçš„èº«å½±ã€‚ å¼€å§‹çš„æ—¶å€™è¦è¿™æ ·å®šä¹‰ï¼šint size[MAXN]; /* å°† size æ•°ç»„ï¼ˆè¡¨ç¤ºå­æ ‘å¤§å°ï¼‰å¡«å……ä¸º 1 */ã€‚ç„¶åè¿™æ ·åˆå¹¶ï¼š inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); if (xx == yy) return; if (size[xx] > size[yy]) swap(xx, yy); // å°çš„åˆå¹¶åˆ°å¤§çš„ fa[xx] = yy; size[yy] += size[xx]; &#125; å¯ä»¥è¯æ˜ï¼Œé‡‡ç”¨æŒ‰ç§©åˆå¹¶çš„å¹¶æŸ¥é›†ï¼Œå¹³å‡æ¯æ¬¡æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯ O(logâ¡n)\\mathcal{O}(\\log n)O(logn)ã€‚ å½“ä¸¤ç§ä¼˜åŒ–åŒæ—¶é‡‡ç”¨æ—¶ï¼Œæ—¶é—´å¤æ‚åº¦ä¼šé™è‡³åé˜¿å…‹æ›¼å‡½æ•°çº§åˆ«ã€‚å…·ä½“çš„èµ„æ–™å¯ä»¥è‡ªè¡Œæœç´¢ã€‚è¦çŸ¥é“é˜¿å…‹æ›¼å‡½æ•°çš„å¢é•¿é€Ÿåº¦è¦æ¯”æŒ‡æ•°å‡½æ•°è¿˜è¦å¯æ€•ï¼Œé‚£ä¹ˆåé˜¿å…‹æ›¼å‡½æ•°çš„å¢é•¿é€Ÿåº¦ä¹Ÿå°±æ…¢çš„å“äººï¼Œå¯ä»¥çœ‹ä½œè¿‘ä¼¼å¸¸æ•°ã€‚ æˆ‘ä»¬ä¸éœ€è¦ä½†å¿ƒè·¯å¾„å‹ç¼©ä¼šå¯¹ size æˆ– rank æ•°ç»„é€ æˆç ´åï¼Œè¿™å¹¶ä¸ä¼šå½±å“æˆ‘ä»¬å·¥ä½œã€‚ å¦‚æœåªé‡‡ç”¨æŒ‰ç§©åˆå¹¶ï¼Œé‚£ä¹ˆå¹¶æŸ¥é›†å°±å¯ä»¥å®ç°å¯æ€•çš„åŠŸèƒ½ï¼šæ”¯æŒæ’¤é”€æ“ä½œï¼Œåªéœ€è¦æŠŠä¹‹å‰è¿ä¸Šçš„è¾¹å†æŒ‡å‘è‡ªå·±å³å¯ã€‚ å¹¶æŸ¥é›†çš„å¤æ‚åº¦ å¯ä»¥é˜…è¯»ä¸‹é¢è¿™ç¯‡æ–‡ç« ã€‚æ¥è‡ª https://oi-wiki.org/ds/dsu-complexity/ï¼Œæ ¹æ® CC BY-SA 4.0 å’Œ SATA åè®®å¼•ç”¨ã€‚ æŸ¥çœ‹æ–‡ç«  è¿™é‡Œè¿˜æ˜¯è¯´å®é™…åº”ç”¨æ—¶æ€ä¹ˆåŠã€‚ä¸€èˆ¬æƒ…å†µä¸‹æˆ‘ä»¬é‡‡ç”¨è·¯å¾„å‹ç¼©å³å¯ï¼Œä½†å¦‚æœæ—¶é—´ç‰¹åˆ«åƒç´§ï¼Œåˆ™ä½¿ç”¨è·¯å¾„å‹ç¼©åŠ æŒ‰ç§©åˆå¹¶ã€‚ ä½†æŸäº›æ—¶å€™è·¯å¾„å‹ç¼©ä¸èµ·ä½œç”¨ï¼Œå› ä¸ºå•æ¬¡åˆå¹¶å¯èƒ½ä¼šé€ æˆå¤§é‡ä¿®æ”¹ã€‚è¿™æ—¶æˆ‘ä»¬åªä½¿ç”¨å¯å‘å¼åˆå¹¶ï¼Œè€Œä¸ä½¿ç”¨è·¯å¾„å‹ç¼©ã€‚æ¯”å¦‚å¯æŒä¹…åŒ–å¹¶æŸ¥é›†ï¼Œçº¿æ®µæ ‘åˆ†æ²»ç­‰ã€‚ è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨ Loj çš„å¹¶æŸ¥é›†æ¨¡æ¿é¢˜ç›® Loj 109ï¼Œæ¥æ£€éªŒå„ç§æ–¹æ³•çš„é€Ÿåº¦ã€‚å¼€å¯ O2 ä¼˜åŒ–ã€‚ æ–¹æ³• æ—¶é—´ ç©ºé—´ æš´åŠ› TLE 15.7 M è·¯å¾„å‹ç¼© 690 ms 15.7 M æŒ‰ç§©åˆå¹¶ 605 ms 31.0 M è·¯å¾„å‹ç¼© + æŒ‰ç§©åˆå¹¶ 579 ms 31.1 M å¯å‘å¼åˆå¹¶ 590 ms 31.0 M è·¯å¾„å‹ç¼© + å¯å‘å¼åˆå¹¶ 601 ms 30.9 M å¯ä»¥çœ‹åˆ°è·¯å¾„å‹ç¼©çš„å‰¯ä½œç”¨è¿˜æ˜¯è¾ƒå¤§çš„ï¼Œè¦æ¯”æŒ‰ç§©åˆå¹¶æ…¢ã€‚ä½†æ˜¯åŒæ—¶é‡‡ç”¨ä¸¤ç§ä¼˜åŒ–å¹¶ä¸ä¼šä½¿ä»£ç å¿«å¤šå°‘ï¼Œæ‰€ä»¥ä¸€èˆ¬ä½¿ç”¨è·¯å¾„å‹ç¼©å³å¯ï¼Œä½†ä¸æ„å‘³ç€å¯ä»¥ä¸å­¦æŒ‰ç§©åˆå¹¶â€”â€”ç‰¹æ®Šæƒ…å†µä¸‹å®ƒèƒ½è§£å†³æ¯”è·¯å¾„å‹ç¼©æ›´å¤šçš„é—®é¢˜ã€‚è¿™é‡Œç»™å‡ºæœ€åä¸€ç§æ–¹æ³•çš„ä»£ç å‚è€ƒï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const i64 MOD = 998244353; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; class UnionFind_Set &#123; private: int fa[4000005], size[4000005]; public: inline void init(int n) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i, size[i] = 1; &#125; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); if (xx == yy) return; if (size[xx] > size[yy]) swap(xx, yy); fa[xx] = yy; size[yy] += size[xx]; &#125; inline bool ask(int x, int y) &#123; if (find(x) == find(y)) return 1; else return 0; &#125; &#125;U; int main(void) &#123; int n = read(), m = read(); i64 ans = 0; U.init(n); while (m--) &#123; int op = read(), x = read(), y = read(); if (op == 0) U.uni(x, y); else &#123; ans &lt;&lt;= 1; ans += U.ask(x, y); ans %= MOD; &#125; &#125; printf(\"%lld\\n\", ans); return 0; &#125; å¹¶æŸ¥é›† Tricks å®é™…ä¸Šå¹¶æŸ¥é›†éå¸¸çš„å¼ºå¤§ã€‚ è¾¹å¸¦æƒ å®é™…ä¸Šå¹¶æŸ¥é›†æ˜¯ä¸€ä¸ªæ£®æ—ï¼Œå¯ä»¥æ‹¥æœ‰ç‚¹æƒå’Œè¾¹æƒã€‚åœ¨æŒ‰ç§©åˆå¹¶ä¸­ï¼Œå¹¶æŸ¥é›†å°±æœ‰äº†ç‚¹æƒã€‚è€Œåªè¦åœ¨åˆå¹¶çš„æ—¶å€™æ›´æ–°è¾¹æƒï¼Œé‚£ä¹ˆå¹¶æŸ¥é›†å°±å¯ä»¥ç»Ÿè®¡è¾¹ä¸Šçš„ä¿¡æ¯äº†ã€‚ æ‰©å±•åŸŸ å°†ä¸€ä¸ªç‚¹æ‹†æˆå‡ ä¸ªç‚¹ä»£è¡¨ä¸åŒçš„ä¿¡æ¯ï¼Œæ¥ä»£è¡¨å…·æœ‰ä¸åŒæ€§è´¨çš„ xxx çš„ä¿¡æ¯ã€‚ Problemset å¹¶æŸ¥é›†æœ‰å¾ˆå¤šæœ‰è¶£çš„é¢˜ç›®ã€‚ ç®€å•å¹¶æŸ¥é›† å°±æ˜¯å¹¶æŸ¥é›†ã€‚ [NOI2015] ç¨‹åºè‡ªåŠ¨åˆ†æ Portal. å¹¶æŸ¥é›†æ“…é•¿ç»´æŠ¤å…·æœ‰ä¼ é€’æ€§çš„æ¡ä»¶ã€‚ç›¸ç­‰å…³ç³»å°±æœ‰è¿™ç§æ€§è´¨ï¼Œå®ƒä»¬åœ¨åŒä¸€ä¸ªé›†åˆä¸­ã€‚è€Œä¸ç­‰å…³ç³»ä¸å¯ä»¥ç”¨å¹¶æŸ¥é›†ç»´æŠ¤ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å…ˆè€ƒè™‘ç›¸ç­‰å…³ç³»ï¼Œå†çœ‹ä¸ç­‰å…³ç³»æ˜¯å¦å’Œå®ƒä»¬çŸ›ç›¾ã€‚æ³¨æ„åˆ°æ•°æ®ç¼–å·å¾ˆå¤§ï¼Œéœ€è¦ç¦»æ•£åŒ–ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, tot, m; int a[1000005], b[1000005], type[1000005]; int d[2000005], fa[2000005]; int P(int x) &#123; return lower_bound(d + 1, d + m + 1, x) - d; &#125; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; int T = read(); while (T--) &#123; n = read(), tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(), b[i] = read(), type[i] = read(); d[++tot] = a[i], d[++tot] = b[i]; &#125; sort(d + 1, d + tot + 1); m = unique(d + 1, d + tot + 1) - (d + 1); for (int i = 1; i &lt;= m; ++i) fa[i] = i; for (int i = 1; i &lt;= n; ++i) if (type[i]) fa[find(P(a[i]))] = find(P(b[i])); bool flag = true; for (int i = 1; i &lt;= n; ++i) if (!type[i] &amp;&amp; find(P(a[i])) == find(P(b[i]))) &#123; flag = false; break; &#125; puts(flag ? \"YES\" : \"NO\"); &#125; return 0; &#125; [NOIP2010 æé«˜ç»„] å…³æŠ¼ç½ªçŠ¯ Portal. å°†å…³ç³»æŒ‰ç…§æ€¨æ°”å€¼ç”±å¤§åˆ°å°æ’åºï¼Œå¦‚æœä¸¤ä¸ªç½ªçŠ¯ä¸ä¸€ä¸ªé›†åˆï¼Œé‚£ä¹ˆå¦‚æœæ²¡æœ‰æ•Œäººåˆ™æ ‡è®°æ•Œäººï¼Œå¦åˆ™å°†æ–°çš„æ•Œäººä¸åŸæ¥æ•Œäººæ‰€åœ¨çš„é›†åˆåˆå¹¶ã€‚è¿™æ ·å¦‚æœæ‰¾åˆ°äº†ä¸¤ä¸ªäººåœ¨ä¸€ä¸ªé›†åˆå†…ï¼Œä¹Ÿå°±æ˜¯ä¹‹å‰ b,cb,cb,c éƒ½æ˜¯ aaa çš„æ•Œäººï¼Œé‚£ä¹ˆåªèƒ½è®© (a,b),(a,c)(a,b),(a,c)(a,b),(a,c) ä¸å‘ç”Ÿå†²çªï¼Œ(b,c)(b,c)(b,c) å‘ç”Ÿå†²çªã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; struct Node &#123; int a, b, c; bool operator &lt; (const Node &amp;a) const &#123; return c > a.c; &#125; &#125; a[100005]; int n, m, b[20005]; int fa[20005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;a[i].a, &amp;a[i].b, &amp;a[i].c); sort(a + 1, a + m + 1); for (int i = 1; i &lt;= m; ++i) &#123; int x = find(a[i].a), y = find(a[i].b); if (x == y) return printf(\"%d\\n\", a[i].c), 0; if (!b[a[i].a]) b[a[i].a] = a[i].b; else fa[find(b[a[i].a])] = y; if (!b[a[i].b]) b[a[i].b] = a[i].a; else fa[find(b[a[i].b])] = x; &#125; puts(\"0\"); return 0; &#125; æ¥ä¸‹æ¥æˆ‘ä»¬ä¼šé€šè¿‡å‡ é“é¢˜ç›®æ¥è®¤è¯†å¸¦æƒå¹¶æŸ¥é›†ã€‚å¸¦æƒå¹¶æŸ¥é›†æœ‰å¾ˆå¤šç§ï¼Œè¦å…·ä½“æƒ…å†µå…·ä½“åˆ†æã€‚ [NOIP2015 æé«˜ç»„] ä¿¡æ¯ä¼ é€’ é¢˜é¢ã€‚ æ±‚æœ‰å‘å›¾çš„æœ€å°ç¯ã€‚ å‡è¯´ä¿¡æ¯ç”± A ä¼ é€’ç»™ Bï¼Œé‚£ä¹ˆå°±è¿ä¸€æ¡ç”± A æŒ‡å‘ B çš„è¾¹ã€‚åœ¨è¿ä¹‹å‰åˆ¤æ–­æ˜¯å¦åœ¨ä¸€ä¸ªé›†åˆé‡Œï¼Œå¦‚æœåœ¨ï¼Œå°±è¯´æ˜å‡ºç°äº†ç¯ã€‚è€Œæˆ‘ä»¬è¿˜æƒ³è¦çŸ¥é“é•¿åº¦ï¼Œæ‰€ä»¥éœ€è¦è®°å½• d[x] è¡¨ç¤ºåˆ°çˆ¶äº²èŠ‚ç‚¹çš„è¾¹æƒã€‚ä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, ans = 0x7fffffff; int fa[200005], d[200005]; int find(int x) &#123; if (x == fa[x]) return x; // æ˜¯è‡ªå·±ç›´æ¥è¿”å› int root = find(fa[x]); // æ‰¾æ‰€åœ¨é›†åˆ d[x] += d[fa[x]]; // ä¸ºè·¯å¾„å‹ç¼©åšå‡†å¤‡ï¼Œè·ç¦»è®¾ä¸ºæ¥åˆ°çˆ¶äº²ä¸Š return fa[x] = root; // è·¯å¾„å‹ç¼© &#125; inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); // è¿™é‡Œçš„æŸ¥æ‰¾è¿˜æœ‰ä¸€ä¸ªä½œç”¨ï¼šæŠŠä¹‹å‰æ²¡æ›´æ–°çš„éƒ½æ›´æ–°ï¼Œæ‰€ä»¥ä¸ç”¨æ‹…å¿ƒåˆå¹¶ä¸¤æ£µæ ‘æ—¶å­—èŠ‚ç‚¹æ²¡æœ‰æ›´æ–°å¯¼è‡´ç»“æœé”™è¯¯ï¼Œå°±æ˜¯æ‰€è°“çš„â€œå»¶è¿Ÿï¼ˆæ‡’æƒ°ï¼‰æ›´æ–°â€ if (xx != yy) &#123; fa[xx] = yy; // x çš„çˆ¶äº²ä¸º y d[x] = d[y] + 1; // x çš„è·ç¦»ä¸º y åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦» +1ï¼ˆå› ä¸º y æ˜¯ x çš„çˆ¶äº²ï¼‰ &#125; else ans = min(ans, d[x] + d[y] + 1); // åœ¨åŒä¸€æ£µæ ‘é‡Œï¼Œç¯é•¿åº¦ä¸ºå„è‡ªåˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»å’Œ +1 &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= n; ++i) uni(i, read()); // è¿™æ˜¯å¹¿ä¹‰çš„åˆå¹¶ï¼Œç¯æ˜¯ä¸èƒ½åˆå¹¶çš„ printf(\"%d\\n\", ans); return 0; &#125; è¿™å°±æ˜¯æ‰€è°“çš„â€œè¾¹å¸¦æƒâ€å¹¶æŸ¥é›†ã€‚æ¯ä¸ªèŠ‚ç‚¹åˆ°æ ‘æ ¹éƒ½æœ‰ä¸€äº›ä¿¡æ¯ã€‚å¯ä»¥å‘ç°è¾¹å¸¦æƒå¹¶æŸ¥é›†ä¾èµ–äºè·¯å¾„å‹ç¼©ï¼Œæ²¡æœ‰è·¯å¾„å‹ç¼©å®ƒæ— æ³•æ­£å¸¸å·¥ä½œï¼ˆæƒ³ä¸€æƒ³ï¼Œä¸ºä»€ä¹ˆï¼‰ã€‚ æœ€å°ç¯æ˜¯å›¾è®ºä¸­çš„ä¸€ä¸ªç»å…¸é—®é¢˜ï¼Œå¹¶æŸ¥é›†å¹¶ä¸èƒ½è§£å†³å®ƒçš„æ‰€æœ‰å˜ç§ã€‚è¯·å­¦æœ‰ä½™åŠ›è¯»è€…è‡ªè¡Œå¯»æ‰¾ dfsã€Tarjanã€Floyd ç­‰èµ„æ–™ã€‚ [NOI2002] é“¶æ²³è‹±é›„ä¼ è¯´ é¢˜é¢ã€‚ ç”±äºè·ç¦»çš„å­˜åœ¨ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°ç”¨è¾¹å¸¦æƒå¹¶æŸ¥é›†æ¥è§£å†³ã€‚ç”±äºåˆå¹¶æ—¶çš„ç‰¹æ®Šæ€§ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è®°å½•é›†åˆçš„å¤§å°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int fa[30005]; int d[30005], Size[30005]; int find(int x) &#123; if (fa[x] == x) return x; int root = find(fa[x]); d[x] += d[fa[x]]; return fa[x] = root; &#125; inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); fa[xx] = yy, d[xx] = Size[yy]; Size[yy] += Size[xx]; &#125; int main(void) &#123; int T = read(); for (int i = 1; i &lt;= 30000; ++i) fa[i] = i, Size[i] = 1; while (T--) &#123; char s[3]; int i, j; scanf(\"%s%d%d\", s, &amp;i, &amp;j); if (s[0] == 'C') &#123; if (find(i) == find(j)) printf(\"%d\\n\", abs(d[i] - d[j]) - 1); else puts(\"-1\"); &#125; else uni(i, j); &#125; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"æ•°æ®ç»“æ„","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†","permalink":"https://james1badcreeper.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"ATCoder ä¹±åšè®°å½•","slug":"default/old/arc-1","date":"2022-11-08T00:00:00.000Z","updated":"2022-11-08T00:00:00.000Z","comments":true,"path":"dae55f85/","link":"","permalink":"https://james1badcreeper.github.io/dae55f85/","excerpt":"å¬è¯´åšç‚¹ AT é¢˜éå¸¸å¥½ç©ï¼Œäºæ˜¯å°±æ¥äº†ã€‚ä½†æ˜¯ç¬”è€…å¤ªèœäº†ï¼Œæ‰€ä»¥éƒ½ä¸ä¼šã€‚","text":"å¬è¯´åšç‚¹ AT é¢˜éå¸¸å¥½ç©ï¼Œäºæ˜¯å°±æ¥äº†ã€‚ä½†æ˜¯ç¬”è€…å¤ªèœäº†ï¼Œæ‰€ä»¥éƒ½ä¸ä¼šã€‚ PART-A james1 æ˜¯èœç‹—ã€‚ AtCoder Regular Contest 104 Portal. A. Plus Minus Portal. æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int a, b; cin >> a >> b; cout &lt;&lt; (a + b) / 2 &lt;&lt; ' ' &lt;&lt; (a - b) / 2 &lt;&lt; endl; return 0; &#125; B. DNA Sequence Portal. æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, ans = 0; char a[5005]; int cnt[4]; int main(void) &#123; scanf(\"%d%s\", &amp;n, a + 1); for (int i = 1; i &lt;= n; ++i) &#123; memset(cnt, 0, sizeof(cnt)); for (int j = i; j &lt;= n; ++j) &#123; if (a[j] == 'A') ++cnt[0]; else if (a[j] == 'T') ++cnt[1]; else if (a[j] == 'G') ++cnt[2]; else ++cnt[3]; if (cnt[0] == cnt[1] &amp;&amp; cnt[2] == cnt[3]) ++ans; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; C. Fair Elevator Portal. å…ˆè€ƒè™‘å‡ ä¸ªåŸºæœ¬æ¡ä»¶ï¼šå¿…é¡»æœ‰ b&gt;ab&gt;ab&gt;aï¼Œæ¯ä¸€ä¸ªä½ç½®æœ€å¤šæœ‰ä¸€ä¸ªäººä¸Šä¸‹ï¼Œå¦åˆ™æ˜¾ç„¶ä¸åˆæ³•ã€‚ å‘ç° nâ‰¤100n\\le 100nâ‰¤100ï¼Œå› æ­¤å¯ä»¥æƒ³çš„æš´åŠ›ä¸€ç‚¹ã€‚æƒ³è¦ç»™ âˆ’1-1âˆ’1 çš„ä½ç½®å¡«æ•°å­—ä¸å¤ªå¥½æï¼Œé‚£ä¹ˆå°±ä¾æ¬¡è€ƒè™‘æ¥¼å±‚ï¼Œç»™æ¥¼å±‚å®‰æ’ä¸Šè¿™ä¸€å±‚ä¸Šæˆ–è€…æ˜¯ä¸‹çš„äººã€‚ è®¾ f(i)f(i)f(i) ä»£è¡¨è€ƒè™‘å‰ iii å±‚æ¥¼æ˜¯å¦å¯ä»¥åšåˆ°åˆæ³•ï¼Œåˆå§‹æ—¶ f(0)=1f(0)=1f(0)=1ï¼Œç›®æ ‡ä¸º f(2n)f(2n)f(2n)ã€‚è½¬ç§»æ˜¾ç„¶æ˜¯ï¼š f(i)=âˆ¨{f(jâˆ’1)âˆ§calc(j,i)}(1â‰¤j&lt;i,2âˆ£iâˆ’j+1)f(i)=\\vee\\{f(j-1)\\wedge \\text{calc}(j,i)\\}(1\\le j&lt;i,2\\mid i-j+1) f(i)=âˆ¨{f(jâˆ’1)âˆ§calc(j,i)}(1â‰¤j&lt;i,2âˆ£iâˆ’j+1) æ³¨æ„åŒºé—´é•¿åº¦ä¸€å®šè¦æ˜¯ 222 çš„å€æ•°ï¼Œå¦åˆ™æ˜¯ä¸å¯èƒ½åˆæ³•çš„ï¼ˆæ ¹æœ¬å¡«ä¸è¿›å»ï¼‰ã€‚ ç°åœ¨é—®é¢˜å°±æ˜¯å¦‚ä½•å®ç°åˆ¤æ–­åŒºé—´åˆæ³•çš„ calc å‡½æ•°ã€‚æ˜¾ç„¶è¿™æ®µåŒºé—´å¿…é¡»æ˜¯&quot;å°é—­&quot;çš„å½“ä¸­çš„ä»»ä½•ä½ç½®éƒ½ä¸å¯ä»¥è·‘åˆ°åŒºé—´å¤–é¢å»ã€‚å†å°±æ˜¯å¿…é¡»åœ¨å‰åŠæ®µä¸Šç”µæ¢¯ï¼ŒååŠæ®µä¸‹ç”µæ¢¯ï¼Œå¦åˆ™å¿…å®šå¯ä»¥åˆ’åˆ†æˆæ›´å°çš„åŒºé—´ã€‚æ­¤æ—¶ä¸Šä¸‹ç”µæ¢¯çš„ä½ç½®å¿…é¡»æ˜¯å‰åŠæ®µä¸­çš„ç¬¬ iii ä¸ªå’ŒååŠæ®µä¸­çš„ç¬¬ iii ä¸ªï¼Œè¿™æ ·æ‰èƒ½ä¿è¯åç”µæ¢¯çš„å±‚æ•°æ˜¯ç›¸ç­‰çš„ã€‚ æ—¶é—´å¤æ‚åº¦ O(n3)O(n^3)O(n3)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[105], b[105]; int cnt[205], p[205]; bool f[205]; bool calc(int L, int R) &#123; for (int i = L; i &lt;= R; ++i) &#123; // åœ¨æ­¤å¤„ä¸‹ï¼Œä¸Šæ¥çš„åœ°æ–¹å°äº L if (p[i] &lt; 0 &amp;&amp; a[-p[i]] != -1 &amp;&amp; a[-p[i]] &lt; L) return false; // åœ¨æ­¤å¤„ä¸Šï¼Œä¸‹å»çš„åœ°æ–¹å¤§äº R if (p[i] > 0 &amp;&amp; b[p[i]] != -1 &amp;&amp; b[p[i]] > R) return false; &#125; int half = (R - L + 1) >> 1; for (int i = L; i &lt;= L + half - 1; ++i) &#123; if (p[i] &lt; 0) return false; // å‰åŠæ®µä¸‹ï¼Œä¸è¡Œ if (p[i + half] > 0) return false; // ååŠæ®µä¸Šï¼Œä¸è¡Œ if (p[i] &amp;&amp; p[i + half] &amp;&amp; p[i] + p[i + half]) return false; // è·ç¦»ä¸ç›¸ç­‰ï¼Œä¸è¡Œ &#125; return true; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", a + i, b + i); if (a[i] != -1 &amp;&amp; b[i] != -1 &amp;&amp; a[i] >= b[i]) return puts(\"No\"), 0; if (a[i] != -1) ++cnt[a[i]], p[a[i]] = i; if (b[i] != -1) ++cnt[b[i]], p[b[i]] = -i; &#125; n &lt;&lt;= 1; for (int i = 1; i &lt;= n; ++i) if (cnt[i] > 1) return puts(\"No\"), 0; f[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = ((i &amp; 1) ? 2 : 1); j &lt;= i; j += 2) if (f[j - 1]) f[i] |= calc(j, i); puts(f[n] ? \"Yes\" : \"No\"); return 0; &#125; ATCoder Regular Contest 105 Portal. A. Fourtune Cookies Portal. æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int main(void) &#123; int a[4]; cin >> a[0] >> a[1] >> a[2] >> a[3]; sort(a, a + 4); if (a[3] == a[0] + a[1] + a[2] || a[1] + a[2] == a[0] + a[3] || a[0] + a[1] == a[2] + a[3]) puts(\"Yes\"); else puts(\"No\"); return 0; &#125; B. MAX-=min Portal. è¿™ä¸ªè¿‡ç¨‹å°±æ˜¯æ›´ç›¸å‡æŸæ³•ï¼Œæ‰€ä»¥æ±‚ gcdâ¡\\gcdgcd å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int main(void) &#123; int n, x, g = 0; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); g = gcd(g, x); &#125; printf(\"%d\\n\", g); return 0; &#125; C. Camels and Bridge Portal.æœ‰ n(2â‰¤nâ‰¤8)n(2\\le n\\le 8)n(2â‰¤nâ‰¤8) åªéª†é©¼ï¼Œç¬¬ iii åªéª†é©¼çš„é‡é‡æ˜¯ wiw_iwiâ€‹ï¼Œä½ å¯ä»¥ä»»æ„æ’åˆ—éª†é©¼çš„é¡ºåºï¼Œå¹¶ä»¤éª†é©¼ä¹‹é—´çš„è·ç¦»ä¸ºéè´Ÿå®æ•°ï¼ˆå¯ä»¥ä¸ç­‰è·ï¼‰ï¼Œéª†é©¼åœ¨è¿‡ä¸€åº§æœ‰ M(1â‰¤Mâ‰¤105)M(1\\le M \\le 10^5)M(1â‰¤Mâ‰¤105) ä¸ªéƒ¨åˆ†çš„æ¡¥æ—¶ä¼šä¿æŒé˜Ÿå½¢ï¼Œç¬¬ iii éƒ¨åˆ†æ¡¥æœ‰ä¸€ä¸ªé•¿åº¦ lil_iliâ€‹ å’Œä¸€ä¸ªæ‰¿é‡èƒ½åŠ› viv_iviâ€‹ï¼Œä¸Šé¢çš„éª†é©¼è´¨é‡ä¸å¯ä»¥è¶…è¿‡æ¡¥çš„åŸä¸­èƒ½åŠ›ã€‚æ‰¾å‡ºéª†é©¼è¿‡æ¡¥çš„æœ€çŸ­é˜Ÿå½¢é•¿åº¦ï¼Œå¯ä»¥è¯æ˜è¿™ä¸€å®šæ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œè‹¥éª†é©¼ä¸å¯èƒ½è¿‡å»åˆ™è¾“å‡º âˆ’1-1âˆ’1ã€‚ nnn çš„èŒƒå›´å¾ˆå°ï¼Œå› æ­¤å¯ä»¥æƒ³çš„æš´åŠ›ä¸€ç‚¹ã€‚è€ƒè™‘æšä¸¾å…¨æ’åˆ—ï¼Œç„¶åä½¿ç”¨ DP æ¥è®¡ç®—æœ€å°é•¿åº¦ï¼šf(i)f(i)f(i) ä¸ºåˆ°ç¬¬ iii ä¸ªéª†é©¼ä¸ºæ­¢çš„æœ€å°è·ç¦»ï¼Œè½¬ç§»çš„æ—¶å€™è¦æšä¸¾å³ç«¯ç‚¹ï¼Œç„¶åä¾æ¬¡å‘å·¦ç«¯æ‰©å±•å¯»æ‰¾æœ€å¤§å€¼ã€‚å¯ä»¥ä½¿ç”¨çŠ¶æ€å‹ç¼©é¢„å¤„ç†å‡ºä¸€ä¸ªéª†é©¼é›†åˆéœ€è¦çš„æœ€é•¿é‚£ä¸€æ®µçš„è·ç¦»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int n, m, ans = 1e9; int w[10], a[10], f[10], W[500]; int l[100005], v[100005]; bool vis[10]; void dfs(int x) &#123; if (x == n) &#123; memset(f, 0, sizeof(f)); for (int i = 1; i &lt; n; ++i) &#123; int now = (1 &lt;&lt; a[i]); for (int j = i - 1; j >= 0; --j) &#123; now |= (1 &lt;&lt; a[j]); f[i] = max(f[i], f[j] + W[now]); &#125; &#125; ans = min(ans, f[n - 1]); return; &#125; for (int i = 0; i &lt; n; ++i) if (!vis[i]) &#123; vis[a[x] = i] = true; dfs(x + 1); vis[i] = false; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", w + i); sort(w, w + n); for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d%d\", l + i, v + i); if (v[i] &lt; w[n - 1]) return puts(\"-1\"), 0; &#125; for (int i = 1; i &lt; (1 &lt;&lt; n); ++i) &#123; int s = 0; for (int j = 0; j &lt; n; ++j) if ((i >> j) &amp; 1) s += w[j]; for (int j = 0; j &lt; m; ++j) if (s > v[j]) W[i] = max(W[i], l[j]); &#125; dfs(0); printf(\"%d\\n\", ans); return 0; &#125; D. Letâ€™s Play Nim Portal.æœ‰ n(1â‰¤nâ‰¤105)n(1 \\leq n\\leq 10 ^ 5)n(1â‰¤nâ‰¤105) ä¸ªèƒŒåŒ…ï¼Œnnn ä¸ªç›˜å­ï¼ŒèƒŒåŒ… iii é‡Œæœ‰ ai(1â‰¤aiâ‰¤109)a _ i(1 \\leq a _ i \\leq 10 ^ 9)aiâ€‹(1â‰¤aiâ€‹â‰¤109) ä¸ªç¡¬å¸ï¼Œåˆå§‹æ—¶ç›˜å­é‡Œæ²¡æœ‰ç¡¬å¸ã€‚ä¸¤ä¸ªäººè½®æµæ“ä½œï¼Œå¦‚æœè¿˜æœ‰èƒŒåŒ…æœ‰ç¡¬å¸ï¼Œé‚£ä¹ˆå¯ä»¥é€‰æ‹©ä¸€ä¸ªèƒŒåŒ…ï¼ŒæŠŠå…¨éƒ¨ç¡¬å¸å¯¼å…¥æŸä¸ªç›˜å­ä¸­ï¼Œå¦‚æœæ²¡æœ‰èƒŒåŒ…æœ‰ç¡¬å¸ï¼Œé‚£ä¹ˆå¯ä»¥é€‰æ‹©ä¸€ä¸ªç›˜å­ï¼Œè‡³å°‘å–èµ°ä¸€ä¸ªç¡¬å¸ï¼Œæœ€åä¸èƒ½æ“ä½œçš„äººè¾“ã€‚ nnn ä¸ºå¥‡æ•°æ—¶åæ‰‹å¿…èƒœï¼Œnnn ä¸ºå¶æ•°æ—¶å¦‚æœæ‰€æœ‰æ•°çš„å‡ºç°æ¬¡æ•°éƒ½ä¸ºå¶æ•°é‚£ä¹ˆè¿˜æ˜¯åæ‰‹å¿…èƒœï¼Œå¦åˆ™å…ˆæ‰‹å¿…èƒœã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;map> using namespace std; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n; map&lt;int, int> s; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); s[x] += 1; &#125; if (n &amp; 1) puts(\"Second\"); else &#123; bool flag = false; for (auto x : s) if (x.second &amp; 1) &#123; flag = true; break; &#125; puts(flag ? \"First\" : \"Second\"); &#125; &#125; return 0; &#125; E. Keep Graph Disconnected Portal.ç»™å®šä¸€å¼ æ— å‘å›¾ï¼Œç”±ä¸¤ä¸ªç©å®¶è½®æµè¿è¾¹ï¼Œä¸å¯ä»¥è¿é‡è¾¹å’Œè‡ªç¯ï¼Œä¸èƒ½ä½¿ 111 å’Œ nnn ç›¸è¿ï¼Œè°ä¸èƒ½æ“ä½œè°è¾“ã€‚é—®è°å¿…èƒœã€‚ æœ€ç»ˆå±€é¢ï¼Œç‚¹å½’ä½œä¸¤ä¸ªé›†åˆï¼Œä¸€ä¸ªä¸ 111 å±äºåŒä¸€ä¸ªé›†åˆï¼Œä¸€ä¸ªä¸ nnn å±äºåŒä¸€ä¸ªé›†åˆï¼Œè¿˜éœ€è¦è¿çš„è¾¹æ•°ä¸º nÃ—(nâˆ’1)Ã·2âˆ’mâˆ’k(nâˆ’k)n\\times(n-1)\\div 2-m-k(n-k)nÃ—(nâˆ’1)Ã·2âˆ’mâˆ’k(nâˆ’k)ã€‚ å½“ nnn ä¸ºå¥‡æ•°æ—¶ï¼Œk(nâˆ’k)k(n-k)k(nâˆ’k) å¿…å®šä¸ºå¶æ•°ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥æ ¹æ®å¥‡å¶æ€§åˆ¤æ–­ã€‚ å½“ nnn ä¸ºå¶æ•°æ—¶ï¼Œè€ƒè™‘ä¸ 1,n1,n1,n ç›¸è¿çš„é›†åˆå¤§å°åˆ†åˆ«ä¸º x,yx,yx,yï¼Œé‚£ä¹ˆè‹¥ x,yx,yx,y å¥‡å¶æ€§ä¸åŒï¼Œåˆ™å…ˆæ‰‹å¯ä»¥éšæ„æ§åˆ¶ kkk çš„å¥‡å¶æ€§ï¼ˆç¬¬ä¸€æ­¥è¾¾åˆ°ï¼Œç„¶åæ¥ä¸‹æ¥ç»´æŠ¤ä¸å˜ï¼‰ï¼Œå¿…èƒœã€‚è‹¥ç›¸åŒï¼Œåˆ™è€ƒè™‘ nÃ—(nâˆ’1)Ã·2âˆ’mâˆ’xyn\\times (n-1)\\div 2 -m -xynÃ—(nâˆ’1)Ã·2âˆ’mâˆ’xy çš„å¥‡å¶æ€§ï¼Œå› ä¸ºæ¯ä¸€æ–¹æ€»èƒ½è®©å¥‡å¶æ€§ä¸å˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int fa[100005], siz[100005]; int find(int x) &#123; if (x == fa[x]) return x; return fa[x] = find(fa[x]); &#125; int n, m; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) fa[i] = i, siz[i] = 1; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); int uu = find(u), vv = find(v); if (uu != vv) fa[vv] = uu, siz[uu] += siz[vv]; &#125; if (find(1) == find(n)) return puts(\"Second\"), void(); if (n % 2) return puts((1ll * n * (n - 1) / 2 - m) % 2 ? \"First\" : \"Second\"), void(); int x = siz[find(1)], y = siz[find(n)]; if (x % 2 != y % 2) return puts(\"First\"), void(); if ((1ll * n * (n - 1) / 2 - m - x * y) % 2) puts(\"First\"); else puts(\"Second\"); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; AtCoder Regular Contest 143 Portal. A. Three Integers Portal. æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef long long i64; int main(void) &#123; i64 a[3]; cin >> a[0] >> a[1] >> a[2]; sort(a, a + 3); if (a[0] + a[1] &lt; a[2]) puts(\"-1\"); else printf(\"%lld\\n\", a[2]); return 0; &#125; C. Piles of Pebbles Portal. åˆ†ç±»è®¨è®ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, x, y; int a[200005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;x, &amp;y); bool flag = 0, g = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); a[i] %= x + y; if (a[i] != 0) flag = true; &#125; if (!flag) return puts(\"Second\"), 0; if (x &lt;= y) puts(\"First\"); else &#123; flag = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &lt; x) flag = true; if (flag) puts(\"Second\"); else puts(\"First\"); &#125; return 0; &#125; AtCoder Regular Contest 145 Portal. A. AB Palindrome Portal. æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; char s[200005]; int main(void) &#123; scanf(\"%d%s\", &amp;n, s); if (s[0] == 'A' &amp;&amp; s[n - 1] == 'A') puts(\"Yes\"); else if (s[0] == 'A' &amp;&amp; s[n - 1] == 'B') puts(\"No\"); else if (s[0] == 'B' &amp;&amp; s[n - 1] == 'A') &#123; if (n > 2) puts(\"Yes\"); else puts(\"No\"); &#125; else puts(\"Yes\"); return 0; &#125; B. AB Game Portal.nnn è½®æ¸¸æˆï¼Œç¬¬ iii è½®æœ‰ iii ä¸ªçŸ³å­ã€‚Alice å…ˆæ‰‹ï¼Œæ¯æ¬¡å¯ä»¥å– aaa çš„å€æ•°çš„çŸ³å­ï¼ŒBob åæ‰‹ï¼Œå¯ä»¥å– bbb çš„å€æ•°çš„çŸ³å­ã€‚è°å–ä¸äº†çŸ³å­ï¼Œè°å°±è¾“ã€‚é—® Alice èµ¢å‡ åœºã€‚ å¯ä»¥è‚¯å®šï¼Œèƒ½å–å¤šå°‘å°±å–å¤šå°‘ã€‚ å½“ n&lt;an&lt;an&lt;a æ—¶ï¼Œæ˜¾ç„¶ç›´æ¥æ­»ã€‚ å½“ a&lt;ba&lt;ba&lt;b æ—¶ï¼Œé™¤äº†ä¸€å¼€å§‹ nâˆ’1n-1nâˆ’1 è½®ï¼Œå‰©ä¸‹éƒ½èµ¢ã€‚ å½“ aâ‰¥ba\\ge baâ‰¥b æ—¶ï¼Œå¯ä»¥å‘ç°æœ‰èƒœåˆ©å¾ªç¯èŠ‚ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int main(void) &#123; i64 n, a, b; cin >> n >> a >> b; if (n &lt; a) puts(\"0\"); else if (n == a) puts(\"1\"); else if (a &lt; b) printf(\"%lld\\n\", n - a + 1); else &#123; i64 ans = 1; n -= a; ans += n / a * b; n %= a; ans += min(n, b - 1); printf(\"%lld\\n\", ans); &#125; return 0; &#125; C. Split and Maximize Portal.å¯¹äºä¸€ä¸ª 1âˆ¼2n1\\sim2n1âˆ¼2n çš„æ’åˆ— [p1,p2,â€¦,p2n][p_{1},p_{2},\\dots,p_{2n}][p1â€‹,p2â€‹,â€¦,p2nâ€‹]ï¼Œè€ƒè™‘å°† PPP æ‹†åˆ†ä¸ºä¸¤ä¸ªå­åºåˆ— [a1,a2,â€¦,an][a_1,a_2,\\dots,a_n][a1â€‹,a2â€‹,â€¦,anâ€‹] å’Œ [b1,b2,â€¦,bn][b_1,b_2,\\dots,b_n][b1â€‹,b2â€‹,â€¦,bnâ€‹]ï¼ŒPPP çš„åˆ†æ•°å®šä¹‰ä¸ºæ‰€æœ‰æ‹†åˆ†æ–¹æ¡ˆä¸­çš„ âˆ‘aibi\\sum a_i b_iâˆ‘aiâ€‹biâ€‹ çš„æœ€å¤§å€¼ã€‚è¯·æ±‚å‡ºåˆ†æ•°å–åˆ°æœ€å¤§å€¼çš„æ’åˆ—çš„æ•°é‡ï¼Œå¯¹ 998244353998244353998244353 å–æ¨¡ã€‚ æ˜¾ç„¶åªèƒ½ (1,2),(3,4)â€¦(2nâˆ’1,2n)(1,2),(3,4)\\dots (2n-1,2n)(1,2),(3,4)â€¦(2nâˆ’1,2n) è¿™æ ·é…å¯¹ï¼Œè€Œæ¯ä¸€ä¸ªé…å¯¹çš„å·¦å³é¡ºåºæ˜¯ä¸å½±å“çš„ï¼Œæ‰€ä»¥ç­”æ¡ˆåŸºæ•°ä¸º 2n2^n2nã€‚ è€Œä¸”è¦ä¿è¯æ˜¯å­åºåˆ—ï¼Œæ‰€ä»¥ç›¸å½“äºåœ¨ 2n2n2n ä¸­é€‰æ‹© nnn ä¸ªä½ç½®è¿›è¡Œæ”¾ç½®ï¼Œæ–¹æ¡ˆæ•°ä¸º (2nn)\\binom{2n}{n}(n2nâ€‹)ã€‚ æ‰€ä»¥ç­”æ¡ˆä¸º 2n(2nn)2^n\\binom{2n}{n}2n(n2nâ€‹)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int main(void) &#123; int n; cin >> n; i64 ans = poww(2, n); for (int i = n + 2; i &lt;= (n &lt;&lt; 1); ++i) ans = ans * i % MOD; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; D. Non Arithmetic Progression Set Portal.æ„é€ ä¸€ä¸ªæœ‰ nnn ä¸ªæ•´æ•°çš„é›†åˆ SSSï¼Œæ»¡è¶³æ‰€æœ‰æ•°çš„å’Œä¸º MMMï¼Œè€Œä¸”æ¯ä¸ªæ•°çš„å€¼åŸŸå‡ä¸º [âˆ’107,107][-10^7,10^7][âˆ’107,107] ä¸­ï¼Œå¹¶ä¸”å¯¹äºä»»æ„ x,y,zâˆˆS,x&lt;y&lt;zx,y,z\\in S, x&lt;y&lt;zx,y,zâˆˆS,x&lt;y&lt;zï¼Œéƒ½æœ‰ yâˆ’xâ‰ zâˆ’yy-x\\neq z-yyâˆ’xî€ =zâˆ’yã€‚ é¦–å…ˆï¼Œyâˆ’xâ‰ zâˆ’yy-x\\neq z-yyâˆ’xî€ =zâˆ’y ç›¸å½“äº x+zâ‰ 2yx+z\\neq 2yx+zî€ =2yã€‚ æˆ‘ä»¬å…ˆæŠ›å¼€å’Œä¸º MMM çš„é™åˆ¶ï¼Œè€ƒè™‘å¦‚ä½•æå®šæœ€åé‚£ä¸ªä¸ç­‰çš„é™åˆ¶æ¡ä»¶ã€‚ è¿™é‡Œå…ˆç»™å‡ºç»“è®ºï¼šå°†æ•°å†™æˆä¸‰è¿›åˆ¶ï¼Œå½“æ•°çš„æ‰€æœ‰ä½éƒ½æ˜¯ 0,10,10,1 æ—¶å¯ä»¥æ»¡è¶³ã€‚ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿè€ƒè™‘ x+z=2yx+z=2yx+z=2yï¼Œyyy ä¹˜ä¸Š 222 ä¹‹åæ¯ä¸€ä½éƒ½æ˜¯ 000 æˆ– 222ï¼Œè€Œ xxx å’Œ zzz å¿…å®šæœ‰ä¸€ä½ä¸ä¸€æ ·ï¼ˆå¦åˆ™å°±ç›¸ç­‰äº†ï¼‰ï¼ŒåŠ ä¸Šä¹‹åè‚¯å®šæœ‰ä¸€ä½æ˜¯ 111ï¼Œå¿…å®šä¸ç­‰äº 2y2y2yã€‚æ‰€ä»¥ä¸ç­‰å…³ç³»æ°¸è¿œæ»¡è¶³ã€‚ ç°åœ¨å‡å®šæˆ‘ä»¬æ„é€ å‡ºæ¥çš„é›†åˆå¯ä»¥è¡¨ç¤ºä¸ºé€’å¢åºåˆ— aaaï¼Œç„¶åè¿›è¡Œä¸‹é¢å¯¹ MMM çš„é™åˆ¶çš„è®¨è®ºã€‚ å‡è®¾æˆ‘ä»¬çš„ sss ä¸ MMM çš„å·®ä¸º xxxï¼Œæ•´ä¸ªåºåˆ—å¦‚æœåŒæ—¶åŠ ä¸Šæˆ–å‡å»ä¸€ä¸ªæ•°ï¼Œå…¶æ€§è´¨ä»ç„¶æ»¡è¶³ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸€ç‚¹å°†å·® xxx æ§åˆ¶åœ¨ 0âˆ¼nâˆ’10\\sim n-10âˆ¼nâˆ’1 å†…ã€‚æˆ‘ä»¬å°†ä¸‰è¿›åˆ¶ä½çš„æœ€åä¸€ä½ç•™ç™½ï¼ˆå³æœ€åä¸€ä½ä¸è¿›è¡Œæ„é€ ï¼Œç•™å‡ºæ¥ä¸€ä¸ª 000ï¼‰ï¼Œç„¶åé€‰æ‹©ä»»æ„ xxx ä¸ªæ•°åŠ ä¸Š 111 å³å¯ï¼Œæœ€åä¸€ä½çš„æ”¹å˜å¹¶ä¸ä¼šå½±å“ç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef long long i64; int n, a[10005]; i64 m, s = 0; int main(void) &#123; cin >> n >> m; for (int p = 1; p &lt;= n; ++p) &#123; int x = 0, i = p * 2; for (int j = 0, z = 1; j &lt; 16; ++j, z *= 3) if ((i >> j) &amp; 1) x += z; a[p] = x; s += a[p]; &#125; int x = ((m - s) % n + n) % n; for (int i = 1; i &lt;= x; ++i) ++a[i], ++s; i64 buf = (m - s) / n; s = 0; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i] + buf); putchar('\\n'); return 0; &#125; AtCoder Regular Contest 147 Portal. A. Max Mod Min Portal. å¯ä»¥é¢„è®¡ç­”æ¡ˆä¸ä¼šå¾ˆå¤§ï¼Œç›´æ¥æ¨¡æ‹Ÿã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;set> using namespace std; int main(void) &#123; ios::sync_with_stdio(false); int n, x; multiset &lt;int, greater&lt;int>> s; cin >> n; while (n--) &#123; cin >> x; s.insert(x); &#125; int res = 0; while (s.size() > 1) &#123; auto i = s.end(), j = s.begin(); --i; int t = (*j) % (*i); s.erase(j); if (t) s.insert(t); ++res; &#125; printf(\"%d\\n\", res); return 0; &#125; B. Swap to Sort Portal.ç°æœ‰ä¸€ä¸ª 111 åˆ° NNN çš„æ’åˆ— P=(P1,P2,â€¦,PN)P=(P_1,P_2,\\ldots,P_N)P=(P1â€‹,P2â€‹,â€¦,PNâ€‹)ã€‚ä½ å¯ä»¥é‡å¤æ‰§è¡Œä»¥ä¸‹ä¸¤ç§æ“ä½œæ¥ä½¿PPPä»å°åˆ°å¤§æ’åºã€‚æ“ä½œ A:A:A: é€‰æ‹©ä¸€ä¸ªæ•´æ•° iii æ»¡è¶³ 1 â‰¤ i â‰¤ Nâˆ’11\\ \\leq\\ i\\ \\leq\\ N-11 â‰¤ i â‰¤ Nâˆ’1ï¼Œç„¶åäº¤æ¢ PiP_iPiâ€‹ å’Œ Pi+1P_{i+1}Pi+1â€‹ã€‚æ“ä½œ B:B:B: é€‰æ‹©ä¸€ä¸ªæ•´æ•° iii æ»¡è¶³ 1 â‰¤ i â‰¤ Nâˆ’21\\ \\leq\\ i\\ \\leq\\ N-21 â‰¤ i â‰¤ Nâˆ’2ï¼Œç„¶åäº¤æ¢ PiP_iPiâ€‹ å’Œ Pi+2P_{i+2}Pi+2â€‹ã€‚è¯·æ‰¾å‡ºä¸€ä¸ªæ“ä½œåºåˆ—æ»¡è¶³æ“ä½œ AAA çš„æ•°é‡æœ€å°‘ã€‚ åªè¦å¥‡æ•°éƒ½åœ¨å¥‡æ•°ä½ç½®ï¼Œå¶æ•°éƒ½åœ¨å¶æ•°ä½ç½®ï¼Œé‚£ä¹ˆåªéœ€è¦ 2 æ“ä½œå°±å¯ä»¥å®Œæˆã€‚å› æ­¤æˆ‘ä»¬åªéœ€è¦ 1 æ“ä½œä¿®æ­£å¥‡å¶æ€§ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef pair&lt;int,int> pii; int n; int a[405]; vector &lt;pii> ans; void f(int ty, int x) &#123; ans.emplace_back(make_pair(ty, x)); swap(a[x], a[x + ty]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); // å¥‡å¶æ€§ä¿®æ­£ for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n - 2; ++j) if (a[j] % 2 != a[j + 2] % 2 &amp;&amp; a[j] % 2 != j % 2) f(2, j); for (int i = 1; i &lt; n; ++i) if (a[i] % 2 != i % 2) f(1, i); // ç»´æŠ¤å¤§å° for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n - 2; ++j) if (a[j] > a[j + 2]) f(2, j); cout &lt;&lt; ans.size() &lt;&lt; endl; for (auto x : ans) printf(\"%c %d\\n\", x.first == 1 ? 'A' : 'B', x.second); return 0; &#125; PART-B æƒ³äº†æƒ³å¯ä»¥æ‰©å¤§ä¸€ä¸‹èŒƒå›´ï¼ŒABC ä¹Ÿå¯ä»¥åšä¸€åšï¼Œä½†ç®€å•é¢˜å°±ä¸å†™äº†ã€‚ ATCoder Regular Contest 144 Portal. C. K Derangement Portal.æ±‚å­—å…¸åºæœ€å°çš„ 1âˆ¼n1\\sim n1âˆ¼n çš„æ’åˆ— ppp æ»¡è¶³ âˆ£piâˆ’iâˆ£â‰¥k\\left|p_i-i\\right|\\geq kâˆ£piâ€‹âˆ’iâˆ£â‰¥kï¼Œæ— è§£è¾“å‡º âˆ’1-1âˆ’1ã€‚2â‰¤nâ‰¤1052\\leq n\\leq10^52â‰¤nâ‰¤105ï¼Œ1â‰¤p&lt;n1\\leq p&lt;n1â‰¤p&lt;nã€‚ æ˜¾ç„¶ï¼Œk&gt;n2k&gt;\\cfrac{n}{2}k&gt;2nâ€‹ çš„æ—¶å€™æ— è§£ã€‚ å¦åˆ™å‘¢ï¼Ÿæ¯”å¦‚æˆ‘ä»¬æ¥çœ‹è¿™æ ·ä¸€ä¸ªï¼š9 1ï¼Œå®ƒçš„ç­”æ¡ˆæ˜¯ 2 1 4 3 6 5 8 9 7ã€‚ æŒ‰ä½æ„é€ ï¼Œè€ƒè™‘æ¯ä¸€ä¸ª iiiï¼Œå¦‚æœ i+ki+ki+k ä¸åœ¨ A1,â€¦,Aiâˆ’1A_1,\\dots,A_{i-1}A1â€‹,â€¦,Aiâˆ’1â€‹ é‡Œï¼Œè€Œä¸”æ»¡è¶³ i+k&gt;nâˆ’ki+k&gt;n-ki+k&gt;nâˆ’kï¼Œé‚£ä¹ˆå°±è®© Aiâ†i+kA_i\\leftarrow i+kAiâ€‹â†i+kï¼Œè¿™æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬åªæ˜¯å»æ‰¾æœ€å°çš„ï¼Œå¯èƒ½æœ€ç»ˆçš„æ„é€ ä¼šå‡ºç°æ­»å±€ï¼Œè¿™ç§æ—¶å€™å°±æ˜¯è¦å‡ºç°æ­»å±€äº†ï¼Œäºæ˜¯å°±ä¸èƒ½ä½¿ç”¨â€œå¦åˆ™â€è¿™ä¸ªæ–¹å¼ï¼› å¦åˆ™å°±æ‰¾åˆ°ä¸€ä¸ªæœ€å°çš„å¯ç”¨çš„ xxx æ»¡è¶³ âˆ£xâˆ’iâˆ£â‰¥k|x-i|\\ge kâˆ£xâˆ’iâˆ£â‰¥kã€‚ ç°åœ¨å¦‚ä½•å®ç°æ›´æ˜¯ä¸ªéš¾é¢˜ã€‚ å½“ nâ‰¥4kn\\ge 4knâ‰¥4k æ—¶ï¼Œæˆ‘ä»¬ä¼šä»¥ 2k2k2k çš„é•¿åº¦ä½œä¸ºå¾ªç¯ï¼Œé•¿æˆ k+1,â€¦,2k,1,â€¦,kk+1,\\dots,2k,1,\\dots,kk+1,â€¦,2k,1,â€¦,k è¿™æ ·å­ã€‚ æ¥ä¸‹æ¥å°±ä¸èƒ½å¾ªç¯äº†ï¼Œå¦åˆ™å¯èƒ½æŠŠå®ƒåé¢æ•´æˆæ— æ³•æ„é€ çš„ã€‚åªå¯èƒ½æœ‰ä¸¤ç§æƒ…å†µï¼ˆå¦åˆ™å·²ç»è¢«åˆ¤ä¸ºæ— è§£ï¼‰ï¼š 2kâ‰¤nâ‰¤3k2k\\le n\\le 3k2kâ‰¤nâ‰¤3kï¼Œå¯ä»¥æ„é€ æˆ Ai={i+k,1â‰¤iâ‰¤nâˆ’k,iâˆ’n+k,nâˆ’k&lt;iâ‰¤n.A_i=\\begin{cases}i+k,&amp;1\\le i \\le n-k,\\\\i-n+k,&amp;n-k&lt;i\\le n.\\end{cases}Aiâ€‹={i+k,iâˆ’n+k,â€‹1â‰¤iâ‰¤nâˆ’k,nâˆ’k&lt;iâ‰¤n.â€‹ 3k&lt;nâ‰¤4k3k&lt;n\\le 4k3k&lt;nâ‰¤4kï¼Œå¯ä»¥æ„é€ æˆ Ai={i+k,1â‰¤iâ‰¤k,iâˆ’k,k&lt;iâ‰¤nâˆ’2k,i+k,nâˆ’2k&lt;iâ‰¤nâˆ’k,iâˆ’2k,nâˆ’k&lt;iâ‰¤3k,iâˆ’k,3k&lt;iâ‰¤n.A_i=\\begin{cases}i+k,&amp;1\\le i\\le k,\\\\i-k,&amp;k&lt;i\\le n-2k,\\\\i+k,&amp;n-2k&lt;i\\le n-k,\\\\i-2k,&amp; n-k&lt;i\\le 3k,\\\\i-k,&amp;3k&lt;i\\le n.\\end{cases}Aiâ€‹=â©â¨â§â€‹i+k,iâˆ’k,i+k,iâˆ’2k,iâˆ’k,â€‹1â‰¤iâ‰¤k,k&lt;iâ‰¤nâˆ’2k,nâˆ’2k&lt;iâ‰¤nâˆ’k,nâˆ’k&lt;iâ‰¤3k,3k&lt;iâ‰¤n.â€‹ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, k; cin >> n >> k; if (k > n / 2) return puts(\"-1\"), 0; int m = 0; while (n - m >= k * 4) &#123; for (int i = 1; i &lt;= k; ++i) printf(\"%d \", m + k + i); for (int i = 1; i &lt;= k; ++i) printf(\"%d \", m + i); m += 2 * k; &#125; if (n - m &lt;= 3 * k) &#123; for (int i = m + k + 1; i &lt;= n; ++i) printf(\"%d \", i); for (int i = m + 1; i &lt;= m + k; ++i) printf(\"%d \", i); &#125; else &#123; int d = n - m - 3 * k; for (int i = 1; i &lt;= k; ++i) printf(\"%d \", m + k + i); for (int i = 1; i &lt;= d; ++i) printf(\"%d \", m + i); for (int i = 1; i &lt;= k; ++i) printf(\"%d \", n - k + i); for (int i = d + 1; i &lt;= k; ++i) printf(\"%d \", m + i); for (int i = 1; i &lt;= d; ++i) printf(\"%d \", m + 2 * k + i); &#125; putchar('\\n'); return 0; &#125; ATCoder Regular Contest 144 Portal. A. Digit Sum of 2x Portal. ä¸€ä¸ªæ•°çš„ç¬¬ä¸€ä½æ˜¯ 111ï¼Œèƒ½å¯¹ç­”æ¡ˆäº§ç”Ÿè´¡çŒ®çš„æ•°çš„åŒºé—´æ˜¯ï¼š [1,2)[1,2)[1,2)ï¼Œ [10,20)[10, 20)[10,20)ï¼Œ [100,200)[100, 200)[100,200)ï¼Œ â€¦ ç¬¬äºŒä½æ˜¯ 111 èƒ½å¯¹ç­”æ¡ˆäº§ç”Ÿè´¡çŒ®çš„æ˜¯ï¼š [11,12)[11,12)[11,12)ï¼Œ [110,120)[110,120)[110,120), â€¦ æšä¸¾å‰é¢ 111 çš„ä¸ªæ•°ä½œä¸ºä¸‹ç•Œé—­åŒºé—´ï¼Œå†åŠ ä¸Š 111 ä½œä¸ºä¸Šç•Œå¼€åŒºé—´ï¼Œä¸æ–­ä¹˜ 101010 æ¥è·å¾—æ–°çš„ä¸Šä¸‹ç•Œï¼Œéœ€è¦æ³¨æ„è¾¹ç•Œæ¡ä»¶ nnn å’Œå½“å‰ç®—çš„æ•°è¦å–ä¸€ä¸ªæœ€å°å€¼ã€‚æ—¶é—´å¤æ‚åº¦ O(logâ¡2n)O(\\log^2 n)O(log2n)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int main(void) &#123; i64 n, ans = 0, base = 0; scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= 16; ++i) &#123; base = base * 10 + 1; i64 w = base, t = base + 1; for (int j = i; j &lt;= 16 &amp;&amp; w &lt;= n; ++j) &#123; ans += (min(t, n + 1) - w); w *= 10, t *= 10; &#125; &#125; printf(\"%lld\\n\", ans); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"æ¯”èµ›è®°å½•","slug":"ç®—æ³•ç«èµ›/æ¯”èµ›è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"åˆ·","slug":"åˆ·","permalink":"https://james1badcreeper.github.io/tags/%E5%88%B7/"},{"name":"ATCoder","slug":"ATCoder","permalink":"https://james1badcreeper.github.io/tags/ATCoder/"}]},{"title":"Codeforces Round #293 å·¦å³çš„ç®€å•é¢˜","slug":"default/old/cf292","date":"2022-11-06T00:00:00.000Z","updated":"2022-11-06T00:00:00.000Z","comments":true,"path":"c3c4dd23/","link":"","permalink":"https://james1badcreeper.github.io/c3c4dd23/","excerpt":"åšä¸äº†ã€Šé«˜è€ƒå¿…åˆ·å·ã€‹ï¼Œé‚£å°±åšåšè¿™ä¸ªå§ã€‚","text":"åšä¸äº†ã€Šé«˜è€ƒå¿…åˆ·å·ã€‹ï¼Œé‚£å°±åšåšè¿™ä¸ªå§ã€‚ å®é™…ä¸Šæ˜¯åœ¨æ´›è°· RMJ åšçš„é¢˜ã€‚ Codeforces Round 292 (Croc Champ 2013 - Round 1) å¤§æ¦‚å°±æ˜¯è¿™æ ·ã€‚ A. SMSC Portal. ç®€å•æ¨¡æ‹Ÿã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;algorithm> using namespace std; int n; int T[1000005], C[1000005]; int inq, maxx; int main(void) &#123; ios::sync_with_stdio(false); cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> T[i] >> C[i]; for (int i = 1; i &lt;= n; ++i) &#123; if (i > 1) inq = max(0, inq - (T[i] - T[i - 1])); inq += C[i]; maxx = max(inq, maxx); &#125; cout &lt;&lt; T[n] + inq &lt;&lt; ' ' &lt;&lt; maxx &lt;&lt; endl; return 0; &#125; B. Network Topology Portal. å¥½åƒè¿˜æ˜¯æ¨¡æ‹Ÿã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, m; vector &lt;int> G[100005]; bool check_ju(void) &#123; int flag = 0; for (int i = 1; i &lt;= n; ++i) if (G[i].size() != 1) &#123; ++flag; if (flag >= 2) return false; &#125; return flag == 1; &#125; bool check_lian(void) &#123; int cnt1 = 0, cnt2 = 0; for (int i = 1; i &lt;= n; ++i) if (G[i].size() == 1) ++cnt1; else if (G[i].size() == 2) ++cnt2; else return false; return cnt1 == 2 &amp;&amp; cnt2 == n - 2; &#125; bool check_huan(void) &#123; for (int i = 1; i &lt;= n; ++i) if (G[i].size() != 2) return false; return true; &#125; int main(void) &#123; cin >> n >> m; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; if (m != n &amp;&amp; m != n - 1) puts(\"unknown topology\"); else if (m == n - 1) &#123; if (check_ju()) puts(\"star topology\"); else if (check_lian()) puts(\"bus topology\"); else puts(\"unknown topology\"); &#125; else &#123; if (check_huan()) puts(\"ring topology\"); else puts(\"unknown topology\"); &#125; return 0; &#125; C. Beautiful IP Addresses Portal. åº”è¯¥è¿˜æ˜¯æ¨¡æ‹Ÿã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #include &lt;vector> using namespace std; int flag = 0; int tot = 0; vector &lt;string> v; bool check(const string &amp;s, int l, int r) &#123; if (s[l] == '0') return r == l + 1; int x = 0; for (int i = l; i &lt; r; ++i) x = x * 10 + s[i] - '0'; return 0 &lt;= x &amp;&amp; x &lt;= 255; &#125; void addIP(const string &amp;s) &#123; int n = s.length(); for (int i = 1; i &lt;= 3; ++i) for (int j = i + 1; j &lt;= i + 3; ++j) for (int k = j + 1; k &lt;= j + 3; ++k) if (1 &lt;= n - k &amp;&amp; n - k &lt;= 3 &amp;&amp; check(s, 0, i) &amp;&amp; check(s, i, j) &amp;&amp; check(s, j, k) &amp;&amp; check(s, k, n)) v.emplace_back(s.substr(0, i) + \".\" + s.substr(i, j - i) + \".\" + s.substr(j, k - j) + \".\" + s.substr(k, n - k)); &#125; void dfs(int x, string s, int n, int state) &#123; if (x == n) &#123; if (state != flag) return; addIP(s); return; &#125; if (x * 2 >= n) &#123; if (state != flag) return; dfs(x + 1, s + s[n - x - 1], n, state); return; &#125; for (int i = 0; i &lt; 10; ++i) if (flag &amp; (1 &lt;&lt; i)) dfs(x + 1, s + char(i + '0'), n, state | (1 &lt;&lt; i)); &#125; int main(void) &#123; ios::sync_with_stdio(false); int n; cin >> n; for (int i = 1, x; i &lt;= n; ++i) &#123; cin >> x; flag |= (1 &lt;&lt; x); &#125; if (n &lt;= 6) &#123; for (int i = 4; i &lt;= 12; ++i) dfs(0, \"\", i, 0); &#125; cout &lt;&lt; v.size() &lt;&lt; '\\n'; for (int i = 0; i &lt; v.size(); ++i) cout &lt;&lt; v[i] &lt;&lt; '\\n'; return 0; &#125; Codeforces Round #178 (Div.2) å¥½åƒè¿˜æ˜¯è¿™æ ·ã€‚ A. Shaass and Oskols Portal. å°±æ˜¯æ¨¡æ‹Ÿã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int a[105]; int main(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; cin >> m; while (m--) &#123; int x, y; cin >> x >> y; a[x - 1] += y - 1; a[x + 1] += a[x] - y; a[x] = 0; &#125; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; '\\n'; return 0; &#125; B. Shaass and Bookshelf Portal. æ¯æœ¬ä¹¦è¦ä¹ˆæ˜¯å‚ç›´æ”¾ç½®ï¼Œè¦ä¹ˆå°†æ¥èººç€ã€‚è®¾ f(i)f(i)f(i) ä¸ºç«–å·çš„æ€»åšåº¦ä¹‹å’Œä¸º iiiï¼Œæ‰€ç”¨çš„æœ€å¤§å®½åº¦ï¼Œé‚£ä¹ˆè½¬ç§»çš„æ—¶å€™å°±æ˜¯ä¸ª 01 èƒŒåŒ…ã€‚ æœ€åè¦æ±‚çš„æ˜¯ç«–ç€çš„æœ€å°æ€»åšåº¦ï¼Œé‚£ç›´æ¥æšä¸¾åˆ¤æ–­æ˜¯å¦åˆæ³•ï¼Œåˆæ³•ä»…å½“å½“å‰çš„åšåº¦è¦å¤§äºç­‰äºä¸Šé¢å †ç€çš„å®½åº¦ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m, s = 0; int t[105], w[105]; int f[205]; int main(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> t[i] >> w[i]; m += t[i]; s += w[i]; f[i] = f[i + n] = -1e9; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = m; j >= t[i]; --j) f[j] = max(f[j], f[j - t[i]] + w[i]); for (int i = 0; i &lt;= m; ++i) if (i >= s - f[i]) return printf(\"%d\\n\", i), 0; return 0; &#125; C. Shaass and Lights Portal. æœ‰ n(1â‰¤nâ‰¤103)n(1\\le n\\le 10^3)n(1â‰¤nâ‰¤103) ç›ç¯ï¼Œæœ‰ mmm ç›å·²ç»ç‚¹äº®ï¼Œæ¯æ¬¡åªèƒ½ç‚¹äº®ä¸å·²ç»ç‚¹äº®çš„ç¯ç›¸é‚»çš„ç¯ï¼Œæ±‚ç‚¹äº®æ‰€æœ‰ç¯çš„æ€»æ–¹æ¡ˆæ•°ï¼Œç­”æ¡ˆå¯¹ 109+710^9+7109+7 å–æ¨¡ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"åˆ·","slug":"åˆ·","permalink":"https://james1badcreeper.github.io/tags/%E5%88%B7/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"}]},{"title":"åŸºäºçº¿æ®µæ ‘å’Œæ ‘çŠ¶æ•°ç»„çš„åºåˆ—ç»´æŠ¤","slug":"notes/DS/Segmenttree","date":"2022-11-06T00:00:00.000Z","updated":"2022-11-06T00:00:00.000Z","comments":true,"path":"89bb6fd1/","link":"","permalink":"https://james1badcreeper.github.io/89bb6fd1/","excerpt":"çº¿æ®µæ ‘ï¼ˆSegment Treeï¼‰æ˜¯ä¸€ç§äºŒå‰æœç´¢æ ‘ï¼Œ1977 å¹´ç”± Jon Louis Bentley å‘æ˜ï¼Œå¯ä»¥è¾ƒä¸ºçµæ´»ä¸”æ•ˆç‡è¾ƒé«˜åœ°è§£å†³ä¿¡æ¯å¯åˆå¹¶çš„åºåˆ—ç»´æŠ¤é—®é¢˜ã€‚è€Œæ ‘çŠ¶æ•°ç»„å¯ä»¥ç»´æŠ¤åºåˆ—çš„å‰ç¼€å’Œã€‚","text":"çº¿æ®µæ ‘ï¼ˆSegment Treeï¼‰æ˜¯ä¸€ç§äºŒå‰æœç´¢æ ‘ï¼Œ1977 å¹´ç”± Jon Louis Bentley å‘æ˜ï¼Œå¯ä»¥è¾ƒä¸ºçµæ´»ä¸”æ•ˆç‡è¾ƒé«˜åœ°è§£å†³ä¿¡æ¯å¯åˆå¹¶çš„åºåˆ—ç»´æŠ¤é—®é¢˜ã€‚è€Œæ ‘çŠ¶æ•°ç»„å¯ä»¥ç»´æŠ¤åºåˆ—çš„å‰ç¼€å’Œã€‚ æ›´æ–°æ—¥å¿— 2023/7/14å¼€å§‹å¤§è§„æ¨¡åœ°æ›´æ”¹ä»£ç ï¼Œé‡æ„æ–‡ç« ã€‚2023/6/30è¡¥å……æ²¡æœ‰ç†è§£é€å½»çš„å†…å®¹ï¼Œå¢åŠ çš„éƒ¨åˆ†å†…å®¹å’Œä¹ é¢˜ï¼Œåˆ é™¤äº†å†—ä½™çš„ä¹ é¢˜ã€‚ æ ‘çŠ¶æ•°ç»„ åˆç§° Fenwick æ ‘ã€äºŒå‰ç´¢å¼•æ ‘ï¼ˆBITï¼‰ã€‚æ”¯æŒç»´æŠ¤å‰ç¼€åç¼€çš„ä¿¡æ¯ã€‚ æ¦‚è¿° æ ‘çŠ¶æ•°ç»„å°†åºåˆ—æ‹†åˆ†æˆäº†æ°å¥½ nnn ä¸ªåŒºé—´ï¼Œå¯¹äºæ¯ä¸€ä¸ªå‰ç¼€æ±‚è§£éƒ½å¯ä»¥æ‹†æˆ logâ¡p\\log plogp ä¸ªåŒºé—´è¿›è¡Œæ±‚è§£ï¼Œè€Œä¸”è‡ªå¸¦ä¸€ä¸ªå¡ä¸æ‰çš„ 1/21/21/2 çš„å¸¸æ•°ï¼Œéšæœºæ•°æ®ä¸‹åˆ™ä¸º 1/41/41/4 çš„å¸¸æ•°ï¼æˆ‘ä»¬é€šè¿‡ lowbitâ¡\\operatorname{lowbit}lowbit æ¥æ”¯æŒæ ‘çŠ¶æ•°ç»„çš„å·¥ä½œã€‚ ä¸€ä¸ªæ˜¾å¼çš„æ ‘çŠ¶æ•°ç»„ æ¨¡æ¿ï¼ŒåŒºé—´å’Œæˆ‘ä»¬å¯ä»¥ç”¨å‰ç¼€å’Œç›¸å‡æ¥æ±‚è§£ï¼Œä»£ç å¦‚ä¸‹ï¼š #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[500005]; i64 C[500005]; void add(int x, int k) &#123; for (; x &lt;= n; x += x &amp; -x) C[x] += k; &#125; i64 sum(int x) &#123; i64 r = 0; for (; x; x -= x &amp; -x) r += C[x]; return r; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), add(i, a[i]); while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) add(x, y); else printf(\"%lld\\n\", sum(y) - sum(x - 1)); &#125; return 0; &#125; æ ‘çŠ¶æ•°ç»„è‡ªèº«ä¹Ÿæœ‰è®¸å¤šæ¼‚äº®çš„æ“ä½œï¼Œè™½ç„¶æ•ˆç‡ä¸Šç•¥å¾®èƒœäºçº¿æ®µæ ‘å’Œå¹³è¡¡æ ‘ï¼Œä½†æ˜¯å¯æ‰©å±•æ€§å’Œç›´è§‚ç¨‹åº¦ä¸Šå´ä¸å¦‚å®ƒä»¬ã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€äº›å¿…é¡»æŒæ¡çš„ã€‚ çº¿æ€§å»ºæ ‘ å¯¹äºæ ‘çŠ¶æ•°ç»„ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½å‘ä¸Šä¼ é€’ï¼Œå…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼š for (int i = 1; i &lt;= n; ++i) &#123; int x; cin >> x; C[i] += x; if (i + lowbit(i) &lt;= n) C[i + lowbit(i)] += C[i]; &#125; å·®åˆ†ä¸å‰ç¼€å’Œ æ ‘çŠ¶æ•°ç»„å¯ä»¥è½»æ¾ç»´æŠ¤åºåˆ—çš„é«˜é˜¶å‰ç¼€å’Œï¼Œé¦–å…ˆå°†åŸåºåˆ—å·®åˆ†å¯ä»¥ç›´æ¥è§£å†³åŒºé—´åŠ å•ç‚¹æŸ¥è¯¢ã€‚ è¿™é‡Œç›´æ¥ç»™å‡ºæ–¹æ³•ã€‚å¯¹äº kkk é˜¶å‰ç¼€å’Œï¼Œå†™å‡º (yâˆ’x+kâˆ’1kâˆ’1)\\dbinom{y-x+k-1}{k-1}(kâˆ’1yâˆ’x+kâˆ’1â€‹) çš„å¤šé¡¹å¼å½¢å¼ï¼Œç„¶å yyy è¡¨ç¤ºçš„æ˜¯ä¸‹æ ‡ï¼Œxxx è¡¨ç¤ºçš„æ˜¯å½“å‰ä½ç½®çš„å€¼ã€‚æ—¶é—´å¤æ‚åº¦ O(kqlogâ¡n)O(kq\\log n)O(kqlogn)ã€‚ æƒå€¼æ ‘çŠ¶æ•°ç»„ æ„å»ºåŸåºåˆ—çš„æƒå€¼æ•°åˆ—ï¼Œç„¶ååˆ©ç”¨æ ‘çŠ¶æ•°ç»„ç»Ÿè®¡ã€‚ä¸‹é¢çš„ä»£ç å¯ä»¥å¿«é€Ÿè§£å†³é€†åºå¯¹é—®é¢˜ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; (-(x))) using namespace std; typedef long long i64; inline int read(void) &#123; int x = 0, c = getchar_unlocked(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar_unlocked();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar_unlocked(); return x * f; &#125; int n, m, a[500005], b[500005]; int C[500005]; void update(int x, int k) &#123; while (x &lt;= n) &#123; C[x] += k; x += lowbit(x); &#125; &#125; int query(int x) &#123; i64 res = 0; while (x) &#123; res += C[x]; x -= lowbit(x); &#125; return res; &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) b[i] = a[i] = read(); sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b; i64 ans = 0; for (int i = n; i >= 1; --i) &#123; ans += query(a[i] - 1); update(a[i], 1); &#125; printf(\"%lld\\n\", ans); return 0; &#125; æƒå€¼æ•°ç»„ä¹Ÿå¯ä»¥å®ç°åæ¬¡æ ‘ï¼Œä½†æ˜¯å½“å¼ºåˆ¶åœ¨çº¿æ—¶å°±å¯„æ‰äº†ã€‚ä½†æ˜¯è¿™å¼•å‡ºäº†ä¸€ä¸ªé‡è¦ trickï¼šæ ‘çŠ¶æ•°ç»„å€å¢ã€‚ æ ‘çŠ¶æ•°ç»„äºŒåˆ†ä¸å€å¢ æˆ‘ä»¬å½“ç„¶å¯ä»¥ä½¿ç”¨äºŒåˆ†å¥—æ ‘çŠ¶æ•°ç»„è¾¾åˆ° O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n) çš„å¤æ‚åº¦ï¼Œç„¶è€Œæœ‰æ²¡æœ‰æ›´å¥½çš„æ–¹å¼é€‚é…æ ‘çŠ¶æ•°ç»„è¿™ç§ç»“æ„å‘¢ï¼Ÿæœ‰ï¼å€å¢ï¼ æŸ¥è¯¢ä¸€ä¸ªæƒå€¼æ ‘çŠ¶æ•°ç»„é‡Œçš„ kkk å°å€¼ã€‚ æˆ‘ä»¬ä»äºŒè¿›åˆ¶é«˜ä½åˆ°ä½ä½æšä¸¾ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚ // æƒå€¼æ ‘çŠ¶æ•°ç»„æŸ¥è¯¢ç¬¬ k å° int kth(int k) &#123; int sum = 0, x = 0; for (int i = 17; i >= 0; --i) &#123; // éœ€æ»¡è¶³ sum &lt; k x += 1 &lt;&lt; i; // å°è¯•æ‰©å±• if (x >= n || sum + C[x] >= k) x -= 1 &lt;&lt; i; // x ä¸åœ¨æ ‘çŠ¶æ•°ç»„èŒƒå›´å†…ï¼Œæˆ–æ‰©å±•å¤±è´¥ else sum += C[x]; &#125; return x + 1; &#125; ç®€ä»‹çº¿æ®µæ ‘ â€œçº¿æ®µæ ‘â€åªæ˜¯ Segment Tree çš„ä¸€ç§ç§°æ³•ï¼Œå› ä¸ºçº¿æ®µæ ‘å¯ä»¥ç†è§£ä¸ºæ˜¯ç”±å¾ˆå¤šçº¿æ®µç»„æˆçš„ï¼Œå…¶å®ƒå«æ³•åŒ…æ‹¬åŒºé—´æ ‘ï¼ˆinterval treeï¼‰ã€èŒƒå›´æ ‘ç­‰ç­‰ã€‚ä½†è¿™äº›ç§°æ³•ä¸€èˆ¬ç”¨äºç‰¹æ®Šé¢†åŸŸï¼ˆå¦‚è®¡ç®—å‡ ä½•ï¼‰ï¼Œæœ¬æ–‡å‡ç”¨çº¿æ®µæ ‘æ¥ä»£è¡¨ Segment Treeã€‚ çº¿æ®µæ ‘æ˜¯ä¸€ç§åŸºäºåˆ†æ²»æ€æƒ³çš„äºŒå‰æ ‘ç»“æ„ï¼Œæœ‰å¦‚ä¸‹ç‰¹å¾ï¼š çº¿æ®µæ ‘çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½ä»£è¡¨ä¸€ä¸ªåŒºé—´ã€‚ çº¿æ®µæ ‘å…·æœ‰å”¯ä¸€çš„æ ¹èŠ‚ç‚¹ï¼Œä»£è¡¨ç»Ÿè®¡èŒƒå›´ï¼Œä¸€èˆ¬ä¸º [1,n][1,n][1,n]ã€‚ çº¿æ®µæ ‘çš„æ¯ä¸ªå¶å­èŠ‚ç‚¹é•¿åº¦éƒ½ä¸º 111ï¼Œå½¢å¦‚ [x,x][x,x][x,x]ã€‚ ä¸€èˆ¬æˆ‘ä»¬å®šä¹‰ï¼Œè‹¥ mid=âŒŠ(l+r)Ã·2âŒ‹mid=\\lfloor(l+r)\\div2\\rfloormid=âŒŠ(l+r)Ã·2âŒ‹ï¼Œé‚£ä¹ˆèŠ‚ç‚¹ [l,r][l,r][l,r] çš„å·¦å­èŠ‚ç‚¹æ˜¯ [l,mid][l,mid][l,mid]ï¼Œå³å­èŠ‚ç‚¹æ˜¯ [mid+1,r][mid+1,r][mid+1,r]ã€‚ ä¸€æ£µçº¿æ®µæ ‘ å¯¹äºä¸Šå›¾è¿™æ£µç»´æŠ¤åŒºé—´ [1,4][1,4][1,4] çš„çº¿æ®µæ ‘è€Œè¨€ï¼Œå¯ä»¥å‘ç°ï¼Œä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹æ˜¯å®ƒçš„ç¼–å·ä¹˜ 222ï¼Œå³å­èŠ‚ç‚¹æ˜¯ä¹˜ 222 åŠ  111ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ç‚¹æ–¹ä¾¿åœ°æ¥å­˜å‚¨çº¿æ®µæ ‘ã€‚ ä½†å‡‘å·§çš„æ˜¯ï¼Œè¿™é¢—çº¿æ®µæ ‘æ˜¯æ»¡äºŒå‰æ ‘ï¼Œå…¶å®ƒæƒ…å†µç±»ä¼¼äºè¿™ç§ï¼š å¦ä¸€æ£µçº¿æ®µæ ‘ å…¶å®å»æ‰æœ€åä¸€å±‚è¿™æ ‘ä»æ˜¯æ»¡äºŒå‰æ ‘ï¼Œè¿™ç§æƒ…å†µä¾ç„¶å¯ä»¥ä½¿ç”¨ä¸Šè¿°æ–¹æ³•å­˜æ ‘ã€‚ çº¿æ®µæ ‘çš„å­˜å‚¨ çº¿æ®µæ ‘çš„æ­£å¸¸å†™æ³•æ˜¯å †å¼çº¿æ®µæ ‘ã€‚ å…¶å®å°±æ˜¯åªç”¨ä¸€ä¸ªæ•°ç»„ TTT å­˜å‚¨çº¿æ®µæ ‘ï¼Œç”¨å †çš„ç¼–å·æ¥è¡¨ç¤ºçº¿æ®µæ ‘çš„å·¦å„¿å­å’Œå³å„¿å­ï¼ˆlc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1ï¼‰ï¼Œä¸è¿‡è¿›è¡Œæ“ä½œçš„æ—¶å€™è¦å¤šä¼ ä¸¤ä¸ªæ•°æ® lll å’Œ rrrã€‚ æ³¨æ„ï¼Œçº¿æ®µæ ‘çš„èŠ‚ç‚¹å¿…é¡»å¼€å››å€ç©ºé—´ï¼å¦åˆ™å¦‚æœé‡åˆ°éæ»¡äºŒå‰æ ‘çš„çº¿æ®µæ ‘ï¼ŒäºŒå€ç©ºé—´å°±ä¼šçˆ†ç‚¸ï¼ åœ¨ç½‘ä¸Šä½ èƒ½çœ‹åˆ°è¿™æ ·ä¸€ç§å †å¼çº¿æ®µæ ‘ï¼š struct N &#123; int l, r; int val; &#125; T[4*MAXN]; æ³¨æ„ï¼Œå®ƒæ˜¯è®°å½•äº†å½“å‰èŠ‚ç‚¹ ooo çš„åŒºé—´ [l,r][l,r][l,r]ï¼Œåœ¨ä¼ å‚æ—¶å¯ä»¥çœæ‰ä¸¤ä¸ªå‚æ•°ï¼ˆå¬ä¸æ‡‚ï¼Ÿé‚£å°±ä¸ç®¡ï¼Œå¾€ä¸‹çœ‹å°±è¡Œï¼‰ã€‚ æœ‰æ—¶å€™è¦ç»´æŠ¤çš„ä¿¡æ¯ç‰¹åˆ«å¤æ‚ï¼Œæˆ‘ä»¬ä¼šå°†æ•°ç»„ TTT çš„ç±»å‹æ”¹ä¸ºç»“æ„ä½“ï¼Œä½†è¿˜æ˜¯ä¸ä¼šä½¿ç”¨è®°å½•åŒºé—´çš„æ–¹å¼ã€‚ ä¸€èˆ¬æˆ‘ä»¬ä½¿ç”¨å †å¼çº¿æ®µæ ‘ä¸­çš„æ•°ç»„æ–¹å¼ï¼Œè€Œä¸è®°å½•å·¦å³å„¿å­ï¼ˆä¸è®°æ…¢ä¸äº†å¤šå°‘ï¼‰ã€‚æ¥ä¸‹æ¥è‹¥ä¸æ˜¯ç‰¹æ®Šæƒ…å†µï¼Œæˆ‘ä»¬å‡ä½¿ç”¨è¿™ç§æ–¹å¼ã€‚ çº¿æ®µæ ‘çš„å»ºæ ‘ æ¥ä¸‹æ¥æˆ‘ä»¬è°ˆè°ˆå¦‚ä½•å»ºæ ‘ï¼Œæˆ‘ä»¬å†æ¥çœ‹è¿™æ£µçº¿æ®µæ ‘ï¼š å˜»å˜»ï¼Œè¿˜æ˜¯æˆ‘ æœ€åä¸€å±‚è‹¥å½“ä½œåŸåºåˆ—çš„å€¼ï¼Œå³ [i,i][i,i][i,i] ä¿å­˜ AiA_iAiâ€‹ çš„å€¼ã€‚ç”±äºçº¿æ®µæ ‘æ˜¯äºŒå‰æ ‘ç»“æ„ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ°ä»ä¸‹å¾€ä¸Šä¼ é€’ä¿¡æ¯ã€‚ä»¥åŒºé—´å’Œä¸ºä¾‹ï¼Œä»¤èŠ‚ç‚¹ [l,r][l,r][l,r] è¡¨ç¤º âˆ‘i=lrAi\\sum\\limits_{i=l}^{r}A_ii=lâˆ‘râ€‹Aiâ€‹ï¼Œæ˜¾ç„¶ [l,r]=[l,mid]+[mid+1,r][l,r]=[l,mid]+[mid+1,r][l,r]=[l,mid]+[mid+1,r]ï¼ˆè¿™é‡Œçš„åŒºé—´ä»£è¡¨åŒºé—´æ‰€å¯¹åº”çš„å€¼ï¼‰ã€‚ æ¯”å¦‚åŸåºåˆ—æ˜¯ 1 2 3 4ï¼Œé‚£ä¹ˆå¯¹äºèŠ‚ç‚¹ 111~777ï¼Œå¯æ¨ç®—å‡ºå®ƒä»¬çš„å€¼åˆ†åˆ«ä¸º 10 3 7 1 2 3 4ã€‚ é‚£ä¹ˆå»ºæ ‘çš„ä»£ç å¤§æ¦‚å°±åƒè¿™æ ·ï¼š #define L(x) ((x)&lt;&lt;1) #define R(x) ((x)&lt;&lt;1|1) // å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥ä¸ç”¨å®å®šä¹‰ã€‚ int T[4*N]; inline void maintain(int o) &#123; T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; // ä»ä¸‹å¾€ä¸Šä¼ é€’ä¿¡æ¯ã€‚äº‹å®ä¸Šä½ ä¹Ÿå¯ä»¥å†™åœ¨éœ€è¦è°ƒç”¨ maintain å‡½æ•°çš„å‡½æ•°é‡Œï¼Œä¸è¿‡æœ‰æ—¶ä¼ é€’çš„ä¿¡æ¯è¾ƒä¸ºå¤æ‚ï¼Œè¿˜æ˜¯å»ºè®®å†™ä¸€ä¸ª maintain å‡½æ•°ã€‚ç½‘ä¸Šæœ‰çš„æ•™ç¨‹æŠŠå®ƒå†™ä½œ pushupï¼Œè‡³äºä¸ºä»€ä¹ˆï¼Œæ¥ä¸‹æ¥ä½ äº†è§£åˆ° pushdown å°±çŸ¥é“äº†ã€‚ &#125; void build(int o, int l, int r) &#123; //o ä»£è¡¨å½“å‰ç»´æŠ¤ç»“ç‚¹çš„æ ‡å·ï¼Œl å’Œ r ä»£è¡¨æ‰€å¯¹åº”çš„åŒºé—´ if (l == r) return T[o] = a[l], void(); //å¦‚æœè¿™æ˜¯å¶å­èŠ‚ç‚¹ï¼Œèµ‹å€¼ int mid = l + r >> 1; // è®¡ç®—ä¸­å€¼ build(o &lt;&lt; 1, l, mid); // ä¸ºå·¦åŠæ®µå»ºæ ‘ build(o &lt;&lt; 1 | 1, mid + 1, r); // ä¸ºå³åŠæ®µå»ºæ ‘ maintain(o); // è®¡ç®—å½“å‰ç»“ç‚¹çš„å€¼ &#125; åœ¨ main ç”¨ build(1, 1, n) æ¥è°ƒç”¨ buildã€‚ ç”±äºæ¯ä¸ªèŠ‚ç‚¹åªè®¿é—®äº†ä¸€æ¬¡ï¼Œæ‰€ä»¥å»ºæ ‘çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)\\mathcal{O}(n)O(n)ã€‚ ç‚¹ä¿®æ”¹ä¸åŒºé—´æŸ¥è¯¢ æ¨¡æ¿ã€‚ ç‚¹ä¿®æ”¹ è¿˜æ˜¯ä»¥è¿™æ£µçº¿æ®µæ ‘ä¸ºä¾‹ï¼š æˆ‘åˆæ¥å•¦ æ ¹æ®åˆšæ‰çš„æ•°æ®ï¼Œåˆå§‹åŒ–åå®ƒåº”è¯¥é•¿è¿™æ ·ï¼š åˆå§‹åŒ–åçš„çº¿æ®µæ ‘ æˆ‘ä»¬å…ˆæ¥è¿›è¡Œç‚¹ä¿®æ”¹ï¼Œæ¯”å¦‚è¦ç»™åŸåºåˆ—çš„ç¬¬ 222 ä¸ªå…ƒç´ åŠ ä¸Š 111ï¼Œé‚£ä¹ˆè¿™æ£µçº¿æ®µæ ‘ä¼šæ€ä¹ˆå˜åŒ–å‘¢ï¼Ÿ å¯ä»¥å‘ç°ï¼ŒèŠ‚ç‚¹ 444ã€222ã€111 éƒ½ä¼šåŠ ä¸Š 111ã€‚çº¿æ®µæ ‘å°±å˜æˆäº†è¿™ä¸ªæ ·å­ï¼š ç‚¹ä¿®æ”¹åçš„çº¿æ®µæ ‘ é‚£ä»£ç æ€ä¹ˆå®ç°å‘¢ï¼Ÿä¸€èˆ¬æ¥è®²ï¼Œæ ¹èŠ‚ç‚¹ 111 æ€»æ˜¯çº¿æ®µæ ‘æ‰§è¡Œçš„å…¥å£ï¼Œä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œé€’å½’æ‰¾åˆ°éœ€è¦ä¿®æ”¹çš„å¶å­èŠ‚ç‚¹ï¼Œè¿™é‡Œä»£ç å¦‚ä¸‹ï¼š void update(int o, int l, int r, int x, int k) &#123; //ç»™åŸåºåˆ—ç¬¬ x ä¸ªå…ƒç´ åŠ ä¸Š kã€‚ if (l == r) return T[o] += k, void(); // è¿™æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥åŠ  int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); // å¶å­èŠ‚ç‚¹åœ¨ [l,mid] å¤„ã€‚ else update(o &lt;&lt; 1 | 1, mid+1, r, x, k); // å¶å­èŠ‚ç‚¹åœ¨ [mid+1,r] å¤„ã€‚ maintain(o); //é‡æ–°è®¡ç®—è¿™ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚ &#125; ç”±äºçº¿æ®µæ ‘çš„å±‚æ•°åœ¨ logâ¡\\loglog çº§åˆ«ï¼Œæ‰€ä»¥ç‚¹ä¿®æ”¹çš„æ—¶é—´å¤æ‚åº¦ä¸º O(logâ¡n)\\mathcal{O}(\\log n)O(logn)ã€‚ åŒºé—´æŸ¥è¯¢ æŸ¥è¯¢åŒºé—´ [l,r][l,r][l,r] çš„å’Œï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œé€’å½’æ‰§è¡Œä¸‹åˆ—è¿‡ç¨‹ï¼š è‹¥å½“å‰åŒºé—´ [l,r][l,r][l,r] å®Œå…¨è¦†ç›–äº†éœ€è¦æ±‚è§£çš„èŒƒå›´ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›ç­”æ¡ˆã€‚ è‹¥å½“å‰åŒºé—´ä¸å·¦å­èŠ‚ç‚¹æœ‰é‡å ï¼Œè®¿é—®å·¦å­èŠ‚ç‚¹ [l,mid][l,mid][l,mid]ã€‚ è‹¥å½“å‰åŒºé—´ä¸å³å­èŠ‚ç‚¹æœ‰é‡å ï¼Œè®¿é—®å³å­èŠ‚ç‚¹ [mid+1,r][mid+1,r][mid+1,r]ï¼ˆæ³¨æ„ä¸æ˜¯è®¿é—®å·¦å­èŠ‚ç‚¹åå°±ä¸ç”¨è®¿é—®å³å­èŠ‚ç‚¹äº†ï¼‰ã€‚ é‚£æ€ä¹ˆè§£é‡Šè¿™ä¸ªä¸œè¥¿å‘¢ï¼Ÿè¿˜æ˜¯çœ‹é‚£æ£µçº¿æ®µæ ‘ ï¼ˆå®ƒçš„å‡ºé•œç‡ä¸ºä»€ä¹ˆè¿™ä¹ˆé«˜ï¼‰ï¼š å—¯ï¼Œåˆæ˜¯æˆ‘ æ¯”å¦‚ç°åœ¨æˆ‘ä»¬è¦æŸ¥ [1,3][1,3][1,3]ã€‚ [1,3][1,3][1,3] ä¸ [1,2][1,2][1,2] å’Œ [3,4][3,4][3,4] éƒ½æœ‰é‡å ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦åˆ†åˆ«è®¿é—®ã€‚ [1,2][1,2][1,2] å®Œå…¨è¦†ç›–ï¼Œç›´æ¥è¿”å›ã€‚ [3,4][3,4][3,4] å·¦å­èŠ‚ç‚¹æœ‰è¦†ç›–ï¼Œå³å­èŠ‚ç‚¹æ²¡æœ‰ï¼Œè®¿é—®å·¦å­èŠ‚ç‚¹ã€‚ [3,3][3,3][3,3] ç›´æ¥è¿”å›ã€‚ æ‰€ä»¥ç­”æ¡ˆæ˜¯ 4+3=74+3=74+3=7ã€‚ é‚£ä¹ˆä»£ç å°±é•¿è¿™æ ·ï¼š int query(int o, int l, int r, int ql, int qr) &#123; //[ql,qr] æ˜¯è¦æŸ¥çš„åŒºé—´ if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; //å®Œå…¨åŒ…å« int mid = l + r >> 1, res = 0; // æ¥ä¸‹æ¥ï¼Œåªè¦ä½ åœ¨ï¼ˆå“ªæ€•åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œæˆ‘å°±æŸ¥ if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); //å·¦å­èŠ‚ç‚¹ if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr); //å³å­èŠ‚ç‚¹ return res; &#125; åŒ updateï¼Œquery çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯ O(logâ¡n)\\mathcal{O}(\\log n)O(logn)ã€‚ ä»¥ä¸‹ä»£ç å°±å¯ä»¥é€šè¿‡åˆšæ‰çš„æ¨¡æ¿äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; int n, m; int T[2000005]; int a[500005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid+1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] += k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid+1, r, x, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1, res = 0; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr); return res; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); build(1, 1, n); while (m--) &#123; int op = read(), x = read(), y = read(); if (op == 1) update(1, 1, n, x, y); else printf(\"%d\\n\", query(1, 1, n, x, y)); &#125; return 0; &#125; Problemset åœ¨è®¨è®ºåŒºé—´ä¿®æ”¹ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹å‡ é“çº¿æ®µæ ‘çš„é¢˜ç›®ã€‚ [Luogu P4513] å°ç™½é€›å…¬å›­ Portal. æœ€å¤§å­æ®µå’Œå¯ä»¥ä½¿ç”¨ O(nlogâ¡n)\\mathcal{O}(n \\log n)O(nlogn) çš„åˆ†æ²»æ³•è¿›è¡Œæ±‚è§£ï¼Œå› ä¸ºè¿™ä¸ªå­æ®µè¦ä¹ˆåœ¨åºåˆ—çš„å·¦åŠæ®µï¼Œè¦ä¹ˆåœ¨å³åŠæ®µï¼Œè¦ä¹ˆè·¨è¶Šä¸­ç‚¹ã€‚åŠ ä¸Šå¤šç»„è¯¢é—®ï¼Œè¿™å°±æ˜¯çº¿æ®µæ ‘å˜›ï¼ æœ€å¤§å’Œçš„å­æ®µåœ¨ä¸­ç‚¹ä¸¤ç«¯å¥½è¯´ï¼Œç°åœ¨å°±æ¥çœ‹ä¸€ä¸‹è·¨è¶Šä¸­ç‚¹çš„æƒ…å†µã€‚ çº¿æ®µæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤ä¸‰ä¸ªå€¼ï¼šæœ€å¤§å­æ®µå’Œã€æœ€å¤§å‰ç¼€å’Œã€æœ€å¤§åç¼€å’Œæ‰€å¯¹åº”çš„åŒºé—´ï¼ˆæ­¤åŒºé—´æ˜¯çº¿æ®µæ ‘çš„èŠ‚ç‚¹æ‰€å¯¹åº”çš„åŒºé—´ï¼‰ã€‚é‚£ä¹ˆæœ€å¤§å­æ®µå’Œè·¨è¶Šä¸­ç‚¹æ—¶ï¼Œå°±æ˜¯å‰åŠåŒºé—´çš„æœ€å¤§åç¼€å’Œï¼ŒåŠ ä¸ŠååŠåŒºé—´çš„æœ€å¤§å‰ç¼€å’Œã€‚ ç»´æŠ¤å››ä¸ªä¿¡æ¯ï¼šåŒºé—´å’Œ sumsumsumï¼Œä»…é å·¦ç«¯çš„æœ€å¤§è¿ç»­å’Œ lmaxlmaxlmaxï¼Œé å³æ®µçš„ rmaxrmaxrmaxï¼Œä»¥åŠåŒºé—´æœ€å¤§å­æ®µå’Œ datdatdatã€‚ åœ¨ query çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦çœ‹å®ƒæ˜¯å¦å®Œå…¨åœ¨å·¦åŒºé—´è¿˜æ˜¯å®Œå…¨åœ¨å³åŒºé—´ï¼Œéƒ½ä¸æ˜¯å°±æ˜¯è·¨åŒºé—´ï¼Œéœ€è¦æ ¹æ®å·¦å³èŠ‚ç‚¹çš„æŸ¥è¯¢ç»“æœè®¡ç®—å½“å‰ç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, m; int a[500005]; struct Node &#123; int sum, lmax, rmax, dat; Node (int sum = 0, int lmax = 0, int rmax = 0, int dat = 0) : sum(sum), lmax(lmax), rmax(rmax), dat(dat) &#123;&#125; &#125;T[2000005]; inline void maintain(int o) &#123; int ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; T[o].sum = T[ls].sum + T[rs].sum; T[o].lmax = max(T[ls].lmax, T[ls].sum + T[rs].lmax); T[o].rmax = max(T[rs].rmax, T[rs].sum + T[ls].rmax); T[o].dat = max(&#123;T[ls].dat, T[rs].dat, T[ls].rmax + T[rs].lmax&#125;); &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].sum = T[o].lmax = T[o].rmax = T[o].dat = a[l]; return; &#125; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; build(ls, l, mid); build(rs, mid + 1, r); maintain(o); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) &#123; T[o].sum = T[o].lmax = T[o].rmax = T[o].dat = k; return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); maintain(o); &#125; Node query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return query(ls, l, mid, ql, qr); if (ql > mid) return query(rs, mid + 1, r, ql, qr); Node x = query(ls, l, mid, ql, qr), y = query(rs, mid + 1, r, ql, qr), res; res.sum = x.sum + y.sum; res.lmax = max(x.lmax, x.sum + y.lmax); res.rmax = max(y.rmax, y.sum + x.rmax); res.dat = max(&#123;x.dat, y.dat, x.rmax + y.lmax&#125;); return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); while (m--) &#123; int k, x, y; scanf(\"%d%d%d\", &amp;k, &amp;x, &amp;y); if (k == 1) &#123; if (x > y) swap(x, y); printf(\"%d\\n\", query(1, 1, n, x, y).dat); &#125; else update(1, 1, n, x, y); &#125; return 0; &#125; [UVa 1400] â€œRay, Pass me the dishes!â€ Portal. ç»™å®šä¸€ä¸ªåºåˆ—å’Œå¤šç»„è¯¢é—® (l,r)(l,r)(l,r)ï¼ŒæŸ¥è¯¢åŒºé—´ [l,r][l,r][l,r] çš„æœ€å¤§å­æ®µå’Œï¼Œå¹¶ç»™å‡ºç­”æ¡ˆå¯¹åº”çš„å­—å…¸åºæœ€å°çš„å­åŒºé—´ã€‚ è¿™å›è¦æ±‚è¾“å‡ºç­”æ¡ˆçš„åŒºé—´äº†ï¼ˆï¼‰ï¼Œä½†æ˜¯ä¹Ÿæ²¡æœ‰ä»€ä¹ˆå¥½æ€•çš„ã€‚æˆ‘ä»¬åªéœ€è¦è®°å½•ä¸€ä¸ª max_sub æ¥è®°å½•åŒºé—´ã€‚ é¦–å…ˆæ˜¯å»ºæ ‘ï¼Œåƒè¿™æ ·ï¼š void build(int o, int l, int r) &#123; if (l == r) &#123; maxsub[o] = make_pair(l, r); maxpre[o] = l; maxsuf[o] = r; return; &#125; // ä»¥ä¸Šæ˜¾ç„¶ int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; build(lc, l, mid); build(rc, mid+1, r); // maintain &#125; å¦‚ä½•ç»´æŠ¤è¿™ä¸€èŠ‚ç‚¹å‘¢ï¼Ÿæ ¹æ®åˆšæ‰æ‰€è¯´ï¼Œå¯¹åº”ä¸‰ç§æƒ…å†µï¼š maxsub[o] = better(maxsub[lc], maxsub[rc]); // å·¦å³åŒºé—´ maxsub[o] = better(maxsub[o], make_pair(maxsuf[lc], maxpre[rc])); // è·¨è¶Šä¸­ç‚¹ å…¶ä¸­ better å‡½æ•°ç”¨äºæ¯”è¾ƒå“ªä¸ªå­åŒºé—´æ›´å¥½ã€‚ maxsuf å’Œ maxpre æ€ä¹ˆç»´æŠ¤å‘¢ï¼Ÿä»¥ maxpre ä¸ºä¾‹å­ï¼Œåƒè¿™æ ·ï¼š LL v1 = sum(l, maxpre[lc]); LL v2 = sum(l, maxpre[rc]); if (v1 == v2) maxpre[o] = min(maxpre[lc], maxpre[rc]); // å³ç«¯ç‚¹è‚¯å®šæ˜¯è¶Šå°è¶Šå¥½çš„ else maxpre[o] = v1 > v2 ? maxpre[lc] : maxpre[rc]; å…¶ä¸­ sum æŒ‡åŸåºåˆ—çš„åŒºé—´å’Œï¼Œå®¹æ˜“ç”¨å‰ç¼€å’Œæ±‚è§£ã€‚ æ¥ä¸‹æ¥æ˜¯æŸ¥è¯¢ï¼Œå¤§æ¦‚åƒè¿™æ ·ï¼š Interval query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return maxsub[o]; // åœ¨åŒºé—´èŒƒå›´å†… int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return query(lc, l, mid, ql, qr); // å®Œå…¨åœ¨å·¦åŠç«¯ if (ql > mid) return query(rc, mid+1, r, ql, qr); // å®Œå…¨åœ¨å³åŠæ®µ Interval ans = better(query(lc, l, mid, ql, qr), query(rc, mid+1, r, ql, qr)); // ä¸è·¨è¶Šä¸­ç‚¹ return better(ans, make_pair(calc_suf(lc, l, mid, ql).L, calc_pre(rc, mid+1, r, qr).R)); // è·¨è¶Šä¸­ç‚¹ &#125; æ³¨æ„æ±‚è§£å‰ç¼€å’Œåç¼€çš„å‡½æ•°ï¼Œè¿™é‡Œçš„å†™æ³•å®Œå…¨ç¬¦åˆåˆšæ‰çš„å®šä¹‰ï¼Œè¿™é‡Œç»™å‡º calc_pre çš„å®ç°ï¼Œcalc_suf çš„å®ç°å¤§è‡´ç›¸åŒã€‚ Interval calc_pre(int o, int l, int r, int qr) &#123; if (maxpre[o] &lt;= qr) return make_pair(l, maxpre[o]); // å®Œå…¨åœ¨æŸ¥è¯¢èŒƒå›´å†… int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return calc_pre(lc, l, mid, qr); // åœ¨å·¦åŠç«¯ // æ³¨æ„å®ƒè¦ä¹ˆå®Œå…¨åœ¨å·¦åŠæ®µè¦ä¹ˆè·¨è¶Šä¸­ç‚¹ï¼Œä¸å¯èƒ½å…¨åœ¨å³åŠæ®µ Interval ans = make_pair(l, calc_pre(rc, mid+1, r, qr).R); // è·¨è¶Šä¸­ç‚¹ return better(ans, make_pair(l, maxpre[lc])); // ä¸å®Œå…¨åœ¨å·¦åŠæ®µæ¯”è¾ƒ &#125; ä¸‹é¢æ˜¯å®Œæ•´ä»£ç ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define Interval pair&lt;int, int> #define L first #define R second #define LL long long using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; int n, m; int a[500005]; Interval maxsub[2000005]; LL prefix_sum[500005]; int maxpre[2000005], maxsuf[2000005]; inline LL sum(int l, int r) &#123;return prefix_sum[r] - prefix_sum[l-1];&#125; inline LL sum(Interval x) &#123;return sum(x.L, x.R);&#125; inline Interval better(Interval a, Interval b) &#123; if (sum(a) != sum(b)) return sum(a) > sum(b) ? a : b; return a &lt; b ? a : b; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; maxsub[o] = make_pair(l, r); maxpre[o] = l; maxsuf[o] = r; return; &#125; int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; build(lc, l, mid); build(rc, mid+1, r); LL v1 = sum(l, maxpre[lc]); LL v2 = sum(l, maxpre[rc]); if (v1 == v2) maxpre[o] = min(maxpre[lc], maxpre[rc]); else maxpre[o] = v1 > v2 ? maxpre[lc] : maxpre[rc]; v1 = sum(maxsuf[lc], r); v2 = sum(maxsuf[rc], r); if (v1 == v2) maxsuf[o] = min(maxsuf[lc], maxsuf[rc]); else maxsuf[o] = v1 > v2 ? maxsuf[lc] : maxsuf[rc]; maxsub[o] = better(maxsub[lc], maxsub[rc]); maxsub[o] = better(maxsub[o], make_pair(maxsuf[lc], maxpre[rc])); &#125; Interval calc_pre(int o, int l, int r, int qr) &#123; if (maxpre[o] &lt;= qr) return make_pair(l, maxpre[o]); int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return calc_pre(lc, l, mid, qr); Interval ans = make_pair(l, calc_pre(rc, mid+1, r, qr).R); return better(ans, make_pair(l, maxpre[lc])); &#125; Interval calc_suf(int o, int l, int r, int ql) &#123; if (maxsuf[o] >= ql) return make_pair(maxsuf[o], r); int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (ql > mid) return calc_suf(rc, mid+1, r, ql); Interval ans = make_pair(calc_suf(lc, l, mid, ql).L, r); return better(ans, make_pair(maxsuf[rc], r)); &#125; Interval query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return maxsub[o]; int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return query(lc, l, mid, ql, qr); if (ql > mid) return query(rc, mid+1, r, ql, qr); Interval ans = better(query(lc, l, mid, ql, qr), query(rc, mid+1, r, ql, qr)); return better(ans, make_pair(calc_suf(lc, l, mid, ql).L, calc_pre(rc, mid+1, r, qr).R)); &#125; int main(void) &#123; int kase = 0; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2) &#123; printf(\"Case %d:\\n\", ++kase); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); prefix_sum[i] = prefix_sum[i-1] + a[i]; &#125; build(1, 1, n); while (m--) &#123; int l = read(), r = read(); Interval ans = query(1, 1, n, l, r); printf(\"%d %d\\n\", ans.L, ans.R); &#125; &#125; return 0; &#125; æ ¹æ®ä»¥ä¸Šå¯ä»¥å‘ç°ï¼Œçº¿æ®µæ ‘å¯ä»¥ç»´æŠ¤çš„æ˜¯å®¹æ˜“æŒ‰ç…§åŒºé—´è¿›è¡Œåˆ’åˆ†å’Œåˆå¹¶ï¼Œè¿™ä¸€ç‚¹åˆç§°æ»¡è¶³åŒºé—´å¯åŠ æ€§ã€‚å…³äºè¿™ä¸€ç‚¹ï¼Œæ¥ä¸‹æ¥è¿˜ä¼šè¯¦ç»†å™è¿°ã€‚ åŒºé—´ GCD Portalã€‚ ç»™å®šé•¿åº¦ä¸º n(nâ©½5Ã—105)n(n\\leqslant 5\\times 10^5)n(nâ©½5Ã—105) çš„åºåˆ— AAAï¼Œm(mâ©½105)m(m\\leqslant 10^5)m(mâ©½105) æ¬¡æ“ä½œï¼šC l r dï¼Œè¡¨ç¤ºåŒºé—´åŠ  dddã€‚Q l rï¼Œè¡¨ç¤ºæ±‚ gcdâ¡(Al,Al+1,â‹¯ ,Arâˆ’1,Ar)\\gcd(A_l,A_{l+1},\\cdots,A_{r-1},A_r)gcd(Alâ€‹,Al+1â€‹,â‹¯,Arâˆ’1â€‹,Arâ€‹)ã€‚ è¿™ä¸ªé—®é¢˜çœ‹ä¸Šå»å¾ˆæ£˜æ‰‹ï¼Œæ€ä¹ˆåŠå‘¢ï¼Ÿå¼ºçƒˆå»ºè®®è¯»è€…åœä¸‹æ¥è‡ªè¡Œæ€è€ƒâ€”â€”æƒ³ä¸€æƒ³ gcdâ¡\\gcdgcd çš„æ€§è´¨ï¼Œåˆ©ç”¨åœ¨æ ‘çŠ¶æ•°ç»„å­¦è¿‡çš„å†…å®¹å°†åŸé—®é¢˜è½¬æ¢ä¸ºå¯ä»¥ç”¨ç‚¹ä¿®æ”¹å®ç°çš„ã€‚è¿˜æœ‰ä¸€ç‚¹å¯ä»¥å‘ç°ï¼šgcdâ¡\\gcdgcd æ»¡è¶³åŒºé—´å¯åŠ æ€§ï¼Œå¯ä»¥é€šè¿‡å°åŒºé—´çš„ gcdâ¡\\gcdgcd æ±‚å‡ºå¤§åŒºé—´çš„ gcdâ¡\\gcdgcdã€‚ è¯·è¯»è€…å…ˆè‡ªè¡Œæ’•çƒ¤ï¼Œç„¶åå†çœ‹è§£ç­”ã€‚ æŸ¥çœ‹è§£ç­” æ ¹æ® gcdâ¡(x,y)=gcdâ¡(x,yâˆ’x)\\gcd(x,y)=\\gcd(x,y-x)gcd(x,y)=gcd(x,yâˆ’x)ï¼Œè€Œä¸”è¿˜æœ‰ gcdâ¡(x,y,z)=gcdâ¡(x,yâˆ’x,zâˆ’y)\\gcd(x,y,z)=\\gcd(x,y-x,z-y)gcd(x,y,z)=gcd(x,yâˆ’x,zâˆ’y)ï¼Œè¿™æ˜¯ä»€ä¹ˆï¼Ÿå·®åˆ†åºåˆ—ï¼é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç”¨æ”¯æŒå•ç‚¹ä¿®æ”¹çš„çº¿æ®µæ ‘æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè¿™æ ·çš„è¯ï¼ŒQ l r ç›¸å½“äºæ±‚ gcd(a[l], query(1, 1, n, l + 1, r)ã€‚AAA æ•°ç»„çš„å€¼å¯ä»¥ç”¨ä¸€ä¸ªæ”¯æŒâ€œåŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢â€çš„æ ‘çŠ¶æ•°ç»„å®ç°ã€‚çº¿æ®µæ ‘ä¿®æ”¹æ—¶ï¼Œéœ€è¦è¿›è¡Œä¸¤æ¬¡å•ç‚¹ä¿®æ”¹ã€‚ä½ å¯èƒ½ä¼šé—®ä¸€ä¸ªé—®é¢˜ï¼Œè´Ÿæ•°æ€ä¹ˆåŠï¼Ÿå®é™…ä¸Š gcdâ¡\\gcdgcd çš„æ€§è´¨å¯¹è´Ÿæ•°åŒæ ·æˆç«‹ï¼Œä½†æ˜¯ä½ çš„è¾“å‡ºæ€»ä¸èƒ½æ˜¯è´Ÿçš„å§ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨è¾“å‡ºæ—¶ abs ä¸€ä¸‹å°±å¥½ã€‚æ³¨æ„ç”±äºæœ‰è´Ÿæ•°ï¼Œæ‰€ä»¥ gcd çš„ä»£ç å®ç°è¦æ›´æ”¹ï¼ˆå› ä¸ºå–æ¨¡è¿ç®—æœ‰å‘ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; inline i64 read(void) &#123; i64 x = 0; int c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; i64 gcd(i64 a, i64 b) &#123; if (b == 0) return a; return gcd(b, (a % b + b) % b); &#125; int n, m; i64 a[500010], b[500010]; class FenwickTree &#123; private: i64 C[500010]; #define lowbit(x) (x &amp; -x) public: inline void add(int x, i64 k) &#123; while (x &lt;= n) &#123; C[x] += k; x += lowbit(x); &#125; &#125; inline i64 sum(int x) &#123; i64 res = 0; while (x) &#123; res += C[x]; x -= lowbit(x); &#125; return res; &#125; &#125;F; class SegmentTree &#123; private: i64 T[2000050]; inline void maintain(int o) &#123; T[o] = gcd(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; public: void build(int o, int l, int r) &#123; if (l == r) return T[o] = b[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; void update(int o, int l, int r, int x, i64 k) &#123; if (l == r) &#123; T[o] += k; return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); maintain(o); &#125; i64 query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1; i64 res = 0; if (ql &lt;= mid) res = gcd(res, query(o &lt;&lt; 1, l, mid, ql, qr)); if (mid &lt; qr) res = gcd(res, query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr)); return res; &#125; &#125; S; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); b[i] = a[i] - a[i-1]; &#125; S.build(1, 1, n); // æ ‘çŠ¶æ•°ç»„ä¸å»ºæ ‘ï¼Œåˆ°æ—¶å€™ç›´æ¥åŠ ä¸Š a[l] å³å¯ while (m--) &#123; char c; cin >> c; int l = read(), r = read(); if (c == 'C') &#123; i64 k = read(); F.add(l, k); S.update(1, 1, n, l, k); if (r &lt; n) &#123; F.add(r + 1, -k); S.update(1, 1, n, r + 1, -k); &#125; &#125; else printf(\"%lld\\n\", abs(gcd(a[l] + F.sum(l), l &lt; r ? S.query(1, 1, n, l + 1, r) : 0))); &#125; return 0; &#125; åŒºé—´ä¿®æ”¹ä¸å»¶è¿Ÿæ ‡è®° æ ¹æ®åˆšæ‰çš„å­¦ä¹ ï¼Œå¯ä»¥å‘ç°çº¿æ®µæ ‘æ˜¯ä¸ªå¾ˆå‰å®³çš„æ•°æ®ç»“æ„ï¼Œä½†å®ƒçš„å¨åŠ›å¯ä¸æ­¢å¦‚æ­¤ï¼Œæ¥çœ‹ï¼Œè¿˜æœ‰æ›´å‰å®³çš„ï¼š å»¶è¿Ÿæ ‡è®°çš„ä»‹ç» [Luogu 3372]ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1 è¿›è¡Œä¸‹é¢ä¸¤ç§æ“ä½œï¼šå°†åŒºé—´ [l,r][l,r][l,r] çš„æ¯ä¸€ä¸ªæ•°åŠ ä¸Š xxxï¼›æ±‚åŒºé—´ [l,r][l,r][l,r] çš„å’Œã€‚ è¿™å›å¯ä¸ä¸€æ ·äº†ï¼Œç‚¹ä¿®æ”¹åªä¼šå½±å“æ ‘ä¸­çš„ logâ¡n\\log nlogn ä¸ªèŠ‚ç‚¹ï¼Œè€ŒåŒºé—´ä¿®æ”¹æœ€åæƒ…å†µä¸‹ä¼šå½±å“åŒºé—´ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œè¿™å¯æ€ä¹ˆåŠï¼Ÿæˆ‘ä»¬è¿™é‡Œè¦å¼•å…¥ä¸€ä¸ªå«åšâ€œå»¶è¿Ÿæ ‡è®°â€çš„ä¸œè¥¿ï¼ˆæˆ–è€…å«å®ƒæ‡’æ ‡è®°ï¼Œå³ lazy tagï¼‰ã€‚ è¯•æƒ³ï¼Œå¦‚æœæˆ‘ä»¬åœ¨ä¸€æ¬¡ä¿®æ”¹æ“ä½œä¸­å‘ç°èŠ‚ç‚¹ ooo ä»£è¡¨çš„åŒºé—´ [ol,or][o_l,o_r][olâ€‹,orâ€‹] ä¸­è¦ä¿®æ”¹çš„åŒºé—´ [l,r][l,r][l,r] è¢«å®Œå…¨è¦†ç›–ï¼Œé‚£ä¹ˆæ›´æ–°ç‚¹ ooo çš„å­æ ‘å°±æ˜¯å¾’åŠ³çš„ã€‚å¯ä»¥ç»™èŠ‚ç‚¹ ooo åšä¸€ä¸ªæ ‡è®°ï¼Œçœæ‰æ¥ä¸‹æ¥çš„æ“ä½œã€‚å°±æ˜¯æ‰“å®Œæ ‡è®°åæˆ‘ä»¬å¯ä»¥ç«‹å³è¿”å›ï¼Œæ­¤æ ‡è®°ä»£è¡¨â€œè¯¥èŠ‚ç‚¹æ›¾ç»è¢«ä¿®æ”¹è¿‡ï¼Œä½†å…¶å­èŠ‚ç‚¹å°šæœªæ›´æ–°â€ã€‚ å¦‚æœåœ¨åç»­çš„æŒ‡ä»¤ä¸­ï¼Œéœ€è¦ä»èŠ‚ç‚¹ ooo å‘ä¸‹é€’å½’ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¸‹ä¼  ooo çš„æ ‡è®°ï¼Œå¹¶æ¸…ç©º ooo çš„æ ‡è®°ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸€ä¸‹è¿™é“é¢˜è¯¥æ€ä¹ˆå†™ã€‚é¦–å…ˆå»ºæ ‘å’Œç»´æŠ¤å½“å‰èŠ‚ç‚¹çš„è¿‡ç¨‹æ²¡æœ‰å˜åŒ–ï¼Œè€Œå¯¹äºä¿®æ”¹æ“ä½œéœ€è¦è¿™æ ·å†™ï¼š void update(int o, int l, int r, int x, int y, int k) //åŒºé—´ [x,y] åŠ ä¸Š k &#123; if (x &lt;= l &amp;&amp; r &lt;= y) //åœ¨åŒºé—´èŒƒå›´å†… &#123; T[o] += (LL)k * (r-l+1); tag[o] += k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid+1 &lt;= y) update(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; è¿™é‡Œæœ‰å‡ ç‚¹éœ€è¦æ³¨æ„ï¼Œé¦–å…ˆæ˜¯ TTT æ•°ç»„çš„ä¿®æ”¹ï¼Œåˆ«å¿˜äº†è¿™æ˜¯åŒºé—´ä¿®æ”¹ï¼Œè¦åŠ ä¸Šçš„æ•°éœ€è¦ä¹˜ä¸ŠåŒºé—´çš„é•¿åº¦ã€‚ ç„¶åæ˜¯ pushdown å‡½æ•°ï¼ˆæœ‰çš„ç‰ˆæœ¬å†™æˆ spreadï¼‰ï¼Œéœ€è¦è¿™æ ·ï¼š inline void pushdown(int o, int l, int r) &#123; if (tag[o]) //æ ‡è®°ä¸æ˜¯ 0 æ‰æœ‰å¿…è¦ä¸‹ä¼ ï¼Œä½†éè¦ä¼ ä¹Ÿéä¸å¯ï¼Œæ…¢ä¸äº†å¤šå°‘ &#123; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; // ä¸‹ä¼ æ ‡è®° int mid = l + r >> 1; // æ³¨æ„åŒºé—´çš„é•¿åº¦ T[o &lt;&lt; 1] += (LL)tag[o] * (mid-l+1); T[o &lt;&lt; 1 | 1] += (LL)tag[o] * (r-mid); tag[o] = 0; // æ¸…é™¤çˆ¶äº²èŠ‚ç‚¹çš„æ ‡è®°ï¼ˆå› ä¸ºä¸‹ä¼ äº†ï¼‰ &#125; &#125; éœ€è¦åˆ†åˆ«ä¿®æ”¹å·¦å³å„¿å­æ ‡è®°çš„å€¼å’Œæ•°å€¼ã€‚ æœ€åæ˜¯é€’å½’çš„è¿‡ç¨‹ï¼Œç”±äºæ˜¯åŒºé—´ä¿®æ”¹ï¼Œæ‰€ä»¥å·¦å³éƒ½éœ€è¦åˆ¤æ–­ï¼ˆmid + 1 &lt;= y æœ‰çš„ç‰ˆæœ¬ä¼šå†™æˆ mid &lt; y ï¼‰ã€‚ æ³¨æ„æŸ¥è¯¢çš„æ—¶å€™ä¹Ÿéœ€è¦ä¸‹ä¼ æ ‡è®°ï¼ˆå¦åˆ™ä½ æ€ä¹ˆæŸ¥ï¼Œå­èŠ‚ç‚¹æ²¡æ³•è®¡ç®—äº†ï¼‰ã€‚ æ³¨æ„åˆ°äº†å§ï¼Ÿpushdown çš„åä¹‰è¯æ˜¯ pushupï¼Œæ‰€ä»¥æœ‰äººæŠŠ maintain å†™æˆ pushupã€‚ æƒ³ä¸€æƒ³ï¼Œä¸ºä»€ä¹ˆä»¥ä¸Šæ“ä½œéƒ½å¯ä»¥ä¿è¯æœ€åçš„ç»“æœæ—¶é—´å¤æ‚åº¦æ˜¯æ­£ç¡®çš„å‘¢ï¼ˆå»ºè®®æ‰‹ç©ï¼‰ï¼Ÿ æŸ¥è¯¢æ“ä½œé“ç†åŸºæœ¬ç›¸åŒï¼Œç›¸ä¿¡å¤§å®¶å¯ä»¥è‡ªå·±å†™å‡ºæ¥ã€‚ é‚£ä¹ˆå¯¹äºè¿™é“é¢˜è€Œè¨€ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define LL long long using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c))&#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; int n, m; LL a[100005]; LL T[400005], tag[400005]; inline void maintain(int o) &#123; T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; inline void pushdown(int o, int l, int r) &#123; if (tag[o]) &#123; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; int mid = l + r >> 1; T[o &lt;&lt; 1] += (LL)tag[o] * (mid-l+1); T[o &lt;&lt; 1 | 1] += (LL)tag[o] * (r-mid); tag[o] = 0; &#125; &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid+1, r); maintain(o); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; T[o] += (LL)k * (r-l+1); tag[o] += k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid+1 &lt;= y) update(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; LL query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1; LL res = 0; pushdown(o, l, r); if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr); return res; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); build(1, 1, n); while (m--) &#123; int op = read(); if (op == 1) &#123; int x = read(), y = read(), k = read(); update(1, 1, n, x, y, k); &#125; else &#123; int x = read(), y = read(); printf(\"%lld\\n\", query(1, 1, n, x, y)); &#125; &#125; return 0; &#125; æ˜¯ä¸æ˜¯æœ‰ç‚¹æ„æ€äº†ï¼Ÿè¿˜æœ‰æ›´å¤æ‚çš„ã€‚ å¤šç»„å»¶è¿Ÿæ ‡è®° ä½ ä»¥ä¸ºå»¶è¿Ÿæ ‡è®°åªèƒ½ç”±æœ‰ä¸€ç»„ï¼Ÿåªè¦ä½ æ„¿æ„ï¼Œéƒ½å¯ä»¥æ•´å‡ºä¸€ç™¾ç»„ï¼ˆä¸è¿‡å¥½åƒä¹Ÿæ²¡æœ‰ä¸€ç™¾ç»„ï¼‰ï¼ [UVa 11992] Fast Matrix Operations Portalã€‚ æœ‰ä¸€ä¸ª rrr è¡Œ ccc åˆ—çš„å…¨é›¶çŸ©é˜µï¼ŒçŸ©é˜µä¸è¶…è¿‡ 202020 è¡Œï¼Œæ”¯æŒå­çŸ©é˜µåŠ ï¼Œå­çŸ©é˜µèµ‹å€¼å’ŒæŸ¥è¯¢å­çŸ©é˜µå’Œã€æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚ ç”±äºçŸ©é˜µæœ€å¤šæœ‰ 202020 è¡Œï¼Œæ‰€ä»¥å¯ä»¥æ¯è¡Œé€ ä¸€æ£µçº¿æ®µæ ‘ï¼Œé‚£ä¹ˆæœ¬ä½“è½¬åŒ–ä¸ºä¸€ç»´é—®é¢˜ã€‚ ç°åœ¨ç”±äºæœ‰ä¸¤ç§æ“ä½œï¼Œé‚£ä¹ˆå°±æœ‰ä¸¤ä¸ªæ ‡è®°ï¼Œä½†ä¸¤ä¸ªæ ‡è®°æ€»å¾—æœ‰ä¸ªé¡ºåºå§ï¼å¦åˆ™ä¸ä¹±å¥—äº†ï¼ ç”±äºå…ˆåŠ åèµ‹å€¼æ˜¯æ²¡æœ‰ä»»ä½•æ„ä¹‰çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è§„å®šå…ˆèµ‹å€¼ååŠ ã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼Œå¯¹äºè¿™ç§è¦ç»´æŠ¤ä¿¡æ¯è¾ƒå¤šçš„çº¿æ®µæ ‘ï¼Œå»ºè®®ä½¿ç”¨ç»“æ„ä½“ï¼Œå¦åˆ™ä»£ç ä¼šæ˜¾å¾—å¾ˆä¹±ã€‚ ä¸è¿‡è¿™é‡Œç¬”è€…æœ‰ç‚¹æ‡’ï¼ŒæœªæŠŠè‡ªå·±çš„ä»£ç æ”¹æˆå…¨ç”¨ç»“æ„ä½“ï¼Œä»…åœ¨æŸ¥è¯¢æ—¶ä½¿ç”¨äº†ç»“æ„ä½“ï¼Œè¯·å¤§å®¶è°…è§£ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> #define o &lt;&lt; 1 ((o) &lt;&lt; 1) #define o &lt;&lt; 1 | 1 (o &lt;&lt; 1 | 1) using namespace std; struct Answer &#123; int sum, min, max; Answer(int s = 0, int i = 1000000002, int a = -1) &#123; sum = s; min = i; max = a; &#125; &#125;; inline Answer up(Answer a, Answer b) &#123; return Answer(a.sum + b.sum, min(a.min, b.min), max(a.max, b.max)); &#125; struct SegmentTree &#123; int sumv[1000005], minv[1000005], maxv[1000005]; int addv[1000005], setv[1000005]; inline void init(void) &#123; // æ²¡æœ‰åˆå€¼ï¼Œå¯ä»¥è¿™æ ·å»ºæ ‘ã€‚ memset(sumv, 0, sizeof(sumv)); memset(minv, 0, sizeof(minv)); memset(maxv, 0, sizeof(maxv)); memset(setv, -1, sizeof(setv)); memset(addv, 0, sizeof(addv)); &#125; inline void maintain(int o) &#123; sumv[o] = sumv[o &lt;&lt; 1] + sumv[o &lt;&lt; 1 | 1]; minv[o] = min(minv[o &lt;&lt; 1], minv[o &lt;&lt; 1 | 1]); maxv[o] = max(maxv[o &lt;&lt; 1], maxv[o &lt;&lt; 1 | 1]); &#125; inline void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; // å…ˆæ setï¼Œå†æ add if (setv[o] >= 0) &#123; setv[o &lt;&lt; 1] = setv[o &lt;&lt; 1 | 1] = setv[o]; addv[o &lt;&lt; 1] = addv[o &lt;&lt; 1 | 1] = 0; // æœ‰ set æ ‡è®°éœ€æ¸…ç©º add æ ‡è®°ã€‚ sumv[o &lt;&lt; 1] = (mid - l + 1) * setv[o]; sumv[o &lt;&lt; 1 | 1] = (r - mid) * setv[o]; minv[o &lt;&lt; 1] = minv[o &lt;&lt; 1 | 1] = maxv[o &lt;&lt; 1] = maxv[o &lt;&lt; 1 | 1] = setv[o]; setv[o] = -1; &#125; if (addv[o] > 0) &#123; addv[o &lt;&lt; 1] += addv[o]; addv[o &lt;&lt; 1 | 1] += addv[o]; sumv[o &lt;&lt; 1] += (mid - l + 1) * addv[o]; sumv[o &lt;&lt; 1 | 1] += (r - mid) * addv[o]; minv[o &lt;&lt; 1] += addv[o]; minv[o &lt;&lt; 1 | 1] += addv[o]; maxv[o &lt;&lt; 1] += addv[o]; maxv[o &lt;&lt; 1 | 1] += addv[o]; addv[o] = 0; &#125; &#125; inline void update_add(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addv[o] += k; sumv[o] += (r - l + 1) * k; minv[o] += k; maxv[o] += k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update_add(o &lt;&lt; 1, l, mid, x, y, k); if (mid + 1 &lt;= y) update_add(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; inline void update_set(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addv[o] = 0; setv[o] = k; sumv[o] = (r - l + 1) * k; minv[o] = maxv[o] = k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update_set(o &lt;&lt; 1, l, mid, x, y, k); if (mid + 1 &lt;= y) update_set(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; // å¼ºçƒˆä¸å»ºè®®åœ¨è¿™é‡Œä½¿ç”¨å…¨å±€å˜é‡è®¡ç®—ç­”æ¡ˆï¼Œè¿™æ˜¯ç¦å¿Œï¼Œä¼šè®©ä»£ç å¾ˆä¹±ã€‚ inline Answer query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return Answer(sumv[o], minv[o], maxv[o]); pushdown(o, l, r); int mid = l + r >> 1; Answer res; if (ql &lt;= mid) res = up(res, query(o &lt;&lt; 1, l, mid, ql, qr)); if (qr >= mid + 1) res = up(res, query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr)); return res; &#125; &#125;T[21]; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int r, c, m; int main(void) &#123; while (scanf(\"%d%d%d\", &amp;r, &amp;c, &amp;m) == 3) &#123; for (int i = 1; i &lt;= r; ++i) T[i].init(); while (m--) &#123; int op = read(); if (op == 1) &#123; int x1 = read(), y1 = read(), x2 = read(), y2 = read(), v = read(); for (int i = x1; i &lt;= x2; ++i) T[i].update_add(1, 1, c, y1, y2, v); &#125; else if (op == 2) &#123; int x1 = read(), y1 = read(), x2 = read(), y2 = read(), v = read(); for (int i = x1; i &lt;= x2; ++i) T[i].update_set(1, 1, c, y1, y2, v); &#125; else &#123; int x1 = read(), y1 = read(), x2 = read(), y2 = read(); int sumr = 0, minr = 1000000002, maxr = -1; for (int i = x1; i &lt;= x2; ++i) &#123; Answer ret = T[i].query(1, 1, c, y1, y2); sumr += ret.sum; minr = min(minr, ret.min); maxr = max(maxr, ret.max); &#125; printf(\"%d %d %d\\n\", sumr, minr, maxr); &#125; &#125; &#125; return 0; &#125; [AHOI2009] ç»´æŠ¤åºåˆ— Portal. åŒºé—´åŠ ï¼ŒåŒºé—´ä¹˜ï¼ŒåŒºé—´æ±‚å’Œã€‚ æ ¹æ®åˆšæ‰çš„ç»éªŒï¼Œè¦ä¹ˆæ˜¯ç°åŠ åä¹˜ï¼Œè¦ä¹ˆæ˜¯å…ˆä¹˜ååŠ ï¼Œä½†æ˜¯éƒ½å¯ä»¥å—ï¼Ÿæ³¨æ„ï¼Œå…ˆåŠ åä¹˜æ˜¯æ— æ³•è¡¨ç¤ºçš„ï¼Œå› ä¸ºå½“ä¹˜çš„æ ‡è®°è¢­æ¥åï¼ŒåŸæ¥çš„åŠ çš„æ ‡è®°å°±å¿…é¡»å˜æˆä¸€ä¸ªåˆ†æ•°ï¼Œè¿™å°±å®Œè›‹äº†ã€‚ å®ç°è¾ƒä¸ºç®€å•ï¼Œè¿™é‡Œä¸åšèµ˜è¿°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define LL long long #define o &lt;&lt; 1 ((o) &lt;&lt; 1) #define o &lt;&lt; 1 | 1 (o &lt;&lt; 1 | 1) using namespace std; int n, p; int a[100005]; int T[400005]; int addv[400005], mulv[400005]; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; inline void maintain(int o) &#123; T[o] = (T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]) % p; &#125; void build(int o, int l, int r) &#123; mulv[o] = 1; if (l == r) &#123; T[o] = a[l] % p; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid+1, r); maintain(o); &#125; inline void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; T[o &lt;&lt; 1] = int(((LL)T[o &lt;&lt; 1] * mulv[o] % p + (LL)addv[o] * (mid - l + 1) % p) % p); T[o &lt;&lt; 1 | 1] = int(((LL)T[o &lt;&lt; 1 | 1] * mulv[o] % p + (LL)addv[o] * (r - mid) % p) % p); mulv[o &lt;&lt; 1] = int((LL)mulv[o &lt;&lt; 1] * mulv[o] % p); mulv[o &lt;&lt; 1 | 1] = int((LL)mulv[o &lt;&lt; 1 | 1] * mulv[o] % p); addv[o &lt;&lt; 1] = int(((LL)addv[o &lt;&lt; 1] * mulv[o] + addv[o]) % p); addv[o &lt;&lt; 1 | 1] = int(((LL)addv[o &lt;&lt; 1 | 1] * mulv[o] + addv[o]) % p); mulv[o] = 1; addv[o] = 0; &#125; void update_mul(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addv[o] = int(addv[o] * (LL)k % p); mulv[o] = int(mulv[o] * (LL)k % p); T[o] = int((LL)T[o] * k % p); return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update_mul(o &lt;&lt; 1, l, mid, x, y, k); if (mid + 1 &lt;= y) update_mul(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; void update_add(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addv[o] = (addv[o] + k) % p; T[o] = int((T[o] + (LL)k * (r - l + 1)) % p); return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update_add(o &lt;&lt; 1, l, mid, x, y, k); if (mid + 1 &lt;= y) update_add(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; int query(int o, int l, int r, int ql, int qr) &#123; if(ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; pushdown(o, l, r); int mid = l + r >> 1, res = 0; if (ql &lt;= mid) res = (res + query(o &lt;&lt; 1, l, mid, ql, qr)) % p; if (mid + 1 &lt;= qr) res = (res + query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr)) % p; return res; &#125; int main(void) &#123; n = read(), p = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); int m = read(); build(1, 1, n); while (m--) &#123; int op = read(), x = read(), y = read(); if (op == 1) &#123; int k = read(); update_mul(1, 1, n, x, y, k); &#125; else if (op == 2) &#123; int k = read(); update_add(1, 1, n, x, y, k); &#125; else printf(\"%d\\n\", query(1, 1, n, x, y)); &#125; return 0; &#125; çº¿æ®µæ ‘çš„æœ¬è´¨ çº¿æ®µæ ‘èƒ½å¹²ä»€ä¹ˆå‘¢ï¼Ÿ åŒºé—´å¯åŠ æ€§ è®°å¾—ä¹‹å‰æåˆ°çš„â€œåŒºé—´å¯åŠ æ€§â€å—ï¼Ÿåˆšæ‰çš„åŒºé—´ä¹˜æ–¹æ“ä½œæ»¡è¶³è¿™ä¸€æ€§è´¨å—ï¼Ÿçº¿æ®µæ ‘çš„å·¥ä½œåŸç†æ˜¯å°†ä¸¤ä¸ªå°åŒºé—´çš„å€¼åˆå¹¶æˆå¤§åŒºé—´çš„å€¼ã€‚æ¯”å¦‚åœ¨æœ€åˆçš„åŒºé—´åŠ åŒºé—´æŸ¥è¯¢é—®é¢˜ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ âˆ‘i=lmidAi+âˆ‘i=mid+1rAi\\sum_{i=l}^{mid}A_i+\\sum_{i=mid+1}^{r}A_iâˆ‘i=lmidâ€‹Aiâ€‹+âˆ‘i=mid+1râ€‹Aiâ€‹ æ¥å¾—åˆ° âˆ‘i=lrAi\\sum_{i=l}^{r}A_iâˆ‘i=lrâ€‹Aiâ€‹ï¼Œå¯ä»¥åˆå¹¶ã€‚ å»¶è¿Ÿæ ‡è®°ä¸å…¶å®ƒ æ ‡è®°æ˜¯ä»€ä¹ˆï¼Ÿå®ƒæ˜¯ä¸€ä¸ªâ€œæ¬ æ¡â€ï¼Œç›¸å½“äºå‘Šè¯‰çº¿æ®µæ ‘æˆ‘åœ¨è¿™æ¬ äº†ä¸œè¥¿ï¼Œç»§ç»­å‘ä¸‹é€’å½’éœ€è¦ pushdownã€‚è€Œä¸”èƒ½æ ‡è®°çš„ä¸œè¥¿å¿…é¡»å¯ä»¥é«˜æ•ˆæ›´æ–°å½“å‰èŠ‚ç‚¹çš„ä¿¡æ¯ã€‚ ä¸ä¸‹ä¼ æ ‡è®°æŸ¥è¯¢æ²¡æœ‰åŠæ³•è¿›è¡Œï¼Ÿå®é™…ä¸Šæ ‡è®°å¯ä»¥æ°¸ä¹…åŒ–ï¼Œå°±æ˜¯åœ¨æŸ¥è¯¢çš„æ—¶å€™ç´¯è®¡ä¸€ä¸‹æ ‡è®°ï¼Œè€Œä¸”å¸¸æ•°ä¼šå°ä¸€ç‚¹ã€‚ä½†æ˜¯åªé™äºç‰¹æ®Šçš„æ ‡è®°ï¼Œæ¯”å¦‚åŒºé—´åŠ æ˜¯å¯ä»¥åšçš„ï¼Œä»¥æœ€åˆçš„åŒºé—´åŠ åŒºé—´æŸ¥è¯¢å’Œä¸ºä¾‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, a[400005]; i64 T[400005], tag[400005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x, int y, i64 k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] += k, T[o] += (r - l + 1) * k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1] + tag[o] * (r - l + 1); &#125; i64 query(int o, int l, int r, int x, int y, i64 t) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o] + t * (r - l + 1); int mid = l + r >> 1; i64 ans = 0; t += tag[o]; if (x &lt;= mid) ans += query(o &lt;&lt; 1, l, mid, x, y, t); if (mid &lt; y) ans += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y, t); return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); while (m--) &#123; int op, l, r, k; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) scanf(\"%d\", &amp;k), update(1, 1, n, l, r, k); else printf(\"%lld\\n\", query(1, 1, n, l, r, 0)); &#125; return 0; &#125; ä½†æ˜¯åŒºé—´èµ‹å€¼ä¸è¡Œï¼Œå› ä¸ºæŸ¥è¯¢çš„è¿‡ç¨‹ä¸­æ— æ³•ç´¯åŠ ï¼Œæ“ä½œçš„å…ˆåé¡ºåºä¼šæ”¹å˜ç»“æœï¼Œä¸çŸ¥é“å“ªä¸ªæ˜¯å…ˆåšçš„ï¼Œæ— æ³•ç»´æŠ¤ã€‚å½“æ ‡è®°éš¾ä»¥ä¸‹ä¼ æ—¶ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨æ ‡è®°æ°¸ä¹…åŒ–ã€‚ æƒå€¼çº¿æ®µæ ‘ å¯¹äºåºåˆ— AAA æ„é€ ä¸€ä¸ªåºåˆ— BBBï¼Œå…¶ä¸­ BiB_iBiâ€‹ è¡¨ç¤º AAA ä¸­æ•°å€¼ iii å‡ºç°çš„æ¬¡æ•°ï¼Œä¹Ÿå°±æ˜¯ aj=ia_j=iajâ€‹=i çš„ jjj çš„ä¸ªæ•°ï¼Œè¿™æ ·çš„ BBB ç§°ä¹‹ä¸º AAA çš„æƒå€¼æ•°åˆ—ï¼Œå¯¹ BBB é€ ä¸€æ£µçº¿æ®µæ ‘å°±æ˜¯æƒå€¼çº¿æ®µæ ‘ã€‚ ä¸»è¦åº”ç”¨äºä¸€äº›è®¡æ•°é—®é¢˜ï¼Œå’Œå¯æŒä¹…åŒ–æ­é…æœ‰å¥‡æ•ˆã€‚ä¸ºäº†ä½¿ä»¥åä¸»å¸­æ ‘ï¼ˆå¯æŒä¹…åŒ–æƒå€¼çº¿æ®µæ ‘ï¼Œåº”ç”¨å¾ˆå¤šï¼‰çš„å­¦ä¹ æ›´åŠ é¡ºåˆ©ï¼Œæˆ‘ä»¬è¿™é‡Œé€šè¿‡ä¸€é“é¢˜æ¥è°ˆä¸€ä¸‹ä»£ç å®ç°ï¼š é€†åºå¯¹ã€‚ å•Šï¼Œä¸è¦é—®æˆ‘é—®ä»€ä¹ˆæ˜¯è¿™é“é¢˜ï¼Œå› ä¸ºå®ƒå¤ªç»å…¸äº†ã€‚ æˆ‘ä»¬çŸ¥é“è¿™é“é¢˜å¯ä»¥ç”¨å½’å¹¶æ’åºæˆ–è€…æ ‘çŠ¶æ•°ç»„è§£å†³ã€‚ä»Šå¤©æˆ‘ä»¬å†æ¥ç”¨æƒå€¼çº¿æ®µæ ‘è§£å†³å®ƒã€‚ è¿™ç§ä¸œè¥¿ä¸€èˆ¬éƒ½éœ€è¦å…ˆç¦»æ•£åŒ–ã€‚è€ƒè™‘æšä¸¾ jjjï¼Œå¯¹äºæ¯ä¸ª jjj åªéœ€è¦æ‰¾åˆ°åœ¨å®ƒä¹‹å‰æœ‰å¤šå°‘ä¸ªå¤§äºå®ƒçš„ aia_iaiâ€‹ å³å¯ï¼Œå¯¹ AAA å‰ jâˆ’1j-1jâˆ’1 ä½å»ºç«‹æƒå€¼çº¿æ®µæ ‘ï¼Œæ¯æ¬¡åªéœ€è¦æŸ¥è¯¢çº¿æ®µæ ‘ä¸Š [aj+1,n][a_j+1,n][ajâ€‹+1,n] çš„å’Œå³å¯ï¼Œç„¶åä¿®æ”¹å¯¹äºæƒå€¼çº¿æ®µæ ‘æ¥è¯´å°±æ˜¯ç‚¹ä¿®æ”¹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int a[500005], T[2000005]; void init(void) &#123; static int tmp[500005]; for (int i = 1; i &lt;= n; ++i) tmp[i] = a[i]; sort(tmp + 1, tmp + n + 1); int m = unique(tmp + 1, tmp + n + 1) - (tmp + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(tmp + 1, tmp + m + 1, a[i]) - tmp; &#125; int query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1, res = 0; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res; &#125; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o]++, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); init(); long long ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; ans += query(1, 1, n, a[i] + 1, n); update(1, 1, n, a[i]); &#125; printf(\"%lld\\n\", ans); return 0; &#125; æ³¨æ„ï¼Œè™½ç„¶ä¸Šè¿°ä»£ç æ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯å¯¹è¿™é“é¢˜æ¥è¯´æ˜¾ç„¶ä¸æ˜¯æœ€ä¼˜çš„ï¼Œå› ä¸ºæŸ¥è¯¢ä¸æ˜¯ç®€å•çš„åŒºé—´æŸ¥è¯¢ï¼Œè€Œæ˜¯ä¸€ç«¯å›ºå®šçš„åŒºé—´ã€‚ä½†æ˜¯ç”¨æ›´é€šç”¨çš„æ–¹å¼æ¥å†™æ˜¾ç„¶ä¸æ˜“å‡ºé”™ã€‚ åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ é€šè¿‡è®°å½•å·¦å³å„¿å­çš„ç¼–å·ï¼Œè€Œä¸æ˜¯ä½¿ç”¨å®Œå…¨äºŒå‰æ ‘çš„ç¼–å·æ³•åˆ™ï¼Œè¿™ç§æ–¹å¼ç§°ä¹‹ä¸ºåŠ¨æ€å¼€ç‚¹ã€‚ä»£ç å¤§æ¦‚é•¿è¿™æ ·ï¼š struct Node &#123; int lc, rc; // å·¦å³èŠ‚ç‚¹ç¼–å· int dat; // å½“å‰ç»´æŠ¤çš„å€¼ &#125;T[SIZE * 2]; // ç»ˆäºåªéœ€è¦äºŒå€ç©ºé—´å•¦ï¼ int root, tot; // æ ¹èŠ‚ç‚¹ç¼–å·ï¼ŒèŠ‚ç‚¹ä¸ªæ•° int newNode(void) &#123; ++tot; T[tot].lc = T[tot].rc = T[tot].dat = 0; return tot; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o].dat += k, void(); int mid = l + r >> 1; if (x &lt;= mid) &#123; if (!T[o].lc) T[o].lc = build(); update(T[o].lc, l, mid, x, k); &#125; else &#123; if (!T[o].rc) T[o].rc = build(); update(T[o].rc, mid + 1, r, x, k); &#125; maintain(o); &#125; int main(void) &#123; tot = 0; root = build(); // å»ºæ ‘ &#125; çº¿æ®µæ ‘äºŒåˆ† æƒå€¼çº¿æ®µæ ‘ä¸Šæ˜¯å¯ä»¥äºŒåˆ†çš„ã€‚ [PA2015] Siano.ä¸€ç‰‡ nnn äº©çš„åœŸåœ°ï¼Œç¬¬ iii äº©åœŸåœ°çš„è‰æ¯å¤©ä¼šé•¿é«˜ aia_iaiâ€‹ å˜ç±³ã€‚ä¸€å…±ä¼šè¿›è¡Œ mmm æ¬¡æ”¶å‰²ï¼Œå…¶ä¸­ç¬¬ iii æ¬¡æ”¶å‰²åœ¨ç¬¬ did_idiâ€‹ å¤©ï¼Œå¹¶æŠŠæ‰€æœ‰é«˜åº¦å¤§äºç­‰äº bib_ibiâ€‹ çš„éƒ¨åˆ†å…¨éƒ¨å‰²å»ã€‚æ¯æ¬¡æ”¶å‰²å¾—åˆ°çš„è‰çš„é«˜åº¦æ€»å’Œæ˜¯å¤šå°‘ï¼Ÿ é¦–å…ˆå‘ç°ä¸€ä¸ªé—®é¢˜ï¼Œé•¿å¾—å¿«çš„è‰ä¸€å®šé•¿å¾—é«˜ã€‚é‚£ä¹ˆå°†è‰çš„ç”Ÿé•¿é€Ÿåº¦ä»å°åˆ°å¤§æ’åºï¼Œæ¯æ¬¡å‰²æ‰çš„ä¸€å®šæ˜¯ä¸€ä¸ªåç¼€åŒºé—´ã€‚ ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ï¼ŒæŸ¥è¯¢æ—¶åœ¨çº¿æ®µæ ‘ä¸ŠäºŒåˆ†ï¼ˆé€’å½’æ—¶çœ‹å·¦å­æ ‘æ˜¯å¦æ»¡è¶³ï¼Œç„¶ååˆ¤æ–­è¿›å…¥å“ªä¸€æ£µå­æ ‘ï¼‰å‡ºæœ€åä¸€ä¸ªå¤§äºç­‰äº bbb çš„ç‚¹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[500005]; i64 s[500005]; struct Node &#123; i64 sum, setv, addv, maxx; Node() : setv(-1) &#123;&#125; &#125; T[2000005]; void grow(int o, int l, int r, i64 val) &#123; T[o].addv += val; T[o].sum += (s[r] - s[l - 1]) * val; T[o].maxx += a[r] * val; &#125; void cut(int o, int l, int r, i64 val) &#123; T[o].setv = T[o].maxx = val; T[o].addv = 0; T[o].sum = (r - l + 1) * val; &#125; void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; if (T[o].setv != -1) &#123; cut(o &lt;&lt; 1, l, mid, T[o].setv); cut(o &lt;&lt; 1 | 1, mid + 1, r, T[o].setv); T[o].setv = -1; &#125; if (T[o].addv) &#123; grow(o &lt;&lt; 1, l, mid, T[o].addv); grow(o &lt;&lt; 1 | 1, mid + 1, r, T[o].addv); T[o].addv = 0; &#125; &#125; i64 modify(int o, int l, int r, int x, int y, i64 val) &#123; if (x > y) return 0; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; i64 tmp = T[o].sum; cut(o, l, r, val); return tmp - T[o].sum; &#125; i64 res = 0; int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) res += modify(o &lt;&lt; 1, l, mid, x, y, val); if (mid &lt; y) res += modify(o &lt;&lt; 1 | 1, mid + 1, r, x, y, val); T[o].sum = T[o &lt;&lt; 1].sum + T[o &lt;&lt; 1 | 1].sum; T[o].maxx = T[o &lt;&lt; 1 | 1].maxx; return res; &#125; int find(int o, int l, int r, i64 val) &#123; if (l == r) return T[o].sum &lt; val ? n + 1 : l; int mid = l + r >> 1; pushdown(o, l, r); if (T[o &lt;&lt; 1].maxx >= val) return find(o &lt;&lt; 1, l, mid, val); return find(o &lt;&lt; 1 | 1, mid + 1, r, val); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + a[i]; i64 last = 0; while (m--) &#123; i64 d, b; scanf(\"%lld%lld\", &amp;d, &amp;b); grow(1, 1, n, d - last); last = d; printf(\"%lld\\n\", modify(1, 1, n, find(1, 1, n, b), n, b)); &#125; return 0; &#125; çº¿æ®µæ ‘çš„åˆ†è£‚ä¸åˆå¹¶ å¯¹äºåŠ¨æ€å¼€ç‚¹çš„æƒå€¼çº¿æ®µæ ‘ï¼Œå®ƒä»¬å¯ä»¥è¿›è¡Œåˆ†è£‚å’Œåˆå¹¶çš„æ“ä½œã€‚ çº¿æ®µæ ‘åˆå¹¶ å‡è®¾ç°åœ¨æœ‰ä¸¤æ£µç»´æŠ¤ç›¸åŒå€¼åŸŸçš„åŸºäºåŠ¨æ€å¼€ç‚¹å®ç°çš„æƒå€¼çº¿æ®µæ ‘ï¼Œç°åœ¨æˆ‘ä»¬æƒ³è¦å°†å®ƒä»¬ç»´æŠ¤çš„å€¼ç›¸åŠ ã€‚è¿™å°±éœ€è¦é€šè¿‡çº¿æ®µæ ‘åˆå¹¶æ¥å®ç°ï¼Œä»ä¸¤ä¸ªæ ¹èŠ‚ç‚¹å¼€å§‹åŒæ­¥éå†ä¸¤æ£µçº¿æ®µæ ‘ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸¤ä¸ªæŒ‡é’ˆ o1,o2o_1,o_2o1â€‹,o2â€‹ï¼Œåœ¨å®ç°ä¸­é‡‡ç”¨ p,qp,qp,qï¼Œæ‰€ä»£è¡¨çš„å­åŒºé—´æ˜¯ä¸€è‡´çš„ã€‚ å¦‚æœä¸¤ä¸ªå…¶ä¸­ä¹‹ä¸€ä¸ºç©ºï¼Œé‚£ä¹ˆè¿”å›é‚£ä¸ªéç©ºçš„ã€‚å¦‚æœéƒ½ä¸æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆéœ€è¦é€’å½’åˆå¹¶ä¸¤æ£µå­æ ‘ï¼Œç„¶ååˆ å»èŠ‚ç‚¹ qqqï¼Œä»¥ ppp ä½œä¸ºåˆå¹¶çš„èŠ‚ç‚¹ï¼ˆç»´æŠ¤æœ€å¤§å€¼ï¼‰ã€‚ int merge(int p, int q, int l, int r) &#123; if (!p) return q; if (!q) return p; if (l == r) &#123; T[p].dat += T[q].dat; return p; &#125; int mid = l + r >> 1; T[p].lc = merge(T[p].lc, T[q].lc, l, mid); T[p].rc = merge(T[p].rc, T[q].rc, mid + 1, r); T[p].dat = max(T[T[p].lc].dat, T[T[p].rc].dat); return p; &#125; æ—¶é—´å¤æ‚åº¦ä¸çº¿æ®µæ ‘çš„è§„æ¨¡ä¸€è‡´ã€‚è¿™æ ·å°† qqq åˆå¹¶åˆ° ppp ä¹‹åä¼šå¯¼è‡´ qqq çš„ç»“æ„è¢«ç ´åï¼Œæ‰€ä»¥è¿™æ ·åªèƒ½ç¦»çº¿ã€‚å¦‚æœå®æ—¶æ–°å»ºèŠ‚ç‚¹å¯ä»¥åšåˆ°åœ¨çº¿ï¼Œè¿™æ ·çš„ç©ºé—´å¤æ‚åº¦ä¸º O(nlogâ¡n)O(n\\log n)O(nlogn)ï¼š int merge(int p, int q, int l, int r) &#123; if (p == 0 || q == 0) return p + q; int o = ++tot; if (l == r) &#123; T[o].dat = T[p].dat + T[q].dat; return o; &#125; int mid = l + r >> 1; T[o].ls = merge(T[p].ls, T[q].rs, l, mid); T[o].rs = merge(T[p].rs, T[q].rs, mid + 1, r); pushup(o); return o; &#125; æ¨¡æ¿ã€‚å·®åˆ†æ“ä½œï¼Œå¯¹æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½ä½¿ç”¨ä¸€æ£µåŠ¨æ€å¼€ç‚¹æƒå€¼çº¿æ®µæ ‘æ¥ç»´æŠ¤ä¿¡æ¯ï¼Œæœ€åå‰ç¼€å’Œä¸€æ¬¡åšçº¿æ®µæ ‘åˆå¹¶å›ç­”è¯¢é—®ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 100000; int n, m, dep[100005], mi[17][100005], dfn[100005], num, lg[100005]; int f[100005], ans[100005]; vector&lt;int> G[100005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; mi[0][dfn[x] = ++num] = fa; dep[x] = dep[fa] + 1; f[x] = fa; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; struct Node &#123; int ls, rs; int cnt, ans; &#125; T[6000005]; int root[100005], tot; inline void pushup(int o) &#123; if (T[T[o].ls].cnt >= T[T[o].rs].cnt) T[o].cnt = T[T[o].ls].cnt, T[o].ans = T[T[o].ls].ans; else T[o].cnt = T[T[o].rs].cnt, T[o].ans = T[T[o].rs].ans; &#125; void update(int &amp;o, int l, int r, int x, int k) &#123; if (!o) o = ++tot; if (l == r) return T[o].cnt += k, T[o].ans = x, void(); int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, l, mid, x, k); else update(T[o].rs, mid + 1, r, x, k); pushup(o); &#125; int merge(int p, int q, int l, int r) &#123; if (!p || !q) return p + q; if (l == r) return T[p].cnt += T[q].cnt, p; int mid = l + r >> 1; T[p].ls = merge(T[p].ls, T[q].ls, l, mid); T[p].rs = merge(T[p].rs, T[q].rs, mid + 1, r); pushup(p); return p; &#125; void calc(int x, int fa) &#123; for (int y : G[x]) if (y != fa) &#123; calc(y, x); root[x] = merge(root[x], root[y], 1, N); &#125; ans[x] = T[root[x]].ans; if (!T[root[x]].cnt) ans[x] = 0; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); while (m--) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); int d = LCA(x, y); update(root[x], 1, N, z, 1); update(root[y], 1, N, z, 1); update(root[d], 1, N, z, -1); update(root[f[d]], 1, N, z, -1); &#125; calc(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; çº¿æ®µæ ‘åˆ†è£‚ æ˜¯å°†ä¸€ä¸ªå¯é‡é›†å‰ kkk å°çš„æ•°ä¹‹åçš„æ•°åˆ†æˆä¸¤ä¸ªé›†åˆï¼Œè¿™æ ·çº¿æ®µæ ‘å°±ä¼šåˆ†è£‚æˆä¸¤æ£µçº¿æ®µæ ‘ã€‚ å¯ä»¥ä»¿ç…§ FHQ-Treap çš„æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥å®ç° O(logâ¡n)O(\\log n)O(logn) çš„çº¿æ®µæ ‘åˆ†è£‚ã€‚ ä»£å¡«å‘ã€‚ Problemset æ„Ÿè§‰å†…å®¹å¾ˆå¤šï¼Ÿçš„ç¡®å¦‚æ­¤ï¼ŒåŸºç¡€æ•°æ®ç»“æ„å¯ä»¥è§£å†³å¾ˆå¤šé—®é¢˜ï¼Œä¸‹é¢æ˜¯ä¸€äº›ç»å…¸é¢˜ã€‚ ç®€å•é—®é¢˜ ä¸»è¦å¦‚ä½•æ‹†åˆ†æˆ–å˜å½¢è¦å¤„ç†çš„å†…å®¹ï¼Œä½¿å¾—æ›´å®¹æ˜“ç»´æŠ¤ã€‚ä»¥åŠå¦‚ä½•åˆå¹¶ç®€å•çš„æ ‡è®°ã€‚ [Luogu P1438] æ— èŠçš„æ•°åˆ— Portal. åŒºé—´åŠ ç­‰å·®æ•°åˆ—ï¼Œå•ç‚¹æŸ¥è¯¢ã€‚ ç­‰å·®æ•°åˆ—çœ‹ä½œä¸€ä¸ªæ•´ä½“å½“æˆæ ‡è®°çš„è¯éå¸¸éš¾ç»´æŠ¤ï¼Œå› ä¸ºé¦–é¡¹ä¸€ç›´åœ¨æ”¹å˜ã€‚å¯¹äºä¸€æ¬¡æ“ä½œï¼Œå¯ä»¥æ‹†æˆå¯¹åŒºé—´çš„ k-d*lï¼ˆä¸ºå½“å‰çš„ lllï¼‰å’Œ +d*iï¼ˆä¸ºå½“å‰ä¸‹æ ‡ï¼‰ã€‚è¿™ä¸ª +d*? çš„æ“ä½œåªéœ€è¦å¼€ä¸€ä¸ªæ ‡è®°ï¼Œç„¶åå†æŸ¥è¯¢çš„æ—¶å€™ä¹˜ä¸Šå½“å‰çš„ lll å°±å¯ä»¥äº†ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; int n, m; int a[100005]; i64 tagk[400005], tagd[400005]; inline void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; tagk[o &lt;&lt; 1] += tagk[o], tagk[o &lt;&lt; 1 | 1] += tagk[o]; tagd[o &lt;&lt; 1] += tagd[o], tagd[o &lt;&lt; 1 | 1] += tagd[o]; tagk[o] = tagd[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k, int d) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tagk[o] += k; tagd[o] += d; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k, d); if (mid + 1 &lt;= y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k, d); &#125; i64 query(int o, int l, int r, int p) &#123; if (l == r) return tagk[o] + l * tagd[o]; int mid = l + r >> 1; pushdown(o, l, r); if (p &lt;= mid) return query(o &lt;&lt; 1, l, mid, p); return query(o &lt;&lt; 1 | 1, mid + 1, r, p); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); while (m--) &#123; int opt; scanf(\"%d\", &amp;opt); if (opt == 1) &#123; int l, r; i64 k, d; scanf(\"%d%d%lld%lld\", &amp;l, &amp;r, &amp;k, &amp;d); update(1, 1, n, l, r, k - d * l, d); &#125; else &#123; int p; scanf(\"%d\", &amp;p); printf(\"%lld\\n\", query(1, 1, n, p) + a[p]); &#125; &#125; return 0; &#125; ä¸ºä»€ä¹ˆæ˜¯å•ç‚¹æŸ¥è¯¢ï¼Ÿå› ä¸ºæŸ¥è¯¢çš„æ—¶å€™æ¯ä¸ªä¸‹æ ‡æ˜¯å˜åŒ–çš„ï¼Œ+d*? çš„ ? ä¸€ç›´åœ¨å˜åŒ–ï¼Œåªèƒ½åšå•ç‚¹ã€‚ [Luogu P6327] åŒºé—´åŠ åŒºé—´ sin å’Œ Portal. é«˜ä¸­è¯¾æœ¬ä»‹ç»äº†ä¸‰è§’å‡½æ•°çš„å’Œå·®è§’å…¬å¼ï¼š sinâ¡(Î±+Î²)=sinâ¡Î±cosâ¡Î²+cosâ¡Î±sinâ¡Î²cosâ¡(Î±+Î²)=cosâ¡Î±cosâ¡Î²âˆ’sinâ¡Î±sinâ¡Î²\\sin(\\alpha+\\beta)=\\sin \\alpha \\cos \\beta + \\cos\\alpha\\sin\\beta\\\\ \\cos(\\alpha+\\beta)=\\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta sin(Î±+Î²)=sinÎ±cosÎ²+cosÎ±sinÎ²cos(Î±+Î²)=cosÎ±cosÎ²âˆ’sinÎ±sinÎ² ç»´æŠ¤ä¸¤ä¸ªé‡ Sin å’Œ Cosï¼Œè®°å½•ä¸€ä¸ªæ ‡è®° tagï¼Œupdate å’Œ pushdown çš„æ—¶å€™ç”¨å…¬å¼ç»´æŠ¤åŠ ä¸Šæ ‡è®°çš„å€¼çš„ä¸‰è§’å‡½æ•°å€¼å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m; int a[200005]; i64 tag[800005]; double Sin[800005], Cos[800005]; inline void maintain(int o) &#123; Sin[o] = Sin[o &lt;&lt; 1] + Sin[o &lt;&lt; 1 | 1]; Cos[o] = Cos[o &lt;&lt; 1] + Cos[o &lt;&lt; 1 | 1]; &#125; inline void maintain(int o, double sinx, double cosx) &#123; double sina = Sin[o], cosa = Cos[o]; Sin[o] = sina * cosx + cosa * sinx; Cos[o] = cosa * cosx - sina * sinx; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; Sin[o] = sin(a[l]); Cos[o] = cos(a[l]); return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; double sinx = sin(tag[o]), cosx = cos(tag[o]); maintain(o &lt;&lt; 1, sinx, cosx); maintain(o &lt;&lt; 1 | 1, sinx, cosx); tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125; int k; double sink, cosk; void update(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; maintain(o, sink, cosk); tag[o] += k; return; &#125; pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y); maintain(o); &#125; double query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return Sin[o]; pushdown(o); double res = 0; int mid = l + r >> 1; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res; &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); build(1, 1, n); m = read(); while (m--) &#123; int op = read(); if (op == 1) &#123; int l = read(), r = read(); k = read(); sink = sin(k), cosk = cos(k); update(1, 1, n, l, r); &#125; else &#123; int l = read(), r = read(); printf(\"%.1lf\\n\", query(1, 1, n, l, r)); &#125; &#125; return 0; &#125; ã€ŒWdsr-2.7ã€æ–‡æ–‡çš„æ‘„å½±å¸ƒç½® Portal. è§‚å¯Ÿæ¡ä»¶ Ai+Akâˆ’minâ¡{Bj},i&lt;j&lt;kA_i+A_k-\\min\\{B_j\\},i&lt;j&lt;kAiâ€‹+Akâ€‹âˆ’min{Bjâ€‹},i&lt;j&lt;kï¼Œæˆ‘ä»¬åœ¨çº¿æ®µæ ‘çš„èŠ‚ç‚¹ä¸­ç»´æŠ¤ AAA çš„æœ€å¤§å€¼å’Œ BBB çš„æœ€å°å€¼ï¼Œä»¥åŠåŒºé—´ç­”æ¡ˆ ansansansã€‚ ç°åœ¨éš¾å°±éš¾åœ¨æ»¡è¶³çº¿æ®µæ ‘çš„â€œåŒºé—´å¯åŠ æ€§â€ï¼Œä¹Ÿå°±æ˜¯å¦‚ä½•ä»å·¦å³å„¿å­åˆå¹¶å‡ºå½“å‰èŠ‚ç‚¹çš„ç­”æ¡ˆã€‚minâ¡{Bj}\\min\\{B_j\\}min{Bjâ€‹} å¯ä»¥å½“æˆä¸€ä¸ªå€¼ï¼Œå°±æ˜¯åŒºé—´ BBB æœ€å°å€¼ã€‚è‚¯å®šå¯ä»¥ä¸‰ä¸ªæ•°å…¨ä»å·¦å­èŠ‚ç‚¹æˆ–å³å­èŠ‚ç‚¹è¿‡æ¥ï¼Œä¹Ÿå¯ä»¥ä¸¤ä¸ªæ•°ä»ä¸€ä¸ªèŠ‚ç‚¹è¿‡æ¥ï¼Œä¸€ä¸ªæ•°ä»å¦ä¸€ä¸ªèŠ‚ç‚¹è¿‡æ¥ã€‚è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬è®° lmaxlmaxlmax ä»£è¡¨ Aiâˆ’BjA_i-B_jAiâ€‹âˆ’Bjâ€‹ çš„æœ€å¤§å€¼ï¼Œrmaxrmaxrmax ä»£è¡¨ Akâˆ’BjA_k-B_jAkâ€‹âˆ’Bjâ€‹ çš„æœ€å¤§å€¼ã€‚è¿™ä¸¤ä¸ªå¯ä»¥ç®€å•ç»´æŠ¤ï¼Œè¦ä¹ˆä»å·¦å³èŠ‚ç‚¹å•ç‹¬è¿‡æ¥ï¼Œè¦ä¹ˆä¸¤ä¸ªä¸‹æ ‡åœ¨ä¸åŒçš„åŒºé—´ï¼Œè€Œä¸”ç”±äº i&lt;j&lt;ki&lt;j&lt;ki&lt;j&lt;kï¼Œæ‰€ä»¥é¡ºåºä¸€å®šã€‚è¿™æ · ansansans å°±è¦ä¹ˆæ˜¯å·¦å­èŠ‚ç‚¹çš„ lmaxlmaxlmax å’Œå³å­èŠ‚ç‚¹çš„ amaxamaxamax åˆå¹¶è¿‡æ¥ï¼Œè¦ä¹ˆæ˜¯ä»å³å­èŠ‚ç‚¹çš„ rmaxrmaxrmax å’Œå·¦å­èŠ‚ç‚¹çš„ lmaxlmaxlmax åˆå¹¶è¿‡æ¥ã€‚ é‚£ä¹ˆ lmaxlmaxlmax å’Œ rmaxrmaxrmax å‘¢ï¼Ÿå¤§è‡´åŒç†ï¼Œè¦ä¹ˆéƒ½åœ¨å¶å­èŠ‚ç‚¹ï¼Œè¦ä¹ˆè·¨åŒºé—´ï¼Œè·¨åŒºé—´çš„æ—¶å€™å°±æ˜¯é€šè¿‡ç»´æŠ¤çš„ A,BA,BA,B å€¼æ¥è®¡ç®—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; int n, m; int a[500005], b[500005]; struct Node &#123; int amax, bmin; int lmax, rmax, ans; &#125; T[2000005]; inline Node merge(Node a, Node b) &#123; Node ans; ans.amax = max(a.amax, b.amax); ans.bmin = min(a.bmin, b.bmin); ans.lmax = max(&#123;a.lmax, b.lmax, a.amax - b.bmin&#125;); ans.rmax = max(&#123;a.rmax, b.rmax, b.amax - a.bmin&#125;); ans.ans = max(&#123;a.ans, b.ans, a.amax + b.rmax, a.lmax + b.amax&#125;); return ans; &#125; void build(int o, int l, int r) &#123; T[o].lmax = T[o].rmax = T[o].ans = -INF; // åˆå§‹ä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œæ˜¯è´Ÿæ— ç©· if (l == r) return T[o].amax = a[l], T[o].bmin = b[l], void(); int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = ls | 1; build(ls, l, mid); build(rs, mid + 1, r); T[o] = merge(T[ls], T[rs]); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o].amax = a[l], T[o].bmin = b[l], void(); int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = ls | 1; if (x &lt;= mid) update(ls, l, mid, x, k); else update(rs, mid + 1, r, x, k); T[o] = merge(T[ls], T[rs]); &#125; Node query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = ls | 1; if (qr &lt;= mid) return query(ls, l, mid, ql, qr); if (mid &lt; ql) return query(rs, mid + 1, r, ql, qr); return merge(query(ls, l, mid, ql, qr), query(rs, mid + 1, r, ql, qr)); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i); build(1, 1, n); while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; a[x] = y; update(1, 1, n, x, y); &#125; else if (op == 2) &#123; b[x] = y; update(1, 1, n, x, y); &#125; else printf(\"%d\\n\", query(1, 1, n, x, y).ans); &#125; return 0; &#125; [NOIP2016 æé«˜ç»„] èš¯èš“ Portal. èš¯èš“é•¿åº¦å¢åŠ è¿™ä¸€äº‹æˆ‘ä»¬ç”¨ä¸€ä¸ªå»¶è¿Ÿæ ‡è®° deltadeltadelta å®Œæˆï¼Œç„¶åä½¿ç”¨ä¸‰ä¸ªé˜Ÿåˆ—æ¨¡æ‹Ÿä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå› ä¸ºåˆ†è£‚è¶Šæ™šçš„èš¯èš“é•¿åº¦åªèƒ½æ›´çŸ­ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; struct Queue &#123; int Q[7000005], L = 1, R = 0; inline void push(int x) &#123; Q[++R] = x; &#125; inline void pop(void) &#123; ++L; &#125; inline int front(void) &#123; return L &lt;= R ? Q[L] : -INF; &#125; inline bool empty(void) &#123; return L > R; &#125; &#125; A, B, C; int n, m, q, u, v, t, delta = 0; int a[100005], ans[7100005], tot = 0; int main(void) &#123; scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); for (int i = n; i >= 1; --i) A.push(a[i]); for (int i = 1; i &lt;= m; ++i, delta += q) &#123; int x; if (A.front() >= B.front() &amp;&amp; A.front() >= C.front()) x = A.front(), A.pop(); else if (B.front() >= A.front() &amp;&amp; B.front() >= C.front()) x = B.front(), B.pop(); else x = C.front(), C.pop(); x += delta; if (i % t == 0) printf(\"%d \", x); int y = 1ll * u * x / v; B.push(y - delta - q); C.push(x - y - delta - q); &#125; putchar('\\n'); for (int i = A.L; i &lt;= A.R; ++i) ans[++tot] = A.Q[i]; for (int i = B.L; i &lt;= B.R; ++i) ans[++tot] = B.Q[i]; for (int i = C.L; i &lt;= C.R; ++i) ans[++tot] = C.Q[i]; sort(ans + 1, ans + tot + 1, greater&lt;int>()); for (int i = 1; i &lt;= tot; ++i) if (i % t == 0) printf(\"%d \", ans[i] + delta); putchar('\\n'); return 0; &#125; [SDOI2009] HH çš„é¡¹é“¾ Portal. æ˜¾ç„¶åŒä¸€ç§ç±»åªæœ‰æœ€å³é¢çš„ä¼šæœ‰ç”¨ã€‚å°†è¯¢é—®æŒ‰ç…§å³ç«¯ç‚¹æ’åºï¼Œç„¶åå¯ä»¥è®©å‰ç¼€å’Œä¸æ–­å‘å³æ‰©å±•ï¼Œæ–¹ä¾¿æŸ¥è¯¢ï¼Œä½¿ç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤å‰ç¼€å’Œå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; struct Question &#123; int l, r, id; bool operator &lt; (const Question &amp;a) const &#123; return r &lt; a.r; &#125; &#125; q[1000005]; int n, m, C[1000005]; int a[1000005], ans[1000005]; int last[1000005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int sum(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r), q[i].id = i; sort(q + 1, q + m + 1); int r = 1; for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt;= q[i].r) &#123; if (last[a[r]]) add(last[a[r]], -1); add(last[a[r]] = r, 1); ++r; &#125; ans[q[i].id] = sum(q[i].r) - sum(q[i].l - 1); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; [GZOI2017] é…å¯¹ç»Ÿè®¡ Portal. æŒ–æ˜é…å¯¹çš„æ€§è´¨ï¼Œå‘ç°å°†é…å¯¹çš„æ•°æ’åºåä¸€ä¸ªæ•°çš„é…å¯¹åªèƒ½æ˜¯å®ƒå·¦è¾¹ç¬¬ä¸€ä¸ªæˆ–è€…æ˜¯å®ƒå³è¾¹ç¬¬ä¸€ä¸ªã€‚å°†è¯¢é—®æŒ‰ç…§å³ç«¯ç‚¹æ’åºï¼Œç„¶åä½¿ç”¨åŒæŒ‡é’ˆåŠ æ ‘çŠ¶æ•°ç»„æ¥ç»´æŠ¤å½“å‰è¯¢é—®çš„ç­”æ¡ˆå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) ((x) &amp; (-(x))) #define X first #define Y second using namespace std; typedef long long i64; typedef pair&lt;int, int> pii; int n, m, tot = 0; pii b[600005]; bool cmp(pii a, pii b) &#123; if (a.Y != b.Y) return a.Y &lt; b.Y; return a.X &lt; b.X; &#125; struct Node &#123; int val, pos; bool operator &lt; (Node &amp;a) const &#123; return val &lt; a.val; &#125; &#125;a[300005]; struct Question &#123; int l, r; int pos, ans; bool operator &lt; (const Question &amp;a) const &#123; if (r != a.r) return r &lt; a.r; return l &lt; a.l; &#125; &#125;Q[300005]; // ============ Fenwick Tree ============ int C[300005]; void update(int x) &#123; while (x &lt;= n) &#123; C[x]++; x += lowbit(x); &#125; &#125; int query(int x) &#123; int res = 0; while (x) &#123; res += C[x]; x -= lowbit(x); &#125; return res; &#125; void add(int l, int r) &#123; if (l > r) swap(l, r); ++tot; b[tot].X = l, b[tot].Y = r; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); if (n == 1) return puts(\"0\"), 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i].val), a[i].pos = i; sort(a + 1, a + n + 1); add(a[1].pos, a[2].pos); add(a[n - 1].pos, a[n].pos); for (int i = 2; i &lt; n; ++i) &#123; int l = a[i].val - a[i - 1].val, r = a[i + 1].val - a[i].val; if (l == r) add(a[i - 1].pos, a[i].pos), add(a[i].pos, a[i + 1].pos); else if (l &lt; r) add(a[i - 1].pos, a[i].pos); else add(a[i].pos, a[i + 1].pos); &#125; sort(b + 1, b + tot + 1, cmp); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r); Q[i].pos = i; &#125; sort(Q + 1, Q + m + 1); i64 ans = 0; for (int i = 1, j = 0; i &lt;= m; ++i) &#123; while (j &lt; tot &amp;&amp; b[j + 1].Y &lt;= Q[i].r) &#123; ++j; update(b[j].X); &#125; ans += 1ll * Q[i].pos * (j - query(Q[i].l - 1)); &#125; printf(\"%lld\\n\", ans); return 0; &#125; ã€ŒWdsr-3ã€ä»¤äººæ„Ÿä¼¤çš„çº¢é›¨ Portal. å®é™…ä¸Š Î©(l,r)=maxâ¡{0,lâˆ’A(1,r)}\\Omega(l,r)=\\max\\{0,l-A(1,r)\\}Î©(l,r)=max{0,lâˆ’A(1,r)}ï¼Œå› æ­¤è€ƒè™‘å¦‚ä½•ç»´æŠ¤å‰ç¼€ AAAã€‚è®¾æ‰€æœ‰â€œæœ€å€¼ç‚¹â€ä¸º bbbï¼Œå‰ç¼€åŠ ä¼šå¯¼è‡´ä¸€äº›æœ€å€¼ç‚¹æ¶ˆå¤±ï¼Œå¹¶æŸ¥é›†ç»´æŠ¤æ¯ä¸ªä½ç½®æ‰€å¯¹åº”çš„æœ€å€¼ç‚¹ï¼Œé“¾è¡¨ç»´æŠ¤æœ€å€¼ç‚¹çš„å­˜åœ¨æƒ…å†µå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int a[6000005], fa[6000005], nxt[6000005], b[6000005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(b, -1, sizeof b); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), fa[i] = i, nxt[i] = n + 1; for (int i = 2, p = 1; i &lt;= n; ++i) &#123; if (a[i] >= a[p]) nxt[p] = i, b[p] = a[i] - a[p], p = i; else fa[i] = p; &#125; while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; int t = find(x); b[t] -= y; while (nxt[t] &lt;= n &amp;&amp; b[t] &lt; 0) &#123; b[t] += b[nxt[t]]; fa[nxt[t]] = t; nxt[t] = nxt[nxt[t]]; &#125; &#125; else printf(\"%d\\n\", max(0, x - find(y))); &#125; return 0; &#125; æŠ€å·§æ€§é—®é¢˜ è¿™é‡Œæ˜¯çº¿æ®µæ ‘çš„ä¸€äº›ç»å…¸åº”ç”¨ã€‚ [Luogu P4145] ä¸Šå¸é€ é¢˜çš„ä¸ƒåˆ†é’Ÿ 2 / èŠ±ç¥æ¸¸å†å„å›½ Portal. æ‡’æ ‡è®°ï¼Ÿ å¦‚æœæ‚¨èƒ½æå‡ºè´¨ç–‘ï¼Œé‚£ä¹ˆç¬”è€…ä¸ºæ‚¨ç‚¹èµã€‚å¦‚æœä¸èƒ½ï¼Œä½ å¯èƒ½è¦é‡æ–°å»çœ‹ã€Šçº¿æ®µæ ‘çš„æœ¬è´¨ã€‹ä¸€èŠ‚ï¼ˆç¬”è€…è¦è¢«æ‰£å·¥èµ„äº†ï¼‰ã€‚ è¦æ³¨æ„åˆ°çš„æ˜¯ï¼Œå¦‚æœä½¿ç”¨å»¶è¿Ÿæ ‡è®°ï¼Œé‚£ä¹ˆå½“å‰çš„åŒºé—´å’Œæ˜¯æ— æ³•ç»´æŠ¤çš„ã€‚å› ä¸ºå®ƒä¸åƒåŒºé—´åŠ åŒºé—´ sin å’Œè¿™ç§ä¸œè¥¿å¯ä»¥è¿›è¡Œæ‹†è§£ï¼Œæ¯ä¸ªæ•°å¼€å¹³æ–¹ååŒºé—´çš„å’Œæ— æ³•ç®€å•ç»´æŠ¤ã€‚ ä½†æ˜¯åŒºé—´å¼€æ–¹è¿™ç§ä¸œè¥¿ï¼Œå¾ˆå®¹æ˜“å°±å¼€åˆ° 111 äº†ã€‚ç„¶è€Œå¯¹ç€ 111 å¼€æ–¹æ˜¯æ²¡æœ‰ç”¨çš„ã€‚æ‰€ä»¥å¦‚æœåŒºé—´çš„æœ€å¤§å€¼æ˜¯ 111ï¼Œé‚£ä¹ˆåŒºé—´å¼€æ–¹è¿™ç§æ“ä½œå°±æ²¡å¿…è¦è¿›è¡Œäº†ã€‚ æˆ‘ä»¬ç›´æ¥ä½¿ç”¨çº¿æ®µæ ‘ï¼Œä½†æ˜¯ä¸éœ€è¦å»¶è¿Ÿæ ‡è®°ï¼Œç»´æŠ¤åˆ°å¶å­èŠ‚ç‚¹ä¸ºæ­¢ã€‚å¦‚æœä¸€ä¸ªåŒºé—´å·²ç»æ¯” 111 å°ï¼Œé‚£ä¹ˆå°±ä¸ç”¨ç»´æŠ¤äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; i64 a[100005]; i64 sum[400005], maxx[400005]; inline void maintain(int o) &#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; maxx[o] = max(maxx[o &lt;&lt; 1], maxx[o &lt;&lt; 1 | 1]); &#125; void build(int o, int l, int r) &#123; if (l == r) return sum[o] = maxx[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; void update(int o, int l, int r, int x, int y) &#123; if (l == r) // å¶å­èŠ‚ç‚¹é‡æ–°ç»´æŠ¤ &#123; sum[o] = sqrt(sum[o]); maxx[o] = sqrt(maxx[o]); return; &#125; int mid = l + r >> 1; if (x &lt;= mid &amp;&amp; maxx[o &lt;&lt; 1] > 1) update(o &lt;&lt; 1, l, mid, x, y); // æœ€å¤§å€¼å¤§äº 1 æ‰ä¿®æ”¹ if (mid &lt; y &amp;&amp; maxx[o &lt;&lt; 1 | 1] > 1) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y); maintain(o); &#125; i64 query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return sum[o]; int mid = l + r >> 1; i64 res = 0; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); scanf(\"%d\", &amp;m); build(1, 1, n); while (m--) &#123; int k, l, r; scanf(\"%d%d%d\", &amp;k, &amp;l, &amp;r); if (l > r) swap(l, r); if (k == 0) update(1, 1, n, l, r); else printf(\"%lld\\n\", query(1, 1, n, l, r)); &#125; return 0; &#125; [TJOI2018] æ•°å­¦è®¡ç®— Portal. è¿™ä¸æ˜¯æ¨¡æ‹Ÿå—ï¼ˆ ä½†æ˜¯ä¸è¡Œï¼Œæˆ‘ä»¬çŸ¥é“é™¤æ³•æ˜¯æ²¡æœ‰éšæ—¶å–æ¨¡æ€§è´¨çš„ï¼Œå°±ç®—ç®—é€†å…ƒï¼Œä¹Ÿæ²¡æœ‰ä¿è¯äº’è´¨ï¼Œé€†å…ƒä¸ä¸€å®šæœ‰ã€‚ æ³¨æ„åˆ°æœ€å¤šé™¤ä¸€æ¬¡ï¼Œä»¥æ—¶é—´å»ºç«‹ä¸€æ£µçº¿æ®µæ ‘ï¼Œæ ¹èŠ‚ç‚¹ç»´æŠ¤çš„æ˜¯å½“å‰çš„ xxx å€¼ã€‚å¯¹äºä¸€ä¸ªä¹˜æ“ä½œï¼Œæˆ‘ä»¬å°±å°†å½“å‰è¯¢é—®çš„ç¼–å·ä¹˜ä¸Š xxxï¼Œå¯¹äºé™¤æ³•ï¼Œæˆ‘ä»¬å°±å°†è¿™ä¸ªç¼–å·æ”¹ä¸º 111ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int Q, M; int T[400005]; void build(int o, int l, int r) &#123; T[o] = 1; if (l == r) return; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) &#123; T[o] = (k == 0) ? 1 : k; return; &#125; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = ls | 1; if (x &lt;= mid) update(ls, l, mid, x, k); else update(rs, mid + 1, r, x, k); T[o] = (i64)T[ls] * T[rs] % M; &#125; int main(void) &#123; int TT; scanf(\"%d\", &amp;TT); while (TT--) &#123; scanf(\"%d%d\", &amp;Q, &amp;M); build(1, 1, Q); for (int i = 1; i &lt;= Q; ++i) &#123; int op, x; scanf(\"%d%d\", &amp;op, &amp;x); if (op == 1) update(1, 1, Q, i, x); else update(1, 1, Q, x, 0); printf(\"%d\\n\", T[1] % M); &#125; &#125; return 0; &#125; è¿™ç§åŸºäºæ—¶é—´çš„æ“ä½œéå¸¸å¸¸è§ï¼Œè¯·è¯»è€…ä¸€å®šè¦ç†Ÿè®°ã€‚ [SHOI2015] è„‘æ´æ²»ç–—ä»ª Portal. å¯¹äºæ“ä½œäºŒï¼Œè€ƒè™‘çº¿æ®µæ ‘ä¸ŠäºŒåˆ†ï¼šéœ€è¦å…ˆæ»¡è¶³å¡«çš„åŒºé—´ï¼Œç„¶åä»å·¦å­æ ‘å¼€å§‹å°è¯•å¡«æ»¡ï¼ˆè§ä»£ç ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct Node &#123; int sum, lmax, rmax, dat, len; &#125; T[800005]; int tag[800005], len[800005]; int n, m; Node hb(const Node &amp;a, const Node &amp;b) &#123; Node c; c.sum = a.sum + b.sum; c.len = a.len + b.len; c.lmax = (a.lmax == a.len ? a.len + b.lmax : a.lmax); c.rmax = (b.rmax == b.len ? b.len + a.rmax : b.rmax); c.dat = max(&#123;a.dat, b.dat, a.rmax + b.lmax&#125;); return c; &#125; void build(int o, int l, int r) &#123; tag[o] = -1; T[o].len = r - l + 1; if (l == r) return T[o].sum = 1, void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void maketag(int o, int l, int r, int k) &#123; T[o].sum = k * (r - l + 1); T[o].lmax = T[o].rmax = T[o].dat = (1 - k) * (r - l + 1); tag[o] = k; &#125; void pushdown(int o, int l, int r) &#123; if (tag[o] == -1) return; int mid = l + r >> 1; maketag(o &lt;&lt; 1, l, mid, tag[o]); maketag(o &lt;&lt; 1 | 1, mid + 1, r, tag[o]); tag[o] = -1; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, l, r, k); int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; pushdown(o, l, r); if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return hb(query(o &lt;&lt; 1, l, mid, x, y), query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); &#125; int cont(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].sum; int res = 0, mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) res += cont(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += cont(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; int dag(int o, int l, int r, int x, int y, int k) &#123; if (k == 0) return 0; if (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; T[o].len - T[o].sum &lt;= k) &#123; int t = T[o].len - T[o].sum; maketag(o, l, r, 1); return k - t; &#125; pushdown(o, l, r); int ans = 0, mid = l + r >> 1; if (y &lt;= mid) ans = dag(o &lt;&lt; 1, l, mid, x, y, k); else if (mid &lt; x) ans = dag(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); else ans = dag(o &lt;&lt; 1 | 1, mid + 1, r, x, y, dag(o &lt;&lt; 1, l, mid, x, y, k)); return T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]), ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); build(1, 1, n); while (m--) &#123; int op, l, r, l1, r1; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 0) update(1, 1, n, l, r, 0); else if (op == 1) &#123; scanf(\"%d%d\", &amp;l1, &amp;r1); int x = cont(1, 1, n, l, r); if (x == 0) continue; update(1, 1, n, l, r, 0); dag(1, 1, n, l1, r1, x); &#125; else printf(\"%d\\n\", query(1, 1, n, l, r).dat); &#125; return 0; &#125; [THUSC2015] å¹³æ–¹è¿ç®— Portal. æ¨¡æ„ä¹‰ä¸‹åŒºé—´å¹³æ–¹æ˜¯å­˜åœ¨å¾ªç¯èŠ‚çš„ï¼Œå¤šæ¬¡å¹³æ–¹åå¿…å®šä¼šé™·å…¥å¾ªç¯ã€‚é‚£ä¹ˆçº¿æ®µæ ‘ç›´æ¥æš´åŠ›ç»´æŠ¤ï¼Œæå‰é¢„å¤„ç†å‡ºæ¯ä¸ªæ•°çš„å¾ªç¯ï¼Œè¿›å…¥äº†å¾ªç¯èŠ‚ä¹‹åå°±å¯ä»¥å¼€å§‹æ‰“æ ‡è®°ï¼Œç»´æŠ¤ä¸€ä¸ªåç§»é‡ä»£è¡¨å¾ªç¯åˆ°å“ªé‡Œå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125; int n, m, l = 1, P, a[100005]; int vis[10005], p[10005]; bool lp[400005]; int now[400005], tag[400005]; i64 T[400005][60]; inline void chk(int o) &#123; if (p[T[o][0]]) &#123; for (int i = 1; i &lt; l; ++i) T[o][i] = T[o][i - 1] * T[o][i - 1] % P; lp[o] = 1; &#125; &#125; inline void pushup(int o) &#123; lp[o] = (lp[o &lt;&lt; 1] &amp;&amp; lp[o &lt;&lt; 1 | 1]); now[o] = 0; if (!lp[o]) T[o][0] = T[o &lt;&lt; 1][now[o &lt;&lt; 1]] + T[o &lt;&lt; 1 | 1][now[o &lt;&lt; 1 | 1]]; else &#123; int lx = now[o &lt;&lt; 1], rx = now[o &lt;&lt; 1 | 1]; for (int i = 0; i &lt; l; ++i) &#123; T[o][i] = T[o &lt;&lt; 1][lx] + T[o &lt;&lt; 1 | 1][rx]; lx = (lx + 1) % l, rx = (rx + 1) % l; &#125; &#125; &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o][0] = a[l], chk(o); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o); &#125; inline void maketag(int o, int k) &#123; tag[o] = (tag[o] + k) % l; now[o] = (now[o] + k) % l; &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; lp[o]) return maketag(o, 1); if (l == r) return T[o][0] = T[o][0] * T[o][0] % P, chk(o); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y); pushup(o); &#125; i64 query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o][now[o]]; pushdown(o); int mid = l + r >> 1; i64 res = 0; if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; void findloop(int x) &#123; for (int i = 1, y = x;; y = y * y % P, ++i) if (vis[y]) &#123; p[y] = i - vis[y]; break; &#125; else vis[y] = i; for (int y = x; vis[y]; y = y * y % P) vis[y] = 0; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;P); for (int i = 0; i &lt; P; ++i) findloop(i); for (int i = 0; i &lt; P; ++i) if (p[i]) l = lcm(l, p[i]); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); while (m--) &#123; int op, l, r; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) update(1, 1, n, l, r); else printf(\"%lld\\n\", query(1, 1, n, l, r)); &#125; return 0; &#125; ç»¼åˆåº”ç”¨ è¿™é‡Œæ˜¯ä¸€äº›ç®€å•çš„ç»¼åˆé¢˜ã€‚ [HEOI2016] æ’åº Portal.ç»™å®šä¸€ä¸ª 111 åˆ° nnn çš„æ’åˆ—ï¼Œè¿›è¡Œ mmm æ¬¡æ“ä½œï¼Œå¯ä»¥æ˜¯å°†ç»™å®šçš„åŒºé—´å‡åºæˆ–è€…é™åºæ’åºã€‚é—®æœ€åç¬¬ qqq ä¸ªä½ç½®ä¸Šçš„æ•°å­—ã€‚ å…ˆæ¥è€ƒè™‘ä¸€ä¸ªç®€å•çš„é—®é¢˜ï¼Œ01 æ’åºæ€ä¹ˆåšï¼Ÿç»´æŠ¤åŒºé—´ 01 çš„æ•°é‡ï¼Œæ’åºçš„æ—¶å€™ç›´æ¥å°†åé¢çš„æ”¹ä¸º 1ï¼Œå‰é¢çš„æ”¹ä¸º 0ï¼Œå¯ä»¥ä½¿ç”¨çº¿æ®µæ ‘å®Œæˆã€‚ ç°åœ¨è€ƒè™‘æ€ä¹ˆæ±‚è§£åŸé—®é¢˜ã€‚å¦‚æœå°†æ‰€æœ‰ â‰¥x\\ge xâ‰¥x çš„æ•°éƒ½è®¾ç½®ä¸º 111ï¼Œ&lt;x&lt;x&lt;x çš„éƒ½è®¾ç½®ä¸º 000ï¼Œé‚£ä¹ˆç…§æ ·æ±‚è§£ï¼Œå¦‚æœç¬¬ qqq ä¸ªä½ç½®æ˜¯ 111 å°±è¯´æ˜ qqq ä»£è¡¨çš„æ•°ä¸€å®š â‰¥x\\ge xâ‰¥xã€‚æœ€ç»ˆäºŒåˆ†å‡ºçš„ç»“æœå°±æ˜¯ç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 201314; int n, m, q; int a[100005], b[100005]; int op[100005], l[100005], r[100005]; int T[400005], tag[400005]; void build(int o, int l, int r) &#123; tag[o] = -1; if (l == r) return T[o] = (b[l] == 1), void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; inline void pushdown(int o, int l, int r) &#123; if (tag[o] == -1) return; int mid = l + r >> 1; tag[o &lt;&lt; 1] = tag[o &lt;&lt; 1 | 1] = tag[o]; T[o &lt;&lt; 1] = tag[o] * (mid-l+1); T[o &lt;&lt; 1 | 1] = tag[o] * (r-mid); tag[o] = -1; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x > y) return; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] = k, T[o] = k * (r-l+1), void(); int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = 0; pushdown(o, l, r); if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; bool P(int x) &#123; for (int i = 1; i &lt;= n; ++i) b[i] = (a[i] >= x ? 1 : 0); build(1, 1, n); for (int i = 1; i &lt;= m; ++i) &#123; int k = query(1, 1, n, l[i], r[i]); if (op[i] == 0) &#123; update(1, 1, n, l[i], r[i] - k, 0); update(1, 1, n, r[i] - k + 1, r[i], 1); &#125; else &#123; update(1, 1, n, l[i], l[i] + k - 1, 1); update(1, 1, n, l[i] + k, r[i], 0); &#125; &#125; return query(1, 1, n, q, q) == 1; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", op + i, l + i, r + i); scanf(\"%d\", &amp;q); int L = 0, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", L); return 0; &#125; [Luogu P5278] ç®—æœ¯å¤©æ‰â‘¨ä¸ç­‰å·®æ•°åˆ— Portal. å‘ç°æ¡ä»¶éå¸¸ä¸¥è‹›ï¼Œå› æ­¤å¯ä»¥è€ƒè™‘å“ˆå¸Œä¹‹ç±»çš„æ–¹æ³•ï¼Œè¿™é‡Œä¸åšèµ˜è¿°ã€‚ ä¸€æ®µåŒºé—´å¯ä»¥é‡æ’ä¸ºç­‰å·®æ•°åˆ—ï¼Œå½“ä¸”ä»…å½“æ»¡è¶³ï¼ˆd=0d=0d=0 å…ˆç‰¹åˆ¤æ‰ï¼‰ï¼š maxâ¡âˆ’minâ¡=dÃ—(lenâˆ’1)\\max -\\min =d\\times (len-1)maxâˆ’min=dÃ—(lenâˆ’1)ï¼› gcdâ¡i=lrâˆ’1(ai+1âˆ’ai)=d\\gcd_{i=l}^{r-1}(a_{i+1}-a_i)=dgcdi=lrâˆ’1â€‹(ai+1â€‹âˆ’aiâ€‹)=dï¼› åºåˆ—ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚ ç”¨çº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ç¬¬ä¸‰æ¡å¯ä»¥ä½¿ç”¨ setã€map ç»´æŠ¤ä¸€ä¸ªæ•°æœ€å·¦è¾¹çš„å‡ºç°ä½ç½®ï¼Œç„¶åç”¨çº¿æ®µæ ‘ç»´æŠ¤è¿™ä¸ªå€¼çš„æœ€å°å€¼ï¼Œå¦‚æœè¿™ä¸ªæ•°å°äº lllï¼Œé‚£ä¹ˆä¸€å®šæ²¡æœ‰é‡å¤å…ƒç´ ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int n, m; int a[300005], c[300005], pre[300005]; unordered_map&lt;int, set&lt;int>> mp; struct Node &#123; int mx, mn, mx_pre; friend Node operator+ (const Node &amp;a, const Node &amp;b) &#123; Node c; c.mx = max(a.mx, b.mx); c.mn = min(a.mn, b.mn); c.mx_pre = max(a.mx_pre, b.mx_pre); return c; &#125; &#125; T[1200005]; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].mx = T[o].mn = a[l]; T[o].mx_pre = pre[l]; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x) &#123; if (l == r) &#123; T[o].mx = T[o].mn = a[l]; T[o].mx_pre = pre[l]; return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; Node res = &#123;-1, INF, 0&#125;; if (x &lt;= mid) res = res + query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res = res + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; int tt[1200005]; void buildx(int o, int l, int r) &#123; if (l == r) return tt[o] = c[l], void(); int mid = l + r >> 1; buildx(o &lt;&lt; 1, l, mid); buildx(o &lt;&lt; 1 | 1, mid + 1, r); tt[o] = gcd(tt[o &lt;&lt; 1], tt[o &lt;&lt; 1 | 1]); &#125; void updatex(int o, int l, int r, int x) &#123; if (l == r) return tt[o] = c[x], void(); int mid = l + r >> 1; if (x &lt;= mid) updatex(o &lt;&lt; 1, l, mid, x); else updatex(o &lt;&lt; 1 | 1, mid + 1, r, x); tt[o] = gcd(tt[o &lt;&lt; 1], tt[o &lt;&lt; 1 | 1]); &#125; int queryx(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tt[o]; int mid = l + r >> 1, res = 0; if (x &lt;= mid) res = gcd(res, queryx(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = gcd(res, queryx(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; bool solve(int l, int r, int k) &#123; if (l == r) return true; Node t = query(1, 1, n, l, r); int g = queryx(1, 1, n - 1, l, r - 1); if (t.mx - t.mn != 1ll * k * (r - l)) return false; if (k &amp;&amp; t.mx_pre >= l) return false; if (g != k) return false; return true; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (mp[a[i]].empty()) pre[i] = -1; else &#123; auto it = mp[a[i]].end(); --it; pre[i] = *it; &#125; mp[a[i]].insert(i); &#125; for (int i = 1; i &lt; n; ++i) c[i] = abs(a[i + 1] - a[i]); build(1, 1, n); if (n - 1) buildx(1, 1, n - 1); int cnt = 0, op, x, y, k; while (m--) &#123; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); x ^= cnt; y ^= cnt; if (op == 1) &#123; auto it = mp[a[x]].find(x); ++it; if (it != mp[a[x]].end()) pre[*it] = pre[x], update(1, 1, n, *it); mp[a[x]].erase(x); a[x] = y; mp[a[x]].insert(x); it = mp[a[x]].upper_bound(x); if (it != mp[a[x]].end()) pre[*it] = x, update(1, 1, n, *it); --it; if (it != mp[a[x]].begin()) --it, pre[x] = *it; else pre[x] = -1; c[x] = abs(a[x + 1] - a[x]); c[x - 1] = abs(a[x] - a[x - 1]); update(1, 1, n, x); if (x &lt; n) updatex(1, 1, n - 1, x); if (x - 1) updatex(1, 1, n - 1, x - 1); &#125; else &#123; scanf(\"%d\", &amp;k); k ^= cnt; if (solve(x, y, k)) puts(\"Yes\"), ++cnt; else puts(\"No\"); &#125; &#125; return 0; &#125; [Luogu P6617] æŸ¥æ‰¾ Search Portal. å®šä¹‰ä¸€ä¸‹ä¸¤ç§å…³ç³»ï¼š â€œè¡¥â€è¡¨ç¤ºä¸æ•° xxx ç›¸åŠ ä¸º wwwã€‚ â€œç­‰â€è¡¨ç¤ºä¸æ•° xxx ç›¸ç­‰ã€‚ è®°å½•æ¯ä¸ªæ•°çš„è¡¥å‰é©±ï¼Œç„¶åç”¨çº¿æ®µæ ‘æŸ¥è¯¢åŒºé—´å†…è¡¥å‰é©±çš„æœ€å¤§ç¼–å·ï¼Ÿå½“ç„¶å¯ä»¥ï¼Œä½†æ˜¯ 1 5 5 5 5 5 è¿™ç§ä¿®æ”¹ 111 å°±å¯ä»¥ç›´æ¥ç‚¸æ‰ï¼šåé¢æ‰€æœ‰æ•°çš„è¡¥å‰é©±éƒ½å°†ä¼šå˜åŠ¨ã€‚ ä»¤ä¸€ä¸ªæ•°çš„è¡¥å‰é©±å¯ä»¥è¢«è®°å½•ï¼Œå½“ä¸”ä»…å½“å®ƒè¡¥å‰é©±çš„ä½ç½®åœ¨å®ƒç­‰å‰é©±å³è¾¹ï¼Œå¦åˆ™è®°å½•ä¸º 000ã€‚ä¸éš¾å‘ç°è¿™æ ·ä¾æ¬¡ä¿®æ”¹æœ€å¤šåªä¼šå½±å“ 555 ä¸ªæ•°ï¼šè‡ªèº«ã€åŸæ¥ axa_xaxâ€‹ çš„è¡¥åé©±å’Œç­‰åé©±ã€yyy çš„è¡¥åé©±å’Œç­‰åé©±ã€‚ä½¿ç”¨ set åŠ çº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, w; int a[500005], T[2000005], pre[2000005]; set&lt;int> s[500005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = pre[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o] = pre[l], void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int res = -1, mid = l + r >> 1; if (x &lt;= mid) res = max(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = max(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; void calc(int x, int y) &#123; // a[x] æ”¹æˆ yï¼Œä¿®æ”¹ x çš„å‰é©± auto i = s[y].find(x); if (i != s[y].begin()) &#123; --i; // i æ˜¯ x çš„ç­‰å‰é©± auto j = s[w - y].lower_bound(x); if (j == s[w - y].begin()) pre[x] = 0; else &#123; --j; // j æ˜¯ x çš„è¡¥å‰é©± if (*j >= *i) pre[x] = *j; else pre[x] = 0; &#125; &#125; else &#123; // æ²¡æœ‰ç­‰å‰é©± auto j = s[w - y].lower_bound(x); if (j == s[w - y].begin()) pre[x] = 0; else pre[x] = *(--j); &#125; update(1, 1, n, x); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;w); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (s[w - a[i]].size()) &#123; int it = *(--s[w - a[i]].end()); if (s[a[i]].empty() || it >= *(--s[a[i]].end())) pre[i] = it; &#125; s[a[i]].insert(i); &#125; build(1, 1, n); int cnt = 0; while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; auto k = s[a[x]].find(x); ++k; // k ä¸º a[x] çš„ç­‰åé©± auto l = s[w - a[x]].upper_bound(x); // l ä¸º a[x] çš„è¡¥åé©± s[a[x]].erase(x); s[y].insert(x); if (k != s[a[x]].end()) calc(*k, a[x]); if (l != s[w - a[x]].end()) calc(*l, w - a[x]); a[x] = y; k = s[a[x]].find(x); ++k; // k ä¸º y çš„ç­‰åé©± l = s[w - a[x]].upper_bound(x); // l ä¸º y çš„è¡¥åé©± if (k != s[a[x]].end()) calc(*k, a[x]); if (l != s[w - a[x]].end()) calc(*l, w - a[x]); calc(x, y); &#125; else &#123; x ^= cnt; y ^= cnt; if (query(1, 1, n, x, y) >= x) puts(\"Yes\"), ++cnt; else puts(\"No\"); &#125; &#125; return 0; &#125; [BJOI2019] åˆ æ•° Portal. è®¾ xxx çš„å‡ºç°æ¬¡æ•°ä¸º tttï¼Œé‚£ä¹ˆå…¶èƒ½è¦†ç›– [xâˆ’t+1,x][x-t+1,x][xâˆ’t+1,x] çš„åŒºé—´ã€‚ç­”æ¡ˆæ˜¯ [1,n][1,n][1,n] ä¸­æœªè¢«è¦†ç›–çš„ä¸ªæ•°ã€‚è¿™æ ·å•ç‚¹ä¿®æ”¹åªä¼šè®©ä¸¤ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°æ›´æ”¹ï¼ŒåŒºé—´å¹³ç§»å¯ä»¥çœ‹ä½œè¯¢é—®åŒºé—´çš„å¹³ç§»ï¼Œæ¯æ¬¡çš„ç§»åŠ¨è·ç¦»ä¹Ÿåªæœ‰ 111ã€‚ çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´ 000 çš„ä¸ªæ•°ã€‚ç”±äºæœ‰åŒºé—´åŠ çš„å»¶è¿Ÿæ ‡è®°ï¼Œå› æ­¤è®°å½•åŒºé—´æœ€å°å€¼å’Œæœ€å°å€¼çš„å‡ºç°æ¬¡æ•°ï¼Œå¯ä»¥åœ¨åŒºé—´åŠ çš„æ—¶å€™æ–¹ä¾¿ç»Ÿè®¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 450005; int n, m, P = 150001; int a[150005], buc[N + 5]; int tag[N * 4 + 5], mn[N * 4 + 5], cnt[N * 4 + 5], ans[N * 4 + 5]; inline void pushup(int o) &#123; mn[o] = min(mn[o &lt;&lt; 1], mn[o &lt;&lt; 1 | 1]); cnt[o] = (mn[o] == mn[o &lt;&lt; 1] ? cnt[o &lt;&lt; 1] : 0) + (mn[o] == mn[o &lt;&lt; 1 | 1] ? cnt[o &lt;&lt; 1 | 1] : 0); ans[o] = ans[o &lt;&lt; 1] + ans[o &lt;&lt; 1 | 1]; &#125; inline void maketag(int o, int k) &#123; mn[o] += k; ans[o] = (mn[o] == 0 ? cnt[o] : 0); tag[o] += k; &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = 0; &#125; void build(int o, int l, int r) &#123; if (l == r) return ans[o] = cnt[o] = 1, void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, k); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); pushup(o); &#125; int query(int o, int l, int r, int x, int y) &#123; // æŸ¥è¯¢ [x, y] å½“ä¸­æ²¡æœ‰è¢«è¦†ç›–çš„ä¸ªæ•° if (x &lt;= l &amp;&amp; r &lt;= y) return ans[o]; pushdown(o); int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; void change(int x, int c) &#123; int k = x - buc[x] + 1 - (c > 0); update(1, 1, N, k, k, c); buc[x] += c; &#125; int main(void) &#123; // è¯¢é—®åŒºé—´ä¸º [1 + P, n + P] scanf(\"%d%d\", &amp;n, &amp;m); build(1, 1, N); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), change(a[i] += P, 1); while (m--) &#123; int p, x; scanf(\"%d%d\", &amp;p, &amp;x); if (p > 0) &#123; // å•ç‚¹ä¿®æ”¹ if (a[p] &lt;= n + P) change(a[p], -1); else --buc[a[p]]; a[p] = x + P; if (a[p] &lt;= n + P) change(a[p], 1); else ++buc[a[p]]; &#125; else &#123; if (x > 0) &#123; // è¯¢é—®åŒºé—´å‘å·¦å¹³ç§» int pos = n + P; if (buc[pos]) update(1, 1, N, pos - buc[pos] + 1, pos, -1); --P; &#125; else &#123; ++P; int pos = n + P; if (buc[pos]) update(1, 1, N, pos - buc[pos] + 1, pos, 1); &#125; &#125; printf(\"%d\\n\", query(1, 1, N, 1 + P, n + P)); &#125; return 0; &#125; [GDOI2014] åƒ Portal. å¯ä»¥å°† [1,l)âˆª(r,n][1,l)\\cup (r,n][1,l)âˆª(r,n] æ‹†å¼€ï¼Œå› æ­¤ä¸€æ¬¡è¯¢é—®å°±å˜æˆäº†åœ¨ [1,l),[l,r][1,l),[l,r][1,l),[l,r] ä¸­å„é€‰ä¸€ä¸ªæ•°ã€‚ é«˜æ•ˆç»´æŠ¤è¿™ä¸ªé—®é¢˜ååˆ†å›°éš¾ï¼Œå‘ç°å€¼åŸŸå¾ˆå°ï¼Œç›´æ¥å¤„ç†å‡ºæ‰€æœ‰æ•°çš„å› æ•°å†åšè€ƒè™‘ã€‚ç¦»çº¿ï¼ŒæŒ‰ç…§å³ç«¯ç‚¹å‡åºæ’åºã€‚å¦‚æœ preaipre_{a_i}preaiâ€‹â€‹ å­˜åœ¨ï¼Œé‚£ä¹ˆè¯¢é—®çš„ lll åœ¨ (preai,i](pre_{a_i},i](preaiâ€‹â€‹,i] çš„èŒƒå›´å†…å‡ºç°æ—¶æ˜¯å¯ä»¥æ›´æ–°åˆ° aia_iaiâ€‹ çš„ï¼Œä¸€ä¸ªåŒºé—´ä¿®æ”¹å•ç‚¹æŸ¥è¯¢çš„çº¿æ®µæ ‘å°±å¯ä»¥å®Œæˆã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(nnlogâ¡n)O(n\\sqrt{n}\\log n)O(nnâ€‹logn)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 1e5; int n, m; int a[100005], pre[100005], nxt[100005]; vector&lt;int> b[100005]; struct Query &#123; int l, r, id; &#125; Q[100005]; int ans[100005]; int T[400005], tag[400005]; inline void maketag(int o, int k) &#123; T[o] = max(T[o], k); tag[o] = max(tag[o], k); &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, k); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x) &#123; if (l == r) return T[o]; pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) return query(o &lt;&lt; 1, l, mid, x); return query(o &lt;&lt; 1 | 1, mid + 1, r, x); &#125; int main(void) &#123; for (int i = 1; i &lt;= N; ++i) for (int j = i; j &lt;= N; j += i) b[j].emplace_back(i); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1, [&amp;](auto a, auto b) &#123; return a.r &lt; b.r; &#125;); for (int i = 1, j = 1; i &lt;= n; ++i) &#123; for (int x : b[a[i]]) &#123; if (pre[x]) update(1, 1, N, pre[x] + 1, i, x); // l åœ¨è¿™éƒ¨åˆ†æ—¶å¯ä»¥æœ‰ç­”æ¡ˆ pre[x] = i; &#125; while (j &lt;= m &amp;&amp; Q[j].r == i) &#123; ans[Q[j].id] = max(ans[Q[j].id], query(1, 1, N, Q[j].l)); ++j; &#125; &#125; memset(T, 0, sizeof T); memset(tag, 0, sizeof tag); sort(Q + 1, Q + m + 1, [&amp;](auto a, auto b) &#123; return a.l > b.l; &#125;); for (int i = n, j = 1; i >= 1; --i) &#123; for (int x : b[a[i]]) &#123; if (nxt[x]) update(1, 1, N, i, nxt[x] - 1, x); nxt[x] = i; &#125; while (j &lt;= m &amp;&amp; Q[j].l == i) &#123; ans[Q[j].id] = max(ans[Q[j].id], query(1, 1, N, Q[j].r)); ++j; &#125; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; [CTT2012] åºåˆ—æ“ä½œ Portal. ç”±äº ccc å¾ˆå°ï¼Œå› æ­¤ç›´æ¥å°†ç­”æ¡ˆè®°å½•åœ¨çº¿æ®µæ ‘å†…ã€‚ å”¯ä¸€å›°éš¾çš„æ˜¯åŒºé—´åŠ ï¼Œå‘ç°å®ƒæ‰€å¢åŠ çš„è´¡çŒ®å¹¶ä¸ç›´è§‚ã€‚æ¯”å¦‚ï¼š [a1,â‹¯ai]â†’[a1+c,â‹¯ai+c][a_1,\\cdots a_i]\\rightarrow [a_1+c,\\cdots a_i+c] [a1â€‹,â‹¯aiâ€‹]â†’[a1â€‹+c,â‹¯aiâ€‹+c] ç„¶åæŠŠä»–ä»¬ä¹˜èµ·æ¥ï¼Œå¹¶å±•å¼€ï¼Œå¯ä»¥å‘ç°å…¶å®æœ‰è§„å¾‹çš„ï¼š fiâ†(lenâˆ’i0)Ã—c0Ã—fi+(lenâˆ’(iâˆ’1)1)Ã—c1Ã—fiâˆ’1+â‹¯f_i\\leftarrow \\binom{len-i}{0}\\times c^0 \\times f_i+\\binom{len-(i-1)}{1}\\times c^1 \\times f_{i-1}+\\cdots fiâ€‹â†(0lenâˆ’iâ€‹)Ã—c0Ã—fiâ€‹+(1lenâˆ’(iâˆ’1)â€‹)Ã—c1Ã—fiâˆ’1â€‹+â‹¯ è¿™ä¸ªä¸œè¥¿å¯ä»¥çº¿æ€§è®¡ç®—ï¼Œé‚£ä¹ˆæ•´ä½“å°±æ˜¯å¥½ç»´æŠ¤çš„äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define REV 2000000000 using namespace std; const int P = 19940417; int n, q, C[50005][25]; int a[50005]; int addv[200005]; bool rev[200005]; struct Node &#123; int c[21]; friend Node operator+ (const Node &amp;a, const Node &amp;b) &#123; Node c; memset(c.c, 0, sizeof c.c); for (int i = 0; i &lt;= 20; ++i) for (int j = 0; i + j &lt;= 20; ++j) c.c[i + j] = (c.c[i + j] + 1ll * a.c[i] * b.c[j]) % P; return c; &#125; &#125; T[200005]; void build(int o, int l, int r) &#123; if (l == r) return T[o].c[0] = 1, T[o].c[1] = a[l] % P, void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int tmp[21]; inline void maketag(int o, int l, int r, int k) &#123; if (k == REV) &#123; rev[o] ^= 1; addv[o] = P - addv[o]; for (int i = 1; i &lt;= 20; ++i) if (i &amp; 1) T[o].c[i] = P - T[o].c[i]; return; &#125; addv[o] = (addv[o] + k) % P; for (int i = tmp[0] = 1; i &lt;= 20; ++i) tmp[i] = 1ll * tmp[i - 1] * k % P; for (int i = min(r - l + 1, 20); i; --i) for (int j = 0; j &lt; i; ++j) T[o].c[i] = (T[o].c[i] + 1ll * T[o].c[j] * tmp[i - j] % P * C[r - l + 1 - j][i - j]) % P; &#125; inline void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; if (rev[o]) &#123; maketag(o &lt;&lt; 1, l, mid, REV); maketag(o &lt;&lt; 1 | 1, mid + 1, r, REV); rev[o] = 0; &#125; if (addv[o]) &#123; maketag(o &lt;&lt; 1, l, mid, addv[o]); maketag(o &lt;&lt; 1 | 1, mid + 1, r, addv[o]); addv[o] = 0; &#125; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, l, r, k); pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; pushdown(o, l, r); int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return query(o &lt;&lt; 1, l, mid, x, y) + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 0; i &lt;= n; ++i) for (int j = C[i][0] = 1; j &lt;= min(i, 20); ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); char op[5]; int l, r, k; while (q--) &#123; scanf(\"%s%d%d\", op, &amp;l, &amp;r); if (op[0] != 'R') scanf(\"%d\", &amp;k); if (op[0] == 'I') update(1, 1, n, l, r, k); else if (op[0] == 'R') update(1, 1, n, l, r, REV); else printf(\"%d\\n\", (query(1, 1, n, l, r).c[k] % P + P) % P); &#125; return 0; &#125; [Ynoi2015] çºµä½¿æ—¥è–„è¥¿å±± Portal.ç‚æœµè‰æƒ³è®©ä½ ç»´æŠ¤ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„æ­£æ•´æ•°åºåˆ— a1,a2,â€¦,ana_1,a_2,\\ldots,a_na1â€‹,a2â€‹,â€¦,anâ€‹ï¼Œæ”¯æŒä¿®æ”¹åºåˆ—ä¸­æŸä¸ªä½ç½®çš„å€¼ã€‚æ¯æ¬¡ä¿®æ”¹åé—®å¯¹åºåˆ—é‡å¤è¿›è¡Œä»¥ä¸‹æ“ä½œï¼Œéœ€è¦è¿›è¡Œå‡ æ¬¡æ“ä½œæ‰èƒ½ä½¿åºåˆ—å˜ä¸ºå…¨ 000ï¼ˆè¯¢é—®ååºåˆ—å’Œè¯¢é—®å‰ç›¸åŒï¼Œä¸ä¼šå˜ä¸ºå…¨ 000ï¼‰ï¼šé€‰å‡ºåºåˆ—ä¸­æœ€å¤§å€¼çš„å‡ºç°ä½ç½®ï¼Œè‹¥æœ‰å¤šä¸ªæœ€å¤§å€¼åˆ™é€‰ä½ç½®æ ‡å·æœ€å°çš„ä¸€ä¸ªï¼Œè®¾ä½ç½®ä¸º xxxï¼Œåˆ™å°† axâˆ’1,ax,ax+1a_{x-1},a_x,a_{x+1}axâˆ’1â€‹,axâ€‹,ax+1â€‹ çš„å€¼å‡ 111ï¼Œå¦‚æœåºåˆ—ä¸­å­˜åœ¨å°äº 000 çš„æ•°ï¼Œåˆ™æŠŠå¯¹åº”çš„æ•°æ”¹ä¸º 000ã€‚1â‰¤n,qâ‰¤1051\\leq n,q\\leq 10^51â‰¤n,qâ‰¤105ï¼Œ1â‰¤xiâ‰¤n1\\leq x_i\\leq n1â‰¤xiâ€‹â‰¤nï¼Œ1â‰¤ai,yiâ‰¤1091\\leq a_i,y_i\\leq 10^91â‰¤aiâ€‹,yiâ€‹â‰¤109ã€‚ è€ƒè™‘å“ªäº›æ•°å¯ä»¥è¢«å‡ã€‚å¦‚æœæˆ‘ä»¬å¼€å§‹å‡ aia_iaiâ€‹ï¼Œé‚£ä¹ˆå®ƒä¸€å®šä¼šä¸€ç›´å‡ä¸‹å»ï¼ˆå› ä¸ºå·¦å³ä¸¤ä¸ªæ°¸è¿œéƒ½æ¯”å®ƒå°ï¼‰ã€‚ å°†åŸåºåˆ—è¿›è¡Œå•è°ƒæé•¿åˆ’åˆ†ï¼Œå‘ç°å¯¹äºæ¯ä¸ªæé•¿å•è°ƒåŒºé—´ï¼Œç­”æ¡ˆä¸€å®šæ˜¯æ‰€æœ‰å¥‡æ•°ä½ç½®æˆ–è€…æ‰€æœ‰å¶æ•°ä½ç½®çš„å’Œã€‚ä½¿ç”¨ä¸€ä¸ª set å­˜å‚¨æ‰€æœ‰çš„æé•¿å•è°ƒåŒºé—´åˆ†å‰²ç‚¹ï¼ˆç§°ä¸ºæå€¼ç‚¹ï¼Œä»¤ä¸€ä¸ªæå€¼ç‚¹ä»£è¡¨æé•¿å•è°ƒåŒºé—´çš„ç»“æŸï¼‰ï¼Œä¿®æ”¹ä¸€ä¸ªæ•°æ—¶æœ€å¤šåªä¼šå½±å“åˆ°äº”ä¸ªæå€¼ç‚¹ï¼ˆä¿®æ”¹ä¸€ä¸ªæå€¼ç‚¹å¯èƒ½ä½¿å®ƒå³è¾¹çš„æå€¼ç‚¹ä¸å­˜åœ¨ï¼Œè¿›è€Œå½±å“å³è¾¹ç¬¬äºŒä¸ªæå€¼ç‚¹ï¼Œå·¦è¾¹åŒç†ï¼‰ï¼Œå¤æ‚åº¦å¯ä»¥æ¥å—ã€‚ æ ¹æ®æ­¤ç»´æŠ¤å³å¯ï¼Œç»†èŠ‚å¾ˆå¤šã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, a[100005]; i64 ans; set&lt;int> s; struct Fenwick &#123; #define lowbit(x) (x &amp; -x) i64 C[100005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; i64 sum(int x) &#123; i64 res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; &#125; T[2]; void calc(set&lt;int>::iterator l, set&lt;int>::iterator r, int op) &#123; for (; l != r; --r) &#123; auto it = r; --it; if (a[*r] > a[*it]) &#123; // å½“å‰æé•¿å•è°ƒåŒºé—´ä¸å—å‰ä¸€ä¸ªå½±å“ int p = *r &amp; 1; ans += (T[p].sum(*r) - T[p].sum(*it)) * op; &#125; else &#123; int p = *it &amp; 1; ans += (T[p].sum(*r - 1) - T[p].sum(*it)) * op; // è¦çœ‹ r è¿™ä¸ªä½ç½®æœ‰æ²¡æœ‰è¢«ä¿®æ”¹ auto lt = r, rt = r; if (lt != s.begin()) --lt; ++rt; if (rt == s.end()) --rt; // æ²¡æœ‰è¢« it ä¿®æ”¹ï¼Œæ²¡æœ‰è¢«åé¢ä¸€ä¸ªæé•¿å•è°ƒå­åŒºé—´ä¿®æ”¹ if ((*r - *lt) % 2 == 0 &amp;&amp; (*rt - *r) % 2 == 0) ans += a[*r] * op; &#125; &#125; if (a[*l] >= a[*l + 1]) return; // æ­¤æ—¶ l è‡ªå·±ä¿®æ”¹è‡ªå·± auto lt = r, rt = r; if (lt != s.begin()) --lt; ++rt; if (rt == s.end()) --rt; if ((*r - *lt) % 2 == 0 &amp;&amp; (*rt - *r) % 2 == 0) ans += a[*r] * op; &#125; void check(int x) &#123; if ((a[x - 1] &lt; a[x]) == (a[x] &lt; a[x + 1])) s.erase(x); else s.insert(x); &#125; void update(int x, int y) &#123; auto it = s.lower_bound(x), l = it, r = it; --l; if (l != s.begin()) --l; ++r; if (r != s.end()) ++r; if (r == s.end()) --r; calc(l, r, -1); T[x &amp; 1].add(x, y - a[x]); a[x] = y; check(x); if (x > 1) check(x - 1); if (x &lt; n) check(x + 1); calc(l, r, 1); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); s.insert(0); s.insert(n + 1); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), update(i, x); scanf(\"%d\", &amp;m); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); update(x, y); printf(\"%lld\\n\", ans); &#125; return 0; &#125; [Code+#1] Yazid çš„æ–°ç”Ÿèˆä¼š Portal.ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n(nâ‰¤5Ã—105)n(n\\le 5\\times 10^5)n(nâ‰¤5Ã—105) çš„åºåˆ—ï¼Œé—®å…¶ä¸­æœ‰å¤šå°‘ä¸ªå­åŒºé—´å­˜åœ¨å‡ºç°æ¬¡æ•°ä¸¥æ ¼è¶…è¿‡å­åŒºé—´é•¿åº¦ä¸€åŠçš„ä¼—æ•°ã€‚ è€ƒè™‘æšä¸¾æ¯ä¸ªç§ç±»çš„æ•°åˆ†åˆ«è®¡ç®—ï¼Œè®¾å½“å‰é€‰ä¸­çš„æ•°ä¸º wwwï¼ŒSiS_iSiâ€‹ ä¸ºå‰ iii ä¸ªæ•°ä¸­ www çš„ä¸ªæ•°ã€‚ å¯¹äºä¸€æ®µåŒºé—´ [l+1,r][l+1,r][l+1,r]ï¼ˆæ–¹ä¾¿å·®åˆ†ï¼‰ï¼Œæ»¡è¶³æ¡ä»¶æ—¶æœ‰ Srâˆ’Sl&gt;râˆ’lâˆ’(Srâˆ’Sl)â†’2Srâˆ’r&gt;2Slâˆ’lS_r-S_l&gt;r-l-(S_r-S_l)\\rightarrow 2S_r-r&gt;2S_l-lSrâ€‹âˆ’Slâ€‹&gt;râˆ’lâˆ’(Srâ€‹âˆ’Slâ€‹)â†’2Srâ€‹âˆ’r&gt;2Slâ€‹âˆ’lï¼Œä¹Ÿå°±æ˜¯åœ¨æ±‚ Pi=2Siâˆ’iP_i=2S_i-iPiâ€‹=2Siâ€‹âˆ’i çš„é€†åºå¯¹ä¸ªæ•°ã€‚ å¯¹äºåŒä¸€ä¸ª wwwï¼ŒPiP_iPiâ€‹ å¯ä»¥åˆ’åˆ†æˆè‹¥å¹²ä¸ªå•è°ƒé€’å‡åŒºé—´ï¼Œæ€»æ•°åœ¨ O(n)O(n)O(n) çº§åˆ«ã€‚åŒä¸€ä¸ªåŒºé—´å†…æ˜¯æ²¡æœ‰è´¡çŒ®çš„ï¼Œåªéœ€è¦è®¡ç®— lll åœ¨å‰é¢åŒºé—´å†…çš„è´¡çŒ®ã€‚ è®¾ cic_iciâ€‹ ä»£è¡¨ iii åœ¨ PPP ä¸­çš„å‡ºç°æ¬¡æ•°ï¼ˆç”±äºå¯èƒ½æœ‰è´Ÿçš„ï¼Œæ‰€ä»¥éœ€è¦åŠ ä¸Šä¸€ä¸ªåç§»é‡ï¼‰ï¼ŒTTT è¡¨ç¤º cic_iciâ€‹ çš„å‰ç¼€å’Œï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ª PiP_iPiâ€‹ çš„è´¡çŒ®å°±æ˜¯å½“å‰çš„ TPiâˆ’1T_{P_i-1}TPiâ€‹âˆ’1â€‹ã€‚å¯¹äºä¸€æ®µ [x,y][x,y][x,y]ï¼Œæ€»è´¡çŒ®å°±æ˜¯ âˆ‘i=xâˆ’1yâˆ’1Ti\\sum\\limits_{i=x-1}^{y-1}T_ii=xâˆ’1âˆ‘yâˆ’1â€‹Tiâ€‹ï¼Œå†æ±‚ä¸€ä¸ª TTT çš„å‰ç¼€å’Œ GGG å³å¯ã€‚ è¿™ä¸ªä¸œè¥¿å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤ï¼Œå…ˆå°† ccc å·®åˆ†å¾—åˆ°æ•°ç»„ dddï¼ˆå› ä¸ºå¯¹äº ccc è¦è¿›è¡ŒåŒºé—´ä¿®æ”¹ï¼‰ï¼Œç„¶åï¼š Gx=âˆ‘i=1xTi=âˆ‘i=1xâˆ‘j=1icj=âˆ‘i=1xâˆ‘j=1iâˆ‘k=1jdk=âˆ‘i=1x(x+2âˆ’i)(x+1âˆ’i)2di\\begin{aligned} G_x&amp;=\\sum_{i=1}^{x} T_i\\\\ &amp;=\\sum_{i=1}^{x}\\sum_{j=1}^{i}c_j\\\\ &amp;=\\sum_{i=1}^{x}\\sum_{j=1}^{i}\\sum_{k=1}^j d_k\\\\ &amp;=\\sum_{i=1}^x \\frac{(x+2-i)(x+1-i)}{2} d_i \\end{aligned} Gxâ€‹â€‹=i=1âˆ‘xâ€‹Tiâ€‹=i=1âˆ‘xâ€‹j=1âˆ‘iâ€‹cjâ€‹=i=1âˆ‘xâ€‹j=1âˆ‘iâ€‹k=1âˆ‘jâ€‹dkâ€‹=i=1âˆ‘xâ€‹2(x+2âˆ’i)(x+1âˆ’i)â€‹diâ€‹â€‹ å°±å¯ä»¥ä½¿ç”¨ä¸‰ä¸ªæ ‘çŠ¶æ•°ç»„ç»´æŠ¤äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; int n, type; int a[500005]; vector&lt;int> b[500005]; i64 C1[1000005], C2[1000005], C3[1000005]; i64 sum(int x) &#123; i64 res = 0; for (int i = x; i > 0; i -= lowbit(i)) res += C1[i] * (x + 2) * (x + 1) - C2[i] * (2 * x + 3) + C3[i]; return res; &#125; void add(int x, i64 k) &#123; for (int i = x; i &lt;= 2 * n + 1; i += lowbit(i)) C1[i] += k, C2[i] += k * x, C3[i] += k * x * x; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;type); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[a[i]].emplace_back(i); i64 ans = 0; const int N = n + 1; for (int i = 0; i &lt; n; ++i) &#123; b[i].emplace_back(n + 1); int last = 0; for (int j = 0; j &lt; b[i].size(); ++j) &#123; int x = 2 * j - (b[i][j] - 1) + N, y = 2 * j - last + N; ans += sum(y - 1) - sum(x - 2); add(x, 1); add(y + 1, -1); last = b[i][j]; &#125; last = 0; for (int j = 0; j &lt; b[i].size(); ++j) &#123; int x = 2 * j - (b[i][j] - 1) + N, y = 2 * j - last + N; add(x, -1); add(y + 1, 1); last = b[i][j]; &#125; &#125; printf(\"%lld\\n\", ans >> 1); return 0; &#125; [RC-03] è®°å¿† Portal. è€ƒè™‘ä½¿ç”¨åŠ¨æ€è§„åˆ’è§£å†³è¿™ä¸ªé—®é¢˜çš„é™æ€ç‰ˆæœ¬ï¼Œä¸€æ“ä½œä¼šå¯¼è‡´ ansansans å¢å¤§ cnt+1cnt+1cnt+1ï¼Œcntcntcnt å¢å¤§ 111ã€‚äºŒæ“ä½œä¼šå¯¼è‡´ ansansans å¢å¤§ 111ï¼Œcntcntcnt æ¸…é›¶ã€‚è½¬ç§»å¯ä»¥ä½¿ç”¨çŸ©é˜µåˆ»ç”»ï¼Œçº¿æ®µæ ‘ç»´æŠ¤æ—¶é—´è½´å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct Matrix &#123; i64 a[3][3]; Matrix() &#123; memset(a, 0, sizeof a); &#125; friend Matrix operator* (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 3; ++i) for (int k = 0; k &lt; 3; ++k) &#123; i64 r = a.a[i][k]; for (int j = 0; j &lt; 3; ++j) c.a[i][j] += r * b.a[k][j]; &#125; return c; &#125; &#125; T[800005], A, B, C; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = (k == 1 ? A : (k == 2 ? B : C)), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o] = T[o &lt;&lt; 1] * T[o &lt;&lt; 1 | 1]; &#125; int n; int op[200005], p[200005]; bool tag[200005]; int main(void) &#123; A.a[0][0] = A.a[1][0] = A.a[1][1] = A.a[2][0] = A.a[2][1] = A.a[2][2] = 1; B.a[0][0] = B.a[2][0] = B.a[2][1] = B.a[2][2] = 1; C.a[0][0] = C.a[1][1] = C.a[2][2] = 1; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n * 4; ++i) T[i] = C; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", op + i); if (op[i] != 3) p[i] = i; else scanf(\"%d\", p + i); if (op[i] == 1) update(1, 1, n, i, 1); else if (op[i] == 2) update(1, 1, n, i, 2); else &#123; p[i] = p[p[i]]; if (tag[p[i]]) tag[p[i]] = 0, update(1, 1, n, p[i], op[p[i]]); else tag[p[i]] = 1, update(1, 1, n, p[i], 3); &#125; Matrix tmp; tmp.a[0][0] = tmp.a[0][1] = tmp.a[0][2] = 1; printf(\"%lld\\n\", (tmp * T[1]).a[0][0]); &#125; return 0; &#125; [çœé€‰è”è€ƒ 2020 A/B å·] å†°ç«æˆ˜å£« Portal. å°†æ¸©åº¦ç¦»æ•£åŒ–ï¼Œé‚£ä¹ˆæ±‚çš„å°±æ˜¯å†°äººå‰ç¼€å’Œï¼ˆIpI_pIpâ€‹ï¼‰å’Œç«äººåç¼€å’Œï¼ˆå‰ç¼€å’Œè®°ä¸º FpF_pFpâ€‹ï¼‰çš„æœ€å°å€¼æœ€å¤§ä¸ºå¤šå°‘ã€‚ç”±äºèƒ½åŠ›å€¼ä¸ä¸ºè´Ÿï¼Œå› æ­¤åªéœ€è¦æ±‚å‡º Ipâ‰¤Fsumâˆ’Fpâˆ’1I_p\\le F_{sum}-F_{p-1}Ipâ€‹â‰¤Fsumâ€‹âˆ’Fpâˆ’1â€‹ çš„æœ€å¤§ ppp å’Œ Ipâ‰¥Fsumâˆ’Fpâˆ’1I_p\\ge F_{sum}-F_{p-1}Ipâ€‹â‰¥Fsumâ€‹âˆ’Fpâˆ’1â€‹ çš„æœ€å¤§ pppï¼ˆä½†æ˜¯ Fpâˆ’1F_{p-1}Fpâˆ’1â€‹ æœ€å°ï¼‰ã€‚ å‰è€…å¥½æï¼Œä½†æ˜¯åè€…æ€ä¹ˆæ±‚ï¼Ÿè€ƒè™‘å°† FFF å¹³ç§»ä¸€ä½ï¼Œæ¡ä»¶ä¸€å˜æˆ Ipâ‰¤Fsumâˆ’FpI_p\\le F_{sum}-F_{p}Ipâ€‹â‰¤Fsumâ€‹âˆ’Fpâ€‹ï¼Œæ¡ä»¶äºŒå˜æˆ Ipâ‰¥Fsumâˆ’FpI_p\\ge F_{sum}-F_{p}Ipâ€‹â‰¥Fsumâ€‹âˆ’Fpâ€‹ã€‚å½“æ±‚å‡ºå‰é¢çš„ ppp åï¼Œå– pâ†p+1p\\leftarrow p+1pâ†p+1ï¼Œé‚£ä¹ˆæ­¤æ—¶ ppp å°±æ˜¯æ»¡è¶³æ¡ä»¶äºŒçš„æœ€å° pppï¼Œç„¶åå†æ¬¡å€å¢å‡ºæœ€å¤§çš„ ppp å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 2e6 + 5; int Q, n, b[N]; int op[N], t[N], x[N], y[N]; int ice[N], fire[N], FS; void add(int x, int k, int *c) &#123; while (x &lt;= n) c[x] += k, x += x &amp; -x; &#125; int main(void) &#123; scanf(\"%d\", &amp;Q); int tot = 0; for (int i = 1; i &lt;= Q; ++i) &#123; scanf(\"%d\", op + i); if (op[i] == 1) scanf(\"%d%d%d\", t + i, x + i, y + i), b[++tot] = x[i]; else scanf(\"%d\", t + i); &#125; sort(b + 1, b + tot + 1); n = unique(b + 1, b + tot + 1) - (b + 1); for (int i = 1; i &lt;= Q; ++i) x[i] = lower_bound(b + 1, b + n + 1, x[i]) - b; for (int i = 1; i &lt;= Q; ++i) &#123; if (op[i] == 2) x[i] = x[t[i]], y[i] = -y[t[i]], t[i] = t[t[i]]; if (t[i] == 0) add(x[i], y[i], ice); else add(x[i] + 1, y[i], fire), FS += y[i]; int I = 0, F = 0, p = 0; for (int j = 20; j >= 0; --j) &#123; p ^= 1 &lt;&lt; j; if (p > n || I + ice[p] > FS - F - fire[p]) p ^= 1 &lt;&lt; j; else I += ice[p], F += fire[p]; &#125; int tot = I; if (p &lt; n) &#123; int x = p + 1, _F = 0; for (; x; x -= x &amp; -x) _F += fire[x]; if (I &lt;= FS - _F) &#123; p = F = 0; tot = FS - _F; for (int j = 20; j >= 0; --j) &#123; p ^= 1 &lt;&lt; j; if (p > n || F + fire[p] > _F) p ^= 1 &lt;&lt; j; else F += fire[p]; &#125; &#125; &#125; if (tot) printf(\"%d %d\\n\", b[p], tot * 2); else puts(\"Peace\"); &#125; return 0; &#125; [CF187D] BRT Contract Portal. å¦‚æœç­‰äº†ä¸€ä¸ªç¯é‚£ä¹ˆåé¢å°±éƒ½æ˜¯ä¸€æ ·çš„äº†ï¼Œè¿™ä¸ªå› æ­¤é—®é¢˜æ˜¯å¦‚ä½•æ‰¾åˆ°ç¬¬ä¸€ä¸ªç­‰çš„ç¯ã€‚ ä»å¼€å§‹åˆ°ä½ç½® iii çš„è·ç¦»æ¨¡ m=(g+r)m=(g+r)m=(g+r) çš„ä½™æ•°ä¸º pppï¼Œå‡ºå‘æ—¶é—´ä¸º tttï¼Œå¦‚æœ gâ‰¤(t+p) mod (g+r)g\\le (t+p)\\bmod (g+r)gâ‰¤(t+p)mod(g+r) å°±éœ€è¦ç­‰è¿™ä¸ªçº¢ç¯ã€‚å¦‚æœè¦ç­‰çº¢ç¯ï¼Œttt çš„å–å€¼æœ‰ä¸¤ç§æƒ…å†µï¼š pâ‰¤g:tâˆˆ[gâˆ’p,g+râˆ’pâˆ’1]p&gt;g:tâˆˆ[0,g+râˆ’pâˆ’1]âˆª[mâˆ’p+g,mâˆ’1]p\\le g: t\\in [g-p,g+r-p-1]\\\\ p&gt;g: t\\in [0,g+r-p-1]\\cup [m-p+g,m-1] pâ‰¤g:tâˆˆ[gâˆ’p,g+râˆ’pâˆ’1]p&gt;g:tâˆˆ[0,g+râˆ’pâˆ’1]âˆª[mâˆ’p+g,mâˆ’1] é‚£ä¹ˆæä¸€ä¸ªåŒºé—´æŸ“è‰²å•ç‚¹æŸ¥è¯¢çš„åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘å°±è¡Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct Node &#123; int ls, rs; int val; &#125; T[20000005]; int n, g, r, m, q, tot = 1, rt; i64 d[100005], f[100005]; inline void pushdown(int o, int l, int r) &#123; if (r - l + 1 > 1 &amp;&amp; T[o].val) &#123; if (!T[o].ls) T[o].ls = ++tot; if (!T[o].rs) T[o].rs = ++tot; T[T[o].ls].val = T[T[o].rs].val = T[o].val; T[o].val = 0; &#125; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; pushdown(o, l, r); if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].val = k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, l, mid, x, y, k); if (mid &lt; y) update(T[o].rs, mid + 1, r, x, y, k); &#125; int query(int o, int l, int r, int x) &#123; pushdown(o, l, r); if (l == r) return T[o].val; int mid = l + r >> 1; if (x &lt;= mid) return query(T[o].ls, l, mid, x); return query(T[o].rs, mid + 1, r, x); &#125; inline i64 query(int t) &#123; int p = query(rt, 0, m - 1, t % m); i64 ans = t + f[p] + d[p]; if (p &lt;= n) ans += m - (d[p] + t) % m; return ans; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;g, &amp;r); m = g + r; for (int i = 1; i &lt;= n + 1; ++i) scanf(\"%lld\", d + i), d[i] += d[i - 1]; update(rt, 0, m - 1, 0, m - 1, n + 1); for (int i = n; i >= 1; --i) &#123; int p = m - d[i] % m; f[i] = query(p) - d[i] - p; p = d[i] % m; if (p &lt;= g) update(rt, 0, m - 1, g - p, g + r - p - 1, i); else update(rt, 0, m - 1, 0, g + r - p - 1, i), update(rt, 0, m - 1, m - p + g, m - 1, i); &#125; for (scanf(\"%d\", &amp;q); q--; ) &#123; int t; scanf(\"%d\", &amp;t); printf(\"%lld\\n\", query(t)); &#125; return 0; &#125; çº¿æ®µæ ‘åˆ†è£‚ä¸åˆå¹¶ å‡ ä¹éƒ½æ˜¯åˆå¹¶çš„é¢˜ã€‚ [POI2011] ROT-Tree Rotations Portal. ç›´æ¥ dfs éå†è¿™æ£µæ ‘ï¼Œç”¨çº¿æ®µæ ‘ç»´æŠ¤æƒå€¼ã€‚äº¤æ¢å·¦å³å­æ ‘åªä¼šå¯¹è·¨è¶Šè¿™ä¸¤æ£µå­æ ‘çš„é€†åºå¯¹äº§ç”Ÿå½±å“ï¼Œç»Ÿè®¡è¿™ä¸ªå°±åªå‰©çº¿æ®µæ ‘åˆå¹¶äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 200000; int n; i64 ans, u, v; struct Node &#123; int ls, rs; int siz; &#125; T[22 * N]; int tot; void update(int &amp;o, int l, int r, int x) &#123; if (!o) o = ++tot; T[o].siz += 1; if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, l, mid, x); else update(T[o].rs, mid + 1, r, x); return; &#125; int merge(int p, int q, int l, int r) &#123; if (!p || !q) return p + q; if (l == r) return T[p].siz += T[q].siz, p; int mid = l + r >> 1; u += 1ll * T[T[p].rs].siz * T[T[q].ls].siz; v += 1ll * T[T[p].ls].siz * T[T[q].rs].siz; T[p].ls = merge(T[p].ls, T[q].ls, l, mid); T[p].rs = merge(T[p].rs, T[q].rs, mid + 1, r); T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz; return p; &#125; int dfs(void) &#123; int pos = 0, val; scanf(\"%d\", &amp;val); if (!val) &#123; int ls = dfs(), rs = dfs(); u = v = 0; pos = merge(ls, rs, 1, n); ans += min(u, v); &#125; else update(pos, 1, n, val); return pos; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); dfs(); printf(\"%lld\\n\", ans); return 0; &#125; [æ¹–å—é›†è®­] æ›´ä¸ºå‰å®³ Portal. å¦‚æœ aaa æ˜¯ bbb çš„ç¥–å…ˆï¼Œé‚£ä¹ˆå¯ä»¥éšä¾¿é€‰ã€‚å¦åˆ™åªèƒ½é€‰ bbb å­æ ‘å†…çš„ cccï¼ˆè€Œä¸”ä¸èƒ½é€‰ bbbï¼‰ï¼Œçº¿æ®µæ ‘åˆå¹¶é¢„å¤„ç†å‡ºæ¯æ£µå­æ ‘ä»¥æ·±åº¦ä¸ºå€¼åŸŸçš„å€¼åŸŸçº¿æ®µæ ‘ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, dep[300005], siz[300005]; vector&lt;int> G[300005]; struct Node &#123; int ls, rs; i64 val; &#125; T[9000005]; int tot, root[300005]; void update(int &amp;o, int l, int r, int x, int k) &#123; if (!o) o = ++tot; T[o].val += k; if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, l, mid, x, k); else update(T[o].rs, mid + 1, r, x, k); &#125; i64 query(int o, int l, int r, int x, int y) &#123; if (!o) return 0; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].val; int mid = l + r >> 1; i64 res = 0; if (x &lt;= mid) res += query(T[o].ls, l, mid, x, y); if (mid &lt; y) res += query(T[o].rs, mid + 1, r, x, y); return res; &#125; int merge(int p, int q, int l, int r) &#123; if (p == 0 || q == 0) return p + q; int mid = l + r >> 1, o = ++tot; T[o].ls = merge(T[p].ls, T[q].ls, l, mid); T[o].rs = merge(T[p].rs, T[q].rs, mid + 1, r); T[o].val = T[p].val + T[q].val; return o; &#125; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; siz[x] = 1; for (int y : G[x]) if (y != fa) dfs(y, x), siz[x] += siz[y]; update(root[x], 1, n, dep[x], siz[x] - 1); if (fa) root[fa] = merge(root[fa], root[x], 1, n); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); while (m--) &#123; int x, k; scanf(\"%d%d\", &amp;x, &amp;k); printf(\"%lld\\n\", query(root[x], 1, n, dep[x] + 1, dep[x] + k) + 1ll * min(k, dep[x] - 1) * (siz[x] - 1)); &#125; return 0; &#125; [NOI2020] å‘½è¿ Portal. è€ƒè™‘è®¾ fx,yf_{x,y}fx,yâ€‹ ä»£è¡¨ä»¥ xxx ä¸ºæ ¹çš„å­æ ‘ä¸­å·²ç»å…¨éƒ¨æ»¡è¶³ï¼Œä¸æ»¡è¶³çš„è·ç¦»æœ€å¤šä¸º yyyï¼ˆä»æ ¹èŠ‚ç‚¹å‘ä¸‹å¼€å§‹ï¼‰çš„æ–¹æ¡ˆæ•°ï¼Œç­”æ¡ˆä¸º f1,0f_{1,0}f1,0â€‹ã€‚ è€ƒè™‘æ¯æ¬¡å°† (x,y)(x,y)(x,y) åˆå¹¶è¿›å½“å‰ç­”æ¡ˆï¼Œåˆ†åˆ«è€ƒè™‘è¿™æ¡è¾¹å¡« 1/01/01/0 çš„è´¡çŒ®ï¼š fx,iâ€²â†âˆ‘j=0depxfx,ify,j+âˆ‘j=0ifx,ify,j+âˆ‘j=0iâˆ’1fx,jfy,if&#x27;_{x,i} \\leftarrow \\sum_{j=0}^{dep_x} f_{x,i}f_{y,j}+\\sum_{j=0}^{i} f_{x,i}f_{y,j}+\\sum_{j=0}^{i-1} f_{x,j}f_{y,i} fx,iâ€²â€‹â†j=0âˆ‘depxâ€‹â€‹fx,iâ€‹fy,jâ€‹+j=0âˆ‘iâ€‹fx,iâ€‹fy,jâ€‹+j=0âˆ‘iâˆ’1â€‹fx,jâ€‹fy,iâ€‹ è®¾ gx,y=âˆ‘i=0yfx,ig_{x,y}=\\sum_{i=0}^y f_{x,i}gx,yâ€‹=âˆ‘i=0yâ€‹fx,iâ€‹ï¼Œåˆ™ï¼š fx,iâ€²=fx,i(gy,depx+gy,i)+fy,igx,iâˆ’1f&#x27;_{x,i}=f_{x,i}(g_{y,dep_x}+g_{y,i})+f_{y,i}g_{x,i-1} fx,iâ€²â€‹=fx,iâ€‹(gy,depxâ€‹â€‹+gy,iâ€‹)+fy,iâ€‹gx,iâˆ’1â€‹ æ‰€æœ‰çš„è½¬ç§»ä½ç½®éƒ½åªä¸æ·±åº¦æœ‰å…³ï¼Œå› æ­¤ç›´æ¥çº¿æ®µæ ‘åˆå¹¶ï¼Œç»´æŠ¤åŒºé—´ä¹˜æ³•çš„ä¿®æ”¹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int n, q; vector&lt;int> G[500005], p[500005]; int dep[500005]; int f[5005][5005], g[5005][5005]; struct Node &#123; int ls, rs; int dat, tag; #define ls(x) T[x].ls #define rs(x) T[x].rs #define dat(x) T[x].dat #define tag(x) T[x].tag &#125; T[10000005]; int tot, rt[2000005]; void update(int &amp;o, int l, int r, int x) &#123; o = ++tot; dat(o) = tag(o) = 1; if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(ls(o), l, mid, x); else update(rs(o), mid + 1, r, x); &#125; inline void pushdown(int o) &#123; if (ls(o)) &#123; dat(ls(o)) = 1ll * dat(ls(o)) * tag(o) % P; tag(ls(o)) = 1ll * tag(ls(o)) * tag(o) % P; &#125; if (rs(o)) &#123; dat(rs(o)) = 1ll * dat(rs(o)) * tag(o) % P; tag(rs(o)) = 1ll * tag(rs(o)) * tag(o) % P; &#125; tag(o) = 1; &#125; int query(int o, int l, int r, int x) &#123; if (!o || r &lt;= x) return dat(o); pushdown(o); int mid = l + r >> 1, ans = query(ls(o), l, mid, x); if (mid &lt; x) ans = (ans + query(rs(o), mid + 1, r, x)) % P; return ans; &#125; int merge(int x, int y, int l, int r, int &amp;s1, int &amp;s2) &#123; // s1 ä¸º g(y, i)ï¼Œs2 ä¸º g(x, i-1) if (!x &amp;&amp; !y) return 0; if (!x || !y) &#123; if (!x) &#123; s1 = (s1 + dat(y)) % P; dat(y) = 1ll * dat(y) * s2 % P; tag(y) = 1ll * tag(y) * s2 % P; return y; &#125; s2 = (s2 + dat(x)) % P; dat(x) = 1ll * dat(x) * s1 % P; tag(x) = 1ll * tag(x) * s1 % P; return x; &#125; if (l == r) &#123; int tmp = dat(x); s1 = (s1 + dat(y)) % P; dat(x) = (1ll * dat(x) * s1 + 1ll * dat(y) * s2) % P; s2 = (s2 + tmp) % P; return x; &#125; pushdown(x); pushdown(y); int mid = l + r >> 1; ls(x) = merge(ls(x), ls(y), l, mid, s1, s2); rs(x) = merge(rs(x), rs(y), mid + 1, r, s1, s2); dat(x) = (dat(ls(x)) + dat(rs(x))) % P; return x; &#125; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; int mx = 0; for (int i : p[x]) mx = max(mx, dep[i]); update(rt[x], 0, n, mx); for (int y : G[x]) if (y != fa) &#123; dfs(y, x); int s1 = query(rt[y], 0, n, dep[x]), s2 = 0; rt[x] = merge(rt[x], rt[y], 0, n, s1, s2); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].emplace_back(y); G[y].emplace_back(x); &#125; scanf(\"%d\", &amp;q); while (q--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); p[y].emplace_back(x); &#125; dfs(1, 0); return !printf(\"%d\\n\", query(rt[1], 0, n, 0)); &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"æ•°æ®ç»“æ„","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"æ ‘çŠ¶æ•°ç»„","slug":"æ ‘çŠ¶æ•°ç»„","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"å¤æ‚ç»“æ„ä¸Šçš„ DP é—®é¢˜","slug":"notes/DP/graph-dp","date":"2022-11-05T00:00:00.000Z","updated":"2023-10-30T00:00:00.000Z","comments":true,"path":"c2587cc4/","link":"","permalink":"https://james1badcreeper.github.io/c2587cc4/","excerpt":"ä¹‹å‰çš„ DP éƒ½æ˜¯åœ¨çº¿æ€§ç»“æ„ä¸Šè¿›è¡Œçš„ï¼Œå®é™…ä¸Š DP è¿˜å¯ä»¥åœ¨æ ‘ä¸Šæˆ–è€… DAG ä¸Šè¿›è¡Œã€‚æœ¬æ–‡å°†å¯¹è¿™äº›å†…å®¹è¿›è¡Œç®€å•çš„ä»‹ç»ã€‚","text":"ä¹‹å‰çš„ DP éƒ½æ˜¯åœ¨çº¿æ€§ç»“æ„ä¸Šè¿›è¡Œçš„ï¼Œå®é™…ä¸Š DP è¿˜å¯ä»¥åœ¨æ ‘ä¸Šæˆ–è€… DAG ä¸Šè¿›è¡Œã€‚æœ¬æ–‡å°†å¯¹è¿™äº›å†…å®¹è¿›è¡Œç®€å•çš„ä»‹ç»ã€‚ æ›´æ–°æ—¥å¿— 2023/10/30æ›´æ–°äº†å°‘è®¸æ‚é¢˜ã€‚ æ ‘å½¢ DP æ ‘å½¢ DP å°±æ˜¯å°†åœ¨çº¿æ€§ç»“æ„ä¸Šçš„ DP å˜åˆ°äº†æ ‘ä¸Šã€‚ æ¦‚å¿µ æ—¢ç„¶ DP éƒ½é•¿åˆ°æ ‘ä¸Šå»äº†ï¼Œé‚£ä¹ˆè‚¯å®šæœ‰ä¸ä¸€æ ·çš„åœ°æ–¹ã€‚ ç”±äºæ ‘å›ºæœ‰çš„é€’å½’æ€§è´¨ï¼Œæ ‘å½¢ DP ä¸€èˆ¬éƒ½æ˜¯é€’å½’è¿›è¡Œçš„ã€‚åœ¨æ ‘å½¢ DP ä¸­ï¼Œæˆ‘ä»¬ä¼šé€‰æ ¹èŠ‚ç‚¹ä¸º DP çš„å¼€å§‹ï¼Œç„¶åå¯¹äºå®ƒçš„æ¯æ£µå­æ ‘è¿›è¡Œé€’å½’ï¼Œç„¶åè€ƒè™‘è½¬ç§»ã€‚é€’å½’åˆ°äº†ä¸€ä¸ªå¶å­èŠ‚ç‚¹ï¼Œå°±å¯ä»¥è¿›è¡Œåˆå§‹åŒ–äº†ã€‚ åŸºç¡€ä¾‹é¢˜ ä¹‹æ‰€ä»¥å¤§å¤šæ•°æ•™ç¨‹éƒ½ç›´æ¥ä¸Šé¢˜ï¼Œæ˜¯å› ä¸ºè¿™ç©æ„æ²¡æ³•è®²ï¼ ä¹‹å‰è¯´äº†æ ‘å½¢ DP å°±æ˜¯åœ¨æ ‘ä¸Šè¿›è¡Œ DPï¼Œå°±æ˜¯æŠŠçŠ¶æ€çš„è½¬ç§»ç§»åˆ°äº†æ ‘ä¸Šã€‚ä½†è¿™ä¹ˆè¯´æ²¡äººèƒ½å¬å¾—æ‡‚ï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½é€šè¿‡é¢˜ç›®æ¥å­¦ä¹ ï¼Œé‚£ä¹ˆå°±æ¥å§ã€‚ [Luogu P1352] æ²¡æœ‰ä¸Šå¸çš„èˆä¼š Portal. æŸå¤§å­¦æœ‰ nnn ä¸ªèŒå‘˜ï¼Œç¼–å·ä¸º 1â€¦n1\\ldots n1â€¦nã€‚ä»–ä»¬ä¹‹é—´æœ‰ä»å±å…³ç³»ï¼Œä¹Ÿå°±æ˜¯è¯´ä»–ä»¬çš„å…³ç³»å°±åƒä¸€æ£µä»¥æ ¡é•¿ä¸ºæ ¹çš„æ ‘ï¼Œçˆ¶ç»“ç‚¹å°±æ˜¯å­ç»“ç‚¹çš„ç›´æ¥ä¸Šå¸ã€‚ç°åœ¨æœ‰ä¸ªå‘¨å¹´åº†å®´ä¼šï¼Œå®´ä¼šæ¯é‚€è¯·æ¥ä¸€ä¸ªèŒå‘˜éƒ½ä¼šå¢åŠ ä¸€å®šçš„å¿«ä¹æŒ‡æ•° rir_iriâ€‹,ä½†æ˜¯å‘¢ï¼Œå¦‚æœæŸä¸ªèŒå‘˜çš„ç›´æ¥ä¸Šå¸æ¥å‚åŠ èˆä¼šäº†ï¼Œé‚£ä¹ˆè¿™ä¸ªèŒå‘˜å°±æ— è®ºå¦‚ä½•ä¹Ÿä¸è‚¯æ¥å‚åŠ èˆä¼šäº†ã€‚è®¡ç®—é‚€è¯·å“ªäº›èŒå‘˜å¯ä»¥ä½¿å¿«ä¹æŒ‡æ•°æœ€å¤§ï¼Œæ±‚æœ€å¤§çš„å¿«ä¹æŒ‡æ•°ã€‚ æ ¹æ®åˆšæ‰çš„è®²è§£å’Œåœ¨çº¿æ€§ DP ä¸­çš„ç»éªŒï¼Œæˆ‘ä»¬å¯ä»¥è®¾ f[x]f[x]f[x] ä¸º xxx çš„å­æ ‘çš„æœ€å¤§çš„å¿«ä¹æŒ‡æ•°ã€‚ ä½†è¿™æ ·ä¸è¡Œï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“ xxx æ˜¯å¦å‚åŠ èˆä¼šï¼Œæ¥åˆ¤æ–­ xxx çš„ä¸Šå¸æ˜¯å¦èƒ½å‚åŠ èˆä¼šã€‚ é‚£ä¹ˆæ ¹æ®åœ¨çº¿æ€§ DP ä¸­è®²è¿‡çš„â€œæ‰“ä¸è¿‡å°±åŠ å…¥â€ï¼Œæˆ‘ä»¬å¯ä»¥è®¾ f[x][0]f[x][0]f[x][0] ä¸º xxx ä¸å‚åŠ èˆä¼šï¼Œf[x][1]f[x][1]f[x][1] ä¸º xxx å‚åŠ èˆä¼šã€‚ é‚£ä¹ˆæ ¹æ®é¢˜æ„ï¼Œä¾¿æœ‰è½¬ç§»ï¼š f[x][0]=âˆ‘sâˆˆson[x]maxâ¡(f[x][0],f[x][1])f[x][0] = \\sum\\limits_{s\\in son[x]}\\max(f[x][0], f[x][1]) f[x][0]=sâˆˆson[x]âˆ‘â€‹max(f[x][0],f[x][1]) f[x][1]=r[x]+âˆ‘sâˆˆson[x]f[x][0]f[x][1] = r[x] + \\sum\\limits_{s\\in son[x]}f[x][0] f[x][1]=r[x]+sâˆˆson[x]âˆ‘â€‹f[x][0] é‚£ä¹ˆä»£ç å°±å¾ˆå®¹æ˜“å†™å‡ºæ¥äº†ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; int n; int r[6005]; bool v[6005]; vector &lt;int> son[6005]; int f[6005][2]; void dp(int o) &#123; f[o][0] = 0; // ä¸å‚åŠ ï¼Œåˆå§‹ä¸º 0 f[o][1] = r[o]; // å‚åŠ ï¼Œåˆå§‹ä¸º r[o] for (int i = 0; i &lt; son[o].size(); ++i) // éå†æ‰€æœ‰å­æ ‘ &#123; int y = son[o][i]; dp(y); // é€’å½’è¿›è¡Œ f[o][0] += max(f[y][0], f[y][1]); // å¯ä»¥å‚åŠ æˆ–ä¸å‚åŠ  f[o][1] += f[y][0]; // åªèƒ½ä¸å‚åŠ  &#125; &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) r[i] = read(); for (int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); v[x] = 1; son[y].push_back(x); &#125; int root; for (int i = 1; i &lt;= n; ++i) if (!v[i]) &#123; root = i; // å¯»æ‰¾æ ¹èŠ‚ç‚¹å¼€å§‹ DP break; &#125; dp(root); cout &lt;&lt; max(f[root][0], f[root][1]) &lt;&lt; endl; // è¦å–æœ€å¤§å€¼ return 0; &#125; çŠ¶æ€æœ‰ O(n)O(n)O(n) ä¸ªï¼Œæ¯ä¸ªçŠ¶æ€åœ¨è½¬ç§»æ—¶éƒ½ä¼šè¢«è€ƒè™‘ä¸€æ¬¡ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ æ ‘å½¢ DP è¿˜æœ‰å¦ä¸€ç§å®ç°æ–¹å¼ï¼šä»¥æ‹“æ‰‘åºè‡ªåº•å‘ä¸Šè¿­ä»£ï¼Œé€Ÿåº¦æ¯”ä¸Šè¿°é€’å½’æ–¹æ³•å¿«ä¸€ç‚¹ï¼Œä½†å®ç”¨æ€§ä¸é«˜ã€‚æ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œäº†è§£ã€‚ [Luogu P2016] æˆ˜ç•¥æ¸¸æˆ Portal. n(nâ‰¤1500)n(n\\le 1500)n(nâ‰¤1500) çš„æ ‘ã€‚ä»–è¦åœ¨è¿™æ£µæ ‘çš„ç»“ç‚¹ä¸Šæ”¾ç½®æœ€å°‘æ•°ç›®çš„å£«å…µï¼Œä½¿å¾—è¿™äº›å£«å…µèƒ½äº†æœ›åˆ°æ‰€æœ‰çš„è·¯ã€‚ä»–è¦åœ¨è¿™æ£µæ ‘çš„ç»“ç‚¹ä¸Šæ”¾ç½®æœ€å°‘æ•°ç›®çš„å£«å…µï¼Œä½¿å¾—è¿™äº›å£«å…µèƒ½äº†æœ›åˆ°æ‰€æœ‰çš„è·¯ã€‚ è¿™é“é¢˜å’Œä¸Šé“å¾ˆç›¸ä¼¼ï¼Œä½†å¯ä»¥æ³¨æ„åˆ°è¿™æ˜¯ä¸€æ£µæ— æ ¹æ ‘ã€‚è€Œæƒ³è¦åšæ ‘å½¢ DPï¼Œå°±å¿…é¡»æœ‰æ ¹ã€‚ é‚£æ€ä¹ˆåŠå‘¢ï¼Ÿè½¬æˆæœ‰æ ¹æ ‘å°±è¡Œäº†ã€‚éšä¾¿æ‰¾ä¸€ä¸ªç»“ç‚¹ä½œæ ¹ï¼Œä»£ç å¦‚ä¸‹ï¼š for (int i = 0; i &lt; n; ++i) &#123; int o = read(), k = read(); for (int j = 0; j &lt; k; ++j) &#123; int t = read(); G[o].push_back(t); G[t].push_back(o); &#125; &#125; v[0] = -1; dfs(0); è¿™é‡Œçš„ vvv æ•°ç»„ä»£è¡¨ v[o]v[o]v[o] çš„çˆ¶äº²ã€‚dfs(o) ä»£è¡¨éå†èŠ‚ç‚¹ oooã€‚ dfs çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š void dfs(int o) &#123; done[o] = 1; for (int i = 0; i &lt; G[o].size(); ++i) &#123; if (done[G[o][i]] == 0) &#123; son[o].push_back(G[o][i]); v[G[o][i]] = o; dfs(G[o][i]); &#125; &#125; &#125; è¿™é‡Œç”¨äº†ä¸€ä¸ª done æ•°ç»„æ¥é˜²æ­¢é‡å¤éå†ï¼Œè¿˜æœ‰ä¸€ç§æ–¹å¼å¦‚ä¸‹ï¼š void dfs(int o, int fa) &#123; for (int i = 0; i &lt; G[o].size(); ++i) if (G[o][i] != fa) &#123; son[o].push_back(G[o][i]); dfs(G[o][i], o); &#125; &#125; ä¸ºä»€ä¹ˆå¯ä»¥è¿™æ ·åšå‘¢ï¼Ÿå› ä¸ºåŠ çš„æ˜¯æ— å‘è¾¹ï¼Œæ¥å›éå†æ—¶æ‰ä¼šé€ æˆé‡å¤éå†ã€‚ æˆ‘ä»¬è®¾ f(i,0)f(i,0)f(i,0) ä»£è¡¨åœ¨ iii çš„ä½ç½®ä¸Šä¸æ”¾å£«å…µï¼Œf(i,1)f(i,1)f(i,1) ä»£è¡¨åœ¨ iii çš„ä½ç½®ä¸Šæ”¾å£«å…µï¼Œå®ƒä»¬çš„å­æ ‘æ‰€éœ€è¦çš„æœ€å°‘å£«å…µã€‚ é‚£ä¹ˆå®Œæ•´ä»£ç å°±å¾ˆå®¹æ˜“å†™å‡ºæ¥äº†ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int f[1505][2]; bool done[1505]; vector &lt;int> son[1505]; vector &lt;int> G[1505]; void dfs(int o, int fa) &#123; done[o] = 1; for (int i = 0; i &lt; G[o].size(); ++i) if (done[G[o][i]] == 0) &#123; son[o].push_back(G[o][i]); dfs(G[o][i], o); &#125; &#125; void dp(int o) &#123; f[o][0] = 0; f[o][1] = 1; for (int i = 0; i &lt; son[o].size(); ++i) &#123; int y = son[o][i]; dp(y); f[o][0] += f[y][1]; // å¿…é¡»æ”¾ f[o][1] += min(f[y][0], f[y][1]); // å¯æ”¾å¯ä¸æ”¾ &#125; &#125; int main(void) &#123; n = read(); for (int i = 0; i &lt; n; ++i) &#123; int o = read(), k = read(); for (int j = 0; j &lt; k; ++j) &#123; int t = read(); G[o].push_back(t); G[t].push_back(o); &#125; &#125; dfs(0, -1); dp(0); cout &lt;&lt; min(f[0][0], f[0][1]) &lt;&lt; endl; return 0; &#125; [Luogu P1122] æœ€å¤§å­æ ‘å’Œ Portal. è¿™è·Ÿä¸Šä¸€é¢˜å¾ˆç›¸ä¼¼ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä¸å»ºæ ‘ï¼Œç›´æ¥åœ¨ DP çš„æ—¶å€™åˆ¤æ–­æ˜¯å¦æ¥è‡ª fa å³å¯ã€‚æ±‚æœ€å¤§å­æ ‘å’Œï¼Œåªéœ€è¦å°†æ­£çš„å­æ ‘åŠ ä¸Šå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n; int a[16005], f[16005]; vector &lt;int> G[16005]; void dp(int o, int fa) &#123; f[o] = a[o]; for (int i = 0; i &lt; G[o].size(); ++i) &#123; int y = G[o][i]; if (y == fa) continue; dp(y, o); if (f[y] > 0) f[o] += f[y]; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1, 0); int ans = -2e9; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; å…³äºæ ‘å½¢ DP æœ‰ä¸€ä¸ªé—®é¢˜ï¼šä¸ºä»€ä¹ˆæˆ‘ä»¬å¯ä»¥éšä¾¿é€‰ä¸€ä¸ªç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹è¿›è¡Œ DP å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºåœ¨è€ƒè™‘å­æ ‘çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœä¸€ä¸ªä»¥ root èŠ‚ç‚¹ä¸ºæ ¹çš„ç­”æ¡ˆä¼šæ›´å¥½ï¼Œå®ƒè¦ä¹ˆç›¸å½“äºä¸€æ£µå­æ ‘ï¼Œè¦ä¹ˆç›¸å½“äºå®ƒçš„ä¸€ä¸ªå­™è¾ˆçš„å­æ ‘ã€‚ å½“ç„¶ä¹Ÿæœ‰ä¾‹å¤–ï¼Œæˆ‘ä»¬å¾ˆå¿«å°±ä¼šè§åˆ°ã€‚ [ZJOI2007] æ—¶æ€åŒæ­¥ Portal. n(nâ‰¤105)n(n\\le 10^5)n(nâ‰¤105) ä¸ªç‚¹çš„æœ‰æ ¹æ ‘ï¼Œæœ‰è¾¹æƒï¼Œä¸€æ¬¡æ“ä½œå¯ä»¥å°†æŸæ¡è¾¹çš„è¾¹æƒ +1+1+1ã€‚æ±‚æœ€å°‘ä½¿ç”¨å¤šå°‘æ¬¡æ“ä½œï¼Œå¯ä»¥è®©æ‰€æœ‰å¶å­ç»“ç‚¹åˆ°æ ¹çš„è·ç¦»ç›¸åŒã€‚ å¾ˆå®¹æ˜“æƒ³åˆ°ä¸€ä¸ªè´ªå¿ƒåšæ³•ï¼šä¼˜å…ˆè°ƒæ•´é ä¸Šçš„è¾¹ã€‚ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºä¸å…¶åœ¨å¶å­èŠ‚ç‚¹çš„è¾¹æƒéƒ½ +1+1+1ï¼Œä¸å¦‚ç›´æ¥åœ¨çˆ¶äº²èŠ‚ç‚¹çš„è¾¹ +1+1+1ã€‚è¿™æ ·ï¼Œä¸€ä¸ªèŠ‚ç‚¹åªéœ€è¦è°ƒæ•´å®ƒçš„å­æ ‘ï¼Œä¿è¯å®ƒçš„å­æ ‘è¾¹æƒç›¸åŒå³å¯ï¼Œå‰©ä¸‹çš„äº¤ç»™å®ƒçš„çˆ¶äº²ã€‚ é‚£æˆ‘ä»¬è®° f(x)f(x)f(x) ä¸ºè°ƒæ•´å¥½ xxx çš„å­æ ‘çš„æœ€å°‘æ“ä½œæ•°ã€‚ä½†æ˜¯æƒ³è¦æˆåŠŸè®¡ç®—ï¼Œæˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·ç¦»ï¼Œæ‰€ä»¥æˆ‘ä»¬è®° g(x)g(x)g(x) ä¸ºè°ƒæ•´å xxx åˆ°å®ƒçš„æœ€åº•å±‚çš„å¶å­èŠ‚ç‚¹çš„è·ç¦»ã€‚ è½¬ç§»ä¹Ÿä¸éš¾ã€‚å¾ˆå®¹æ˜“å¾—å‡º g(x)g(x)g(x) çš„è½¬ç§»ï¼š g(x)=maxâ¡yâˆˆson(x){g[y]+wx,y}g(x)=\\max\\limits_{y\\in son(x)}\\left\\{g[y]+w_{x,y}\\right\\} g(x)=yâˆˆson(x)maxâ€‹{g[y]+wx,yâ€‹} f(x)f(x)f(x) æ€ä¹ˆè½¬ï¼Ÿåƒè¿™æ ·ï¼š f(x)=âˆ‘yâˆˆson(x)(f(y)+(g(x)âˆ’g(y)âˆ’wx,y))f(x)=\\sum\\limits_{y\\in son(x)}(f(y)+(g(x)-g(y)-w_{x,y})) f(x)=yâˆˆson(x)âˆ‘â€‹(f(y)+(g(x)âˆ’g(y)âˆ’wx,yâ€‹)) ä»€ä¹ˆæ„æ€ï¼Ÿé¦–å…ˆè‚¯å®šè¦åŠ ä¸Šè°ƒæ•´æ‰€æœ‰å­æ ‘çš„ä»£ä»·ï¼Œç„¶åè¦å¼€å§‹è°ƒæ•´è¿™äº›å­æ ‘ã€‚ä»£ä»·æ˜¯å¤šå°‘ï¼Ÿæ˜¾ç„¶æ˜¯ g(x)âˆ’g(y)âˆ’wx,yg(x)-g(y)-w_{x,y}g(x)âˆ’g(y)âˆ’wx,yâ€‹ï¼Œä¹Ÿå°±æ˜¯å½“å‰çš„æ·±åº¦å‰ªå»å¶å­èŠ‚ç‚¹çš„æ·±åº¦å†å‡å»è¿™æ¡è¾¹çš„é•¿åº¦ã€‚ ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define pii pair&lt;int, int> #define Y first #define W second using namespace std; using i64 = long long; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, s; i64 f[500005], g[500005]; vector &lt;pii> son[500005]; struct edge &#123; int from, to, dist; edge(int u, int v, int d) : from(u), to(v), dist(d) &#123;&#125; &#125;; vector &lt;edge> edges; vector &lt;int> G[500005]; inline void addedge(int u, int v, int d) &#123; edges.push_back(edge(u, v, d)); G[u].push_back(edges.size() - 1); &#125; void dp(int x) &#123; // 0 å°±æ˜¯åˆå§‹æ¡ä»¶ï¼Œå¶å­èŠ‚ç‚¹ä¸éœ€è¦è°ƒæ•´ for (int i = 0; i &lt; son[x].size(); ++i) dp(son[x][i].Y); // å¯¹å„¿å­è¿›è¡Œå¤„ç† for (int i = 0; i &lt; son[x].size(); ++i) g[x] = max(g[x], g[son[x][i].Y] + son[x][i].W); // g çš„è½¬ç§» for (int i = 0; i &lt; son[x].size(); ++i) f[x] += f[son[x][i].Y] + (g[x] - g[son[x][i].Y] - son[x][i].W); // f çš„è½¬ç§» &#125; void dfs(int o, int fa) &#123; for (int i = 0; i &lt; G[o].size(); ++i) &#123; edge &amp;e = edges[G[o][i]]; if (e.to != fa) &#123; son[o].push_back(make_pair(e.to, e.dist)); dfs(e.to, o); &#125; &#125; &#125; int main(void) &#123; n = read(), s = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(), d = read(); addedge(u, v, d); addedge(v, u, d); &#125; dfs(s, -1); // å»ºæ ‘ dp(s); printf(\"%lld\\n\", f[s]); return 0; &#125; [ZJOI2006] ä¸‰è‰²äºŒå‰æ ‘ Portal. è®¾ f(i,0),f(i,1),f(i,2)f(i,0),f(i,1),f(i,2)f(i,0),f(i,1),f(i,2) åˆ†åˆ«ä»£è¡¨ iii èŠ‚ç‚¹æŸ“æˆç»¿è‰²ã€çº¢è‰²ã€è“è‰²çš„ç»¿è‰²èŠ‚ç‚¹æœ€å¤šæ•°ã€‚è½¬ç§»å¯¹äºè¯»åˆ°è¿™çš„è¯»è€…æ¥è¯´åº”è¯¥ä¸æ˜¯å›°éš¾ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; char s[500005]; int f[500005][3], g[500005][3]; // f æœ€å¤šï¼Œg æœ€å°‘ï¼Œ0~2: GRB çš„ç»¿è‰²èŠ‚ç‚¹ void dp(int o) &#123; if (s[o] == '0') &#123; f[o][0] = g[o][0] = 1; return; &#125; int x, y; dp(x = ++n); if (s[o] == '1') &#123; f[o][0] = max(f[x][1], f[x][2]) + 1; f[o][1] = max(f[x][0], f[x][2]); f[o][2] = max(f[x][0], f[x][1]); g[o][0] = min(g[x][1], g[x][2]) + 1; g[o][1] = min(g[x][0], g[x][2]); g[o][2] = min(g[x][0], g[x][1]); &#125; else &#123; dp(y = ++n); f[o][0] = max(f[x][1] + f[y][2], f[x][2] + f[y][1]) + 1; f[o][1] = max(f[x][0] + f[y][2], f[x][2] + f[y][0]); f[o][2] = max(f[x][0] + f[y][1], f[x][1] + f[y][0]); g[o][0] = min(g[x][1] + g[y][2], g[x][2] + g[y][1]) + 1; g[o][1] = min(g[x][0] + g[y][2], g[x][2] + g[y][0]); g[o][2] = min(g[x][0] + g[y][1], g[x][1] + g[y][0]); &#125; &#125; int main(void) &#123; scanf(\"%s\", s + 1); dp(++n); printf(\"%d %d\\n\", max(&#123;f[1][0], f[1][1], f[1][2]&#125;), min(&#123;g[1][0], g[1][1], g[1][2]&#125;)); return 0; &#125; [UVa 12186] Another Crisis Portal. çŠ¶æ€çš„å®šä¹‰ä¸è½¬ç§»å¯¹äºè¯»è€…æ¥è¯´åº”è¯¥å·²ç»ä¸æ˜¯å›°éš¾ï¼Œè¿™é‡Œæä¾›å¦ä¸€ç§å®ç°ã€‚ç”±äºéœ€è¦æ’åºï¼Œæ‰€ä»¥å°† dp åšæˆæœ‰è¿”å›å€¼çš„å‡½æ•°ï¼Œè¿™æ ·å…¶å®æ›´ç±»ä¼¼äº dfsã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, t, f[100005]; vector &lt;int> son[100005]; int dp(int x) &#123; if (son[x].empty()) return 1; vector &lt;int> a; for (int i = 0; i &lt; son[x].size(); ++i) a.push_back(dp(son[x][i])); sort(a.begin(), a.end()); int c = ceil(son[x].size() * t / 100.0); int ans = 0; for (int i = 0; i &lt; c; ++i) ans += a[i]; return ans; &#125; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;t) == 2 &amp;&amp; n) &#123; for (int i = 0; i &lt;= n; ++i) &#123; son[i].clear(); f[i] = 0; &#125; for (int i = 1, x; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); son[x].push_back(i); &#125; printf(\"%d\\n\", dp(0)); &#125; return 0; &#125; [UVa 1218] Perfect Service Portal. è¿™ç§é¢˜æœ‰å±äºè‡ªå·±çš„å¥—è·¯ï¼š f(x,0)f(x,0)f(x,0) ä»£è¡¨ xxx æ˜¯æœåŠ¡å™¨ï¼Œé‚£ä¹ˆå„¿å­éšä¾¿ï¼› f(x,1)f(x,1)f(x,1) ä»£è¡¨ xxx ä¸æ˜¯ï¼Œä½†æ˜¯çˆ¶äº²æ˜¯ï¼Œé‚£ä¹ˆå„¿å­éƒ½ä¸æ˜¯ï¼› f(x,2)f(x,2)f(x,2) ä»£è¡¨ xxx å’Œçˆ¶äº²éƒ½ä¸æ˜¯ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªå„¿å­æ˜¯ã€‚ è½¬ç§»æ–¹ç¨‹åº”è¯¥ä¸éš¾å†™å‡ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; const int INF = 10001; int n, f[10005][3]; vector &lt;int> G[10005]; void dp(int x, int fa) &#123; f[x][0] = 1, f[x][1] = 0, f[x][2] = INF; int sum = 0; for (auto y : G[x]) &#123; if (y == fa) continue; dp(y, x); f[x][0] += min(f[y][0], f[y][1]); f[x][1] += f[y][2]; sum += f[y][2]; &#125; for (auto y : G[x]) if (y != fa) f[x][2] = min(f[x][2], sum - f[y][2] + f[y][0]); &#125; int main(void) &#123; while (n != -1 &amp;&amp; scanf(\"%d\", &amp;n) == 1) &#123; for (int i = 1; i &lt;= n; ++i) G[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1, 0); printf(\"%d\\n\", min(f[1][0], f[1][2])); scanf(\"%d\", &amp;n); &#125; return 0; &#125; æ ‘å½¢èƒŒåŒ… é—®é¢˜å®šä¹‰åœ¨æ ‘å½¢ç»“æ„ä¸Šï¼Œä¾ç…§å­æ ‘è®¾å®šå­é—®é¢˜ã€‚å¸¸å¸¸ç”¨ f(x,s)f(x,s)f(x,s) è¡¨ç¤ºå­æ ‘ xxx åœ¨çŠ¶æ€é™åˆ¶ sss ä¸‹çš„æœ€ä¼˜è§£ã€‚å…ˆé€’å½’æ±‚è§£å­æ ‘çš„ç­”æ¡ˆï¼Œå†è®¡ç®—å½“å‰ç»“ç‚¹ç­”æ¡ˆã€‚ æ™®é€šçš„èƒŒåŒ…ï¼Œå¦‚ 01 èƒŒåŒ…å¯ä»¥æ”¾åˆ°æ ‘ä¸Šï¼Œè€Œæ ‘å½¢ç»“æ„è¿˜å¯ä»¥ç”¨æ¥è§£å†³ä¾èµ–æ€§èƒŒåŒ…ã€‚ æ™®é€šèƒŒåŒ… | [Luogu P2015] äºŒå‰è‹¹æœæ ‘ Portal. æœ‰ä¸€æ£µè‹¹æœæ ‘ï¼Œå¦‚æœæ ‘ææœ‰åˆ†å‰ï¼Œä¸€å®šæ˜¯åˆ†äºŒå‰ï¼ˆå°±æ˜¯è¯´æ²¡æœ‰åªæœ‰ä¸€ä¸ªå„¿å­çš„ç»“ç‚¹ï¼‰è¿™æ£µæ ‘å…±æœ‰ NNN ä¸ªç»“ç‚¹ï¼ˆå¶å­ç‚¹æˆ–è€…æ ‘æåˆ†å‰ç‚¹ï¼‰ï¼Œç¼–å·ä¸º 1âˆ¼N1 \\sim N1âˆ¼Nï¼Œæ ‘æ ¹ç¼–å·ä¸€å®šæ˜¯ 111ã€‚æˆ‘ä»¬ç”¨ä¸€æ ¹æ ‘æä¸¤ç«¯è¿æ¥çš„ç»“ç‚¹çš„ç¼–å·æ¥æè¿°ä¸€æ ¹æ ‘æçš„ä½ç½®ã€‚ä¸‹é¢æ˜¯ä¸€é¢—æœ‰ 444 ä¸ªæ ‘æçš„æ ‘ï¼š2 5 \\ &#x2F; 3 4 \\ &#x2F; 1ç°åœ¨è¿™é¢—æ ‘ææ¡å¤ªå¤šäº†ï¼Œéœ€è¦å‰ªæã€‚ä½†æ˜¯ä¸€äº›æ ‘æä¸Šé•¿æœ‰è‹¹æœã€‚ç»™å®šéœ€è¦ä¿ç•™çš„æ ‘ææ•°é‡ï¼Œæ±‚å‡ºæœ€å¤šèƒ½ç•™ä½å¤šå°‘è‹¹æœã€‚ æˆ‘ä»¬è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨ä»¥ iii ä¸ºæ ¹çš„å­æ ‘ï¼Œæ°å¥½ä¿ç•™ jjj æ¡è¾¹æ‰€èƒ½è·å¾—çš„æœ€å¤šè‹¹æœæ•°ã€‚é‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘å·¦å³å­æ ‘ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œç”±äº f(x,0)f(x,0)f(x,0) è¿™ä¸ªçŠ¶æ€æ˜¯å­˜åœ¨çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è®© âˆ’1-1âˆ’1 çš„ä½“ç§¯ä»£è¡¨ä»€ä¹ˆéƒ½ä¸é€‰ã€‚ ä¸‹é¢æ˜¯ä»£ç ï¼Œè¯·ä»”ç»†é˜…è¯»ã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, q; int son[105][2], val[105][2]; int s[105]; // s[x] ä¸º x åŠå…¶å­èŠ‚ç‚¹æ‰€å«æœ‰çš„è¾¹æ•° int f[105][105]; void dp(int o) &#123; int x = son[o][0], y = son[o][1]; if (!x) return; dp(x), dp(y); s[o] = s[x] + s[y] + 2; // +2 æ˜¯è¿æ¥å·¦å³å­æ ‘ç”¨æ‰çš„ for (int i = -1; i &lt;= s[x]; ++i) for (int j = -1; j &lt;= s[y]; ++j) &#123; int vl = (i == -1 ? 0 : f[x][i] + val[o][0]); // -1 ä¸é€‰å°±æ˜¯ 0ï¼Œé€‰äº†å°±æ˜¯å„¿å­çš„èƒ½è·å¾—çš„è‹¹æœæ•°å€¼åŠ ä¸Šå„¿å­ä¸Šçš„è‹¹æœæ•°ï¼ˆå› ä¸ºè¿™ä¸€æ¡è¾¹é€‰äº†ï¼‰ int vr = (j == -1 ? 0 : f[y][j] + val[o][1]); f[o][i + j + 2] = max(f[o][i + j + 2], vl + vr); // i + j æ˜¯å·¦å­æ ‘å’Œå³å­æ ‘ç”¨æ‰çš„è¾¹ï¼Œ+2 æ˜¯å½“å‰èŠ‚ç‚¹è¿æ¥å·¦å³å­æ ‘ç”¨æ‰çš„è¾¹ &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt; n; ++i) &#123; int x; scanf(\"%d\", &amp;x); int b = son[x][0] > 0; // å­˜åœ¨å·¦å­æ ‘å°±å¾€å³å­æ ‘é‡Œè¯»å…¥ scanf(\"%d%d\", &amp;son[x][b], &amp;val[x][b]); // è¿™é‡Œçš„æ ‘æä¸Šçš„è‹¹æœé€ç»™å„¿å­ &#125; dp(1); printf(\"%d\\n\", f[1][q]); return 0; &#125; å¯ä»¥å‘ç°ï¼Œå…¶å®è¿™å°±æ˜¯ä¸€ä¸ª 01 èƒŒåŒ…é—®é¢˜ï¼Œåªä¸è¿‡è·‘åˆ°äº†æ ‘ä¸Šã€‚ ä¾èµ–æ€§èƒŒåŒ… | [CTSC1997] é€‰è¯¾ Portal. åœ¨å¤§å­¦é‡Œæ¯ä¸ªå­¦ç”Ÿï¼Œä¸ºäº†è¾¾åˆ°ä¸€å®šçš„å­¦åˆ†ï¼Œå¿…é¡»ä»å¾ˆå¤šè¯¾ç¨‹é‡Œé€‰æ‹©ä¸€äº›è¯¾ç¨‹æ¥å­¦ä¹ ï¼Œåœ¨è¯¾ç¨‹é‡Œæœ‰äº›è¯¾ç¨‹å¿…é¡»åœ¨æŸäº›è¯¾ç¨‹ä¹‹å‰å­¦ä¹ ï¼Œå¦‚é«˜ç­‰æ•°å­¦æ€»æ˜¯åœ¨å…¶å®ƒè¯¾ç¨‹ä¹‹å‰å­¦ä¹ ã€‚ç°åœ¨æœ‰ NNN é—¨åŠŸè¯¾ï¼Œæ¯é—¨è¯¾æœ‰ä¸ªå­¦åˆ†ï¼Œæ¯é—¨è¯¾æœ‰ä¸€é—¨æˆ–æ²¡æœ‰ç›´æ¥å…ˆä¿®è¯¾ï¼ˆè‹¥è¯¾ç¨‹ a æ˜¯è¯¾ç¨‹ b çš„å…ˆä¿®è¯¾å³åªæœ‰å­¦å®Œäº†è¯¾ç¨‹ aï¼Œæ‰èƒ½å­¦ä¹ è¯¾ç¨‹ bï¼‰ã€‚ä¸€ä¸ªå­¦ç”Ÿè¦ä»è¿™äº›è¯¾ç¨‹é‡Œé€‰æ‹© MMM é—¨è¯¾ç¨‹å­¦ä¹ ï¼Œé—®ä»–èƒ½è·å¾—çš„æœ€å¤§å­¦åˆ†æ˜¯å¤šå°‘ï¼Ÿ åœ¨ã€ŠèƒŒåŒ…ã€‹ä¸­æˆ‘ä»¬å°±è®¨è®ºè¿‡è¿™ä¸ªé—®é¢˜ï¼Œä¸è¿‡å½“æ—¶æˆ‘ä»¬ç»™å‡ºçš„æ–¹æ¡ˆæ˜¯æš´åŠ›æšä¸¾å­é›†è½¬æ¢æˆåˆ†ç»„èƒŒåŒ…ï¼Œä½†æ˜¯æ˜¾ç„¶å¾ˆæ…¢ã€‚ç°åœ¨æœ‰äº†æ ‘ï¼Œè¿™ç±»é—®é¢˜å°±å˜çš„å¥½è§£äº†ã€‚ å¦‚æœæ²¡æœ‰å…ˆä¿®è¯¾çš„é™åˆ¶ï¼Œè¿™å°±æ˜¯ä¸€ä¸ªæ ‡å‡†çš„ 01 èƒŒåŒ…é—®é¢˜ã€‚ç”±äºæ¯é—¨è¯¾ç¨‹çš„å…ˆä¿®è¯¾åªæœ‰ä¸€é—¨ï¼Œè¿™å°±æ„æˆäº†ä¸€æ£µæ¯é—¨è¯¾éƒ½ä»¥è‡ªå·±çš„å…ˆä¿®è¯¾ä¸ºçˆ¶äº²çš„æ£®æ—ç»“æ„ï¼ˆå› ä¸ºå¯èƒ½ä¼šæœ‰å¤šé—¨è¯¾æ²¡æœ‰å…ˆä¿®è¯¾ï¼‰ã€‚æ—¢ç„¶å¦‚æ­¤ï¼Œæˆ‘ä»¬å¢è®¾ä¸€ä¸ªè™šï¼ˆchaoï¼‰æ‹Ÿï¼ˆjiï¼‰è¯¾ï¼ˆbaï¼‰ç¨‹ï¼ˆbaï¼‰ï¼Œ0 å·èŠ‚ç‚¹ï¼Œä½œä¸ºâ€å®é™…ä¸Šæ²¡æœ‰å…ˆä¿®è¯¾çš„è¯¾ç¨‹â€œã€‚ è®¾ f(x,t)f(x,t)f(x,t) è¡¨ç¤ºåœ¨ä»¥ xxx ä¸ºæ ¹çš„å­æ ‘ä¸­é€‰ ttt é—¨è¯¾ç¨‹èƒ½è·å¾—çš„æœ€é«˜å­¦åˆ†ã€‚è®¾å®ƒçš„å­èŠ‚ç‚¹ä¸ªæ•°ä¸º pppï¼Œé‚£ä¹ˆæœ‰ f(x,0)=0f(x,0)=0f(x,0)=0ã€‚å½“ t&gt;0t&gt;0t&gt;0 æ—¶ï¼Œå¿…é¡»é€‰èŠ‚ç‚¹ xxxï¼Œé‚£ä¹ˆæœ‰ï¼ˆscore[x]score[x]score[x] æŒ‡è¯¾ç¨‹ xxx è·å¾—çš„å­¦åˆ†ï¼Œyiy_iyiâ€‹ æŒ‡ xxx çš„å­èŠ‚ç‚¹ï¼‰ï¼š f(x,t)=maxâ¡âˆ‘i=1pci=tâˆ’1{âˆ‘i=1pf(yi,ci)}+score[x]f(x,t)=\\max\\limits_{\\sum_{i=1}^{p} c_i=t-1}\\left\\{\\sum\\limits_{i=1}^{p}f(y_i,c_i)\\right\\}+score[x] f(x,t)=âˆ‘i=1pâ€‹ciâ€‹=tâˆ’1maxâ€‹{i=1âˆ‘pâ€‹f(yiâ€‹,ciâ€‹)}+score[x] ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦åœ¨æ»¡è¶³å­èŠ‚ç‚¹æ‰€é€‰çš„ç§‘ç›®çš„ç»¼åˆä¸º (âˆ‘i=1pci)=tâˆ’1\\left(\\sum_{i=1}^{p} c_i\\right)=t-1(âˆ‘i=1pâ€‹ciâ€‹)=tâˆ’1 çš„å‰æä¸‹ï¼Œåœ¨å­æ ‘ä¸­é€‰è¯¾è·å¾—æœ€å¤§çš„å¾—åˆ†ã€‚ ç°åœ¨æƒ³ä¸€æƒ³ï¼Œè¿™å°±æ˜¯åˆ†ç»„èƒŒåŒ…çš„å¤„ç†æ–¹å¼ï¼ å¯ä»¥è¿™ä¹ˆç†è§£ã€‚å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œæœ‰ ppp ä¸ªå„¿å­ï¼Œä¹Ÿå°±æ˜¯æœ‰ ppp ç»„ç‰©å“ï¼Œæ¯ç»„ç‰©å“éƒ½æœ‰ tâˆ’1t-1tâˆ’1 ä¸ªï¼ˆä¸è¶³çš„ç”¨ä½“ç§¯å’Œä»·å€¼éƒ½ä¸º 000 çš„ç‰©å“æ¥è¡¥é½ï¼‰ï¼Œå…¶ä¸­ç¬¬ iii ç»„çš„ç¬¬ jjj ä¸ªç‰©å“ä½“ç§¯ä¸º jjjï¼Œä»·å€¼ä¸º f(yi,j)f(y_i,j)f(yiâ€‹,j)ã€‚èƒŒåŒ…çš„æ€»å®¹é‡ä¸º tâˆ’1t-1tâˆ’1ï¼ˆå› ä¸ºå½“å‰èŠ‚ç‚¹ä¼šåƒæ‰ä½“ç§¯ä¸º 111 çš„å®¹é‡ï¼‰ã€‚ æ¯ç»„ä¸­è‡³å¤šåªèƒ½é€‰ä¸€ä¸ªç‰©å“ï¼ˆéš¾ä¸æˆä½ è¿˜èƒ½åŒæ—¶é€‰ f(yi,0)f(y_i,0)f(yiâ€‹,0) å’Œ f(yi,1)f(y_i,1)f(yiâ€‹,1) å— ï¼‰ï¼Œä½¿å¾—ç‰©å“ä½“ç§¯ä¸è¶…è¿‡ tâˆ’1t-1tâˆ’1 çš„å‰æä¸‹ï¼ˆæ ¹æ®ä¹‹å‰èƒŒåŒ…ä¸­æ‰€æ¨çš„åŸç†ï¼Œä¸éœ€è¦å–ä½“ç§¯åˆ†åˆ«ä¸º 0âˆ¼tâˆ’10\\sim t-10âˆ¼tâˆ’1 çš„æœ€å¤§å€¼ï¼‰ï¼Œç‰©å“ä»·å€¼æœ€å¤§ï¼ˆè·å¾—æœ€å¤šçš„å­¦åˆ†ï¼‰ã€‚ç„¶è€Œæˆ‘ä»¬çš„è¶…çº§çˆ¸çˆ¸ 000 å·èŠ‚ç‚¹é™¤å¤–ï¼Œå› ä¸ºå®ƒæ ¹æœ¬ä¸éœ€è¦è¢«é€‰ä¿®ï¼ŒèƒŒåŒ…æ€»å®¹ç§¯ä¸º tttã€‚ å®ç°æ—¶æˆ‘ä»¬å¯ä»¥è£…ä½œæœ‰ m+1m+1m+1 ä¸ªå¯é€‰çš„ç‰©å“ï¼Œè¿™æ ·å°±ä¸ç”¨ç†ä¼šè¶…çº§çˆ¸çˆ¸äº†ã€‚ä¸‹é¢æ˜¯ä»£ç ï¼Œè¯·ä»”ç»†é˜…è¯»ã€‚ #include &lt;bits/stdc++.h> using namespace std; int n, m, s[305], siz[305]; int f[305][305]; vector &lt;int> son[305]; void dp(int x) &#123; f[x][0] = 0; f[x][1] = s[x]; siz[x] = 1; for (int y : son[x]) &#123; dp(y); // é€’å½’æ±‚è§£æ¯ä¸ªç‰©å“çš„ä»·å€¼ï¼ˆæ¯ä¸ªå„¿å­çš„ä»·å€¼ï¼‰ for (int i = min(siz[x], m + 1); i >= 1; --i) for (int j = min(siz[y], m + 1 - i); j >= max(1, i - siz[x]); --j) f[x][i + j] = max(f[x][i + j], f[x][i] + f[y][j]); siz[x] += siz[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); son[x].push_back(i); s[i] = read(); &#125; memset(f, 0xff, sizeof(f)); // æ±‚çš„æ˜¯æœ€å¤§å€¼ dp(0); // ä»è¶…çº§èŠ‚ç‚¹å¼€å§‹ dp printf(\"%d\\n\", f[0][m + 1]); // å¿…é€‰ï¼Œæ‰€ä»¥ç­”æ¡ˆåªèƒ½æ˜¯è¿™ä¸€ä¸ª return 0; &#125; æ ‘å½¢èƒŒåŒ…ä¸­çš„ä¸Šä¸‹ç•Œéœ€è¦æ³¨æ„ï¼Œéœ€è¦å¡æ­»ï¼Œæ³¨æ„ä¸è¦éå†åˆ°æ— ç”¨çš„çŠ¶æ€ï¼Œä¸€å®šæ˜¯ä¸€ä¸ªå°†å­æ ‘åˆå¹¶åˆ°å½“å‰èŠ‚ç‚¹çš„è¿‡ç¨‹ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯æ—¶é—´å¤æ‚åº¦ä¸º O(nm)O(nm)O(nm)ï¼Œå¤§è‡´åŸç†æ˜¯ï¼šâ€œæ¯å¯¹èŠ‚ç‚¹åªä¼šæ°å¥½åœ¨ LCA å¤„åˆå¹¶ä¸€æ¬¡â€ã€‚ æ¢æ ¹ DP POJ3585 Accumulation Degreeã€‚ æ­£å¸¸æ¥è®²ï¼Œè¿™é“é¢˜æ€ä¹ˆåšï¼Ÿå¾ˆæ˜¾ç„¶ï¼Œä¸èƒ½éšä¾¿é€‰ä¸€ä¸ªç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œè¿™æ ·æ— æ³•ç»Ÿè®¡ç­”æ¡ˆã€‚å¦‚æœæšä¸¾æºç‚¹ï¼Œé‚£ä¹ˆæ¯æ¬¡éƒ½è·‘ä¸€ä¸ªæ ‘å½¢ DP å°±å¯ä»¥è§£å†³äº†ï¼Œä½†æ˜¯æ—¶é—´ä¸å…è®¸ã€‚ä½†æ˜¯ä¸è¦ç´§ï¼Œä¸€ç§åä¸ºâ€œäºŒæ¬¡æ‰«æä¸æ¢æ ¹æ³•â€çš„æŠ€å·§å¯ä»¥åª DP ä¸€æ¬¡æ¥ç»Ÿè®¡ç­”æ¡ˆï¼Œä¹Ÿè¢«ç§°ä¹‹ä¸ºæ¢æ ¹ DPã€‚åœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæŠŠ nnn æ¬¡ DP çš„è½¬ç§»æ–¹ç¨‹å†™å‡ºæ¥ï¼š f(x)=âˆ‘yâˆˆSon(x){minâ¡{f(y),c(x,y)},deg[x]&gt;1,c(x,y),deg[x]=1.f(x) = \\sum_{y\\in Son(x)} \\begin{cases} \\min\\{f(y), c(x, y)\\}&amp;, deg[x]&gt;1,\\\\ c(x,y)&amp;, deg[x] = 1. \\end{cases} f(x)=yâˆˆSon(x)âˆ‘â€‹{min{f(y),c(x,y)}c(x,y)â€‹,deg[x]&gt;1,,deg[x]=1.â€‹ void dp(int x, int fa) &#123; f[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].to, w = G[x][i].val; if (y != fa) &#123; dp(y, x); if (deg[y] == 1) f[x] += w; else f[x] += min(f[y], w); &#125; &#125; &#125; æˆ‘ä»¬ä»»æ„é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸º root è¿›è¡Œå¦‚ä¸Šæ“ä½œåï¼Œå°±å¯ä»¥å¼€å§‹æ¢æ ¹äº†ï¼š è®¾ g(x)g(x)g(x) ä»£è¡¨ä»¥ xxx ä½œä¸ºæºç‚¹ï¼Œæµå‘æ•´ä¸ªæ°´ç³»ï¼Œæµé‡æœ€å¤§æ˜¯å¤šå°‘ã€‚åˆå§‹è‚¯å®šæ˜¯ g(root)=f(root)g(root)=f(root)g(root)=f(root)ã€‚ å¦‚æœ g(x)g(x)g(x) å·²ç»è¢«æ±‚å‡ºï¼Œé‚£ä¹ˆå¯¹äºå­èŠ‚ç‚¹ yyyï¼Œg(y)g(y)g(y) åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼š ä» yyy æµå…¥ yyy çš„å­æ ‘çš„æµé‡ï¼Œå°±æ˜¯ f(y)f(y)f(y)ï¼› ä» yyy åˆ°çˆ¶äº² xxx ç„¶åç»§ç»­æµçš„æµé‡ã€‚ è¿™ä¸ª 222 æ€ä¹ˆæ±‚ï¼Ÿè¿˜è®°å¾—æˆ‘ä»¬æ˜¯æ€ä¹ˆæ±‚è§£æ ‘çš„é‡å¿ƒçš„å—ï¼Ÿæˆ‘ä»¬ç”¨æ•´ä½“çš„å‡å»äº†å±€éƒ¨çš„ï¼Œå°±ç­‰äºé™¤äº†å±€éƒ¨ä»¥å¤–çš„å†…å®¹äº†ã€‚ è¿™é‡Œä¹Ÿæ˜¯ä¸€æ ·ï¼Œåƒè¿™æ ·ï¼š g(y)=f(y)+{minâ¡{g(x)âˆ’minâ¡{f(y),c(x,y)},c(x,y)},deg[x]&gt;1c(x,y),deg[x]=1g(y)=f(y)+\\begin{cases} \\min\\left\\{g(x)-\\min\\left\\{f(y),c(x,y)\\right\\}, c(x,y)\\right\\}&amp;,deg[x]&gt;1\\\\ c(x,y)&amp;,deg[x]=1 \\end{cases} g(y)=f(y)+{min{g(x)âˆ’min{f(y),c(x,y)},c(x,y)}c(x,y)â€‹,deg[x]&gt;1,deg[x]=1â€‹ å½“ yyy çš„çˆ¶äº² xxx æ˜¯ä¸ªåº¦æ•°ä¸º 111 çš„ç‚¹æ—¶ï¼Œå®ƒå°±æ˜¯ä¸€ä¸ªæ±‡ç‚¹ï¼Œæµé‡å°±æ˜¯ c(x,y)c(x,y)c(x,y)ï¼›å½“å®ƒä¸æ˜¯ä¸€ä¸ªæ±‡ç‚¹çš„æ—¶å€™ï¼Œå°±ç­‰äºä»¥å®ƒçˆ¶äº²ä½œä¸ºæºç‚¹çš„æ•´ä¸ªæ°´ç³»çš„æµé‡ g(x)g(x)g(x)ï¼Œå‡å»ä» xâ†’yx\\rightarrow yxâ†’y çš„æµé‡ minâ¡{f(y),c(x,y)}\\min\\{f(y),c(x,y)\\}min{f(y),c(x,y)}ï¼ŒåŒæ—¶è¿˜è¦å°†è¿™ä¸ªå·®ä¸ c(x,y)c(x,y)c(x,y) å–æœ€å°å€¼ã€‚ #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int to, val; edge(int to = 0, int val = 0) : to(to), val(val) &#123;&#125; &#125;; int n; int f[200005], g[200005], deg[200005]; vector &lt;edge> G[200005]; inline void addedge(int u, int v, int w) &#123; G[u].push_back(edge(v, w)); &#125; void dp(int x, int fa) &#123; f[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].to, w = G[x][i].val; if (y != fa) &#123; dp(y, x); if (deg[y] == 1) f[x] += w; else f[x] += min(f[y], w); &#125; &#125; &#125; void dfs(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].to, w = G[x][i].val; if (y != fa) &#123; if (deg[x] == 1) g[y] = f[y] + w; // å…ˆè®¡ç®—å¥½å½“å‰çš„ gï¼Œç„¶åå†éå† else g[y] = f[y] + min(g[x] - min(f[y], w), w); dfs(y, x); &#125; &#125; &#125; void solve(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) G[i].clear(); memset(deg, 0, sizeof(deg)); memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w), addedge(v, u, w); deg[u]++, deg[v]++; &#125; dp(1, -1); g[1] = f[1]; dfs(1, -1); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, g[i]); printf(\"%d\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æ¢æ ¹çš„è¿‡ç¨‹ä¸­ï¼Œè¦ææ˜ç™½ä»£ä»·å°‘äº†ä»€ä¹ˆï¼Œåˆå¤šäº†ä»€ä¹ˆã€‚ å›¾ä¸Š DP æˆ‘ä»¬è¯´è¿‡ï¼ŒDP éœ€è¦æœ‰æ— åæ•ˆæ€§ã€‚æ‰€ä»¥ä¸€èˆ¬æˆ‘ä»¬åªèƒ½åœ¨ DAG ä¸Šè¿›è¡Œ DPï¼ˆåé¢ä¼šå­¦ä¹ åˆ°é«˜æ–¯æ¶ˆå…ƒå¯ä»¥è¿›è¡Œåæ•ˆæ€§å¤„ç†ï¼‰ã€‚å½“ç„¶ï¼Œä¸å¤ªå¤æ‚çš„é—®é¢˜ï¼Œå¦‚å•ä¸ªç¯ä¸Šçš„é—®é¢˜ä¸Šçš„é—®é¢˜ä¹Ÿæ˜¯å¯ä»¥åšçš„ã€‚æˆ–è€…ï¼Œä¸€èˆ¬å›¾çš„ç¼©ç‚¹ä¹‹åä¹Ÿå¯ä»¥åšã€‚ DAG ä¸Šçš„ DP ä½ æœ‰æ²¡æœ‰æƒ³è¿‡ DP çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿ ç®€è¿° çº¿æ€§ç»“æ„ä¸Šçš„ DP ä¹Ÿå¥½ï¼Œæ ‘å½¢ç»“æ„ä¸Šçš„ DP ä¹Ÿç½¢ã€‚å®ƒä»¬éƒ½æœ‰â€œçŠ¶æ€â€â€å†³ç­–â€ä¸¤ä¸ªæ¦‚å¿µã€‚çŠ¶æ€å¯¹åº”å›¾ä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œè€Œå†³ç­–å¯¹åº”å›¾ä¸Šçš„è¾¹ã€‚ ä½ æœ‰æ²¡æœ‰å‘ç°ä»€ä¹ˆï¼Ÿ å¦‚æœ DP çš„çŠ¶æ€å›¾é•¿æˆä¸‹å›¾è¿™æ ·ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ æƒ³è¦æ±‚è§£çŠ¶æ€ 333ï¼Œä¾èµ–äºçŠ¶æ€ 222ï¼Œè€ŒçŠ¶æ€ 222 ä¾èµ–äºçŠ¶æ€ 111ï¼ŒçŠ¶æ€ 111 åˆä¾èµ–äºçŠ¶æ€ 333ï¼è¿™æˆäº†ä¸ªæ— é™å¾ªç¯é—®é¢˜ã€‚ æ‰€ä»¥å¯ä»¥å¾—å‡ºç»“è®ºï¼ŒDP ä¸€èˆ¬åªé€‚ç”¨äºæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œéå†é¡ºåºä¾¿æ˜¯è¿™ä¸ª DAG çš„ä¸€ä¸ªæ‹“æ‰‘åºã€‚å¦‚æœè¿™ä¸ªå›¾æ˜¯å¸¦ç¯çš„ï¼Œé‚£ä¹ˆä¸€èˆ¬å®ƒå°±ä¸èƒ½ DPã€‚ ä¸€ä¸ªé—®é¢˜å¯ä»¥ DPï¼Œæ˜¯å› ä¸ºè¿™ä¸ªé—®é¢˜å¯ä»¥ä»å°é—®é¢˜çš„è§£ï¼Œæ¨æ–­å‡ºå¤§é—®é¢˜çš„è§£ã€‚æˆ‘ä»¬å¯ä»¥ä»åˆå§‹çŠ¶æ€çš„è§£ï¼Œæ¨å‡ºæœ€ç»ˆçŠ¶æ€çš„è§£ï¼Œä»è€Œè§£å†³é—®é¢˜ã€‚ä¹Ÿå°±æ˜¯è¯´æœ‰è¿™å‡ æ¡æ€§è´¨ï¼š å¦‚æœæˆ‘ä»¬æŒ‰ä»¥ä¸Šæ–¹æ³•ç»˜å›¾ï¼Œé‚£ä¹ˆç«‹å³å°±æœ‰å‡ æ¡æ€§è´¨ï¼š DP çš„æ¯ä¸€ä¸ªçŠ¶æ€éƒ½å¯¹åº”ç€ä¸€ä¸ªç‚¹ï¼› æ¯ç§å¯èƒ½çš„è½¬ç§»æ–¹å¼ï¼Œéƒ½å¯¹åº”ç€ä¸€æ¡æœ‰å‘è¾¹ï¼› DP çš„æ±‚è§£é¡ºåºï¼Œç­‰åŒäºè¿™å¼ å›¾ä¸Šçš„æ‹“æ‰‘æ’åºï¼› æ•´å¼ å›¾å¿…é¡»æ˜¯ DAGï¼Œå¦åˆ™ä¸å¯èƒ½æ‰¾åˆ°åˆé€‚çš„æ±‚è§£é¡ºåºã€‚ [Luogu P1613] è·‘è·¯ Portal. æˆ‘ä»¬çš„ç›®çš„å°±æ˜¯å»ºå›¾ï¼Œç„¶åæ±‚æœ€çŸ­è·¯ã€‚ä»¤ G[i,j,k]=1G[i,j,k]=1G[i,j,k]=1 ä»£è¡¨å­˜åœ¨ä¸€æ¡ iâ†’ji\\rightarrow jiâ†’jï¼Œé•¿åº¦ä¸º 2k2^k2k çš„è¾¹ï¼Œè¿™æ ·çš„è¾¹å°±æ˜¯å¯ä»¥ 1s1s1s è·‘å®Œçš„ã€‚é‚£ä¹ˆè‹¥ G[i,t,kâˆ’1]=G[t,j,kâˆ’1]=1G[i,t,k-1]=G[t,j,k-1]=1G[i,t,kâˆ’1]=G[t,j,kâˆ’1]=1ï¼Œåˆ™ G[i,j,k]=1G[i,j,k]=1G[i,j,k]=1ã€‚ç”±äºå›¾çš„è§„æ¨¡å¾ˆå°ï¼Œæ±‚æœ€çŸ­è·¯æ—¶ç›´æ¥ä½¿ç”¨ Floyd å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int f[55][55]; bool G[55][55][40]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(f, 0x3f, sizeof f); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); f[u][v] = 1; G[u][v][0] = true; &#125; for (int l = 1; l &lt;= 32; ++l) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int k = 1; k &lt;= n; ++k) if (G[i][j][l - 1] &amp;&amp; G[j][k][l - 1]) &#123; G[i][k][l] = true; f[i][k] = 1; &#125; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) f[i][j] = min(f[i][j], f[i][k] + f[k][j]); printf(\"%d\\n\", f[1][n]); return 0; &#125; ç¯ä¸Š DP å¯ä»¥è€ƒè™‘ä½¿ç”¨ç¼©ç‚¹è§£å†³ã€‚ Problemset å¯èƒ½æ¯”è¾ƒéº»çƒ¦ï¼Œä½†éƒ½æ²¡æœ‰ä»€ä¹ˆéš¾åº¦ã€‚ æ ‘å½¢ DP åŸºç¡€çš„æ ‘å½¢ DPï¼Œåé¢çš„é¢˜ä¼šç¨å¾®éš¾ä¸€ç‚¹ã€‚ [SDOI2006] ä¿å®‰ç«™å²— Portal. è®¾ f(x,0),f(x,1),f(x,2)f(x,0),f(x,1),f(x,2)f(x,0),f(x,1),f(x,2) åˆ†åˆ«ä»£è¡¨ç”±çˆ¶äº²ã€è‡ªå·±å’Œå„¿å­æ¥ç»´æŠ¤ã€‚éœ€è¦æ³¨æ„çš„å°±æ˜¯ç”±å„¿å­ç»´æŠ¤çš„ï¼Œå„¿å­è¦è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯è‡ªå·±ç»´æŠ¤è‡ªå·±çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int w[1505], f[1505][3]; vector &lt;int> G[1505]; void dp(int x, int fa) &#123; f[x][1] = w[x]; int flag = 0, minn = 1e9; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y != fa) &#123; dp(y, x); f[x][0] += min(&#123;f[y][1], f[y][2]&#125;); f[x][1] += min(&#123;f[y][0], f[y][1], f[y][2]&#125;); if (f[y][1] &lt; f[y][2]) f[x][2] += f[y][1], flag = true; else minn = min(minn, f[y][1] - f[y][2]), f[x][2] += f[y][2]; &#125; &#125; if (!flag) f[x][2] += minn; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int p, t, x; scanf(\"%d\", &amp;p); scanf(\"%d%d\", w + p, &amp;t); while (t--) &#123; scanf(\"%d\", &amp;x); G[p].push_back(x), G[x].push_back(p); &#125; &#125; dp(1, 0); printf(\"%d\\n\", min(f[1][1], f[1][2])); return 0; &#125; [CSP-S2019] æ‹¬å·æ ‘ Portal. f(i)f(i)f(i) è¡¨ç¤º iii åˆ° 111 çš„ç­”æ¡ˆï¼Œå†è®° g(i)g(i)g(i) ä¸ºç¬¬ iii ä¸ªèŠ‚ç‚¹çš„è´¡çŒ®ï¼Œå¦‚æœæ‰«æåˆ°å½“å‰ä¸€ä¸ª )ï¼Œå°±è¯´æ˜è¿™ä¸ªèŠ‚ç‚¹æ˜¯æœ‰è´¡çŒ®çš„ã€‚ç»´æŠ¤ä¸€ä¸ªè®°å½•å·¦æ‹¬å·ä½ç½®çš„æ ˆï¼Œæ‰«æåˆ°ä¸€ä¸ª ) å°±ä»æ ˆä¸­è¿›è¡ŒåŒ¹é…ï¼Œæ›´æ–° g(x)=g(k)+1g(x)=g(k)+1g(x)=g(k)+1ï¼Œå…¶ä¸­ kkk ä¸ºå¼¹å‡ºçš„æ ˆé¡¶çš„çˆ¶äº²ï¼Œè¿™æ ·å¯ä»¥å°†çˆ¶äº²çš„è´¡çŒ®å€¼ä¹Ÿç®—ä¸Šã€‚å¦‚æœæ˜¯ ( å°±ç›´æ¥å…¥æ ˆã€‚è¿™æ—¶å€™å°±å¯ä»¥è®¡ç®—å½“å‰çš„ç­”æ¡ˆï¼šçˆ¶äº²èŠ‚ç‚¹çš„ç­”æ¡ˆåŠ ä¸Šå½“å‰èŠ‚ç‚¹çš„è´¡çŒ®ã€‚æ¥ä¸‹æ¥å°±å¯ä»¥é€’å½’è®¡ç®—å„¿å­çš„è´¡çŒ®ï¼Œç„¶åè¦è¿˜åŸç°åœºä½¿å¾—çˆ¶äº²çš„å…¶å®ƒå„¿å­å¯ä»¥æ­£ç¡®è®¡ç®—ï¼šå¦‚æœå¼¹å‡ºè¿‡æ ˆå°±è¦æŠŠè¿™ä¸ªå†å‹å›å»ï¼Œå¦åˆ™å¦‚æœå‘ç°æ ˆä¸æ˜¯ç©ºçš„ï¼Œå°±æ˜¯å‹è¿›å»è¿‡å…ƒç´ ï¼ŒæŠŠå®ƒ pop å‡ºæ¥ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, fa[500005]; i64 ans = 0, f[500005], g[500005]; // g[i] è¡¨ç¤ºèŠ‚ç‚¹ i çš„è´¡çŒ® char s[500005]; vector &lt;int> son[500005]; stack &lt;int> v; void dp(int x) &#123; int tmp = -1; if (s[x] == ')') &#123; if (!v.empty()) &#123; tmp = v.top(); g[x] = g[fa[tmp]] + 1; v.pop(); &#125; &#125; else v.push(x); f[x] = f[fa[x]] + g[x]; for (int i = 0; i &lt; son[x].size(); ++i) dp(son[x][i]); if (tmp != -1) v.push(tmp); // å‹å›å» else if (!v.empty()) v.pop(); // è¿˜åŸç°åœºï¼Œå°†å‹å…¥çš„ '(' pop å‡ºæ¥ &#125; int main(void) &#123; scanf(\"%d%s\", &amp;n, s + 1); for (int i = 2, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), son[x].push_back(i), fa[i] = x; dp(1); for (int i = 1; i &lt;= n; ++i) ans ^= f[i] * i; printf(\"%lld\\n\", ans); return 0; &#125; [CF486D] Valid Sets Portal. å‘ç°éœ€è¦æšä¸¾ç‚¹æ¥ç»Ÿè®¡ä¿¡æ¯ï¼Œä½†æ˜¯æ¢æ ¹ DP ä¸æ˜¯å¾ˆå¥½åšï¼Œè€Œä¸”æ•°æ®èŒƒå›´å¾ˆå°ï¼Œæ‰€ä»¥è€ƒè™‘æšä¸¾æ¯ä¸ªç‚¹ç„¶åè¿›è¡Œæš´åŠ› DPã€‚ æˆ‘ä»¬æšä¸¾æ¯ä¸€ä¸ªç‚¹ï¼Œå¹¶ä»¤å®ƒæ˜¯ç‚¹æƒæœ€å¤§çš„ç‚¹ã€‚è®¾ f(x)f(x)f(x) ä»£è¡¨åŒ…å« xxx çš„å­æ ‘çš„æœ€å¤§è¿é€šå—æ•°ã€‚å¦‚æœå„¿å­ yyy çš„ç‚¹æƒå·®å¤§äºäº† ddd ä¸è¡Œï¼Œå¦‚æœç‚¹æƒæ¯” rootrootroot å¤§ä¹Ÿä¸è¡Œï¼Œç›¸ç­‰çš„æ—¶å€™è¦åˆ¤æ–­ä¸€ä¸‹ç‚¹çš„ç¼–å·ï¼Œåªèƒ½è®¡ç®—ä¸€ä¸ªï¼Œå› ä¸ºæšä¸¾ yyy çš„æ—¶å€™å®ƒè¿˜ä¼šè¢«è®¡ç®—ä¸€éã€‚ è½¬ç§»ä¹Ÿå¾ˆç®€å•ï¼Œè¦ä¹˜ä¸Šå­æ ‘çš„å¤§å° +1ï¼Œè®¾å­æ ‘çš„å¤§å°ä¸º size(x)size(x)size(x)ï¼Œå¯¹åº”é€‰ 0âˆ¼size(y)0\\sim size(y)0âˆ¼size(y)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 1000000007; int n, d; int a[2005], f[2005]; vector &lt;int> G[2005]; inline void addedge(int u, int v) &#123; G[u].push_back(v); &#125; void dp(int x, int fa, int root) &#123; f[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; if (a[y] > a[root] || (a[y] == a[root] &amp;&amp; y &lt; root)) continue; if (a[root] - a[y] > d) continue; dp(y, x, root); f[x] = 1ll * f[x] * (f[y] + 1) % MOD; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;d, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; memset(f, 0, sizeof(f)); dp(i, 0, i); ans = (ans + f[i]) % MOD; &#125; printf(\"%d\\n\", ans); return 0; &#125; [å›½å®¶é›†è®­é˜Ÿ] èªèªå¯å¯ Portal. è®¾ f(x,i)f(x,i)f(x,i) ä»£è¡¨è·ç¦» xxx ä¸º iiiï¼ˆæ¨¡æ„ä¹‰ï¼‰çš„ç‚¹æ•°ï¼ŒæŒ‰ç…§ç±»ä¼¼äºç‚¹åˆ†æ²»çš„æ–¹å¼ç»Ÿè®¡å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int n, ans, f[20005][3]; vector&lt;pair&lt;int, int>> G[20005]; int M(int x) &#123; return (x % 3 + 3) % 3; &#125; void dfs(int x, int fa) &#123; f[x][0] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, w = G[x][i].second; if (y == fa) continue; dfs(y, x); for (int i = 0; i &lt; 3; ++i) ans += f[y][i] * f[x][M(-i - w)] * 2; for (int i = 0; i &lt; 3; ++i) f[x][M(i + w)] += f[y][i]; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].emplace_back(make_pair(v, d)); G[v].emplace_back(make_pair(u, d)); &#125; dfs(1, 0); ans += n; int full = n * n; int g = gcd(ans, full); ans /= g, full /= g; printf(\"%d/%d\\n\", ans, full); return 0; &#125; [HNOI2003] æ¶ˆé˜²å±€çš„è®¾ç«‹ Portal. ä»¤ f(x,0âˆ¼4)f(x,0\\sim 4)f(x,0âˆ¼4) åˆ†åˆ«ä»£è¡¨ xxx è¦†ç›–åˆ°å®ƒçš„çˆ·çˆ·ï¼Œå®ƒçš„çˆ¶äº²ï¼Œå®ƒè‡ªå·±ï¼Œå®ƒçš„å„¿å­ï¼Œå®ƒçš„å­™å­åŠå…¶å­æ ‘çš„æœ€å°ä»£ä»·ï¼Œè½¬ç§»è§ä»£ç ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int f[1005][5]; vector &lt;int> G[1005]; inline void addedge(int u, int v) &#123; G[u].push_back(v); &#125; void dp(int x, int fa) &#123; int tot = 0, sum3 = 0, sum2 = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; dp(y, x); ++tot; sum3 += f[y][3]; // è®°å½•å„¿å­è‡ªè¡Œè¦†ç›–å®ƒä»¬çš„å„¿å­æ‰€åœ¨çš„å­æ ‘ sum2 += f[y][2]; // è®°å½•å„¿å­è‡ªè¡Œè¦†ç›–å®ƒæ‰€åœ¨çš„å­æ ‘ &#125; if (tot == 0) &#123; f[x][0] = f[x][1] = f[x][2] = 1; return; &#125; f[x][0] = 1, f[x][1] = f[x][2] = 1e9; // åªæœ‰æƒ³è¦è¦†ç›–è‡ªå·±çš„çˆ·çˆ·æ˜¯å¿…é¡»è¦è‡ªè¡Œæ‰§è¡Œçš„ï¼Œåˆå€¼ä¸º 1 for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; // è·ç¦»ä¸º 2 çš„ç‚¹éƒ½è¦†ç›–äº†ï¼Œåªéœ€è¦å„¿å­è¦†ç›–å®ƒä»¬çš„å­™å­å³å¯ f[x][0] += f[y][4]; // f[x][1] çš„ç”±æ¥ï¼šå®ƒæœ‰ä¸€ä¸ªå„¿å­(y)è¦†ç›–åˆ°äº†å®ƒçš„çˆ·çˆ·ï¼Œå¯ä»¥è¦†ç›–å®ƒçš„å…„å¼Ÿï¼Œä½†æ˜¯æ— æ³•è¦†ç›–åˆ°å®ƒå…„å¼Ÿçš„å­æ ‘ï¼ˆä¸å«è‡ªå·±ï¼‰ f[x][1] = min(f[x][1], f[y][0] + sum3 - f[y][3]); // f[x][2] çš„ç”±æ¥ï¼šå®ƒæœ‰ä¸€ä¸ªå„¿å­(y)è¦†ç›–åˆ°äº†å®ƒçš„çˆ¶äº²ï¼Œä½†æ˜¯å®ƒçš„å…„å¼Ÿæ— æ³•è¦†ç›– f[x][2] = min(f[x][2], f[y][1] + sum2 - f[y][2]); // è¦æ±‚å®ƒæ‰€æœ‰çš„å„¿å­è¢«è¦†ç›–ï¼Œå„¿å­éœ€è¦è¦†ç›–è‡ªå·±å’Œå­æ ‘ f[x][3] += f[y][2]; // è¦æ±‚å®ƒçš„å­™å­è¢«è¦†ç›–ï¼Œå„¿å­éœ€è¦è¦†ç›–å®ƒä»¬çš„å„¿å­å³å¯ f[x][4] += f[y][3]; &#125; for (int i = 1; i &lt; 5; ++i) f[x][i] = min(f[x][i], f[x][i - 1]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2, x; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); addedge(i, x); addedge(x, i); &#125; dp(1, 0); printf(\"%d\\n\", f[1][2]); // ç­”æ¡ˆæ˜¯è¦†ç›–è‡ªå·±åŠå­æ ‘ return 0; &#125; æ ‘ä¸ŠèƒŒåŒ… æ ‘ä¸ŠèƒŒåŒ…ï¼ˆåˆ†ç»„ï¼Œä¾èµ–æ€§ï¼‰çš„æ¨¡å‹éå¸¸æœ‰ç”¨ï¼Œè€Œä¸”ç±»ä¼¼äº f[x][k]f[x][k]f[x][k] çš„çŠ¶æ€è®¾è®¡ä¹Ÿå¯ä»¥ç®—æ˜¯å¹¿ä¹‰çš„æ ‘å½¢èƒŒåŒ…ï¼Œä¸€å®šè¦äº†è§£åŸç†ã€‚ [Luogu P1273] æœ‰çº¿ç”µè§†ç½‘ Portal. å°±æ˜¯é€‰è¯¾çš„ç¿»ç‰ˆï¼Œè®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨ä»¥ iii ä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œæ»¡è¶³äº† jjj ä¸ªå®¢æˆ·çš„æœ€å¤§æ”¶ç›Šã€‚ç„¶åç›´æ¥ DP åšå°±è¡Œã€‚æ³¨æ„æœ€å¤šèƒ½æ»¡è¶³çš„å®¢æˆ·ä¸ªæ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #define pii pair&lt;int, int> using namespace std; int n, m, f[3005][3005]; // f[i][j] ä»¥ i ä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œj ä¸ªå®¢æˆ·è½¬çš„æœ€å¤§æ”¶ç›Š int M[3005]; vector &lt;pii> G[3005]; int dp(int x) &#123; // è¿”å›è§‚ä¼—çš„ä¸ªæ•° f[x][0] = 0; if (x > n - m) return 1; int sum = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, w = G[x][i].second; sum += dp(y); for (int j = sum; j >= 0; --j) for (int k = j; k >= 0; --k) f[x][j] = max(f[x][j], f[x][j - k] + f[y][k] - w); &#125; return sum; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n - m; ++i) &#123; int k; scanf(\"%d\", &amp;k); while (k--) &#123; int a, c; scanf(\"%d%d\", &amp;a, &amp;c); G[i].push_back(&#123;a, c&#125;); &#125; &#125; memset(f, 0xbf, sizeof(f)); for (int i = n - m + 1; i &lt;= n; ++i) scanf(\"%d\", &amp;f[i][1]); dp(1); for (int i = m; i >= 0; --i) if (f[1][i] >= 0) &#123; printf(\"%d\\n\", i); break; &#125; return 0; &#125; [Luogu P1272] é‡å»ºé“è·¯ Portal.ä¸€åœºå¯æ€•çš„åœ°éœ‡åï¼Œäººä»¬ç”¨ NNN ä¸ªç‰²å£æ£šï¼ˆç¼–å· 1âˆ¼N1\\sim N1âˆ¼Nï¼‰é‡å»ºäº†å†œå¤« John çš„ç‰§åœºã€‚ç”±äºäººä»¬æ²¡æœ‰æ—¶é—´å»ºè®¾å¤šä½™çš„é“è·¯ï¼Œæ‰€ä»¥ç°åœ¨ä»ä¸€ä¸ªç‰²å£æ£šåˆ°å¦ä¸€ä¸ªç‰²å£æ£šçš„é“è·¯æ˜¯æƒŸä¸€çš„ã€‚å› æ­¤ï¼Œç‰§åœºè¿è¾“ç³»ç»Ÿå¯ä»¥è¢«æ„å»ºæˆä¸€æ£µæ ‘ã€‚John æƒ³è¦çŸ¥é“å¦ä¸€æ¬¡åœ°éœ‡ä¼šé€ æˆå¤šä¸¥é‡çš„ç ´åã€‚æœ‰äº›é“è·¯ä¸€æ—¦è¢«æ¯åï¼Œå°±ä¼šä½¿ä¸€æ£µå«æœ‰ PPP ä¸ªç‰²å£æ£šçš„å­æ ‘å’Œå‰©ä½™çš„ç‰²å£æ£šåˆ†ç¦»ï¼ŒJohn æƒ³çŸ¥é“è¿™äº›é“è·¯çš„æœ€å°æ•°ç›®ã€‚ è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨ä»¥ iii ä¸ºæ ¹ï¼Œä¿ç•™ jjj ä¸ªç‚¹æ‹†æ‰çš„æœ€å°è¾¹æ•°ï¼Œè€Œä¸” iii å¿…é¡»ä¿ç•™ã€‚ åˆå§‹æ—¶ f(x,1)f(x,1)f(x,1) ç­‰äº xxx ç‚¹çš„åº¦æ•°ï¼Œè½¬ç§»çš„æ—¶å€™æŒ‰ç…§æ ‘å½¢èƒŒåŒ…çš„æ–¹å¼è½¬ç§»ï¼š f(x,i)=minâ¡j=0iâˆ’1{f(x,iâˆ’j)+f(y,j)âˆ’2}f(x,i)=\\min_{j=0}^{i-1}\\{f(x,i-j)+f(y,j)-2\\} f(x,i)=j=0miniâˆ’1â€‹{f(x,iâˆ’j)+f(y,j)âˆ’2} ä¸ºä»€ä¹ˆæ˜¯å‡ 222 å‘¢ï¼Ÿå› ä¸º xxx å’Œ yyy è¦è¿è¾¹ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹å°±ä¸ç”¨æ‹†äº†ã€‚æ˜¾ç„¶ï¼Œè¿™æ¡è¾¹ä¹‹å‰åœ¨ x,yx,yx,y å„è¢«æ‹†äº†ä¸€æ¬¡ï¼Œæ‰€ä»¥å‡å» 222ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, p, f[155][155]; // i ä¸ºæ ¹ï¼Œä¿ç•™ j ä¸ªç‚¹æ‹†æ‰çš„æœ€å°è¾¹æ•° int siz[155]; vector &lt;int> G[155]; void dp(int x, int fa) &#123; siz[x] = 1; f[x][1] = G[x].size(); for (int y : G[x]) if (y != fa) &#123; dp(y, x); siz[x] += siz[y]; for (int i = siz[x]; i >= 0; --i) &#123; for (int j = i - 1; j >= 0; --j) f[x][i] = min(f[x][i], f[x][i - j] + f[y][j] - 2); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; memset(f, 0x3f, sizeof(f)); dp(1, 0); int ans = f[1][p]; for (int i = 2; i &lt;= n; ++i) ans = min(ans, f[i][p]); printf(\"%d\\n\", ans); return 0; &#125; [HAOI2015] æ ‘ä¸ŠæŸ“è‰² Portal.æœ‰ä¸€æ£µç‚¹æ•°ä¸º n(1â‰¤nâ‰¤2Ã—103)n(1\\le n \\le 2\\times 10^3)n(1â‰¤nâ‰¤2Ã—103) çš„æ ‘ï¼Œæ ‘è¾¹æœ‰è¾¹æƒã€‚ç»™ä½ ä¸€ä¸ªåœ¨ 0âˆ¼n0 \\sim n0âˆ¼n ä¹‹å†…çš„æ­£æ•´æ•° kkk ï¼Œä½ è¦åœ¨è¿™æ£µæ ‘ä¸­é€‰æ‹© kkk ä¸ªç‚¹ï¼Œå°†å…¶æŸ“æˆé»‘è‰²ï¼Œå¹¶å°†å…¶ä»– çš„ nâˆ’kn-knâˆ’k ä¸ªç‚¹æŸ“æˆç™½è‰²ã€‚å°†æ‰€æœ‰ç‚¹æŸ“è‰²åï¼Œä½ ä¼šè·å¾—é»‘ç‚¹ä¸¤ä¸¤ä¹‹é—´çš„è·ç¦»åŠ ä¸Šç™½ç‚¹ä¸¤ä¸¤ä¹‹é—´çš„è·ç¦»çš„å’Œçš„æ”¶ç›Šã€‚é—®å—ç›Šæœ€å¤§å€¼æ˜¯å¤šå°‘ã€‚ è€ƒè™‘æ¯ä¸€æ¡è¾¹çš„è´¡çŒ®ï¼Œè¿™æ ·å°±å¯ä»¥ç»Ÿè®¡äº†å‡ºä¸€æ¡è¾¹è¢«ç»è¿‡äº†å¤šå°‘æ¬¡ã€‚å‡è®¾è¿™æ¡è¾¹è¿æ¥çš„å­æ ‘ä¸­æœ‰ kkk ä¸ªé»‘è‰²ç‚¹ï¼Œé‚£ä¹ˆç»è¿‡æ¬¡æ•°å°±æ˜¯ kÃ—(mâˆ’k)+(siz[y]âˆ’k)Ã—(nâˆ’mâˆ’siz[y]+k)k\\times (m-k)+(siz[y]-k)\\times(n-m-siz[y]+k)kÃ—(mâˆ’k)+(siz[y]âˆ’k)Ã—(nâˆ’mâˆ’siz[y]+k)ï¼Œç„¶å kkk åªèƒ½é€‰æ‹©ä¸€ä¸ªï¼Œè¿™å°±æ˜¯åˆ†ç»„èƒŒåŒ…ï¼ é‚£ä¹ˆè®¾ f[x][k]f[x][k]f[x][k] ä»£è¡¨ä»¥ xxx ä¸ºæ ¹ï¼Œé€‰æ‹©äº† kkk ä¸ªå­èŠ‚ç‚¹æŸ“æˆé»‘è‰²çš„æœ€å¤§è´¡çŒ®ã€‚å®ç°æ—¶æœ‰ä¸€ä¸ªç»†èŠ‚ï¼šåº”è¯¥æŠŠæ‰€æœ‰ fff éƒ½åˆå§‹åŒ–ä¸º âˆ’1-1âˆ’1ï¼Œä»£è¡¨æ˜¯ä¸åˆæ³•çš„ã€‚ç„¶åä»¤ k=0,1k=0,1k=0,1 æ—¶ f=0f=0f=0ï¼Œå› ä¸ºåªé€‰ 0,10,10,1 ä¸ªé»‘ç‚¹è‚¯å®šåˆæ³•ã€‚è½¬ç§»çš„æ—¶å€™å€’åºæšä¸¾ï¼Œå¦‚æœå„¿å­çš„å€¼æ˜¯åˆæ³•çš„å°±ç”¨æ ‘å½¢èƒŒåŒ…çš„æ–¹å¼æ›´æ–°ã€‚ç‰¹åˆ«çš„ï¼Œä¸æ™®é€šæ ‘å½¢èƒŒåŒ…ä¸ä¸€æ ·ï¼Œkkk çš„é€‰æ‹©ä¸€å®šæ˜¯è¦é€‰ 000 å†é€‰å…¶å®ƒçš„ï¼Œå› ä¸ºæœ¬æ¥å°±è¦ç®—ä¸Šå„¿å­ç‚¹çš„å…¨ç™½è´¡çŒ®ï¼ˆå³ä½¿ä¸€ä¸ªé»‘ç‚¹ä¸é€‰ï¼Œä¹Ÿæ˜¯æœ‰è´¡çŒ®çš„ï¼Œä½“ç§¯ä¸º 000 ä½†æ˜¯ä»·å€¼ä¸ä¸º 000ï¼Œè´¡çŒ®å¿…é¡»è®¡ç®—ï¼‰ã€‚æ‰€ä»¥è½¬ç§»çš„æ—¶å€™å¯ä»¥é€‰æ‹©æ­£åºæˆ–è€…æå‰å¤„ç†å¥½ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct edge &#123; int v, d; &#125;; int n, m, siz[2005]; i64 f[2005][2005]; vector&lt;edge> G[2005]; void dp(int x, int fa) &#123; siz[x] = 1; f[x][0] = f[x][1] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].v; i64 w = G[x][i].d; if (y != fa) &#123; dp(y, x); siz[x] += siz[y]; for (int j = min(m, siz[x]); j >= 0; --j) &#123; if (f[x][j] != -1) f[x][j] += f[y][0] + w * siz[y] * (n - m - siz[y]); for (int k = min(j, siz[y]); k >= 1; --k) &#123; if (f[x][j - k] == -1) continue; i64 val = 1ll * k * (m - k) + 1ll * (siz[y] - k) * (n - m - (siz[y] - k)); f[x][j] = max(f[x][j], f[x][j - k] + f[y][k] + val * w); &#125; &#125; &#125; &#125; &#125; int main(void) &#123; memset(f, -1, sizeof(f)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(&#123;v, d&#125;); G[v].push_back(&#123;u, d&#125;); &#125; dp(1, 0); printf(\"%lld\\n\", f[1][m]); return 0; &#125; æ¢æ ¹ DP åŒæ ·ï¼Œä¹Ÿä¸æ˜¯å¾ˆéš¾ã€‚ [POI2008] STA-Station Portal. æ¢æ ¹ DP çš„æ¨¡æ¿é¢˜ã€‚åœ¨æ¢æ ¹çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å­æ ‘å¤§å°å’Œçˆ¶äº² xxx çš„ç­”æ¡ˆï¼Œé‚£ä¹ˆå„¿å­ yyy çš„ç­”æ¡ˆç›¸æ¯”çˆ¶äº²æ¥è®²ï¼Œå®ƒæ‰€æœ‰çš„å­æ ‘æ·±åº¦éƒ½å‡å» 111ï¼Œè€Œä¸æ˜¯å®ƒå­æ ‘çš„æ·±åº¦éƒ½åŠ ä¸Šäº† 111ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int s[1000005], dep[1000005]; i64 f[1000005]; vector &lt;int> G[1000005]; inline void addedge(int u, int v) &#123; G[u].push_back(v); &#125; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1, s[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y != fa) dfs(y, x), s[x] += s[y]; &#125; &#125; void dp(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y != fa) &#123; f[y] = f[x] - s[y] + (n - s[y]); // -s[y], +(n - s[y]) dp(y, x); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) f[1] += dep[i]; dp(1, 0); i64 ans = 0; int id = 0; for (int i = 1; i &lt;= n; ++i) if (f[i] > ans) ans = f[i], id = i; printf(\"%d\\n\", id); return 0; &#125; DAG ä¸Šçš„ DP æŒ‰ç…§æ‹“æ‰‘åºè½¬ç§»ã€‚ [CF721C] The Journey Portal. è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨åœ¨ iii èµ°è¿‡ jjj ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; const int INF = 0x3f3f3f3f; int n, m, k, ans, in[5005]; int f[5005][5005]; int pre[5005][5005]; vector&lt;pair&lt;int, int>> G[5005]; void Kahn(void) &#123; queue&lt;int> q; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) q.push(i); f[1][1] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].first, w = G[u][i].second; for (int j = 1; j &lt;= n; ++j) &#123; if (f[v][j + 1] > f[u][j] + w) &#123; f[v][j + 1] = f[u][j] + w; pre[v][j + 1] = u; &#125; if (f[n][j] &lt;= k) ans = max(ans, j); &#125; --in[v]; if (in[v] == 0) q.push(v); &#125; &#125; &#125; int p[5005]; void dfs(int x, int t) &#123; p[t] = x; if (t > 1) dfs(pre[x][t], t - 1); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].emplace_back(make_pair(v, d)); ++in[v]; &#125; Kahn(); printf(\"%d\\n\", ans); dfs(n, ans); for (int i = 1; i &lt;= ans; ++i) printf(\"%d \", p[i]); putchar('\\n'); return 0; &#125; æ‚é¢˜ è¡¥å……ä¸€äº›é¢˜ç›®ã€‚ [CF274B] Zero Tree Portal. æ¯æ¬¡å¿…é¡»æ“ä½œ 111 èŠ‚ç‚¹çš„æ¡ä»¶è¿‡äºå¥‡æ€ªï¼Œè®¾ f(x),g(x)f(x),g(x)f(x),g(x) åˆ†åˆ«ä»£è¡¨è¿™ä¸ªèŠ‚ç‚¹åº”è¯¥åŠ å‡å¤šå°‘ï¼Œç„¶åéœ€è¦å–å­æ ‘ä¸­çš„æœ€å¤§å€¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, a[100005]; vector&lt;int> G[100005]; i64 f[100005], g[100005]; // f[x] åŠ ï¼Œg[x] å‡ void dfs(int x, int fa) &#123; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); f[x] = max(f[x], f[y]); g[x] = max(g[x], g[y]); &#125; int k = a[x] + f[x] - g[x]; if (k > 0) g[x] += k; else f[x] -= k; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; dfs(1, 0); cout &lt;&lt; f[1] + g[1] &lt;&lt; \"\\n\"; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"æ ‘å½¢ DP","slug":"æ ‘å½¢-DP","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E5%BD%A2-DP/"},{"name":"å›¾ä¸Š DP","slug":"å›¾ä¸Š-DP","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E4%B8%8A-DP/"}]},{"title":"ç”Ÿæˆæ ‘é—®é¢˜","slug":"notes/å›¾è®º/span-tree","date":"2022-10-14T00:00:00.000Z","updated":"2022-10-14T00:00:00.000Z","comments":true,"path":"9acb5cb3/","link":"","permalink":"https://james1badcreeper.github.io/9acb5cb3/","excerpt":"åœ¨æ— å‘å›¾ä¸­ï¼Œç”Ÿæˆæ ‘æŒ‡ä¸€æ£µç”±å…¨éƒ¨é¡¶ç‚¹å’Œç»„æˆçš„æ ‘ï¼Œè€Œå½“ä¸­è¾¹æƒä¹‹å’Œæœ€å°çš„ç”Ÿæˆæ ‘ç§°ä¸ºæœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spanning Treeï¼ŒMSTï¼‰ã€‚æœ¬æ–‡ä¼šå¼•å¯¼ä½ å­¦ä¹  MST çš„ Kruskal å’Œ Prim ç®—æ³•ã€‚","text":"åœ¨æ— å‘å›¾ä¸­ï¼Œç”Ÿæˆæ ‘æŒ‡ä¸€æ£µç”±å…¨éƒ¨é¡¶ç‚¹å’Œç»„æˆçš„æ ‘ï¼Œè€Œå½“ä¸­è¾¹æƒä¹‹å’Œæœ€å°çš„ç”Ÿæˆæ ‘ç§°ä¸ºæœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spanning Treeï¼ŒMSTï¼‰ã€‚æœ¬æ–‡ä¼šå¼•å¯¼ä½ å­¦ä¹  MST çš„ Kruskal å’Œ Prim ç®—æ³•ã€‚ æœ€å°ç”Ÿæˆæ ‘ å¸¸è§çš„æ±‚è§£ MST çš„æ–¹æ³•æœ‰ä¸¤ç§ï¼šKruskal å’Œ Primã€‚æ¨¡æ¿ã€‚ Kruskal Kruskal åŸºäºè´ªå¿ƒçš„æ€æƒ³ã€‚Kruskal å…ˆæŠŠ mmm æ¡è¾¹è¿›è¡Œæ’åºï¼Œç„¶åæ£€æŸ¥æ¯æ¡è¾¹ u,vu,vu,vï¼Œå¦‚æœ uuu å’Œ vvv åœ¨åŒä¸€ä¸ªè¿é€šåˆ†é‡ä¸­ï¼Œé‚£ä¹ˆåŠ å…¥åå°±ä¼šå½¢æˆç¯ï¼Œä¸èƒ½åŠ å…¥ã€‚è‹¥ä¸åœ¨å‘¢ï¼Ÿé‚£å°±ç›´æ¥åŠ å…¥ï¼Œä¸€å®šæ˜¯æœ€ä¼˜çš„ã€‚è¯æ˜å¯ä»¥ä½¿ç”¨åè¯æ³•ï¼Œè¿™é‡Œç•¥å»ã€‚ å®ç°ä¸Šï¼Œæ’åºç›´æ¥ç”¨ sortï¼Œç»´æŠ¤çš„è¿‡ç¨‹å¯ä»¥é‡‡ç”¨å¹¶æŸ¥é›†ï¼Œå‚è€ƒä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, fa[5005]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; struct edge &#123; int u, v, w; bool operator&lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[200005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); sort(e + 1, e + m + 1); int tot = 1, ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = find(e[i].u), v = find(e[i].v); if (u == v) continue; ++tot; fa[u] = v; ans += e[i].w; if (tot == n) break; &#125; if (tot != n) puts(\"orz\"); else printf(\"%d\\n\", ans); return 0; &#125; æ—¶é—´å¤æ‚åº¦ O(mlogâ¡n+nlogâ¡n)\\mathcal{O}(m\\log n+n\\log n)O(mlogn+nlogn)ï¼ˆä¸€èˆ¬è®¤ä¸º m&gt;nm &gt; nm&gt;nï¼Œæ‰€ä»¥å†™ä½œ O(mlogâ¡n)\\mathcal{O}(m\\log n)O(mlogn)ï¼‰ã€‚ Prim Prim åŒæ ·åŸºäºè´ªå¿ƒçš„æ€æƒ³ï¼Œè¯»è€…åº”è¯¥äº†è§£è¿‡ Dijkstra ç®—æ³•ï¼ŒPrim å’Œ Dijkstra å¤§æ¦‚å°±æ˜¯ç›¸åŒçš„åŸç†ã€‚ Prim ç®—æ³•ç»´æŠ¤çš„æ˜¯ MST çš„ä¸€éƒ¨åˆ†ã€‚æœ€åˆï¼ŒPrim ç¡®å®š 111 å·èŠ‚ç‚¹å±äº MSTï¼ˆå³å°† 111 ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼‰ã€‚ è®¾ç¡®å®šå±äº MST çš„ç‚¹é›†ä¸º TTTï¼Œæœªç¡®å®šä¸º SSSã€‚Prim ä¼šæ‰¾åˆ°è¾¹æƒæœ€å°çš„è¾¹ (u,v),uâˆˆT,vâˆˆS(u,v),u\\in T,v\\in S(u,v),uâˆˆT,vâˆˆSï¼Œç„¶åå°†è¿™æ¡è¾¹åŠ å…¥ MSTã€‚ å®ç°æ—¶å¼€ä¸€ä¸ª ddd æ•°ç»„ï¼Œå½“ iâˆˆSi\\in SiâˆˆS æ—¶ï¼Œd[i]d[i]d[i] ä»£è¡¨ä¸é›†åˆ TTT ä¸­èŠ‚ç‚¹ä¹‹é—´æƒå€¼æœ€å°çš„è¾¹çš„æƒå€¼ï¼Œæœ€ç»ˆç­”æ¡ˆå°±æ˜¯ âˆ‘d\\sum dâˆ‘dã€‚ å‘æ²¡å‘ç°è¿™ä¸€è¿‡ç¨‹å¾ˆåƒ Dijkstraï¼Ÿçš„ç¡®å¦‚æ­¤ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int G[5005][5005], d[5005], v[5005]; void Prim(void) &#123; memset(d, 0x3f, sizeof d); d[1] = 0; for (int op = 1; op &lt; n; ++op) &#123; int x = 0; for (int i = 1; i &lt;= n; ++i) if (!v[i] &amp;&amp; (d[i] &lt; d[x])) x = i; v[x] = 1; for (int y = 1; y &lt;= n; ++y) if (v[y] == 0) d[y] = min(d[y], G[x][y]); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(G, 0x3f, sizeof G); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u][v] = G[v][u] = min(G[u][v], w); &#125; Prim(); int ans = 0; for (int i = 1; i &lt;= n; ans += d[i++]) if (d[i] > 1e9) return puts(\"orz\"), 0; return !printf(\"%d\\n\", ans); &#125; Prim çš„å¤æ‚åº¦æ˜¯ O(n2)\\mathcal{O}(n^2)O(n2)ï¼Œè™½ç„¶å’Œ Dijkstra ä¸€æ ·å¯ä»¥ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–åˆ° O(mlogâ¡n)\\mathcal{O}(m\\log n)O(mlogn)ï¼Œä½†æ˜¯è¿™æ—¶å°±ä¸å¦‚ç›´æ¥ç”¨ Kruskalã€‚æ‰€ä»¥ Prim ç”¨äºç¨ å¯†å›¾ï¼ˆå°¤å…¶æ˜¯å®Œå…¨å›¾ï¼‰çš„ MST æ±‚è§£ã€‚ Boruvka å¯¹äºä¸€ä¸ªç‚¹ iiiï¼Œå…¶æœ€å°æƒå€¼çš„ä¸´è¾¹å¿…å®šåœ¨ MST ä¸Šã€‚é‚£ä¹ˆè¿­ä»£ logâ¡n\\log nlogn æ¬¡ï¼Œæ¯æ¬¡æ‰«ææ¯æ¡è¾¹ï¼Œç„¶ååˆå¹¶è¿é€šå—ã€‚ ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º O(mlogâ¡n)O(m\\log n)O(mlogn)ï¼Œä½†æ˜¯å®é™…ä¸­å¹¶ä¸å¸¸ç”¨ã€‚å®ç”¨çš„æ˜¯è¿™ä¸ªæ€æƒ³ã€‚æ¯”å¦‚ç»™å®šä¸€å¼  nnn ä¸ªç‚¹çš„å®Œå…¨å›¾ï¼Œè¾¹æƒé€šè¿‡æŸç§æ–¹å¼è®¡ç®—ã€‚è¿™æ—¶å¯ä»¥ä½¿ç”¨ Boruvka ç®—æ³•ï¼Œåˆ©ç”¨æ•°æ®ç»“æ„å¿«é€Ÿè®¡ç®—ä¸åœ¨å½“å‰è¿é€šå—çš„æœ€å°è¾¹æƒã€‚ å…¶å®ƒç”Ÿæˆæ ‘ ç”Ÿæˆæ ‘é—®é¢˜æœ‰ä¸€äº›å˜ç§ï¼Œè¿™é‡Œç®€å•ä»‹ç»ä¸€ä¸‹ï¼š æœ€å°ç“¶é¢ˆç”Ÿæˆæ ‘ è¿™ç±»é—®é¢˜å½¢å¦‚è¿™æ ·ï¼šç»™å‡ºä¸€ä¸ªå¸¦æƒæ— å‘å›¾ï¼Œæ±‚ä¸€æ£µç”Ÿæˆæ ‘ï¼Œä½¿å¾—æœ€å¤§è¾¹æƒå€¼å°½é‡å°ã€‚ æ€ä¹ˆæ±‚å‘¢ï¼Ÿæˆ‘ä»¬è‚¯å®šè¦æŠŠæ‰€æœ‰è¾¹éƒ½æ’åºï¼Œç„¶åæ±‚è§£ã€‚ç­‰ç­‰ï¼Œè¿™ä¸å°±æ˜¯ Kruskal ç®—æ³•å—ï¼Ÿçš„ç¡®å¦‚æ­¤ã€‚åŸå›¾çš„æœ€å°ç”Ÿæˆæ ‘å°±ä¸€å®šæ˜¯æœ€å°ç“¶é¢ˆç”Ÿæˆæ ‘ï¼ˆä½†è¦æ³¨æ„æœ€å°ç“¶é¢ˆç”Ÿæˆæ ‘ä¸ä¸€å®šæ˜¯æœ€å°ç”Ÿæˆæ ‘ï¼‰ã€‚ æœ€å°ç“¶é¢ˆè·¯ æ±‚å¸¦æƒæ— å‘å›¾ uuu å’Œ vvv çš„ä¸€æ¡è·¯å¾„ï¼Œä½¿å¾—è¿™æ¡è·¯å¾„ä¸Šçš„æœ€å¤§è¾¹æƒå€¼æœ€å°ï¼Œè¿™æ ·çš„è·¯è¢«ç§°ä¸ºæœ€å°ç“¶é¢ˆè·¯ã€‚ æ€ä¹ˆåšå‘¢ï¼Ÿå¯ä»¥ä½¿ç”¨äºŒåˆ† + 01 BFS æ¥è§£å†³ï¼Œä½†æ•ˆç‡è¾ƒä½ã€‚å¯ä»¥æ±‚åŸå›¾çš„ MSTï¼Œç„¶åæ‰€æœ‰è·¯å¾„å¿…å®šåœ¨ MST ä¸Šã€‚ä¸ºä»€ä¹ˆå¯ä»¥è¿™ä¹ˆåšå‘¢ï¼Ÿå¯ä»¥ç”¨åè¯æ³•ï¼Œä¼šè¯æ˜å‡ºè¿™æ ·ä¸€ä¸ªç»“è®ºï¼šå¦‚æœå­˜åœ¨ä¸€æ¡è·¯å¾„ä¸åœ¨ MST ä¸Šï¼Œé‚£ä¹ˆè¿™ä¸ª MST ä¸€å®šæ˜¯å‡çš„ã€‚ æ¬¡å°ç”Ÿæˆæ ‘ æ¨¡æ¿ã€‚ è¿™é‡Œåªè®¨è®ºä¸¥æ ¼æ¬¡å°ç”Ÿæˆæ ‘ï¼Œéä¸¥æ ¼çš„åŒç†ã€‚ ç”±äº Kruskal ç®—æ³•çš„è¿‡ç¨‹ï¼Œå¯ä»¥è¯æ˜æ¬¡å°ç”Ÿæˆæ ‘åªå’Œæœ€å°ç”Ÿæˆæ ‘æœ‰ä¸€æ¡è¾¹å·®è·ã€‚æ¥ä¸‹æ¥è€ƒè™‘å¦‚ä½•æ›¿æ¢ï¼š è®¾æœ€å°ç”Ÿæˆæ ‘ä¸º TTTï¼Œæƒå€¼å’Œä¸º SSSï¼Œé‚£ä¹ˆéå†æ¯ä¸€æ¡è¾¹ï¼ŒåŠ å…¥ä¸€æ¡è¾¹åæ ‘ä¸Šä¼šå‡ºç°ä¸€ä¸ªç¯ï¼Œå†æ–­æ‰è¿™ä¸ªç¯ä¸­è¾¹æƒæœ€å¤§çš„è¾¹ï¼ˆè‹¥åŠ å…¥çš„ä¹Ÿæ˜¯æœ€å¤§çš„ï¼Œé‚£ä¹ˆéœ€è¦æ–­æ‰æ¬¡å¤§çš„ï¼Œç”±äºåŸæ¥å·²ç»æ˜¯ MSTï¼Œæ˜¾ç„¶åŠ å…¥çš„åªèƒ½å¤§äºç­‰äºï¼‰ï¼Œå¯¹ä¸Šè¿°æ‰€æœ‰ç”Ÿæˆçš„ç­”æ¡ˆå– minâ¡\\minmin ä¹‹åå°±å¯ä»¥å¾—åˆ°ç­”æ¡ˆã€‚ ç°åœ¨çš„é—®é¢˜å°±æ˜¯ï¼Œå¦‚ä½•é«˜æ ¡ç»´æŠ¤ u,vu,vu,v è·¯å¾„ä¸Šçš„æœ€å¤§å€¼å‘¢ï¼Ÿ é‡‡ç”¨æ ‘ä¸Šå€å¢æ³•ï¼Œç±»ä¼¼äº ST è¡¨ï¼Œå­˜å‚¨æ¯ä¸ªç‚¹å‘ä¸Š 2i2^i2i æ¡è¾¹çš„æœ€å¤§å€¼ä¸æ¬¡å¤§å€¼ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å€å¢æŸ¥è¯¢å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> #include &lt;cstring> using namespace std; typedef long long i64; const int INF = 1e9; const i64 INF64 = 2e18; struct edge &#123; int u, v, w; bool use; bool operator &lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[300005]; int n, m; int bin[100005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; #define pii pair&lt;int, int> vector&lt;pii> G[100005]; i64 ans0 = 0; void Kruskal(void) &#123; for (int i = 1; i &lt;= n; ++i) bin[i] = i; sort(e + 1, e + m + 1); int tot = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = find(e[i].u), v = find(e[i].v); if (u != v) &#123; ans0 += e[i].w; bin[u] = v; e[i].use = true; G[e[i].u].push_back(&#123;e[i].v, e[i].w&#125;); G[e[i].v].push_back(&#123;e[i].u, e[i].w&#125;); ++tot; &#125; if (tot == n - 1) break; &#125; &#125; int dep[100005], lg[100005]; int f[100005][20]; int mx[100005][20], mx2[100005][20]; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; f[x][0] = fa; mx2[x][0] = -INF; for (int i = 1; (1 &lt;&lt; i) &lt;= dep[x]; ++i) &#123; f[x][i] = f[f[x][i - 1]][i - 1]; int g[4] = &#123;mx[x][i - 1], mx[f[x][i - 1]][i - 1], mx2[x][i - 1], mx2[f[x][i - 1]][i - 1]&#125;; sort(g, g + 4); mx[x][i] = g[3]; int p = 2; while (p >= 0 &amp;&amp; g[p] == g[3]) --p; mx2[x][i] = (p == -1 ? -INF : g[p]); &#125; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, w = G[x][i].second; if (y != fa) &#123; mx[y][0] = w; dfs(y, x); &#125; &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; i64 calc(int x, int y, int val) &#123; int res = -INF; for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) &#123; if (val != mx[x][i]) res = max(res, mx[x][i]); else res = max(res, mx2[x][i]); x = f[x][i]; &#125; return res; &#125; int main(void) &#123; ios::sync_with_stdio(false); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); Kruskal(); dfs(1, 0); i64 ans = INF64; for (int i = 1; i &lt;= m; ++i) if (!e[i].use) &#123; int lca = LCA(e[i].u, e[i].v); i64 tmpa = calc(e[i].u, lca, e[i].w); i64 tmpb = calc(e[i].v, lca, e[i].w); ans = min(ans, ans0 - max(tmpa, tmpb) + e[i].w); &#125; if (ans != INF64) printf(\"%lld\\n\", ans); else puts(\"-1\"); return 0; &#125; æœ‰å‘å›¾ä¸­æœ‰ä¸€ç±»ç”Ÿæˆæ ‘ç§°ä¸ºæœ€å°æ ‘å½¢å›¾ã€‚è¿™ä¸ªé—®é¢˜æ¯”è¾ƒå¤æ‚ï¼Œä¸åœ¨æœ¬æ–‡ä¸­è®¨è®ºã€‚æ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥è‡ªè¡Œäº†è§£ã€‚ è¿˜æœ‰ä¸€ç±»é—®é¢˜ç§°ä¸º k å°ç”Ÿæˆæ ‘ï¼Œä½†æ˜¯è¿™ç§é—®é¢˜çš„åšæ³•ç¬”è€…æš‚æ—¶æ²¡æœ‰äº†è§£ã€‚æ®é—»åœ¨å¤§ç¥åˆ˜æ±ä½³çš„ã€Šç®—æ³•è‰ºæœ¯ä¸ä¿¡æ¯å­¦ç«èµ›ã€‹P300 ä¸­æœ‰è¯´æ˜ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡ŒæŒ‘æˆ˜ Problemset è¿™é‡Œçš„é¢˜ç›®éƒ½æ¯”è¾ƒç®€å•ã€‚ ç®€å•ç”Ÿæˆæ ‘ è¿™æ˜¯æœ€åŸºæœ¬çš„ç”Ÿæˆæ ‘é—®é¢˜ã€‚ [Luogu P1195] å£è¢‹çš„å¤©ç©º Portal. è¿™ä¸ª KKK æ˜¯ä»€ä¹ˆï¼Ÿä¸è¦ç´§ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä½¿ç”¨ Kruskal ç®—æ³•ï¼Œä¸è¿‡ä¸ä¸€å®šè¦è¿æˆä¸€æ£µæ ‘ï¼Œæˆ‘ä»¬åªè¦æŠŠè¿™äº›äº‘è¿æˆ KKK ä¸ªå³å¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåªéœ€è¦è¿ Nâˆ’KN-KNâˆ’K æ¡è¾¹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, m, k; struct edge &#123; int u, v, d; edge(int u = 0, int v = 0, int d = 0) : u(u), v(v), d(d) &#123;&#125; bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125;a[10005]; int fa[1005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;a[i].u, &amp;a[i].v, &amp;a[i].d); sort(a + 1, a + m + 1); int ans = 0, cnt = 0; for (int i = 1; i &lt;= m; ++i) &#123; int x = find(a[i].u), y = find(a[i].v); if (x == y) continue; fa[x] = y, ans += a[i].d, ++cnt; if (cnt == n - k) &#123; printf(\"%d\\n\", ans); return 0; &#125; &#125; puts(\"No Answer\"); return 0; &#125; [UVa 1395] Slim Span Portal. ç»™å®šä¸€ä¸ª n(nâ‰¤100)n(n\\le 100)n(nâ‰¤100) ä¸ªç‚¹çš„æ— å‘å›¾ï¼Œæ±‚æœ€å¤§è¾¹å‡æœ€å°è¾¹çš„å€¼å°½é‡å°çš„ç”Ÿæˆæ ‘ã€‚ å¦‚æœæœ€å°è¾¹ç¡®å®šï¼Œæˆ‘ä»¬æ±‚å‡ºæœ€å°ç”Ÿæˆæ ‘ï¼Œé‚£ä¹ˆå°±å¯ä»¥æ±‚å‡ºè¿™ä¸ªå€¼äº†ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int fa[105]; int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]); &#125; struct edge &#123; int u, v, d; edge(int u, int v, int d) : u(u), v(v), d(d) &#123;&#125; inline bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125;; vector &lt;edge> e; int n, m; inline int kruskal(void) &#123; sort(e.begin(), e.end()); int ans = 0x7fffffff; for (int L = 0; L &lt; m; ++L) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i; int cnt = 0; for (int R = L; R &lt; m; ++R) &#123; int a = find(e[R].u), b = find(e[R].v); if (a == b) continue; fa[a] = b; if (++cnt == n - 1) &#123; ans = min(ans, e[R].d - e[L].d); break; &#125; &#125; &#125; if (ans == 0x7fffffff) return -1; return ans; &#125; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; e.clear(); for (int i = 0; i &lt; m; ++i) &#123; int u = read(), v = read(), d = read(); e.push_back(edge(u, v, d)); &#125; printf(\"%d\\n\", kruskal()); &#125; return 0; &#125; [Luogu P2700] é€ä¸ªå‡»ç ´ Portal. æˆ‘ä»¬ç°å‡è®¾éœ€è¦æ‘§æ¯æ‰€æœ‰çš„è¾¹ï¼Œç„¶åæŒ‰è¾¹æƒä»å¤§åˆ°å°æ’åºã€‚å¦‚æœä¸¤ä¸ªç‚¹éƒ½ä¸æ˜¯æ•ŒäººèŠ‚ç‚¹å°±è¿è¾¹ï¼Œæ³¨æ„çˆ¶äº²ä¹Ÿè¦è®¾ç½®ä¸ºæ•ŒäººèŠ‚ç‚¹ï¼ˆå¦‚æœè¿æ¥çš„ç‚¹æœ‰æ•Œäººï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; struct edge &#123; int u, v, d; edge(int u = 0, int v = 0, int d = 0) : u(u), v(v), d(d) &#123;&#125; bool operator &lt; (const edge &amp;a) const &#123; return d > a.d; &#125; &#125;a[100005]; int n, k, s[100005]; int fa[100005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= k; ++i) &#123; int x; scanf(\"%d\", &amp;x); s[x] = true; &#125; long long ans = 0; for (int i = 1; i &lt; n; ++i) &#123; scanf(\"%d%d%d\", &amp;a[i].u, &amp;a[i].v, &amp;a[i].d); ans += a[i].d; &#125; for (int i = 1; i &lt;= n; ++i) fa[i] = i; sort(a + 1, a + n + 1); for (int i = 1; i &lt; n; ++i) &#123; int x = find(a[i].u), y = find(a[i].v); if (s[x] &amp;&amp; s[y]) continue; fa[x] = y; ans -= a[i].d; s[y] = (s[x] | s[y]); &#125; printf(\"%lld\\n\", ans); return 0; &#125; [USACO08OCT] Watering Hole G Portal. æˆ‘ä»¬åªéœ€è¦å¢è®¾ä¸€ä¸ªæ°´äº•ç‚¹ 000ï¼Œè®©æ¯ä¸€ä¸ªç‰§åœºéƒ½ä¸ 000 è¿ä¸€æ¡ WiW_iWiâ€‹ çš„è¾¹ï¼Œç„¶åä½¿ç”¨ Primï¼ˆå› ä¸ºæ˜¯å®Œå…¨å›¾ï¼Œå¼€å¤§æ•°æ®èŒƒå›´å³å¯æ€æ­» Kruskalï¼‰æ±‚è§£æœ€å°ç”Ÿæˆæ ‘ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, d[305]; bool v[305]; int a[305][305]; void Prim(void) &#123; memset(d, 0x3f, sizeof(d)); d[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x = -1; for (int j = 0; j &lt;= n; ++j) if (!v[j] &amp;&amp; (x == -1 || d[j] &lt; d[x])) x = j; v[x] = true; for (int j = 0; j &lt;= n; ++j) if (!v[j]) d[j] = min(d[j], a[x][j]); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int w; scanf(\"%d\", &amp;w); a[0][i] = a[i][0] = w; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[i][j]); Prim(); int ans = 0; for (int i = 0; i &lt;= n; ++i) ans += d[i]; printf(\"%d\\n\", ans); return 0; &#125; [UVa 1151] Buy or Build Portal. é€šè¿‡äºŒç»´æšä¸¾ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾çš„æŠŠè¿™ç©æ„è½¬åŒ–æˆå›¾ã€‚å¯¹ç€å›¾ä½¿ç”¨ Kruskalï¼Œå¾—åˆ° nâˆ’1n-1nâˆ’1 æ¡è¾¹ï¼Œå°±æ˜¯å¯èƒ½æˆä¸ºæœ€ç»ˆç­”æ¡ˆçš„è¾¹ã€‚ç„¶åæšä¸¾è´­ä¹°å“ªäº›å¥—é¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x * f; &#125; int n, q, cost[8]; vector &lt;int> sub[8]; int x[1005], y[1005]; struct edge &#123; int u, v, d; edge(int u = 0, int v = 0, int d = 0) : u(u), v(v), d(d) &#123;&#125; bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125;; vector &lt;edge> e, es; int fa[1005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; inline void UnionFind_init(void) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i; &#125; int kruskal(int cnt, const vector &lt;edge> &amp;G, bool flag) &#123; if (cnt == 1) return 0; int ans = 0; for (int i = 0; i &lt; G.size(); ++i) &#123; int x = find(G[i].u), y = find(G[i].v); if (x == y) continue; fa[x] = y; ans += G[i].d; if (flag) es.push_back(G[i]); --cnt; if (cnt == 1) break; &#125; return ans; &#125; int main(void) &#123; int T = read(); while (T--) &#123; n = read(), q = read(); for (int i = 0; i &lt; q; ++i) &#123; int m = read(); cost[i] = read(); sub[i].clear(); while (m--) sub[i].push_back(read()); &#125; for (int i = 1; i &lt;= n; ++i) x[i] = read(), y[i] = read(); e.clear(), es.clear(); for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) e.push_back(edge(i, j, (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]))); sort(e.begin(), e.end()); UnionFind_init(); int ans = kruskal(n, e, true); for (int i = 0; i &lt; (1 &lt;&lt; q); ++i) &#123; UnionFind_init(); int cnt = n, c = 0; for (int j = 0; j &lt; q; ++j) if (i &amp; (1 &lt;&lt; j)) &#123; c += cost[j]; for (int k = 1; k &lt; sub[j].size(); ++k) &#123; int x = find(sub[j][k]), y = find(sub[j][0]); if (x != y) fa[x] = y, --cnt; &#125; &#125; ans = min(ans, c + kruskal(cnt, es, false)); &#125; printf(\"%d\\n\", ans); if (T) putchar('\\n'); &#125; return 0; &#125; [CF609E] Minimum spanning tree for each edge Portal. è·Ÿæ¬¡å°ç”Ÿæˆæ ‘çš„æ€è·¯æ˜¯ä¸€æ ·çš„ï¼Œåœ¨è·¯å¾„ä¸Šæ‰¾ä¸€æ¡æœ€å¤§çš„è¾¹æ¢ä¸‹æ¥å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> using namespace std; typedef long long i64; int n, m; i64 ans = 0; struct edge &#123; int u, v, d, id; bool use; bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125; e[200005]; int bin[200005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; int f[20][200005], dep[200005], w[20][200005]; vector&lt;pair&lt;int, int>> G[200005]; void dfs(int x, int fa) &#123; f[0][x] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= 18; ++i) f[i][x] = f[i - 1][f[i - 1][x]], w[i][x] = max(w[i - 1][x], w[i - 1][f[i - 1][x]]); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, d = G[x][i].second; if (y != fa) &#123; w[0][y] = d; dfs(y, x); &#125; &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); int ans = 0; for (int i = 18; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) ans = max(ans, w[i][x]), x = f[i][x]; if (x == y) return ans; for (int i = 18; i >= 0; --i) if (f[i][x] != f[i][y]) &#123; ans = max(&#123;ans, w[i][x], w[i][y]&#125;); x = f[i][x], y = f[i][y]; &#125; return max(&#123;ans, w[0][x], w[0][y]&#125;); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].d), e[i].id = i; sort(e + 1, e + m + 1); for (int i = 1; i &lt;= n; ++i) bin[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v, d = e[i].d; int x = find(u), y = find(v); if (x != y) &#123; bin[x] = y; e[i].use = true; G[u].push_back(&#123;v, d&#125;); G[v].push_back(&#123;u, d&#125;); ans += d; &#125; &#125; dfs(1, 0); static i64 p[200005]; for (int i = 1; i &lt;= m; ++i) &#123; if (e[i].use) p[e[i].id] = ans; else p[e[i].id] = ans - LCA(e[i].u, e[i].v) + e[i].d; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%lld\\n\", p[i]); return 0; &#125; [CF76A] Gift Portal. æšä¸¾èƒ½å¤Ÿä½¿ç”¨çš„æœ€å¤§çš„ gggï¼Œå¦‚æœä¸€æ¡è¾¹æ²¡èƒ½è¢«é€‰ä¸­åˆ™åˆ æ‰è¿™æ¡è¾¹ã€‚æ—¶é—´å¤æ‚åº¦ O(mnlogâ¡n)O(mn\\log n)O(mnlogn)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, G, S, g[50005]; struct edge &#123; int u, v, g, s; bool operator &lt; (const edge &amp;a) const &#123; return s &lt; a.s; &#125; &#125; e[50005]; multiset&lt;edge> E; i64 ans = 2e18; int f[205]; int find(int x) &#123; if (f[x] == x) return x; return f[x] = find(f[x]); &#125; bool check(int mxg) &#123; int cnt = 1; for (int i = 1; i &lt;= n; ++i) f[i] = i; for (auto it = E.begin(); it != E.end(); ++it) &#123; auto e = *it; if (e.g > g[mxg]) continue; int x = find(e.u), y = find(e.v); if (x == y) continue; ++cnt; f[x] = y; if (cnt == n) break; &#125; return cnt == n; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;G, &amp;S); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].g, &amp;e[i].s), E.insert(e[i]), g[i] = e[i].g; sort(g + 1, g + m + 1); int L = 0, R = m + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) R = mid; else L = mid; &#125; if (R == m + 1) return puts(\"-1\"), 0; for (int mxg = R; mxg &lt;= m; ++mxg) &#123; int cnt = 1, now = 0; for (int i = 1; i &lt;= n; ++i) f[i] = i; for (auto it = E.begin(); it != E.end(); ++it) &#123; auto e = *it; if (e.g > g[mxg]) continue; int x = find(e.u), y = find(e.v); if (x == y) &#123; auto id = it; --id; E.erase(it); it = id; continue; &#125; ++cnt; f[x] = y; now = e.s; if (cnt == n) break; &#125; if (cnt == n) ans = min(ans, 1ll * now * S + 1ll * g[mxg] * G); &#125; printf(\"%lld\\n\", ans); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"ç”Ÿæˆæ ‘","slug":"ç”Ÿæˆæ ‘","permalink":"https://james1badcreeper.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"æ‹“æ‰‘æ’åºä¸å›¾çš„è¿é€šæ€§é—®é¢˜","slug":"notes/å›¾è®º/connectivity","date":"2022-10-04T00:00:00.000Z","updated":"2022-10-04T00:00:00.000Z","comments":true,"path":"242bd056/","link":"","permalink":"https://james1badcreeper.github.io/242bd056/","excerpt":"åœ¨å›¾ä¸­ï¼Œå¦‚ä½•åˆ¤æ–­ä¸€å¼ å›¾æ˜¯å¦è¿é€šï¼Ÿå¦‚æœåˆ æ‰æŸæ¡è¾¹ï¼Œå®ƒè¿˜è¿é€šå—ï¼Ÿæœ‰å‘å›¾å‘¢ï¼Ÿè¿™äº›æ“ä½œæœ‰ä»€ä¹ˆç‰¹æ®Šæ€§è´¨å—ï¼Ÿæœ¬æ–‡å°†æ¢è®¨ä»¥ Tarjan ç®—æ³•ä¸ºæ ¸å¿ƒçš„æœ‰å…³å›¾çš„è¿é€šæ€§çš„é—®é¢˜å’Œæ¬§æ‹‰è·¯é—®é¢˜ã€‚","text":"åœ¨å›¾ä¸­ï¼Œå¦‚ä½•åˆ¤æ–­ä¸€å¼ å›¾æ˜¯å¦è¿é€šï¼Ÿå¦‚æœåˆ æ‰æŸæ¡è¾¹ï¼Œå®ƒè¿˜è¿é€šå—ï¼Ÿæœ‰å‘å›¾å‘¢ï¼Ÿè¿™äº›æ“ä½œæœ‰ä»€ä¹ˆç‰¹æ®Šæ€§è´¨å—ï¼Ÿæœ¬æ–‡å°†æ¢è®¨ä»¥ Tarjan ç®—æ³•ä¸ºæ ¸å¿ƒçš„æœ‰å…³å›¾çš„è¿é€šæ€§çš„é—®é¢˜å’Œæ¬§æ‹‰è·¯é—®é¢˜ã€‚ é™¤äº† Tarjan ç®—æ³•ï¼Œå¹¶æŸ¥é›†ç­‰å†…å®¹ä¹Ÿèƒ½è§£å†³ä¸€äº›å›¾è¿é€šæ€§é—®é¢˜ï¼Œè¯·å‚ç…§ç¬”è€…ç›¸å…³æ–‡ç« ã€‚ æ‹“æ‰‘æ’åº åˆ«é—®æˆ‘ä¸ºä»€ä¹ˆæŠŠè¿™ä¸ªæ”¾åˆ°è¿™é‡Œæ¥è®²ï¼Œå› ä¸ºæ¥ä¸‹æ¥å¾ˆå¤šé¢˜éƒ½è¦ç”¨åˆ°å®ƒã€‚ ä¸¥æ ¼æ„ä¹‰ä¸Šæ¥è¯´ï¼Œæ‹“æ‰‘æ’åºä¸æ˜¯ä¸€ç§æ’åºã€‚æ˜¯å¯¹æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰GGGï¼Œå°† GGG ä¸­æ‰€æœ‰é¡¶ç‚¹æ’æˆä¸€ä¸ªçº¿æ€§åºåˆ—ï¼Œä½¿å¾—å›¾ä¸­ä»»æ„ä¸€å¯¹é¡¶ç‚¹ uuu å’Œ vvv ï¼Œè‹¥å®ƒä»¬ä¹‹é—´å­˜åœ¨ä¸€æ¡æœ‰å‘è¾¹ (u,v)(u,v)(u,v),åˆ™ uuu åœ¨çº¿æ€§åºåˆ—ä¸­å‡ºç°åœ¨ vvv ä¹‹å‰ã€‚ æ¨¡æ¿ã€‚ å¼€ä¸€ä¸ªé˜Ÿåˆ—è®°å½•æ‰€æœ‰å…¥åº¦ä¸º 000 çš„ç‚¹ï¼Œç„¶åç»´æŠ¤å³å¯ã€‚è¿™ä¸€è¿‡ç¨‹è¢«ç§°ä¹‹ä¸º Kahn ç®—æ³•ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int in[105]; vector&lt;int> G[105]; queue&lt;int> q; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; memset(in, 0, sizeof(in)); for (int i = 1; i &lt;= n; ++i) G[i].clear(); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); ++in[y]; &#125; for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) q.push(i); while (!q.empty()) &#123; int t = q.front(); q.pop(); printf(\"%d \", t); for (int i = 0; i &lt; G[t].size(); ++i) &#123; --in[G[t][i]]; if (in[G[t][i]] == 0) q.push(G[t][i]); &#125; &#125; putchar('\\n'); &#125; return 0; &#125; æ‹“æ‰‘æ’åºä¹Ÿå¯ä»¥ä½¿ç”¨ dfs å®ç°ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œå­¦ä¹ ã€‚ æœ‰çš„æ—¶å€™æ±‚çš„æ‹“æ‰‘åºè¦æ±‚å­—å…¸åºï¼Œè¿™æ—¶å€™ç›´æ¥å°†é˜Ÿåˆ—æ”¹ä¸ºä¼˜å…ˆé˜Ÿåˆ—å³å¯ã€‚ æ— å‘å›¾çš„è¿é€šæ€§ ç»™å®šæ— å‘å›¾ G=(V,E)G=(V,E)G=(V,E)ï¼Œå¦‚æœ xâˆˆVx\\in VxâˆˆVï¼Œä»å›¾ä¸­åˆ å»èŠ‚ç‚¹ xxx å’Œä¸ xxx å…³è”çš„æ‰€æœ‰è¾¹ä¹‹åï¼ŒGGG è¢«åˆ†è£‚æˆä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„ä¸ç›¸è¿çš„å­å›¾ï¼Œé‚£ä¹ˆç§° xxx ç§°ä¹‹ä¸º GGG çš„å‰²ç‚¹æˆ–å‰²é¡¶ã€‚å¦‚æœ eâˆˆVe\\in VeâˆˆVï¼Œå°† eee åˆ å»åï¼ŒGGG åˆ†è£‚æˆä¸¤ä¸ªä¸ç›¸è¿çš„å­å›¾ï¼Œåˆ™ç§° eee ä¸º GGG çš„æ¡¥æˆ–å‰²è¾¹ã€‚ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Tarjan ç®—æ³•åœ¨çº¿æ€§æ—¶é—´å†…æ±‚è§£æ— å‘å›¾çš„å‰²ç‚¹å’Œæ¡¥ã€‚ æƒ³è¦ä½¿ç”¨ Tarjan ç®—æ³•ï¼Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£å‡ ä¸ªåŸºæœ¬æ¦‚å¿µï¼š Tarjan ç®—æ³• æ—¶é—´æˆ³ã€‚æˆ‘ä»¬å¯¹å›¾è¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†ï¼ŒæŒ‰ç…§æ¯ä¸ªèŠ‚ç‚¹ç¬¬ä¸€æ¬¡è¢«è®¿é—®åˆ°çš„é¡ºåºï¼Œä¾æ¬¡ç»™äºˆ nnn ä¸ªèŠ‚ç‚¹ 1âˆ¼n1\\sim n1âˆ¼n çš„æ•´æ•°æ ‡è®°ï¼Œè®°ä¸ºæ—¶é—´æˆ³ dfn[x]dfn[x]dfn[x]ï¼Œä»£è¡¨åœ¨ DFS åºä¸­å‡ºç°çš„ä½ç½®ã€‚ æœç´¢æ ‘ã€‚åœ¨æ— å‘è¿é€šå›¾ä¸­ä»»é€‰ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘è¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†ï¼Œæ¯ä¸ªç‚¹åªè®¿é—®ä¸€æ¬¡ï¼Œæ‰€æœ‰å‘ç”Ÿé€’å½’çš„è¾¹ (x,y)(x,y)(x,y)ï¼ˆå³ xxx åˆ° yyy æ˜¯å¯¹ yyy çš„ç¬¬ä¸€æ¬¡éå†ï¼‰ï¼Œè¿™æ ·çš„è¾¹æœ‰ nâˆ’1n-1nâˆ’1 æ¡ï¼Œæ„æˆä¸€æ£µæ ‘ï¼Œç§°ä¹‹ä¸ºâ€æ— å‘è¿é€šå›¾çš„æœç´¢æ ‘â€œã€‚å¦‚æœè¿™å¼ å›¾ä¸è¿é€šï¼Œé‚£ä¹ˆå®ƒä¼šç”Ÿæˆè‹¥å¹²æ£µæ ‘ï¼Œç§°ä¹‹ä¸ºâ€æ— å‘å›¾çš„æœç´¢æ£®æ—â€œã€‚ è¿½æº¯å€¼ã€‚é™¤äº†æ—¶é—´æˆ³å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªæ¦‚å¿µï¼šè¿½æº¯å€¼ low[x]low[x]low[x]ï¼Œä¹Ÿå°±æ˜¯èƒ½ä¸ç»è¿‡çˆ¶äº²èŠ‚ç‚¹åˆ°è¾¾çš„æœ€å°æ—¶é—´æˆ³ã€‚è®¾ subtree(x)\\text{subtree}(x)subtree(x) ä»£è¡¨æœç´¢æ ‘ä¸­ä»¥ xxx çš„å­æ ‘ï¼Œlow[x]low[x]low[x] å®šä¹‰ä¸ºä»¥ä¸‹èŠ‚ç‚¹çš„æ—¶é—´æˆ³çš„æœ€å°å€¼ï¼š subtree(x)\\text{subtree}(x)subtree(x) ä¸­çš„èŠ‚ç‚¹ï¼› é€šè¿‡ 111 æ¡ä¸åœ¨æœç´¢æ ‘ä¸Šçš„è¾¹ï¼Œå¯ä»¥åˆ°è¾¾ subtree(x)\\text{subtree}(x)subtree(x) çš„èŠ‚ç‚¹ã€‚ è¿™æ˜¯ä¸€å¼ æ— å‘å›¾ï¼Œç²—è¾¹æ ‡å‡ºäº†æœç´¢æ ‘ï¼Œ1 ä¸ºæ ¹èŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹æ˜¯å®ƒçš„æ—¶é—´æˆ³ï¼Œæ‹¬å·æ ‡å‡ºäº†å®ƒçš„è¿½æº¯å€¼ å¦‚ä¸Šå›¾ï¼Œ111 èŠ‚ç‚¹çš„è¿½æº¯å€¼æ˜¯å®ƒè‡ªå·±çš„æ—¶é—´æˆ³ï¼Œ(1,5)(1,5)(1,5) ä¸€æ¡ä¸åœ¨æœç´¢æ ‘ä¸Šçš„è¾¹ä½¿å¾— low[5]=dfn[1]=1low[5]=dfn[1]=1low[5]=dfn[1]=1ï¼Œæ‰€ä»¥ 2,3,42,3,42,3,4 èŠ‚ç‚¹éƒ½æ˜¯ 555 çš„ç¥–å…ˆï¼Œåˆå› ä¸º (1,5)(1,5)(1,5) è¿™æ¡è¾¹ï¼Œæ‰€ä»¥ low[2]=low[3]=low[4]=dfn[1]=1low[2]=low[3]=low[4]=dfn[1]=1low[2]=low[3]=low[4]=dfn[1]=1ã€‚å‰©ä½™èŠ‚ç‚¹å¤§è‡´åŒç†ã€‚ æˆ‘ä»¬è®¡ç®—è¿½æº¯å€¼æ—¶ï¼Œåº”è¯¥é¦–å…ˆä»¤ low[x]=dfn[x]low[x]=dfn[x]low[x]=dfn[x]ï¼Œç„¶åè€ƒè™‘ xxx å‡ºå‘çš„æ¯æ¡è¾¹ (x,y)(x,y)(x,y)ï¼šå¦‚æœåœ¨æœç´¢æ ‘ä¸Š xxx æ˜¯ yyy çš„çˆ¶äº²ï¼Œé‚£ä¹ˆ low[x]=minâ¡{low[x],low[y]}low[x]=\\min\\{low[x], low[y]\\}low[x]=min{low[x],low[y]}ï¼›å¦‚æœ (x,y)(x,y)(x,y) ä¸æ˜¯æœç´¢æ ‘ä¸Šçš„è¾¹ï¼Œåˆ™ low[x]=minâ¡{low[x],dfn[y]}low[x]=\\min\\{low[x], dfn[y]\\}low[x]=min{low[x],dfn[y]}ã€‚ Tarjan çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n+m)O(n+m)O(n+m)ã€‚ è‡³äºè¿½æº¯å€¼ç©¶ç«Ÿæ˜¯æ€ä¹ˆæ¥çš„ï¼Œè¯»è€…å¯ä»¥è‡ªè¡ŒæŸ¥é˜…èµ„æ–™ã€‚ å‰²è¾¹åˆ¤å®šæ³•åˆ™ æ— å‘è¾¹ (x,y)(x,y)(x,y) æ˜¯å‰²è¾¹ï¼Œå½“ä¸”ä»…å½“æœç´¢æ ‘ä¸Šå­˜åœ¨ä¸€ä¸ª xxx çš„å­èŠ‚ç‚¹ yyyï¼Œæ»¡è¶³ dfn[x]&lt;low[y]dfn[x]&lt;low[y]dfn[x]&lt;low[y]ã€‚ä¹Ÿå°±æ˜¯è¯´ä» subtree(y)\\text{subtree}(y)subtree(y) å‡ºå‘ï¼Œè‹¥ä¸ç»è¿‡ (x,y)(x,y)(x,y)ï¼Œæ€ä¹ˆèµ°éƒ½æ— æ³•åˆ°è¾¾ xxx æˆ–æ¯” xxx æ›´æ—©è®¿é—®çš„èŠ‚ç‚¹ï¼ˆå› ä¸º dfn[x]&lt;low[y]dfn[x]&lt;low[y]dfn[x]&lt;low[y]ï¼Œå³æƒ³è¦åˆ° yyy å¿…é¡»ç»è¿‡ (x,y)(x,y)(x,y)ï¼Œå³ yyy è¢«å›°åœ¨ xxx çš„å­æ ‘ä¸­äº†ï¼‰ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹ä¾¿æ˜¯æ¡¥ã€‚ å¯ä»¥å‘ç°ï¼Œæ¡¥ä¸€å®šæ˜¯æœç´¢æ ‘ä¸­çš„è¾¹ï¼Œå¹¶ä¸”ä¸€ä¸ªç®€å•ç¯ä¸­çš„è¾¹ä¸€å®šéƒ½ä¸æ˜¯æ¡¥ã€‚ è™šçº¿æ ‡å‡ºäº†æ¡¥ åœ¨å­˜è¾¹çš„æ—¶å€™ä½¿ç”¨äº†ä¸€ä¸ª edges æ•°ç»„ï¼Œè¿™æ ·ä½¿ç”¨â€æˆå¯¹å˜æ¢â€œå¯ä»¥è½»æ¾çš„æ‰¾åˆ°åå‘è¾¹ã€‚è®°å½• fa çš„è¯é‡åˆ°é‡è¾¹æ—¶ä¼šå‡ºé”™ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, num = 0; // num ç”¨äºæ—¶é—´æˆ³çš„æ ‡è®° int dfn[105], low[105]; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; vector &lt;edge> edges; bool bridge[205]; vector &lt;int> G[105]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x, int in_edge) &#123; // in_edge è®°å½•é€’å½’è¿›å…¥ x çš„è¾¹çš„ç¼–å· dfn[x] = low[x] = ++num; // æ ‡è®°æ—¶é—´æˆ³ï¼Œå¹¶åœ¨åˆå§‹å°† low[x] æ ‡è®°ä¸º dfn[x] for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; // è·å–è¾¹ (x,y) if (!dfn[y]) &#123; // æœªè®¿é—® tarjan(y, G[x][i]); // é€’å½’éå† // èƒ½è·‘åˆ°è¿™é‡Œçš„è‚¯å®šæ˜¯æœç´¢æ ‘ä¸Šçš„ // æ‰€ä»¥ x æ˜¯ y çš„çˆ¶äº²èŠ‚ç‚¹äº†ï¼Œä¹Ÿå°±æ˜¯ y å±äº subtree(x) low[x] = min(low[x], low[y]); // å‰²è¾¹åˆ¤å®šæ³•åˆ™ï¼Œåœ¨æœç´¢æ ‘ä¸Šå­˜åœ¨ x çš„ä¸€ä¸ªå­èŠ‚ç‚¹ y ä½¿å¾— dfn[x] &lt; low[y] if (dfn[x] &lt; low[y]) bridge[G[x][i]] = bridge[G[x][i] ^ 1] = true; // æ ‡è®°çš„æ—¶å€™æ ‡è®°æ­£è¾¹å’Œåè¾¹ &#125; else if (G[x][i] != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); // å¦‚æœå½“å‰è¿™æ¡è¾¹æ˜¯ x->y çš„åè¾¹ y->xï¼Œé‚£ä¹ˆè¿™æ¡å‘½ä»¤ä¸ä¼šè¢«æ‰§è¡Œï¼Œå› ä¸ºå®ƒåœ¨æœç´¢æ ‘ä¸Š // ä½†æ˜¯æœ‰é‡è¾¹çš„è¯ä»–å°±ä¸æ˜¯æœç´¢æ ‘ä¸Šçš„è¾¹ &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i, -1); // å›¾ä¸ä¸€å®šè¿é€šï¼Œæ¯ä¸ªç‚¹éƒ½éœ€è¦ tarjanã€‚æœ€åˆæ²¡æœ‰è¾¹åˆ° iï¼Œç”¨ -1 ä»£æ›¿ï¼Œ-1 ^ 1 = -2 puts(\"Bridges:\"); for (int i = 0; i &lt; edges.size(); i += 2) if (bridge[i]) printf(\"%d %d\\n\", edges[i].from, edges[i].to); return 0; &#125; å‰²ç‚¹åˆ¤å®šæ³•åˆ™ æ¨¡æ¿ã€‚ å¦‚æœ xxx ä¸æ˜¯æœç´¢æ£®æ—ä¸­ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆ xxx æ˜¯å‰²ç‚¹å½“ä¸”ä»…å½“æœç´¢æ ‘ä¸Šå­˜åœ¨ xxx çš„å­èŠ‚ç‚¹ yyy æ»¡è¶³ dfn[x]â‰¤low[y]dfn[x]\\le low[y]dfn[x]â‰¤low[y]ã€‚å¦‚æœè¿™æ˜¯æ ¹èŠ‚ç‚¹ï¼Œè¿™æ ·çš„ yyy å¿…é¡»æœ‰ä¸¤ä¸ªæˆ–ä»¥ä¸Šï¼Œxxx æ‰æ˜¯å‰²ç‚¹ã€‚ ç”±äºæ˜¯å°äºç­‰äºï¼Œæ‰€ä»¥çˆ¶èŠ‚ç‚¹å’Œé‡è¾¹å³ä½¿ä¸è€ƒè™‘ä¹Ÿèƒ½å¾—åˆ°æ­£ç¡®ç»“æœã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, root, num = 0, ans = 0; int dfn[20005], low[20005]; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; vector &lt;edge> edges; bool cut[20005]; vector &lt;int> G[20005]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; int flag = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; ++flag; if (x != root || flag > 1) cut[x] = true; // å¦‚æœä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œæˆ–è€… flag >= 2ï¼Œå°±æ˜¯å‰²ç‚¹ &#125; &#125; else low[x] = min(low[x], dfn[y]); // å¯ä»¥ç›´æ¥æ›´æ–° &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) root = i, tarjan(i); // è®°å½•æ ¹èŠ‚ç‚¹ï¼Œç„¶å tarjan for (int i = 1; i &lt;= n; ++i) if (cut[i]) ++ans; printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (cut[i]) printf(\"%d \", i); putchar('\\n'); return 0; &#125; [POI2008] BLO-Blockade Portal. ä¸€å¼ è¿é€šçš„æ— å‘å›¾ï¼Œè¯·ä½ å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ iii æ±‚å‡ºï¼ŒæŠŠä¸èŠ‚ç‚¹ iii å…³è”çš„æ‰€æœ‰è¾¹å»æ‰ä»¥åï¼ˆä¸å»æ‰èŠ‚ç‚¹ iii æœ¬èº«ï¼‰ï¼Œæ— å‘å›¾æœ‰å¤šå°‘ä¸ªæœ‰åºç‚¹å¯¹ (x,y)(x,y)(x,y)ï¼Œæ»¡è¶³ xxx å’Œ yyy ä¸è¿é€šã€‚ å¦‚æœä¸€ä¸ªç‚¹ä¸æ˜¯å‰²ç‚¹ï¼Œé‚£ä¹ˆæ–­æ‰è¿™ä¸ªç‚¹æ‰€è¿çš„æ‰€æœ‰è¾¹åå›¾çš„å‰©ä½™éƒ¨åˆ†ä¾ç„¶è¿é€šï¼Œåªæœ‰è¿™ä¸ªç‚¹ä¸å›¾ä¸­å…¶å®ƒçš„æ‰€æœ‰ç‚¹æ„æˆçš„æœ‰åºç‚¹å¯¹æ»¡è¶³ä¸è¿é€šï¼Œå…±æœ‰ (nâˆ’1)Ã—2(n-1)\\times 2(nâˆ’1)Ã—2 ä¸ªã€‚ å¦‚æœè¿™ä¸ªç‚¹æ˜¯å‰²ç‚¹ï¼Œé‚£ä¹ˆæ–­æ‰åå›¾ä¼šåˆ†è£‚æˆè‹¥å¹²ä¸ªè¿é€šå—ã€‚æˆ‘ä»¬åº”è¯¥æ±‚å‡ºè¿™äº›è¿é€šå—çš„å¤§å°ï¼Œç„¶åä¸¤ä¸¤ç›¸ä¹˜å†å°†è¿™äº›ç§¯ç›¸åŠ ã€‚è®¾å†æœç´¢æ ‘ä¸­ï¼ŒèŠ‚ç‚¹ iii çš„å­èŠ‚ç‚¹é›†åˆä¸­ï¼Œæœ‰ ttt ä¸ªç‚¹æ»¡è¶³ dfn[x]â‰¤low[sk]dfn[x]\\le low[s_k]dfn[x]â‰¤low[skâ€‹]ï¼Œæ–­æ‰ä¹‹åï¼Œæ— å‘å›¾è‡³å¤šåˆ†è£‚ä¸º t+2t+2t+2 ä¸ªè¿é€šå—ï¼Œè¿™äº›è¿é€šå—åˆ†åˆ«æ˜¯ï¼šttt ä¸ªæ–­æ‰ä¹‹åçš„å°å­æ ‘ï¼Œ111 ä¸ªå½“å‰èŠ‚ç‚¹ xxx è‡ªå·±æ„æˆçš„è¿é€šå—ï¼Œå›¾çš„å‰©ä½™éƒ¨åˆ†ï¼ˆxxx çš„çˆ¶äº²åŠå…¶å®ƒï¼‰ã€‚ ç”±äº Tarjan ç®—æ³•æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª dfsã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»ä¼¼æ±‚æ ‘çš„é‡å¿ƒçš„æ–¹å¼ï¼Œè®¾åœ¨æœç´¢æ ‘ä¸­ size[x]size[x]size[x] è¡¨ç¤º xxx çš„å­æ ‘å¤§å°ï¼Œé‚£ä¹ˆæ–­æ‰ä¹‹åçš„æœ‰åºæ•°å¯¹æ•°é‡ä¸ºï¼š æ¯æ£µå°å­æ ‘æ‰€å¯¹åº”çš„ï¼š size[s1]Ã—(nâˆ’size[s1])+â€¦size[st]Ã—(nâˆ’size[st])=âˆ‘i=1tsize[si]Ã—(nâˆ’size[si])size[s_1]\\times (n-size[s_1]) + \\dots size[s_t]\\times (n-size[s_t]) = \\sum\\limits_{i=1}^{t}size[s_i]\\times (n-size[s_i]) size[s1â€‹]Ã—(nâˆ’size[s1â€‹])+â€¦size[stâ€‹]Ã—(nâˆ’size[stâ€‹])=i=1âˆ‘tâ€‹size[siâ€‹]Ã—(nâˆ’size[siâ€‹]) å½“å‰èŠ‚ç‚¹ xxx å¯¹åº”çš„ï¼š 1Ã—(nâˆ’1)=nâˆ’11\\times(n-1) = n-1 1Ã—(nâˆ’1)=nâˆ’1 å‰©ä½™éƒ¨åˆ†å¯¹åº”çš„ï¼ˆå‰è€…ä¸ºå‰©ä½™éƒ¨åˆ†çš„å¤§å°ï¼Œåè€…ä¸ºå°å­æ ‘å’Œå½“å‰èŠ‚ç‚¹çš„å¤§å°å’Œï¼‰ï¼š (nâˆ’1âˆ’âˆ‘i=1tsize[si])Ã—(1+âˆ‘i=1tsize[si])\\left(n-1-\\sum\\limits_{i=1}^{t} size[s_i]\\right)\\times \\left(1+\\sum\\limits_{i=1}^{t} size[s_i]\\right) (nâˆ’1âˆ’i=1âˆ‘tâ€‹size[siâ€‹])Ã—(1+i=1âˆ‘tâ€‹size[siâ€‹]) ä»£ç ä¾¿ä¸éš¾å†™å‡ºï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; int n, m, num; int dfn[100005], low[100005]; int Size[100005]; i64 ans[100005]; bool cut[100005]; vector &lt;edge> edges; vector &lt;int> G[100005]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; Size[x] = 1; int flag = 0; i64 sum = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (!dfn[y]) &#123; tarjan(y); Size[x] += Size[y]; low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; ++flag; ans[x] += (i64)Size[y] * (n - Size[y]); sum += Size[y]; if (x != 1 || flag > 1) cut[x] = true; &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; if (cut[x]) ans[x] += (n - 1) + (n - 1 - sum) * (1 + sum); else ans[x] = (n - 1) &lt;&lt; 1; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; tarjan(1); // æ‰€æœ‰åŸå¸‚éƒ½è¿é€šï¼Œè°ƒç”¨ä¸€æ¬¡ tarjan å³å¯ for (int i = 1; i &lt;= n; ++i) printf(\"%lld\\n\", ans[i]); return 0; &#125; åŒè¿é€šåˆ†é‡ä¸ç¼©ç‚¹ å¦‚æœä¸€å¼ å›¾ä¸å­˜åœ¨å‰²è¾¹ï¼Œé‚£ä¹ˆè¿™å¼ å›¾è¢«ç§°ä¸ºè¾¹åŒè¿é€šå›¾ã€‚å¦‚æœå®ƒä¸å­˜åœ¨å‰²ç‚¹ï¼Œé‚£ä¹ˆç§°ä¹‹ä¸ºç‚¹åŒè¿é€šå›¾ã€‚ æ¥ä¸‹æ¥ç»™å‡ºçš„ä¸¤ä»½ä»£ç åŒæ—¶ä¹Ÿæ˜¯æ— å‘å›¾è¿é€šæ€§çš„æ¨¡æ¿ã€‚ e-DCC åŠå…¶ç¼©ç‚¹ æ— å‘è¿é€šå›¾çš„æå¤§è¾¹åŒè¿é€šå­å›¾è¢«ç§°ä¹‹ä¸ºè¾¹åŒè¿é€šåˆ†é‡ï¼Œç®€è®°ä¸º e-DCCã€‚å…¶ä¸­æå¤§å­å›¾çš„æ„æ€æ˜¯ä¸å­˜åœ¨ä¸€ä¸ªæ›´å¤§çš„å­å›¾ï¼Œè¿™ä¸ªå­å›¾åŒ…å«äº†åŸæ¥çš„å­å›¾ï¼Œä¹Ÿæ»¡è¶³è¿™ä¸ªé™åˆ¶æ¡ä»¶ã€‚ ä¸€ä¸ªå›¾çš„è¾¹åŒè¿é€šåˆ†é‡ä¹‹é—´ä¸€å®šæ˜¯ä¸ç›¸äº¤çš„ã€‚å¦‚æœä¸¤ä¸ªåŒè¿é€šåˆ†é‡ç›¸äº¤äº†ï¼Œé‚£ä¹ˆé¡ºå»å®ƒä»¬ä¸­çš„ä¸€æ¡è¾¹ï¼Œä¸¤ä¸ªå­å›¾ä¾ç„¶æ˜¯è¿é€šçš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸¤ä¸ªåŒè¿é€šåˆ†é‡æ˜¯ä¸€ä¸ªæ›´å¤§çš„åŒè¿é€šåˆ†é‡çš„ä¸€éƒ¨åˆ†ã€‚ æ¨¡æ¿ã€‚ e-DCC çš„æ±‚è§£éå¸¸å®¹æ˜“ï¼Œå› ä¸ºå¦‚æœå›¾ä¸å­˜åœ¨å‰²è¾¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æŠŠæ‰€æœ‰çš„å‰²è¾¹éƒ½ç»™åˆ æ‰ï¼Œå›¾ä¼šåˆ†è£‚æˆè‹¥å¹²ä¸ªè¿é€šå—ï¼Œæ¯ä¸€ä¸ªè¿é€šå—éƒ½æ˜¯ä¸€ä¸ª e-DCCã€‚ æœ‰ä¸€ä¸ªæ€§è´¨ï¼šæ— å‘è¿é€šå›¾æ˜¯è¾¹åŒè¿é€šå›¾ï¼Œå½“ä¸”ä»…å½“ä»»æ„ä¸€æ¡è¾¹éƒ½åŒ…å«åœ¨è‡³å°‘ä¸€ä¸ªç®€å•ç¯ä¸­ã€‚ æ±‚è§£ e-DCC æ—¶ï¼Œç»è¿‡ä¸€ä¸ªç‚¹å°±è¦å°†è¿™ä¸ªç‚¹å‹å…¥æ ˆã€‚å½“ low[x]=dfn[x]low[x]=dfn[x]low[x]=dfn[x] æ—¶ï¼Œä»£è¡¨ xxx å°±æ˜¯è¿é€šå—æ·±åº¦æœ€å¤§çš„ç‚¹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; int n, m, num = 0, cnt = 0, c[500005]; int dfn[500005], low[500005]; bool bridge[4000005]; int st[500005], tot = 0; vector &lt;edge> edges; vector &lt;int> G[500005]; vector &lt;int> ans[500005]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x, int in_edge) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (!dfn[y]) &#123; tarjan(y, G[x][i]); low[x] = min(low[x], low[y]); if (dfn[x] &lt; low[y]) bridge[G[x][i]] = bridge[G[x][i] ^ 1] = true; &#125; else if (G[x][i] != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); &#125; if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ans[cnt].push_back(y); &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i, -1); printf(\"%d\\n\", cnt); for (int i = 1; i &lt;= cnt; ++i) &#123; printf(\"%d \", ans[i].size()); for (auto x : ans[i]) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; å°†æ¯ä¸€ä¸ª e-DCC éƒ½çœ‹ä½œä¸€ä¸ªèŠ‚ç‚¹ï¼ŒæŠŠå‰²è¾¹çœ‹ä½œè¿æ¥ e-DCC çš„è¾¹ï¼Œè¿™æ ·ä¼šäº§ç”Ÿä¸€æ£µæ ‘ï¼ˆä¸è¿é€šçš„æ— å‘å›¾å°±æ˜¯æ£®æ—ï¼‰ã€‚è¿™ç§æŠŠ e-DCC ç¼©ä¸ºä¸€ä¸ªèŠ‚ç‚¹çš„æ–¹å¼å°±å«åšç¼©ç‚¹ï¼Œåœ¨è§£å†³è¿é€šæ€§é—®é¢˜çš„æ—¶å€™éå¸¸æœ‰ç”¨ã€‚ for (int i = 0; i &lt; edges.size(); ++i) if (c[edges[i].from] != c[edges[i].to]) addedge(c[edges[i].from], c[edges[i].to]); // ä¸åœ¨ä¸€ä¸ª e-DCC é‡Œé¢ï¼Œå°† e-DCC è¿è¾¹ v-DCC åŠå…¶ç¼©ç‚¹ æ— å‘è¿é€šå›¾çš„æå¤§ç‚¹åŒè¿é€šå­å›¾è¢«ç§°ä¹‹ä¸ºç‚¹åŒè¿é€šåˆ†é‡ï¼Œç®€è®°ä¸º v-DCCã€‚ åœ¨æ±‚è§£çš„æ—¶å€™ï¼Œæ¯è®¿é—®åˆ°ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œéƒ½éœ€è¦å°†å®ƒå…¥æ ˆã€‚è‹¥å‰²ç‚¹çš„åˆ¤å®šæ³•åˆ™æˆç«‹ï¼Œé‚£ä¹ˆæ— è®ºå¦‚ä½•ï¼Œéƒ½è¦ä¸æ–­å¼¹å‡ºèŠ‚ç‚¹ï¼Œç›´åˆ° yyy è¢«å¼¹å‡ºã€‚å¼¹å‡ºçš„æ‰€æœ‰ä¸œè¥¿åŠ ä¸Š xxx å°±æ˜¯ä¸€ä¸ª v-DCCã€‚è¿˜æœ‰ï¼Œå¦‚æœä¸€ä¸ªç‚¹æ˜¯è‡ªå·±å•ç‹¬ä¸€ä¸ªï¼Œé‚£ä¹ˆå®ƒä¹Ÿæ˜¯ä¸€ä¸ª v-DCCï¼Œéœ€è¦ç‰¹åˆ¤ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, root, num = 0, tot = 0, cnt = 0; int dfn[500005], low[500005], stack[500005]; vector &lt;int> G[500005], ans[500005]; bool cut[500005]; inline void addedge(int u, int v) &#123; G[u].push_back(v); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; stack[++tot] = x; if (x == root &amp;&amp; G[x].size() == 0) &#123; ans[++cnt].push_back(x); return; &#125; int flag = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; ++cnt; ++flag; if (x != root || flag > 1) cut[x] = true; int z; do &#123; z = stack[tot--]; ans[cnt].push_back(z); &#125; while (z != y); ans[cnt].push_back(x); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (u != v) addedge(u, v), addedge(v, u); // ä¸ºäº†æ–¹ä¾¿åˆ¤æ–­å­¤ç«‹ç‚¹ï¼Œæ‰€ä»¥è‡ªç¯ä¸èƒ½åŠ  &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) root = i, tarjan(i); printf(\"%d\\n\", cnt); for (int i = 1; i &lt;= cnt; ++i) &#123; printf(\"%d \", ans[i].size()); for (int j = 0; j &lt; ans[i].size(); ++j) printf(\"%d \", ans[i][j]); putchar('\\n'); &#125; return 0; &#125; è¾¹åŒè¿é€šåˆ†é‡å’Œç‚¹åŒè¿é€šåˆ†é‡ç»Ÿç§°ä¸ºåŒè¿é€šåˆ†é‡ï¼Œå³ DCCï¼ˆDouble Connected componentï¼‰ã€‚ ç‚¹åŒè¿é€šåˆ†é‡å¯ä»¥å¼•å‡ºåœ†æ–¹æ ‘ï¼Œæ˜¯è§£å†³ç‚¹ç›¸å…³è·¯å¾„é—®é¢˜çš„åˆ©å™¨ï¼Œè¯·å‚çœ‹ã€Šçœé€‰åˆçº§å›¾è®ºã€‹ã€‚ æœ‰å‘å›¾çš„è¿é€šæ€§ åœ¨æœ‰å‘å›¾ä¸­ï¼Œå¦‚æœä»»æ„ä¸¤ä¸ªç‚¹éƒ½å¯ä»¥äº’ç›¸åˆ°è¾¾ï¼Œé‚£ä¹ˆè¿™å¼ å›¾è¢«æˆä¸ºå¼ºè¿é€šå›¾ï¼Œæœ‰å‘å›¾çš„æå¤§å¼ºè¿é€šå­å›¾è¢«ç§°ä¹‹ä¸ºå¼ºè¿é€šåˆ†é‡ï¼ˆSCCï¼‰ã€‚æ˜¾ç„¶ï¼Œä¸€ä¸ªç‚¹æœ€å¤šå±äºä¸€ä¸ª SCCã€‚ Tarjan ç®—æ³• æ¨¡æ¿. Tarjan ç®—æ³•å¯ä»¥æ±‚å‡ºæœ‰å‘å›¾çš„å¼ºè¿é€šåˆ†é‡ã€‚å½“å›¾å˜æˆæ— å‘å›¾æ—¶ï¼Œè¯¥ç®—æ³•ä¹Ÿå¯ä»¥æ­£å¸¸å·¥ä½œã€‚ è¿™é‡Œç›´æ¥ç»™å‡ºä»£ç ï¼ŒåŸç†æœ‰æ—¶é—´å†å†™ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; bool ins[10005]; int dfn[10005], low[10005], num = 0; int st[10005], tot = 0; int cnt = 0, c[10005], siz[10005]; vector &lt;int> G[10005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (auto y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; ++siz[cnt]; &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); int ans = 0; for (int i = 1; i &lt;= cnt; ++i) if (siz[i] > 1) ++ans; printf(\"%d\\n\", ans); return 0; &#125; ç¼©ç‚¹ åŒæ— å‘å›¾ï¼Œå°†ä¸€ä¸ª SCC ç¼©æˆä¸€ä¸ªç‚¹ï¼Œä¾¿æ˜¯ç¼©ç‚¹ã€‚æœ‰å‘å›¾åœ¨ç¼©ç‚¹ä¹‹åå¯ä»¥å¾—åˆ° DAGï¼Œç„¶åå°±å¯ä»¥è¿›è¡Œæ‹“æ‰‘æ’åºä¹‹ç±»çš„æ“ä½œã€‚ æ¨¡æ¿ã€‚åœ¨åšçš„æ—¶å€™å¯ä»¥å‘ç°ä¸€ä¸ª SCC å†…çš„ç‚¹éƒ½å¯ä»¥åˆ°è¾¾ï¼Œç¼©ç‚¹ä¹‹åçš„æƒå€¼ç›¸å½“äº SCC å†…ç‚¹çš„æƒå€¼ç»¼åˆï¼Œè€Œä¸”åœ¨ Tarjan çš„è¿‡ç¨‹ä¸­å°±å¯ä»¥è¿›è¡Œ DPï¼šè®¾ f(s)f(s)f(s) ä»£è¡¨ä» iii å¼€å§‹çš„æœ€å¤§æƒå€¼ï¼Œç»™ SCC ç¼–å·æ—¶è¦è¿›è¡Œè½¬ç§»ï¼Œæœ€åä¹Ÿè¦åŠ ä¸Š SCC å†…çš„ç‚¹æƒå’Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, ans = 0, a[10005], f[10005]; bool ins[10005]; int dfn[10005], low[10005], num = 0; int st[10005], tot = 0; int cnt = 0, c[10005], siz[10005]; vector &lt;int> G[10005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (auto y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y, sum = 0; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; ++siz[cnt]; sum += a[y]; for (auto v : G[y]) f[cnt] = max(f[cnt], f[c[v]]); &#125; while (x != y); f[cnt] += sum; ans = max(ans, f[cnt]); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); printf(\"%d\\n\", ans); return 0; &#125; 2-SAT é—®é¢˜ 2-SAT é—®é¢˜ã€‚æœ‰ nnn ä¸ªå˜é‡ï¼Œåªæœ‰ 01 ä¸¤ç§å–å€¼ï¼Œå¹¶æœ‰ mmm ä¸ªéœ€è¦æ»¡è¶³çš„å½¢å¦‚â€œxix_ixiâ€‹ ä¸º aaa æˆ– xjx_jxjâ€‹ ä¸º bbbâ€ï¼ˆå¦‚æœç»™å®šçš„æ˜¯ä¸”é€»è¾‘ä¹Ÿèƒ½è½¬åŒ–ä¸ºè¿™ç§å½¢å¼ï¼‰ï¼Œæ±‚å‡ºä¸€ç»„ä½¿å¾—æ‰€æœ‰æ¡ä»¶æ»¡è¶³çš„å˜é‡å–å€¼ï¼ˆå¯èƒ½æ— è§£ï¼‰ï¼Œ1â‰¤n,mâ‰¤1061\\le n,m\\le 10^61â‰¤n,mâ‰¤106ã€‚ ç”±äºæ¯ä¸€ä¸ªæ¡ä»¶åªå’Œä¸¤ä¸ªå˜é‡ç›¸å…³ï¼Œå¯ä»¥è¢«æ„å»ºæˆå›¾çš„è¾¹ã€‚ å¯¹äºæ¯ä¸ªå˜é‡ xxxï¼Œæˆ‘ä»¬å»ºç«‹ä¸¤ä¸ªç‚¹ï¼Œx,Â¬xx,\\neg xx,Â¬x åˆ†åˆ«è¡¨ç¤º xxx å–çœŸå‡ã€‚å¯¹äºé™åˆ¶æ¡ä»¶ aâˆ¨ba\\vee baâˆ¨bï¼Œå¯ä»¥è½¬åŒ–ä¸º Â¬aâ†’bâˆ§Â¬bâ†’a\\neg a\\rightarrow b\\wedge \\neg b\\rightarrow aÂ¬aâ†’bâˆ§Â¬bâ†’aï¼Œè¿æ¥è¿™ä¸¤æ¡è¾¹ã€‚ç„¶åæ±‚å‡ºè¿™å¼ å›¾çš„ SCCã€‚ åŒä¸€ SCC å†…çš„å˜é‡å€¼ä¸€å®šç›¸ç­‰ï¼Œé‚£ä¹ˆ x,Â¬xx,\\neg xx,Â¬x å°±ä¸èƒ½åœ¨åŒä¸€ä¸ª SCC å†…ã€‚è¦æ»¡è¶³æ‰€æœ‰çš„é™åˆ¶æ¡ä»¶ï¼Œéœ€è¦ xxx æ‰€åœ¨çš„ SCC çš„æ‹“æ‰‘åºåœ¨ Â¬x\\neg xÂ¬x æ‰€åœ¨çš„ SCC çš„æ‹“æ‰‘åºä¹‹åæ‰æ˜¯çœŸï¼Œæ‰€ä»¥è¦è¾“å‡º c[i] &gt; c[i+n]ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int dfn[2000005], low[2000005], num; int st[2000005], tot = 0, col[2000005], cnt = 0; bool ins[2000005]; vector&lt;int> G[2000005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; col[y] = cnt; &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, a, v, b; scanf(\"%d%d%d%d\", &amp;u, &amp;a, &amp;v, &amp;b); G[u + (!a) * n].emplace_back(v + b * n); G[v + (!b) * n].emplace_back(u + a * n); &#125; for (int i = 1; i &lt;= n &lt;&lt; 1; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) if (col[i] == col[i + n]) return puts(\"IMPOSSIBLE\"), 0; puts(\"POSSIBLE\"); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", col[i + n] &lt; col[i]); return putchar('\\n'), 0; &#125; è¿˜å¯ä»¥è§„å®šä¸€ä¸ªå˜é‡çš„å€¼ã€‚æ¯”å¦‚è§„å®šå®ƒä¸ºçœŸï¼Œé‚£ä¹ˆå°±ä» Â¬x\\neg xÂ¬x å‘ xxx è¿ä¸€æ¡è¾¹å³å¯ã€‚ æ¬§æ‹‰å›¾ ä»ä¸€ç¬”ç”»å¼•å‡ºçš„ä¸€ç±»è¿é€šæ€§é—®é¢˜ã€‚ æ¦‚è¿° ç»™å®šä¸€å¼ å›¾ï¼Œè‹¥å­˜åœ¨ä¸€æ¡ä»ä¸€ä¸ªç‚¹èµ°åˆ°å¦ä¸€ä¸ªç‚¹ï¼Œä¸é‡ä¸æ¼åœ°ç»è¿‡å›¾ä¸Šæ‰€æœ‰çš„è¾¹ä¸€æ¬¡ï¼Œé‚£ä¹ˆè¿™æ¡è·¯ç§°ä¹‹ä¸ºæ¬§æ‹‰è·¯ã€‚ç‰¹åˆ«åœ°ï¼Œå¦‚æœä»ä¸€ä¸ªç‚¹å‡ºå‘å›åˆ°äº†ä¸€ä¸ªç‚¹ï¼Œé‚£ä¹ˆè¿™æ¡è·¯ç§°ä¹‹ä¸ºæ¬§æ‹‰å›è·¯ã€‚å­˜åœ¨æ¬§æ‹‰å›è·¯çš„å›¾ç§°ä¹‹ä¸ºæ¬§æ‹‰å›¾ã€‚ä¸å­˜åœ¨æ¬§æ‹‰å›è·¯ä½†æ˜¯å­˜åœ¨æ¬§æ‹‰è·¯çš„å›¾ç§°ä¸ºåŠæ¬§æ‹‰å›¾ã€‚ åœ¨å°å­¦å·²ç»å­¦è¿‡ï¼Œå¯¹äºæ— å‘å›¾ï¼Œå¦‚æœå›¾ä¸­åº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹æ˜¯ 000 æˆ– 222ï¼Œé‚£ä¹ˆè¿™ä¸ªå›¾å¯ä»¥ä¸€ç¬”ç”»ã€‚å½“ä¸º 000 æ—¶ï¼Œè¿™ä¸ªå›¾æ˜¯æ¬§æ‹‰å›¾ï¼Œå½“ä¸º 222 æ—¶ï¼Œå­˜åœ¨æ¬§æ‹‰è·¯ã€‚ è€Œå¯¹äºä¸€å¼ æœ‰å‘å›¾ï¼ˆæ˜¾ç„¶ï¼Œå®ƒè‡³å°‘éœ€è¦å¼±è¿é€šï¼‰ï¼Œæ˜¯æ¬§æ‹‰å›¾å½“ä¸”ä»…å½“å…¶æ˜¯ä¸€ä¸ªå¼ºè¿é€šå›¾ä¸”æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦å’Œå‡ºåº¦ç›¸ç­‰ã€‚å¦‚æœè¿™å¼ å›¾æ°å­˜åœ¨ä¸€ä¸ªé¡¶ç‚¹çš„å‡ºåº¦æ¯”å…¥åº¦å° 111ï¼Œå¦ä¸€ä¸ªç‚¹å…¥åº¦æ¯”å‡ºåº¦å° 111ï¼Œè¿™ä¸ªå›¾å­˜åœ¨æ¬§æ‹‰è·¯ã€‚ Hierholzer ç®—æ³• é‡‡ç”¨ DFS ä¸æ–­æ‰¾ç¯ï¼Œéå†å½“å‰èŠ‚ç‚¹ uuu çš„æ‰€æœ‰å‡ºè¾¹ï¼Œå¦‚æœæ²¡æœ‰èµ°è¿‡é‚£å°±éå†ï¼Œéå†å®Œæ‰€æœ‰å‡ºè¾¹åå°† uuu åŠ å…¥æ¬§æ‹‰è·¯å¾„ï¼Œæœ€åå¦‚æœéå†çš„ç‚¹çš„ä¸ªæ•°ä¸º m+1m+1m+1ï¼Œé‚£ä¹ˆå°±å¾—åˆ°äº†åç€çš„æ¬§æ‹‰è·¯å¾„ï¼Œå¦åˆ™æ¬§æ‹‰è·¯å¾„ä¸å­˜åœ¨ã€‚ åœ¨æ‰¾æ¬§æ‹‰å›è·¯æ—¶ï¼Œå¯ä»¥ä»ä»»æ„èŠ‚ç‚¹å‡ºå‘ã€‚å¦åˆ™ï¼Œéœ€è¦ä»æ ¹æ®æ€§è´¨æ‰¾åˆ°çš„ç‚¹å‡ºå‘ã€‚ æ¨¡æ¿ï¼Œä»£ç å…¥ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, in[100005]; vector&lt;int> G[100005]; int tot, st[200005], cur[200005]; void dfs(int x) &#123; for (; cur[x] &lt; G[x].size(); ) dfs(G[x][cur[x]++]); st[++tot] = x; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); ++in[v]; &#125; int s = 0; for (int i = 1; i &lt;= n; ++i) &#123; sort(G[i].begin(), G[i].end()); if (abs(int(G[i].size()) - in[i]) > 1) return puts(\"No\"), 0; if (G[i].size() > in[i]) &#123; if (s) return puts(\"No\"), 0; else s = i; &#125; &#125; dfs(s ? s : 1); if (tot != m + 1) return puts(\"No\"), 0; for (int i = tot; i >= 1; --i) printf(\"%d \", st[i]); return putchar('\\n'), 0; &#125; åœ¨ä½¿ç”¨å…¶æ±‚æ— å‘å›¾çš„æ¬§æ‹‰è·¯å¾„æ—¶ï¼Œéœ€è¦æ ‡è®°å…¶åå‘è¾¹ä¸å¯ä»¥èµ°äº†ã€‚ å“ˆå¯†é¡¿å›¾ é€šè¿‡å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹ä¸€æ¬¡çš„é€šè·¯ç§°ä¸ºå“ˆå¯†é¡¿é€šè·¯ï¼Œé€šè¿‡å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹ä¸€æ¬¡çš„å›è·¯ç§°ä¸ºå“ˆå¯†é¡¿å›è·¯ã€‚åˆ¤æ–­ä¸€ä¸ªå›¾æ˜¯å¦å­˜åœ¨å“ˆå¯†é¡¿å›è·¯æ˜¯ NPC çš„ï¼Œä¸å­˜åœ¨å¤šé¡¹å¼æ—¶é—´å¤æ‚åº¦çš„æ±‚æ³•ã€‚ å…¶å®ƒæ€§è´¨æœ‰æ—¶é—´å†å†™ã€‚ Problemset è¿é€šæ€§çš„é—®é¢˜å¾ˆæœ‰æ„æ€ï¼Œæˆ‘ä»¬æ¥çœ‹å‡ é“é¢˜ç©ä¸€ä¸‹ã€‚ æ‹“æ‰‘æ’åº åŸºç¡€ä¸­çš„åŸºç¡€ã€‚ [Luogu P1347] æ’åº Portal. ä½¿ç”¨æ‹“æ‰‘æ’åºã€‚åœ¨è¿‡ç¨‹ä¸­è®°å½•æ‹“æ‰‘åºï¼ˆå¼€ä¸€ä¸ª ans æ•°ç»„è®°å½•å‡ºé˜Ÿçš„é¡ºåºï¼‰ä»¥ä¾¿è¾“å‡ºç­”æ¡ˆã€‚çŸ›ç›¾æ„å‘³ç€è¿™ä¸æ˜¯ä¸€ä¸ª DAGï¼Œä¹Ÿå°±ä¼šå¯¼è‡´æœ‰çš„ç‚¹çš„å…¥åº¦åœ¨æ‹“æ‰‘æ’åºç»“æŸåä¾ç„¶ä¸ä¸º 000ã€‚å¦‚æœæ‰€æœ‰çš„è¯»å…¥éƒ½å®Œæˆåä¾ç„¶æ²¡æœ‰å”¯ä¸€çš„æ‹“æ‰‘åºï¼ˆé€šè¿‡è®°å½•ä¸€ä¸ªç‚¹æ˜¯ç¬¬å‡ è½®å…¥é˜Ÿçš„ï¼Œç¬¬ nnn è½®å°±æ˜¯å”¯ä¸€ï¼‰ï¼Œé‚£ä¹ˆå°±æ˜¯æœ‰å¤šè§£ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> #define X first #define Y second #define mp make_pair using namespace std; int n, m, now, kase = 0; int inn[30], in[30], ans[30]; bool s[30]; vector &lt;int> G[30]; int topo(void) &#123; for (int i = 0; i &lt; 26; ++i) in[i] = inn[i]; queue &lt;pii> q; int sum = 0; for (int i = 0; i &lt; 26; ++i) if (s[i] == true &amp;&amp; in[i] == 0) q.push(mp(i, 1)); int res = 0, tot = 0; while (!q.empty()) &#123; int u = q.front().X, val = q.front().Y; q.pop(); ans[++tot] = u; res = max(res, val); for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; --in[v]; if (in[v] == 0) q.push(mp(v, val + 1)); &#125; &#125; if (res == n) return 1; else &#123; for (int i = 0; i &lt; 26; ++i) if (s[i] &amp;&amp; in[i] != 0) return 2; &#125; return 3; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); char gc[5]; while (m--) &#123; ++kase; scanf(\"%s\", gc); G[gc[0] - 'A'].push_back(gc[2] - 'A'); ++inn[gc[2] - 'A']; s[gc[0] - 'A'] = true, s[gc[2] - 'A'] = true; int t = topo(); if (t == 1) &#123; printf(\"Sorted sequence determined after %d relations: \", kase); for (int i = 1; i &lt;= n; ++i) printf(\"%c\", ans[i] + 'A'); printf(\".\\n\"); return 0; &#125; else if (t == 2) &#123; printf(\"Inconsistency found after %d relations.\\n\", kase); return 0; &#125; &#125; puts(\"Sorted sequence cannot be determined.\"); return 0; &#125; [Luogu P1113] æ‚åŠ¡ Portal. è®° f(i)f(i)f(i) ä»£è¡¨å®Œæˆä»»åŠ¡ iii éœ€è¦çš„æœ€çŸ­æ—¶é—´ã€‚è¿›è¡Œæ‹“æ‰‘æ’åºï¼Œç»Ÿè®¡ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™é¡ºå¸¦æ›´æ–°å®ƒå…³è”çš„ fff å€¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int len[10005], in[10005], f[10005]; vector &lt;int> G[10005]; void Kahn(void) &#123; queue &lt;int> q; for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) &#123; q.push(i); f[i] = len[i]; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; --in[G[u][i]]; if (in[G[u][i]] == 0) q.push(G[u][i]); f[G[u][i]] = max(f[G[u][i]], f[u] + len[G[u][i]]); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, len + i); while (scanf(\"%d\", &amp;y) == 1 &amp;&amp; y) &#123; G[y].push_back(x); ++in[x]; &#125; &#125; Kahn(); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; [HNOI2015] èœè‚´åˆ¶ä½œ Portal. å¾ˆå®¹æ˜“æƒ³åˆ°æ‹“æ‰‘æ’åºï¼Œä½†æ˜¯è¿™ä¸ªé¡ºåºï¼Ÿæˆ‘ä»¬æƒ³è¦è®©å°çš„ç¼–å·å°½é‡é å‰ï¼Œä½†æ˜¯ç›´æ¥ç”¨å°æ ¹å †å°±é”™äº†ï¼šå› ä¸ºè¿™é“é¢˜è¦ä¿è¯çš„ä¸æ˜¯å­—å…¸åºï¼Œè€Œæ˜¯å°çš„å°½é‡é å‰ï¼Œå³ä½¿ä¸€ä¸ªå¤§çš„å‡ºç°åœ¨äº†å®ƒå‰é¢ã€‚è¿™æ ·çš„è¯å‘ç°ä¸€ä¸ªè¶Šå¤§çš„æ•°ï¼Œå®ƒè¶Šåœ¨åé¢è¶Šæœ‰åˆ©ï¼Œå› ä¸ºè¿™æ ·å°çš„å°±è·‘åˆ°å‰é¢å»äº†ã€‚ é‚£ä¹ˆï¼Œå»ºåå›¾ï¼Œè¿›è¡Œæ‹“æ‰‘æ’åºï¼Œä½¿ç”¨ Kahn ç®—æ³•é…ä¸Šä¸€ä¸ªå¤§æ ¹å †ï¼Œè¿™æ ·å¯ä»¥ä¿è¯æœ€ç»ˆå¤§çš„å°½å¯èƒ½åœ°æ™šå‡ºï¼ŒæŠŠå°çš„é¡¶åˆ°å‰é¢ã€‚ æœ¬é¢˜éå¸¸ç»å…¸ï¼Œå¼ºçƒˆå»ºè®®è¯»è€…è®°ä½è¿™ä¸ªç»“è®ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, in[100005], ans[100005]; vector &lt;int> G[100005]; void Kahn(void) &#123; int tot = 0; priority_queue &lt;int> q; for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) q.push(i); while (!q.empty()) &#123; int u = q.top(); q.pop(); ans[++tot] = u; for (int i = 0; i &lt; G[u].size(); ++i) &#123; --in[G[u][i]]; if (in[G[u][i]] == 0) q.push(G[u][i]); &#125; &#125; if (tot != n) puts(\"Impossible!\"); else &#123; for (int i = n; i >= 1; --i) printf(\"%d \", ans[i]); putchar('\\n'); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; memset(in, 0, sizeof(in)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) G[i].clear(); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[v].push_back(u); ++in[u]; &#125; Kahn(); &#125; return 0; &#125; [CSP-S2020] å‡½æ•°è°ƒç”¨ Portal. æ“ä½œä¸‰ä¼šå¯¼è‡´åˆ«çš„å‡½æ•°è°ƒç”¨å¾ˆå¤šæ¬¡ï¼Œè€Œæ“ä½œäºŒå¯ä»¥çœ‹ä½œæ˜¯å®ƒä¹‹å‰çš„æ“ä½œé‡å¤æ‰§è¡Œï¼Œå› æ­¤å¯ä»¥è€ƒè™‘ä¸€æ“ä½œæ‰§è¡Œçš„æ¬¡æ•°ã€‚å¯¹åå›¾è¿›è¡Œä¸€æ¬¡æ‹“æ‰‘æ’åºæ±‚å‡ºä¹˜æ³•æ ‡è®°ï¼Œç„¶åå¯¹æ­£å›¾è¿›è¡Œæ‹“æ‰‘æ’åºæ¥æ‰§è¡Œå‡½æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int n, m, Q; int a[100005], cnt[100005], in[100005]; vector&lt;int> G[100005], E[100005]; int type[100005], p[100005], v[100005], mul[100005]; void Kahn1(void) &#123; // åœ¨ E ä¸Šæ‹“æ‰‘æ’åº queue&lt;int> q; for (int i = 0; i &lt;= m; ++i) &#123; in[i] = G[i].size(); if (!in[i]) q.push(i); &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v : E[u]) &#123; mul[v] = 1ll * mul[v] * mul[u] % P; --in[v]; if (!in[v]) q.push(v); &#125; &#125; &#125; void Kahn2(void) &#123; queue&lt;int> q; for (int i = 0; i &lt;= m; ++i) &#123; in[i] = E[i].size(); if (!in[i]) q.push(i); &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); int tag = 1; reverse(G[u].begin(), G[u].end()); // åè°ƒç”¨çš„å‡½æ•°ä¼šè®©å‰é¢çš„é‡å¤æ‰§è¡Œ for (int v : G[u]) &#123; cnt[v] = (cnt[v] + 1ll * cnt[u] * tag) % P; tag = 1ll * tag * mul[v] % P; --in[v]; if (!in[v]) q.push(v); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); scanf(\"%d\", &amp;m); mul[0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d\", type + i); mul[i] = 1; if (type[i] == 1) scanf(\"%d%d\", p + i, v + i); else if (type[i] == 2) scanf(\"%d\", mul + i); else &#123; int len; scanf(\"%d\", &amp;len); while (len--) &#123; int x; scanf(\"%d\", &amp;x); G[i].emplace_back(x); E[x].emplace_back(i); &#125; &#125; &#125; scanf(\"%d\", &amp;Q); cnt[0] = 1; while (Q--) &#123; int x; scanf(\"%d\", &amp;x); G[0].emplace_back(x); E[x].emplace_back(0); &#125; Kahn1(); Kahn2(); for (int i = 1; i &lt;= n; ++i) a[i] = 1ll * a[i] * mul[0] % P; for (int i = 1; i &lt;= m; ++i) if (type[i] == 1) a[p[i]] = (a[p[i]] + 1ll * cnt[i] * v[i]) % P; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); return 0; &#125; è¿é€šæ€§é—®é¢˜ è¿™é‡Œçš„é¢˜éƒ½æ¯”è¾ƒåŸºç¡€ã€‚ [Luogu P2002] æ¶ˆæ¯æ‰©æ•£ Portal. å…ˆæ±‚å‡º SCCï¼Œå¦‚æœä¸¤ä¸ª SCC ç›¸è¿ï¼Œé‚£ä¹ˆåªéœ€è¦å‘å¸ƒä¸€ä¸ªæ¶ˆæ¯å°±å¯ä»¥äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int st[100005], tot = 0; bool ins[100005]; int dfn[100005], low[100005], num = 0; int cnt = 0, c[100005]; vector&lt;int> G[100005]; bool flag[100005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) for (int j : G[i]) if (c[i] != c[j]) flag[c[j]] = true; int ans = 0; for (int i = 1; i &lt;= cnt; ++i) ans += (flag[i] == 0); printf(\"%d\\n\", ans); return 0; &#125; [USACO03FALL] å—æ¬¢è¿çš„ç‰› G Portal. åªæœ‰å½“å‡ºåº¦ä¸º 000 çš„ SCC ä»…æœ‰ä¸€ä¸ªæ—¶ï¼Œæ‰ä¼šæœ‰æ˜æ˜Ÿå‡ºç°ï¼Œæ•°é‡æ˜¯è¿™ä¸ª SCC çš„å¤§å°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int st[10005], tot = 0; bool ins[10005]; int out[10005]; int c[10005], siz[10005], cnt = 0; int dfn[10005], low[10005], num = 0; vector &lt;int> G[10005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; siz[cnt] += 1; c[y] = cnt; &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) for (int j : G[i]) if (c[i] != c[j]) ++out[c[i]]; int ans = 0, flag = 0; for (int i = 1; i &lt;= cnt; ++i) if (out[i] == 0) ans = siz[i], ++flag; if (flag > 1) puts(\"0\"); else printf(\"%d\\n\", ans); return 0; &#125; [USACO5.3] Network of Schools Portal. ç¬¬äºŒé—®çš„ç­”æ¡ˆæ˜¯ç¼©ç‚¹ä¹‹åå…¥åº¦ä¸º 000 çš„ç‚¹çš„ä¸ªæ•°å’Œå‡ºåº¦ä¸º 000 çš„ç‚¹çš„ä¸ªæ•°çš„æœ€å¤§å€¼ã€‚ç‰¹åˆ«åœ°ï¼Œå½“åªæœ‰ä¸€ä¸ª SCC æ—¶ï¼Œç­”æ¡ˆä¸º 000ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n; int st[10005], tot = 0; bool ins[10005]; int dfn[10005], low[10005], num = 0; int cnt = 0, c[10005]; vector &lt;int> G[10005]; bool flag[10005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; &#125; while (x != y); &#125; &#125; int in[10005], out[10005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int j; while (scanf(\"%d\", &amp;j) == 1 &amp;&amp; j) G[i].push_back(j); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) for (int j : G[i]) if (c[i] != c[j]) &#123; flag[c[j]] = true; ++in[c[j]], ++out[c[i]]; &#125; int ans = 0, p = 0, q = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; ans += (flag[i] == 0); p += (in[i] == 0); q += (out[i] == 0); &#125; printf(\"%d\\n%d\\n\", ans, cnt == 1 ? 0 : max(p, q)); return 0; &#125; [APIO2009] æŠ¢æ è®¡åˆ’ Portal. æ˜¾ç„¶æ˜¯ç¼©ç‚¹åè¿›è¡Œ DPï¼Œä¸è¿‡è¿™é‡Œæ˜¾ç„¶ç”¨ä»¥ iii ä¸ºç»ˆç‚¹çš„çŠ¶æ€æ¯”è¾ƒæ–¹ä¾¿ï¼Œæ‰€ä»¥ Tarjan ä¹‹åè¦é‡æ–°å»ºå›¾ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, s, p; int low[500005], dfn[500005], num = 0; int st[500005], tot = 0, f[500005]; int val[500005], sum[500005], c[500005], cnt = 0; bool ins[500005]; vector&lt;int> G[500005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; sum[cnt] += val[y]; &#125; while (x != y); &#125; &#125; int in[500005]; vector&lt;int> G2[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); &#125; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", val + i); scanf(\"%d%d\", &amp;s, &amp;p); tarjan(s); for (int i = 1; i &lt;= n; ++i) if (c[i]) for (int j : G[i]) if (c[i] != c[j]) &#123; G2[c[i]].push_back(c[j]); ++in[c[j]]; &#125; queue&lt;int> q; q.push(c[s]); f[c[s]] = sum[c[s]]; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v : G2[u]) &#123; f[v] = max(f[v], f[u] + sum[v]); --in[v]; if (in[v] == 0) q.push(v); &#125; &#125; int ans = 0; for (int i = 1; i &lt;= p; ++i) &#123; int x; scanf(\"%d\", &amp;x); ans = max(ans, f[c[x]]); &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P2656] é‡‡è˜‘è‡ Portal. æ˜¾ç„¶ä¸€ä¸ª SCC å†…çš„è˜‘è‡å¯ä»¥é‡‡å¹²å‡€ï¼Œé‚£ä¹ˆ SCC ç¼©ç‚¹ä¹‹ååœ¨ DAG ä¸Š DP å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, s; int dfn[80005], low[80005], num = 0; int st[80005], tot = 0; bool ins[80005]; int cnt, c[80005]; vector&lt;int> G[80005]; struct edge &#123; int u, v, w; long double d; edge(int u = 0, int v = 0, int w = 0, long double d = 0) : u(u), v(v), w(w), d(d) &#123;&#125; &#125;; vector&lt;edge> edges; inline void addedge(int u, int v, int w, long double d) &#123; edges.emplace_back(edge(u, v, w, d)); G[u].emplace_back(edges.size() - 1); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].v; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); &#125; if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; &#125; while (x != y); &#125; &#125; int val[80005], in[80005], f[80005], ans = 0; vector&lt;edge> G2[80005]; void Kahn(void) &#123; queue&lt;int> q; q.push(c[s]); while (!q.empty()) &#123; int u = q.front(); q.pop(); f[u] += val[u]; for (int i = 0; i &lt; G2[u].size(); ++i) &#123; edge &amp;e = G2[u][i]; f[e.v] = max(f[e.v], f[u] + e.w); --in[e.v]; if (in[e.v] == 0) q.push(e.v); &#125; ans = max(ans, f[u]); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v, w; long double d; scanf(\"%d%d%d%Lf\", &amp;u, &amp;v, &amp;w, &amp;d); addedge(u, v, w, d); &#125; scanf(\"%d\", &amp;s); tarjan(s); for (int i = 0; i &lt; edges.size(); ++i) &#123; edge &amp;e = edges[i]; if (dfn[e.u] &amp;&amp; dfn[e.v]) &#123; if (c[e.u] == c[e.v]) &#123; while (e.w) &#123; val[c[e.u]] += e.w; e.w *= e.d; &#125; &#125; else &#123; G2[c[e.u]].push_back(edge(c[e.u], c[e.v], e.w, e.d)); ++in[c[e.v]]; &#125; &#125; &#125; Kahn(); printf(\"%d\\n\", ans); return 0; &#125; [USACO06JAN] Redundant Paths G Portal. ç›´æ¥æ±‚å‡º e-DCC ç¼©ç‚¹åçš„æ ‘ï¼Œç„¶åå°†å¶å­é…å¯¹å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; int n, m, num = 0, cnt = 0; int dfn[5005], low[5005], c[5005], in[5005]; bool bridge[20005]; vector &lt;edge> edges; vector &lt;int> G[5005]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x, int in_edge) &#123; dfn[x] = low[x] = ++num; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (!dfn[y]) &#123; tarjan(y, G[x][i]); low[x] = min(low[x], low[y]); if (dfn[x] &lt; low[y]) bridge[G[x][i]] = bridge[G[x][i] ^ 1] = true; &#125; else if (G[x][i] != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); &#125; &#125; void dfs(int x) &#123; c[x] = cnt; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (c[y] || bridge[G[x][i]]) continue; dfs(y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; tarjan(1, -1); int res = 0; for (int i = 1; i &lt;= n; ++i) if (!c[i]) &#123; ++cnt; dfs(i); &#125; for (int i = 0; i &lt; edges.size(); i += 2) // ç»Ÿè®¡å¶å­çš„ä¸ªæ•°ï¼Œå…¥åº¦ä¸º 1 çš„æ˜¯å¶å­ if (c[edges[i].from] != c[edges[i].to]) &#123; ++in[c[edges[i].from]]; ++in[c[edges[i].to]]; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) if (in[i] == 1) ++ans; printf(\"%d\\n\", (ans + 1) / 2); return 0; &#125; è¿é€šæ€§çš„åº”ç”¨ è¿™é‡Œçš„é¢˜éƒ½éœ€è¦ä¸€äº›ç®€å•åˆ†æèƒ½åŠ›ã€‚ [CF1777E] Edge Reverse Portal. æ˜¾ç„¶æ˜¯äºŒåˆ†ç­”æ¡ˆï¼Œå¯ä»¥åè½¬çš„è¾¹ç›¸å½“äºæ— å‘è¾¹ï¼Œå°†å›¾ SCC ç¼©ç‚¹ååº”è¯¥æ°å¥½æœ‰ä¸€ä¸ªå…¥åº¦ä¸º 000 çš„ç‚¹æ‰èƒ½æ»¡è¶³æ¡ä»¶ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int u, v, w; bool operator &lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[200005]; int n, m; vector&lt;int> G[200005]; int dfn[200005], low[200005], num, st[200005], tot; int cnt, col[200005], deg[200005]; bool ins[200005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (dfn[x] == low[x]) &#123; int y; ++cnt; do ins[y = st[tot--]] = false, col[y] = cnt; while (x != y); &#125; &#125; bool P(int x) &#123; for (int i = 1; i &lt;= n; ++i) G[i].clear(), dfn[i] = ins[i] = deg[i] = 0; for (int i = 1; i &lt;= m; ++i) &#123; G[e[i].u].emplace_back(e[i].v); if (i &lt;= x) G[e[i].v].emplace_back(e[i].u); &#125; num = tot = cnt = 0; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int u = 1; u &lt;= n; ++u) for (int v : G[u]) if (col[u] != col[v]) ++deg[col[v]]; int res = 0; for (int i = 1; i &lt;= cnt; ++i) res += (deg[i] == 0); return res == 1; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); sort(e + 1, e + m + 1); int L = -1, R = m + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) R = mid; else L = mid; &#125; printf(\"%d\\n\", R != m + 1 ? e[R].w : -1); &#125; return 0; &#125; [NOI2017] æ¸¸æˆ Portal. æˆ‘ä»¬åªè¦æšä¸¾ xxx æ˜¯ AAA è¿˜æ˜¯ BBBï¼Œå°±å¯ä»¥è¦†ç›–æ‰€æœ‰é€‰æ‹©çš„åœ°å›¾ï¼Œè¿™æ ·å°±æ˜¯ä¸€ä¸ª 2-SAT æ¨¡æ¿ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(2d(n+m))O(2^d(n+m))O(2d(n+m))ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, d; char s[50005]; int dfn[100005], low[100005], num, st[100005], tot; bool ins[100005], flag; vector&lt;int> G[100005]; int col[100005], cnt; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; ++cnt; int y; do ins[y = st[tot--]] = false, col[y] = cnt; while (x != y); &#125; &#125; int a[100005], b[100005]; char x[100005], y[100005]; int pos[10]; char val[10]; bool c[3][3]; // å½“ä¸å…è®¸ä½¿ç”¨ i æ—¶ï¼Œä½¿ç”¨äº† i+1 ä¸ºçœŸï¼Œå¦åˆ™ä¸ºå‡ bool solve(void) &#123; num = tot = cnt = 0; for (int i = 1; i &lt;= n &lt;&lt; 1; ++i) dfn[i] = ins[i] = 0, G[i].clear(); for (int i = 1; i &lt;= d; ++i) s[pos[i]] = val[i]; for (int i = 1; i &lt;= m; ++i) &#123; if (s[a[i]] == x[i]) continue; bool p = c[s[a[i]] - 'A'][x[i] - 'A'], q = c[s[b[i]] - 'A'][y[i] - 'A']; if (s[b[i]] == y[i]) &#123; G[a[i] + (!p) * n].emplace_back(a[i] + p * n); // æ­¤æ—¶ä¸èƒ½æ»¡è¶³ a è‡ªå·±çš„é™åˆ¶æ¡ä»¶ï¼Œå¿…é¡»è®©å…¶ä¸ºå‡ continue; &#125; G[a[i] + (!p) * n].emplace_back(b[i] + (!q) * n); G[b[i] + q * n].emplace_back(a[i] + p * n); &#125; for (int i = 1; i &lt;= n &lt;&lt; 1; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) if (col[i] == col[i + n]) return 0; for (int i = 1; i &lt;= n; ++i) putchar((s[i] - 'A' + (col[i + n] > col[i] ? 1 : 2)) % 3 + 'A'); return putchar('\\n'), 1; &#125; void dfs(int x) &#123; if (flag) return; if (x > d) return flag = solve(), void(); val[x] = 'A'; dfs(x + 1); val[x] = 'B'; dfs(x + 1); &#125; int main(void) &#123; scanf(\"%d%d%s%d\", &amp;n, &amp;d, s + 1, &amp;m); d = 0; c[0][1] = c[1][2] = c[2][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; s[i] -= 32; if (s[i] == 'X') pos[++d] = i; &#125; for (int i = 1; i &lt;= m; ++i) scanf(\"%d %c %d %c\", a + i, x + i, b + i, y + i); dfs(1); if (!flag) puts(\"-1\"); return 0; &#125; [yLOI2018] é”¦é²¤æŠ„ Portal.ç»™ä½ ä¸€å¼ æœ‰å‘å›¾ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªç‚¹æƒã€‚ä»»æ„æ—¶åˆ»ä½ å¯ä»¥ä»»æ„é€‰æ‹©ä¸€ä¸ªæœ‰å…¥åº¦çš„ç‚¹ï¼Œè·å¾—å®ƒçš„ç‚¹æƒå¹¶æŠŠå®ƒå’Œå®ƒçš„å‡ºè¾¹ä»å›¾ä¸Šåˆ å»ã€‚æœ€å¤šèƒ½é€‰æ‹© kkk ä¸ªç‚¹ï¼Œæ±‚æœ€å¤šèƒ½è·å¾—å¤šå°‘ç‚¹æƒã€‚nâ‰¤5Ã—105n \\leq 5 \\times 10^5nâ‰¤5Ã—105ã€‚ å…ˆè€ƒè™‘ä¸€ä¸ª DAG çš„æƒ…å†µã€‚æˆ‘ä»¬åªè¦å…ˆæ‰¾åˆ°éœ€è¦åˆ é™¤çš„ç‚¹ï¼ˆèƒ½å¤Ÿè¢«åˆ é™¤ä¸”æ˜¯å‰ kkk å¤§ï¼‰ï¼Œç„¶åæŒ‰ç…§è¿™äº›ç‚¹çš„æ‹“æ‰‘åºçš„å€’åºåˆ ç‚¹ï¼Œé‚£ä¹ˆå¯ä»¥å‘ç°è¿™äº›ç‚¹éƒ½å¯ä»¥è¢«åˆ å»ï¼Œå¹¶ä¸ä¼šå½±å“åé¢çš„ç‚¹çš„å…¥åº¦ã€‚ å› æ­¤å¯¹åŸå›¾è¿›è¡Œ SCC ç¼©ç‚¹ï¼Œè¿™æ ·æ•´ä½“ä¸Šçš„é€»è¾‘æ˜¯ä¸å˜çš„ï¼Œæˆ‘ä»¬åªéœ€è¦å•ç‹¬è€ƒè™‘ä¸€ä¸‹ SCC å†…éƒ¨æ€ä¹ˆåˆ ã€‚çœ‹ä¸€ä¸ªç®€å•çš„ï¼š ç°åœ¨ 2,3,42,3,42,3,4 åœ¨ä¸€ä¸ª SCC å†…ï¼Œç”±äºè¿™ä¸ª SCC æ˜¯æœ‰ä¸€ä¸ªå…¥åº¦çš„ 1â†’21\\rightarrow 21â†’2ï¼Œå› æ­¤åªè¦ä¸å…ˆåˆ  222ï¼Œé‚£ä¹ˆè¿™ä¸ª SCC å°±å¯ä»¥åˆ å¹²å‡€ã€‚ä½†æ˜¯å¦‚æœæ²¡æœ‰ 1â†’21\\rightarrow 21â†’2 è¿™æ¡è¾¹å‘¢ï¼Ÿé‚£ä¹ˆ SCC åˆ å®Œå¿…é¡»ç•™ä¸€ä¸ªç‚¹ï¼ˆåªéœ€è¦ä»ä»»æ„ä¸€ä¸ªä½ç½®å¼€å§‹é¡ºç€ç¯åˆ ï¼Œæœ€åå°±ä¼šå‰©ä¸€ä¸ªç‚¹ï¼‰ï¼Œä½†æ˜¯ï¼å¦‚æœè¿™ä¸ª SCC å†…å­˜åœ¨è‡ªç¯ï¼Œé‚£ä¹ˆå®ƒè¿˜æ˜¯å¯ä»¥è¢«åˆ å¹²å‡€çš„ã€‚ å› æ­¤æˆ‘ä»¬åªéœ€è¦æ’é™¤æ‰æœ¬æ¥å°±å…¥åº¦ä¸º 000 çš„ç‚¹å’Œä¸€ä¸ªæ²¡æœ‰å…¥åº¦æ²¡æœ‰è‡ªç¯çš„ SCC å†…çš„ç‚¹æƒæœ€å°çš„ç‚¹ï¼Œå‰©ä¸‹çš„ç‚¹å–å‰ kkk å¤§å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, k; int w[500010]; int dfn[500010], low[500010], num = 0; int st[500010], tot = 0; int cnt = 0, c[500010]; bool ins[500010]; vector&lt;int> G[500010]; vector&lt;int> scc[500010]; bool self[500010]; bool selfscc[500010]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; scc[cnt].push_back(y); selfscc[cnt] |= self[y]; &#125; while (x != y); &#125; &#125; int in[500010]; int val[500010], tot2 = 0; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", w + i); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (u != v) G[u].push_back(v); else self[u] = true; &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) for (int j : G[i]) if (c[i] != c[j]) ++in[c[j]]; for (int i = 1; i &lt;= cnt; ++i) &#123; int minn = 1e9, flag = false; for (int j : scc[i]) minn = min(minn, w[j]); for (int j : scc[i]) if (in[i] || selfscc[i]) val[++tot2] = w[j]; else if (w[j] > minn || flag) val[++tot2] = w[j]; else flag = true; &#125; sort(val + 1, val + tot2 + 1, greater&lt;int>()); int ans = 0; for (int i = 1; i &lt;= k; ++i) ans += val[i]; printf(\"%d\\n\", ans); return 0; &#125; [CF51F] Caterpillar Portal. ä¸€ä¸ªæ¯›æ¯›è™«å®šä¹‰ä¸ºä¸€ä¸ªæ— å‘è”é€šæ— ç¯å›¾ä¸Šå­˜åœ¨ä¸€æ¡è·¯å¾„ ppp ä½¿å¾—ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹è·ç¦» ppp çš„è·ç¦»è‡³å¤šä¸º 111ã€‚æ¯›æ¯›è™«å¯ä»¥åŒ…å«è‡ªç¯ï¼ˆä¸€æ¡ä»ä¸€ä¸ªé¡¶ç‚¹è¿å‘è‡ªå·±çš„è¾¹ï¼‰ï¼Œä½†æ˜¯ä¸å¯ä»¥åŒ…å«é‡è¾¹ã€‚è¿™ä¸ªå›¾ç‰‡æ˜¯ä¸€ä¸ªæ¯›æ¯›è™«çš„ä¾‹å­ï¼šç°åœ¨ä½ æœ‰ä¸€å¼ æ— å‘å›¾ GGGï¼ˆä¸ä¸€å®šè”é€šï¼‰ ã€‚ä½ è¢«å…è®¸åšä¸€äº›åˆå¹¶æ“ä½œã€‚æ¯æ¬¡æ“ä½œå°†ä¸¤ä¸ªé¡¶ç‚¹åˆå¹¶æˆä¸€ä¸ªé¡¶ç‚¹ã€‚æ¯æ¬¡é€‰æ‹©ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ a,b(aâ‰ b)a,b (a\\neq b)a,b(aî€ =b)ï¼Œè¿™äº›é¡¶ç‚¹ä»¥åŠå®ƒä»¬çš„è¾¹ï¼ˆè‡³å°‘è¿æ¥ç€ a,ba,ba,b ä¸­ä¸€ä¸ªç‚¹çš„è¾¹ï¼‰å°†è¢«åˆ é™¤ï¼Œè€Œåé¡¶ç‚¹ www ä¼šè¢«åŠ å…¥ï¼Œä»¥åŠå¯¹äºæ¯æ¡è¾¹ (x,a),(x,b)(x,a),(x,b)(x,a),(x,b) éƒ½ä¼šæœ‰æ–°è¾¹ (x,w)(x,w)(x,w) åŠ å…¥ã€‚å¦‚æœæœ‰ä¸€æ¡è¾¹ (a,b)(a,b)(a,b) å®ƒä¼šè¢«è½¬æ¢æˆè‡ªç¯ (w,w)(w,w)(w,w)ã€‚å¾—åˆ°çš„å›¾ï¼ˆæ“ä½œç»“æŸåï¼‰å¯èƒ½ä¼šæœ‰é‡è¾¹ã€‚æˆ‘ä»¬æ³¨æ„åˆ°è¿™ä¸ªæ“ä½œå‡å°‘äº† 111 ä¸ªé¡¶ç‚¹ï¼Œå´æ²¡æœ‰æ”¹å˜è¾¹çš„æ•°é‡ã€‚åˆå¹¶æ“ä½œå¯ä»¥ç®€å•çš„æè¿°ä¸ºå°†å›¾ä¸­ä¸¤ä¸ªé¡¶ç‚¹åˆå¹¶ä¸ºå›¾ä¸­çš„ä¸€ä¸ªé¡¶ç‚¹å¹¶ç»§æ‰¿åŸæ¥æ‰€æœ‰çš„è¾¹ã€‚ä½ å¯ä»¥è¿ç»­åœ°ä½¿ç”¨åˆå¹¶æ“ä½œï¼Œä»è€Œå°†ç»™å®šçš„å›¾è½¬å˜æˆä¸€ä¸ªæ¯›æ¯›è™«ã€‚æ±‚å‡ºè¿™å¼ å›¾è½¬å˜æˆä¸€ä¸ªæ¯›æ¯›è™«çš„æœ€å°‘æ“ä½œæ¬¡æ•°ã€‚ æ¯›æ¯›è™«ä¸Šä¸èƒ½é•¿å‡ºæ¥ç¯ï¼Œæ‰€ä»¥æŠŠæ¯ä¸€ä¸ª e-DCC ç¼©ç‚¹ï¼Œå›¾ä¼šå˜æˆä¸€ä¸ªæ£®æ—ï¼Œæˆ‘ä»¬éœ€è¦å¤„ç†æ¯ä¸€æ£µæ ‘ï¼Œç„¶åæŠŠè¿™äº›æ ‘åˆå¹¶ï¼Œéœ€è¦æ ‘çš„ä¸ªæ•°å‡å»ä¸€çš„ä»£ä»·ã€‚ ç”±äºç¯å¿…é¡»è¦åˆå¹¶ï¼Œå¦‚æœè¦ç›´æ¥ç»Ÿè®¡æ“ä½œæ¬¡æ•°è¿˜éœ€è¦ç»Ÿè®¡ç¯çš„å¤§å°ï¼Œä¸å¦¨æ¢ä¸€ä¸ªæ€è·¯ï¼Œé»˜è®¤æ‰€æœ‰ç‚¹éƒ½éœ€è¦åˆå¹¶ï¼Œç„¶åå‡å»ä¸éœ€è¦åˆå¹¶çš„ã€‚ ç°åœ¨è€ƒè™‘æœ€åä¸€ä¸ªé—®é¢˜ï¼Œä¸€æ£µæ ‘æ€ä¹ˆå¤„ç†ï¼Ÿç›´è§‰å‘Šè¯‰æˆ‘ä»¬ï¼šè¿™æ¡è·¯å¾„ ppp åº”è¯¥æ˜¯é•¿åº¦ä¸º ddd ç›´å¾„ï¼Œè¿™æ ·æ‰èƒ½è®©è¦åŠ¨çš„ç‚¹æ›´å°‘ã€‚ç›´å¾„å¯ä»¥è®©æˆ‘ä»¬å°‘åˆå¹¶ ddd ä¸ªç‚¹ï¼Œå¶å­ä¸Šçš„ç‚¹ä¹Ÿå¯ä»¥ä¸ç”¨åˆå¹¶ï¼ˆç”»ä¸ªå›¾çœ‹çœ‹ï¼‰ï¼Œä½†æ˜¯ç›´å¾„ä¸¤ç«¯è¿˜æœ‰ä¸¤ä¸ªå¶å­ï¼Œæ‰€ä»¥è¦å‡å»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int u, v; edge(int u = 0, int v = 0) : u(u), v(v) &#123;&#125; &#125;; int n, m, cnt = 0, ans = 0, c[50005]; int num = 0, dfn[50005], low[50005]; int st[50005], tot = 0; bool vis[50005]; vector &lt;int> G[50005], F[50005]; vector &lt;edge> edges; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x, int in_edge) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].v; if (!dfn[y]) &#123; tarjan(y, G[x][i]); low[x] = min(low[x], low[y]); &#125; else if (G[x][i] != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); &#125; if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; c[y] = cnt; &#125; while (x != y); &#125; &#125; vector &lt;int> li; int d[50005]; void dfs(int x, int fa) &#123; d[x] = d[fa] + 1; for (int y : F[x]) if (y != fa) dfs(y, x); &#125; void find(int x) &#123; li.emplace_back(x); vis[x] = true; for (int i : F[x]) if (!vis[i]) find(i); &#125; void kill(int x) &#123; if (F[x].empty()) return ans += 1, void(); li.clear(); find(x); dfs(x, 0); int u = x, leaf = 0; for (int y : li) if (d[y] > d[u]) u = y; d[u] = 0; dfs(u, 0); for (int y : li) if (d[y] > d[u]) u = y; for (int y : li) leaf += (F[y].size() == 1); ans += d[u] + leaf - 2; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i, -1); for (int i = 0; i &lt; edges.size(); ++i) if (c[edges[i].u] != c[edges[i].v]) F[c[edges[i].u]].push_back(c[edges[i].v]); int ret = -1; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) ++ret, kill(i); printf(\"%d\\n\", n - ans + ret); return 0; &#125; æ¬§æ‹‰è·¯é—®é¢˜ ä¸æ¬§æ‹‰è·¯å¾„ç›¸å…³çš„é—®é¢˜ã€‚ [Luogu P1341] æ— åºå­—æ¯å¯¹ Portal. æ¨¡æ¿ï¼Œæ‰¾æ— å‘å›¾çš„ä¸€ç¬”ç”»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int H(char x) &#123; if (x >= 'A' &amp;&amp; x &lt;= 'Z') return x - 'A' + 1; return x - 'a' + 27; &#125; char V(int x) &#123; if (x &lt;= 26) return x - 1 + 'A'; return x - 27 + 'a'; &#125; int m, G[60][60], tot, in[60]; char st[1005]; void dfs(int x) &#123; for (int i = 1; i &lt;= 52; ++i) if (G[x][i]) &#123; G[x][i] = G[i][x] = false; dfs(i); &#125; st[++tot] = V(x); &#125; int main(void) &#123; scanf(\"%d\", &amp;m); int sta = 1e9; for (int i = 1; i &lt;= m; ++i) &#123; char s[5]; scanf(\"%s\", s); int u = H(s[0]), v = H(s[1]); G[u][v] = G[v][u] = 1; ++in[u]; ++in[v]; sta = min(&#123;sta, u, v&#125;); &#125; int cnt = 0, h = 0; for (int i = 1; i &lt;= 52; ++i) if (in[i] &amp; 1) &#123; ++cnt; if (!h) h = i; &#125; if (cnt == 1 || cnt > 2) return puts(\"No Solution\"), 0; dfs(h ? h : sta); if (tot != m + 1) return puts(\"No Solution\"), 0; for (int i = tot; i >= 1; --i) putchar(st[i]); return putchar('\\n'), 0; &#125; [CF1152E] Neko and Flashback Portal. å¯¹äºä¸€ä¸ª iiiï¼Œæœ‰ bi=minâ¡{ai,ai+1},ci=maxâ¡{ai,ai+1}b_i=\\min\\{a_i,a_{i+1}\\},c_i=\\max\\{a_i,a_{i+1}\\}biâ€‹=min{aiâ€‹,ai+1â€‹},ciâ€‹=max{aiâ€‹,ai+1â€‹}ï¼Œä¹Ÿå°±æ˜¯è¯´ bi,cib_i,c_ibiâ€‹,ciâ€‹ å„æ˜¯ ai,ai+1a_i,a_{i+1}aiâ€‹,ai+1â€‹ å…¶ä¸­çš„ä¸€ä¸ªï¼ˆå½“ç„¶éœ€è¦ biâ‰¤cib_i\\le c_ibiâ€‹â‰¤ciâ€‹ï¼Œå¦åˆ™æ— è§£ï¼‰ã€‚ æ³¨æ„è¿™ä¸ªè¾“å‡ºæ–¹å¼ï¼Œppp çš„ä½œç”¨æ˜¯å°† aaa æ’åˆ—ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åªéœ€è¦æ±‚å‡º aaa æœ‰å“ªäº›æ•°ç»„æˆå³å¯ã€‚å°†ç»™å®šçš„ ai,ai+1a_i,a_{i+1}aiâ€‹,ai+1â€‹ çš„å…³ç³»çœ‹æˆä¸€æ¡æ— å‘è¾¹ï¼Œèµ°è¿‡è¿™ä¸ªè·¯å¾„å°±ç›¸å½“äºæ»¡è¶³äº†ä¸€ä¸ªé™åˆ¶æ¡ä»¶ã€‚é‚£ä¹ˆåœ¨å›¾ä¸Šæ‰¾å‡ºæ¬§æ‹‰è·¯ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªæ»¡è¶³æ‰€æœ‰çš„é™åˆ¶æ¡ä»¶çš„åºåˆ— aaaï¼ˆéœ€è¦å…ˆç¦»æ•£åŒ–åå†å»ºå›¾ï¼‰ã€‚æ—¶é—´å¤æ‚åº¦ O((n+m)logâ¡m)O((n+m)\\log m)O((n+m)logm)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> using namespace std; int n, tot, cur[100005], deg[200005], st[200005]; int b[100005], c[100005], B[200005]; vector&lt;int> edges; vector&lt;int> G[200005]; inline void addedge(int u, int v) &#123; edges.emplace_back(v); G[u].emplace_back(edges.size() - 1); ++deg[v]; &#125; void dfs(int x) &#123; for (; cur[x] &lt; G[x].size(); ++cur[x]) &#123; int y = edges[G[x][cur[x]]]; if (y) &#123; edges[G[x][cur[x]]] = 0, edges[G[x][cur[x]] ^ 1] = 0; dfs(y); &#125; &#125; st[++tot] = x; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) scanf(\"%d\", b + i), B[++tot] = b[i]; for (int i = 1; i &lt; n; ++i) scanf(\"%d\", c + i), B[++tot] = c[i]; sort(B + 1, B + tot + 1); tot = unique(B + 1, B + tot + 1) - (B + 1); for (int i = 1; i &lt; n; ++i) &#123; b[i] = lower_bound(B + 1, B + tot + 1, b[i]) - B; c[i] = lower_bound(B + 1, B + tot + 1, c[i]) - B; if (b[i] > c[i]) return puts(\"-1\"), 0; addedge(b[i], c[i]); addedge(c[i], b[i]); &#125; int cnt = 0, h = 0; for (int i = 1; i &lt;= tot; ++i) if (deg[i] &amp; 1) &#123; ++cnt; if (!h) h = i; &#125; if (cnt == 1 || cnt > 2) return puts(\"-1\"), 0; tot = 0; dfs(h ? h : 1); if (tot != n) return puts(\"-1\"), 0; for (int i = tot; i >= 1; --i) printf(\"%d \", B[st[i]]); putchar('\\n'); return 0; &#125; [CF36E] Two Paths Portal. ä¸€é“å€¼å¾—ä¸€æƒ³ä¸å€¼å¾—ä¸€å†™çš„æ¬§æ‹‰è·¯ã€‚ åŸå›¾ä¸­æœ€å¤šåªèƒ½æœ‰ä¸¤ä¸ªè¿é€šå—ï¼Œæœ‰ä¸¤ä¸ªæ—¶å°±æ˜¯åˆ†åˆ«æ‰¾æ¬§æ‹‰è·¯ï¼Œä¸‹é¢æ¥çœ‹åªæœ‰ä¸€ä¸ªã€‚ å¦‚æœå®ƒåªæœ‰é›¶ä¸ªæˆ–ä¸¤ä¸ªå¥‡ç‚¹ï¼Œé‚£ä¹ˆæœ‰ä¸€ä¸ªæ¬§æ‹‰è·¯ï¼Œæˆ‘ä»¬æŠŠè¿™æ¡è·¯å¾„åˆ†å¼€ä¸€æ¡è¾¹ä½œä¸ºä¸€éƒ¨åˆ†ï¼Œè¿™æ ·å°±æ˜¯ä¸¤éƒ¨åˆ†äº†ï¼ˆåˆ†ä¸å‡ºæ¥å°±æ— è§£ï¼‰ï¼ å¦‚æœæœ‰å››ä¸ªå¥‡ç‚¹ï¼Œé‚£ä¹ˆæ˜¯ä¸¤ä¸ªï¼ˆåŠï¼‰æ¬§æ‹‰å›¾æ‹¼èµ·æ¥çš„ï¼Œå› æ­¤è€ƒè™‘ç»™ä¸¤ä¸ªå¥‡ç‚¹è¿ä¸€æ¡å‡è¾¹ï¼Œè·‘æ¬§æ‹‰è·¯ï¼Œè¾“å‡ºçš„æ—¶å€™ä»¥è¿™æ¡å‡è¾¹ä¸ºåˆ†ç•Œè¾“å‡ºä¸¤éƒ¨åˆ†ã€‚ ç”±äºè¦è¾“å‡ºè¾¹çš„ç¼–å·ï¼Œå› æ­¤ç”¨é“¾å¼å‰å‘æ˜Ÿæ–¹ä¾¿ä¸€äº›ï¼Œæç‚¹çš„æ—¶å€™éå†æ‰€æœ‰çš„è¾¹å¯»æ‰¾å¯¹åº”çš„æ˜¯å“ªä¸€æ¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, edgecnt = 1, dcc, oddcnt, head[10005], d[10005]; int dccOdd[10005], v[10005], U[10005], V[10005], b[20005]; bool vis[10005], printed[10005]; vector&lt;int> ans; struct Edge &#123; int to, nxt; &#125; G[20005]; inline void addedge(int u, int v) &#123; G[++edgecnt] = &#123;v, head[u]&#125;; head[u] = edgecnt; ++d[v]; &#125; void mark(int x) &#123; v[x] = dcc; dccOdd[dcc] += d[x] &amp; 1; oddcnt += d[x] &amp; 1; for (int i = head[x], y; i; i = G[i].nxt) if (!v[y = G[i].to]) mark(y); &#125; void dfs(int u) &#123; if (!d[u]) return ans.emplace_back(u), void(); for (int i = head[u], v; i; i = G[i].nxt) if (!vis[i >> 1]) &#123; vis[i >> 1] = true, --d[v = G[i].to], --d[u]; dfs(v); &#125; ans.emplace_back(u); &#125; void print(int l, int r) &#123; for (int i = l; i &lt; r; ++i) for (int j = head[ans[i]]; j; j = G[j].nxt) if (!printed[j >> 1] &amp;&amp; j >> 1 &lt;= m &amp;&amp; ans[i + 1] == G[j].to) &#123; if (i != l) putchar(' '); printed[j >> 1] = true; printf(\"%d\", j >> 1); break; &#125; putchar('\\n'); &#125; int main(void) &#123; freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", U + i, V + i); b[i &lt;&lt; 1] = U[i]; b[(i &lt;&lt; 1) - 1] = V[i]; &#125; sort(b + 1, b + 2 * m + 1); n = unique(b + 1, b + 2 * m + 1) - (b + 1); for (int i = 1; i &lt;= m; ++i) &#123; U[i] = lower_bound(b + 1, b + n + 1, U[i]) - b; V[i] = lower_bound(b + 1, b + n + 1, V[i]) - b; addedge(U[i], V[i]); addedge(V[i], U[i]); &#125; for (int i = 1; i &lt;= n; ++i) if (!v[i]) ++dcc, mark(i); if (oddcnt > 4 || dcc > 2) return puts(\"-1\"), 0; if (dcc == 1) &#123; int ond1 = 0, ond2 = 0, st = 0; if (oddcnt == 0) dfs(1); else if (oddcnt == 2) &#123; for (int i = 1; i &lt;= n; ++i) if (d[i] &amp; 1) &#123; dfs(i); break; &#125; &#125; else &#123; for (int i = 1; i &lt;= n &amp;&amp; !st; ++i) if (d[i] &amp; 1) &#123; if (!ond1) ond1 = i; else if (!ond2) ond2 = i; else st = i; &#125; addedge(ond1, ond2), addedge(ond2, ond1); // ä¸¤ä¸ªå¥‡æ•°ç‚¹åŠ ä¸€æ¡è™šæ‹Ÿè¾¹ ++d[ond1], ++d[ond2]; dfs(st); &#125; if (oddcnt != 4) &#123; if (ans.size() &lt;= 2) return puts(\"-1\"), 0; printf(\"%d\\n\", 1); print(0, 1); printf(\"%d\\n\", ans.size() - 2); print(1, ans.size()); &#125; else &#123; int _pre = 0; for (int i = 0; i &lt; ans.size(); ++i) &#123; if ((_pre == ond1 &amp;&amp; ans[i] == ond2) || (_pre == ond2 &amp;&amp; ans[i] == ond1)) &#123; printf(\"%d\\n\", i - 1); print(0, i - 1); printf(\"%d\\n\", m - i + 1); print(i, ans.size()); break; &#125; _pre = ans[i]; &#125; &#125; &#125; else &#123; if (dccOdd[1] > 2 || dccOdd[2] > 2) return puts(\"-1\"), 0; int nowVis = 0; for (int i = 1; i &lt;= n; ++i) if ((!nowVis || v[i] != nowVis) &amp;&amp; bool(dccOdd[v[i]]) == (d[i] &amp; 1)) &#123; dfs(i); printf(\"%d\\n\", ans.size() - 1); print(0, ans.size()); ans.clear(); if (nowVis) break; nowVis = v[i]; &#125; &#125; return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"ä¹è‡³åä¸€æœˆ Codeforces é¢˜ç›®é€‰ä½œ","slug":"default/old/cf202091","date":"2022-09-10T00:00:00.000Z","updated":"2022-09-10T00:00:00.000Z","comments":true,"path":"d0a8ff8d/","link":"","permalink":"https://james1badcreeper.github.io/d0a8ff8d/","excerpt":"è¿›å…¥ NOIP è®¡åˆ’åæœŸï¼Œå¼€å§‹é’ˆå¯¹æ€§åœ°åˆ·ä¸€äº› CF é¢˜ã€‚","text":"è¿›å…¥ NOIP è®¡åˆ’åæœŸï¼Œå¼€å§‹é’ˆå¯¹æ€§åœ°åˆ·ä¸€äº› CF é¢˜ã€‚ æ„é€ ä¸å…¶å®ƒæŠ€å·§ ä¹Ÿå°±æ˜¯æ‚é¢˜ï¼ŒåŒ…æ‹¬æ„é€ ï¼Œç®€å•æ–¹æ³•ï¼ˆå¦‚åŒæŒ‡é’ˆï¼‰å’Œæ€ç»´é¢˜ç­‰ã€‚ 1400~1500 Rating å€¼ä¸º 1400~1500 çš„æ‚é¢˜ã€‚ [CF1697C] awooâ€™s Favorite Problem Portal. å¯ä»¥å‘ç° a åªèƒ½å¾€åèµ°ï¼Œè€Œ c åªèƒ½å¾€å‰èµ°ï¼Œè€Œä¸” a, b ä¸ b, c çš„ç›¸å¯¹ä½ç½®ä¸å˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;string> #include &lt;cstring> using namespace std; int n; int suma[2][100005], sumc[2][100005]; string a, b; int main(void) &#123; int T; cin >> T; while (T--) &#123; cin >> n >> a >> b; bool flag = true; int b0 = 0, b1 = 0, i = 0, j = 0; for (; i &lt; n; ++i) &#123; while (b[j] == 'b') ++b1, ++j; // æ‰¾åˆ° t ä¸­ç¬¬ä¸€ä¸ªä¸æ˜¯ b çš„ï¼Œä»¥åŒ¹é…å½“å‰å­—ç¬¦ if (a[i] == 'b') ++b0; // å½“å‰çš„ s çš„è¿™ä¸ªå­—ç¬¦æ˜¯ bï¼Œè·³è¿‡ else &#123; if (a[i] != b[j] || a[i] == 'a' &amp;&amp; i > j || a[i] == 'c' &amp;&amp; i &lt; j) &#123; flag = false; break; &#125; ++j; // è¿™ä¸ªå­—ç¬¦åŒ¹é…è¿‡äº† &#125; &#125; while (j &lt; n) b1 += (b[j] == 'b'), ++j; if (b0 != b1) flag = false; cout &lt;&lt; (flag ? \"YES\" : \"NO\") &lt;&lt; '\\n'; &#125; return 0; &#125; [CF1728C] Digital Logarithm Portal. ä½¿ç”¨ä¸¤ä¸ªå¤§æ ¹å †è´ªå¿ƒåœ°ç»´æŠ¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;queue> using namespace std; int calc(int x) &#123; if (x == 0) return 1; int res = 0; while (x) &#123; ++res; x /= 10; &#125; return res; &#125; void solve(void) &#123; int n; priority_queue &lt;int> a, b; cin >> n; for (int i = 1, x; i &lt;= n; ++i) cin >> x, a.push(x); for (int i = 1, x; i &lt;= n; ++i) cin >> x, b.push(x); int ans = 0; while (!a.empty()) &#123; int x = a.top(), y = b.top(); if (x == y) a.pop(), b.pop(); else if (x &lt; y) b.pop(), b.push(calc(y)), ++ans; else a.pop(), a.push(calc(x)), ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; [CF1722G] Even-Odd XOR Portal. a=b âŸº a xor b=0a=b \\iff a~\\text{xor}~ b=0a=bâŸºa xor b=0ï¼Œä¹Ÿå°±æ˜¯åºåˆ—çš„å¼‚æˆ–å’Œä¸º 000ï¼Œæ ¹æ®æ­¤æ„é€ å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; void solve(void) &#123; int n = 0, w = 0, a[2]; cin >> n; for (int i = 1; i &lt; n - 2; ++i) cout &lt;&lt; i &lt;&lt; ' ', w ^= i; cout &lt;&lt; (1 &lt;&lt; 28) &lt;&lt; ' ' &lt;&lt; (1 &lt;&lt; 29) &lt;&lt; ' '; w ^= (1 &lt;&lt; 28); w ^= (1 &lt;&lt; 29); cout &lt;&lt; w &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; DP è¿™é‡Œæ˜¯ä¸€äº›åŠ¨æ€è§„åˆ’çš„é¢˜ç›®ã€‚ 1900~2100 è¿™ä¸ªæ¡£çš„ DP é¢˜ä¸€èˆ¬éƒ½æ¯”è¾ƒåŸºç¡€ã€‚ [CF229D] Towers Portal. ä»¤ f(i,j)f(i,j)f(i,j) ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªï¼Œå°† (j,i](j,i](j,i] åˆå¹¶èµ·æ¥çš„æœ€å°ä»£ä»·ã€‚å†™å¥½æ–¹ç¨‹åå‘ç°å…·æœ‰å•è°ƒæ€§ï¼Œç„¶åå°±åªå‰©ä¸€ç»´äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, s[5005]; int f[5005], g[5005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", s + i); s[i] += s[i - 1]; &#125; memset(f, 0x3f, sizeof(f)); f[0] = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; i; ++j) if (s[i] - s[j] >= s[j] - s[g[j]]) &#123; f[i] = f[j] + i - j - 1; g[i] = j; &#125; printf(\"%d\\n\", f[n]); return 0; &#125; å•è°ƒé˜Ÿåˆ—å¯ä»¥å°†å…¶ä¼˜åŒ–åˆ° O(n)O(n)O(n)ã€‚ [CF9D] How many trees? Portal. æ±‚é«˜åº¦ä¸è¶…è¿‡ hhhï¼Œæœ‰ nnn ä¸ªç‚¹çš„äºŒå‰æ ‘ä¸ªæ•°ã€‚ ç›´æ¥ f(i,j)f(i,j)f(i,j)ï¼Œç„¶åé€’æ¨ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, h; i64 f[40][40]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;h); for (int i = 0; i &lt;= n; ++i) f[0][i] = 1; for (int i = 1; i &lt;= n; ++i) // loop h for (int j = 1; j &lt;= n; ++j) for (int k = 0; k &lt; j; ++k) f[j][i] += f[k][i - 1] * f[j - k - 1][i - 1]; printf(\"%lld\\n\", f[n][n] - f[n][h - 1]); return 0; &#125; [CF1012C] Hills Portal. è®¾ f(i,j,k)f(i,j,k)f(i,j,k) ä¸ºå½“å‰è€ƒè™‘åˆ° iiiï¼Œkkk ä»£è¡¨å½“å‰æ˜¯ä¸æ˜¯éœ€è¦æ»¡è¶³çš„ï¼Œjjj ä»£è¡¨æ€»å…±æ»¡è¶³çš„ä¸ªæ•°å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int n; int a[5005]; int f[5005][2505][2]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0x3f, sizeof(f)); f[0][0][0] = f[1][0][0] = f[1][1][1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; f[i][0][0] = 0; for (int j = 1; j &lt;= (i + 1) / 2; ++j) &#123; f[i][j][0] = min(f[i - 1][j][0], f[i - 1][j][1] + max(0, a[i] - a[i - 1] + 1)); f[i][j][1] = min(f[i - 2][j - 1][0] + max(0, a[i - 1] - a[i] + 1), f[i - 2][j - 1][1] + max(&#123;0, a[i - 1] - a[i - 2] + 1, a[i - 1] - a[i] + 1&#125;)); &#125; &#125; for (int i = 1; i &lt;= (n + 1) / 2; ++i) printf(\"%d \", min(f[n][i][0], f[n][i][1])); putchar('\\n'); return 0; &#125; [CF533B] Work Group Portal. è®¾ f[x][0/1]f[x][0/1]f[x][0/1] ä»£è¡¨å¥‡æ•°æˆ–å¶æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; typedef long long i64; const i64 INF = 1e18; int n, root, a[200005]; i64 f[200005][2], ans = 0; vector &lt;int> G[200005]; void dp(int x) &#123; f[x][0] = 0, f[x][1] = -INF; for (auto y : G[x]) &#123; dp(y); i64 p = f[x][0], q = f[x][1]; f[x][0] = max(p + f[y][0], q + f[y][1]); f[x][1] = max(p + f[y][1], q + f[y][0]); &#125; f[x][1] = max(f[x][1], f[x][0] + a[x]); ans = max(&#123;ans, f[x][0], f[x][1]&#125;); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;x, a + i); if (x != -1) G[x].push_back(i); else root = i; &#125; dp(root); printf(\"%lld\\n\", ans); return 0; &#125; [CF1060E] Sergey and Subway Portal. ä¸åŠ è¾¹çš„ç­”æ¡ˆå¾ˆå®¹æ˜“è®¡ç®—ï¼ŒåŠ è¾¹ä¹‹åé•¿åº¦åº”è¯¥é™¤ä»¥ 222ï¼Œä½†æ˜¯å¥‡æ•°é•¿åº¦æ˜¯éœ€è¦ä¿®æ­£çš„ï¼Œåº”è¯¥åŠ ä¸Šå¥‡æ•°é•¿åº¦çš„è·¯å¾„æ•°å†é™¤ã€‚å¥‡æ•°é•¿åº¦çš„è·¯å¾„æ•°åˆ©ç”¨æ·±åº¦çš„å¥‡å¶æ€§å°±èƒ½ç®€å•è®¡ç®—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; i64 ans = 0; int n, dep[200005], siz[200005], cnt[2]; vector &lt;int> G[200005]; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; siz[x] = 1; cnt[dep[x] &amp; 1] += 1; for (auto y : G[x]) &#123; if (y == fa) continue; dfs(y, x); siz[x] += siz[y]; ans += 1ll * siz[y] * (n - siz[y]); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x, y; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); &#125; dfs(1, 0); printf(\"%lld\\n\", (ans + 1ll * cnt[0] * cnt[1]) / 2); return 0; &#125; DS è¿™é‡Œæ˜¯ä¸€äº›æ•°æ®ç»“æ„çš„é¢˜ç›®ã€‚ 2000 Rating å€¼ä¸º 2000~2100 çš„ç®€å•æ•°æ®ç»“æ„ã€‚ [CF242E] XOR on Segment Portal. ç”±äº xor çš„æ¯ä¸€ä½å¯ä»¥åˆ†å¼€è®¡ç®—ï¼Œè€Œä¸”æ•°çš„å€¼åŸŸå¾ˆå°ï¼Œå¯ä»¥å¼€ 20 æ£µçº¿æ®µæ ‘å¯¹æ¯ä¸€ä½è¿›è¡Œç»Ÿè®¡ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, m; int a[100005]; int T[400005][20], tag[400005]; inline void maintain(int o) &#123; for (int i = 0; i &lt; 20; ++i) T[o][i] = T[o &lt;&lt; 1][i] + T[o &lt;&lt; 1 | 1][i]; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; for (int i = 0; i &lt; 20; ++i) if ((a[l] >> i) &amp; 1) T[o][i] = 1; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; inline void pushdown(int o, int l, int r) &#123; if (!tag[o]) return; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; for (int i = 0; i &lt; 20; ++i) if ((tag[o] >> i) &amp; 1) &#123; T[ls][i] = mid - l + 1 - T[ls][i]; T[rs][i] = r - mid - T[rs][i]; &#125; tag[ls] ^= tag[o], tag[rs] ^= tag[o]; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; for (int i = 0; i &lt; 20; ++i) if ((k >> i) &amp; 1) T[o][i] = r - l + 1 - T[o][i]; tag[o] ^= k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); maintain(o); &#125; i64 query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; i64 res = 0; for (int i = 0; i &lt; 20; ++i) res += 1ll * T[o][i] * (1 &lt;&lt; i); return res; &#125; pushdown(o, l, r); int mid = l + r >> 1; i64 res = 0; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); scanf(\"%d\", &amp;m); while (m--) &#123; int op, l, r, x; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) printf(\"%lld\\n\", query(1, 1, n, l, r)); else &#123; scanf(\"%d\", &amp;x); update(1, 1, n, l, r, x); &#125; &#125; return 0; &#125; æ•°å­¦ è¿™é‡Œæ˜¯ä¸€äº›æ•°å­¦é¢˜ã€‚ å›¾è®º è¿™é‡Œæ˜¯å›¾è®ºé¢˜ã€‚ 1600~1800 è¿™ä¸ªèŒƒå›´å†…çš„å›¾è®ºé¢˜åœ¨ OI ä¸­éƒ½ä¸ä¼šå¾ˆéš¾ï¼Œå°±æ˜¯ç»å…¸ç®—æ³•çš„ç®€å•è¿ç”¨ã€‚ ç»¼åˆé—®é¢˜ ä¸æ­¢ä¸€ç§ç®—æ³•çš„é¢˜ç›®ï¼Œæˆ–è€…è€ƒéªŒæ€ç»´ã€‚ 1700~1900 Rating å€¼ä¸º 1700~1900 çš„ç»¼åˆæ€§é¢˜ç›®ã€‚ [CF223B] Two Strings Portal. æˆ‘ä»¬æ‰«æ sssï¼Œç„¶åè´ªå¿ƒåœ°é…å¯¹ï¼Œè¯¦è§ä»£ç ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;cstdio> #include &lt;cstring> int n, m, f[30]; // f è®°å½• t ä¸­æ¯ä¸€ä¸ªå­—æ¯çš„ä½ç½® +1 int l = 1, cnt = 1; // l è®°å½•å½“å‰åœ¨ t ä¸­çš„é…å¯¹æ ‡å· char s[200005], t[200005]; int main(void) &#123; scanf(\"%s%s\", s + 1, t + 1); n = strlen(s + 1), m = strlen(t + 1); for (int i = 1; i &lt;= n; ++i) &#123; // å¯ä»¥é…å¯¹å°±é…å¯¹ if (s[i] == t[l]) ++l; if (s[i] == t[cnt]) f[s[i] - 'a'] = ++cnt; // è¿™ä¸ªå­—æ¯åœ¨ t ä¸­æ‰«ä¸åˆ° // å³ä½¿åé¢æœ‰ï¼Œå‰é¢çš„ä¹Ÿä¸å¤Ÿæ„æˆå­åºåˆ— if (f[s[i] - 'a'] == 0) return puts(\"No\"), 0; // å½“ l > è¿™ä¸ªå­—æ¯æœ€åä¸€æ¬¡çš„ä½ç½®+1 æ—¶ï¼Œè¯´æ˜å½“å‰çš„ l æ ¹æœ¬ä¸å¯èƒ½åŒ¹é…ä¸Š // æˆ‘ä»¬å°†å®ƒç§»åˆ°æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œè¿™æ · t ä¸­æœ€åå‡ºç°çš„ä½ç½®ä¹‹å‰éƒ½æ˜¯å¯ä»¥ä¸ s çš„åŒ¹é…çš„ï¼Œè¿™æ ·åªéœ€è¦åŒ¹é… t ä¸­çš„å‰©ä½™å†…å®¹ï¼Œç”±äºé€‰çš„æ˜¯å­åºåˆ—æ‰€ä»¥è‚¯å®šæ˜¯å‰©çš„è¶Šå°‘è¶Šå¥½ï¼Œæ‰€ä»¥ç§»åˆ°æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚ if (f[s[i] - 'a'] &lt; l) l = f[s[i] - 'a']; &#125; if (l &lt;= m) puts(\"No\"); // æ²¡æœ‰é…å®Œ else puts(\"Yes\"); return 0; &#125; [CF959D] Mahmoud and Ehab and another array construction task Portal. ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„æ•°åˆ— {an}\\{a_n\\}{anâ€‹}ã€‚è¦æ±‚æ„é€ ä¸€ä¸ªæ•°åˆ— {bn}\\{b_n\\}{bnâ€‹} æ»¡è¶³ âˆ€ iâ‰ j\\forall \\ i\\neq jâˆ€ iî€ =jï¼Œ bib_ibiâ€‹ ä¸ bjb_jbjâ€‹ äº’è´¨ï¼ˆå³ (bi,bj)=1(b_i,b_j)=1(biâ€‹,bjâ€‹)=1ï¼‰ï¼Œä¸” {bn}\\{b_n\\}{bnâ€‹} çš„å­—å…¸åº â‰¥\\geâ‰¥ {an}\\{a_n\\}{anâ€‹} çš„å­—å…¸åºï¼Œä¸” {bn}\\{b_n\\}{bnâ€‹} çš„å­—å…¸åºæ˜¯æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„æ•°åˆ—ä¸­æœ€å°çš„ã€‚1â‰¤nâ‰¤1051\\leq n\\leq 10^51â‰¤nâ‰¤105ï¼Œ 2â‰¤aiâ‰¤1052\\leq a_i\\leq 10^52â‰¤aiâ€‹â‰¤105ã€‚ ä¸€å¼€å§‹æ‰€æœ‰æ•°éƒ½èƒ½é€‰ï¼Œç„¶åæ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äº aia_iaiâ€‹ çš„ï¼Œæ€æ‰å®ƒçš„æ‰€æœ‰å€æ•°ï¼Œå¦‚æœæ­¤æ—¶å·²ç»å¤§äº aia_iaiâ€‹ äº†ï¼Œé‚£ä¹ˆåé¢å°±éšä¾¿é€‰äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;set> using namespace std; const int N = 2000000; int n; int a[100005]; set &lt;int> s; void kill(int x) &#123; for (int i = x; i &lt;= N; i += x) if (s.count(i)) s.erase(i); &#125; void del(int x) &#123; for (int i = 2; i * i &lt;= N; ++i) &#123; if (x % i == 0) &#123; while (x % i == 0) x /= i; kill(i); &#125; &#125; if (x > 1) kill(x); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 2; i &lt;= N; ++i) s.insert(i); bool flag = false; for (int i = 1; i &lt;= n; ++i) &#123; auto it = flag ? s.begin() : s.lower_bound(a[i]); printf(\"%d \", *it); del(*it); &#125; putchar('\\n'); return 0; &#125; [CF1718A2] Burenka and Traditions (hard version) Portal. ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„æ•°ç»„ AAAï¼Œä¸€æ¬¡æ“ä½œå¯ä»¥é€‰æ‹©ä¸€ä¸ªåŒºé—´ [l,r][l,r][l,r]ï¼Œå°†æ‰€æœ‰æ•°å¼‚æˆ–ä¸Š xxxï¼Œä»£ä»·ä¸º âŒˆrâˆ’l+12âŒ‰\\lceil \\frac{r-l+1}{2}\\rceilâŒˆ2râˆ’l+1â€‹âŒ‰ã€‚é—®å°†æ‰€æœ‰æ•°å˜æˆ 000 çš„æœ€å°ä»£ä»·ã€‚ ç”±äºå‘ä¸Šå–æ•´çš„æ€§è´¨ï¼Œå¯ä»¥å‘ç°æ‰€æœ‰æ“ä½œéƒ½å¯ä»¥æ‹†åˆ†æˆåŒºé—´é•¿åº¦ä¸º 1âˆ¼21\\sim 21âˆ¼2 çš„æ“ä½œã€‚ä¸€å¼€å§‹ ans=nans=nans=nï¼Œå½“ä¸€æ®µå­æ®µçš„å¼‚æˆ–å’Œä¸º 000 æ—¶ï¼Œå¯ä»¥è¿ç€ç”¨åŒºé—´é•¿åº¦ä¸º 222 çš„æ“ä½œï¼Œansansans å¯ä»¥å‡å° 111ï¼Œè´ªå¿ƒå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;map> using namespace std; int n; int a[100005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; int ans = n, S = 0; map &lt;int, int> s; s[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; S ^= a[i]; if (s.find(S) != s.end()) &#123; --ans; s.clear(); s[S = 0] = 1; &#125; else s[S] = 1; &#125; cout &lt;&lt; ans &lt;&lt; '\\n'; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"}]},{"title":"ç®€å•æ¦‚ç‡è®º","slug":"notes/æ•°å­¦/easy-probability","date":"2022-09-01T00:00:00.000Z","updated":"2022-09-01T00:00:00.000Z","comments":true,"path":"ccbe608c/","link":"","permalink":"https://james1badcreeper.github.io/ccbe608c/","excerpt":"æ¦‚ç‡è®ºç ”ç©¶çš„æ˜¯éšæœºäº‹ä»¶ï¼Œæœ¬æ–‡å°†ç®€å•ä»‹ç»æ¦‚ç‡è®ºã€‚","text":"æ¦‚ç‡è®ºç ”ç©¶çš„æ˜¯éšæœºäº‹ä»¶ï¼Œæœ¬æ–‡å°†ç®€å•ä»‹ç»æ¦‚ç‡è®ºã€‚ äº‹ä»¶ è¿™æ˜¯ä¸€äº›åŸºæœ¬æ¦‚å¿µã€‚ éšæœºäº‹ä»¶ä¸æ ·æœ¬ç©ºé—´ éšæœºè¯•éªŒæŒ‡çš„æ˜¯åœ¨ç›¸åŒçš„æ¡ä»¶ä¸‹ï¼Œå¯¹æŸä¸ªéšæœºç°è±¡è¿›è¡Œçš„å¤§é‡é‡å¤è§‚æµ‹ã€‚éšæœºè¯•éªŒå¯ä»¥åœ¨ç›¸åŒçš„æ¡ä»¶ä¸‹é‡å¤è¿›è¡Œï¼Œå‡ºç°çš„æ‰€æœ‰å¯èƒ½ç»“æœä¸æ­¢ä¸€ä¸ªï¼Œä½†éƒ½å·²çŸ¥ï¼ˆæ¯”å¦‚æŠ›ä¸€æšæ— é™è–„ä½†æœ‰ä¸€å®šè´¨é‡ç¡¬å¸ä¸€å®šæ˜¯æ­£é¢æœä¸Šæˆ–è€…åé¢æœä¸Šï¼‰ï¼Œæ¯æ¬¡å®éªŒæ€»æ˜¯å‡ºç°å¯èƒ½ç»“æœä¹‹ä¸€ï¼Œä½†å®éªŒå‰æ— æ³•é¢„çŸ¥å¾—åˆ°å“ªä¸€ç§ç»“æœ[1]ã€‚ æˆ‘ä»¬æŠŠæ¯ä¸€ç§å¯èƒ½ï¼Œæ¯”å¦‚æŠ›ç¡¬å¸å‡ºç°æ­£é¢ï¼Œç§°ä¹‹ä¸ºåŸºæœ¬äº‹ä»¶ï¼Œæˆ–è€…æ ·æœ¬ç‚¹ï¼Œç”¨ A,B,Câ€¦A,B,C\\dotsA,B,Câ€¦ è¡¨ç¤ºï¼Œå…¨ä½“æ ·æœ¬ç‚¹æ„æˆçš„é›†åˆç§°ä¸ºæ ·æœ¬ç©ºé—´ï¼Œç”¨ Î©\\OmegaÎ© æ¥è¡¨ç¤ºï¼ˆæœ‰çš„æ—¶å€™ä¹Ÿæ˜¯ç”¨ SSSï¼‰ã€‚ æ ·æœ¬ç©ºé—´å¯ä»¥æ˜¯æœ‰é™é›†ï¼Œä¹Ÿå¯ä»¥æ˜¯æ— é™é›†ã€‚æ¯”å¦‚æŠ›ç¡¬å¸æ—¶ S={æ­£ï¼Œå}S=\\{æ­£ï¼Œå\\}S={æ­£ï¼Œå}ï¼Œæ˜¯æœ‰é™é›†ï¼›é€‰å–ä¸€ä¸ª [0,1][0,1][0,1] ä¸­çš„å®æ•°æ—¶ï¼ŒS={xâˆˆRâˆ£0â‰¤xâ‰¤1}S=\\{x\\in\\mathbb{R}\\mid 0\\le x\\le 1\\}S={xâˆˆRâˆ£0â‰¤xâ‰¤1}ï¼Œå°±æ˜¯ä¸€ä¸ªæ— é™é›†ã€‚ éšæœºäº‹ä»¶ AAA æ˜¯ Î©\\OmegaÎ© çš„ä¸€ä¸ªå­é›†ï¼Œå½“ AAA ä¸­çš„æŸä¸ªåŸºæœ¬äº‹ä»¶å‘ç”Ÿçš„æ—¶å€™ï¼Œæˆ‘ä»¬ç§° AAA äº‹ä»¶å‘ç”Ÿã€‚ è‹¥ A=Î©A=\\OmegaA=Î©ï¼Œåˆ™ç§° AAA æ˜¯å¿…ç„¶äº‹ä»¶ï¼Œæ¯”å¦‚ james1 è€ƒè¯•å¾—é›¶åˆ†ï¼› è‹¥ A=âˆ…A=\\varnothingA=âˆ…ï¼Œåˆ™ç§° AAA æ˜¯ä¸å¯èƒ½äº‹ä»¶ï¼Œæ¯”å¦‚ james1 çš„æ™ºå•†ä¸ºæ­£æ•°ã€‚ å®é™…ä¸Šä¸Šè¿°ä¾‹å­ä¸å¤ªå‡†ç¡®ï¼Œçœ‹çœ‹å°±å¥½ã€‚ æˆ‘ä»¬å…³å¿ƒçš„äº‹ä»¶æ„æˆäº‹ä»¶åŸŸ F\\mathcal{F}Fï¼Œè€Œä¸”éœ€è¦ F\\mathcal{F}F åœ¨è¡¥è¿ç®—ã€å’Œå¯æ•°å¹¶ä¸‹æ˜¯å°é—­çš„ï¼Œå¹¶ä¸” âˆ…âˆˆF\\varnothing \\in \\mathcal{F}âˆ…âˆˆFã€‚ P(A)P(A)P(A) ä»£è¡¨å…¶ä¸€ä¸ªéšæœºäº‹ä»¶ AAA å‘ç”Ÿçš„æ¦‚ç‡ï¼ŒPPP ç§°ä¸ºæ¦‚ç‡å‡½æ•°ï¼Œæ˜¯ä¸€ä¸ªä»äº‹ä»¶åŸŸ F\\mathcal{F}F åˆ° [0,1][0,1][0,1] çš„æ˜ å°„ï¼Œæ»¡è¶³ï¼š è§„èŒƒæ€§ï¼ŒP(Î©)=1P(\\Omega)=1P(Î©)=1ï¼› å¯æ•°å¯åŠ æ€§ï¼Œä¹Ÿå°±æ˜¯ä¸‹æ–‡æ‰€è¯´çš„äº’æ–¥äº‹ä»¶çš„æ¦‚ç‡å¯åŠ ã€‚ åœ¨ç ”ç©¶ä¸€ä¸ªéšæœºç°è±¡æ—¶ï¼Œæˆ‘ä»¬é€šå¸¸å…³æ³¨æ ·æœ¬ç©ºé—´ Î©\\OmegaÎ©ï¼Œäº‹ä»¶åŸŸ F\\mathcal{F}F å’Œæ¦‚ç‡å‡½æ•° PPPï¼Œå°† (Î©,F,P)(\\Omega, \\mathcal{F}, P)(Î©,F,P) ç§°ä¸ºä¸€ä¸ªæ¦‚ç‡ç©ºé—´ã€‚ äº‹ä»¶çš„è¿ç®— ç”±äºéšæœºäº‹ä»¶æ˜¯é›†åˆï¼Œæ‰€ä»¥å®ƒä»¬çš„è¿ç®—è·Ÿé›†åˆè¿ç®—å¤§è‡´åŒç†ã€‚ è‹¥ AâŠ†BA\\subseteq BAâŠ†Bï¼Œåˆ™ AAA å‘ç”Ÿæ—¶ BBB ä¸€å®šå‘ç”Ÿã€‚ ä¹Ÿè¢«ç§°ä¸ºæ¦‚ç‡å‡½æ•°çš„å•è°ƒæ€§ï¼Œå³è‹¥ AâŠ†BA\\subseteq BAâŠ†Bï¼Œé‚£ä¹ˆ P(A)â‰¤P(B)P(A)\\le P(B)P(A)â‰¤P(B)ã€‚ è‹¥ A=BA=BA=Bï¼Œåˆ™å®ƒä»¬åŒ…å«çš„æ ·æœ¬ç‚¹æ˜¯ç›¸åŒçš„ï¼› å‡ ä¸ªä¸åŒçš„éšæœºäº‹ä»¶ä¹Ÿä¼šåŒæ—¶å‘ç”Ÿï¼Œå‘ç”Ÿçš„æƒ…å†µå°±æ˜¯å®ƒä»¬çš„äº¤é›†ï¼Œå³ Aâˆ©BA\\cap BAâˆ©Bï¼Œç®€è®°ä¸º ABABABã€‚ è‹¥ Aâˆ©B=âˆ…A\\cap B=\\varnothingAâˆ©B=âˆ…ï¼Œé‚£ä¹ˆ A,BA,BA,B ä¸å¯èƒ½åŒæ—¶å‘ç”Ÿï¼Œä¹Ÿå°±æ˜¯è¯´ A,BA,BA,B æ˜¯äº’æ–¥äº‹ä»¶ï¼Œæˆ–ç§°â€œäº’ä¸ç›¸å®¹äº‹ä»¶â€œã€‚nnn ä¸ªéšæœºäº‹ä»¶äº’æ–¥çš„å……è¦æ¡ä»¶æ˜¯ä»»æ„ä¸¤ä¸ªéšæœºäº‹ä»¶äº’æ–¥ï¼Œæ­¤æ—¶æœ‰ P(A+B)=P(A)+P(B)P(A+B)=P(A)+P(B)P(A+B)=P(A)+P(B)ï¼Œè¢«ç§°ä¸ºäº’æ–¥äº‹ä»¶çš„æ¦‚ç‡åŠ æ³•å…¬å¼ã€‚ AâˆªBA\\cup BAâˆªB è¡¨ç¤º A,BA,BA,B è‡³å°‘æœ‰ä¸€ä¸ªå‘ç”Ÿï¼Œç®€è®°ä¸º A+BA+BA+Bã€‚ AAA å‘ç”Ÿï¼ŒBBB ä¸å‘ç”Ÿè®°ä¸º Aâˆ’BA-BAâˆ’Bã€‚ ç”± AAA ä¸å‘ç”Ÿæ‰€æ„æˆçš„äº‹ä»¶ï¼Œæˆä¸º AAA çš„å¯¹ç«‹äº‹ä»¶ï¼Œä¹Ÿå°±æ˜¯è¯´ AAA çš„å¯¹ç«‹äº‹ä»¶ Aâ€¾=âˆÎ©A\\overline{A}=\\complement_{\\Omega}AA=âˆÎ©â€‹Aã€‚ AAâ€¾=âˆ…,A+Aâ€¾=S,Aâ€¾â€¾=AA\\overline{A}=\\varnothing,A+\\overline{A}=S,\\overline{\\overline{A}}=AAA=âˆ…,A+A=S,A=Aã€‚ å¾·Â·æ‘©æ ¹å®šå¾‹ï¼ŒA+Bâ€¾=Aâ€¾ Bâ€¾,ABâ€¾=Aâ€¾+Bâ€¾\\overline{A+B}=\\overline{A}~\\overline{B},\\overline{AB}=\\overline{A}+\\overline{B}A+Bâ€‹=A B,AB=A+Bã€‚åˆ†åˆ«æŒ‡å¦‚æœ AAA æˆ– BBB ä¸å‘ç”Ÿï¼Œé‚£ä¹ˆ A,BA,BA,B åŒæ—¶ä¸å‘ç”Ÿï¼›å¦‚æœ AAA ä¸” BBB ä¸å‘ç”Ÿï¼Œé‚£ä¹ˆåªéœ€è¦ AAA ä¸å‘ç”Ÿæˆ–è€… BBB ä¸å‘ç”Ÿå³å¯ï¼Œå…·ä½“å¯ä»¥é€šè¿‡ Venn å›¾æ¥ç†è§£ã€‚ å®¹æ–¥åŸç†ï¼šP(A+B)=P(A)+P(B)âˆ’P(AB)P(A+B)=P(A)+P(B)-P(AB)P(A+B)=P(A)+P(B)âˆ’P(AB)ã€‚ P(Aâˆ’B)=P(A)âˆ’P(AB)P(A-B)=P(A)-P(AB)P(Aâˆ’B)=P(A)âˆ’P(AB)ã€‚ æ¦‚ç‡æ¨¡å‹ æ¦‚ç‡è¦æ¥å•¦ï¼ å¤å…¸æ¦‚å‹ å½“æ¯ä¸€ä¸ªæ ·æœ¬ç‚¹åªæœ‰æœ‰é™ä¸ªåŸºæœ¬ç»“æœï¼Œæ¯ä¸ªåŸºæœ¬ç»“æœå‡ºç°çš„å¯èƒ½æ€§æ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆï¼š P(A)=card(A)card(S)P(A)=\\cfrac{\\text{card}(A)}{\\text{card}(S)} P(A)=card(S)card(A)â€‹ ç”Ÿæ—¥æ‚–è®ºã€‚ä¸€å¹´æœ‰ 365365365 å¤©ï¼Œæ¯ä¸ªäººçš„ç”Ÿæ—¥å®Œå…¨éšæœºï¼Œæœ‰ 303030 ä½åŒå­¦ï¼Œé—®â€äº‹ä»¶ AAAï¼ˆå­˜åœ¨ä¸¤ä¸ªåŒå­¦ç”Ÿæ—¥ç›¸åŒï¼‰â€œçš„æ¦‚ç‡ã€‚ æˆ‘ä»¬å¯ä»¥æ±‚ 1âˆ’Aâ€¾1-\\overline{A}1âˆ’Aï¼Œå°±å¯ä»¥å¾—å‡ºç­”æ¡ˆã€‚é‚£ä¹ˆåˆ©ç”¨ä¹˜æ³•åŸç†ï¼š P(Aâ€¾)=A36530âˆi=130365=365Ã—â‹¯Ã—336365Ã—â‹¯Ã—365â‰ˆ0.29368P\\left(\\overline{A}\\right)=\\cfrac{A_{365}^{30}}{\\prod_{i=1}^{30}365}=\\cfrac{365\\times \\cdots \\times336}{365\\times\\cdots\\times 365}\\approx 0.29368P(A)=âˆi=130â€‹365A36530â€‹â€‹=365Ã—â‹¯Ã—365365Ã—â‹¯Ã—336â€‹â‰ˆ0.29368ï¼Œä¹Ÿå°±æ˜¯è¯´ P(A)â‰ˆ70%P(A)\\approx 70\\%P(A)â‰ˆ70%ï¼ å¤å…¸æ¦‚å‹çš„åº”ç”¨ æˆ‘ä»¬æ¥çœ‹ä¸€äº›ç®€å•çš„é¢˜ç›®ã€‚ [Luogu P2719] æç¬‘ä¸–ç•Œæ¯ Portal. card(S)card(S)card(S) å¾ˆå¥½æ±‚ï¼Œå°±æ˜¯ C2nnC_{2n}^{n}C2nnâ€‹ã€‚ä½†æ˜¯è®¡ç®—æœ€æœ«å°¾ä¸¤ä¸ªäººæ‹¿åˆ°ç›¸åŒçƒç¥¨çš„æ¦‚ç‡è¾ƒéš¾ï¼ˆå› ä¸ºä¸ä¸€å®šéœ€è¦æŠ›ç¡¬å¸äº†ï¼‰ï¼Œè€ƒè™‘è®¡ç®—ä¸åŒçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¦æ±‚å‡ºâ€œåˆ°æœ€åä¸¤äººæ—¶ï¼Œä¸¤ç±»é—¨ç¥¨éƒ½æ²¡æœ‰è¢«å–ç©ºâ€œçš„æ¦‚ç‡ã€‚æ»¡è¶³æ¡ä»¶çš„äº‹ä»¶å…±æœ‰ C2nâˆ’2nâˆ’1C_{2n-2}^{n-1}C2nâˆ’2nâˆ’1â€‹ ç§ï¼Œæ¯ç§äº‹ä»¶å‘ç”Ÿçš„æ¦‚ç‡æ˜¯ 122nâˆ’2\\cfrac{1}{2^{2n-2}}22nâˆ’21â€‹ï¼ˆå› ä¸ºä¸€å®šéœ€è¦æŠ›ç¡¬å¸ï¼‰ï¼Œä¹Ÿå°±æ˜¯ C2nâˆ’2nâˆ’1Ã—122nâˆ’2C_{2n-2}^{n-1}\\times\\cfrac{1}{2^{2n-2}}C2nâˆ’2nâˆ’1â€‹Ã—22nâˆ’21â€‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; double ans = 1.0; int main(void) &#123; scanf(\"%d\", &amp;n); n >>= 1; for (int i = 1; i &lt; n; ++i) ans = ans * (i + n - 1) / (i &lt;&lt; 2); printf(\"%.4lf\\n\", 1 - ans); return 0; &#125; [UVa 1636] Headshot Portal. ç›´æ¥æŠ ä¸€æªæ²¡æœ‰å­å¼¹çš„æ¦‚ç‡æ˜¯ 00 çš„ä¸ªæ•°é™¤ä»¥ 0 çš„ä¸ªæ•°ï¼Œè½¬ä¸€ä¸‹æ²¡æœ‰å­å¼¹çš„æ¦‚ç‡æ˜¯ 0 çš„ä¸ªæ•°åˆä¸€æ€»æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;cstdio> #include &lt;cstring> int main(void) &#123; static char s[120]; while (scanf(\"%s\", s) == 1) &#123; int a = 0, b = 0, n = strlen(s); for (int i = 0; i &lt; n; ++i) if (s[i] == '0') &#123; ++b; if (s[(i + 1) % n] == '0') ++a; &#125; // a / b ? b / n if (a * n == b * b) puts(\"EQUAL\"); else if (a * n > b * b) puts(\"SHOOT\"); else puts(\"ROTATE\"); &#125; return 0; &#125; [UVa 10491] Cows and Cars Portal. ç›´æ¥åˆ†åˆšå¼€å§‹æŠ“åˆ°ç‰›å’Œæ²¡æŠ“åˆ°ç‰›ç®€å•è®¨è®ºå³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int a, b, c; while (scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c) == 3) printf(\"%.5lf\\n\", double(a * b + b * b - b) / (double(a + b) * (a + b - c - 1))); // a / (a + b) * b / (a + b - c - 1) // b / (a + b) * (b - 1) / (a + b - c - 1) // a * b + b * b - b return 0; &#125; å‡ ä½•æ¦‚å‹ é›†åˆæ¦‚å‹çš„æ ·æœ¬ç©ºé—´ä¸ºæ— é™é›†ã€‚æ¯”å¦‚è¯´ james1 ç­‰è½¦ï¼Œè½¦åœ¨ 8:00âˆ¼9:008:00\\sim 9:008:00âˆ¼9:00 åˆ°ï¼Œé‚£ä¹ˆåœ¨å…«ç‚¹åŠä¹‹å‰ç­‰åˆ°è½¦çš„æ—¶é—´ä¸º 50%50\\%50%ã€‚ æ˜¾ç„¶æ ·æœ¬ç©ºé—´æ˜¯æ— é™é›†ï¼Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨å¤å…¸æ¦‚å‹çš„å…¬å¼è¿›è¡Œè®¡ç®—ã€‚å®é™…ä¸Šè¿™ä¸ªé—®é¢˜æœ‰è‡ªå·±çš„å‡ ä½•æ„ä¹‰ï¼šçº¿æ®µä¸€åŠçš„é•¿åº¦ã€‚ è´å¶æ–¯å…¬å¼ æœŸæœ› æˆ‘ä»¬è®¨è®ºçš„å‡æ˜¯ç¦»æ•£å‹éšæœºå˜é‡ã€‚ æ¦‚å¿µ æŠ› 100100100 æ¬¡ç¡¬å¸ï¼ŒæœŸæœ›æœ‰ 505050 æšæœä¸Šã€‚æ•°å­¦æœŸæœ›æŒ‡çš„å°±æ˜¯æ¯æ¬¡å®éªŒä¸­æœŸæœ›çš„ç»“æœã€‚å½¢å¼åŒ–åœ°ï¼Œè‹¥éšæœºå˜é‡ XXX çš„å–å€¼æœ‰ x1â‹¯xnx_1\\cdots x_nx1â€‹â‹¯xnâ€‹ï¼Œé‚£ä¹ˆ E(X)=âˆ‘pixiE(X)=\\sum p_i x_iE(X)=âˆ‘piâ€‹xiâ€‹ï¼Œå‰ææ˜¯è¿™ä¸ªå¼å­ç»å¯¹æ”¶æ•›ã€‚ æœŸæœ›çš„æ€§è´¨ æœŸæœ›æ˜¯ä¸€ä¸ªçº¿æ€§å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´ E(aX+bY)=aÃ—E(X)+bÃ—(Y)E(aX+bY)=a\\times E(X)+b\\times (Y)E(aX+bY)=aÃ—E(X)+bÃ—(Y)ã€‚è¿™ä¸ªä¸œè¥¿å¾ˆæœ‰ç”¨ã€‚æ¯”å¦‚ james1 è¦æŠ›éª°å­ï¼ŒæŠ›ä¸¤ä¸ªå…­é¢éª°å­ï¼Œä¸‰ä¸ªå…«é¢éª°å­ï¼Œé‚£ä¹ˆå…­é¢éª°å­çš„æœŸæœ›æŠ›å‡ºå€¼ä¸º E(X)=3.5E(X)=3.5E(X)=3.5ï¼Œå…«é¢éª°å­çš„æœŸæœ›æŠ›å‡ºå€¼ä¸º E(Y)=4.5E(Y)=4.5E(Y)=4.5ï¼Œé‚£ä¹ˆ E(2X+3Y)=2E(X)+3E(Y)=20.5E(2X+3Y)=2E(X)+3E(Y)=20.5E(2X+3Y)=2E(X)+3E(Y)=20.5ã€‚ æ•°å­¦æœŸæœ› DP æ•°å­¦æœŸæœ›çš„çº¿æ€§æ€§è´¨éå¸¸é‡è¦ï¼Œæ˜¯æˆ‘ä»¬å¯¹å®ƒè¿›è¡Œ DP çš„å‰æã€‚ [Luogu P4316] ç»¿è±†è›™çš„å½’å®¿ Portal.ç»™å‡ºå¼  nnn ä¸ªç‚¹ mmm æ¡è¾¹çš„æœ‰å‘æ— ç¯å›¾ï¼Œèµ·ç‚¹ä¸º 111ï¼Œç»ˆç‚¹ä¸º nnnï¼Œæ¯æ¡è¾¹éƒ½æœ‰ä¸€ä¸ªé•¿åº¦ï¼Œå¹¶ä¸”ä»èµ·ç‚¹å‡ºå‘èƒ½å¤Ÿåˆ°è¾¾æ‰€æœ‰çš„ç‚¹ï¼Œæ‰€æœ‰çš„ç‚¹ä¹Ÿéƒ½èƒ½å¤Ÿåˆ°è¾¾ç»ˆç‚¹ã€‚ç»¿è±†è›™ä»èµ·ç‚¹å‡ºå‘ï¼Œèµ°å‘ç»ˆç‚¹ã€‚ åˆ°è¾¾æ¯ä¸€ä¸ªé¡¶ç‚¹æ—¶ï¼Œå¦‚æœè¯¥èŠ‚ç‚¹æœ‰ kkk æ¡å‡ºè¾¹ï¼Œç»¿è±†è›™å¯ä»¥é€‰æ‹©ä»»æ„ä¸€æ¡è¾¹ç¦»å¼€è¯¥ç‚¹ï¼Œå¹¶ä¸”èµ°å‘æ¯æ¡è¾¹çš„æ¦‚ç‡ä¸º 1k\\frac{1}{k}k1â€‹ ã€‚ç°åœ¨ç»¿è±†è›™æƒ³çŸ¥é“ï¼Œä»èµ·ç‚¹èµ°åˆ°ç»ˆç‚¹çš„æ‰€ç»è¿‡çš„è·¯å¾„æ€»é•¿åº¦æœŸæœ›æ˜¯å¤šå°‘ï¼Ÿ è®¾ f(x)f(x)f(x) è¡¨ç¤ºä» xxx èµ°åˆ°ç»ˆç‚¹çš„è·¯å¾„æœŸæœ›é•¿åº¦ã€‚ç­‰ç­‰ï¼Œä¸ºä»€ä¹ˆä¸æ˜¯ä» 111 åˆ° xxx å‘¢ï¼Ÿæƒ³æƒ³è½¬ç§»çš„æ—¶å€™è¦ä¹˜ä¸Šæ¦‚ç‡ï¼Œå¦‚æœç”¨æ­£çš„çŠ¶æ€å®šä¹‰ï¼Œæˆ‘ä»¬ä¸çŸ¥åˆ°æœ‰å¤šå¤§çš„æ¦‚ç‡èµ°åˆ° xxxï¼Œè¿™æ ·ä¼šä½¿å¾—è®¡ç®—å˜çš„ç›¸å½“å›°éš¾ã€‚é‡‡ç”¨å€’åºçš„è¯ï¼Œå°±ä¸å­˜åœ¨è¿™ç§é—®é¢˜äº†ã€‚äº‹å®ä¸Šï¼Œå¾ˆå¤šæœŸæœ› DP éƒ½æ˜¯å€’åºè¿›è¡Œçš„ã€‚ é‚£ä¹ˆï¼š f(x)=1kâˆ‘i=1k(F[y]+z)f(x)=\\frac{1}{k}\\sum_{i=1}^{k}(F[y]+z) f(x)=k1â€‹i=1âˆ‘kâ€‹(F[y]+z) è¿™æ ·æˆ‘ä»¬å»ºåå›¾ï¼Œåœ¨ä¸Šé¢è¿›è¡Œ DPã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> using namespace std; struct edge &#123; int v, d; edge(int v = 0, int d = 0) : v(v), d(d) &#123;&#125; &#125;; int n, m; int in[100005], deg[100005]; double dis[100005]; vector &lt;edge> G[100005]; queue &lt;int> q; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[v].push_back(edge(u, w)); ++deg[u], ++in[u]; // è¿›å…¥ u çš„åº¦æ•° &#125; q.push(n); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].v, w = G[u][i].d; dis[v] += (dis[u] + w) / deg[v]; --in[v]; if (in[v] == 0) q.push(v); &#125; &#125; printf(\"%.2lf\\n\", dis[1]); return 0; &#125; [Cnoi2020] çº¿æ€§ç”Ÿç‰© Portal.çº¿å½¢ç”Ÿç‰©è¦ä» 111 å·å°é˜¶èµ°åˆ° n+1n+1n+1 å·å°é˜¶ã€‚1,2,3,â€¦,n1,2,3,\\ldots,n1,2,3,â€¦,n å·å°é˜¶éƒ½æœ‰ä¸€æ¡è¿å‘ä¸‹ä¸€å°é˜¶çš„æœ‰å‘è¾¹ iâ†’i+1i\\rightarrow i+1iâ†’i+1ã€‚è¿˜æœ‰ mmm æ¡è¿”ç¥–è¾¹ uiâ†’vi(uiâ‰¥vi)u_i \\rightarrow v_i (u_i \\ge v_i)uiâ€‹â†’viâ€‹(uiâ€‹â‰¥viâ€‹)ï¼Œå®ƒä»¬æ„æˆäº†ä¸€ä¸ªè¿”ç¥–å›¾ã€‚çº¿å½¢ç”Ÿç‰©æ¯æ­¥ä¼š ç­‰æ¦‚ç‡åœ° é€‰å–å½“å‰å°é˜¶çš„ä¸€æ¡å‡ºè¾¹å¹¶èµ°å‘å¯¹åº”çš„å°é˜¶ã€‚å½“èµ°åˆ° n+1n+1n+1 å·å°é˜¶æ—¶ï¼Œçº¿å½¢ç”Ÿç‰©å°±ä¼šåœæ­¢è¡Œèµ°ã€‚æ±‚çº¿æ€§ç”Ÿç‰©æœŸæœ›è¡Œèµ°çš„æ­¥æ•°å€¼ã€‚ è®° E[i]E[i]E[i] ä¸ºä» iâ†’i+1i\\rightarrow i+1iâ†’i+1 çš„æœŸæœ›æ­¥æ•°å€¼ï¼Œé‚£ä¹ˆ Exâ†’y=âˆ‘i=xyâˆ’1E[i]E_{x\\rightarrow y}=\\sum_{i=x}^{y-1}E[i]Exâ†’yâ€‹=âˆ‘i=xyâˆ’1â€‹E[i]ã€‚æˆ‘ä»¬è®° sumxsum_xsumxâ€‹ ä»£è¡¨ âˆ‘i=0xsum[i]\\sum_{i=0}^{x} sum[i]âˆ‘i=0xâ€‹sum[i]ï¼Œduxdu_xduxâ€‹ ä»£è¡¨è¿”ç¥–è¾¹çš„æ•°é‡ã€‚é‚£ä¹ˆæœ‰ï¼ˆç¬¬ä¸€è¡Œä»£è¡¨æ­£å¸¸éœ€è¦ä¸€æ­¥ï¼ŒåŠ ä¸Šè¿”ç¥–è¾¹ï¼‰ï¼š Exâ†’x+1=1+âˆ‘(x,y)âˆˆEEyâ†’x+1dux+1, Exâ†’x+1=dux+1+âˆ‘(x,y)âˆˆEsumxâˆ’1âˆ’sumyâˆ’1dux+1E_{x\\rightarrow x+1}=\\frac{1+\\sum_{(x,y)\\in E} E_{y\\rightarrow x}+1}{du_x+1},\\\\\\ \\\\ E_{x\\rightarrow x+1}=\\frac{du_x+1+\\sum_{(x,y)\\in E} sum_{x-1}-sum_{y-1}}{du_x+1} Exâ†’x+1â€‹=duxâ€‹+11+âˆ‘(x,y)âˆˆEâ€‹Eyâ†’xâ€‹+1â€‹, Exâ†’x+1â€‹=duxâ€‹+1duxâ€‹+1+âˆ‘(x,y)âˆˆEâ€‹sumxâˆ’1â€‹âˆ’sumyâˆ’1â€‹â€‹ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; const int MOD = 998244353; const int MAXN = 1000000; int poww(int x, int y) &#123; int res = 1; while (y) &#123; if (y &amp; 1) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; y >>= 1; &#125; return res; &#125; int id, n, m; int E[MAXN + 5], sum[MAXN + 5]; vector &lt;int> G[MAXN + 5]; int main(void) &#123; scanf(\"%d%d%d\", &amp;id, &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); &#125; for (int x = 1; x &lt;= n; ++x) &#123; E[x] = G[x].size() + 1; for (int y : G[x]) E[x] = ((E[x] + sum[x - 1] - sum[y - 1] + 1) % MOD + MOD) % MOD; E[x] = 1ll * E[x] * poww(G[x].size() + 1, MOD - 2) % MOD; sum[x] = (sum[x - 1] + E[x]) % MOD; &#125; printf(\"%lld\\n\", sum[n]); return 0; &#125; Problemset çº¯æ¦‚ç‡çš„é¢˜ç›®ä¸æ˜¯å¾ˆå¤šï¼Œå¾€å¾€ä¼šä¸å…¶å®ƒç®—æ³•ç»¼åˆã€‚ä½†æ˜¯ä¹Ÿæœ‰ä¸€äº›ç®€å•é¢˜ç›®ï¼š ç®€å•é¢˜ç›® è¿™é‡Œæ˜¯ä¸€äº›æ¦‚ç‡çš„ç®€å•åº”ç”¨ã€‚ [å›½å®¶é›†è®­é˜Ÿ] å•ä½é€‰é”™ Portal. ç­”æ¡ˆæ˜¯ âˆ‘1maxâ¡{aiâˆ’1,ai}\\sum \\frac{1}{\\max\\{a_{i-1},a_{i}\\}}âˆ‘max{aiâˆ’1â€‹,aiâ€‹}1â€‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, A, B, C; int a[10000005]; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;A, &amp;B, &amp;C, a); for (int i = 1; i &lt; n; i++) a[i] = ((long long) a[i - 1] * A + B) % 100000001; for (int i = 0; i &lt; n; i++) a[i] = a[i] % C + 1; double ans = 0; for (int i = 1; i &lt;= n; ++i) ans += 1.0 / max(a[i - 1], a[i % n]); printf(\"%.3lf\\n\", ans); return 0; &#125; [TJOI2015] æ¦‚ç‡è®º Portal. nnn ä¸ªèŠ‚ç‚¹çš„äºŒå‰æ ‘æ•°é‡æ˜¯å¡ç‰¹å…°æ•°ã€‚å°† nnn ä¸ªç‚¹çš„äºŒå‰æ ‘åˆ å»ä¸€ä¸ªå¶å­å¯ä»¥å¾—åˆ° nâˆ’1n-1nâˆ’1 ä¸ªç‚¹çš„äºŒå‰æ ‘ï¼Œé—®é¢˜è½¬åŒ–ä¸ºæœ‰å¤šå°‘ç»„å¯¹åº”ã€‚å¯ä»¥åœ¨ nâˆ’1n-1nâˆ’1 ä¸ªç‚¹çš„äºŒå‰æ ‘ä¸Šæ”¾ç½® nnn ä¸ªå¶å­ï¼Œå› æ­¤ç­”æ¡ˆæ˜¯ nÃ—Cnâˆ’1Cn\\frac{n\\times C_{n-1}}{C_n}Cnâ€‹nÃ—Cnâˆ’1â€‹â€‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int main(void) &#123; double n; cin >> n; printf(\"%.11lf\\n\", n * (n + 1) / (2 * (2 * n - 1))); return 0; &#125; [BJOI2019] å…‰çº¿ Portal. è®¾ pip_ipiâ€‹ ä»£è¡¨ä»ç¬¬ä¸€é¢é•œå­åˆ°ç¬¬ iii é¢é•œå­çš„é€å…‰ç‡ï¼Œqiq_iqiâ€‹ ä»£è¡¨ç¬¬ iii é¢é•œå­å°„å…¥å…‰çº¿æ—¶çš„åå°„ç‡ã€‚é‚£ä¹ˆï¼š pi=piâˆ’1Ã—aiÃ—âˆ‘i=0âˆ(biqiâˆ’1)kqi=bi+qiâˆ’1Ã—ai2Ã—âˆ‘i=0âˆ(biqiâˆ’1)kp_i=p_{i-1}\\times a_i\\times \\sum_{i=0}^{\\infty}(b_iq_{i-1})^k\\\\ q_i=b_i+q_{i-1}\\times a_i^2\\times \\sum_{i=0}^{\\infty}(b_iq_{i-1})^k piâ€‹=piâˆ’1â€‹Ã—aiâ€‹Ã—i=0âˆ‘âˆâ€‹(biâ€‹qiâˆ’1â€‹)kqiâ€‹=biâ€‹+qiâˆ’1â€‹Ã—ai2â€‹Ã—i=0âˆ‘âˆâ€‹(biâ€‹qiâˆ’1â€‹)k æœ‰ âˆ‘i=0âˆxk=11âˆ’x,âˆ£xâˆ£&lt;1\\displaystyle\\sum_{i=0}^{\\infty}x^k = \\frac{1}{1-x},|x|&lt;1i=0âˆ‘âˆâ€‹xk=1âˆ’x1â€‹,âˆ£xâˆ£&lt;1ï¼Œå› æ­¤ä¸Šå¼å¯ä»¥ç›´æ¥è®¡ç®—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; inline int poww(int a, int b) &#123; int r = 1; a %= P; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int main(void) &#123; int i1 = poww(100, P - 2), p = 1, q = 0; int n, a, b; scanf(\"%d\", &amp;n); while (n--) &#123; scanf(\"%d%d\", &amp;a, &amp;b); a = 1ll * a * i1 % P, b = 1ll * b * i1 % P; int w = poww((1 - 1ll * q * b % P + P) % P, P - 2); // é€è¿‡çš„ p = 1ll * p * a % P * w % P; q = (b + 1ll * q * a % P * a % P * w) % P; &#125; printf(\"%d\\n\", p); return 0; &#125; æœŸæœ› ä¸»è¦æ˜¯ä¸€äº›å°æ¦‚å¿µã€‚ [JXOI2018] æ¸¸æˆ Portal. è¦æ±‚çš„æ˜¯æœ€åä¸€ä¸ªå¿…é¡»è‡ªå·±æ£€æŸ¥è‡ªå·±ï¼ˆç§°ä¸ºå…³é”®ç‚¹ï¼‰çš„äººçš„æ•°å­—çš„æœŸæœ›å‡ºç°ä½ç½®ï¼Œè®¾æœ‰ kkk ä¸ªè¿™ç§äººï¼Œé‚£ä¹ˆæœ€åä¸€ä¸ªå…³é”®ç‚¹åé¢çš„äººæ•°æœŸæœ›ä¸º (nâˆ’k)Ã—1k+1(n-k)\\times \\cfrac{1}{k+1}(nâˆ’k)Ã—k+11â€‹ï¼Œä½ç½®è‡ªç„¶å¯ä»¥æ±‚å‡ºï¼šnâˆ’(nâˆ’k)Ã—1k+1=k(n+1)k+1n-(n-k)\\times \\cfrac{1}{k+1}=\\cfrac{k(n+1)}{k+1}nâˆ’(nâˆ’k)Ã—k+11â€‹=k+1k(n+1)â€‹ã€‚ç„¶åä¹˜ä¸Šæ–¹æ¡ˆæ•° n!n!n! å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 1000000007; int l, r, res = 0, ans; bool flag[10000005]; int main(void) &#123; scanf(\"%d%d\", &amp;l, &amp;r); for (int i = l; i &lt;= r; ++i) if (!flag[i]) &#123; ++res; for (int j = i * 2; j &lt;= r; j += i) flag[j] = true; &#125; ans = res; for (int i = 1; i &lt;= r - l + 2; ++i) if (i != res + 1) ans = 1ll * ans * i % MOD; printf(\"%d\\n\", ans); return 0; &#125; æ‹“æ‰‘åºæœŸæœ› DP ä¾ç…§æ‹“æ‰‘åºç›´æ¥åŠ¨æ€è§„åˆ’å³å¯ã€‚åé¢æœ‰äº›é¢˜éš¾åº¦åå¤§ã€‚ [Luogu P1654] OSU! Portal. ä½¿ç”¨å¢é‡æ³•åˆ†æã€‚å½“å¢åŠ ä¸€ä¸ª 111 æ—¶ï¼Œç­”æ¡ˆå˜ä¸º (x+1)3=x3+3x2+3x+1(x+1)^3=x^3+3x^2+3x+1(x+1)3=x3+3x2+3x+1ï¼Œä¹Ÿå°±æ˜¯è¯´ç­”æ¡ˆå¢åŠ äº† 3x2+3x+13x^2+3x+13x2+3x+1ï¼Œé‚£ä¹ˆç»´æŠ¤ x2x^2x2 å’Œ xxx çš„æœŸæœ›å€¼å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; double p, x1[100005], x2[100005], f[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lf\", &amp;p); x1[i] = (x1[i - 1] + 1) * p; x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * p; f[i] = f[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * p; &#125; printf(\"%.1lf\\n\", f[n]); return 0; &#125; [SHOI2014] æ¦‚ç‡å……ç”µå™¨ Portal. æ¢æ ¹ DPã€‚è½¬ç§»æ–¹ç¨‹ï¼šf(x)â†f(y)Ã—f(x)+(1âˆ’f(x))Ã—wf(x)\\leftarrow f(y)\\times f(x)+(1-f(x))\\times wf(x)â†f(y)Ã—f(x)+(1âˆ’f(x))Ã—wã€‚æ¢æ ¹çš„æ—¶ä¾¯ç®—å‡ºä¹‹å‰æ²¡è¢« yyy è´¡çŒ®æ—¶ xxx çš„ç­”æ¡ˆï¼Œæ‹¿è¿™ä¸ªå¯¹ yyy è¿›è¡Œè´¡çŒ®ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cmath> using namespace std; const double eps = 1e-8; int n; double f[500005]; vector&lt;pair&lt;int, double>> G[500005]; void dfs1(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; double w = G[x][i].second; if (y == fa) continue; dfs1(y, x); f[x] += f[y] * (1 - f[x]) * w; &#125; &#125; void dfs2(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; double w = G[x][i].second; if (y == fa) continue; if (fabs(1 - f[y] * w) > eps) &#123; double last = (f[x] - f[y] * w) / (1 - f[y] * w); f[y] += last * (1 - f[y]) * w; &#125; dfs2(y, x); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].emplace_back(make_pair(v, w / 100.0)); G[v].emplace_back(make_pair(u, w / 100.0)); &#125; for (int i = 1, t; i &lt;= n; ++i) scanf(\"%d\", &amp;t), f[i] = t / 100.0; dfs1(1, 0); dfs2(1, 0); double ans = 0; for (int i = 1; i &lt;= n; ++i) ans += f[i]; printf(\"%.6lf\\n\", ans); return 0; &#125; éæ‹“æ‰‘åºæœŸæœ› DP å®é™…æƒ…å†µå¤æ‚å¾—å¤šï¼Œç¡¬è¦è¯´çš„è¯æˆ‘åªè¦çŸ¥é“ç©ºæ°”æµåŠ¨é€Ÿåº¦ã€æŠ›ç¡¬å¸çš„åŠ›çš„å¤§å°æ–¹å‘ã€æ¥è§¦é¢ç§¯ç­‰å†…å®¹ï¼Œä¸€å®šèƒ½è®¡ç®—å‡ºæŠ›ç¡¬å¸çš„ç»“æœã€‚ç”šè‡³è®¡ç®—æœºçš„éšæœºæ•°è®¡ç®—ä¹Ÿæ˜¯æœ‰ä¸€ä¸ªå…¬å¼çš„ï¼ˆæ‰€ä»¥ç”Ÿæˆçš„æ˜¯ä¼ªéšæœºæ•°ï¼‰ã€‚çœŸæ­£çš„éšæœºæ•°è¿˜æœ‰ä¸€äº›ä¼ªéšæœºæ•°ä¸å…·æœ‰çš„æ€§è´¨ï¼Œæ¯”å¦‚ä¸ä¿¡æ¯ç†µç›¸å…³çš„æ€§è´¨ã€‚ â†©ï¸","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¦‚ç‡","slug":"æ¦‚ç‡","permalink":"https://james1badcreeper.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"æœŸæœ›","slug":"æœŸæœ›","permalink":"https://james1badcreeper.github.io/tags/%E6%9C%9F%E6%9C%9B/"}]},{"title":"åŸºç¡€çº¿æ€§ä»£æ•°","slug":"notes/æ•°å­¦/la-basic","date":"2022-08-27T00:00:00.000Z","updated":"2022-08-27T00:00:00.000Z","comments":true,"path":"22ceb96a/","link":"","permalink":"https://james1badcreeper.github.io/22ceb96a/","excerpt":"çº¿æ€§ä»£æ•°æ˜¯ä»£æ•°å­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œä¸»è¦å¤„ç†çº¿æ€§å…³ç³»é—®é¢˜ã€‚OI ä¸­ç”¨åˆ°çš„ç›¸å…³çŸ¥è¯†å¹¶ä¸å¤šï¼Œä¸»è¦æ˜¯çŸ©é˜µä¹˜æ³•ä¸é«˜æ–¯æ¶ˆå…ƒç­‰ï¼Œæœ¬æ–‡å°†ç®€å•ä»‹ç»è¿™äº›å†…å®¹ã€‚","text":"çº¿æ€§ä»£æ•°æ˜¯ä»£æ•°å­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œä¸»è¦å¤„ç†çº¿æ€§å…³ç³»é—®é¢˜ã€‚OI ä¸­ç”¨åˆ°çš„ç›¸å…³çŸ¥è¯†å¹¶ä¸å¤šï¼Œä¸»è¦æ˜¯çŸ©é˜µä¹˜æ³•ä¸é«˜æ–¯æ¶ˆå…ƒç­‰ï¼Œæœ¬æ–‡å°†ç®€å•ä»‹ç»è¿™äº›å†…å®¹ã€‚ çŸ©é˜µä¹˜æ³• ä¸€ä¸ª nÃ—mn\\times mnÃ—m çš„çŸ©é˜µå¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ª nÃ—mn\\times mnÃ—m çš„äºŒç»´æ•°ç»„ã€‚çŸ©é˜µåŠ æ³•å’Œå‡æ³•å°±æ˜¯æŠŠç›¸å¯¹åº”çš„æ•°åŠ å‡ï¼Œè€ŒçŸ©é˜µä¹˜æ³•åˆ™å¾ˆæœ‰æ„æ€ï¼Œæ‹¥æœ‰å‡ ä½•æ„ä¹‰ï¼Œè¿™é‡Œä¸åšå±•å¼€ã€‚ çŸ©é˜µä¹˜æ³• è®¾ AAA æ˜¯ nÃ—mn\\times mnÃ—m çš„çŸ©é˜µï¼ŒBBB æ˜¯ mÃ—pm\\times pmÃ—p çš„çŸ©é˜µï¼Œé‚£ä¹ˆ C=AÃ—BC=A\\times BC=AÃ—B æ˜¯ nÃ—pn\\times pnÃ—p çš„çŸ©é˜µï¼Œå¹¶ä¸”ï¼š Ci,j=âˆ‘k=1Ai,kBk,jC_{i,j}=\\sum_{k=1}A_{i,k}B_{k,j} Ci,jâ€‹=k=1âˆ‘â€‹Ai,kâ€‹Bk,jâ€‹ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š for (int i = 0; i &lt; n; ++i) for (int k = 0; k &lt; n; ++k) &#123; int r = a[i][k]; for (int j = 0; j &lt; n; ++j) c[i][j] += r * b[k][j]; &#125; æ³¨æ„å¾ªç¯é¡ºåºï¼è¿™æ ·çš„é¡ºåºå¯¹ç­”æ¡ˆä¸ä¼šé€ æˆå½±å“ï¼Œä½†æ˜¯ç¼“å­˜è®¿é—®æ˜¯è¿ç»­çš„ï¼Œå› æ­¤è·‘å¾—è¾ƒå¿«ã€‚ çŸ©é˜µå¿«é€Ÿå¹‚ çŸ©é˜µä¹˜æ³•ä¸æ»¡è¶³äº¤æ¢å¾‹ï¼Œä½†æ˜¯æ»¡è¶³ç»“åˆå¾‹ï¼ˆä¹Ÿæ»¡è¶³åˆ†é…å¾‹ï¼‰ï¼Œå› æ­¤å¿«é€Ÿå¹‚çš„è®¡ç®—æ–¹å¼å¯ä»¥ç›´æ¥ç§»ç”¨ã€‚æ³¨æ„çŸ©é˜µä¹˜æ³•æœ‰ä¸€ä¸ªâ€œå•ä½çŸ©é˜µâ€çš„æ¦‚å¿µï¼Œç±»ä¼¼äºæ•°çš„ä¹˜æ³•ä¸­â€œ1â€ã€‚ æ¨¡æ¿ï¼Œä»£ç å…¥ä¸‹ï¼š æŸ¥çœ‹ä»£ç  struct Matrix &#123; int a[105][105]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125;; void reset(void) &#123; // æ„å»ºå•ä½çŸ©é˜µ for (int i = 1; i &lt;= n; ++i) a[i][i] = 1; &#125; &#125;; Matrix operator * (const Matrix &amp;x, const Matrix &amp;y) &#123; Matrix z; for (int i = 1; i &lt;= n; ++i) for (int k = 1; k &lt;= n; ++k) &#123; int r = x.a[i][k]; for (int j = 1; j &lt;= n; ++j) z.a[i][j] = (z.a[i][j] + 1ll * r * y.a[k][j]) % MOD; &#125; return z; &#125; Matrix poww(Matrix a, i64 b) &#123; Matrix res; res.reset(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; çŸ©é˜µä¸é€’æ¨ çŸ©é˜µä¹˜æ³•çš„ä¸€å¤§ä½œç”¨å°±æ˜¯åŠ é€Ÿé€’æ¨ã€‚ æ¦‚è¿° é€’æ¨éƒ½æœ‰ä¸€ä¸ªé€’æ¨å¼å­ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ªå¼å­ä¸­çš„å˜é‡å†™è¿›çŸ©é˜µï¼Œç„¶åå†ä¹˜ä¸Šä¸€ä¸ªçŸ©é˜µè¿›è¡Œå˜æ¢ã€‚ç”±äºé€’æ¨å¼å¿…å˜ï¼Œå› æ­¤æ¯æ¬¡ä¹˜ä¸Šçš„çŸ©é˜µéƒ½æ˜¯ç›¸åŒçš„ï¼Œå¯ä»¥ä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚æ¥è¿›è¡Œè®¡ç®—ã€‚ [Luogu P1962] æ–æ³¢é‚£å¥‘æ•°åˆ— Portal. è¦å°† [Fnâˆ’1Fnâˆ’2]\\begin{bmatrix}F_{n-1}\\\\F_{n-2}\\end{bmatrix}[Fnâˆ’1â€‹Fnâˆ’2â€‹â€‹] å˜æ¢ä¸º [FnFnâˆ’1]\\begin{bmatrix}F_{n}\\\\F_{n-1}\\end{bmatrix}[Fnâ€‹Fnâˆ’1â€‹â€‹]ï¼Œåˆ©ç”¨å¾…å®šç³»æ•°æ³•å¯ä»¥æ±‚å¾—éœ€è¦ä¹˜ä¸Š A=[1110]\\mathbf{A}=\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}A=[11â€‹10â€‹]ï¼Œå³ [FnFnâˆ’1]=[1110][Fnâˆ’1Fnâˆ’2]\\begin{bmatrix}F_{n}\\\\F_{n-1}\\end{bmatrix}=\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}\\begin{bmatrix}F_{n-1}\\\\F_{n-2}\\end{bmatrix}[Fnâ€‹Fnâˆ’1â€‹â€‹]=[11â€‹10â€‹][Fnâˆ’1â€‹Fnâˆ’2â€‹â€‹]ã€‚è¦å¤šæ¬¡å˜æ¢çš„è¯ï¼Œç”±äºçŸ©é˜µä¹˜æ³•æœ‰ç»“åˆå¾‹ï¼Œåˆ©ç”¨çŸ©é˜µå¿«é€Ÿå¹‚å°±å¯ä»¥æå®šï¼Œæœ€ååœ¨ä¹˜ä¸Šåˆå§‹ FFF çŸ©é˜µã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; const int MOD = 1000000007; struct Matrix &#123; int a[3][3]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125;; void reset(void) &#123; for (int i = 1; i &lt;= 2; ++i) a[i][i] = 1; &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 1; i &lt;= 2; ++i) for (int k = 1; k &lt;= 2; ++k) &#123; int r = a.a[i][k]; for (int j = 1; j &lt;= 2; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b .a[k][j]) % MOD; &#125; return c; &#125; &#125;; Matrix poww(Matrix T, i64 b) &#123; Matrix res; res.reset(); while (b) &#123; if (b &amp; 1) res = res * T; T = T * T; b >>= 1; &#125; return res; &#125; int main(void) &#123; i64 n; cin >> n; if (n &lt;= 2) return puts(\"1\"), 0; Matrix a, f; a.a[1][1] = a.a[1][2] = a.a[2][1] = 1; f.a[1][1] = 1; // f è®°å½• F[1], F[0] a = poww(a, n - 1); // ä» n = 2 å˜æ¢ï¼Œæ‰€ä»¥ -1 f = a * f; cout &lt;&lt; f.a[1][1] &lt;&lt; '\\n'; return 0; &#125; [Luogu P1939] ã€æ¨¡æ¿ã€‘çŸ©é˜µåŠ é€Ÿï¼ˆæ•°åˆ—ï¼‰ Portal. æ–¹æ³•æ˜¯ç›¸åŒçš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int MOD = 1000000007; const int N = 3; struct Matrix &#123; int a[4][4]; Matrix(void) &#123; memset(a, 0, sizeof(a)); &#125; void build(void) &#123; for (int i = 1; i &lt;= N; ++i) a[i][i] = 1; &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 1; i &lt;= N; ++i) for (int k = 1; k &lt;= N; ++k) &#123; int r = a.a[i][k]; for (int j = 1; j &lt;= N; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b.a[k][j]) % MOD; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; res.build(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; int n; cin >> n; if (n &lt;= 3) &#123; puts(\"1\"); continue; &#125; Matrix a, f; a.a[1][1] = a.a[1][3] = a.a[2][1] = a.a[3][2] = 1; f.a[1][1] = f.a[2][1] = f.a[3][1] = 1; a = poww(a, n - 3); f = a * f; cout &lt;&lt; f.a[1][1] &lt;&lt; '\\n'; &#125; return 0; &#125; [Luogu P1349] å¹¿ä¹‰æ–æ³¢é‚£å¥‘æ•°åˆ— Portal. åªæ˜¯æˆ‘ä»¬çš„å˜æ¢çŸ©é˜µä¸ä¸€æ ·äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int N = 2; int m; struct Matrix &#123; int a[3][3]; Matrix(void) &#123; memset(a, 0, sizeof(a)); &#125; void build(void) &#123; for (int i = 1; i &lt;= N; ++i) a[i][i] = 1; &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 1; i &lt;= N; ++i) for (int k = 1; k &lt;= N; ++k) &#123; int r = a.a[i][k]; for (int j = 1; j &lt;= N; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b.a[k][j]) % m; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; res.build(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; int main(void) &#123; int p, q, a1, a2, n; cin >> p >> q >> a1 >> a2 >> n >> m; if (n &lt;= 2) return (cout &lt;&lt; (n == 1 ? a1 : a2) &lt;&lt; '\\n', 0); Matrix a, f; a.a[1][1] = p, a.a[1][2] = q, a.a[2][1] = 1; f.a[1][1] = a2, f.a[2][1] = a1; a = poww(a, n - 2); f = a * f; cout &lt;&lt; f.a[1][1] &lt;&lt; '\\n'; return 0; &#125; é«˜æ–¯æ¶ˆå…ƒ ç›¸å…³çŸ¥è¯†ç‚¹ LGV å¼•ç† çŸ©é˜µæ ‘å®šç† BEST å®šç† çº¿æ€§åŸº Problemset ä¸»è¦æ˜¯åº”ç”¨ã€‚ çº¿æ€§ä»£æ•°åŸºç¡€ ä¸€äº›ç®€å•é¢˜ã€‚ç”¨åˆ°äº†æ¦‚å¿µå’ŒçŸ©é˜µä¹˜æ³•ã€‚ [NOI2012] éšæœºæ•°ç”Ÿæˆå™¨ Portal. è¿™æ ·ï¼š [Fnc]=[a101][Fnâˆ’1c]\\begin{bmatrix}F_n\\\\c\\end{bmatrix}=\\begin{bmatrix}a&amp;1\\\\0&amp;1\\end{bmatrix}\\begin{bmatrix}F_{n-1}\\\\c\\end{bmatrix} [Fnâ€‹câ€‹]=[a0â€‹11â€‹][Fnâˆ’1â€‹câ€‹] æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; typedef __int128_t LL; i64 m, a, c, x0, n, g; struct Matrix &#123; i64 a[2][2]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; void build(void) &#123; a[0][0] = a[1][1] = 1; &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 2; ++i) for (int k = 0; k &lt; 2; ++k) &#123; i64 r = a.a[i][k]; for (int j = 0; j &lt; 2; ++j) c.a[i][j] = (c.a[i][j] + (LL)r * b.a[k][j]) % m; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, i64 b) &#123; Matrix res; res.build(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; int main(void) &#123; cin >> m >> a >> c >> x0 >> n >> g; Matrix A, F; A.a[0][0] = a; A.a[0][1] = A.a[1][1] = 1; F.a[0][0] = x0, F.a[1][0] = c; A = poww(A, n); F = A * F; cout &lt;&lt; F.a[0][0] % g &lt;&lt; endl; return 0; &#125; [NOI2013] å‘é‡å†…ç§¯ Portal. å‘ç°æ¨¡æ•°æ˜¯ 222 æˆ– 333ï¼Œå› æ­¤è€ƒè™‘ä¹±æã€‚ ç»´æŠ¤å‘é‡çš„å‰ç¼€å’Œï¼Œè®©ä¸€ä¸ªå‘é‡ä¹˜ä»¥å®ƒå‰é¢çš„å‰ç¼€å’Œå‘é‡ã€‚k=2k=2k=2 æ—¶å¦‚æœä¸ä¸º (iâˆ’1) mod 2(i-1)\\bmod 2(iâˆ’1)mod2 è¯´æ˜æœ‰ä¸€ä¸ªä¹˜ç§¯ä¸º 000ï¼Œæš´åŠ›æ‰¾å³å¯ã€‚ k=3k=3k=3 æ—¶ç»´æŠ¤å‰ç¼€å¹³æ–¹å’Œå¯ä»¥è¾¾åˆ°ä¸€æ ·çš„æ•ˆæœã€‚ éšæœºåŒ–åšå‡ è½®å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, k; int a[100005][105], id[100005], b[105], c[105][105]; mt19937 Rand(time(0)); inline bool check(int x, int y) &#123; int r = 0; for (int i = 1; i &lt;= m; ++i) r += a[x][i] * a[y][i]; return r % k == 0; &#125; inline int calc(int x) &#123; int ans = 0; if (k == 2) &#123; for (int i = 1; i &lt;= m; ++i) &#123; ans = (ans + b[i] * a[x][i]) % k; b[i] = (b[i] + a[x][i]) % k; &#125; &#125; else &#123; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= m; ++j) &#123; ans = (ans + c[i][j] * a[x][i] * a[x][j]) % k; c[i][j] = (c[i][j] + a[x][i] * a[x][j]) % k; &#125; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[i][j]), a[i][j] %= k; for (int i = 1; i &lt;= n; ++i) id[i] = i; for (int T = 1; T &lt;= 7; ++T) &#123; shuffle(id + 1, id + n + 1, Rand); memset(b, 0, sizeof b); memset(c, 0, sizeof c); for (int i = 1; i &lt;= n; ++i) if (calc(id[i]) != (i - 1) % k) // æœ‰è§£ for (int j = 1; j &lt; i; ++j) if (check(id[i], id[j])) &#123; if (id[i] > id[j]) swap(id[i], id[j]); return printf(\"%d %d\\n\", id[i], id[j]), 0; &#125; &#125; puts(\"-1 -1\"); return 0; &#125; é«˜æ–¯æ¶ˆå…ƒ","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"çº¿æ€§ä»£æ•°","slug":"çº¿æ€§ä»£æ•°","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"çŸ©é˜µå¿«é€Ÿå¹‚","slug":"çŸ©é˜µå¿«é€Ÿå¹‚","permalink":"https://james1badcreeper.github.io/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"é«˜æ–¯æ¶ˆå…ƒ","slug":"é«˜æ–¯æ¶ˆå…ƒ","permalink":"https://james1badcreeper.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]},{"title":"NOIP èŒƒå›´å†…è¾ƒéš¾çš„ DP","slug":"notes/DP/noip-dp","date":"2022-08-18T00:00:00.000Z","updated":"2022-08-18T00:00:00.000Z","comments":true,"path":"d52d1ad2/","link":"","permalink":"https://james1badcreeper.github.io/d52d1ad2/","excerpt":"åœ¨ NOIP èŒƒå›´å†…éœ€è¦æŒæ¡çš„è¾ƒéš¾ DP åŒ…æ‹¬ï¼šçŠ¶å‹ DPã€å•è°ƒé˜Ÿåˆ—ä¼˜åŒ– DP å’Œå€å¢ä¼˜åŒ– DPã€‚","text":"åœ¨ NOIP èŒƒå›´å†…éœ€è¦æŒæ¡çš„è¾ƒéš¾ DP åŒ…æ‹¬ï¼šçŠ¶å‹ DPã€å•è°ƒé˜Ÿåˆ—ä¼˜åŒ– DP å’Œå€å¢ä¼˜åŒ– DPã€‚ çŠ¶æ€å‹ç¼© é€šè¿‡å°†çŠ¶æ€åˆ©ç”¨å‹ç¼©ä¸ºæ•´æ•°ï¼Œè¿™æ ·çš„æ“ä½œç§°ä¹‹ä¸ºçŠ¶æ€å‹ç¼©ï¼Œè¿ç”¨åˆ°åŠ¨æ€è§„åˆ’ä¸Šå°±æ˜¯çŠ¶å‹ DPã€‚åœ¨æšä¸¾ä¸­æœ‰ä¸€ç§æ“ä½œå«åšâ€å­é›†æšä¸¾â€œï¼Œå°±æ˜¯æšä¸¾æ•´æ•°ï¼Œç„¶ååˆ©ç”¨ä½è¿ç®—å–å¾—å…¶åœ¨äºŒè¿›åˆ¶ä¸‹çš„æ¯ä¸€ä½ï¼Œç„¶åå°±ç¡®å®šäº†ä¸€ä¸ªå…ƒç´ çš„å­˜åœ¨çŠ¶æ€ã€‚ å¼•å…¥ é¦–å…ˆå…ˆäº†è§£ä¸€äº›å¸¸ç”¨çš„äºŒè¿›åˆ¶è®¡ç®—æ–¹æ³•ï¼š æ„ä¹‰ï¼ˆnnn ä½äºŒè¿›åˆ¶æ„ä¹‰ä¸‹ï¼Œä½æ•°ä»å³èµ·ï¼‰ è¿ç®— è§£é‡Š nnn çš„ç¬¬ kkk ä½ (n &gt;&gt; k) &amp; 1 æ˜¾ç„¶ nnn çš„ç¬¬ kkk ä½å–å n xor (1 &lt;&lt; k) å¼‚æˆ–å¯ä»¥å–å nnn çš„ç¬¬ kkk ä½å˜ 111 n | (1 &lt;&lt; k) æˆ–å¯ä»¥èµ‹å€¼ä¸º 111 nnn çš„ç¬¬ kkk ä½å˜ 000 n &amp; (~(1 &lt;&lt; k)) åˆ›é€ å‡ºä¸€ä¸ªé™¤äº†ç¬¬ kkk ä½éƒ½æ˜¯ 111 çš„ä¸œè¥¿è¿›è¡Œä¸è¿ç®— nnn çš„å kkk ä½ n &amp; ((1 &lt;&lt; k) - 1) åˆ›é€ ä¸€ä¸ªå kkk ä½éƒ½æ˜¯ 111 çš„ä¸œè¥¿è¿›è¡Œä¸è¿ç®— mmm çš„éç©ºå­é›†éå† for (int s = m; s; s = s - 1 &amp; m) å‡å»æœ€å³è¾¹çš„ 111ï¼Œä½†æ˜¯å®ƒè¿˜ä¼šå›æ¥ å°†ç”±é›†åˆæ„æˆçš„çŠ¶æ€é€šè¿‡è¿›åˆ¶è½¬åŒ–ä¸ºæ•´æ•°ï¼Œç§°ä¹‹ä¸ºçŠ¶æ€å‹ç¼©ã€‚æˆ‘ä»¬é€šè¿‡ä¸€é“ç®€å•çš„é¢˜ç›®æ¥å¤§æ¦‚è®¤è¯†è¿™ç©æ„ã€‚ æœ€çŸ­ Hamilton è·¯å¾„ã€‚ å¯¹äºå·²ç»è¯»åˆ°è¿™çš„è¯»è€…æ¥è¯´ï¼Œå¾ˆå®¹æ˜“è®¾è®¡å‡ºçŠ¶æ€ï¼šF(a,i)F({a},i)F(a,i) ä»£è¡¨å·²ç»ç»è¿‡äº† a{a}a ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œç›®å‰å¤„äºç‚¹ iii çš„é•¿åº¦ã€‚è¿™æ ·è¡Œå—ï¼Ÿè¦å°† a{a}a ç”¨ vector è®°å½•ä¸‹æ¥ï¼Œè¿™æ · F å°±æˆäº†ä¸€ä¸ª mapï¼Œæ— æ³•æ¥å—ã€‚ è€ƒè™‘çŠ¶æ€å‹ç¼©ï¼Œæˆ‘ä»¬æä¸€ä¸ªé•¿åº¦ä¸º 202020 çš„ 010101 åºåˆ—ï¼Œ111 ä»£è¡¨ç»è¿‡äº†ï¼Œ000 ä»£è¡¨æ²¡æœ‰ç»è¿‡ã€‚010101 åºåˆ—æ˜¯ä»€ä¹ˆï¼ŸäºŒè¿›åˆ¶ä¸²ï¼äºŒè¿›åˆ¶ä¸²çš„æšä¸¾æ˜¯ä»€ä¹ˆï¼Ÿæšä¸¾æ•´æ•°ï¼ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å®šä¹‰ f(i,j),i&lt;2nf(i,j),i&lt;2^nf(i,j),i&lt;2nï¼Œæ¥è¡¨ç¤ºè·Ÿåˆšæ‰åŒæ ·çš„å†…å®¹ã€‚åˆå§‹æ—¶æ˜¾ç„¶ f(1,0)=0f(1,0)=0f(1,0)=0ï¼Œæœ€ç»ˆç›®æ ‡æ˜¯ f(2nâˆ’1,nâˆ’1)f(2^n-1,n-1)f(2nâˆ’1,nâˆ’1)ï¼ˆnnn ä¸ª 111ï¼Œç»ˆç‚¹ä¸º nâˆ’1n-1nâˆ’1ï¼‰ï¼Œæ¥ä¸‹æ¥è€ƒè™‘å¦‚ä½•è¿›è¡Œè½¬ç§»ã€‚ æœ‰ f(i,j)=minâ¡{f(i xor (1&lt;&lt;j),k)+d(k,j)},(i&gt;&gt;j)&amp;1=1f(i,j)=\\min\\{f(i\\text{ xor } (1 &lt;&lt; j),k)+d(k,j)\\},(i&gt;&gt;j)\\And 1=1f(i,j)=min{f(i xor (1&lt;&lt;j),k)+d(k,j)},(i&gt;&gt;j)&amp;1=1ï¼Œä¹Ÿå°±æ˜¯è¯´å½“ jjj å·²ç»è®¿é—®è¿‡ï¼Œf(i,j)f(i,j)f(i,j) æ‰å¯ä»¥ä» kâ†’jk\\rightarrow jkâ†’j è¿‡æ¥ï¼Œè€Œä¸”çŠ¶æ€é›†åˆä¸­æ²¡æœ‰ jjjã€‚kkk çš„å–å€¼ä»…é™äºåœ¨ i xor (1&lt;&lt;j)i\\text{ xor } (1 &lt;&lt; j)i xor (1&lt;&lt;j) ä¸­æœ‰çš„ã€‚ ä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int MAXN = 1 &lt;&lt; 20; int n; int a[25][25]; int f[MAXN + 5][25]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) scanf(\"%d\", &amp;a[i][j]); memset(f, 0x3f, sizeof(f)); f[1][0] = 0; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) for (int j = 0; j &lt; n; ++j) if ((i >> j) &amp; 1) // i çš„ç¬¬ j ä½æ˜¯ 1ï¼Œè¦å–åä½¿å¾—æ¥çš„çŠ¶æ€çš„ç¬¬ j ä½æ˜¯ 0 for (int k = 0; k &lt; n; ++k) if ((i ^ (1 &lt;&lt; j)) >> k &amp; 1) // i xor (1 &lt;&lt; j) çš„ç¬¬ k ä½æ˜¯ 1 f[i][j] = min(f[i][j], f[i ^ (1 &lt;&lt; j)][k] + a[k][j]); printf(\"%d\\n\", f[(1 &lt;&lt; n) - 1][n - 1]); return 0; &#125; æ³¨æ„åˆ°äº†å—ï¼ŸçŠ¶æ€å‹ç¼©åçš„çŠ¶æ€å†…å®¹æ˜¯åçš„ï¼Œåœ¨äººçœ‹èµ·æ¥æ˜¯åçš„ã€‚æœ€åä¸€ä½ä»£è¡¨äº†ç¬¬ä¸€ä½çš„çŠ¶æ€ã€‚ çŠ¶æ€å‹ç¼©å®ä¾‹ æˆ‘ä»¬æ¥çœ‹æ›´å¤šé—®é¢˜æ¥ç†Ÿç»ƒåº”ç”¨çŠ¶æ€å‹ç¼©ç®—æ³•ã€‚ [Luogu P1171] å”®è´§å‘˜çš„éš¾é¢˜ Portal. è¿™å°±æ˜¯ç»å…¸çš„è´§éƒæ‹…é—®é¢˜ï¼ˆTSPï¼‰ã€‚è®¾ d(i,S)d(i,S)d(i,S) ä»£è¡¨å½“å‰åœ¨åŸå¸‚ iiiï¼Œç»è¿‡çš„åŸå¸‚çŠ¶å‹åä¸º SSS çš„æœ€å°è·ç¦»å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int INF = 0x3f3f3f3f; int n; int d[25][25]; int f[25][(1 &lt;&lt; 20) + 5]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) scanf(\"%d\", &amp;d[i][j]); memset(f, 0x3f, sizeof(f)); f[0][1] = 0; // è¿™é‡Œé‡‡ç”¨äº†åˆ·è¡¨æ³• for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (int j = 0; j &lt; n; ++j) &#123; if (f[j][i] == INF) continue; for (int k = 0; k &lt; n; ++k) if (((i >> k) &amp; 1) == 0) f[k][i | (1 &lt;&lt; k)] = min(f[k][i | (1 &lt;&lt; k)], f[j][i] + d[j][k]); &#125; int ans = INF; for (int i = 0; i &lt; n; ++i) ans = min(ans, f[i][(1 &lt;&lt; n) - 1] + d[i][0]); printf(\"%d\\n\", ans); return 0; &#125; [SCOI2005] äº’ä¸ä¾µçŠ¯ Portal. è®¾ f(i,j,k)f(i,j,k)f(i,j,k) è¡¨ç¤ºè€ƒè™‘å‰ iii è¡Œï¼Œæ”¾äº† jjj ä¸ªå›½ç‹ï¼Œå½“å‰è¡Œçš„çŠ¶æ€å‹ç¼©åä¸º kkkã€‚ç°åœ¨æšä¸¾ä¸Šä¸€è¡Œçš„çŠ¶æ€ lllï¼Œé—®é¢˜å°±æ˜¯åˆ¤æ–­ lll åˆä¸åˆæ³•ã€‚ ä¸éš¾å‘ç°ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸­æˆ‘ä»¬åªéœ€è¦åˆ¤æ–­å½“å‰è¡Œå’Œä¸Šä¸€è¡Œçš„åˆæ³•æƒ…å†µã€‚å¯¹äº kkkï¼Œå¦‚æœå®ƒå­˜åœ¨ç›¸é‚»çš„ä¸¤ä½éƒ½æ˜¯ 111ï¼Œé‚£å°±ä¸è¡Œã€‚æˆ‘ä»¬å¯ä»¥å°†å®ƒå·¦ç§»æˆ–å³ç§»ä¸€ä½ï¼Œè¿™æ ·åœ¨è·ŸåŸæ¥çš„å€¼åšä¸è¿ç®—ï¼Œç»“æœä¸æ˜¯ 000 çš„è¯å°±è¯´æ˜å­˜åœ¨ç›¸é‚»çš„ä¸¤ä½æ•°æ˜¯ 111ã€‚è·Ÿä¸Šä¸€è¡Œåˆ¤æ–­çš„æ—¶å€™ä¹Ÿå¯ä»¥ç”¨ç±»ä¼¼çš„æ–¹æ³•ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int n, K, nn; i64 f[10][85][1030]; int getlen(int x) &#123; int res = 0; while (x) &#123; x -= (x &amp; (-x)); ++res; &#125; return res; &#125; bool check(int x, int y) &#123; if (y &amp; (y >> 1)) return false; // ä¸Šä¸€è¡Œå·¦å³æœ‰äºº if (x &amp; y) return false; // å½“å‰äººçš„å¤´ä¸Šæœ‰äºº if ((x &lt;&lt; 1) &amp; y) return false; // å½“å‰äººçš„å·¦ä¸Šæœ‰äºº if ((x >> 1) &amp; y) return false; // å½“å‰äººçš„å³ä¸Šæœ‰äºº return true; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;K); nn = 1 &lt;&lt; n; f[0][0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= K; ++j) for (int k = 0; k &lt; nn; ++k) &#123; int len = getlen(k); if (len > j) continue; if (k &amp; (k >> 1)) continue; // å·¦å³æœ‰äººï¼Œä¸è¡Œ for (int l = 0; l &lt; nn; ++l) // ä¸Šä¸€è¡Œçš„çŠ¶æ€ if (check(k, l)) f[i][j][k] += f[i - 1][j - len][l]; &#125; i64 ans = 0; for (int i = 0; i &lt; nn; ++i) ans += f[n][K][i]; printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P2622] å…³ç¯é—®é¢˜ II Portal. è®¾ f(i)f(i)f(i) è¡¨ç¤ºå½“å‰æ¯ç›ç¯çš„çŠ¶æ€å‹ç¼©åæœ€å°‘æŒ‰å¤šå°‘æ¬¡æŒ‰é’®ï¼Œè½¬ç§»çš„æ—¶å€™ä½¿ç”¨åˆ·è¡¨æ³•ï¼Œä»å…¨å¼€å¼€å§‹æšä¸¾çŠ¶æ€ï¼Œä¾æ¬¡åŠ¨æ¯ä¸ªå¼€å…³ï¼Œçœ‹å®ƒèƒ½å¤Ÿè½¬ç§»åˆ°å“ªé‡Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int MAXN = (1 &lt;&lt; 10) + 5; int n, nn, m; int a[105][15], f[MAXN]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); nn = 1 &lt;&lt; n; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[i][j]); memset(f, 0x3f, sizeof(f)); f[nn - 1] = 0; for (int i = nn - 1; i >= 0; --i) for (int j = 1; j &lt;= m; ++j) &#123; int now = i; for (int k = 0; k &lt; n; ++k) if (a[j][k + 1] == 1) now &amp;= (~(1 &lt;&lt; k)); else if (a[j][k + 1] == -1) now |= (1 &lt;&lt; k); f[now] = min(f[now], f[i] + 1); &#125; if (f[0] == 0x3f3f3f3f) puts(\"-1\"); else printf(\"%d\\n\", f[0]); return 0; &#125; [USACO06NOV] Corn Fields G Portal. æˆ‘ä»¬å°†æ¯ä¸€è¡Œçš„çŠ¶æ€çŠ¶å‹ï¼Œç„¶åç”¨ç±»ä¼¼äºâ€œäº’ä¸ä¾µçŠ¯â€çš„æ–¹å¼æ¥åˆ¤æ–­è¿™ä¸€è¡Œçš„çŠ¶æ€æ˜¯å¦åˆæ³•ï¼ˆæ˜¯å¦è‡ªå·±è¿ç€æˆ–è€…è·Ÿä¸Šä¸€è¡Œè¿ç€ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 100000000; int n, m; int a[15][15]; int f[15][4100]; bool check(int row, int x) &#123; if (x &amp; (x &lt;&lt; 1)) return false; for (int i = 0; i &lt; m; ++i) if (((x >> i) &amp; 1) == 1 &amp;&amp; !a[row][i]) return false; return true; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; m; ++j) scanf(\"%d\", &amp;a[i][j]); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; (1 &lt;&lt; m); ++j) if (check(i, j)) for (int k = 0; k &lt; (1 &lt;&lt; m); ++k) if ((k &amp; j) == 0) f[i][j] = (f[i][j] + f[i - 1][k]) % MOD; &#125; int ans = 0; for (int i = 0; i &lt; (1 &lt;&lt; m); ++i) ans = (ans + f[n][i]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; æ¥ä¸‹æ¥çš„é¢˜ç›®ä¸å†æ˜¯è›®å¹²äº†ï¼Œè€Œæ˜¯æœ‰ä¸€äº›ç‰¹æ®Šçš„æŠ€å·§ã€‚ æŒ‰ç§©è½¬ç§» | [CF11D] A Simple Task Portal. è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨ç»ˆç‚¹ä¸º jjjï¼Œèµ°è¿‡çš„ç‚¹çŠ¶å‹åä¸º iii çš„æ–¹æ¡ˆæ•°ã€‚è½¬ç§»å‘¢ï¼Ÿä¸å¤ªå¯¹ï¼Œè¿™æ ·ä¸çŸ¥é“å½“å‰ä½ç½®ã€‚æ¢å¥è¯è¯´ï¼ŒçŠ¶æ€å®šä¹‰çš„ä¸å¤Ÿå¥½ï¼Œå¯¼è‡´æ— æ³•è½¬ç§»ã€‚ ä¸‹é¢è¦æ±‚ iii çš„äºŒè¿›åˆ¶ä½ä¸‹ç¬¬ä¸€ä¸ª 111 ä»£è¡¨å½“å‰èµ°åˆ°çš„ä½ç½®ã€‚è¿™æ˜¯ä»€ä¹ˆï¼Ÿlowbitï¼è½¬ç§»çš„æ—¶å€™è¦æ±‚æ·»åŠ çš„ç‚¹åªèƒ½åœ¨ lowbit åé¢ã€‚è¿™æ ·å°±å¾ˆå¥½å†™äº†ã€‚è¿™ç§è€ƒè™‘æŒ‰ç…§é¡ºåºçš„è½¬ç§»è¢«ç§°ä¸ºæŒ‰ç§©è½¬ç§»ã€‚ æ³¨æ„è¿™æ ·ä¼šæŠŠæ¯ä¸€ä¸ªç¯ç®—é‡ä¸¤éï¼Œè€Œä¸”è¿˜ä¼šå‡ºå†™èµ° iâ†’j,jâ†’ii\\rightarrow j,j\\rightarrow iiâ†’j,jâ†’i çš„é”™è¯¯æƒ…å†µï¼Œéœ€è¦å»æ‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, m; i64 f[600000][20]; bool a[20][20]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); --u, --v; a[u][v] = a[v][u] = true; &#125; i64 ans = 0; for (int i = 0; i &lt; n; ++i) f[1 &lt;&lt; i][i] = 1; for (int i = 1; i &lt; (1 &lt;&lt; n); ++i) for (int j = 0; j &lt; n; ++j) &#123; if (!f[i][j]) continue; for (int k = 0; k &lt; n; ++k) &#123; if (!a[j][k]) continue; if ((i &amp; (-i)) > (1 &lt;&lt; k)) continue; if ((1 &lt;&lt; k) &amp; i) &#123; if ((1 &lt;&lt; k) == (i &amp; (-i))) ans += f[i][j]; &#125; else f[i | (1 &lt;&lt; k)][k] += f[i][j]; &#125; &#125; printf(\"%lld\\n\", (ans - m) / 2); return 0; &#125; ä¸‰è¿›åˆ¶çŠ¶æ€å‹ç¼© | [NOI 2001] ç‚®å…µé˜µåœ° Portal. æˆ‘ä»¬å¯ä»¥è¿™æ ·å®šä¹‰ï¼Œ222 è¡¨ç¤ºæ”¾ç½®äº†ç‚®å…µï¼Œ222 ä¸‹é¢å¿…é¡»æ˜¯ 111ï¼Œ111 ä¸‹è¾¹å¿…é¡»æ˜¯ 000ï¼ŒåŒä¸€è¡Œä¸¤ä¸ª 222 é—´éš”ä¸å°äº 333ã€‚ é‚£ä¹ˆï¼š 0 0 0 0 2 0 0 1 0 ä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªçŠ¶æ€ä¸å†ç”± 01 è¡¨ç¤ºï¼Œè€Œæ˜¯ç”± 012 è¡¨ç¤ºï¼Œä¹Ÿå°±æ˜¯ä¸‰è¿›åˆ¶ã€‚ æŠŠæ¯ä¸€è¡Œçš„çŠ¶æ€å‹ç¼©ä¸ºä¸€ä¸ª MMM ä½çš„ä¸‰è¿›åˆ¶æ•°ï¼Œè®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨ç¬¬ iii è¡Œçš„çŠ¶æ€å‹ç¼©åä¸º jjj æ—¶ï¼Œå‰ iii è¡Œæœ€å¤šèƒ½æ”¾ç½®å¤šå°‘åˆæ³•çš„ç‚®å…µã€‚ ä½†å³ä½¿è¿™æ ·ï¼ŒçŠ¶æ€ä¹Ÿå¾ˆå¤æ‚ï¼Œä½¿ç”¨å¡«è¡¨æ³•çš„è¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¼šå¾ˆå¤æ‚ï¼Œæ‰€ä»¥æˆ‘ä»¬é‡‡ç”¨åˆ·è¡¨æ³•ï¼Œåˆ©ç”¨ dfs è¿›è¡Œæ›´æ–°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int P[] = &#123;1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147&#125;; int n, m; char s[105][15]; int f[105][59050]; int v[15]; // æ ‡è®° row å¯ä»¥å¡«ä»€ä¹ˆï¼Œlast ä¸º row - 1 è¡Œçš„çŠ¶æ€ // 0 è¡¨ç¤ºåªèƒ½å¡« 0ï¼Œ1 è¡¨ç¤ºåªèƒ½å¡« 1ï¼Œ2 è¡¨ç¤ºåªèƒ½å¡« 0 æˆ– 2 // ç»“æœè®°å½•åœ¨ v æ•°ç»„ä¸­ inline void mark(int row, int last) &#123; for (int i = 0; i &lt; m; ++i, last /= 3) &#123; if (last % 3 == 2) v[i] = 1; else if (last % 3 == 1) v[i] = 0; else if (s[row][i] == 'H') v[i] = 0; else v[i] = 2; &#125; &#125; // ç¬¬ row è¡Œçš„çŠ¶æ€ä¸º lastï¼Œå¡«ç¬¬ row + 1 è¡Œï¼Œæ‰«æåˆ°ç¬¬ col åˆ—ï¼Œcnt ä¸ºå¡«çš„ç‚®å…µæ•°ï¼Œnow ä¸ºç¬¬ row + 1 è¡ŒçŠ¶æ€ void dfs(int row, int col, int last, int now, int cnt) &#123; if (col == m) // 0 ~ m-1 éƒ½å¡«å®Œäº† &#123; f[row + 1][now] = max(f[row + 1][now], f[row][last] + cnt); return; &#125; if (v[col] == 2 || v[col] == 0) dfs(row, col + 1, last, now, cnt); // é€‰æ‹©å¡« 0ï¼Œnow æ²¡æœ‰å˜åŒ– if (v[col] == 1) dfs(row, col + 1, last, now + P[col], cnt); // å¡«äº† 1ï¼Œnow çš„ç¬¬ col - 1 ä½åŠ ä¸Š P[col - 1] if (v[col] == 2) &#123; int v1 = v[col + 1], v2 = v[col + 2]; // å³èµ·ä¸¤ä¸ªä¸èƒ½æ”¾ if (v[col + 1] == 2) v[col + 1] = 0; if (v[col + 2] == 2) v[col + 2] = 0; dfs(row, col + 1, last, now + 2 * P[col], cnt + 1); // å¡«äº† 2ï¼Œnow çš„ç¬¬ col - 1 ä½åŠ ä¸Š 2 * P[col - 1] v[col + 1] = v1, v[col + 2] = v2; // è¿˜åŸ &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", s[i]); memset(f, 0xff, sizeof f); f[0][0] = 0; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; P[m]; ++j) &#123; if (f[i][j] == -1) continue; mark(i + 1, j); // æ ‡è®° dfs ä¸­ row + 1 çš„å¯å¡«çŠ¶æ€ dfs(i, 0, j, 0, 0); &#125; int ans = 0; for (int i = 0; i &lt; P[m]; ++i) ans = max(ans, f[n][i]); printf(\"%d\\n\", ans); return 0; &#125; è¿™é“é¢˜ä¹Ÿå¯ä»¥ä½¿ç”¨äºŒè¿›åˆ¶çŠ¶æ€å‹ç¼©æ¥åšï¼Œä¸è¿‡ç›¸å½“éº»çƒ¦ã€‚è¿˜å¯ä»¥ä½¿ç”¨è½®å»“çº¿åŠ¨æ€è§„åˆ’ã€‚è½®å»“çº¿ DPï¼ˆåˆç§°æ’å¤´ DPï¼‰æ˜¯çŠ¶å‹ DP çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ï¼Œæˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„æ‰€æœ‰çŠ¶å‹ DP éƒ½æ˜¯ä»¥â€œæ ¼å­â€ä½œä¸ºçŠ¶æ€çš„ï¼Œä½†æœ‰çš„æ—¶å€™å›¾å½¢å¾ˆå¤æ‚ï¼Œéœ€è¦ä»¥å›¾å½¢çš„è½®å»“ä½œä¸ºçŠ¶æ€ã€‚è¿™ç§ DP å°†åœ¨ç¬”è€…åç»­çš„æ–‡ç« ä¸­è®ºè¿°ã€‚ å­é›†å’Œ DPï¼ˆsosDPï¼‰ sosDPï¼ŒæŒ‡çš„æ˜¯ Sum over Substes DPï¼Œç”¨æ¥è§£å†³å­é›†ç±»çš„æ±‚å’Œé—®é¢˜ï¼ˆä¹Ÿèƒ½è§£å†³é«˜ç»´ç©ºé—´çš„æ±‚å’Œé—®é¢˜ï¼Œä½†æ˜¯æ—¶ç©ºå¾€å¾€ä¸å…è®¸ï¼‰ã€‚ é«˜ç»´å‰ç¼€å’Œ sosDP çš„æœ€é‡è¦åº”ç”¨ä¾¿æ˜¯å®ç°é«˜ç»´å‰ç¼€å’Œã€‚ ç»™å®šä¸€ä¸ªå« 2n2^n2n ä¸ªæ•´æ•°çš„é›†åˆ AAAï¼Œæˆ‘ä»¬éœ€è¦æ±‚å‡ºæ¯ä¸€ä¸ªå­é›†å’Œï¼Œæ±‚å‡ºå‰ç¼€å’Œã€‚å³å­é›†å’Œä¸º sis_isiâ€‹ï¼Œé‚£ä¹ˆå‰ç¼€å’Œ fi=âˆ‘jâŠ†isjf_i=\\sum_{j\\subseteq i}s_jfiâ€‹=âˆ‘jâŠ†iâ€‹sjâ€‹ã€‚ è¿™ä¸ªé—®é¢˜å¯ä»¥ç›´æ¥ä½¿ç”¨ sosDP æ¥æ±‚è§£ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nÃ—2n)O(n\\times 2^n)O(nÃ—2n)ã€‚ for (int j = 0; j &lt; n; ++j) for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) if ((i >> j) &amp; 1) f[i] += f[i ^ (1 &lt;&lt; j)]; è¿™æ˜¯ä»€ä¹ˆï¼Ÿè¿˜è®°å¾— DP å¯¹å‰ç¼€å’Œçš„é€’æ¨å—ï¼Ÿè¿™é‡Œæ˜¯ä¸€æ ·çš„é“ç†ã€‚æ³¨æ„åˆ° jjj åœ¨å¤–å±‚ï¼Œå¦‚æœç¬¬ jjj ä½ï¼ˆä»£è¡¨ç»´åº¦ï¼‰æ˜¯ 111ï¼Œé‚£ä¹ˆå°±å°†å‰ç¼€å’Œè½¬ç§»è¿‡æ¥ã€‚ [ARC100E] Or Plus Max Portal.ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º 2n2^n2n çš„åºåˆ— aaaï¼Œæ¯ä¸ª1â‰¤Kâ‰¤2nâˆ’11\\le K\\le 2^n-11â‰¤Kâ‰¤2nâˆ’1ï¼Œæ‰¾å‡ºæœ€å¤§çš„ ai+aja_i+a_jaiâ€‹+ajâ€‹ï¼ˆiorjâ‰¤Ki \\mathbin{\\mathrm{or}} j \\le Kiorjâ‰¤Kï¼Œ0â‰¤i&lt;j&lt;2n0 \\le i &lt; j &lt; 2^n0â‰¤i&lt;j&lt;2nï¼‰å¹¶è¾“å‡ºã€‚or\\mathbin{\\mathrm{or}}or è¡¨ç¤ºæŒ‰ä½æˆ–è¿ç®—ã€‚gg è®°å¾—å—ï¼Ÿå‰ç¼€å’Œå¯ä»¥åšåŒºé—´å’Œï¼Œè¿˜å¯ä»¥åšå‰ç¼€æœ€å¤§å€¼ã€‚è€Œç°åœ¨æ˜¯ä¸¤ä¸ªæœ€å¤§å€¼ç›¸åŠ ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç”¨é«˜ç»´å‰ç¼€å’Œå¤„ç†æœ€å¤§å€¼å’Œæ¬¡å¤§å€¼å³å¯ã€‚ æ³¨æ„åˆ°è¿™é‡Œä¸æ˜¯å­é›†ï¼Œè€Œæ˜¯æœ€é«˜ä½ï¼Œå› æ­¤è¿˜éœ€è¦å¯¹é«˜ç»´å‰ç¼€å’Œæ•°ç»„å–æœ€å¤§å€¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; int n, nn; struct Node &#123; int max1, max2; Node(int max1 = -INF, int max2 = -INF) : max1(max1), max2(max2) &#123;&#125; Node operator + (const Node &amp;x) &#123; Node y; if (max1 > x.max1) &#123; y.max1 = max1; y.max2 = max(max2, x.max1); &#125; else &#123; y.max1 = x.max1; y.max2 = max(max1, x.max2); &#125; return y; &#125; &#125; a[300000]; int main(void) &#123; scanf(\"%d\", &amp;n); nn = 1 &lt;&lt; n; for (int i = 0; i &lt; nn; ++i) scanf(\"%d\", &amp;a[i].max1); for (int j = 0; j &lt; n; ++j) for (int i = 0; i &lt; nn; ++i) if ((i >> j) &amp; 1) a[i] = a[i] + a[i ^ (1 &lt;&lt; j)]; int ans = 0; for (int i = 1; i &lt; nn; ++i) &#123; ans = max(ans, a[i].max1 + a[i].max2); printf(\"%d\\n\", ans); &#125; return 0; &#125; å•è°ƒé˜Ÿåˆ— è¿˜è®°å¾—â€œé™åˆ¶é•¿åº¦çš„æœ€å¤§å­æ®µå’Œâ€å—ï¼Ÿé‚£å°±æ˜¯ä¸€ä¸ªç»å…¸çš„å•è°ƒé˜Ÿåˆ—ä¼˜åŒ– DPã€‚ å•è°ƒé˜Ÿåˆ—å¯ä»¥ç»´æŠ¤å†³ç­–å–å€¼èŒƒå›´ä¸Šä¸‹å˜åŒ–ï¼ˆé˜Ÿé¦–é˜Ÿå°¾å‡å¯ä»¥å¼¹å‡ºï¼‰ï¼Œè€Œä¸”æ¯ä¸ªå†³ç­–åœ¨å€™é€‰é›†åˆä¸­è‡³å¤šæ’å…¥æˆ–åˆ é™¤ä¸€æ¬¡ã€‚ ç®€å•é—®é¢˜ è¿™é‡Œçš„é—®é¢˜æ¯”è¾ƒç®€å•ã€‚ [Luogu P1725] çªéœ²è¯º Portal. å‡ ä¹å°±æ˜¯æ¨¡æ¿ã€‚è®¾ f(i)f(i)f(i) ä¸ºåˆ° iii çš„æœ€å¤§åˆ†æ•°ï¼Œè½¬ç§»çš„æ—¶å€™ç›´æ¥ä»å•è°ƒé˜Ÿåˆ—é‡Œè·å–ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, l, r; int a[200005], f[200005]; int L = 1, R = 0, q[200005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;l, &amp;r); for (int i = 0; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0xbf, sizeof(f)); f[0] = a[0]; int ans = -1e9; for (int i = l; i &lt;= n; ++i) &#123; while (L &lt;= R &amp;&amp; f[q[R]] &lt;= f[i - l]) --R; while (L &lt;= R &amp;&amp; q[L] + r &lt; i) ++L; q[++R] = i - l; f[i] = f[q[L]] + a[i]; if (i + r > n) ans = max(ans, f[i]); &#125; printf(\"%d\\n\", ans); return 0; &#125; [NOIP2017 æ™®åŠç»„] è·³æˆ¿å­ Portal. è€ƒè™‘äºŒåˆ†ç­”æ¡ˆï¼Œåˆ¤å®šçš„æ—¶å€™ä½¿ç”¨å•è°ƒé˜Ÿåˆ—ä¼˜åŒ– DP æ±‚å‡ºæœ€å¤§åˆ†æ•°å³å¯ã€‚ é—®é¢˜æ˜¯ï¼Œå¦‚ä½•å…¥é˜Ÿï¼Ÿä½¿ç”¨ä¸€ä¸ªæŒ‡é’ˆï¼Œåœ¨æ‰«æåˆ°ä¸€ä¸ªæ–°çš„ä½ç½®æ—¶å¼€å§‹åˆ¤æ–­å®ƒä¹‹å‰çš„æ˜¯å¦å¯è¡Œï¼Œå°±æ˜¯ä¸€ä¸ªæ»‘åŠ¨çª—å£çš„è¿‡ç¨‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; const i64 INF = 1e18; int n, d, k; int x[500005], s[500005]; i64 f[500005]; // è€ƒè™‘åˆ°ç¬¬ i ä¸ªä½ç½®çš„æœ€å¤§å¾—åˆ† int Q[500005]; bool P(int g) &#123; int l = (d > g ? d - g : 1), r = d + g; int L = 1, R = 0, j = 0; i64 ans = -INF; memset(f, 0xbf, sizeof(f)); memset(Q, 0, sizeof(Q)); f[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (j &lt; i &amp;&amp; x[i] - x[j] >= l) &#123; if (f[j] > -INF) &#123; while (L &lt;= R &amp;&amp; f[Q[R]] &lt;= f[j]) --R; Q[++R] = j; &#125; ++j; &#125; while (L &lt;= R &amp;&amp; x[i] - x[Q[L]] > r) ++L; if (L &lt;= R) f[i] = f[Q[L]] + s[i]; ans = max(ans, f[i]); &#125; return ans >= k; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;d, &amp;k); i64 sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", x + i, s + i); if (s[i] > 0) sum += s[i]; &#125; if (sum &lt; k) return puts(\"-1\"), 0; int L = 0, R = 1000000001; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) R = mid; else L = mid; &#125; printf(\"%d\\n\", R); return 0; &#125; [USACO11OPEN] Mowing the Lawn G Portal.Farmer John çš„è‰åªéå¸¸è„ä¹±ï¼Œå› æ­¤ï¼ŒFarmer John åªèƒ½å¤Ÿè®©ä»–çš„å¥¶ç‰›æ¥å®Œæˆè¿™é¡¹å·¥ä½œã€‚Farmer John æœ‰ NNNï¼ˆ1â‰¤Nâ‰¤1051\\le N\\le 10^51â‰¤Nâ‰¤105ï¼‰åªæ’æˆä¸€æ’çš„å¥¶ç‰›ï¼Œç¼–å·ä¸º 1â€¦N1\\ldots N1â€¦Nã€‚æ¯åªå¥¶ç‰›çš„æ•ˆç‡æ˜¯ä¸åŒçš„ï¼Œå¥¶ç‰› iii çš„æ•ˆç‡ä¸º EiE_iEiâ€‹ï¼ˆ0â‰¤Eiâ‰¤1090\\le E_i\\le 10^90â‰¤Eiâ€‹â‰¤109ï¼‰ã€‚é è¿‘çš„å¥¶ç‰›ä»¬å¾ˆç†Ÿæ‚‰ï¼Œå› æ­¤ï¼Œå¦‚æœ Farmer Johnå®‰æ’è¶…è¿‡ KKK åªè¿ç»­çš„å¥¶ç‰›ï¼Œé‚£ä¹ˆï¼Œè¿™äº›å¥¶ç‰›å°±ä¼šç½¢å·¥å»å¼€æ´¾å¯¹ :)ã€‚å› æ­¤ï¼Œç°åœ¨ Farmer John éœ€è¦ä½ çš„å¸®åŠ©ï¼Œè®¡ç®— FJ å¯ä»¥å¾—åˆ°çš„æœ€å¤§æ•ˆç‡ï¼Œå¹¶ä¸”è¯¥æ–¹æ¡ˆä¸­æ²¡æœ‰è¿ç»­çš„è¶…è¿‡ KKK åªå¥¶ç‰›ã€‚ è®¾ f(i,0)f(i,0)f(i,0) è¡¨ç¤ºä¸å–ç¬¬ iii å¤´å¥¶ç‰›çš„æœ€å¤§æ•ˆç‡ï¼Œf(i,1)f(i,1)f(i,1) åˆ™å–ï¼Œé‚£ä¹ˆï¼š f(i,0)=maxâ¡{f(iâˆ’1,0),f(iâˆ’1,1)}f(i,1)=maxâ¡j=iâˆ’k+1i{f(j,0)+âˆ‘l=jie[l]}f(i,0)=\\max\\{f(i-1,0),f(i-1,1)\\}\\\\ f(i,1)=\\max_{j=i-k+1}^{i}\\left\\{f(j,0)+\\sum_{l=j}^{i}e[l]\\right\\} f(i,0)=max{f(iâˆ’1,0),f(iâˆ’1,1)}f(i,1)=j=iâˆ’k+1maxiâ€‹â©â¨â§â€‹f(j,0)+l=jâˆ‘iâ€‹e[l]â­â¬â«â€‹ ç¬¬äºŒä¸ªå¼å­å¯ä»¥ä½¿ç”¨å‰ç¼€å’Œå˜å½¢å¹¶æ‹†å¼€ï¼š f(i,1)=maxâ¡j=iâˆ’k+1i{f(j,0)âˆ’s[j]}+s[i]f(i,1)=\\max_{j=i-k+1}^{i}\\left\\{f(j,0)-s[j]\\right\\}+s[i] f(i,1)=j=iâˆ’k+1maxiâ€‹{f(j,0)âˆ’s[j]}+s[i] max ä¸­çš„å†…å®¹ä¾¿å¯ä»¥ä½¿ç”¨å•è°ƒé˜Ÿåˆ—æ¥ç»´æŠ¤ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, k; int a[100005]; int Q[100005], L = 1, R = 0; i64 s[100005], f[100005][2]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); Q[++R] = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); s[i] = s[i - 1] + a[i]; f[i][0] = max(f[i - 1][0], f[i - 1][1]); while (L &lt;= R &amp;&amp; i - Q[L] > k) ++L; f[i][1] = f[Q[L]][0] + s[i] - s[Q[L]]; while (L &lt;= R &amp;&amp; f[i][0] - s[i] > f[Q[R]][0] - s[Q[R]]) --R; Q[++R] = i; &#125; printf(\"%lld\\n\", max(f[n][0], f[n][1])); return 0; &#125; å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–å¤šé‡èƒŒåŒ… Problemset æœ‰äº›é¢˜éœ€è¦ç‰¹å®šçš„æ¨¡å‹ï¼Œè¯·å‚è€ƒã€ŠåŠ¨æ€è§„åˆ’çš„çŠ¶æ€è®¾è®¡ã€‹ã€‚ çŠ¶æ€å‹ç¼© DP è¿™é‡Œçš„é¢˜ä¸ä¼šå¾ˆéš¾ã€‚ [CF8C] Looking for Order Portal. ä¸€æ¬¡æœ€å¤šåªèƒ½æ‹¿ä¸¤ä¸ªç‰©å“ï¼Œé‚£ä¹ˆè½¬ç§»çš„æ—¶å€™ä½¿ç”¨ä¸¤ä¸ª for å¾ªç¯ã€‚è®° f(i)f(i)f(i) ä»£è¡¨æ‹¿å–å¾—ç‰©å“çŠ¶æ€å‹ç¼©åçš„æœ€å°ä»£ä»·ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥è½¬ç§»ã€‚ä½†æ˜¯è¿™æ ·çš„å¤æ‚åº¦è¿‡é«˜ï¼Œå®é™…ä¸Šå¾ˆå¤šç‰©å“çš„è½¬ç§»éƒ½æ˜¯äº’ä¸å¹²æ‰°çš„ï¼Œåªè¦ç¬¬ä¸€ä¸ªç‰©å“ç¡®å®šäº†ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„å°±å¯ä»¥ç›´æ¥ break æ‰äº†ã€‚ æœ¬é¢˜éœ€è¦æ‰“å°è§£ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨æ›´æ–°çš„æ—¶å€™çœ‹ä¸€ä¸‹è¿™ä¸ªçŠ¶æ€ä»å“ªé‡Œæ¥çš„å°±å¯ä»¥äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int MAXN = (1 &lt;&lt; 24); const int INF = 0x3f3f3f3f; int n, m; int x[30], y[30]; int f[MAXN + 5], pre[MAXN + 5]; inline int dis(int p, int q) &#123; int a = x[p] - x[q], b = y[p] - y[q]; return a * a + b * b; &#125; int main(void) &#123; scanf(\"%d%d%d\", x, y, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", x + i, y + i); memset(f, 0x3f, sizeof(f)); f[0] = 0; for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) &#123; if (f[i] == INF) continue; for (int j = 0; j &lt; n; ++j) &#123; if (i &amp; (1 &lt;&lt; j)) continue; for (int k = 0; k &lt; n; ++k) &#123; if (i &amp; (1 &lt;&lt; k)) continue; int dp = (i | (1 &lt;&lt; j) | (1 &lt;&lt; k)); int cost = f[i] + dis(0, j + 1) + dis(j + 1, k + 1) + dis(k + 1, 0); if (f[dp] > cost) &#123; f[dp] = cost; pre[dp] = i; &#125; &#125; break; // æ¥ä¸‹æ¥çš„ç¬¬ j ä¸ªç‰©å“ä¼šæœ‰å…¶å®ƒçš„ i æ¥è´Ÿè´£ &#125; &#125; printf(\"%d\\n\", f[(1 &lt;&lt; n) - 1]); int now = (1 &lt;&lt; n) - 1; while (now) &#123; printf(\"0 \"); int update = (now ^ pre[now]); for (int i = 0; i &lt; n; ++i) if (update &amp; (1 &lt;&lt; i)) printf(\"%d \", i + 1); now = pre[now]; &#125; puts(\"0\"); return 0; &#125; [Luogu P3694] é‚¦é‚¦çš„å¤§åˆå”±ç«™é˜Ÿ Portal. ç±»ä¼¼äºä¸Šä¸€é¢˜ï¼Œè®¾ f(i)f(i)f(i) è¡¨ç¤ºå½“å‰ MMM ä¸ªé˜Ÿä¼å®Œæˆç«™é˜Ÿçš„æƒ…å†µï¼Œå®Œæˆè®°ä¸º 111ï¼Œæœªå®Œæˆè®°ä¸º 000ï¼ŒçŠ¶æ€å‹ç¼©åçš„ç»“æœã€‚è½¬ç§»æ—¶é‡‡ç”¨å¡«è¡¨æ³•ï¼Œä»…å½“ iii çš„ç¬¬ jjj ä½æ˜¯ 111 æ—¶è½¬ç§»ï¼š f(i)=minâ¡{f(i xor (1&lt;&lt;j)+cnt[j]âˆ’sum(x,y))}f(i)=\\min\\{f(i \\text{ xor } (1&lt;&lt;j)+cnt[j]-sum(x,y))\\} f(i)=min{f(i xor (1&lt;&lt;j)+cnt[j]âˆ’sum(x,y))} å…¶ä¸­ cnt[j]cnt[j]cnt[j] ä»£è¡¨ jjj è¿™ä¸ªä¹é˜Ÿçš„äººæ•°ï¼Œå½“ä¸­æœ‰ sum(x,y)sum(x,y)sum(x,y) ä¸ªæ˜¯ä¸éœ€è¦é‡æ–°å®‰æ’çš„ã€‚sumsumsum çš„å…·ä½“æ±‚æ³•è§ä»£ç ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int MM = (1 &lt;&lt; 20) + 5; int n, m, mm; int a[100005], cnt[100005]; int sum[100005][20]; int f[MM]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); mm = 1 &lt;&lt; m; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); --a[i]; // å°†å®ƒä¿®æ”¹ä¸ºä» 0 å¼€å§‹ç¼–å·çš„ ++cnt[a[i]]; for (int j = 0; j &lt; m; ++j) sum[i][j] = sum[i - 1][j]; // å°†å‰ç¼€å’Œç§»è¿‡æ¥ ++sum[i][a[i]]; // ä¿®æ”¹å½“å‰ i çš„å‰ç¼€å’Œ &#125; memset(f, 0x3f, sizeof(f)); f[0] = 0; for (int i = 1; i &lt; mm; ++i) &#123; int len = 0; // è®°å½•éœ€è¦å®‰æ’çš„äººæ•° for (int j = 0; j &lt; m; ++j) if (i &amp; (1 &lt;&lt; j)) len += cnt[j]; for (int j = 0; j &lt; m; ++j) if (i &amp; (1 &lt;&lt; j)) f[i] = min(f[i], f[i ^ (1 &lt;&lt; j)] + cnt[j] - (sum[len][j] - sum[len - cnt[j]][j])); // sum[len][j] ä»£è¡¨åœ¨é•¿åº¦ä¸º n ä¸­åºåˆ—çš„å‰ len ä½ï¼Œä¹Ÿå°±æ˜¯å®‰æ’äº†çš„äººæ•°ä½ï¼Œè¿™æ · j çš„äººæ•° // å‡å» sum[len-cnt[j]][j]ï¼Œç»™è¿™äº›äººç•™å‡º cnt[j] ä¸ªä½ç½®ã€‚è¿™æ · j çš„äººæ•° &#125; printf(\"%d\\n\", f[mm - 1]); return 0; &#125; [UVA10817] Headmasterâ€™s Headache Portal. è®¾ f(i,s0,s1,s2)f(i,s_0,s_1,s_2)f(i,s0â€‹,s1â€‹,s2â€‹) ä»£è¡¨æ‰«æåˆ°ç¬¬ iii ä¸ªäººï¼Œæ²¡æœ‰äººæ•™çš„è¯¾ç¨‹ã€ä¸€ä¸ªäººæ•™å’Œä¸¤ä¸ªäººæ•™çš„è¯¾ç¨‹çŠ¶å‹ååˆ†åˆ«æ˜¯ s0,s1,s2s_0,s_1,s_2s0â€‹,s1â€‹,s2â€‹ï¼Œå®ç°é‡‡ç”¨è®°å¿†åŒ–æœç´¢ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;sstream> #include &lt;string> #include &lt;cstring> using namespace std; const int INF = 1e9; int S, m, n; int c[125], s[125], f[125][300][300]; int dp(int i, int s0, int s1, int s2) &#123; if (i == m + n) return s2 == (1 &lt;&lt; S) - 1 ? 0 : INF; if (f[i][s1][s2] != -1) return f[i][s1][s2]; int &amp;ans = f[i][s1][s2]; ans = INF; if (i >= m) ans = dp(i + 1, s0, s1, s2); int m0 = s[i] &amp; s0, m1 = s[i] &amp; s1; s0 ^= m0; s1 = (s1 ^ m1) | m0; s2 |= m1; return ans = min(ans, dp(i + 1, s0, s1, s2) + c[i]); &#125; int main(void) &#123; while (cin >> S >> m >> n &amp;&amp; S) &#123; memset(s, 0, sizeof(s)); string st; getline(cin, st); for (int i = 0; i &lt; m + n; ++i) &#123; getline(cin, st); stringstream ss(st); ss >> c[i]; int x; while (ss >> x) s[i] |= (1 &lt;&lt; (x - 1)); &#125; memset(f, -1, sizeof(f)); cout &lt;&lt; dp(0, (1 &lt;&lt; S) - 1, 0, 0) &lt;&lt; '\\n'; &#125; return 0; &#125; å•è°ƒé˜Ÿåˆ— DP è¿™é‡Œçš„å•è°ƒé˜Ÿåˆ—å¯èƒ½ä¼šéš¾ä¸€ç‚¹ã€‚ [NOI2005] ç‘°ä¸½åå°”å…¹ Portal. è®¾ f(k,i,j)f(k,i,j)f(k,i,j) ä»£è¡¨è€ƒè™‘åˆ°ç¬¬ kkk ä¸ªæ—¶é—´æ®µï¼Œé’¢ç´ä½ç½®åœ¨ (i,j)(i,j)(i,j) çš„æœ€å¤§æ»‘åŠ¨æ—¶é—´ã€‚æ¯ä¸€ä¸ªæ—¶é—´æ®µæˆ‘ä»¬éƒ½è¦æšä¸¾èµ·ç‚¹è¿›è¡Œ DPï¼Œè½¬ç§»çš„è¿‡ç¨‹ä¸­å¯ä»¥ä½¿ç”¨æ»‘åŠ¨çª—å£å¯»æ‰¾æœ€å¤§å€¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #define rep(t) for (int i = 1; i &lt;= t; ++i) using namespace std; const int dx[] = &#123;0, -1, 1, 0, 0&#125;, dy[] = &#123;0, 0, 0, -1, 1&#125;; int n, m, sx, sy, k; int f[205][205]; char s[205][205]; pair&lt;int, int> Q[205]; int L, R; void work(int x, int y, int len, int d) &#123; L = 1, R = 0; for (int i = 1; x >= 1 &amp;&amp; x &lt;= n &amp;&amp; y >= 1 &amp;&amp; y &lt;= m; ++i, x += dx[d], y += dy[d]) &#123; if (s[x][y] == 'x') &#123; L = 1, R = 0; continue; &#125; while (L &lt;= R &amp;&amp; Q[R].first + i - Q[R].second &lt; f[x][y]) --R; while (L &lt;= R &amp;&amp; i - Q[L].second > len) ++L; Q[++R] = make_pair(f[x][y], i); f[x][y] = Q[L].first + i - Q[L].second; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;sx, &amp;sy, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", s[i] + 1); memset(f, 0xbf, sizeof(f)); f[sx][sy] = 0; while (k--) &#123; int s, t, d; scanf(\"%d%d%d\", &amp;s, &amp;t, &amp;d); int len = t - s + 1; if (d == 1) rep(m) work(n, i, len, d); else if (d == 2) rep(m) work(1, i, len, d); else if (d == 3) rep(n) work(i, m, len, d); else if (d == 4) rep(n) work(i, 1, len, d); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) ans = max(ans, f[i][j]); printf(\"%d\\n\", ans); return 0; &#125; [SCOI2010] è‚¡ç¥¨äº¤æ˜“ Portal. f(i,j)f(i,j)f(i,j) ä»£è¡¨ç¬¬ iii å¤©æ‰‹é‡Œæœ‰ jjj è‚¡çš„ä»·å€¼ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥ä¹°ï¼Œæˆ–æ˜¯ä»å‰ä¸€å¤©è½¬ç§»è¿‡æ¥ï¼Œæˆ–æ˜¯ä» iâˆ’wâˆ’1i-w-1iâˆ’wâˆ’1 å¤©è¿›è¡Œä¹°å–ã€‚æœ€åä¸€ç§è½¬ç§»çš„ä¹°çš„æƒ…å†µçš„æ–¹ç¨‹å¦‚ä¸‹ï¼š f(i,j)=maxâ¡{f(iâˆ’wâˆ’1,k)âˆ’apÃ—j+apÃ—kâˆ£jâˆ’asâ‰¤kâ‰¤j}f(i,j)=\\max\\{f(i-w-1,k)-ap\\times j + ap\\times k\\mid j-as\\le k\\le j\\} f(i,j)=max{f(iâˆ’wâˆ’1,k)âˆ’apÃ—j+apÃ—kâˆ£jâˆ’asâ‰¤kâ‰¤j} è¿™ä¸ªå¼å­ä¸€çœ‹å°±å¾ˆå•è°ƒé˜Ÿåˆ—ï¼Œå› ä¸ºç›¸å½“äºæ‰¾ apÃ—kap\\times kapÃ—k çš„æœ€å¤§å€¼ï¼Œç›´æ¥ç”¨å•è°ƒé˜Ÿåˆ—ç»´æŠ¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, maxP, w; int f[2005][2005]; // åœ¨ç¬¬ i å¤©æ—¶ï¼Œæ‰‹ä¸­æŒæœ‰ j è‚¡ï¼Œæœ€å¤šçš„é’± int Q[2005], L = 1, R = 0; void ckmax(int &amp;f, int a) &#123; if (f &lt; a) f = a; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;maxP, &amp;w); memset(f, 0xbf, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; int ap, bp, as, bs; scanf(\"%d%d%d%d\", &amp;ap, &amp;bp, &amp;as, &amp;bs); for (int j = 0; j &lt;= maxP; ++j) f[i][j] = f[i - 1][j]; for (int j = 0; j &lt;= as; ++j) ckmax(f[i][j], -j * ap); L = 1, R = 0; if (i - w &lt;= 1) continue; for (int j = 0; j &lt;= maxP; ++j) &#123; // f[i][j] &lt;- f[i - w - 1][k]ï¼Œä¹°å…¥ while (L &lt;= R &amp;&amp; Q[L] &lt; j - as) ++L; while (L &lt;= R &amp;&amp; f[i - w - 1][Q[R]] + Q[R] * ap &lt;= f[i - w - 1][j] + j * ap) --R; Q[++R] = j; ckmax(f[i][j], f[i - w - 1][Q[L]] - ap * (j - Q[L])); &#125; L = 1, R = 0; for (int j = maxP; j >= 0; --j) &#123; // f[i][j] &lt;- f[i - w - 1][k]ï¼Œå–å‡º while (L &lt;= R &amp;&amp; Q[L] > j + bs) ++L; while (L &lt;= R &amp;&amp; f[i - w - 1][Q[R]] + Q[R] * bp &lt;= f[i - w - 1][j] + j * bp) --R; Q[++R] = j; ckmax(f[i][j], f[i - w - 1][Q[L]] + bp * (Q[L] - j)); &#125; &#125; printf(\"%d\\n\", f[n][0]); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"çŠ¶å‹ DP","slug":"çŠ¶å‹-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%8A%B6%E5%8E%8B-DP/"},{"name":"å•è°ƒé˜Ÿåˆ—","slug":"å•è°ƒé˜Ÿåˆ—","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"CSP-S & NOIP 2022 æ¸¸è®°","slug":"summaries/æ¸¸è®°/CSP2022","date":"2022-08-05T00:00:00.000Z","updated":"2022-08-05T00:00:00.000Z","comments":false,"path":"acb544c/","link":"","permalink":"https://james1badcreeper.github.io/acb544c/","excerpt":"æœ¬æ–‡ä¸º james1 CSP-S 2022 çš„è®°å½•ï¼ˆåŒæ—¶æŠŠ NOIP ä¸€èµ·å†™æ‰äº†ï¼‰ï¼Œå¤§å®¶å¿«æ¥çœ‹è¿™ä¸ªæ°´æµ¸è’Ÿè’»æ˜¯æ€ä¹ˆçˆ†é›¶çš„å§ï¼","text":"æœ¬æ–‡ä¸º james1 CSP-S 2022 çš„è®°å½•ï¼ˆåŒæ—¶æŠŠ NOIP ä¸€èµ·å†™æ‰äº†ï¼‰ï¼Œå¤§å®¶å¿«æ¥çœ‹è¿™ä¸ªæ°´æµ¸è’Ÿè’»æ˜¯æ€ä¹ˆçˆ†é›¶çš„å§ï¼ æš‘å‡ ä¸­è€ƒä¹‹åçš„æ•…äº‹ã€‚ 8.5 å¼€å‘äº†æ–‡ç« ã€‚è¿™æ˜¯æ´›è°· NOIP è®¡åˆ’çš„ç¬¬ä¸‰å‘¨ï¼Œå­¦ä¹ å›¾è®ºã€‚åˆšäº¤å®Œä¸€é“ MST çš„é¢˜ç›®ã€‚è¦æ±‚è‡ªå·±åšå®šæ„å¿—ï¼Œé’¢é“æ´ªæµå‘å‰è¿›ï¼ è¿™æ¬¡ï¼Œæˆ‘ä¸€å®šè¦æ‹¿åˆ° 300 åˆ†ã€‚ 8.14 NOIP è®¡åˆ’çš„ç¬¬å››åœºæ¨¡æ‹Ÿèµ›ï¼ŒæŒ‚äº† 100100100 åˆ†ï¼š å…¨æ˜¯ T1 æŒ‚çš„ï¼› æ­£è§£æƒ³åˆ°äº†ï¼Œä½†æ˜¯æ•°ç»„å¼€å°äº†ï¼› ä¸ä¼šè¯æ˜æ­£è§£ï¼Œäºæ˜¯è¿˜å†™äº†ä¸ªæš´åŠ›ä¸Šå»ï¼› ä½†æ˜¯æˆ‘çš„æ­£è§£æ˜¯å€’ç€è¾“å…¥çš„ï¼Œè€Œæš´åŠ›æ˜¯æ­£çš„ï¼› æˆ‘æ²¡æœ‰å°†ä¸¤ä¸ªè¾“å…¥åˆ†å¼€ï¼› äºæ˜¯æš´åŠ› WA äº†ï¼Œæ­£è§£ RE äº†ï¼› 265â†’165265 \\rightarrow 165265â†’165ï¼Œrk3 â†’\\rightarrowâ†’ rk32ã€‚ æˆ‘æ˜¯åºŸç‰©ã€‚ 8.20 è¢« Summer Pockets åˆ€äº†ï¼ˆè‹çº¿ï¼‰ï¼Œé’»çŸ³ç²’ä¹Ÿæ‰›ä¸ä½å•Šï¼Œè¢«åˆ€å“­äº†â€¦â€¦ ä¸ºä»€ä¹ˆæœ«æ—¥æ—¶ï¼ˆå·ä¸‰å’Œå·äº”ï¼‰å’Œæœ«æ—¥å†ï¼ˆå·åä¸€ï¼‰éƒ½æ˜¯åˆ€ï¼Œé­”ç¦æ—§çº¦ï¼ˆå·äºŒåäºŒï¼‰ä¹Ÿæ˜¯åˆ€ï¼ˆè™½ç„¶åé¢å›æ¥äº†ï¼‰ï¼Œç„¶åè¿™ä¸ªä¹Ÿæ˜¯åˆ€å•Šâ€¦â€¦ æˆ–è€…è¯´æˆ‘çœ‹çš„æ‰€æœ‰ä¸œè¥¿éƒ½æ˜¯åˆ€ï¼ˆå¯èƒ½æ˜¯å› ä¸ºä½œä¸ºæå€¡è€…çš„å®Œç¾ä¸»ä¹‰å‹æ ¹æ¥å—ä¸äº†åˆ€ï¼‰ï¼Œæˆ–è€…åªæ˜¯å› ä¸ºè¿™æ˜¯æˆ‘ç¬¬ä¸€æ¬¡ç© Galgameï¼Œä½†æ˜¯å¾ˆå¯èƒ½æ²¡æœ‰ç¬¬äºŒæ¬¡äº†ï¼ˆå› ä¸ºå…´è¶£ä¸åœ¨æ­¤ï¼‰ã€‚ 8.21 æ—©ä¸Šå¾—çŸ¥æœ‰ç–«æƒ…ï¼Œå†›è®­å»¶æœŸäº†â€¦â€¦ å…¶å®ä¸æ˜¯å¾ˆå¼€å¿ƒï¼ˆæˆ‘å»¿å››çš„å†›è®­æ€èƒ½ä¸å‚åŠ é™¤éæˆ‘è¿›äº† E ç±»çœé˜Ÿï¼Ÿå†å»¶å°±çœŸçš„æ²¡äº†ï¼‰â€¦â€¦ ä¸‹åˆ NOIp è®¡åˆ’ç¬¬äº”åœºæ¨¡æ‹Ÿèµ›ï¼Œè¢«æ‰“å‚»äº†ï¼š T1 å°±æ˜¯ä¸ª Div.4 Aï¼Œæ°´è¿‡å»äº†ï¼› T2 æ„Ÿè§‰æ­£è§£æ˜¯æœç´¢+å¼ºåŠ›çš„å‰ªæï¼Œä½†æ˜¯æš´åŠ›çš„æœç´¢éƒ½é”™äº†ï¼ŒæŒ‚äº† 50 åˆ†ï¼› T3 å†™äº†ä¸€ä¸ªå¥‡æ€ªçš„å‰ªæï¼Œæ„Ÿè§‰èƒ½å¾— 60ï¼Œä¸è¿‡å¤šéª—äº† 10 åˆ†å˜æˆäº† 70ï¼› T4 ä¸ä¼šï¼Œå†™äºŒç»´å‰ç¼€å’Œå¾—äº† 50ã€‚ ä¸ºä»€ä¹ˆè¿™äº›æ¯”èµ›çš„éƒ¨åˆ†åˆ†éƒ½è¿™ä¹ˆæ°´å•Šqaqã€‚ç°åœ¨çš„æ¯”èµ›è·Ÿä»¥å‰ä¸ä¸€æ ·äº†å•Šï¼Œä»¥å‰æé«˜ç»„ä¸€é“é¢˜ä¹±å†™éƒ½èƒ½ 80+ï¼Œç°åœ¨éª—åˆ†åº”è¯¥éƒ½ä¸å®¹æ˜“å•Šã€‚ æœ€åæ€»åˆ†æ˜¯ 220220220ï¼Œrk18ã€‚é€€æ­¥äº†ï¼Œä¸Šä¸€åœºä¸æŒ‚åˆ†æœ‰ rk3ï¼Œè¿™æ¬¡å³ä½¿ä¸æŒ‚åˆ†ä¹Ÿåªæœ‰ rk11ã€‚ è®²è¯„çš„æ—¶å€™è€å¸ˆæŒ‡ç€æˆ‘å’Œå…¶å®ƒå‡ ä¸ªäººçš„ T2 çš„é›¶åˆ†ï¼šè¿™å‡ ä¸ªäººçˆ†é›¶äº†æˆ‘ä¹Ÿä¸å¤ªæ¸…æ¥šæ€ä¹ˆå›äº‹â€¦â€¦ å…¬ å¼€ å¤„ åˆ‘ï¼Œæœ‰æ—¶é—´çš„è¯å»å¤ä¹ ä¸€ä¸‹å¤æ‚æœç´¢å§â€¦â€¦ Extraï¼šT2 æ˜¯ DPï¼Œæˆ‘æ˜¯å‚»å­ã€‚ ä¸è¿‡æ—¢ç„¶éƒ½ç–«æƒ…äº†ï¼Œå°±å»å¤šå­¦ç‚¹é«˜çº§çŸ¥è¯†å§ï¼ˆé¢˜åˆ·åäº†ï¼‰ï¼ 8.22 åŸå®šæ˜¯è¿™å¤©åšæ ¸é…¸æ£€æµ‹ï¼Œä½†æ˜¯è¢«å–æ¶ˆäº†ã€‚ çŒœå¯¹äº†ï¼Œè¿™å‘¨å­¦ä¹ æ•°è®ºã€‚ 8.26 è¿™ä¸€æ®µå†™äº 1:24 AMã€‚ ç¬¬äºŒé˜¶æ®µè¿›è¡Œçš„ä¸æ˜¯å¾ˆé¡ºåˆ©ï¼Œä½†æ˜¯ç¥è´ºå­¦é•¿ @wind_whisper ä»¥ 450 åˆ†çš„å¥½æˆç»©å¤ºå¾— NOI AUï¼Œrk 14ã€‚%%% è¿™ä¸€æ®µå†™äº 6:05 PMã€‚ æ¥è‡ªæ´›è°· NOIP è®¡åˆ’ç¾¤ ä¾¦æµ‹åˆ°åœ¨é€”çš„ 3k æ‰“å‡»ã€‚ 8.28 NOIp è®¡åˆ’ç¬¬å…­åœºæ¨¡æ‹Ÿèµ›ï¼Œè¢«å–€ç§‹èç‚¸æ­»äº†ã€‚ rk41ï¼Œåªæœ‰ 40 åˆ†ï¼Œrk1 çš„åˆ†æ•°æ˜¯æˆ‘çš„äº”å€orzã€‚ T2 å¿˜äº†åˆ æ‰è°ƒè¯•ä»£ç ï¼ŒæŒ‚äº† 40ï¼› T2 ç»†èŠ‚å®ç°åˆå‡ºäº†ä¸€äº›é—®é¢˜ï¼Œå†æŒ‚ 40ï¼› T3 æœ€å°ç“¶é¢ˆç”Ÿæˆæ ‘çœ‹æˆæœ€å°ç”Ÿæˆæ ‘äº†ï¼ŒæŒ‚äº† 40ï¼› æˆ‘æ˜¯ç¯ã€‚ èˆµæ‰‹ï¼Œæ˜¯ä¸ä»–çš„æˆ˜èˆ°å…±å­˜äº¡çš„ã€‚ 8.30 å¼€å­¦ï¼Œä½†æ˜¯ä¸Šç½‘è¯¾å‰çš„æœ€åæ—¥å­ï¼ ç¨å¾®å†™äº†ç‚¹æ–‡åŒ–è¯¾ï¼Œä½†æ˜¯å‘ç°å…¨éƒ½ä¸ä¼šã€‚ å¤ªèœäº†ï¼Œæ‰€ä»¥æ‹¼å§ã€‚ 8.31 å·²ç»å¼€å§‹ç•™ä½œä¸šäº†ï¼Œä¹Ÿå°±æ„å‘³ç€è¿™ä¸€æ®µçš„å®Œç»“ã€‚ ã€Šè“è‰²è®¡åˆ’ã€‹PART-B éœ€è¦å¼€å¯ã€‚ ç½‘è¯¾ è™½ç„¶æ˜¯ç½‘è¯¾ï¼Œä½†ä¹Ÿæ˜¯å¼€å­¦äº†ã€‚ é’¢é“æ´ªæµå‘å‰è¿›ï¼ 9.2 å­¦æ ¡çš„ç¬¬ä¸€åœºæ¨¡æ‹Ÿèµ›ï¼Œæ’ååœ¨åä¸€å°åŠã€‚èœæ˜¯æ ¹æœ¬ï¼ŒAB ä¸¤é“æ•°å­¦é¢˜ï¼Œè¿™ä¸¤å‘¨å­¦ä»€ä¹ˆäº†ï¼Ÿè€Œä¸” C ä¸ºä»€ä¹ˆæŒ‚äº† 75 åˆ†ï¼ŸçŸ¥é“æ•°æ®ä¸å¯èƒ½å¾ˆå¼ºï¼ŒSPFA æ”¹ä¼˜å…ˆé˜Ÿåˆ—è‚¯å®šèƒ½æ°´ä¸å°‘åˆ†ï¼Œä½†æ˜¯å†™æŒ‚äº†ï¼Ÿè€Œä¸”æ˜æ˜çŸ¥é“æ­£è§£è¦ç¼©ç‚¹ï¼Œä½†æ˜¯ä¸€ç›´æ²¡æœ‰å­¦æœ‰å‘å›¾çš„è¿é€šæ€§é—®é¢˜ï¼Ÿ 9.4 NOIP è®¡åˆ’çš„ç¬¬ä¸ƒåœºæ¨¡æ‹Ÿèµ›ã€‚ 2:00 å¼€è€ƒï¼ŒD é¢˜æ˜¯ Summer Pockets å¥½è¯„ï¼ˆä½†æ˜¯ä¸ºä»€ä¹ˆ CYJian çš„èƒŒæ™¯æ˜¯äŒ·å•Šï¼‰ã€‚ ä½†æ˜¯æˆ‘çš„è¯­æ–‡ä½œä¸šè¿˜æ²¡æœ‰å†™å®Œï¼Œæ‰“äº†å¤§æ¦‚åŠä¸ªå°æ—¶æµ‘èº«éš¾å—ï¼Œè„‘å­ä¸è½¬ï¼Œè¯»é”™äº†ä¸¤æ¬¡ T1ï¼Œè¿˜åªä¼šæœ€æš´åŠ›çš„å†™æ³•ï¼Œæ‰€ä»¥å…ˆå»å†™ä½œä¸šäº†ã€‚ åˆšä¸Šé«˜ä¸­ä¸ä¼šç­”é¢˜ï¼Œå…ˆè¯»äº†ä¸€éã€Šä¸€æœ¬æ¶‚ä¹¦ã€‹çš„å¯¹åº”ç« èŠ‚ï¼Œç„¶ååˆå»åšä½œä¸šï¼Œå†™å®Œå¿«ä¸‰ç‚¹åŠäº†ã€‚ å¤§æ¦‚ç”¨ 30min è¿‡æ‰äº† T1ï¼Œæš´åŠ›è®¡æ•°ç¢¾è¿‡å»å³å¯ï¼Œä½†æ˜¯äºŒåˆ†å’Œå¿«é€Ÿå¹‚éƒ½éœ€è¦é¢„å¤„ç†ï¼Œä¸€å¼€å§‹è¿˜è‡ªä¿¡åœ°è®¤ä¸º O(n2logâ¡n)O(n^2 \\log n)O(n2logn) èƒ½è¿‡ 500050005000ï¼Œå‘ç°å¹¶ä¸èƒ½ï¼ˆæ²¡å¼€ O2 è€Œä¸”å¸¸æ•°å¾ˆå¤§ï¼‰ã€‚ ç„¶åçœ‹äº†ä¸€ä¸‹ T2ï¼Œçœ‹ä¸æ‡‚ã€‚ äºæ˜¯å»çœ‹ç›´æ¥è¢«æ ‡é¢˜å¸å¼•çš„ T4ï¼Œä½†æ˜¯ä¸ä¼šï¼Œè€Œä¸”å¥½åƒè¯»çš„é¢˜è¿˜æ˜¯é”™çš„ã€‚ å»çœ‹ T3ï¼Œæ„Ÿè§‰æš´åŠ›å¾ˆå¥½å†™ï¼Œä½†æ˜¯å†™å®Œæœ‰ bugï¼Œè°ƒäº†å¤§åŠä¸ªå°æ—¶æ²¡è°ƒå‡ºæ¥ï¼ŒåŸåœ°è‡ªé—­ã€‚ ç»™ T4 å†™äº†ä¸€ä¸ª puts(&quot;0&quot;)ï¼Œå¹¶å†™ä¸Šäº†æˆ‘æ°¸è¿œå–œæ¬¢ç©ºé—¨è‹ã€‚ äºæ˜¯æœ€ç»ˆ 100+0+30+20=150100+0+30+20=150100+0+30+20=150ï¼Œrk12ï¼ˆå®é™…ä¸Šæ²¡æœ‰ï¼Œå› ä¸ºå¤§ç¥ä»¬éƒ½æ²¡æœ‰æ—¶é—´æ‰“ï¼‰ï¼Œä¸ºä»€ä¹ˆ T3 è¿˜æœ‰ 303030 åˆ†å•Šï¼Œä»¥ä¸º 606060 åˆ†çš„åšæ³•è¦å˜æˆ 000 äº†ã€‚ ç„¶åçœ‹äº†ä¸€ä¸‹ç¾¤ï¼Œé‚£ä¸ª 606060 åˆ†çš„ T3 åšæ³•å®é™…ä¸Šå› ä¸ºæ•°æ®ä¸å¤Ÿå¼ºæœ‰ 808080 åˆ†ï¼ˆæˆ‘å¤ªèœäº†ï¼‰ã€‚ rk1 çš„åˆ†æ•°æ˜¯æˆ‘çš„ä¸¤å€ï¼Œorzã€‚ 9.5 è¿™å‘¨å­¦ä¹ æ ‘ï¼Œæœ€åä¸€å‘¨å­¦ä¹ å†…å®¹äº†ã€‚ CCF å–œæ¬¢æ¤æ ‘é€ æ—ï¼Œè€Œä¸”è¿™æ˜¯ç”Ÿæ€ç¯ä¿ï¼Œæ‰€ä»¥éœ€è¦è®¤çœŸå­¦ä¹ ã€‚ 9.6 æ¥è‡ª NOIP è®¡åˆ’ç¾¤ æ¯’ç˜¤ä¸Šçº¿äº† å­¦ä¹ çœŸçš„æ˜¯æ€ä¹ˆéƒ½èƒ½å­¦ï¼Œå…è´¹çš„èµ„æ–™éƒ½æœ‰ä¸å°‘ï¼Œå…³é”®çœ‹æ€ä¹ˆæ¨ï¼Œæˆ–è€…è¯´æ€ä¹ˆåšæŒä¸‹æ¥ï¼Œè€Œä¸”è¿˜è¦ä¿æŒä¸€å®šçš„é€Ÿåº¦ï¼Œæˆ˜äº‰æœºå™¨ä¸èƒ½ç†„ç«ã€‚ 9.7 æˆ‘çœŸçš„æ²¡æœ‰æƒ³åˆ°æˆ‘ä¼šæ¯å¤©éƒ½åœ¨è¿™é‡Œå†™å­—ã€‚ å­¦ä¸ä¼š Splayã€‚ 9.8 åˆ—äº†è®¡åˆ’æ¸…å•ï¼Œå…ˆæ•´æ•°å­¦å’Œæ ‘ä¸Šé—®é¢˜ï¼Œæ•°æ®ç»“æ„å…ˆä¸¢æ‰ã€‚ Unleashed. 9.9 è¿™ä¸€æ®µå†™äº 0:06 AMï¼š å…¶å®å­¦èµ·æ¥çœŸçš„å¾ˆçˆ½ï¼ŒåšæŒå§ã€‚ å¦å¤–æ¥åˆ°äº†æ¶ˆæ¯ï¼Œåˆèµ›è¦åœ¨è‡ªå·±å®¶é‡Œè€ƒï¼ˆå› ä¸ºç–«æƒ…ï¼‰ï¼Œè¿™â€¦â€¦ å¤§æ¦‚åœ¨åŠå¤œæ´›è°· AC 800ï¼ŒNOIP å‰å¿…é¡» AC 1kã€‚ 9.10 æœ¬æ¥æ‰“ç®—å»æ‰“ pjudge çš„ï¼Œä½†æ˜¯åˆå»æ‰“æ´›è°·æœˆèµ›äº†ã€‚ è¢«æ´›è°·æœˆèµ›çˆ†æ€ï¼Œå±…ç„¶è¿˜çœ‹é”™é¢˜äº†ã€‚ 9.11 å­¦æ ¡çš„ç¬¬äºŒåœºæ¨¡æ‹Ÿèµ›ï¼ˆè·Ÿä¸Šå‘¨çš„é‚£åœºä¸æ˜¯ä¸€ä¸ªåœ°æ–¹çš„ï¼Œè¿™å›æ˜¯å…«æ ¡è”è€ƒï¼‰ï¼Œåˆ†æ•°ä¸åˆ°ä¸‰ä½æ•°ï¼Œä½†æ˜¯é¢˜çš„è´¨é‡è¿˜æ˜¯çœŸçš„ä¸é”™çš„ï¼ˆå¤§æ¦‚è´¨é‡ç›¸å½“äº NOIP è®¡åˆ’æœ€å¥½çš„ä¸€åœºï¼Œå°±æ˜¯ç¬¬å…­ä¸ƒåœºï¼‰ã€‚ ç¨å¾®åšä¸€ç‚¹æ–‡åŒ–è¯¾å’Œ CFï¼Œæ˜å¤© lxl åœºï¼Œã€Šæœ€éš¾çš„çº¿æ®µæ ‘ã€‹è¦å‡ºç°äº†ã€‚ å†™äºåŠå¤œï¼š æœ€è¿‘å¯èƒ½ä¼šæ¯”è¾ƒç´¯ï¼Œä½†æ˜¯ä¸ç®¡æ€ä¹ˆè¯´ï¼Œä¸€å®šè¦åšæŒä¸‹æ¥ã€‚å…»æˆåšæŒçš„ä¹ æƒ¯æœ¬èº«ä¹Ÿæ˜¯ä¸€ç§ä¹ æƒ¯ã€‚çœŸæ­£çš„å¤§ boss è¿˜æ²¡æœ‰æ¥å‘¢ã€‚ æ•™ç»ƒçš„è¯ï¼Œå®³æ€• 9.12 å†™äº 0:04 AMï¼š ä¸ºä»€ä¹ˆæˆ‘ç°åœ¨è¿˜åœ¨å†™è¯­æ–‡ä½œä¸šâ€¦â€¦ æ˜å¤©æ—©ä¸Šå®šçš„ 6:00 çš„é—¹é’Ÿå†™ä½œä¸šï¼Œ8:00 å­¦æ ¡æ¨¡æ‹Ÿèµ›ï¼Œä¸‹åˆ NOIP è®¡åˆ’æ¨¡æ‹Ÿèµ›ï¼Œç„¶åè¿˜å¾—å‡†å¤‡è¯ºæ›¼åº•ç™»é™†çš„æ¼”è®²ï¼ˆä¸è¦é—®æˆ‘ä¸ºä»€ä¹ˆè¦å‡†å¤‡è¿™ä¸ªç©æ„ï¼Œåæ­£å°±æ˜¯è¦è®²ï¼‰ï¼Œç„¶åè¿˜å¾—å¤ä¹ æ–‡åŒ–è¯¾ï¼Œå¢è¡¥éƒ¨åˆ†å­¦ä¹ ç¬”è®°ï¼Œçˆ†åˆ· CFâ€¦â€¦ åŠ æ²¹å•Šï¼ è“è‰²è®¡åˆ’2.0 alpha PART A-III ä¸Šåˆå­¦æ ¡çš„ç¬¬ä¸‰åœºæ¨¡æ‹Ÿèµ›ï¼ŒçœŸÂ·è¢«çˆ†æ€ã€‚ ä¸‹åˆ NOIP è®¡åˆ’ç¬¬å…«åœºï¼Œæ¯”ä¸Šåˆç®€å•ï¼Œä½†è¿˜æ˜¯ä¸ç†æƒ³ï¼ŒT2 å’Œ T3 å•¥éƒ½ä¸ä¼šã€‚ æ„Ÿè§‰æœ€è¿‘çŠ¶æ€ä¸å¤ªå¥½å•Šï¼Œè«éæ˜¯ç¡å¾—å¤ªå°‘äº†ï¼Ÿå¿…é¡»èµ¶ç´§è°ƒæ•´å›æ¥ï¼ ä½ æ€ä¹ˆç¡å¾—ç€çš„ï¼Ÿä½ è¿™ä¸ªé˜¶æ®µç¡å¾—ç€çš„ï¼Ÿæˆ‘å°±æ„Ÿè§‰åŒªå¤·æ‰€æ€å•Šï¼ 9.13 åˆ·ï¼Œå­¦ï¼Œæ€ã€‚ 3k è¯´ AT çš„ Retomejudge å¿«ä¿®å¥½äº†ï¼ŒæœŸå¾…ã€‚ å†™äº 9:25 PM: å­¦æ ¡å¼€å§‹é›†è®­äº†ï¼Œä¸è¿‡æ˜¯çº¿ä¸Šã€‚ è¢«åˆä¸€é“ julian å‘äº† 90ptsã€‚ â€œé¼ â€å¼å¦å…‹ 9.15 çœŸçš„ï¼Œæ´»è¶Šæ¥è¶Šå¤šã€‚ åˆèµ› ä»¥ Day1 ä»£è¡¨ 9.18 æ—¥ã€‚ Day -2 9.16ã€‚ ä¸»è¦è¿˜æ˜¯å­¦ä¹ ä¸€äº›æ–‡åŒ–è¯¾ï¼Œå†™ä½œä¸šï¼Œè¡¥ NOIP è®¡åˆ’é¢˜å•ã€‚ åˆèµ›ä»€ä¹ˆä¸æ‹…å¿ƒçš„ï¼Œè¾½å®çœè¿™è¾¹åªè¦ä¸ä½œå¼Šå°±è‚¯å®šèƒ½è¿‡ã€‚å› ä¸ºæ˜¯çº¿ä¸Šè€ƒï¼Œæ‰€ä»¥æ‰“ç®—æ˜å¤©æ£€æŸ¥ä¸€ä¸‹è®¾å¤‡ã€‚ å¤ªé˜³ï¼Œä½ åœ¨å“ªé‡Œï¼Ÿ Day 1 9.18ã€‚ 12:00 ä¹‹åæ‰æµ‹äº†ä¸€ä¸‹è®¾å¤‡ï¼Œä¸æ„§æ˜¯æˆ‘ã€‚ å®‡å®™å°„çº¿é‚£ä¸ªé¢˜è¢« NOIP è®¡åˆ’ç¾¤é‡Œçš„äººæŠ¼ä¸­äº†ï¼Œorzã€‚ æ„Ÿè§‰æ¯”å»å¹´ç®€å•äº†å¤ªå¤šï¼Œä¸è¿‡é€‰ B çš„å˜å°‘äº†ã€‚ çº¿ä¸Šè€ƒï¼Œæ–‡ä»¶æ­»æ´»ä¸ä¼šä¼ ï¼Œå¯„äº†ã€‚ ä½œä¸šè¿˜æ²¡æœ‰å†™å®Œï¼Œæˆ‘æ˜å¤©è¿˜éœ€è¦è®²æ–¯å¤§æ—æ ¼å‹’ï¼ˆä¸æ˜¯è¯ºæ›¼åº•äº†ï¼Œæ”¹äº†ï¼‰ã€‚ ç¬¬äºŒè½® å†…å®¹é¢„è®¡åŒ…æ‹¬ç½‘è¯¾çš„æœ€åä¸€å‘¨ã€å¤å­¦ã€å›½åº†ç§‹ä»¤è¥å’Œ CSP ç¬¬äºŒè½®ã€‚ ç½‘è¯¾çš„æœ€å è¿™åº”è¯¥æ˜¯æœ€åä¸€å‘¨çš„ç½‘è¯¾äº†ã€‚ 9.19ï¼ˆæ–¯å¤§æ—æ ¼å‹’ï¼‰ ä¸Šåˆè¾¹å¬è¯¾è¾¹ç»ƒä¹ æ–¯å¤§æ—æ ¼å‹’çš„æ¼”è®²ã€‚ ä¸­åˆè®²çš„æ—¶å€™å¥½åƒæ•ˆæœè¿˜ä¸é”™ï¼Ÿæˆ‘ä¹Ÿè¦æˆä¸ºé’¢é“ä¹‹äººï¼ NOIP è®¡åˆ’çœŸÂ·è¿›å…¥äº†åæœŸï¼Œ3k å‘å¨äº†ã€‚ å†²ï¼ åšé¢˜é‡å¿ƒå¼€å§‹è½¬ç§»ï¼ŒæŒ‰ç…§è“è‰²è®¡åˆ’ PART-A ç¬¬å››é˜¶æ®µè¿›è¡Œå†²åˆºã€‚ æ™šä¸Šå‘ç”Ÿäº†æŸäº›äº‹æƒ…ï¼Œæƒ³å“­ã€‚ åœ¨è¿™é‡Œåªç”¨äº†å¯¥å¯¥å‡ ä¸ªæ–‡å­—æ›¿ä»£ã€‚ æœ¬æ¥è¿˜æƒ³å†™ç‚¹ä»€ä¹ˆï¼Œä½†å°±æ˜¯å†™ä¸å‡ºæ¥ã€‚ ä¸ä»…æ˜¯è¯­æ–‡å·®ï¼Œæ›´æ˜¯å› ä¸ºæœ‰äº›å¿ƒæƒ…çœŸçš„æ— æ³•ç”¨æ–‡å­—è¡¨è¾¾ã€‚ 9.20 Burn everything with raging Hellfire. æˆ‘ä»¬ä»åœ°ç‹±ä¸­å½’æ¥ï¼Œåªä¸ºæ¸…ç®—ã€‚ æ•™ç»ƒè®²çš„å¥½æœ‰é“ç†ï¼ˆä¸æ˜¯ä¸Šé¢è¿™å¥è¯ï¼ï¼‰ã€‚ 9.21 å†™äº 0:06 AMã€‚ Revenge. å†™äº 9:55 AMã€‚ Revenging. æœ‰çš„æ—¶å€™æ€»æ˜¯å¿˜äº†åˆå¿ƒï¼Œå­¦ä¹ çš„ç›®çš„æ˜¯å­¦ä¼šæ–°çš„çŸ¥è¯†ç‚¹ã€‚ 9.22 æ–—å¿—ä¸æ­»ã€‚ ç¨å¾®æ›´æ”¹äº†ä¸‹è“è‰²è®¡åˆ’ã€‚ 9.23 æ´»æ€ä¹ˆè¿™ä¹ˆå¤šâ€¦â€¦ä»Šå¤©å­¦æ ¡æ¨¡æ‹Ÿèµ›ï¼Œç„¶åè¿˜æœ‰ CFï¼Œç„¶åè¿˜ä¸åœè¯¾ï¼Œæ–‡åŒ–è¯¾ä½œä¸šä¸€å †ã€‚ ä½†æ˜¯åšçš„å¥½çˆ½ã€‚ æ˜å¤©è¦å»å­¦æ ¡åšæ ¸é…¸å•¦ï¼Œç»ˆäºå¯ä»¥å›å»äº†ï¼ ä½†æ˜¯ç°åœ¨çœŸçš„æœ‰ç‚¹ç´¯ï¼Œå—ï¼Ÿ 9.24 è“è‰²è®¡åˆ’ 2.0 PART A-V Eschaton å¤å­¦ åˆšå¼€å§‹å¾ˆä¹±ï¼Œä½†æ˜¯åé¢çœŸçš„å¾ˆæœ‰æ„æ€ã€‚ 9.25 æ‰‹å¿™è„šä¹±.jpg 9.26 çœŸçš„å¼€å­¦å•¦ï¼ æ–‡åŒ–è¯¾éå¸¸å¥½ï¼ç„¶è€Œä¸‹åˆå±…ç„¶è¿˜æœ‰å„ç§å¥‡æ€ªçš„è¯¾ç¨‹ï¼ é£Ÿå ‚éå¸¸å¥½ï¼ä»·é’±æ˜¯éš”å£å­¦æ ¡çš„ä¸€åŠä½†æ˜¯è´¨é‡æ˜¯ä¸¤å€ï¼è‡ªåŠ©é¤ 20 å…ƒä¸€ä½ï¼ˆæˆ‘ä»¬ç­ä¸»ä»»è€å¸ˆè¯´ä¸è¦å»ä¸‰å››æ¥¼åƒä¸œè¥¿ï¼Œè¯´çš„å¥½æœ‰é“ç†ï¼‰ï¼ åæ­£å¾ˆå¥½ï¼ä¸‹åˆæ¨¡æ‹Ÿèµ›ï¼ç‚¸æ­»äº†ï¼ é’¢é“æ´ªæµï¼ 9.30 å¥½ä¹…æ²¡å†™ä¸œè¥¿äº†ï¼Œæ¥èƒ¡ä¹±å†™ç‚¹ã€‚ æœ€è¿‘æŒºå¿™ï¼ŒçœŸæ²¡æœ‰ä»€ä¹ˆæ—¶é—´æ¥å†™ã€‚æˆ–è€…æ˜¯æ²¡ä»€ä¹ˆå¿ƒæƒ…å†™ã€‚ é¢˜éå¸¸çš„å¤šï¼Œç„¶è€Œè¿˜æ²¡å¤šå°‘æ—¶é—´å»è¡¥ã€‚ å›½åº† ã€‚ã€‚ã€‚ 10.3 å¾ˆä¹…æ²¡å†™ä¸œè¥¿äº†ï¼Œä¸»è¦æ˜¯çœŸçš„æ²¡æ—¶é—´å†™ã€‚ ç°åœ¨çœŸçš„æ²¡è¿™ç§é—²å¿ƒäº†ï¼Œæ¯•ç«Ÿé«˜ä¸€çš„è¿™æ®µæ—¶é—´æ˜¯ä¸å¯èƒ½åœè¯¾çš„ã€‚æƒ³è¦åŒæ—¶æŠ“æ–‡åŒ–è¯¾å’Œ OI çœŸçš„å¾ˆç´¯ã€‚ 10.4 ä¸Šåˆæ¨¡æ‹Ÿèµ›ä¸ºä»€ä¹ˆæœ‰ä¸¤ä¸ªç­¾åˆ°é¢˜å•Šqaq ç„¶åè¿™æ˜¯æœ€åçš„æœºä¼šäº†ï¼Œå¦åˆ™åªèƒ½é€€å½¹äº†ã€‚ æˆ‘ä»¬ä¼šä¸æ‹©æ‰‹æ®µåœ°è¿½æ±‚èƒœåˆ©ã€‚ 10.5 æˆ‘è¿™ä¸ªäººè¿˜æœ‰å¾—æ•‘ã€‚ ä¸Šåˆçš„ NOIp å¤šæ ¡æ¨¡æ‹Ÿæ´»æ´»å‡ºæˆäº†çœé€‰åœºéš¾åº¦ å’çƒæ´ªæµã€‚ ç‹‚æš´æ¨¡å¼ã€‚ ç¬¬äºŒè½® æˆ‘å¸Œæœ›æˆ‘æŠ›æ‰è‡ªå·±çš„æ„Ÿæƒ…ã€‚ I, Robot. 10.16 ä¸Šåˆæ²¡æœ‰å»å­¦æ ¡æ‰“å¤šæ ¡ï¼Œæ‰“ç®—ä¸‹åˆè®¤çœŸæ‰“ä¸€ä¸‹ NOIP è®¡åˆ’çš„ç¬¬åäºŒåœºã€‚ ç„¶å 205ï¼Œä½†æ˜¯ Luogu ä¸Šæµ‹æ˜¯ 270â€¦â€¦ æ˜æ˜¾æ˜¯è¾“åœ¨äº† T2 ä¸Šï¼ˆæ‹¿äº† 50 åˆ†çš„ç‰¹æ®Šæ€§è´¨ï¼‰ï¼Œè¿™ä¸ªçœŸçš„ä¸åº”è¯¥è¿ä¸€ä¸ªäºŒåˆ†éƒ½æƒ³ä¸å‡ºæ¥ã€‚ æœ‰äºº AK äº†ï¼Œä½†æ˜¯æ˜¾ç„¶ T3 è¿œè¿œè¶…å‡ºäº†æˆ‘çš„èƒ½åŠ›èŒƒå›´ï¼Œä¸ rk1 å·®è¿™ 75 åˆ†å¾ˆæ­£å¸¸ã€‚T4 æš´åŠ›å†²è¿‡å» 19 ä¸ªç‚¹æ‹¿äº† 95 æŠŠæˆ‘æ•´æ‡µäº†ï¼Œæ­£è§£ä¹Ÿä¸éš¾æƒ³ï¼Œå°±æ˜¯æ ¹å·åˆ†æ²»ä¼˜åŒ–ã€‚éš¾åº¦ T1 &lt; T2 &lt; T4 &lt; T3ã€‚ ç„¶åä½œä¸šå†™ä¸å®Œäº† çªç„¶æ„Ÿè§‰å®¶é•¿è¯´çš„å¥½å¯¹ï¼Œåœ¨è¿™ä¸ªé˜¶æ®µï¼Œä½œä¸ºä¸€ä¸ªæœºå™¨äººæ˜¯çœŸçš„æœ‰ç”¨ã€‚ æ— å°½çš„é’¢é“æ´ªæµç¢¾è¿‡äº†åœ°ç‹±ï¼Œå°†åœ°ç‹±å†°å°ã€‚æ˜å¤©ï¼Œä¸€å®šèƒ½åˆ°è¾¾é‚£è“è‰²å½¼ç«¯ã€‚ 10.19 å’çƒã€‚å’çƒã€‚å’çƒï¼ ç¦æ­¢æ‘†çƒ‚ã€‚ è´­ä¹°äº†å’çƒã€‚ 10.22 ä»Šå¤©æ˜¯æ˜ŸæœŸå…­ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸‹ä¸€å‘¨çš„è¿™ä¸ªæ—¶å€™å°± CSP äº†ã€‚ æ•™ç»ƒè¯´ CSP åªæ˜¯ç»ƒå…µï¼Œä½†å®é™…ä¸Šè¿˜æ˜¯æ„Ÿè§‰ä¸å¤ªç¨³ã€‚æ„Ÿè§‰ä»Šå¹´çš„éš¾åº¦è¿˜æ˜¯ä¼šå†åŠ å¼ºï¼Œæƒ³è¦è·å¾—ä¸€ä¸ªæ¯”è¾ƒå¥½çš„æˆç»©è‡³å°‘éœ€è¦åˆ‡æ‰ä¸¤é“é¢˜ï¼Œç„¶è€Œè¿™ç§äº‹æˆ‘ä»æ¥æ²¡æœ‰å¹²å‡ºæ¥è¿‡ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œè¦å¯„ã€‚ å­¦æ ¡æ¨¡æ‹Ÿèµ›ï¼Œè¢«è¯„æµ‹ç³»ç»Ÿåäº† 100ã€‚100 åˆ†ç¥­å¤©ï¼ŒCSP èƒ½ä¸èƒ½è¿æ°”å¥½ç‚¹ï¼Ÿ 10.23 æ–‡åŒ–è¯¾ï¼åˆçˆ±åˆæ¨ï¼ å—é™äºé«˜è€ƒçš„åŸå› ï¼Œå¾ˆå¤šå†…å®¹è€å¸ˆéƒ½åªå¼€äº†ä¸ªå¤´ï¼Œç„¶åâ€œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥ç ”ç©¶ï¼Œç«èµ›ç”Ÿåº”è¯¥éƒ½ä¼šâ€ï¼è™½ç„¶æˆ‘ç†è§£ä¸ºäº†é«˜è€ƒåªèƒ½è¿™ä¹ˆåšï¼Œæ¯•ç«Ÿè¯¾çœŸçš„å¾ˆç´§å¼ ï¼ æ‰€ä»¥ï¼Œä¸€å®šè¦å­¦ç«èµ›å•Šï¼å¦åˆ™é«˜ä¸­ç™½ä¸Šäº†ï¼ å‘ç”Ÿäº†ä¸€ä»¶æœ‰è¶£çš„äº‹æƒ…ï¼šå’çƒæ»šé”®ç›˜äº†ã€‚ ä¸‹åˆæ˜¯ NOIP è®¡åˆ’çš„ç¬¬åä¸‰åœºï¼ˆæ²¡é”™ï¼Œä¸Šåˆçš„å¤šæ ¡æˆ‘åˆæ²¡æ‰“ï¼‰ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ CSP ä¹‹å‰ï¼ˆåº”è¯¥æ˜¯ï¼‰çš„æœ€åä¸€åœºæ¨¡æ‹Ÿèµ›äº†ã€‚ ç„¶è€Œå…¨ç¨‹è‡ªé—­ï¼Œ165165165 åœ¨å 80%80\\%80% èœçˆ†äº†ã€‚ äº‹åå‘ç° T2 è´¼ç®€å•ï¼Œä½†æ˜¯æˆ‘åªä¼šéƒ¨åˆ†åˆ†ï¼Œæˆ‘æ˜¯åºŸç‰©ã€‚ å’çƒã€‚ 10.24 ä¸‹åˆæŠŠç»¼åˆæŠ€æœ¯å’Œå›´æ£‹è¯¾ç¿˜æ‰äº†ã€‚ æ‹¿ç€å’çƒåœ¨å­¦æ ¡ç‹‚å¥” è¿åŠ¨ä¼šæ‹¿äº†ä¸ªå€’æ•°ç¬¬ä¸€ 10.25 å‡Œæ™¨å†™ä¸‹çš„æ–‡å­—ï¼š æ­£å¼å¼€å§‹çœé€‰å­¦ä¹ çš„é¢„ä¹ é˜¶æ®µï¼Œåæ­£æ˜¯ â€”â€” Dashï¼ è“è‰²è®¡åˆ’ 2.0 plus PART B-I DASH Day -3 10/26ï¼Œæ™šä¸Šåˆ°è¾¾é…’åº—ã€‚ ç„¶åå¤§å®¶å»æ‰“ä¸‰å›½æ€äº†ï¼Œæˆ‘ä¹Ÿä¸ä¼šæ‰“ï¼Œçœ‹äº†ä¸€ä¼šè¿˜æ˜¯ä¸ä¼šï¼Œå°±å»å¹²åˆ«çš„äº†ã€‚ è·Ÿ KH ä¸€ä¸ªå±‹ï¼Œorz ç„¶åä¸‰å›½æ€æ‰“åˆ°äº† 11 ç‚¹ï¼Œorz Day -2 æ—©ä¸Šèµ·åºŠå›°éš¾ç—‡ã€‚ ä¸­åˆ dqq è®¢çš„é¥­ï¼Œ%%%\\%\\%\\%%%% ä»Šå¤©ä¸‹åˆå±…ç„¶æœ‰æ¨¡æ‹Ÿèµ›ï¼Œorz ç„¶åè¢«çˆ†æ€ï¼Œorz æ™šä¸Šå†™çº¿æ®µæ ‘è°ƒä¸å‡ºæ¥äº†ï¼Œorz Day -1 æ™šé¥­çš„æ—¶å€™ KH å’Œ dqq è®¨è®ºäº†æœºå™¨äººä¸æ„è¯†å­˜åœ¨ï¼Œæœ€åçš„ç»“è®ºæ˜¯ï¼šè¿™ä¸ªä¸–ç•Œæ˜¯ç”± wind_whisper åˆ›é€ çš„ï¼ŒKH æ˜¯ wind_whisper çš„æ„è¯†ï¼Œdqq å’Œæˆ‘è¿™ç§å¼‚ç±»åº”è¯¥è¢«é©±é€ã€‚ æ™šä¸Šå¤§å®¶åœ¨æ‰“å—ï¼Œä½†æ˜¯æˆ‘ä¸ä¼šæ‰“ Day 1 ä¸­åˆè†œæ‹œäº†å’çƒå’Œ wind_whisperï¼Œç„¶åå°±è¿›å»äº†ã€‚ è‡´å‘½ä¼¤ï¼šåˆ·é¢˜å¤ªå°‘ï¼Œæ‰‹é€Ÿå¤ªæ…¢ã€‚ å¤§æ¦‚ç”¨ 1h å†™äº† T1 çš„ 707070ï¼Œ1.5h å†™äº† T2 çš„ 757575ï¼Œå¤ªåƒåœ¾äº†ã€‚ å†™äº† T4 çš„ 323232 åˆ†ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªå­ä»»åŠ¡å¿˜è®°åˆ å»è°ƒè¯•ä»£ç äº†ï¼ŒæŒ‚äº†ä¸€åŠï¼Œå¯„ã€‚ T3 çš„æš´åŠ›å°±æ²¡ Dash å‡ºæ¥ã€‚ åˆ†å€’æ˜¯æ²¡æŒ‚ï¼Œä¹Ÿæ²¡ä»€ä¹ˆå¯æŒ‚çš„äº†ã€‚ ç„¶åå¤šä¸ªæ°‘é—´æ•°æ®çš„ç»“æœè¯æ˜ï¼ŒKH AK äº†ï¼Œå¤ªå¼ºå¤§äº†ã€‚ æ™šä¸Šå­¦é•¿çœ‹æˆ‘è‰°éš¾çš„å­¦ä¹ åˆ†å— æ€»ç»“ï¼šä»¥åçš„æ–‡ä»¶è¾“å…¥è¾“å‡ºå’Œè°ƒè¯•ä»£ç éƒ½ä¸è¦æ³¨é‡Šï¼Œç”¨ ifdef åŒ…è£¹èµ·æ¥ï¼Œå¹¶ä¸”å°†è°ƒè¯•å†…å®¹è¾“å‡ºåˆ° stderrï¼Œè¿›ä¸€æ­¥é™ä½å‡ºé”™çš„å¯èƒ½ã€‚ Day 2 è€ƒå®Œäº†ï¼Œä½†æ˜¯å´é­”äº†ã€‚ è¿™å‡ å¤©çš„æ”¶è·çœŸçš„å¾ˆå¤šï¼ŒKH å’Œ dqq éƒ½æ•™äº†æˆ‘å¾ˆå¤šï¼Œæ„Ÿè°¢ã€‚ æˆ‘æˆ–è®¸éœ€è¦å¥½å¥½è§„åˆ’ä¸€ä¸‹æ¥ä¸‹æ¥è¯¥æ€ä¹ˆåŠã€‚ è·Ÿ gg ç”³è¯·äº†åœè¯¾ã€‚ NOIP åœè¯¾ç”³è¯·æˆåŠŸäº†ï¼ é¬¼åŸ å‘ç°è‡ªå·±å¿…é¡» Dashï¼Œéœ€è¦è€ƒåˆ° NOIP ä¸€ç­‰å¥–æ‰èƒ½è·å¾— 3k çš„å¥–é‡‘ï¼Œè€Œä¸”è¿˜éœ€è¦å†²è¿› 10%10\\%10% æ‹¿åˆ° 7 çº§é’©ï¼Œè¿˜éœ€è¦ Dash è¿›å‰é¢ä¿è¯è¯¾èƒ½åœåˆ°çœé€‰ï¼Œå¹¶ä¸”æ’ååœ¨å‰é¢æ‰èƒ½æœ‰æœºä¼šå†²è¿‡çœé€‰ã€‚ 11.2 å’çƒã€‚ æ³¨æ„ï¼Œä¸æ˜¯ T1 åšä¸å‡ºæ¥å°±æ„å‘³ç€åé¢åºŸäº†ã€‚éš¾åº¦æ˜¯ä¸»è§‚åˆ¤æ–­çš„ï¼Œæ‰€ä»¥æ²¡æœ‰é¡ºåºã€‚ åœè¯¾æœ€å¤§çš„é—®é¢˜æ˜¯å¦‚ä½•åˆç†å®‰æ’æ—¶é—´ï¼Œå¦åˆ™è¿™ç§è‡ªç”±åªä¼šæŠŠä½ é€è¿›åœ°ç‹±ã€‚ ç°åœ¨ç†Ÿæ‚‰èŠ‚å¥äº†å§ï¼Ÿæ˜¯æ—¶å€™åŠ¨çœŸæ ¼çš„äº†ï¼ 11.3 å¸Œæœ›çŸ¥é“è‡ªå·±åœ¨åšä»€ä¹ˆã€‚ èŠ‚å¥ä¸è¦ä¹±ï¼Œæˆ‘æ‹¿çš„æ˜¯è‡ªå·±çš„é”®ç›˜ã€‚ 11.4 çœ‹äº†å¤šå¤´çš„éšç¬”ï¼ŒçœŸçš„å¾ˆæ·±åˆ»ã€‚ å‘½è¿æ˜¯å¯ä»¥æŒæ§çš„ï¼Œè¿æ°”æ˜¯å¯ä»¥è·å¾—çš„ï¼Œä½†è·å¾—çš„åªæ˜¯è¿æ°”ã€‚ 11.5 å¤šæ ¡è¢«çˆ†æ€ï¼ŒçŠ¶å‹ DP æ²¡ Dash å‡ºæ¥ æ™šä¸Š AT å¤ªåˆºæ¿€äº†ï¼Œç»“æŸå‰ 5s äº¤äº†ä¸ªå¡æ—¶åšæ³•å¡è¿‡å»äº† æ˜å¤©æ˜¯ä¸æ˜¯æœ‰ä¸‰åœºæ¯”èµ›å•Šâ€¦â€¦ 11.6 ä¸Šåˆå­¦æ ¡æ¨¡æ‹ŸçœŸå¥½ç© ä¸‹åˆ NOIp è®¡åˆ’ï¼ŒT4 æˆ‘ä¸ä¼š ODTï¼Œç®—é”™äº†æ¬¡æ•°å¯¼è‡´æ²¡å†™èŠ±ç¥æ¸¸å†å„å›½ï¼Œç›´æ¥æ­»æ‰ 505050 åˆ†ã€‚ ç§‘æŠ€è¿™ç§ä¸œè¥¿è¿˜æ˜¯è¦ç¨å¾®çˆ¬ä¸€ä¸‹ï¼Œä¸èƒ½å…¨å †åˆ°çœé€‰ã€‚ æ™šä¸Š CF åäº†ã€‚ å†¬ä¹‹å¤ çœ©ã—ã•ã ã‘ã¯ã€å¿˜ã‚Œãªã‹ã£ãŸã€‚\\large\\color{skyblue}çœ©ã—ã•ã ã‘ã¯ã€å¿˜ã‚Œãªã‹ã£ãŸã€‚ çœ©ã—ã•ã ã‘ã¯ã€å¿˜ã‚Œãªã‹ã£ãŸã€‚ 11.7 CSP å‡ºåˆ†äº†ï¼Œ203ï¼Œå¤ªåƒåœ¾äº†ã€‚æ²¡æœ‰å¸Œæœ›äº†ï¼Œè¦é€€å½¹äº†ã€‚ æ˜æ˜ä»Šå¤©å†¬è‡³ï¼Œå¿ƒè¿˜åœ¨é‚£ç››å¤ã€‚æ„Ÿè°¢ä½ çš„é™ªä¼´ã€‚ 11.8 æˆ‘åªèƒ½è¯´æ¨¡æ‹Ÿèµ› T2 å‡ºæ¯å‡½æ•°ï¼ŒT4 è€ƒè‡ªåŠ¨æœºä¸Š DAG é“¾å‰–åˆ†çš„å‡ºé¢˜äººæ˜¯æ¯’ç˜¤ã€‚ 11.9 åšå¥½è§‰æ‚Ÿå§ã€‚ ç°åœ¨ï¼Œå‡›å†¬å°†è‡³ã€‚This is THE EXILE. åŠ æ²¹å•Šï¼Œjames1ï¼ 11.12 æ‰“äº† CF Div.2ï¼Œå¤ªèœäº†ï¼ŒC éƒ½ä¸ä¼šã€‚ æˆ‘æ˜¯ä»€ä¹ˆå‘€ 11.15 æ¨¡æ‹Ÿèµ›ä¸­é˜µäº¡çš„æ—¥å¸¸ å‘œå‘œå‘œï¼Œå¤ªèœäº†ï¼Œå¿«å»å¹²è¯¥å¹²çš„äº‹æƒ…å§ã€‚ å¥‹æ–—ä»ç„¶æ˜¯æœ€æœ‰æ„ä¹‰çš„ç­”æ¡ˆã€‚ DEAD END æˆ‘å®£å¸ƒæˆ‘å°†åœ¨ NOIP 2022 ä¹‹åé€€å½¹ã€‚è¾“äº†å°±æ˜¯è¾“äº†ï¼Œæ²¡æœ‰ä»€ä¹ˆå¥½åé©³çš„ã€‚åœ¨è¿™é‡Œç¥æ„¿å‰©ä¸‹çš„äººèƒ½åšæŒæˆ˜æ–—ä¸‹å»ã€‚æˆ‘æ˜¯åºŸäº†ã€‚æ—¢ç„¶å¦‚æ­¤ï¼Œåœ¨è€ƒåœºä¸Šï¼ŒOI ç”Ÿæ¶¯ä¸­çš„æœ€åå››ä¸ªå°æ—¶ï¼Œæ€»å¾—å¥½å¥½æ‰“å§ï¼Œè‡³å°‘ä¹Ÿæ‰“ä¸ªçˆ†é›¶ï¼Œåˆ«è€ƒè¯•ä½œå¼Šäº†ã€‚ 11.20 (Day -6) ä¸Šä¸‹åˆçš„æ¨¡æ‹Ÿèµ›éƒ½è‡ªé—­äº†ã€‚ å†è§äº†ï¼ŒOIã€‚ 11.21 (Day -5) å¤šå¤´å¥½é—ªï¼Œæ‹œè°¢å¤šå¤´ã€‚ å‡†å¤‡é€€å½¹ã€‚ å½’é€” NOIP å–æ¶ˆäº†ã€‚å¯èƒ½ç”¨ CSP æˆç»©ç®—ï¼Œé‚£å°±æ²¡æœºä¼šäº†ï¼Œæ‘†çƒ‚å§ã€‚ åè®° å…¶å®ä¹Ÿæ²¡ä»€ä¹ˆå¥½è¯´çš„äº†ï¼Œå¼€å§‹äº†ã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"ç®€å•æ ‘å½¢é—®é¢˜","slug":"notes/DS/tree","date":"2022-08-01T00:00:00.000Z","updated":"2022-08-01T00:00:00.000Z","comments":true,"path":"85699f68/","link":"","permalink":"https://james1badcreeper.github.io/85699f68/","excerpt":"æœ¬æ–‡å¯¹ç®€å•çš„æ ‘å½¢é—®é¢˜è¿›è¡Œäº†è®²è§£ã€‚","text":"æœ¬æ–‡å¯¹ç®€å•çš„æ ‘å½¢é—®é¢˜è¿›è¡Œäº†è®²è§£ã€‚ æœ‰å…³æ ‘çš„é—®é¢˜åœ¨è€ƒè¯•æ—¶éå¸¸å¸¸è§ï¼Œæ‰€ä»¥å¿…é¡»ç†Ÿç»ƒæŒæ¡ã€‚æœ¬æ–‡ä»‹ç»çš„é—®é¢˜éƒ½æ¯”è¾ƒç®€å•ï¼Œä¸æ¶‰åŠä»€ä¹ˆé«˜éš¾çš„é—®é¢˜ã€‚ æ ‘çš„æ€§è´¨ä¸éå† æˆ‘ä»¬çŸ¥é“ï¼Œä¸€æ£µæ ‘æœ‰ nnn ä¸ªç‚¹ï¼Œnâˆ’1n-1nâˆ’1 æ¡è¾¹ï¼Œä¸”ä¸€å®šæ˜¯è¿é€šçš„ã€‚æœ‰å‡ ç§ç‰¹æ®Šçš„æ ‘ï¼š é“¾ï¼šæ ‘é€€åŒ–æˆé“¾å¼ç»“æ„ã€‚ â€œèŠèŠ±å›¾â€ï¼šæ ‘çš„æ·±åº¦æ°å¥½ä¸º 222ã€‚ [Luogu P5908] çŒ«çŒ«å’Œä¼é¹…ã€‚ å¯ä»¥ç®€å•çš„ä½¿ç”¨æ ‘çš„æ·±åº¦ä¼˜å…ˆéå†æ¥è§£å†³é—®é¢˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, d, ans = 0, dis[100005]; vector &lt;int> G[100005]; void dfs(int o, int f) &#123; if (dis[o] &lt;= d &amp;&amp; o != 1) ++ans; for (int i = 0; i &lt; G[o].size(); ++i) &#123; int &amp;y = G[o][i]; if (y == f) continue; dis[y] = dis[o] + 1; dfs(y, o); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;d); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; è¾¹æƒè½¬ç‚¹æƒã€‚å®é™…ä¸Šåœ¨æ ‘å½¢é—®é¢˜ä¸­ï¼Œè¾¹æƒéå¸¸ä¸å¥½å¤„ç†ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨æ·±åº¦ä¼˜å…ˆéå†çš„æ—¶å€™å°†è¾¹æƒå…¨æ”¾ç»™å„¿å­ã€‚å¤§æ¦‚åƒè¿™æ ·ï¼š d[y] = w; // è½¬ç§»è¾¹æƒä¸ºå„¿å­çš„ç‚¹æƒ dfs(y, x); æ ‘çš„ç›´å¾„ æŒ‡çš„æ˜¯æ ‘ä¸Šçš„æœ€é•¿è·¯å¾„ï¼Œå¯ä»¥é€šè¿‡ä¸¤æ¬¡ DFS æ±‚å‡ºã€‚ç¬¬ä¸€æ¬¡ DFS ä»ä»»æ„èŠ‚ç‚¹å¼€å§‹éå†ï¼Œèµ°åˆ°æœ€è¿œçš„åœ°æ–¹ï¼Œç„¶åä»è¿™ä¸ªåœ°æ–¹å¼€å§‹ç¬¬äºŒæ¬¡ DFSï¼Œèµ°åˆ°æœ€è¿œçš„åœ°æ–¹ã€‚è¿™ä¸¤ä¸ªæœ€è¿œçš„åœ°æ–¹è¿æ¥èµ·æ¥å°±æ˜¯æ ‘çš„ç›´å¾„ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, maxx = 0; bool v[10005]; int dis[10005]; vector &lt;int> G[10005]; void dfs(int o, int fa) &#123; for (int i = 0; i &lt; G[o].size(); ++i) &#123; if (G[o][i] == fa) continue; dis[G[o][i]] = dis[o] + 1; if (dis[G[o][i]] > dis[maxx]) maxx = G[o][i]; dfs(G[o][i], o); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, -1); memset(v, 0, sizeof(v)); dis[maxx] = 0; dfs(maxx, -1); printf(\"%d\\n\", dis[maxx]); return 0; &#125; æ ‘çš„ç›´å¾„æœ‰ä¸€ä¸ªæ˜¾ç„¶çš„æ€§è´¨ï¼šç›´å¾„çš„æŸä¸ªç«¯ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„è·ç¦»çš„æœ€å°å€¼ä¸€å®šæ˜¯æ‰€æœ‰ç‚¹ä¸­æœ€å¤§çš„ã€‚ æ ‘çš„é‡å¿ƒ å¯¹äºæ ‘ä¸Šçš„æ¯ä¸€ä¸ªç‚¹ï¼Œè®¡ç®—å…¶æ‰€æœ‰å­æ ‘ä¸­æœ€å¤§çš„å­æ ‘èŠ‚ç‚¹æ•°ï¼Œä½¿å¾—è¿™ä¸ªå€¼æœ€å°çš„ç‚¹å°±æ˜¯è¿™æ£µæ ‘çš„é‡å¿ƒã€‚æ ‘çš„é‡å¿ƒæœ‰ä»¥ä¸‹æ€§è´¨ï¼š ä»¥æ ‘çš„é‡å¿ƒä¸ºæ ¹æ—¶ï¼Œæ‰€æœ‰å­æ ‘çš„å¤§å°éƒ½ä¸è¶…è¿‡æ•´æ£µæ ‘å¤§å°çš„ä¸€åŠã€‚ ä½¿ç”¨åè¯æ³•ã€‚è®¾å½“å‰çš„é‡å¿ƒä¸º uuuï¼Œä¸ uuu ç›¸è¿çš„å­æ ‘ vvv çš„å¤§å°è¶…è¿‡äº†æ•´æ£µæ ‘çš„ä¸€åŠï¼Œé‚£ä¹ˆå°† vvv æ›¿æ¢ä¸ºæ ‘çš„é‡å¿ƒï¼Œæ˜¾ç„¶è¿™æ—¶ uuu çš„å­æ ‘ä¸è¶…è¿‡æ•´æ£µæ ‘å¤§å°çš„ä¸€åŠï¼Œè€Œ vvv çš„å­æ ‘å¤§å°å‡å°äº† 111ï¼Œä¸€å®šæ¯” uuu ä½œä¸ºé‡å¿ƒæ›´å¥½ã€‚ æ ‘ä¸­æ‰€æœ‰ç‚¹åˆ°æŸä¸ªç‚¹çš„è·ç¦»å’Œä¸­ï¼Œåˆ°é‡å¿ƒçš„è·ç¦»å’Œæ˜¯æœ€å°çš„ï¼›å¦‚æœæœ‰ä¸¤ä¸ªé‡å¿ƒï¼Œé‚£ä¹ˆåˆ°å®ƒä»¬çš„è·ç¦»å’Œä¸€æ ·ã€‚ å› ä¸ºå¦‚æœç§»åŠ¨äº†ï¼Œå¢åŠ çš„è·ç¦»ä¸€å®šå¤§äºç­‰äºå‡å°‘çš„è·ç¦»ã€‚ æŠŠä¸¤æ£µæ ‘é€šè¿‡ä¸€æ¡è¾¹ç›¸è¿å¾—åˆ°ä¸€æ£µæ–°çš„æ ‘ï¼Œé‚£ä¹ˆæ–°çš„æ ‘çš„é‡å¿ƒåœ¨è¿æ¥åŸæ¥ä¸¤æ£µæ ‘çš„é‡å¿ƒçš„è·¯å¾„ä¸Šã€‚ å¦‚æœä¸åœ¨è¿™æ¡è·¯å¾„ä¸Šï¼Œé‚£ä¹ˆåªæœ‰é‚£ä¸ªèŠ‚ç‚¹çš„å­æ ‘çš„ä»£ä»·ä¼šå‡å°ï¼Œå…¶å®ƒçš„éƒ½ä¼šå¢åŠ ï¼Œå¾—ä¸å¿å¤±ã€‚ åœ¨ä¸€æ£µæ ‘ä¸Šæ·»åŠ æˆ–åˆ é™¤ä¸€ä¸ªå¶å­ï¼Œé‚£ä¹ˆå®ƒçš„é‡å¿ƒæœ€å¤šåªç§»åŠ¨ä¸€æ¡è¾¹çš„è·ç¦»ã€‚ å¢åŠ æˆ–å‡å°‘ä¸€ä¸ªå¶å­ï¼Œåªèƒ½ä½¿æœ€å¤§çš„å­æ ‘æ°å¥½æ¯”ä¸€åŠå¤š 111ï¼Œé‡å¿ƒåªç§»åŠ¨ 111 å³å¯ã€‚ ç°åœ¨æˆ‘ä»¬æ¥çœ‹å¦‚ä½•æ±‚å‡ºæ ‘çš„é‡å¿ƒã€‚æˆ‘ä»¬å‡å®š 111 ä¸ºæ ¹èŠ‚ç‚¹ï¼Œç„¶åè®¾ size[x]size[x]size[x] ä»£è¡¨ xxx çš„å­æ ‘å¤§å°ã€‚æˆ‘ä»¬å®šä¹‰ max_part ä¸ºå½“å‰ dfs åˆ°çš„èŠ‚ç‚¹ä¸­ï¼Œæœ€å¤§çš„å­æ ‘å¤§å°ã€‚å®ƒçš„å­©å­ä»¬çš„å­æ ‘å¤§å°åœ¨ dfs æ—¶å°±å¯ä»¥ç»Ÿè®¡ï¼Œè€Œå‰©ä¸‹çš„ä¸€æ£µå­æ ‘å°±æ˜¯å®ƒçˆ¶äº²å¯¹åº”çš„å­æ ‘ï¼Œè¿™å°±æ˜¯ nâˆ’size[x]n-size[x]nâˆ’size[x]ã€‚è¿™æ ·åªéœ€è¦è°ƒç”¨ä¸€æ¬¡ dfsï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ int n, pos, ans = 1e7; // pos ä¸ºé‡å¿ƒï¼Œans ä¸ºé‡å¿ƒå¯¹åº”çš„æœ€å¤§å­æ ‘ int s[105]; vector &lt;int> G[105]; void dfs(int x, int fa) &#123; s[x] = 1; int max_part = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; // æƒ³é€ƒå›çˆ¶äº²ï¼Œç›´æ¥æªæ¯™ dfs(y, x); s[x] += s[y]; // çˆ¶èŠ‚ç‚¹çš„å­æ ‘å¤§å°åŠ ä¸Šå­èŠ‚ç‚¹çš„ max_part = max(max_part, s[y]); // æ›´æ–° max_part &#125; max_part = max(max_part, n - s[x]); // æœ€åä¸€æ£µå­æ ‘æ˜¯çˆ¶äº²èŠ‚ç‚¹å¯¹åº”çš„å­æ ‘ï¼ˆè¿™é‡Œçš„å­æ ‘æ˜¯æŒ‡ä»¥ x ä¸ºæ ¹çš„æƒ…å†µï¼‰ if (max_part &lt; ans) // ç­”æ¡ˆæ›´ä¼˜å°±æ›´æ–° &#123; ans = max_part; pos = x; &#125; &#125; å­¦è¿‡æ ‘å½¢ DP çš„è¯»è€…åº”è¯¥å¯ä»¥å‘ç°è¿™ä¸ªä¸œè¥¿ç±»ä¼¼äºæ¢æ ¹ DPï¼Œä½†åˆä¸å¤ªä¸€æ ·ã€‚ æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆLCAï¼‰ LCA æ˜¯æŒ‡ç‚¹é›†çš„ LCAï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬è®°æŸç‚¹é›† A={uiâˆ£1â©½iâ©½n}A=\\{u_i|1\\leqslant i\\leqslant n\\}A={uiâ€‹âˆ£1â©½iâ©½n} çš„æœ€è¿‘å…¬å…±ç¥–å…ˆä¸º LCA(u1,u2,â€¦,un)LCA(u_1,u_2,\\ldots,u_n)LCA(u1â€‹,u2â€‹,â€¦,unâ€‹) æˆ– LCA(A)LCA(A)LCA(A)ã€‚å«ä¹‰æ˜¯ç¦»å®ƒä»¬æœ€è¿‘çš„ä¸€ä¸ªç‚¹ï¼Œæ˜¯å®ƒä»¬æ‰€æœ‰ç‚¹çš„ç¥–å…ˆã€‚ LCA æœ‰ä»¥ä¸‹æ€§è´¨ï¼š LCA(u)=uLCA(u)=uLCA(u)=uï¼› LCA(u,v)=uLCA(u,v)=uLCA(u,v)=u çš„å……è¦æ¡ä»¶æ˜¯ uuu æ˜¯ vvv çš„ç¥–å…ˆï¼› å¦‚æœ uuu ä¸ä¸º vvv çš„ç¥–å…ˆå¹¶ä¸” vvv ä¸ä¸º uuu çš„ç¥–å…ˆï¼Œé‚£ä¹ˆ u,vu,vu,v åˆ†åˆ«å¤„äº LCA(u,v)LCA(u,v)LCA(u,v) çš„ä¸¤æ£µä¸åŒå­æ ‘ä¸­ï¼› ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œå‰åºéå†ä¸­ï¼ŒLCA(S)LCA(S)LCA(S) å‡ºç°åœ¨æ‰€æœ‰ SSS ä¸­å…ƒç´ ä¹‹å‰ï¼Œååºéå†ä¸­ LCA(S)LCA(S)LCA(S) åˆ™å‡ºç°åœ¨æ‰€æœ‰ SSS ä¸­å…ƒç´ ä¹‹åï¼› ä¸¤ç‚¹é›†å¹¶çš„æœ€è¿‘å…¬å…±ç¥–å…ˆä¸ºä¸¤ç‚¹é›†åˆ†åˆ«çš„æœ€è¿‘å…¬å…±ç¥–å…ˆçš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œå³ LCA(AâˆªB)=LCA(LCA(A),LCA(B))LCA(A \\cup B) = LCA(LCA(A),LCA(B))LCA(AâˆªB)=LCA(LCA(A),LCA(B))ï¼› ä¸¤ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆå¿…å®šå¤„åœ¨æ ‘ä¸Šä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯ä¸Šï¼Œä¸” dist(u,v)=h(u)+h(v)âˆ’2h(LCA(u,v))dist(u,v)=h(u)+h(v)-2h(LCA(u,v))dist(u,v)=h(u)+h(v)âˆ’2h(LCA(u,v))ï¼Œå…¶ä¸­ h(x)h(x)h(x) æŒ‡ xxx åˆ°æ ‘æ ¹çš„è·ç¦»ã€‚ è¿™äº›æ€§è´¨éƒ½æ¯”è¾ƒæ˜¾ç„¶ï¼Œåœ¨æ­¤ä¸åšè¯æ˜ã€‚ ç°åœ¨æˆ‘ä»¬æ¥è®¨è®º LCA çš„æ±‚æ³•ã€‚ LCA æœ‰å¤šç§æ±‚æ³•ï¼Œä¸åŒæƒ…å†µè¦ç”¨ä¸åŒçš„æ–¹æ³•ã€‚ å¯ä»¥åœ¨ æ¨¡æ¿ è¿›è¡Œæµ‹è¯•ã€‚ å‘ä¸Šæ ‡è®°æ³• æ¯”å¦‚æˆ‘ä»¬ç°åœ¨è¦æ±‚ LCA(u,v)LCA(u,v)LCA(u,v)ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆè®© uuu å’Œ vvv å‘ä¸Šè·³åˆ°åŒä¸€æ·±åº¦ï¼Œç„¶åè®©å®ƒä»¬ä¸€èµ·å¾€ä¸Šè°ƒï¼Œä¸€å®šå¯ä»¥æ‰¾åˆ°å®ƒä»¬çš„ LCAã€‚ int n, m, root; vector &lt;int> G[500005]; bool v[500005]; struct node &#123; int p, fa, dep; &#125;T[500005]; void dfs(int o, int deep) &#123; v[o] = 1; T[o].dep = deep; for (int i = 0; i &lt; G[o].size(); ++i) if (!v[G[o][i]]) &#123; T[G[o][i]].fa = o; dfs(G[o][i], deep + 1); &#125; &#125; int LCA(int x, int y) &#123; if (T[x].dep &lt; T[y].dep) swap(x, y); while (T[x].dep > T[y].dep) x = T[x].fa; // è·³åˆ°åŒä¸€æ·±åº¦ if (x == y) return x; // æ­¤å¤„ç‰¹åˆ¤å¯ä»¥ç•¥å»ï¼Œä½†ä¹ æƒ¯å†™ä¸Š while (x != y) x = T[x].fa, y = T[y].fa; // ä¸€èµ·å¾€ä¸Šè·³ return x; &#125; int main(void) &#123; n = read(), m = read(), root = read(); for (int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); G[x].push_back(y); G[y].push_back(x); &#125; T[root].fa = -1; dfs(root, 1); // æ„é€ æ ‘ while (m--) &#123; int a = read(), b = read(); cout &lt;&lt; LCA(a, b) &lt;&lt; endl; &#125; return 0; &#125; æ ‘ä¸Šå€å¢æ³• ä»¥ä¸Šåšæ³•ææ…¢ï¼Œæœ€å¸¸ç”¨çš„å¿«é€Ÿæ±‚ LCA çš„æ–¹æ³•æ˜¯æ ‘ä¸Šå€å¢æ³•ã€‚è®¾ f[x,k]f[x,k]f[x,k] è¡¨ç¤º xxx çš„ 2k2^k2k è¾ˆç¥–å…ˆã€‚è‹¥è¯¥èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™ä»¤ f[x,k]=âˆ’1f[x,k]=-1f[x,k]=âˆ’1ï¼ˆä¸è®¾ä¸º 000 çš„åŸå› æ˜¯æœ‰çš„é¢˜éœ€è¦è®¾ä¸€ä¸ªç¼–å·ä¸º 000 çš„è™šæ‹ŸèŠ‚ç‚¹ï¼‰ã€‚é‚£ä¹ˆæœ‰ f[x,k]=f[f[x,kâˆ’1]][kâˆ’1]f[x,k]=f[f[x,k-1]][k-1]f[x,k]=f[f[x,kâˆ’1]][kâˆ’1]ï¼Œæ¥ä¸‹æ¥çš„æ€è·¯è·Ÿå‘ä¸Šæ ‡è®°æ³•å¤§è‡´ç›¸åŒã€‚ åœ¨æ±‚è§£ LCA æ—¶ï¼Œæˆ‘ä»¬å…ˆè®©å®ƒä»¬éƒ½è·³åˆ°åŒä¸€æ·±åº¦ã€‚å¦‚æœæ­¤æ—¶ä¸¤ä¸ªç‚¹å·²ç»ç›¸ç­‰ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹å°±æ˜¯ LCAï¼ˆæ­¤æ­¥ä¸èƒ½ç•¥å»ï¼ŒåŸå› æ¥ä¸‹æ¥ä¼šè¯´æ˜ï¼‰ã€‚ç„¶åæˆ‘ä»¬å°è¯•ç€è®©å®ƒä»¬ä¸€èµ·å¾€ä¸Šè·³ï¼Œå¦‚æœè·³å®Œå€¼è¿˜ä¸ç›¸ç­‰ï¼Œé‚£ä¸€å®šè·³ã€‚æœ€åå†è·³ä¸€æ­¥å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m, root; int dep[500005]; int lg[500005]; int f[500005][20]; vector &lt;int> G[500005]; void dfs(int o, int fa) &#123; f[o][0] = fa; // æ ¹æ®å®šä¹‰ dep[o] = dep[fa] + 1; // æ·±åº¦ä¸ºçˆ¶äº² +1 for (int i = 1; i &lt;= lg[n]; ++i) // è·³å‡ºæ ‘çš„å€¼éƒ½ä¼šå˜æˆ -1 f[o][i] = f[f[o][i - 1]][i - 1]; for (int i = 0; i &lt; G[o].size(); ++i) if (G[o][i] != fa) dfs(G[o][i], o); // å¦‚æœä¸å¾€çˆ¶äº²å›ï¼Œå°±ä»¥ G[o][i] ä¸ºå„¿å­ï¼Œo ä¸ºçˆ¶äº² dfs &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) // ä»ä¸€ä¸ªæœ€å¤§å¯èƒ½å€¼å¼€å§‹æšä¸¾ï¼Œè¿™æ ·åšçš„æ­£ç¡®æ€§åŸºäºäºŒè¿›åˆ¶æ‹†åˆ† if (dep[f[x][i]] >= dep[y]) x = f[x][i]; // å¦‚æœè·³è¿™ä¹ˆå¤§æ·±åº¦ä¾ç„¶æ¯” y å¤§ï¼Œé‚£åªèƒ½è·³ if (x == y) return x; // æ­¤æ­¥ä¸èƒ½çœå»ï¼Œå¦åˆ™å·²ç»æ˜¯ LCAï¼Œæœ€å return æ—¶è¿˜ä¼šå†è·³ä¸€æ¬¡ for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; // å¦‚æœè·³è¿™ä¹ˆå¤§éƒ½ä¸ç›¸ç­‰ï¼Œæ­¤æ—¶å¿…é¡»è¦è·³ return f[x][0]; // æœ€åå†è·³ä¸€æ­¥ä¾¿ä¸€å®šæ˜¯ LCA &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;root); lg[1] = 0; for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(root, -1); // è®© -1 ä½œä¸ºæ ¹èŠ‚ç‚¹çš„â€œçˆ¶äº²â€œï¼Œä½¿å¾— f æ•°ç»„ä¸­è·³å‡ºæ ‘çš„éƒ½å˜æˆ -1 while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", LCA(x, y)); &#125; return 0; &#125; é™¤äº†æ±‚è§£ LCA é—®é¢˜ï¼Œå¾ˆå¤šæ ‘ä¸Šé—®é¢˜éƒ½ä¼šç”¨åˆ°æ ‘ä¸Šå€å¢æ³•ã€‚ æ ‘ä¸Šå‰ç¼€å’Œä¸å·®åˆ† å‰ç¼€å’Œå’Œå·®åˆ†æ˜¯çº¿æ€§ç»“æ„ä¸Šçš„æœ‰åŠ›å·¥å…·ï¼Œä½†æ˜¯å®ƒä»¬ä¹Ÿå¯ä»¥æ¬åˆ°æ ‘ä¸Šæ¥ã€‚ æ ‘ä¸Šå‰ç¼€å’Œ è®¾ SiS_iSiâ€‹ ä»£è¡¨æ ¹èŠ‚ç‚¹åˆ°èŠ‚ç‚¹ iii çš„æƒå€¼æ€»å’Œï¼Œé‚£ä¹ˆï¼š å¦‚æœæ˜¯è¾¹æƒï¼Œé‚£ä¹ˆ d(x,y)=Sx+Syâˆ’2Ã—SLCA(x,y)d(x,y)=S_x+S_y-2\\times S_{LCA(x,y)}d(x,y)=Sxâ€‹+Syâ€‹âˆ’2Ã—SLCA(x,y)â€‹ï¼Œ å¦‚æœæ˜¯ç‚¹æƒï¼Œé‚£ä¹ˆ d(x,y)=Sx+Syâˆ’SLCA(x,y)âˆ’Sfa[LCA(x,y)]d(x,y)=S_x+S_y-S_{LCA(x,y)}-S_{fa[LCA(x,y)]}d(x,y)=Sxâ€‹+Syâ€‹âˆ’SLCA(x,y)â€‹âˆ’Sfa[LCA(x,y)]â€‹ï¼ˆå› ä¸º LCA å¤„åªèƒ½å‡ä¸€æ¬¡ï¼‰ã€‚ æ ‘ä¸Šç‚¹å·®åˆ† ä¹Ÿå°±æ˜¯å¯¹äºç‚¹æƒçš„æ ‘ä¸Šå·®åˆ†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç»™å®šè‹¥å¹²æ¡è·¯ç»ï¼Œæ±‚å‡ºæ¯ä¸ªç‚¹ç»è¿‡çš„æ¬¡æ•°ã€‚é‚£ä¹ˆï¼š // s -> t d[s]++, d[t]++; d[lca(s, t)]--, d[fa[lca(s, t)]]--; å½“ç„¶ä¸åŒçš„æ•°å€¼ä¹Ÿå¯ä»¥æ”¹ã€‚ æ¨¡æ¿ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, k, lg[50005], dep[50005]; int f[50005][18], sum[50005]; vector &lt;int> G[50005]; void dfs(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (int i = 0; i &lt; G[x].size(); ++i) if (G[x][i] != fa) dfs(G[x][i], x); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; void get(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; get(y, x); sum[x] += sum[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; dfs(1, 0); while (k--) &#123; int s, t, lca; scanf(\"%d%d\", &amp;s, &amp;t); lca = LCA(s, t); sum[s]++, sum[t]++; sum[lca]--, sum[f[lca][0]]--; &#125; get(1, 0); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, sum[i]); printf(\"%d\\n\", ans); return 0; &#125; æ ‘ä¸Šè¾¹å·®åˆ† è¿˜æ˜¯ç›´æ¥å°†è¾¹å‰ç¼€å’Œæ¬è¿‡æ¥ï¼š d[s]++, d[t]++; d[lca(s, t)] -= 2; DFS åºåˆ— æ ‘åœ¨è¿›è¡Œ DFS æ—¶ï¼Œä¼šæœ‰å…¥æ ˆå‡ºæ ˆçš„é¡ºåºï¼Œè€Œä¸”æ¯ä¸€ä¸ªæ ‘æ°å¥½å…¥æ ˆä¸€æ¬¡ã€å‡ºæ ˆä¸€æ¬¡ã€‚è¿™æ ·äº§ç”Ÿçš„åºåˆ—å°±æ˜¯æ ‘çš„ æ¬§æ‹‰åºã€‚å¦‚æœåªè®°å½•ä¸€æ¬¡èŠ‚ç‚¹ï¼Œé‚£ä¹ˆäº§ç”Ÿçš„æ˜¯ DFS åºï¼Œè®¿é—®åˆ°é¡ºåºè®°ä¸ºæ—¶é—´æˆ³ dfnã€‚ æ¦‚è¿° æ¯”å¦‚è¿™æ ·ä¸€æ£µæ ‘ï¼š å®ƒçš„æ¬§æ‹‰åºå°±æ˜¯ 1 4 4 2 6 8 8 6 5 5 2 3 7 7 3 1ã€‚ å¯ä»¥å‘ç°ï¼Œæ¬§æ‹‰åºæœ‰ä»¥ä¸‹æ€§è´¨ï¼š è‹¥æ ‘çš„å¤§å°ä¸º nnnï¼Œé‚£ä¹ˆæ¬§æ‹‰åºçš„é•¿åº¦å°±ç­‰äº 2n2n2nï¼Œæ¯ä¸ªæ•°æ°å¥½å‡ºç°äº†ä¸¤æ¬¡ã€‚ æ¯æ£µå­æ ‘ xxx åœ¨æ¬§æ‹‰åºä¸­ä¸€å®šæ˜¯è¿ç»­çš„ä¸€æ®µï¼ŒèŠ‚ç‚¹ xxx ä¸€å®šåŒæ—¶åœ¨è¿™ä¸ªè¿ç»­æ®µçš„ä¸¤ç«¯ã€‚ è€Œ DFS åºå¯ä»¥ä¸æ ‘ä¸Šå·®åˆ†ç»“åˆèµ·æ¥ï¼Œå®ç°æ»¡è¶³å·®åˆ†ä¿¡æ¯çš„æ ‘ä¸Šä¿¡æ¯é«˜æ•ˆç»´æŠ¤ã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ DFS åºçš„åº”ç”¨ï¼š å•ç‚¹ä¿®æ”¹ æ¨¡æ¿ã€‚ å•ç‚¹å¢åŠ ï¼ŒæŸ¥è¯¢å­æ ‘å’Œã€‚ æ ¹æ® DFS åºåˆ—çš„æ€§è´¨ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ ‘ä¸Šä¿¡æ¯è½¬åŒ–åˆ°é“¾ä¸Šæ¥ç»´æŠ¤ã€‚æ€ä¹ˆè½¬å‘¢ï¼Ÿå¯ä»¥å‘ç°ï¼Œå­æ ‘ä¸€å®šæ˜¯åœ¨æ ¹åé¢è¿ç€çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬è®°å½• sizsizsiz å¤§å°å°±å¯ä»¥äº†ã€‚ æ¥ä¸‹æ¥å°±æ˜¯ Fenwick æ ‘äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; int n, m, root; int a[1000005], siz[1000005]; int dfn[1000005], num = 0; vector &lt;int> G[1000005]; i64 C[1000005]; void add(int x, int k) &#123; while (x &lt;= n) &#123; C[x] += k; x += lowbit(x); &#125; &#125; i64 sum(int x) &#123; i64 res = 0; while (x) &#123; res += C[x]; x -= lowbit(x); &#125; return res; &#125; void dfs(int x, int fa) &#123; dfn[x] = ++num; siz[x] = 1; add(num, a[x]); for (auto y : G[x]) &#123; if (y == fa) continue; dfs(y, x); siz[x] += siz[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;root); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(root, 0); while (m--) &#123; int op, a, x; scanf(\"%d%d\", &amp;op, &amp;a); if (op == 1) &#123; scanf(\"%d\", &amp;x); add(dfn[a], x); &#125; else &#123; printf(\"%lld\\n\", sum(dfn[a] + siz[a] - 1) - sum(dfn[a] - 1)); &#125; &#125; return 0; &#125; å­æ ‘ä¿®æ”¹ æ¨¡æ¿ã€‚ å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å¢åŠ  xxxï¼Œå­æ ‘èŠ‚ç‚¹å’Œã€‚ å®é™…ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œæˆ‘ä»¬åªéœ€è¦å°†æ ‘çŠ¶æ•°ç»„æ›¿æ¢ä¸ºçº¿æ®µæ ‘ï¼ˆå½“ç„¶ï¼Œåˆ©ç”¨æ‹†åˆ†ä¿¡æ¯æ ‘çŠ¶æ•°ç»„ä¹Ÿå¯ä»¥åšï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; int n, m, root; int a[1000005], siz[1000005]; int dfn[1000005], idx[1000005], num = 0; vector &lt;int> G[1000005]; i64 T[4000005]; int tag[4000005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[idx[l]], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; inline void pushdown(int o, int l, int r) &#123; if (!tag[o]) return; int mid = l + r >> 1; T[o &lt;&lt; 1] += 1ll * (mid - l + 1) * tag[o], T[o &lt;&lt; 1 | 1] += 1ll * (r - mid) * tag[o]; tag[o &lt;&lt; 1] += tag[o], tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o] += 1ll * (r - l + 1) * k, tag[o] += k, void(); int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; i64 query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; i64 res = 0; pushdown(o, l, r); if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; void dfs(int x, int fa) &#123; dfn[x] = ++num; idx[num] = x; siz[x] = 1; for (auto y : G[x]) &#123; if (y == fa) continue; dfs(y, x); siz[x] += siz[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;root); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(root, 0); build(1, 1, n); while (m--) &#123; int op, a, x; scanf(\"%d%d\", &amp;op, &amp;a); if (op == 1) &#123; scanf(\"%d\", &amp;x); update(1, 1, n, dfn[a], dfn[a] + siz[a] - 1, x); &#125; else &#123; printf(\"%lld\\n\", query(1, 1, n, dfn[a], dfn[a] + siz[a] - 1)); &#125; &#125; return 0; &#125; é“¾ä¸Šä¿®æ”¹ è¿™é‡Œç®€å•æä¸€ä¸‹ï¼Œæœ‰å…´è¶£å¯ä»¥å†™ä¸€ä¸‹æ¨¡æ¿ã€‚ æˆ‘ä»¬è¯´è¿‡ï¼ŒDFS åºç»´æŠ¤çš„ä¾æ—§æ˜¯å‰ç¼€å’Œï¼Œæ‰€ä»¥åˆ©ç”¨æ ‘ä¸Šå·®åˆ†çš„æ–¹å¼ï¼Œé…åˆæ ‘çŠ¶æ•°ç»„å¯ä»¥å¿«é€Ÿä¿®æ”¹ä¸æŸ¥è¯¢ï¼Œä¼šæ¯”é‡é“¾å‰–åˆ†å°‘ä¸€ä¸ª logâ¡\\loglogã€‚ ä½†æ˜¯å½“ç»´æŠ¤çš„å†…å®¹ä¸æ»¡è¶³å·®åˆ†çš„åŒºé—´å¯å‡æ€§ï¼ŒDFS åºå°±åšä¸äº†äº†ã€‚ å¿«é€Ÿ LCA DFS åºæ±‚ LCA æ˜¯å¸¸ç”¨æ–¹å¼ä¸­æœ€å¿«çš„ LCA ç®—æ³•ï¼Œå¹¶ä¸”æ˜¯åœ¨çº¿çš„ã€‚å¯ä»¥åšåˆ° O(nlogâ¡n)O(n\\log n)O(nlogn) é¢„å¤„ç†ï¼ŒO(1)O(1)O(1) æŸ¥è¯¢ã€‚è€Œæ¬§æ‹‰åºæ±‚ LCA åˆ™æœ‰ 222 å€çš„å¸¸æ•°ï¼Œè‡³äºåˆ©ç”¨ç¬›å¡å°”æ ‘çš„ O(n)O(n)O(n) é¢„å¤„ç†åšæ³•åˆ™å¹¶ä¸ä½¿ç”¨ï¼Œå› ä¸ºå¤§éƒ¨åˆ†æ ‘ä¸Šé—®é¢˜éƒ½æ˜¯å¸¦ logâ¡\\loglog çš„ã€‚å°¤å…¶æ˜¯å¯¹äºè™šæ ‘è¿™è¯¢é—® LCA æ¬¡æ•°æå¤šçš„ä¸œè¥¿ï¼ŒDFS åºçš„ä¼˜åŠ¿å¾ˆå¤§ã€‚ è€ƒè™‘æ ‘ä¸Šçš„ä¸¤ä¸ªèŠ‚ç‚¹ u,vu,vu,v å’Œå…¶ LCA dddï¼Œddd æ˜¾ç„¶åœ¨ u,vu,vu,v ä¹‹å‰å‡ºç°ã€‚ å¦‚æœ uuu ä¸æ˜¯ vvv çš„ç¥–å…ˆï¼Œæˆ‘ä»¬åªéœ€è¦æ±‚å‡º uuu å’Œ vvv çš„ DFS åºä¹‹é—´æ·±åº¦æœ€å°çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå®ƒçš„çˆ¶äº²å°±æ˜¯ dddã€‚ å¦‚æœæ˜¯ï¼Œé‚£ä¹ˆç›´æ¥ä»¤ uuu å˜æˆ dfn æ¯”å®ƒå¤§ 111 çš„èŠ‚ç‚¹ï¼Œå°±è½¬åŒ–æˆäº†ä¸Šä¸€ç§æƒ…å†µã€‚ åªéœ€è¦ç‰¹åˆ¤æ‰ u=vu=vu=vï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥æ”¹å˜ uuu çš„ DFS åºäº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int N = 5e5 + 5; int n, m, root, num, dfn[N], dep[N], lg[N], mi[20][N]; vector&lt;int> G[N]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; // è¿™ä¸ª inline æœ‰ç”¨ void dfs(int x, int fa) &#123; mi[0][dfn[x] = ++num] = fa, dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int d = lg[v - u]; return get(mi[d][u + 1], mi[d][v - (1 &lt;&lt; d) + 1]); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;root); for (int i = 2; i &lt;= n; i++) lg[i] = lg[i >> 1] + 1; for (int i = 1, u, v; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs(root, 0); for (int i = 1; i &lt;= lg[n]; i++) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; j++) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1, u, v; i &lt;= m; i++) scanf(\"%d%d\", &amp;u, &amp;v), printf(\"%d\\n\", LCA(u, v)); return 0; &#125; æ ‘é“¾ä¸æ ‘é“¾å‰–åˆ† æˆ‘ä»¬å­¦è¿‡çš„å¾ˆå¤šå†…å®¹ï¼Œæ¯”å¦‚çº¿æ®µæ ‘ï¼Œéƒ½åªèƒ½å¤„ç†åºåˆ—ï¼Œä¹Ÿå°±æ˜¯é“¾ä¸Šçš„é—®é¢˜ã€‚å½“å®ƒè·‘åˆ°äº†æ ‘ä¸Šï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ DFS åºåˆ—æ¥è¿›è¡Œå¤„ç†ã€‚ä½†æ˜¯å½“ç»´æŠ¤çš„ä¿¡æ¯ä¸æ»¡è¶³å·®åˆ†æ€§è´¨åï¼ŒDFS åºå°±æ˜¾å¾—æ— åŠ›äº†ã€‚è¿™æ˜¯å€™æ€ä¹ˆåŠï¼Ÿè¦å¯¹æ ‘é“¾è¿›è¡Œå¤„ç†äº†ã€‚ æ¦‚å¿µ æˆ‘ä»¬å…ˆç®€å•ä»‹ç»ä¸€ä¸‹ç›¸å…³æ¦‚å¿µã€‚ æ ‘é“¾æ˜¯æŒ‡æ ‘ä¸Šçš„ä¸€æ¡é“¾ï¼Œæ ‘é“¾å‰–åˆ†å°±æ˜¯å°†æ•´æ£µæ ‘å‰–åˆ†æˆè‹¥å¹²æ¡é“¾ï¼Œä½¿å®ƒç»„åˆæˆçº¿æ€§ç»“æ„ï¼Œç„¶åå¯ä»¥åœ¨çº¿æ€§ç»“æ„ä¸Šå·¥ä½œçš„å¼ºå¤§æ•°æ®ç»“æ„å°±å¯ä»¥æ´¾ä¸Šç”¨åœºäº†ï¼Œä¹Ÿç®€ç§°æ ‘å‰–ã€‚ æ ‘é“¾å‰–åˆ†æœ‰å¤šç§å½¢å¼ï¼Œæ¯”å¦‚é‡é“¾å‰–åˆ†ï¼Œé•¿é“¾å‰–åˆ†å’Œå®é“¾å‰–åˆ†ï¼Œå…¶ä¸­é‡é“¾å‰–åˆ†æœ€ä¸ºå¸¸ç”¨ï¼Œå¤§éƒ¨åˆ†æ ‘å‰–æŒ‡çš„éƒ½æ˜¯å®ƒã€‚ è¿™é‡Œåªä»‹ç»æœ€å¸¸ç”¨çš„é‡é“¾å‰–åˆ†ï¼Œé•¿é“¾å‰–åˆ†è¯·å‚è€ƒã€Šå¤æ‚æ ‘å½¢é—®é¢˜ã€‹ã€‚ é‡é“¾å‰–åˆ† æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹è¿™ä¸ªé—®é¢˜ï¼š ä½ éœ€è¦å†™ä¸€ç§æ•°æ®ç»“æ„ï¼Œæ”¯æŒåŒºé—´ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢ã€‚ è¿™ä¸ªæˆ‘å½“ç„¶ä¼šï¼ç›´æ¥çº¿æ®µæ ‘æ•²ä¸Šå»ä¸ä¹…å®Œäº‹äº†å˜›ï¼ é‚£ä¹ˆå†æ¥ä¸€ä¸ªï¼š ç»™å‡ºä¸€æ£µæ ‘ï¼Œæ”¯æŒé“¾ä¸Šä¿®æ”¹ï¼Œé“¾ä¸ŠæŸ¥è¯¢ï¼Œå­æ ‘ä¿®æ”¹ï¼Œå­æ ‘æŸ¥è¯¢ã€‚ è¿™æ˜¯ä»€ä¹ˆï¼Ÿ è¿™ä¸ªé¢˜æ˜¯æœ‰çš„ï¼Œæ¨¡æ¿ã€‚ æˆ‘ä»¬ä¸ä¼šè¿™ç§é¢˜ï¼Œæˆ‘ä»¬åªä¼šåœ¨é“¾ä¸Šåšï¼Œé‚£å°±éœ€è¦ä½¿ç”¨æ ‘é“¾å‰–åˆ†ã€‚ é‡é“¾å‰–åˆ†å¯ä»¥å°†æ ‘ä¸Šçš„ä»»æ„ä¸€æ¡è·¯å¾„åˆ’åˆ†æˆé•¿åº¦ä¸è¶…è¿‡ O(logâ¡n)O(\\log n)O(logn) çš„è¿ç»­é“¾ï¼Œæ¯æ¡é“¾ä¸Šçš„ç‚¹æ·±åº¦äº’ä¸ç›¸åŒï¼ˆå³è‡ªåº•å‘ä¸Šçš„ä¸€æ¡é“¾ï¼Œé“¾ä¸Šæ‰€æœ‰ç‚¹çš„ LCA ä¸ºé“¾çš„æ·±åº¦å°çš„é‚£ä¸ªç«¯ç‚¹ï¼‰ã€‚ æˆ‘ä»¬é¦–å…ˆéœ€è¦äº†è§£å‡ ä¸ªæ¦‚å¿µï¼š å­æ ‘çš„å¤§å°ï¼šå­æ ‘ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚ é‡å­èŠ‚ç‚¹ï¼ˆé‡èŠ‚ç‚¹ï¼‰ï¼šè¡¨ç¤ºå…¶å­èŠ‚ç‚¹ä¸­å­æ ‘æœ€å¤§çš„å­ç»“ç‚¹ã€‚å¦‚æœæœ‰å¤šä¸ªå­æ ‘æœ€å¤§çš„å­ç»“ç‚¹ï¼Œå–å…¶ä¸€ã€‚å¦‚æœæ²¡æœ‰å­èŠ‚ç‚¹ï¼Œå°±æ— é‡å­èŠ‚ç‚¹ã€‚ è½»å­èŠ‚ç‚¹ï¼ˆè½»èŠ‚ç‚¹ï¼‰ï¼šé™¤äº†é‡å­èŠ‚ç‚¹å¤–çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚ç‰¹åˆ«åœ°ï¼Œæ ‘æ ¹æ˜¯è½»èŠ‚ç‚¹ã€‚ é‡è¾¹ï¼šè¿æ¥èŠ‚ç‚¹åˆ°å®ƒçš„é‡å­èŠ‚ç‚¹çš„è¾¹ã€‚ è½»è¾¹ï¼šé™¤äº†é‡è¾¹ä¹‹å¤–çš„æ‰€æœ‰è¾¹ã€‚ é‡é“¾ï¼šè‹¥å¹²æ¡é¦–å°¾è¿æ¥çš„é‡è¾¹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€æ¡é‡é“¾çš„å¼€å¤´æ˜¯ä¸€ä¸ªè½»èŠ‚ç‚¹ï¼Œå‰©ä¸‹çš„éƒ½æ˜¯é‡èŠ‚ç‚¹ã€‚ç‰¹åˆ«åœ°ï¼Œä¸€ä¸ªè½å•çš„èŠ‚ç‚¹ä¹Ÿæ˜¯é‡é“¾ã€‚ è¿™æ ·æ•´æ£µæ ‘å°±è¢«å‰–åˆ†æˆè‹¥å¹²æ¡é‡é“¾ï¼Œå¯ä»¥è¯æ˜é“¾çš„è§„æ¨¡æ˜¯ O(logâ¡n)O(\\log n)O(logn) çš„ã€‚ å®ç°æ—¶è¦é€šè¿‡ä¸¤æ¬¡ dfsï¼Œå¤§æ¦‚åƒè¿™æ ·ï¼š int f[100005], son[100005], top[100005]; // son æŒ‡é‡å„¿å­ï¼Œæ²¡æœ‰ä¸º -1ï¼›top æŒ‡é‡é“¾çš„é¡¶ç«¯èŠ‚ç‚¹çš„æ ‡å· int dep[100005], siz[100005], dfn[100005], tot = 0; // dfn æŒ‡æ—¶é—´æˆ³ vector &lt;int> G[100005]; void dfs1(int x, int fa) &#123; dep[x] = dep[fa] + 1; f[x] = fa; siz[x] = 1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) // topf è®°å½•è¿™ä¸ªé‡é“¾çš„é¡¶ç‚¹ &#123; dfn[x] = ++tot; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); // ä¼˜å…ˆå¤„ç†é‡é“¾ for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); // éå†è½»å„¿å­ &#125; æ³¨æ„åˆ°é‡é“¾çš„å¤„ç†æ€»æ˜¯ä¼˜å…ˆçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé‡é“¾å†…çš„æ—¶é—´æˆ³ç¼–å·æ˜¯è¿ç»­çš„ï¼Œé‚£ä¹ˆå°±å†³å®šäº†æˆ‘ä»¬ç»´æŠ¤çš„æ—¶å€™ç›´æ¥å¯¹åº”äº†ä¸€æ®µåºåˆ—ä¸Šçš„åŒºé—´ã€‚ å»ºç«‹ä¸€æ£µçº¿æ®µæ ‘ï¼Œä»¥ xxx åˆ° yyy çš„æœ€çŸ­è·¯å¾„ä¸ŠåŠ ä¸Š zzz ä¸ºä¾‹ï¼Œåƒè¿™æ ·ï¼š while (top[x] != top[y]) // å¦‚æœå®ƒä»¬ä¸åœ¨ä¸€æ¡é‡é“¾ä¸Š &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); // è¦è®¡ç®—æ·±çš„èŠ‚ç‚¹ update(1, 1, n, dfn[top[x]], dfn[x], z); // æ›´æ–° x = f[top[x]]; // è·³ä¸Šæ¥ï¼Œæ³¨æ„é‡é“¾çš„å¤´éƒ¨å·²ç»ä¿®æ”¹è¿‡äº†ï¼Œè·³åˆ°é‡é“¾å¤´çš„çˆ¶äº²ä¸Š &#125; if (dep[x] > dep[y]) swap(x, y); update(1, 1, n, dfn[x], dfn[y], z); // ç°åœ¨å·²ç»åœ¨ä¸€æ¡é‡é“¾ä¸Šï¼Œæ›´æ–° å‘æ²¡å‘ç°è¿™ä¸ªå¤„ç†ç‰¹åˆ«åƒ LCA çš„æ±‚è§£ï¼Ÿæ²¡é”™ï¼ŒLCA ç¡®å®ä¹Ÿå¯ä»¥ç”¨æ ‘é“¾å‰–åˆ†æ¥æ±‚è§£ï¼Œä½†æ˜¯ä¸å¦‚å€å¢ç®€å•ï¼Œé™¤éæ°å¥½è¿™é“é¢˜ç›®éœ€è¦ç”¨åˆ°æ ‘é“¾å‰–åˆ†ï¼Œæˆ‘ä»¬æ‰ä¼šä½¿ç”¨æ ‘é“¾å‰–åˆ†æ¥æ±‚è§£ LCAã€‚ é‚£ä¹ˆå¯¹äºå­æ ‘çš„æ“ä½œå‘¢ï¼Ÿç”±äºæ˜¯æ·±åº¦ä¼˜å…ˆéå†ï¼Œæ‰€ä»¥ä¸€æ£µå­æ ‘å†…çš„æ—¶é—´æˆ³ç¼–å·ä¹Ÿæ˜¯è¿ç»­çš„ï¼ˆä¾ç„¶å…·æœ‰ DFS åºçš„æ€§è´¨ï¼‰ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤ï¼š update(1, 1, n, dfn[x], dfn[x] + siz[x] - 1, k); // åˆ©ç”¨å­æ ‘çš„å¤§å°ç›´æ¥è®¡ç®— é‚£ä¹ˆå®Œæ•´ä»£ç å°±å¾ˆç®€å•äº†ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, m, root, P; int w[100005], f[100005], son[100005], top[100005]; int dep[100005], siz[100005], dfn[100005], tot = 0, a[100005]; vector &lt;int> G[100005]; void dfs1(int x, int fa) &#123; dep[x] = dep[fa] + 1; f[x] = fa; siz[x] = 1; int maxx = -1; for (auto y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > maxx) son[x] = y, maxx = siz[y]; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++tot; top[x] = topf; a[tot] = w[x]; if (son[x] == -1) return; dfs2(son[x], topf); for (auto y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int T[400005], tag[400005]; inline void maintain(int o) &#123; T[o] = (T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]) % P; &#125; inline void pushdown(int o, int l, int r) &#123; if (!tag[o]) return; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; tag[ls] = (tag[ls] + tag[o]) % P, tag[rs] = (tag[rs] + tag[o]) % P; T[ls] = (T[ls] + 1ll * tag[o] * (mid - l + 1)) % P, T[rs] = (T[rs] + 1ll * tag[o] * (r - mid)) % P; tag[o] = 0; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o] = a[l] % P; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; T[o] = (T[o] + 1ll * k * (r - l + 1)) % P; tag[o] = (tag[o] + k) % P; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); maintain(o); &#125; int query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; pushdown(o, l, r); int mid = l + r >> 1, res = 0; if (ql &lt;= mid) res = (res + query(o &lt;&lt; 1, l, mid, ql, qr)) % P; if (mid &lt; qr) res = (res + query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr)) % P; return res; &#125; int main(void) &#123; memset(son, 0xff, sizeof(son)); scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;root, &amp;P); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", w + i); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs1(root, 0); dfs2(root, root); build(1, 1, n); while (m--) &#123; int k, x, y, z; scanf(\"%d\", &amp;k); if (k == 1) &#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); z %= P; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); update(1, 1, n, dfn[top[x]], dfn[x], z); x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); update(1, 1, n, dfn[x], dfn[y], z); &#125; else if (k == 2) &#123; scanf(\"%d%d\", &amp;x, &amp;y); int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ans = (ans + query(1, 1, n, dfn[top[x]], dfn[x])) % P; x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); ans = (ans + query(1, 1, n, dfn[x], dfn[y])) % P; printf(\"%d\\n\", ans); &#125; else if (k == 3) &#123; scanf(\"%d%d\", &amp;x, &amp;k); update(1, 1, n, dfn[x], dfn[x] + siz[x] - 1, k); &#125; else &#123; scanf(\"%d\", &amp;x); printf(\"%d\\n\", query(1, 1, n, dfn[x], dfn[x] + siz[x] - 1)); &#125; &#125; return 0; &#125; ç®—æ³•ç†è®ºå®è·µå¤æ‚åº¦ä¸º O(nlogâ¡2n)O(n\\log^2 n)O(nlog2n)ï¼Œä½†å®é™…ä¸Šè¿œè¿œè¾¾ä¸åˆ°ä¸Šç•Œï¼Œé‡é“¾å‰–åˆ†çš„å¸¸æ•°å¾ˆå°ã€‚ ä½†å³ä½¿å¦‚æ­¤ï¼Œæ ‘é“¾å‰–åˆ†ä¹Ÿæ˜¯æ¯” DFS åºæ…¢çš„ã€‚å¦‚æœèƒ½ä½¿ç”¨ DFS åºï¼Œæ›´æ¨èç”¨å®ƒã€‚ æ ‘é“¾å‰–åˆ†æ±‚ LCA ä¹‹å‰ç»´æŠ¤é“¾çš„è¿‡ç¨‹å¾ˆåƒæ±‚ LCA å¾€ä¸Šè·³çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥é‡é“¾å‰–åˆ†ä¹Ÿå¯ä»¥ç”¨æ¥æ±‚ LCAã€‚ int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; // ä¸åœ¨ä¸€æ¡é‡é“¾ä¸Š if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; ä¸€èˆ¬æ¥è®²æ ‘é“¾å‰–åˆ†ä¼šæ¯”å€å¢ç®—æ³•å¿«ä¸€ç‚¹ï¼Œå¸¸æ•°ä¹Ÿå¾ˆå°ï¼ˆæƒ³æƒ³é‚£ä¸ªäºŒç»´æ•°ç»„å§ï¼‰ï¼Œç”šè‡³ä¸ä¼šæ¯” O(1)O(1)O(1) LCA æ…¢ï¼ˆå› ä¸ºæœ‰å¯»å€ï¼‰ã€‚ Problemset æˆ‘ä»¬æ¥çœ‹ä¸€äº›æœ‰è¶£çš„é¢˜ç›®ï¼Œå‰é¢çš„ä¸€äº›é¢˜ç›®éƒ½å¾ˆç®€å•ï¼Œåé¢çš„éƒ¨åˆ†é¢˜ç›®ç›¸å½“å¤æ‚ã€‚ ç®€å•æ ‘å½¢é—®é¢˜ ä¸æ¶‰åŠä»€ä¹ˆç®—æ³•ï¼Œåªéœ€è¦æ ‘çš„æœ‰å…³çŸ¥è¯†ï¼Œä»¥åŠæ±‚è§£æ ‘çš„ç›´å¾„å’Œæ ‘çš„é‡å¿ƒçš„æ–¹æ³•ç­‰å³å¯ã€‚ [JLOI2012] æ ‘ Portal. ç›´æ¥ dfs éå†æ ‘å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, c, ans = 0, a[100005]; vector &lt;int> son[100005]; void dfs(int o, int sum) &#123; if (sum == c) return ++ans, void(); if (sum > c) return; for (auto x : son[o]) dfs(x, sum + a[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;c); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); son[u].push_back(v); &#125; for (int i = 1; i &lt;= n; ++i) dfs(i, a[i]); printf(\"%d\\n\", ans); return 0; &#125; [YsOI2020] æ¤æ ‘ Portal. ç±»ä¼¼äºæ±‚æ ‘çš„é‡å¿ƒï¼Œä¸è¿‡è¦ç»Ÿè®¡çš„æ˜¯å­æ ‘çš„å¤§å°ã€‚æ³¨æ„ 111 å·èŠ‚ç‚¹è‚¯å®šæ˜¯å¯ä»¥çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, s[1000005]; bool flag[1000005]; vector &lt;int> G[1000005]; void dfs(int x, int fa) &#123; int num = 0; s[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; dfs(y, x); s[x] += s[y]; if (!num) num = s[y]; if (num != s[y]) flag[x] = true; &#125; if (x != 1 &amp;&amp; num &amp;&amp; num != n - s[x]) flag[x] = true; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) if (!flag[i]) printf(\"%d \", i); putchar('\\n'); return 0; &#125; [NOIP2014 æé«˜ç»„] è”åˆæƒå€¼ Portal. ç”±äºè·ç¦»ä¸º 222ï¼Œæ‰€ä»¥æšä¸¾æ¯ä¸€ä¸ªç‚¹ï¼Œä¸å®ƒç›¸é‚»çš„ç‚¹ä¸¤ä¸¤äº’ä¸ºè”åˆç‚¹ï¼Œç„¶åä½¿ç”¨ nnn é¡¹å¼çš„å¹³æ–¹è®¡ç®—å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define MOD 10007 using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int W[200005]; vector &lt;int> G[200005]; int main(void) &#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; ++i) W[i] = read(); int anssum = 0, ansmax = 0; for (int i = 1; i &lt;= n; ++i) &#123; int res = 0, ret = 0; int maxx1 = 0, maxx2 = 0; for (int j = 0; j &lt; G[i].size(); ++j) &#123; #define pocket W[G[i][j]] if (pocket > maxx1) maxx2 = maxx1, maxx1 = pocket; else if (pocket > maxx2) maxx2 = pocket; res = (res + pocket) % MOD; ret = (ret + pocket * pocket) % MOD; &#125; anssum = (anssum + res * res % MOD - ret + MOD) % MOD; ansmax = max(ansmax, maxx1 * maxx2); &#125; printf(\"%d %d\\n\", ansmax, anssum); return 0; &#125; [NOI2011] é“è·¯ä¿®å»º Portal. æˆ‘ä»¬é‡‡ç”¨ç±»ä¼¼æ±‚æ ‘çš„é‡å¿ƒçš„æ–¹æ³•ã€‚ç»Ÿè®¡ä¸€æ¡è¾¹çš„è´¹ç”¨æ—¶ï¼Œä¸€éƒ¨åˆ†å¤§å°æ˜¯å­æ ‘çš„å¤§å°ï¼Œå¦ä¸€éƒ¨åˆ†æ˜¯ nnn å‡å»è¿™ä¸ªå­æ ‘çš„å¤§å°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define i64 long long using namespace std; struct edge &#123; int v, d; edge(int v = 0, int d = 0) : v(v), d(d) &#123;&#125; &#125;; int n; i64 ans; int s[1000005]; vector &lt;edge> G[1000005]; void dfs(int x, int fa) &#123; s[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].v, w = G[x][i].d; if (y == fa) continue; dfs(y, x); ans += (i64)w * abs(s[y] - (n - s[y])); s[x] += s[y]; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(edge(v, d)); G[v].push_back(edge(u, d)); &#125; dfs(1, 0); printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P1395] ä¼šè®® Portal. æ ‘ä¸­æ‰€æœ‰ç‚¹åˆ°æŸä¸ªç‚¹çš„è·ç¦»å’Œä¸­ï¼Œåˆ°é‡å¿ƒçš„è·ç¦»å’Œæ˜¯æœ€å°çš„ã€‚æˆ‘ä»¬åªéœ€è¦å…ˆæ±‚å‡ºæ ‘çš„é‡å¿ƒï¼Œç„¶åç”¨ dfs è®¡ç®—è·ç¦»å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, ans = 1e7, pos, s[50005]; vector &lt;int> G[50005]; void dfs(int x, int fa) &#123; s[x] = 1; int max_part = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; dfs(y, x); s[x] += s[y]; max_part = max(max_part, s[y]); &#125; max_part = max(max_part, n - s[x]); if (max_part &lt; ans || (max_part == ans &amp;&amp; x &lt; pos)) &#123; pos = x; ans = max_part; &#125; &#125; int sum = 0, dep[50005]; void dfs2(int x, int fa) &#123; dep[x] = dep[fa] + 1; sum += dep[x]; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; dfs2(y, x); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); dep[0] = -1; dfs2(pos, 0); printf(\"%d %d\\n\", pos, sum); return 0; &#125; LCA çš„ç»¼åˆåº”ç”¨ åŒ…æ‹¬ LCAã€æ ‘ä¸Šå·®åˆ†ç­‰å†…å®¹ã€‚æœ‰çš„æ—¶å€™ä¹Ÿä¼šä¸åˆ«çš„ç®—æ³•ç»¼åˆï¼ˆæ¯”å¦‚äºŒåˆ†ï¼‰ï¼Œä½†ä¸æ¶‰åŠé«˜éš¾çš„ç®—æ³•ã€‚ [Luogu P3938] æ–æ³¢é‚£å¥‘ Portal. æ ‘çš„è§„æ¨¡å¾ˆå¤§ï¼Œä½†æ˜¯æ·±åº¦å¾ˆå°ï¼Œæˆ‘ä»¬è€ƒè™‘ä¸å»ºæ ‘ä½¿ç”¨å‘ä¸Šæ ‡è®°æ³•ã€‚ç”±äº dep è‚¯å®šæ˜¯ç¼–å·è¶Šå¤§çš„èŠ‚ç‚¹è¶Šå¤§ï¼Œå› æ­¤ç°åœ¨çš„é—®é¢˜å°±æ˜¯æœ‰å¦‚ä½•æ±‚è§£ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¸çˆ¸ã€‚ å‘ç°èŠ‚ç‚¹å’Œçˆ¶äº²çš„å·®éƒ½æ˜¯æ–æ³¢é‚£å¥‘æ•°ï¼Œç›´æ¥äºŒåˆ†å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef long long i64; const i64 MAXL = 1e12; i64 f[105] = &#123;0, 1&#125;; int main(void) &#123; int i; for (i = 2;; ++i) &#123; f[i] = f[i - 1] + f[i - 2]; if (f[i] > MAXL) break; &#125; int n; scanf(\"%d\", &amp;n); while (n--) &#123; i64 a, b; scanf(\"%lld%lld\", &amp;a, &amp;b); while (a != b) &#123; if (a > b) swap(a, b); b -= (*(lower_bound(f, f + i + 1, b) - 1)); &#125; printf(\"%lld\\n\", a); &#125; return 0; &#125; [JLOI2014] æ¾é¼ çš„æ–°å®¶ Portal. ç›´æ¥ä½¿ç”¨æ ‘ä¸Šç‚¹å·®åˆ†å³å¯ï¼Œä½†æ˜¯è¦æ³¨æ„å¤„ç†é‡å¤çš„æƒ…å†µã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, a[300005], dep[300005]; int f[300005][35], sum[300005]; vector &lt;int> G[300005]; void dfs(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= 30; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (auto y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 30; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = 30; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; void get(int x, int fa) &#123; for (auto y : G[x]) if (y != fa) &#123; get(y, x); sum[x] += sum[y]; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt; n; ++i) &#123; int lca = LCA(a[i], a[i + 1]); sum[a[i]]++; sum[a[i + 1]]++; sum[lca]--; sum[f[lca][0]]--; &#125; get(1, 0); for (int i = 2; i &lt;= n; ++i) --sum[a[i]]; for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", sum[i]); return 0; &#125; [BJOI2018] æ±‚å’Œ Portal. æ³¨æ„åˆ° kkk çš„èŒƒå›´å¾ˆå°ï¼Œå› æ­¤å¯ä»¥å°†ä¸åŒçš„ kkk åˆ†å¼€æ¥åšï¼Œé‚£ä¹ˆè¿™é“é¢˜å°±æˆäº†æ ‘ä¸Šå‰ç¼€å’Œçš„æ¨¡æ¿é¢˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; const int MOD = 998244353; int n, m, lg[300005]; int f[300005][25], dep[300005]; i64 w[55][300005]; vector &lt;int> G[300005]; void dfs(int x, int fa) &#123; if (fa == 0) dep[x] = 0; else dep[x] = dep[fa] + 1; f[x][0] = fa; w[1][x] = dep[x]; for (int i = 2; i &lt;= 50; ++i) w[i][x] = w[i - 1][x] * dep[x] % MOD; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (auto y : G[x]) if (y != fa) dfs(y, x); &#125; void df5(int x, int fa) &#123; for (auto y : G[x]) if (y != fa) &#123; for (int i = 1; i &lt;= 50; ++i) w[i][y] = (w[i][y] + w[i][x]) % MOD; df5(y, x); &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; dfs(1, 0); df5(1, 0); scanf(\"%d\", &amp;m); while (m--) &#123; int x, y, k; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;k); int lca = LCA(x, y); printf(\"%lld\\n\", ((w[k][x] + w[k][y] - w[k][lca] - w[k][f[lca][0]]) % MOD + MOD) % MOD); &#125; return 0; &#125; [CF519E] A and B and Lecture Rooms Portal. å¦‚æœä¸¤ä¸ªç‚¹ç›¸åŒï¼Œé‚£ä¹ˆæ‰€æœ‰éƒ½å¯ä»¥ã€‚å¦‚æœè¿™ä¸¤ä¸ªç‚¹ä¹‹é—´çš„ç®€å•è·¯å¾„çš„ä¸­ç‚¹ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆæ²¡æœ‰å¯ä»¥çš„ã€‚ å¦åˆ™å‘¢ï¼Ÿå‡è±¡ä¸¤ä¸ªç‚¹å¦‚æœåœ¨åŒä¸€æ·±åº¦ä¸Šï¼Œé‚£ä¹ˆåªæœ‰å…¶ LCA çš„ï¼ŒåŒ…å«ç€ä¸¤ä¸ªç‚¹çš„ä¸¤æ£µå­æ ‘ä¸Šçš„ç‚¹æ˜¯ä¸å¯ä»¥çš„ã€‚ä¸åœ¨åŒä¸€æ·±åº¦ä¸Šï¼Œæ‰¾åˆ°å®ƒä»¬çš„ä¸­ç‚¹ï¼Œç„¶åä¸­ç‚¹çš„å­æ ‘ï¼Œé™¤äº†åŒ…å«è¾ƒæ·±èŠ‚ç‚¹çš„é‚£æ£µå­æ ‘å¤–ï¼Œéƒ½æ˜¯å¯ä»¥çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, lg[100005]; int f[17][100005], dep[100005], siz[100005]; vector&lt;int> G[100005]; void dfs(int x, int fa) &#123; dep[x] = dep[f[0][x] = fa] + 1; siz[x] = 1; for (int i = 1; i &lt;= lg[n]; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x), siz[x] += siz[y]; &#125; int lca(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; void calc(int x, int y) &#123; if (x == y) return printf(\"%d\\n\", siz[1]), void(); int l = lca(x, y); if ((dep[x] + dep[y] - 2 * dep[l]) % 2) return puts(\"0\"), void(); if (dep[x] == dep[y]) &#123; for (int i = lg[n]; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return printf(\"%d\\n\", n - siz[x] - siz[y]), void(); &#125; int up = (dep[x] + dep[y] - 2 * dep[l]) / 2; if (dep[x] &lt; dep[y]) swap(x, y); int x0 = x; for (int i = lg[n]; i >= 0; --i) &#123; if (up >> i &amp; 1) x = f[i][x]; if (up - 1 >> i &amp; 1) x0 = f[i][x0]; &#125; printf(\"%d\\n\", siz[x] - siz[x0]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (scanf(\"%d\", &amp;m); m--; ) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); calc(a, b); &#125; return 0; &#125; [NOIP2015 æé«˜ç»„] è¿è¾“è®¡åˆ’ Portal. åƒè¿™ç§è¦æ±‚æœ€å¤§å€¼æœ€å°çš„é—®é¢˜æ˜¾ç„¶æƒ³åˆ°äºŒåˆ†ç­”æ¡ˆï¼Œç„¶åä½¿ç”¨æ ‘ä¸Šè¾¹å·®åˆ†è¿›è¡Œ check å³å¯ï¼Œå°±æ‰¾ä¸€ä¸ªè™«æ´åœ¨æ‰€æœ‰ä¸æ»¡è¶³æ¡ä»¶çš„è¿è¾“è®¡åˆ’ä¸Šï¼Œå–æœ€å¤§çš„ä¸€ä¸ªæ¥åˆ¤æ–­æ˜¯å¦å¯è¡Œã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; struct edge &#123; int v, d; edge(int v = 0, int d = 0) : v(v), d(d) &#123;&#125; &#125;; int n, m, lg[300005]; int dep[300005], f[300005][20], dis[300005]; int s[300005], t[300005], lca[300005], dist[300005], C[300005]; int maxlen = 0, sum = 0, val[300005], ans; vector &lt;edge> G[300005]; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1, f[x][0] = fa; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].v, w = G[x][i].d; if (y == fa) continue; dis[y] = dis[x] + w, val[y] = w; dfs(y, x); &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; void get(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].v; if (y == fa) continue; get(y, x); C[x] += C[y]; &#125; &#125; bool P(int x) &#123; // æ‰€æœ‰è¿è¾“è®¡åˆ’éƒ½ä¸è¶…è¿‡ x int cnt = 0, maxdis = 0; memset(C, 0, sizeof(C)); for (int i = 1; i &lt;= m; ++i) if (dist[i] > x) &#123; C[s[i]]++, C[t[i]]++, C[lca[i]] -= 2; ++cnt; &#125; if (cnt == 0) return true; get(1, 0); for (int i = 1; i &lt;= n; ++i) if (C[i] == cnt) maxdis = max(maxdis, val[i]); if (maxlen - maxdis &lt;= x) return true; return false; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, u, v, d; i &lt; n; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(edge(v, d)), G[v].push_back(edge(u, d)); &#125; for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; dfs(1, 0); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", s + i, t + i); lca[i] = LCA(s[i], t[i]); dist[i] = dis[s[i]] + dis[t[i]] - 2 * dis[lca[i]]; sum += dist[i]; maxlen = max(maxlen, dist[i]); &#125; int L = -1, R = 300000005; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) R = mid; else L = mid; &#125; printf(\"%d\\n\", R); return 0; &#125; [NOIP2013 æé«˜ç»„] è´§è½¦è¿è¾“ Portal. ç›´è§‰å‘Šè¯‰æˆ‘ä»¬ï¼Œèµ°çš„è·¯åº”è¯¥åœ¨æœ€å¤§ç”Ÿæˆæ ‘ä¸Šã€‚é‚£æˆ‘ä»¬å…ˆæ±‚å‡ºç”Ÿæˆæ ‘ï¼Œç„¶åé¢„å¤„ç† LCAï¼Œè¦è®° w[x][i] ä»£è¡¨ xxx å‘ä¸Šè¹¦ 2i2^i2i æ¬¡æ‰€é‡åˆ°çš„æœ€å°è¾¹æƒï¼Œç„¶åç›´æ¥åšå°±è¡Œäº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> using namespace std; const int INF = 1e9; struct edge &#123; int u, v, d; edge(int u = 0, int v = 0, int d = 0) : u(u), v(v), d(d) &#123;&#125; bool operator &lt; (const edge &amp;a) const &#123; return d > a.d; &#125; &#125;a[50005]; int n, m, q; int bin[10005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; vector &lt;edge> G[10005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(u, v, d)); &#125; void Kruskal(void) &#123; sort(a + 1, a + m + 1); for (int i = 1; i &lt;= n; ++i) bin[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int x = find(a[i].u), y = find(a[i].v); if (x == y) continue; bin[x] = y; addedge(a[i].u, a[i].v, a[i].d); addedge(a[i].v, a[i].u, a[i].d); &#125; &#125; bool v[10005]; int dep[10005], lg[10005]; int f[10005][15], w[10005][15]; void dfs(int x, int fa) &#123; v[x] = true; dep[x] = dep[fa] + 1; f[x][0] = fa; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1], w[x][i] = min(w[x][i - 1], w[f[x][i - 1]][i - 1]); for (int i = 0; i &lt; G[x].size(); ++i) if (G[x][i].v != fa) &#123; w[G[x][i].v][0] = G[x][i].d; dfs(G[x][i].v, x); &#125; &#125; int LCA(int x, int y) &#123; if (find(x) != find(y)) return -1; if (dep[x] &lt; dep[y]) swap(x, y); int ans = INF; for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) ans = min(ans, w[x][i]), x = f[x][i]; if (x == y) return ans; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) ans = min(&#123;ans, w[x][i], w[y][i]&#125;), x = f[x][i], y = f[y][i]; return min(&#123;ans, w[x][0], w[y][0]&#125;); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;a[i].u, &amp;a[i].v, &amp;a[i].d); Kruskal(); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= n; ++i) if (!v[i]) dfs(i, 0); scanf(\"%d\", &amp;q); while (q--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", LCA(x, y)); &#125; return 0; &#125; [NOIP2016 æé«˜ç»„] å¤©å¤©çˆ±è·‘æ­¥ Portal. ä¸€æ£µåŒ…å« nnn ä¸ªç‚¹çš„æ ‘ï¼Œæœ‰ mmm ä¸ªç©å®¶ï¼Œç¬¬ iii ä¸ªç©å®¶çš„èµ·ç‚¹ä¸º sis_isiâ€‹ï¼Œç»ˆç‚¹ä¸º tit_itiâ€‹ã€‚æ‰€æœ‰ç©å®¶åœ¨ç¬¬ 000 ç§’åŒæ—¶ä»è‡ªå·±çš„èµ·ç‚¹å‡ºå‘ï¼Œä»¥æ¯ç§’è·‘ä¸€æ¡è¾¹çš„é€Ÿåº¦å‘ç€ç»ˆç‚¹è·‘å»ã€‚æ¯ä¸ªç»“ç‚¹ä¸Šéƒ½æ”¾ç½®äº†ä¸€ä¸ªè§‚å¯Ÿå‘˜ã€‚åœ¨ç»“ç‚¹ jjj çš„è§‚å¯Ÿå‘˜ä¼šé€‰æ‹©åœ¨ç¬¬ wjw_jwjâ€‹ ç§’è§‚å¯Ÿç©å®¶ï¼Œä¸€ä¸ªç©å®¶èƒ½è¢«è¿™ä¸ªè§‚å¯Ÿå‘˜è§‚å¯Ÿåˆ°å½“ä¸”ä»…å½“è¯¥ç©å®¶æ°å¥½åœ¨ç¬¬ wjw_jwjâ€‹ ç§’ä¹Ÿæ­£å¥½åˆ°è¾¾äº†ç»“ç‚¹ jjj ã€‚é—®æ¯ä¸ªè§‚å¯Ÿå‘˜ä¼šè§‚å¯Ÿåˆ°å¤šå°‘äººï¼Ÿ ä¸€ä¸ªç©å®¶èƒ½å¤Ÿè¢«è§‚å¯Ÿå‘˜ xxx è§‚å¯Ÿåˆ°ï¼Œå½“ä¸”ä»…å½“ï¼š è¿™ä¸ªè§‚å¯Ÿå‘˜åœ¨ [s,LCA(s,t)][s,LCA(s,t)][s,LCA(s,t)] ä¸Šï¼Œé‚£ä¹ˆéœ€è¦æ»¡è¶³ dep[s]âˆ’dep[x]=w[x]dep[s]-dep[x]=w[x]dep[s]âˆ’dep[x]=w[x]ï¼Œç›¸å½“äº dep[s]=dep[x]+w[x]dep[s]=dep[x]+w[x]dep[s]=dep[x]+w[x]ã€‚ è¿™ä¸ªè§‚å¯Ÿå‘˜åœ¨ (LCA(s,t),t](LCA(s,t),t](LCA(s,t),t] ä¸Šï¼Œé‚£ä¹ˆéœ€è¦æ»¡è¶³ dep[s]+dep[x]âˆ’2Ã—dep[LCA(s,t)]=w[x]dep[s]+dep[x]-2\\times dep[LCA(s,t)]=w[x]dep[s]+dep[x]âˆ’2Ã—dep[LCA(s,t)]=w[x]ï¼Œç›¸å½“äº dep[s]âˆ’2Ã—dep[LCA(s,t)]=w[x]âˆ’dep[x]dep[s]-2\\times dep[LCA(s,t)]=w[x]-dep[x]dep[s]âˆ’2Ã—dep[LCA(s,t)]=w[x]âˆ’dep[x]ã€‚ è¿™ä¸ªæ¨¡å‹å°±å¾ˆæ¸…æ™°äº†ï¼Œå› ä¸ºå³é¢çš„ä¿¡æ¯åªå’Œè§‚å¯Ÿå‘˜çš„ä½ç½®æœ‰å…³ã€‚å› æ­¤å¯¹äºæ¯ä¸€ä¸ªç©å®¶ï¼Œæˆ‘ä»¬éƒ½ä½¿ç”¨æ ‘ä¸Šå·®åˆ†çš„æ€è·¯ã€‚å°†ç©å®¶æ‹†åˆ†æˆä¸¤ä¸ªï¼ˆä¸€ä¸ªä» sss åˆ° lcalcalcaï¼Œä¸€ä¸ªä» ttt åˆ° lcalcalcaï¼‰ï¼Œç„¶åæŠŠå·®åˆ†ç»´æŠ¤æ“ä½œï¼Œç»™æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½åŠ ä¸Šä¸€ç§â€œç‰©å“â€ã€‚æ”¾ç½®ç›¸åº”èŠ‚ç‚¹ç¼–å·çš„åˆ° STL vector ä¸­ã€‚ç„¶åè¿›è¡Œ DFSã€‚ å»ºç«‹æ•°ç»„ c1,c2c1,c2c1,c2 æ¥ç»´æŠ¤æ ‘ä¸Šå‰ç¼€å’Œï¼ˆå› ä¸ºæœ‰ä¸¤ç§ï¼Œåˆ†å¼€ç»´æŠ¤æ¯”è¾ƒæ–¹ä¾¿ï¼‰ã€‚ä½¿ç”¨ DFS æ¥ç»Ÿè®¡æ ‘ä¸Šå‰ç¼€å’Œï¼Œåˆšæ‰å·²ç»æŠŠå·®åˆ†çš„æ“ä½œæ”¾ç½®åˆ°äº† STL vector ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦å°†è¿™äº›æ“ä½œæ‰§è¡Œï¼Œç»Ÿè®¡å‰å ccc çš„å˜åŒ–å°±å¯ä»¥å¾—åˆ°å½“å‰èŠ‚ç‚¹çš„ç­”æ¡ˆäº†ã€‚ æ³¨æ„ç¼–å·å¯èƒ½æ˜¯è´Ÿçš„ï¼Œéœ€è¦å¹³ç§»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; const int N = 300005; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m, f[N][20]; int dep[N], lg[N]; int w[N], ans[N], c1[N * 2], c2[N * 2]; vector &lt;int> G[N]; vector &lt;int> a1[N], b1[N], a2[N], b2[N]; void dfs(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (auto y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; void dfs2(int x, int fa) &#123; int val1 = c1[w[x] + dep[x]], val2 = c2[w[x] - dep[x] + n]; for (auto y : G[x]) &#123; if (y == fa) continue; dfs2(y, x); &#125; for (auto i : a1[x]) c1[i]++; for (auto i : b1[x]) c1[i]--; for (auto i : a2[x]) c2[i + n]++; for (auto i : b2[x]) c2[i + n]--; ans[x] = c1[w[x] + dep[x]] - val1 + c2[w[x] - dep[x] + n] - val2; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1, u, v; i &lt; n; ++i) &#123; u = read(), v = read(); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) w[i] = read(); while (m--) &#123; int s = read(), t = read(); int lca = LCA(s, t); a1[s].emplace_back(dep[s]); b1[f[lca][0]].emplace_back(dep[s]); a2[t].emplace_back(dep[s] - 2 * dep[lca]); b2[lca].emplace_back(dep[s] - 2 * dep[lca]); &#125; dfs2(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", ans[i]); putchar('\\n'); return 0; &#125; DFS åºåˆ— çœ‹èµ·æ¥é‡é“¾å‰–åˆ†å¯ä»¥ä»£æ›¿ DFS åºåˆ—ï¼Œåªæ˜¯æ…¢äº†ä¸€ç‚¹ã€‚å®é™…ä¸Šä¸æ˜¯ã€‚æœ¬è´¨ä¸Šé‡é“¾å‰–åˆ†ä¹Ÿæ˜¯ä¸€ç§ç‰¹æ®Šçš„ DFS åºåˆ—ï¼Œè€Œé‡é“¾å‰–åˆ†è½¬ä¸ºé“¾å¼ç»“æ„æ¥ç»´æŠ¤ä¹Ÿä¸èƒ½è§£å†³æ‰€æœ‰é—®é¢˜ï¼ˆæ¯”å¦‚æ ‘ä¸Šå€å¢å°±å¾ˆæœ‰ç”¨ï¼‰ã€‚DFS åºåˆ—è‡ªèº«ä¹Ÿæœ‰ä¸€æ¡ç¾å¦™çš„æ€§è´¨ï¼šæ¯ä¸€ä¸ªèŠ‚ç‚¹æ°å¥½å‡ºç°ä¸¤æ¬¡ï¼Œä¸­é—´æ˜¯å­æ ‘ã€‚è¿™é‡Œä»…ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œè¶³å¤Ÿè¯´æ˜é—®é¢˜ã€‚ [CF176E] Archaeology Portal.æœ‰ä¸€æ£µ nnn ä¸ªç‚¹çš„å¸¦æƒæ ‘ï¼Œæ¯ä¸ªç‚¹éƒ½æ˜¯é»‘è‰²æˆ–ç™½è‰²ï¼Œæœ€åˆæ‰€æœ‰ç‚¹éƒ½æ˜¯ç™½è‰²çš„ã€‚æœ‰ qqq ä¸ªè¯¢é—®ï¼šæŠŠç‚¹ xxx ä»ç™½è‰²å˜æˆé»‘è‰²ã€‚æŠŠç‚¹ xxx ä»é»‘è‰²å˜æˆç™½è‰²ã€‚æŸ¥è¯¢é»‘ç‚¹çš„å¯¼å‡ºå­æ ‘ (((ç”¨æœ€å°‘çš„è¾¹æŠŠæ‰€æœ‰çš„é»‘ç‚¹è¿é€šèµ·æ¥çš„æ ‘))) çš„æ€»è¾¹æƒå’Œï¼Œå®é™…ä¸Šå°±æ˜¯è™šæ ‘å¤§å°ã€‚ä¿è¯ 1â‰¤n,qâ‰¤105,1â‰¤xâ‰¤n1 \\leq n, q \\leq 10^5, 1 \\leq x \\leq n1â‰¤n,qâ‰¤105,1â‰¤xâ‰¤nã€‚ ç»´æŠ¤é»‘ç‚¹çš„é›†åˆï¼Œå¹¶å°†å®ƒä»¬æŒ‰ç…§ dfn ä»å°åˆ°å¤§æ’åºï¼Œè®¾æ’åºåçš„åºåˆ—ä¸º fffï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ï¼š 12(d(f1,f2)+â‹¯+d(fnâˆ’1,fn)+d(fn,f1))\\frac{1}{2}(d(f_1,f_2)+\\cdots+d(f_{n-1},f_n)+d(f_n,f_1)) 21â€‹(d(f1â€‹,f2â€‹)+â‹¯+d(fnâˆ’1â€‹,fnâ€‹)+d(fnâ€‹,f1â€‹)) DFS åºåˆ—çš„æ€§è´¨å°±å¯ä»¥è¯æ˜ï¼šå®ƒç›¸å½“äºæ˜¯éå†äº†è¿™äº›ç‚¹ä¸¤éã€‚çŸ¥é“äº†è¿™ä¸€ç‚¹ä¹‹åå°±å¯ä»¥ç›´æ¥ç»´æŠ¤ï¼Œæ’å…¥å’Œåˆ é™¤çš„æ—¶å€™è®¡ç®—å¯¹ç­”æ¡ˆçš„è´¡çŒ®å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #include &lt;set> #define pii pair&lt;int, int> using namespace std; typedef long long i64; int n, q; set&lt;int> S; int dfn[100005], son[100005], top[100005], num = 0; int f[100005], siz[100005], dep[100005], idx[100005]; i64 dis[100005], ans = 0; vector&lt;pii> G[100005]; void dfs1(int x, int fa) &#123; siz[x] = 1; f[x] = fa; dep[x] = dep[fa] + 1; int max_part = -1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, w = G[x][i].second; if (y != fa) &#123; dis[y] = dis[x] + w; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > max_part) &#123; son[x] = y; max_part = siz[y]; &#125; &#125; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; idx[num] = x; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; &#125; int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; i64 F(int x, int y) &#123; return dis[x] + dis[y] - 2 * dis[LCA(x, y)]; &#125; i64 query(set&lt;int>::iterator it) &#123; auto pre = it, nxt = it; pre = (it == S.begin() ? S.end() : it); --pre; ++nxt; if (nxt == S.end()) nxt = S.begin(); int l = idx[*pre], r = idx[*nxt], x = idx[*it]; return F(l, x) + F(x, r) - F(l, r); &#125; int main(void) &#123; memset(son, -1, sizeof(son)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(&#123;v, d&#125;); G[v].push_back(&#123;u, d&#125;); &#125; dfs1(1, 0); dfs2(1, 1); scanf(\"%d\", &amp;q); while (q--) &#123; char op = getchar(); int x; while (op != '+' &amp;&amp; op != '-' &amp;&amp; op != '?') op = getchar(); if (op == '+') &#123; scanf(\"%d\", &amp;x); if (S.find(dfn[x]) != S.end()) continue; auto it = S.insert(dfn[x]).first; if (S.size() > 2) ans += query(it); else if (S.size() == 2) &#123; ++it; auto ot = (it == S.end() ? S.begin() : it); ans = F(idx[*ot], x) * 2; &#125; &#125; else if (op == '-') &#123; scanf(\"%d\", &amp;x); auto it = S.find(dfn[x]); if (it == S.end()) continue; if (S.size() == 2) ans = 0; else if (S.size() > 2) ans -= query(it); S.erase(it); &#125; else printf(\"%lld\\n\", ans / 2); &#125; return 0; &#125; [CF1149C] Tree Generatorâ„¢ Portal. è€ƒè™‘æ‹¬å·åºçš„ä»»æ„ä¸€ä¸ªå­åºåˆ—ä»£è¡¨äº†ä»€ä¹ˆï¼Ÿæ ‘ä¸Šè·¯å¾„çš„ç§»åŠ¨è¿‡ç¨‹ï¼ç”±äºç›´å¾„å¿…èƒ½è¡¨ç¤ºæˆä¸€ä¸ªç§»åŠ¨è¿‡ç¨‹ï¼Œå› æ­¤è®¾ f(l,r)f(l,r)f(l,r) ä»£è¡¨æ‹¬å·åº [l,r][l,r][l,r] ä¸­åˆ æ‰åŒ¹é…æ‹¬å·ä¹‹åçš„é•¿åº¦ï¼Œæœ€å¤§çš„ f(l,r)f(l,r)f(l,r) å°±æ˜¯ç­”æ¡ˆã€‚ ç„¶é¹…è¿™ä¸œè¥¿çœ‹èµ·æ¥ä¸æ˜¯å¾ˆå¥½ç»´æŠ¤ï¼Œä½†ä¸æ˜¯ä¸èƒ½æ¨å‡ºä¸€ç‚¹ä¸œè¥¿ï¼šè®¾ ( = 1, ) = -1ã€‚å‰©ä½™çš„æ‹¬å·ä¸€å®šå½¢å¦‚ )))(((ï¼Œè®¾åˆ å®Œä¹‹åè®¾ xxx ä¸ªæœ‰æ‹¬å·ï¼Œyyy ä¸ªå·¦æ‹¬å·ï¼Œåˆ™ f(l,r)=x+y=maxâ¡{s(k+1,r)âˆ’s(l,k)}f(l,r)=x+y=\\max\\{s(k+1,r)-s(l,k)\\}f(l,r)=x+y=max{s(k+1,r)âˆ’s(l,k)}ã€‚ è¿™ä¸ªä¸œè¥¿å°±å¯ä»¥ç”¨å°ç™½é€›å…¬å›­çº¿æ®µæ ‘æ¥ç»´æŠ¤äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, a[200005]; char s[200005]; struct Node &#123; int s, lmx, rmn, lrans, lans, rans, ans; friend Node operator+ (const Node &amp;a, const Node &amp;b) &#123; Node c; c.s = a.s + b.s; c.lmx = max(a.lmx, a.s + b.lmx); c.rmn = min(b.rmn, a.rmn + b.s); c.lans = max(&#123;a.lans, a.lrans + b.lmx, b.lans - a.s&#125;); c.rans = max(&#123;b.rans, b.lrans - a.rmn, a.rans + b.s&#125;); c.lrans = max(a.lrans + b.s, b.lrans - a.s); c.ans = max(&#123;a.ans, b.ans, a.rans + b.lmx, b.lans - a.rmn&#125;); return c; &#125; &#125; T[800005]; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].s = a[l]; T[o].lmx = max(a[l], 0); T[o].rmn = min(a[l], 0); T[o].lans = T[o].rans = T[o].lrans = T[o].ans = 1; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) &#123; T[o].s = k; T[o].lmx = max(k, 0); T[o].rmn = min(k, 0); return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, s + 1); n = n * 2 - 2; for (int i = 1; i &lt;= n; ++i) a[i] = (s[i] == '(' ? 1 : -1); build(1, 1, n); printf(\"%d\\n\", T[1].ans); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); swap(a[x], a[y]); update(1, 1, n, x, a[x]); update(1, 1, n, y, a[y]); printf(\"%d\\n\", T[1].ans); &#125; return 0; &#125; å…¶å®ƒæ ‘ä¸Šé—®é¢˜ è¿™é‡Œæ˜¯ä¸€äº›æ ‘ä¸Šæ‚é¢˜ã€‚ ã€XR-3ã€‘æ ¸å¿ƒåŸå¸‚ Portal. è€ƒè™‘ä»å¶å­èŠ‚ç‚¹å¼€å§‹å‘ä¸­é—´æ¨è¿›ã€‚å½“å¶å­èŠ‚ç‚¹çš„æ•°é‡è¾¾åˆ° nâˆ’kn-knâˆ’k æ—¶å°±åº”åœæ­¢ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> using namespace std; int n, k, dep[100005], deg[100005]; bool vis[100005]; vector&lt;int> G[100005]; queue&lt;int> Q; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); k = n - k; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); deg[u] += 1; G[v].emplace_back(u); deg[v] += 1; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) if (G[i].size() == 1 &amp;&amp; k >= 1) Q.push(i), vis[i] = true, --k, ans = dep[i] = 1, --deg[i]; if (k >= 1) &#123; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; deg[y] -= 1; if (!vis[y] &amp;&amp; deg[y] == 1) &#123; dep[y] = dep[x] + 1; ans = max(ans, dep[y]); vis[y] = true; Q.push(y); --k; if (k &lt; 1) &#123; printf(\"%d\\n\", ans); return 0; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; è¡¨è¾¾å¼æ ‘ | [CSP-J2020] è¡¨è¾¾å¼ Portal. å…ˆè€ƒè™‘ä¸å¸¦ä¿®æ€ä¹ˆåšã€‚æ‰«æ sssï¼Œå¼€ä¸€ä¸ªæ ˆï¼Œå»ºç«‹è¡¨è¾¾å¼æ ‘ï¼Œé‡åˆ°æ•°å°±å…¥æ ˆï¼Œè¿ç®—ç¬¦å°±å¼¹æ ˆè¿›è¡Œè¿ç®—ç„¶åå†å…¥æ ˆã€‚æœ€å dfs ä¸€æ¬¡è¡¨è¾¾å¼æ ‘å°±å¯ä»¥è®¡ç®—å‡ºç­”æ¡ˆã€‚ å½“ä¿®æ”¹æ—¶ï¼Œè¦ä¹ˆç­”æ¡ˆä¼šå˜ï¼Œè¦ä¹ˆç­”æ¡ˆä¸å˜ã€‚è®°å½•ä¸€ä¸ªæ•°ç»„ cccï¼Œä»£è¡¨ç­”æ¡ˆæ˜¯å¦ä¼šä¸å˜ã€‚å¦‚æœä¸è¿ç®—çš„æ—¶å€™ä¸€ä¸ªæ•°ä¸ºé›¶ï¼Œé‚£ä¹ˆæ”¹å˜å¦ä¸€ä¸ªæ•°æ²¡æœ‰æ„ä¹‰ã€‚æˆ–è¿ç®—åŒç†ã€‚è¿™ç§å…³ç³»å¯ä»¥å†ä¸€æ¬¡è¿›è¡Œ dfsï¼Œé€šè¿‡æˆ–è¿ç®—å‘å„¿å­ä¼ é€’ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;stack> using namespace std; int n, q, a[2000005], ck = 0; int son[2000005][2]; bool flag[2000005], c[2000005]; // c è®°å½•å½“å‰èŠ‚ç‚¹çš„å€¼æ”¹å˜æ˜¯å¦æœ‰ç”¨ char s[1000010]; bool dfs(int x, bool f) &#123; f ^= flag[x]; a[x] ^= f; if (x &lt;= n) return a[x]; bool p = dfs(son[x][0], f), q = dfs(son[x][1], f); if (a[x] == 2) &#123; if (p == 0) c[son[x][1]] = 1; if (q == 0) c[son[x][0]] = 1; return p &amp; q; &#125; else &#123; if (p == 1) c[son[x][1]] = 1; if (q == 1) c[son[x][0]] = 1; return p | q; &#125; &#125; void dfs2(int x) &#123; if (x &lt;= n) return; c[son[x][0]] |= c[x]; c[son[x][1]] |= c[x]; dfs2(son[x][0]); dfs2(son[x][1]); &#125; int main(void) &#123; fgets(s, 1000002, stdin); scanf(\"%d\", &amp;n); ck = n; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); stack&lt;int> b; for (int i = 0; s[i]; i += 2) &#123; if (s[i] == 'x') &#123; int x = 0; ++i; while (s[i] != ' ') &#123; x = x * 10 + s[i] - '0'; ++i; &#125; --i; b.push(x); &#125; else if (s[i] == '!') flag[b.top()] ^= 1; else &#123; int x = b.top(); b.pop(); int y = b.top(); b.pop(); b.push(++ck); if (s[i] == '&amp;') a[ck] = 2; else a[ck] = 3; son[ck][0] = x; son[ck][1] = y; &#125; &#125; bool ans = dfs(ck, 0); dfs2(ck); scanf(\"%d\", &amp;q); while (q--) &#123; int x; scanf(\"%d\", &amp;x); printf(\"%d\\n\", c[x] ? ans : !ans); &#125; return 0; &#125; [SDOI2011] æ¶ˆé˜² Portal. è¦é€‰çš„è¯ï¼Œå¾€ç›´å¾„ä¸Šé€‰æ¯”è¾ƒå¥½ï¼Œå› ä¸ºå³ä½¿ç›´å¾„é€‰ä¸æ»¡è€Œé€‰åˆ°äº†éç›´å¾„ä¸Šçš„è¾¹ï¼Œé‚£ä¹ˆåŸæ¥ç›´å¾„ä¸Šçš„ç‚¹ä¹Ÿä½¿ç­”æ¡ˆè·ç¦»æ›´å¤§ã€‚ å› æ­¤éšä¾¿æä¸€æ¡ç›´å¾„ï¼Œç„¶åæšä¸¾ç›´å¾„ä¸Šçš„ä¸€ä¸ªèµ·ç‚¹ï¼Œè®¡ç®—ä¸€ä¸ªæœ€è¿œçš„ç»ˆç‚¹ï¼ˆè·ç¦»ä¸è¶…è¿‡ sssï¼‰ï¼Œé€‰è¿™ä¸€æ®µã€‚åªè€ƒè™‘ç›´å¾„ä¸Šçš„ç‚¹ï¼Œæ»¡è¶³æœ€è¿œç‚¹è·ç¦»æœ€å°çš„è¿™ä¸€æ®µå³ä¸ºç­”æ¡ˆã€‚å› ä¸ºå¦‚æœä¸æ˜¯ç­”æ¡ˆï¼ˆç›´å¾„å¤–ç‚¹åˆ°è¿™æ®µçš„è·ç¦»æ›´å¤§ï¼‰ï¼Œé‚£ä¹ˆè¿™æ¡ç›´å¾„å¿…ç„¶æ˜¯å‡çš„ã€‚ è¿™é‡Œå·æ‡’äº†ï¼Œç›´å¾„ä¸Šçš„æŸ¥æ‰¾æ²¡æœ‰ä½¿ç”¨å•è°ƒé˜Ÿåˆ—ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> using namespace std; int n, s, X, Y, ison[300005]; // (X, Y) ä¸ºç›´å¾„ int d[300005], fr[300005]; // X -> Y ä»å“ªé‡Œæ¥ int ans = 2e9; vector&lt;pii> G[300005]; void dfs(int x, int fa) &#123; fr[x] = fa; for (auto [y, w] : G[x]) if (y != fa) d[y] = d[x] + w, dfs(y, x); &#125; void workA(void) &#123; // æ ‡è®°ç›´å¾„ä¸Šçš„ç‚¹, d[x] ä¸º x åˆ° Y çš„è·ç¦» memset(d, 0, sizeof d); int u = Y; ison[Y] = 1; while (u != X) &#123; for (auto [v, w] : G[u]) if (v == fr[u]) ison[v] = 1, d[v] = d[u] + w; u = fr[u]; &#125; &#125; int find(int x, int len) &#123; // x å‘ X èµ° len æœ€è¿œèµ°åˆ°å“ªé‡Œ for (auto [y, w] : G[x]) if (y == fr[x] &amp;&amp; len >= w) return find(y, len - w); return x; &#125; void workB(void) &#123; // æšä¸¾ç›´å¾„ä¸Šçš„èµ·ç‚¹ int u = Y; while (u != X) &#123; ans = min(ans, max(d[u], d[X] - d[find(u, s)])); u = fr[u]; &#125; ans = min(ans, max(d[X], d[X] - d[find(X, s)])); &#125; void query(int x, int fa) &#123; for (auto [y, w] : G[x]) if (!ison[y] &amp;&amp; y != fa) d[y] = d[x] + w, query(y, x); &#125; void workC(void) &#123; memset(d, 0, sizeof d); int u = Y; while (u != X) query(u, 0), u = fr[u]; query(X, 0); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;s); for (int i = 1; i &lt;= n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].emplace_back(v, w); G[v].emplace_back(u, w); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) if (d[i] > d[X]) X = i; d[X] = 0; dfs(X, 0); for (int i = 1; i &lt;= n; ++i) if (d[i] > d[Y]) Y = i; workA(); workB(); workC(); for (int i = 1; i &lt;= n; ++i) ans = max(ans, d[i]); return !printf(\"%d\\n\", ans); &#125; [CF1707C] DFS Trees Portal. é¢˜ä¸­çš„æ±‚è§£æ–¹å¼æ˜¯æ±‚æœç´¢æ ‘ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä»¥ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„æ—¶å€™ï¼Œæ‰€æœ‰ä¸åœ¨ MST ä¸Šçš„è¾¹å¿…é¡»éƒ½æ˜¯è¿”ç¥–è¾¹ã€‚ å¯¹äºä¸€æ¡è¾¹è¿æ¥çš„ä¸¤ä¸ªç‚¹ï¼Œä¸¤å­æ ‘å†…çš„ç‚¹éƒ½ +1ï¼Œæ ‘ä¸Šå·®åˆ†ç»´æŠ¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, lg[100005]; struct Edge &#123; int u, v; &#125; e[200005]; bool vis[200005]; int bin[100005], f[18][100005], dep[100005], s[100005]; vector&lt;int> G[100005]; int find(int x) &#123; return bin[x] == x ? x : bin[x] = find(bin[x]); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; void dfs(int x, int fa) &#123; f[0][x] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= lg[n]; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; void dfs2(int x, int fa) &#123; s[x] += s[fa]; for (int y : G[x]) if (y != fa) dfs2(y, x); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;e[i].u, &amp;e[i].v); for (int i = 1; i &lt;= n; ++i) bin[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v; if (find(u) == find(v)) continue; G[u].emplace_back(v); G[v].emplace_back(u); vis[i] = 1; bin[find(u)] = find(v); &#125; dfs(1, 0); for (int i = 1; i &lt;= m; ++i) if (!vis[i]) &#123; int u = e[i].u, v = e[i].v, l = LCA(u, v); if (dep[u] > dep[v]) swap(u, v); if (l == u) &#123; // (u, v) è·¯å¾„ä¸Šä¸è¡Œ ++s[1], ++s[v]; int p = v; for (int j = lg[n]; j >= 0; --j) if (dep[f[j][p]] > dep[u]) p = f[j][p]; --s[p]; &#125; else ++s[u], ++s[v]; &#125; dfs2(1, 0); for (int i = 1; i &lt;= n; ++i) putchar(s[i] == m - (n - 1) ? '1' : '0'); return putchar('\\n'), 0; &#125; é‡é“¾å‰–åˆ† çœ‹èµ·æ¥æ ‘é“¾å‰–åˆ†å°±æ˜¯ä¸ªæ¿å­ï¼Œåªæ˜¯å°†é“¾ä¸Šçš„æ•°æ®ç»“æ„æ”¾åˆ°æ ‘ä¸Šäº†ã€‚å®é™…ä¸Šä¸æ˜¯ï¼Œå› ä¸ºæ ‘è‡ªèº«ä¹Ÿæœ‰è®¸å¤šæ€§è´¨ã€‚ [NOI2021] è½»é‡è¾¹ Portal.æœ‰ä¸€æ£µ nnn ä¸ªç»“ç‚¹çš„æ ‘ï¼Œæ ‘ä¸Šçš„æ¯ä¸€æ¡è¾¹å¯èƒ½æ˜¯è½»è¾¹æˆ–è€…é‡è¾¹ã€‚æ¥ä¸‹æ¥ä½ éœ€è¦å¯¹æ ‘è¿›è¡Œ mmm æ¬¡æ“ä½œï¼Œåœ¨æ‰€æœ‰æ“ä½œå¼€å§‹å‰ï¼Œæ ‘ä¸Šæ‰€æœ‰è¾¹éƒ½æ˜¯è½»è¾¹ã€‚æ“ä½œæœ‰ä»¥ä¸‹ä¸¤ç§ï¼šç»™å®šä¸¤ä¸ªç‚¹ aaa å’Œ bbbï¼Œé¦–å…ˆå¯¹äº aaa åˆ° bbb è·¯å¾„ä¸Šçš„æ‰€æœ‰ç‚¹ xxxï¼ˆåŒ…å« aaa å’Œ bbbï¼‰ï¼Œä½ è¦å°†ä¸ xxx ç›¸è¿çš„æ‰€æœ‰è¾¹å˜ä¸ºè½»è¾¹ã€‚ç„¶åå†å°† aaa åˆ° bbb è·¯å¾„ä¸ŠåŒ…å«çš„æ‰€æœ‰è¾¹å˜ä¸ºé‡è¾¹ã€‚ç»™å®šä¸¤ä¸ªç‚¹ aaa å’Œ bbbï¼Œä½ éœ€è¦è®¡ç®—å½“å‰ aaa åˆ° bbb çš„è·¯å¾„ä¸Šä¸€å…±åŒ…å«å¤šå°‘æ¡é‡è¾¹ã€‚ è‚¯å®šæ˜¯æ ‘å‰–ï¼ˆLCT ä¹Ÿå¯ï¼Œä½†æ˜¯ç¬”è€…ä¸ä¼š LCTï¼‰ï¼Œä½†æ˜¯å¦‚ä½•ç®€å•ç»´æŠ¤å‘¢ï¼Ÿ è€ƒè™‘ä½¿ç”¨é¢œè‰²æ¥ç»´æŠ¤ã€‚åˆå§‹æ—¶æ¯ä¸€ä¸ªç‚¹çš„é¢œè‰²éƒ½ä¸åŒï¼›æ¯ä¸€æ¬¡ä¿®æ”¹çš„æ—¶å€™ï¼Œæˆ‘ä»¬éƒ½å°† (a,b)(a,b)(a,b) é—´æŸ“ä¸Šä¸€ä¸ªæ–°çš„é¢œè‰²ï¼Œç„¶åé‡è¾¹çš„åˆ¤å®šæ³•åˆ™å°±å˜æˆäº†ï¼šè¿æ¥çš„ä¸¤ä¸ªç«¯ç‚¹çš„é¢œè‰²ç›¸åŒï¼ˆæƒ³ä¸€æƒ³çœ‹æ˜¯ä¸æ˜¯è¿™æ ·ï¼‰ã€‚ é‚£ä¹ˆå®ç°ä¸€ä¸ªå¯ä»¥ç»Ÿè®¡é¢œè‰²ç›¸åŒçš„ç›¸é‚»å¯¹çš„çº¿æ®µæ ‘å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; vector &lt;int> G[100005]; int dep[100005], siz[100005], f[100005]; int dfn[100005], top[100005], son[100005], num = 0; void dfs1(int x, int fa) &#123; dep[x] = dep[fa] + 1; siz[x] = 1; f[x] = fa; int maxx = -1; for (auto y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > maxx) &#123; maxx = siz[y]; son[x] = y; &#125; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (auto y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; // Segment Tree struct Node &#123; int lc, rc, tag; int cnt; Node(int lc = 0, int rc = 0, int cnt = 0, int tag = 0) : lc(lc), rc(rc), tag(tag), cnt(cnt) &#123;&#125; &#125; T[400005]; inline Node hb(const Node &amp;a, const Node &amp;b) &#123; Node c(a.lc, b.rc, a.cnt + b.cnt + (a.rc == b.lc)); return c; &#125; inline void pushdown(int o, int l, int r) &#123; if (!T[o].tag) return; int mid = l + r >> 1; T[o &lt;&lt; 1] = Node(T[o].tag, T[o].tag, mid - l, T[o].tag); T[o &lt;&lt; 1 | 1] = Node(T[o].tag, T[o].tag, r - mid - 1, T[o].tag); T[o].tag = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; T[o] = Node(k, k, r - l, k); return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; pushdown(o, l, r); int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return hb(query(o &lt;&lt; 1, l, mid, x, y), query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); &#125; int query(int x, int y) &#123; bool flag = 0; Node ans1, ans2, tmp; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y), flag = !flag; tmp = query(1, 1, n, dfn[top[x]], dfn[x]); if (flag) ans2 = Node(tmp.lc, ans2.rc, ans2.cnt + tmp.cnt + (ans2.lc == tmp.rc)); else ans1 = Node(ans1.lc, tmp.lc, ans1.cnt + tmp.cnt + (ans1.rc == tmp.rc)); x = f[top[x]]; &#125; if (dep[x] &lt; dep[y]) swap(x, y), flag = !flag; tmp = query(1, 1, n, dfn[y], dfn[x]); if (flag) ans2 = Node(tmp.lc, ans2.rc, ans2.cnt + tmp.cnt + (ans2.lc == tmp.rc)); else ans1 = Node(ans1.lc, tmp.lc, ans1.cnt + tmp.cnt + (ans1.rc == tmp.rc)); return ans1.cnt + ans2.cnt + (ans1.rc == ans2.lc); &#125; int main(void) &#123; int TT; scanf(\"%d\", &amp;TT); while (TT--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); num = 0; memset(son, -1, sizeof(son)); memset(T, 0, sizeof(T)); for (int i = 1; i &lt;= n; ++i) G[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; for (int i = 1; i &lt;= n; ++i) update(1, 1, n, i, i, -i); dfs1(1, 0); dfs2(1, 1); for (int i = 1; i &lt;= m; ++i) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); update(1, 1, n, dfn[top[x]], dfn[x], i); x = f[top[x]]; &#125; if (dep[x] &lt; dep[y]) swap(x, y); update(1, 1, n, dfn[y], dfn[x], i); &#125; else printf(\"%d\\n\", query(x, y)); &#125; &#125; return 0; &#125; [SCOI2015] æƒ…æŠ¥ä¼ é€’ Portal.nnn åæƒ…æŠ¥å‘˜å½¢æˆæ ‘å½¢ç»“æ„ï¼Œæ¯å¤©ä¼šæ´¾å‘ä»¥ä¸‹ä¸¤ç§ä»»åŠ¡ä¸­çš„ä¸€ä¸ªä»»åŠ¡ï¼šæŒ‡æ´¾ TTT å·æƒ…æŠ¥å‘˜æœé›†æƒ…æŠ¥ï¼›å°†ä¸€æ¡æƒ…æŠ¥ä» XXX å·æƒ…æŠ¥å‘˜ç»æœ€çŸ­è·¯å¾„ä¼ é€’ç»™ YYY å·æƒ…æŠ¥å‘˜ã€‚æƒ…æŠ¥å‘˜æœ€åˆå¤„äºæ½œä¼é˜¶æ®µï¼Œæ­¤æ—¶æ‰€æœ‰æƒ…æŠ¥å‘˜çš„å±é™©å€¼ä¸º 000ï¼›ä¸€æ—¦æŸä¸ªæƒ…æŠ¥å‘˜å¼€å§‹æœé›†æƒ…æŠ¥ï¼Œä»–çš„å±é™©å€¼å°±ä¼šæŒç»­å¢åŠ ï¼Œæ¯å¤©å¢åŠ  111 ç‚¹ï¼ˆå¼€å§‹æœé›†æƒ…æŠ¥çš„å½“å¤©å±é™©å€¼ä»ä¸º 000ï¼Œç¬¬ 222 å¤©ä¸º 111ï¼‰ã€‚æ¯æ¡æƒ…æŠ¥éƒ½æœ‰ä¸€ä¸ªé£é™©æ§åˆ¶å€¼ CCCã€‚å‚ä¸ä¼ é€’è¿™æ¡æƒ…æŠ¥çš„å±é™©å€¼å¤§äº CCC çš„æƒ…æŠ¥å‘˜å°†å¯¹è¯¥æ¡æƒ…æŠ¥æ„æˆå¨èƒã€‚é—®å¯¹äºæ¯ä¸ªä¼ é€’æƒ…æŠ¥ä»»åŠ¡ï¼Œå‚ä¸ä¼ é€’çš„æƒ…æŠ¥å‘˜æœ‰å¤šå°‘ä¸ªï¼Œå…¶ä¸­å¯¹è¯¥æ¡æƒ…æŠ¥æ„æˆå¨èƒçš„æƒ…æŠ¥å‘˜æœ‰å¤šå°‘ä¸ªã€‚nâ‰¤2Ã—105,Qâ‰¤2Ã—105,0&lt;Pi,Ciâ‰¤N,1â‰¤Ti,Xi,Yiâ‰¤nn\\le 2\\times 10^5,Q\\le 2\\times 10^5,0&lt;P_i,C_i\\le N,1\\le T_i,X_i,Y_i\\le nnâ‰¤2Ã—105,Qâ‰¤2Ã—105,0&lt;Piâ€‹,Ciâ€‹â‰¤N,1â‰¤Tiâ€‹,Xiâ€‹,Yiâ€‹â‰¤nã€‚ è€ƒè™‘è¿™ä¸ªé™åˆ¶æ¡ä»¶æ˜¯ä»€ä¹ˆæ„æ€ã€‚å‡å®šä¸€ä¸ªäººå¼€å§‹ä½œæ­»çš„æ—¶é—´ä¸º tttï¼Œä¸€æ¡æƒ…æŠ¥ä¼ é€’ä»»åŠ¡çš„æ—¶é—´ä¸º iiiï¼Œé‚£ä¹ˆéœ€è¦æ»¡è¶³ t+c&gt;it+c&gt;it+c&gt;iï¼Œä¹Ÿå°±æ˜¯ tâ‰¥iâˆ’câˆ’1t\\ge i-c-1tâ‰¥iâˆ’câˆ’1ã€‚ é‚£ä¹ˆï¼Œç¦»çº¿ï¼ŒæŒ‰ç…§ iâˆ’câˆ’1i-c-1iâˆ’câˆ’1 æ’åºï¼Œç„¶åä¾æ¬¡å°†å†’é™©è€…æ·»åŠ è¿›æ¥ï¼ˆå•ç‚¹ä¿®æ”¹ï¼‰ï¼ŒæŸ¥è¯¢å°±æ˜¯é“¾ä¸Šè·ç¦»å’Œé“¾ä¸ŠæŸ¥è¯¢ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; struct Question &#123; int x, y, c, id; Question(int x = 0, int y = 0, int c = 0, int id = 0) : x(x), y(y), c(c), id(id) &#123;&#125; bool operator &lt; (const Question &amp;a) const &#123; return c &lt; a.c; &#125; &#125; Q[200005]; struct Operation &#123; int x, t; Operation(int x = 0, int t = 0) : x(x), t(t) &#123;&#125; &#125; A[200005]; int tot = 0, tot2 = 0; int n, q, root; bool vis[200005]; int f[200005], dep[200005], siz[200005], dis[200005]; int son[200005], top[200005], dfn[200005], num = 0; vector&lt;int> G[200005]; int ans[200005]; void dfs1(int x) &#123; dep[x] = dep[f[x]] + 1; siz[x] = 1; int max_part = -1; for (int y : G[x]) &#123; dfs1(y); siz[x] += siz[y]; if (siz[y] > max_part) &#123; max_part = siz[y]; son[x] = y; &#125; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (int y : G[x]) if (y != son[x]) dfs2(y, y); &#125; int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; int T[800005]; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o] += 1, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; int main(void) &#123; memset(son, -1, sizeof(son)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i); if (f[i] == 0) root = i; else G[f[i]].emplace_back(i); &#125; dfs1(root); dfs2(root, root); scanf(\"%d\", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; int op, x, y, c; scanf(\"%d%d\", &amp;op, &amp;x); if (op == 1) &#123; scanf(\"%d%d\", &amp;y, &amp;c); ++tot; Q[tot] = Question(x, y, i - c - 1, tot); &#125; else A[++tot2] = Operation(x, i); &#125; sort(Q + 1, Q + tot + 1); for (int i = 1, p = 1; i &lt;= tot; ++i) &#123; while (p &lt;= tot2 &amp;&amp; A[p].t &lt;= Q[i].c) &#123; if (!vis[A[p].x]) update(1, 1, n, dfn[A[p].x]); vis[A[p].x] = true; ++p; &#125; int x = Q[i].x, y = Q[i].y, res = 0; dis[Q[i].id] = dep[x] + dep[y] - 2 * dep[LCA(x, y)] + 1; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); res += query(1, 1, n, dfn[top[x]], dfn[x]); x = f[top[x]]; &#125; if (dep[x] &lt; dep[y]) swap(x, y); res += query(1, 1, n, dfn[y], dfn[x]); ans[Q[i].id] = res; &#125; for (int i = 1; i &lt;= tot; ++i) printf(\"%d %d\\n\", dis[i], ans[i]); return 0; &#125; [BJOI2014] å¤§èåˆ Portal.ç»™å®šä¸€ä¸ªæ— å‘å›¾ï¼ŒåŠ¨æ€åŠ è¾¹ï¼ŒæŸ¥è¯¢ä¸€æ¡è¾¹çš„è´Ÿè½½ï¼ˆç»è¿‡è¿™æ¡è¾¹çš„ç®€å•è·¯å¾„çš„æ•°é‡ï¼‰ï¼Œä¿è¯ä»»æ„æ—¶åˆ»å›¾éƒ½æ˜¯ä¸€ç‰‡æ£®æ—ã€‚ è§£å†³åŠ¨æ€å›¾çš„å¸¸è§„æ‰‹æ®µä¾ç„¶æ˜¯åŠ¨æ€æ ‘ï¼Œä½†æ˜¯æ­¤é¢˜æ²¡æœ‰åˆ è¾¹æ“ä½œï¼Œä¹Ÿæ²¡æœ‰å¼ºåˆ¶åœ¨çº¿ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘ä½¿ç”¨æ ‘å‰–æ¥æ±‚è§£ã€‚ å°†è¯¢é—®å…¨éƒ¨è¯»å…¥ï¼Œç„¶åå»ºç«‹å‡ºæœ€ç»ˆçš„æ£®æ—ï¼Œå¹¶å¯¹æ¯ä¸€æ£µæ ‘éƒ½è¿›è¡Œæ ‘é“¾å‰–åˆ†ã€‚å»ºç«‹ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ç»´æŠ¤æ ‘ä¸Šå­æ ‘çš„å¤§å°çš„å‰ç¼€å’Œï¼Œåˆ©ç”¨å·®åˆ†çš„æ–¹å¼è¿›è¡Œä¿®æ”¹ï¼ˆå› ä¸ºå­æ ‘å¤§å°åªéœ€è¦å•ç‚¹æŸ¥è¯¢ï¼Œå†™çº¿æ®µæ ‘æœ‰ç‚¹å°é¢˜å¤§åšäº†ï¼‰ã€‚åˆå§‹æ—¶è¦å°†æ‰€æœ‰æ‰€æœ‰ç‚¹çš„å­æ ‘å¤§å°éƒ½åˆå§‹åŒ–ä¸º 111ï¼Œå› ä¸ºå®ƒä»¬éƒ½æ˜¯å­¤ç«‹çš„ã€‚åŒæ—¶ç»´æŠ¤ä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œç”¨äºæŸ¥è¯¢ä¸€ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„é›†åˆã€‚ æ‰«ææ¯ä¸€ä¸ªæ“ä½œï¼š è¿è¾¹ã€‚è®¾è¦å°† yyy è¿æ¥åˆ° xxxï¼Œxxx æ˜¯ yyy çš„ç¥–å…ˆï¼Œé‚£ä¹ˆå¹¶æŸ¥é›†è¿›è¡Œåˆå¹¶æ“ä½œï¼Œç°åœ¨åœ¨å¹¶æŸ¥é›†ä¸­ï¼Œfind(y) çš„ç»“æœä¸€å®šæ˜¯ find(x) çš„ç»“æœã€‚ç°åœ¨éœ€è¦ç»´æŠ¤å­æ ‘å¤§å°ã€‚yyy æ‰€å¯¹åº”çš„å­æ ‘å¤§å°ä¸å˜ï¼Œxxx ä»¥åŠ xxx çš„çˆ¶äº²æ‰€å¯¹åº”çš„å­æ ‘å¤§å°éœ€è¦åŠ ä¸Š siz[y]siz[y]siz[y]ã€‚ä½†æ˜¯ç”±äºæ ‘è¿˜æ²¡æœ‰å»ºå®Œï¼Œæ‰€ä»¥ä» find(x) çš„çˆ¶äº²å¼€å§‹ï¼Œéœ€è¦å‡å» siz[y]siz[y]siz[y]ã€‚ æŸ¥è¯¢ã€‚å½“å‰ yyy çš„å­æ ‘å¤§å°æ˜¯ä¸€éƒ¨åˆ†ï¼Œæ•´ä¸ªé›†åˆä¸­å‰©ä¸‹çš„æ˜¯ä¸€éƒ¨åˆ†ï¼Œä¸¤è€…çš„ä¹˜ç§¯å°±æ˜¯ç­”æ¡ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; struct Question &#123; char op; int x, y; &#125; a[100005]; int n, q; vector&lt;int> G[100005]; int dep[100005], siz[100005], f[100005]; int dfn[100005], top[100005], son[100005], num = 0; struct UnionFind_Set &#123; int f[100005]; void init(void) &#123; for (int i = 1; i &lt;= n; ++i) f[i] = i; &#125; int find(int x) &#123; if (f[x] == x) return x; return f[x] = find(f[x]); &#125; &#125; S; void dfs1(int x, int fa) &#123; dep[x] = dep[fa] + 1; siz[x] = 1; f[x] = fa; int max_part = -1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > max_part) &#123; son[x] = y; max_part = siz[y]; &#125; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int C[100005]; void add(int x, int k) &#123; if (x == 0) return; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int query(int x) &#123; int res = 0; for (; x >= 1; x -= lowbit(x)) res += C[x]; return res; &#125; void update(int x, int k) &#123; while (x >= 1) &#123; // ä¿®æ”¹ï¼štop[x] -> x add(dfn[top[x]], k); add(dfn[x] + 1, -k); // å› ä¸ºæ˜¯å·®åˆ†ï¼Œå‡çš„åœ°æ–¹è¦åŠ ä¸Š 1 x = f[top[x]]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; a[i].op = getchar(); while (a[i].op != 'A' &amp;&amp; a[i].op != 'Q') a[i].op = getchar(); scanf(\"%d %d\", &amp;a[i].x, &amp;a[i].y); if (a[i].op == 'A') &#123; G[a[i].x].emplace_back(a[i].y); G[a[i].y].emplace_back(a[i].x); &#125; &#125; memset(son, -1, sizeof(son)); for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) &#123; dfs1(i, 0); dfs2(i, i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; update(i, 1); update(f[i], -1); &#125; S.init(); for (int i = 1; i &lt;= q; ++i) &#123; int op = a[i].op, x = a[i].x, y = a[i].y; if (dep[x] > dep[y]) swap(x, y); // x æ˜¯ y çš„ç¥–å…ˆ uint sy = query(dfn[y]); if (op == 'A') &#123; S.f[y] = S.find(x); update(x, sy); update(f[S.f[x]], -sy); &#125; else &#123; uint s = query(dfn[S.find(x)]); printf(\"%u\\n\", sy * (s - sy)); &#125; &#125; return 0; &#125; [LNOI2014] LCA Portal.ç»™å‡ºä¸€ä¸ª nnn ä¸ªèŠ‚ç‚¹çš„æœ‰æ ¹æ ‘ï¼ˆç¼–å·ä¸º 000 åˆ° nâˆ’1n-1nâˆ’1ï¼Œæ ¹èŠ‚ç‚¹ä¸º 000ï¼‰ã€‚æœ‰ mmm æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ç»™å‡º l r zl\\ r\\ zl r zï¼Œæ±‚ âˆ‘i=lrdep[LCA(i,z)]\\sum_{i=l}^r dep[LCA(i,z)]âˆ‘i=lrâ€‹dep[LCA(i,z)]ã€‚1â‰¤n,mâ‰¤5Ã—1041\\le n,m\\le 5\\times 10^41â‰¤n,mâ‰¤5Ã—104ã€‚ å¯¹äºä¸€ä¸ªè¯¢é—®æ¥è¯´ï¼Œæ‰€æœ‰çš„ LCA éƒ½åœ¨ zzz åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šï¼Œæ·±åº¦ä»£è¡¨çš„å«ä¹‰æ˜¯å½“å‰ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„ç‚¹æ•°ã€‚æŠŠ xxx åˆ°æ ¹çš„è·¯å¾„ä¸Šçš„ç‚¹å…¨éƒ¨ +1+1+1ï¼Œæ±‚ yyy åˆ°æ ¹çš„è·¯å¾„çš„æƒå€¼ï¼Œå°±æ˜¯ LCA(x,y)LCA(x,y)LCA(x,y) çš„æ·±åº¦ã€‚äºæ˜¯æˆ‘ä»¬é‡‡ç”¨å·®åˆ†çš„æ–¹å¼æ±‚è§£è¯¢é—®ï¼Œå°†è¯¢é—®ç¦»çº¿ï¼Œä¾æ¬¡å°†ç‚¹åŠ å…¥ç³»ç»Ÿè¿›è¡Œç»´æŠ¤ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int MOD = 201314; int n, m; int f[50005], dep[50005], siz[50005]; int dfn[50005], son[50005], top[50005], num = 0; vector&lt;int> G[50005]; void dfs1(int x) &#123; dep[x] = dep[f[x]] + 1; siz[x] = 1; int max_part = -1; for (int y : G[x]) &#123; dfs1(y); siz[x] += siz[y]; if (siz[y] > max_part) max_part = siz[y], son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (int y : G[x]) if (y != son[x]) dfs2(y, y); &#125; int T[200005], tag[200005]; inline void pushdown(int o, int l, int r) &#123; if (!tag[o]) return; int mid = l + r >> 1; tag[o &lt;&lt; 1] += tag[o], tag[o &lt;&lt; 1 | 1] += tag[o]; T[o &lt;&lt; 1] += tag[o] * (mid - l + 1), T[o &lt;&lt; 1 | 1] += tag[o] * (r - mid); tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] += 1, T[o] += r - l + 1, void(); int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y); T[o] = (T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]) % MOD; &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = 0; pushdown(o, l, r); if (x &lt;= mid) res = (res + query(o &lt;&lt; 1, l, mid, x, y)) % MOD; if (mid &lt; y) res = (res + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)) % MOD; return res; &#125; void update(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); update(1, 1, n, dfn[top[x]], dfn[x]); x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); update(1, 1, n, dfn[x], dfn[y]); &#125; int query(int x, int y) &#123; int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ans = (ans + query(1, 1, n, dfn[top[x]], dfn[x])) % MOD; x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); ans = (ans + query(1, 1, n, dfn[x], dfn[y])) % MOD; return ans; &#125; struct Question &#123; int id, r, z, flag; Question(int id = 0, int r = 0, int z = 0, int flag = 0) : id(id), r(r), z(z), flag(flag) &#123;&#125; bool operator &lt; (const Question &amp;a) const &#123; return r &lt; a.r; &#125; &#125; Q[100005]; int ans[50005]; int main(void) &#123; memset(son, 0xff, sizeof(son)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i); ++f[i]; G[f[i]].emplace_back(i); &#125; dfs1(1); dfs2(1, 1); for (int i = 1; i &lt;= m; ++i) &#123; int l, r, z; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;z); ++l, ++r, ++z; Q[(i &lt;&lt; 1) - 1] = Question(i, l - 1, z, -1); Q[(i &lt;&lt; 1)] = Question(i, r, z, 1); &#125; sort(Q + 1, Q + m * 2 + 1); int r = 0; for (int i = 1; i &lt;= m * 2; ++i) &#123; while (r &lt; Q[i].r) update(1, ++r); ans[Q[i].id] += Q[i].flag * query(1, Q[i].z); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", (ans[i] + MOD) % MOD); return 0; &#125; [Ynoi2017] ç”±ä¹ƒçš„ OJ Portal. å›æƒ³å½“åˆçš„è´ªå¿ƒæ˜¯æ€ä¹ˆåšçš„ï¼Œäºæ˜¯æˆ‘ä»¬ç”¨çº¿æ®µæ ‘ç»´æŠ¤ 0,10,10,1 ç»è¿‡è¿™äº›è¿ç®—ä¹‹åä¼šå˜æˆä»€ä¹ˆï¼Œè¦ç»´æŠ¤ 646464 ä¸ªï¼Œå› æ­¤å¯ä»¥å‹è¿›ä¸€ä¸ª unsigned long long è¿›è¡Œç»´æŠ¤ã€‚ç”±äºæ ‘å‰–çš„ç‰¹æ€§ï¼Œæ‰€ä»¥æ­£åéƒ½éœ€è¦ç»´æŠ¤ã€‚åˆå¹¶çš„æ—¶å€™å¾ˆå¥½å¤„ç†ï¼Œå¯ä»¥è®¨è®ºä¸€ä¸‹å½“å‰ä½ä»€ä¹ˆæ—¶å€™æ˜¯ 111ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; const u64 INF = 0 - 1; int n, m, k, op[100005]; u64 val[100005]; int f[100005], siz[100005], dep[100005]; int top[100005], dfn[100005], idx[100005], num, son[100005]; vector&lt;int> G[100005]; void dfs1(int x, int fa) &#123; dep[x] = dep[f[x] = fa] + 1; siz[x] = 1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; idx[dfn[x] = ++num] = x; top[x] = topf; if (son[x]) dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; u64 calc(u64 v, int x) &#123; if (op[x] == 1) return v &amp; val[x]; if (op[x] == 2) return v | val[x]; return v ^ val[x]; &#125; struct Node &#123; u64 a0, a1, b0, b1; Node() : a0(0), a1(0), b0(0), b1(0) &#123;&#125; // a: 0/1 ä»å·¦åˆ°å³ // b: 0/1 ä»å³åˆ°å·¦ &#125; T[400005]; inline Node operator+ (const Node &amp;a, const Node &amp;b) &#123; Node c; c.a0 = ((a.a0 &amp; b.a1) | (~a.a0 &amp; b.a0)); c.a1 = ((a.a1 &amp; b.a1) | (~a.a1 &amp; b.a0)); c.b0 = ((b.b0 &amp; a.b1) | (~b.b0 &amp; a.b0)); c.b1 = ((b.b1 &amp; a.b1) | (~b.b1 &amp; a.b0)); return c; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].a0 = T[o].b0 = calc(0, idx[l]); T[o].a1 = T[o].b1 = calc(INF, idx[l]); return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x) &#123; if (l == r) &#123; T[o].a0 = T[o].b0 = calc(0, idx[l]); T[o].a1 = T[o].b1 = calc(INF, idx[l]); return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return query(o &lt;&lt; 1, l, mid, x, y) + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); &#125; Node ans1[100005], ans2[100005]; int tot1, tot2; Node query(int x, int y) &#123; tot1 = tot2 = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] >= dep[top[y]]) &#123; ans1[++tot1] = query(1, 1, n, dfn[top[x]], dfn[x]); x = f[top[x]]; &#125; else &#123; ans2[++tot2] = query(1, 1, n, dfn[top[y]], dfn[y]); y = f[top[y]]; &#125; &#125; if (dep[x] > dep[y]) ans1[++tot1] = query(1, 1, n, dfn[y], dfn[x]); else ans2[++tot2] = query(1, 1, n, dfn[x], dfn[y]); for (int i = 1; i &lt;= tot1; ++i) swap(ans1[i].a0, ans1[i].b0), swap(ans1[i].a1, ans1[i].b1); Node ans; if (tot1) &#123; ans = ans1[1]; for (int i = 2; i &lt;= tot1; ++i) ans = ans + ans1[i]; if (tot2) ans = ans + ans2[tot2]; &#125; else ans = ans2[tot2]; for (int i = tot2 - 1; i >= 1; --i) ans = ans + ans2[i]; return ans; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%llu\", op + i, val + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(1, 0); dfs2(1, 1); build(1, 1, n); while (m--) &#123; int opt, x, y; u64 z; scanf(\"%d%d%d%llu\", &amp;opt, &amp;x, &amp;y, &amp;z); if (opt == 1) &#123; u64 ans = 0; Node t = query(x, y); for (int i = 63; i >= 0; --i) &#123; u64 t0 = (t.a0 >> i) &amp; 1ull; u64 t1 = (t.a1 >> i) &amp; 1ull; if ((1ull &lt;&lt; i) > z || t0 >= t1) ans |= (t0 ? (1ull &lt;&lt; i) : 0); else ans |= (t1 ? (1ull &lt;&lt; i) : 0), z -= (1ull &lt;&lt; i); &#125; printf(\"%llu\\n\", ans); &#125; else &#123; op[x] = y; val[x] = z; update(1, 1, n, dfn[x]); &#125; &#125; return 0; &#125; [CF1017G] The Tree Portal.ç»´æŠ¤ä¸€æ£µæ ‘ï¼š1 xï¼šå¦‚æœ xxx ä¸ºç™½è‰²ï¼Œé‚£ä¹ˆå°†å…¶æŸ“é»‘ï¼Œå¦åˆ™å¯¹è¿™ä¸ªèŠ‚ç‚¹çš„å„¿å­è¿›è¡Œé€’å½’æ“ä½œï¼›2 xï¼šå°† xxx å­æ ‘ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹æŸ“æˆç™½è‰²ã€‚3 xï¼šæŸ¥è¯¢ xxx çš„é¢œè‰²ã€‚ å…³é”®é—®é¢˜æ˜¯ï¼Œè¿™ä¸ª 1 æ“ä½œæ˜¯ä»€ä¹ˆé¬¼ï¼Ÿå¦‚æœèŠ‚ç‚¹ yyy ä¼šè¢« 1 x å½±å“åˆ°ï¼Œé‚£è¯´æ˜ xâˆ¼yx\\sim yxâˆ¼y ä¸­é™¤äº† yyy çš„èŠ‚ç‚¹éƒ½è¢«æŸ“é»‘äº†ã€‚ ç®€å•æ ‘ä¸Šä¹±æ ä¸€äº›æœ‰è¶£çš„é¢˜ã€‚ [Ynoi Easy Round 2021] TEST_68 Portal. å‘ç°å¾ˆå¤šç‚¹çš„ç­”æ¡ˆåº”è¯¥æ˜¯ä¸€æ ·çš„ã€‚æˆ‘ä»¬å°†æ‰€æœ‰ç‚¹åŠ å…¥ 01-Trieï¼Œæ‰¾å‡ºä¸€ä¸ªå¼‚æˆ–å€¼æœ€å¤§çš„ç‚¹å¯¹ (p,q)(p,q)(p,q)ï¼Œåªæœ‰ (1,p),(1,q)(1,p),(1,q)(1,p),(1,q) è¿™ä¸¤æ¡é“¾ä¸Šçš„ç­”æ¡ˆå¯èƒ½ä¸æœ€å¤§ç­”æ¡ˆä¸åŒã€‚è€ƒè™‘ç”± 111 å¼€å§‹éå†é“¾ï¼ˆå› ä¸º 111 çš„é™åˆ¶æ˜¯æœ€ä¸¥çš„ï¼Œè€Œä¸¤æ¡é“¾åˆ†åˆ«éå†ä¸€æ¬¡ï¼‰ï¼Œä¸æ–­è§£æ”¾æ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œå°†å®ƒä»¬åŠ å…¥ Trieï¼Œæ‰¾å‡ºå¼‚æˆ–çš„æœ€å¤§å€¼ã€‚ æ—¶é—´å¤æ‚åº¦ O(nlogâ¡V)O(n\\log V)O(nlogV)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 500005; i64 a[500005]; int val[N * 60], ch[N * 60][2], tot; void insert(int id) &#123; int x = 0; for (int i = 59; i >= 0; --i) &#123; int c = a[id] >> i &amp; 1; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; val[x] = id; &#125; int query(int id) &#123; // è¿”å›å¼‚æˆ–å€¼æœ€å¤§çš„èŠ‚ç‚¹ç¼–å· int x = 0; for (int i = 59; i >= 0; --i) &#123; int c = a[id] >> i &amp; 1; if (!ch[x][c ^ 1]) x = ch[x][c]; else x = ch[x][c ^ 1]; &#125; return val[x]; &#125; int n, p, q; int f[500005], dep[500005], son[2]; bool v[500005]; i64 Ans[500005], ans, s[500005]; vector&lt;int> G[500005]; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); v[x] = v[y] = 1; while (dep[x] > dep[y]) v[x = f[x]] = 1; if (x == y) return x; while (x != y) v[x = f[x]] = 1, v[y = f[y]] = 1; return x; &#125; void dfs2(int x) &#123; insert(x); s[x] = max(s[x], a[x] ^ a[query(x)]); for (int y : G[x]) dfs2(y), s[x] = max(s[x], s[y]); &#125; void dfs1(int x, int type) &#123; Ans[x] = max(Ans[x], s[f[x]]); s[x] = s[f[x]]; insert(x); s[x] = max(s[x], a[x] ^ a[query(x)]); for (int y : G[x]) if (!v[y] || y == son[type]) dfs2(y), s[x] = max(s[x], s[y]); for (int y : G[x]) if (v[y] &amp;&amp; y != son[type]) dfs1(y, type); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); dep[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i), G[f[i]].emplace_back(i); dep[i] = dep[f[i]] + 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", a + i); insert(i); int x = query(i); if ((a[i] ^ a[x]) > ans) ans = a[p = i] ^ a[q = x]; &#125; int lca = LCA(p, q), tmp = lca; for (int x : G[lca]) if (v[x]) son[1] = son[0], son[0] = x; while (tmp) v[tmp = f[tmp]] = 1; memset(val, 0, sizeof val); memset(ch, 0, sizeof ch); tot = 0; dfs1(1, 0); memset(s, 0, sizeof s); memset(val, 0, sizeof val); memset(ch, 0, sizeof ch); tot = 0; dfs1(1, 1); for (int i = 1; i &lt;= n; ++i) printf(\"%lld\\n\", v[i] ? Ans[i] : ans); return 0; &#125; [CF19E] Fairy Portal. æœ¬æ¥å°±æ˜¯äºŒåˆ†å›¾çš„å¯ä»¥éšä¾¿åˆ ã€‚å¯¹äºéäºŒåˆ†å›¾ï¼Œåªèƒ½åˆ æ‰è¢«æ‰€æœ‰å¥‡ç¯è¦†ç›–çš„è¾¹ï¼Œè€Œä¸”ä¸èƒ½è¢«å¶ç¯è¦†ç›–ã€‚æ‰¾ä¸€æ£µæœç´¢æ ‘ï¼Œç„¶åæ£€æŸ¥æ‰€æœ‰è¿”ç¥–è¾¹å³å¯ï¼ˆå› ä¸ºæœç´¢æ ‘ä¸å­˜åœ¨æ¨ªå‰è¾¹ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, cnt, sp, s[10005]; vector&lt;pair&lt;int, int> > G[10005]; vector&lt;int> ans; bool vis[10005], dis[10005], pas[10005]; void dfs(int x) &#123; vis[x] = 1; for (auto [y, i] : G[x]) if (!vis[y]) &#123; dis[y] = dis[x] ^ 1; pas[i] = 1; dfs(y); &#125; else if (!pas[i]) &#123; pas[i] = 1; if (dis[y] == dis[x]) &#123; ++cnt; sp = i; ++s[x], --s[y]; &#125; else --s[x], ++s[y]; &#125; &#125; void dfs2(int x) &#123; vis[x] = 1; for (auto [y, i] : G[x]) if (!vis[y]) &#123; dfs2(y); if (s[y] == cnt) ans.emplace_back(i); s[x] += s[y]; &#125; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1, u, v; i &lt;= m; ++i) &#123; cin >> u >> v; G[u].emplace_back(v, i); G[v].emplace_back(u, i); &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i); if (cnt == 0) &#123; cout &lt;&lt; m &lt;&lt; \"\\n\"; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; i &lt;&lt; \" \"; return cout &lt;&lt; \"\\n\", 0; &#125; if (cnt == 1) ans.emplace_back(sp); for (int i = 1; i &lt;= n; ++i) vis[i] = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs2(i); sort(ans.begin(), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; \"\\n\"; for (int x : ans) cout &lt;&lt; x &lt;&lt; \" \"; return cout &lt;&lt; \"\\n\", 0; &#125; ã€XR-4ã€‘ å¤è¯» Portal. æšä¸¾ä¸€ä¸ªè½®å›èƒ½å¤Ÿåˆ°è¾¾çš„ç‚¹ï¼Œå°†å…¶æ‰€æœ‰éœ€è¦æ„é€ çš„å­æ ‘åˆå¹¶ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m, ans = 1e9, pos, dx; struct Node &#123; int ls, rs; &#125; T[2005], T2[2005]; int get(void) &#123; int c = getchar() - '0', x = ++n; if (c &amp; 1) T[x].ls = get(); if (c &amp; 2) T[x].rs = get(); return x; &#125; void dfs2(int x, int y) &#123; if (x == pos || y == dx) dx = y, y = 1; if (T[x].ls) &#123; if (!T2[y].ls) T2[y].ls = ++m; dfs2(T[x].ls, T2[y].ls); &#125; if (T[x].rs) &#123; if (!T2[y].rs) T2[y].rs = ++m; dfs2(T[x].rs, T2[y].rs); &#125; &#125; void dfs(int x, int dep) &#123; m = 1; memset(T2, 0, sizeof T2); pos = x; dx = 0; dfs2(1, 1); ans = min(ans, (m - 1) * 2 - dep + 1); if (T[x].ls) dfs(T[x].ls, dep + 1); if (T[x].rs) dfs(T[x].rs, dep + 1); &#125; int main(void) &#123; get(); dfs(1, 1); return !printf(\"%d\\n\", ans); &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"æ•°æ®ç»“æ„","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"æ ‘","slug":"æ ‘","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91/"},{"name":"LCA","slug":"LCA","permalink":"https://james1badcreeper.github.io/tags/LCA/"},{"name":"æ ‘çš„ç›´å¾„","slug":"æ ‘çš„ç›´å¾„","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"æ ‘çš„é‡å¿ƒ","slug":"æ ‘çš„é‡å¿ƒ","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"æ ‘é“¾å‰–åˆ†","slug":"æ ‘é“¾å‰–åˆ†","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"æ ‘ä¸Šå·®åˆ†","slug":"æ ‘ä¸Šå·®åˆ†","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"}]},{"title":"æœ€çŸ­è·¯é—®é¢˜","slug":"notes/å›¾è®º/Shortest-path","date":"2022-08-01T00:00:00.000Z","updated":"2022-08-01T00:00:00.000Z","comments":true,"path":"6bbbc5e9/","link":"","permalink":"https://james1badcreeper.github.io/6bbbc5e9/","excerpt":"æœ€çŸ­è·¯æ˜¯å›¾è®ºä¸­çš„å¸¸è€ƒé—®é¢˜ï¼Œæœ¬æ–‡å¼•å¯¼ä½ å­¦ä¹ æœ€çŸ­è·¯çš„ Floydï¼ŒBellmanFord åŠ Djikstra ç®—æ³•ï¼Œä»¥åŠå®ƒä»¬çš„å„ç§åº”ç”¨ã€‚è¿˜æœ‰ä¸€ç§åŸºäºæœ€çŸ­è·¯çš„ç³»ç»Ÿï¼šå·®åˆ†çº¦æŸç³»ç»Ÿã€‚","text":"æœ€çŸ­è·¯æ˜¯å›¾è®ºä¸­çš„å¸¸è€ƒé—®é¢˜ï¼Œæœ¬æ–‡å¼•å¯¼ä½ å­¦ä¹ æœ€çŸ­è·¯çš„ Floydï¼ŒBellmanFord åŠ Djikstra ç®—æ³•ï¼Œä»¥åŠå®ƒä»¬çš„å„ç§åº”ç”¨ã€‚è¿˜æœ‰ä¸€ç§åŸºäºæœ€çŸ­è·¯çš„ç³»ç»Ÿï¼šå·®åˆ†çº¦æŸç³»ç»Ÿã€‚ æ¦‚å¿µ æ¾å¼›ã€‚æœ€çŸ­è·¯çš„æ ¸å¿ƒæ€æƒ³æ˜¯æ¾å¼›ï¼Œå³æ‰¾ä¸€ä¸ªç‚¹ Cï¼Œå¦‚æœä» A åˆ° B çš„è·ç¦»æ¯”ä» A åˆ° C å†åˆ° B çš„è·ç¦»é•¿ï¼Œé‚£ä¹ˆæ›´æ–°æœ€çŸ­è·¯ï¼Œè¿™ä¾¿æ˜¯æ¾å¼›æ“ä½œã€‚ ç¯ã€‚è¦è®¤è¯†åˆ°ä¸€ä¸ªäº‹å®ã€‚å¦‚æœæœ€çŸ­è·¯å­˜åœ¨ï¼Œä¸€å®šæ˜¯ä¸ªä¸å«ç¯çš„æœ€çŸ­è·¯ã€‚å› ä¸ºå¦‚æœå®ƒæ˜¯æ­£ç¯ï¼ˆè¾¹æƒå’Œä¸ºæ­£æ•°ï¼‰ï¼Œèµ°å®ƒæ˜¯è‡ªå¯»æ­»è·¯ï¼›å¦‚æœå®ƒæ˜¯é›¶ç¯ï¼Œèµ°å®ƒæ²¡æœ‰æ„ä¹‰ï¼›å¦‚æœå®ƒæ˜¯è´Ÿç¯ï¼Œåˆ™ä¸å­˜åœ¨æœ€çŸ­è·¯äº†ï¼ˆä¸€ç›´è½¬åœˆåˆ·åˆ†ï¼Œæˆ–è€…è¯´å­˜åœ¨é•¿åº¦ä¸º -INF çš„æœ€çŸ­è·¯ï¼Œå½“ç„¶ï¼Œå‰ææ˜¯è¿™ä¸ªè´Ÿç¯èƒ½èµ°åˆ°ï¼‰ã€‚ å¯¹äºæ— æƒå›¾ï¼ˆæˆ–è€… 01 æƒå€¼ï¼ŒBFS æ—¶åŒç«¯é˜Ÿåˆ—ç»´æŠ¤å³å¯ï¼‰çš„æœ€çŸ­è·¯ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ BFS æ¥æ±‚è§£ã€‚ å¤šæºæœ€çŸ­è·¯ æŒ‡æ±‚ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯çš„é—®é¢˜ï¼Œä¸€èˆ¬ä½¿ç”¨ç®€å•å¥½å†™çš„ Floyd ç®—æ³•ï¼ˆå…¨ç§°ä¸º Floyd-Warshallï¼‰ã€‚ Floyd éå¸¸ç®€å•ï¼Œç”¨é‚»æ¥çŸ©é˜µå­˜å›¾ï¼Œåˆå§‹åŒ–è¾¹ä¸ºè·ç¦»ï¼Œå…¶å®ƒè·ç¦»ä¸ºæ— ç©·å¤§ï¼Œè·‘ä¸‹é¢çš„ä»£ç ï¼ˆæ³¨æ„å¾ªç¯é¡ºåºï¼ï¼‰ï¼š for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); å—¯ï¼Œéå¸¸ç®€å•ï¼Œä½†æ€ä¹ˆè¯æ˜å‘¢ï¼Ÿ å¥½ï¼Œç»™ç‚¹æç¤ºï¼Œè¿™å®é™…ä¸Šæ˜¯ä¸ª DPï¼Œè€Œä¸”æ•°ç»„çš„ç¬¬ä¸€ç»´è¢«æ»šæ‰äº†ã€‚ å®é™…ä¸Šï¼Œè®¾ D[k,i,j]D[k,i,j]D[k,i,j] ä¸ºç»è¿‡è‹¥å¹²ç¼–å·ä¸è¶…è¿‡ kkk çš„èŠ‚ç‚¹çš„ iii åˆ° jjj çš„æœ€çŸ­è·¯é•¿åº¦ã€‚é‚£ä¹ˆæœ‰ä¸¤ç§é€‰æ‹©ï¼šç»è¿‡ç¼–å·ä¸è¶…è¿‡ kâˆ’1k-1kâˆ’1 çš„ç‚¹ï¼Œæˆ–è€…ä» iii åˆ° kkk å†åˆ° jjjï¼Œä¹Ÿå°±æ˜¯ D[k,i,j]=minâ¡{D[kâˆ’1,i,j],D[kâˆ’1,i,k]+D[kâˆ’1,k,j]}D[k,i,j]=\\min\\{D[k-1,i,j], D[k-1,i,k]+D[k-1,k,j]\\}D[k,i,j]=min{D[kâˆ’1,i,j],D[kâˆ’1,i,k]+D[kâˆ’1,k,j]} æ”¹å˜æ¾å¼›æ“ä½œï¼Œå°±å¯ä»¥æ±‚ä¸åŒçš„è·¯å¾„ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œå¦‚æœæ±‚å›¾çš„è¿é€šæ€§ï¼Œé‚£ä¹ˆè¿™ä¸€é—®é¢˜è¢«ç§°ä¸ºä¼ é€’é—­åŒ…ã€‚ä»£ç æ˜¯ d[i][j] |= (d[i][k] &amp; d[k][j])ã€‚ Floyd çš„æ—¶é—´å¤æ‚åº¦æ˜¯ Î˜(n3)\\Theta(n^3)Î˜(n3)ã€‚ æœ‰çš„æ—¶å€™ä½ ä¼šåœ¨ç½‘ä¸Šçœ‹åˆ°ä¸€ç§åˆ¤æ–­ k, i, j æ˜¯å¦ä¸ç›¸ç­‰çš„ä»£ç ï¼Œä½†æ˜¯æ²¡æœ‰å¿…è¦ã€‚å› ä¸ºå³ä½¿å…¶ä¸­æœ‰å˜é‡ç›¸ç­‰ï¼Œå®ƒçš„ç»“æœä¹Ÿä¼šæ˜¯æ­£ç¡®çš„ã€‚ è¯´ä¸ªæœ‰è¶£çš„äº‹æƒ…ï¼Œå³ä½¿å¾ªç¯é¡ºåºé”™è¯¯ï¼Œåªè¦è¿ç»­è·‘ä¸‰é Floydï¼Œå®ƒçš„ç»“æœä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚ Johnson ä¸€ç§ç‰¹æ®Šçš„å¤šæºæœ€çŸ­è·¯ç®—æ³•ï¼Œå¯ä»¥åšåˆ° O(nmlogâ¡m)O(nm \\log m)O(nmlogm) çš„å¤æ‚åº¦æ¥æ±‚è§£ï¼ˆDijkstra çš„å¤æ‚åº¦æ˜¯ O(mlogâ¡m)O(m\\log m)O(mlogm)ï¼Œä½†å®ç”¨æ€§ä¸é«˜ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªå·±äº†è§£å­¦ä¹ ã€‚ Floyd çš„é¢˜ç›® æˆ‘ä»¬æ¥å‡ é“ç®€å•é¢˜ã€‚ [Luogu 1119] ç¾åé‡å»º Portal. ç›´æ¥ä½¿ç”¨ Floyd ç®—æ³•ã€‚å› ä¸ºæˆ‘ä»¬çŸ¥é“ Floyd æ˜¯ä¸ªä»¥â€œåˆ°è¾¾ç‚¹çš„ç¼–å·â€ä¸ºé˜¶æ®µçš„ DP ç®—æ³•ï¼Œè¿™è·Ÿé¢˜ç›®çš„è¦æ±‚æ­£å¥½ç¬¦åˆã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x; &#125; int n, m; int d[205][205]; int t[205]; int main(void) &#123; n = read(), m = read(); memset(d, 0x3f, sizeof(d)); for (int i = 0; i &lt; n; ++i) &#123; t[i] = read(); d[i][i] = 0; &#125; while (m--) &#123; int x = read(), y = read(), v = read(); d[x][y] = v; d[y][x] = v; &#125; int q = read(), k = 0; while (q--) &#123; int x = read(), y = read(), T = read(); for (; t[k] &lt;= T &amp;&amp; k &lt; n; ++k) // æ ¸å¿ƒ for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); if (t[x] > T || t[y] > T || d[x][y] == 0x3f3f3f3f) puts(\"-1\"); // å¯èƒ½è¿™ä¸ªæ‘åº„ä¾æ—§å¤„äºæŠ¥åºŸ else printf(\"%d\\n\", d[x][y]); &#125; return 0; &#125; æ—¶é—´å¤æ‚åº¦ O(n3)O(n^3)O(n3)ã€‚ [UVa 10048] Audiophobia Portal ä¹Ÿå¯ä»¥ä½¿ç”¨ Floydã€‚æˆ‘ä»¬æ±‚çš„è¿˜æ˜¯æœ€çŸ­è·¯ï¼Œè·¯å¾„ä¸­çš„åŠ æ³•å˜æˆäº† max è€Œå·²ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int c, s, q, kase = 0; int d[105][105]; int main(void) &#123; while (scanf(\"%d%d%d\", &amp;c, &amp;s, &amp;q) == 3 &amp;&amp; c) &#123; if (kase) putchar('\\n'); printf(\"Case #%d\\n\", ++kase); memset(d, 0x7f, sizeof(d)); while (s--) &#123; int x, y, val; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;val); d[x][y] = min(d[x][y], val); d[y][x] = min(d[y][x], val); &#125; for (int i = 1; i &lt;= c; ++i) d[i][i] = 0; for (int k = 1; k &lt;= c; ++k) for (int i = 1; i &lt;= c; ++i) for (int j = 1; j &lt;= c; ++j) d[i][j] = min(d[i][j], max(d[i][k], d[k][j])); while (q--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); if (d[x][y] == 0x7f7f7f7f) puts(\"no path\"); else printf(\"%d\\n\", d[x][y]); &#125; &#125; return 0; &#125; [UVa 247] Calling Circles Portal. ç”¨ Floyd æ±‚å‡ºä¼ é€’é—­åŒ…å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #include &lt;cstring> #include &lt;vector> using namespace std; int n, m, kase; vector &lt;string> names; bool f[30][30], vis[30]; char a[100], b[100]; int ID(const string &amp;s) &#123; for (int i = 0; i &lt; names.size(); ++i) if (names[i] == s) return i; names.push_back(s); return names.size() - 1; &#125; void dfs(int u) &#123; vis[u] = true; for (int v = 0; v &lt; n; ++v) if (!vis[v] &amp;&amp; f[u][v] &amp;&amp; f[v][u]) &#123; cout &lt;&lt; \", \" &lt;&lt; names[v]; dfs(v); &#125; &#125; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; names.clear(); memset(f, 0, sizeof(f)); for (int i = 0; i &lt; n; ++i) f[i][i] = 1; while (m--) &#123; scanf(\"%s%s\", a, b); f[ID(a)][ID(b)] = 1; &#125; for (int k = 0; k &lt; n; ++k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) f[i][j] |= f[i][k] &amp; f[k][j]; if (kase) putchar('\\n'); printf(\"Calling circles for data set %d:\\n\", ++kase); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; n; ++i) if (!vis[i]) &#123; cout &lt;&lt; names[i]; dfs(i); putchar('\\n'); &#125; &#125; return 0; &#125; è´Ÿç¯ Floyd å¯ä»¥åˆ¤æ–­æ˜¯å¦æœ‰è´Ÿç¯ã€‚å¦‚æœä»ä¸€ä¸ªç‚¹ç»•äº†ä¸€åœˆå›åˆ°äº†è‡ªå·±ï¼Œæ­£å¸¸æƒ…å†µä¸‹ f(i,i)=0f(i,i)=0f(i,i)=0ï¼Œä½†å¦‚æœè·‘äº†ä¸€ä¸ªè´Ÿç¯ï¼Œå®ƒå°±ä¼šå˜æˆè´Ÿæ•°ã€‚ [USACO06DEC] Wormholes G. ä½¿ç”¨ Floyd åˆ¤æ–­è´Ÿç¯å³å¯ï¼Œéœ€è¦å¸æ°§ï¼ˆä¸å¸æ°§éœ€è¦ä½¿ç”¨åæ–‡ä»‹ç»çš„ SPFAï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m, w; int f[505][505]; int main(void) &#123; int T = read(); while (T--) &#123; memset(f, 0x3f, sizeof(f)); n = read(), m = read(), w = read(); while (m--) &#123; int x = read(), y = read(), v = read(); f[x][y] = min(f[x][y], v); f[y][x] = min(f[y][x], v); &#125; while (w--) &#123; int x = read(), y = read(); f[x][y] = min(f[x][y], -read()); &#125; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) f[i][j] = min(f[i][j], f[i][k] + f[k][j]); bool flag = true; for (int i = 1; i &lt;= n; ++i) if (f[i][i] &lt; 0) &#123; puts(\"YES\"); flag = false; break; &#125; if (flag) puts(\"NO\"); &#125; return 0; &#125; æœ€å°ç¯é—®é¢˜ ç»™å®šä¸€å¼ å›¾ï¼Œæ±‚å›¾ä¸­ä¸€ä¸ªè‡³å°‘åŒ…å« 333 ä¸ªç‚¹çš„ç¯ï¼Œç¯ä¸Šçš„èŠ‚ç‚¹ä¸é‡å¤ï¼Œå¹¶ä¸”ç¯ä¸Šçš„è¾¹çš„é•¿åº¦ä¹‹å’Œæœ€å°ã€‚è¯¥é—®é¢˜ç§°ä¸ºå›¾çš„æœ€å°ç¯é—®é¢˜ã€‚ æ¨¡æ¿ã€‚æ³¨æ„ï¼ŒFloyd åªèƒ½è§£å†³æ— å‘å›¾çš„æœ€å°ç¯é—®é¢˜ã€‚ å¯ä»¥å‘ç°ï¼Œæœ€å°ç¯çš„é•¿åº¦å°±æ˜¯ minâ¡1â‰¤i&lt;j&lt;k{d[i,j]+a[i,k]+a[k,j]}\\min\\limits_{1\\le i&lt;j&lt;k}\\{d[i,j]+a[i,k]+a[k,j]\\}1â‰¤i&lt;j&lt;kminâ€‹{d[i,j]+a[i,k]+a[k,j]}ï¼Œä»£è¡¨ç»è¿‡èŠ‚ç‚¹ kkkï¼Œç”±ç¼–å·ä¸è¶…è¿‡ kkk çš„èŠ‚ç‚¹æ„æˆï¼ˆi,j,ki,j,ki,j,kï¼‰çš„é¡ºåºæ˜¯ä¸ºäº†ä¿è¯ä¸é‡å¤ç»è¿‡èŠ‚ç‚¹ã€‚ for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt; k; i++) for (int j = i + 1; j &lt; k; j++) ans = min(ans, f[i][j] + a[i][k] + a[k][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) f[i][j] = min(f[i][j], f[i][k] + f[k][j]); &#125; Bellman-Ford è¿™æ˜¯ä¸€ç§ Î˜(nm)\\Theta(nm)Î˜(nm) çš„å•æºæœ€çŸ­è·¯ç®—æ³•ï¼Œå³å¯ä»¥è®¡ç®—å‡ºä» sss åˆ°ä»»æ„ä¸€ç‚¹çš„æœ€çŸ­è·¯ã€‚ åŸç† åŸºäºä¹‹å‰è¯´çš„æœ‰æœ€çŸ­è·¯ï¼Œä¸€å®šæ˜¯ä¸å«ç¯çš„ã€‚é‚£ä¹ˆæˆ‘ä»¬æ’‘æ­»åªè¦è¿­ä»£ nâˆ’1n-1nâˆ’1 æ¬¡ï¼Œæ¯æ¬¡æ£€æŸ¥æ‰€æœ‰çš„è¾¹ï¼Œä¾¿ä¼šæ²¡æœ‰æ›´æ–°çš„å†…å®¹ï¼ˆç¯æ˜¯æ— æ„ä¹‰çš„ï¼‰ï¼Œä¾¿å¯ä»¥å¾—åˆ°æ­£ç¡®çš„æœ€çŸ­è·¯ï¼Œä»£ç å¦‚ä¸‹ï¼š memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; for (int op = 1; op &lt; n; ++op) // è¿­ä»£ n-1 æ¬¡ for (int i = 0; i &lt; edges.size(); ++i) // æ£€æŸ¥æ‰€æœ‰è¾¹ if (dis[edges[i].u] + edges[i].val &lt; dis[edges[i].v]) dis[edges[i].v] = dis[edges[i].u] + edges[i].val; SPFA ä½†æ˜¯ Bellman-Ford ä¹Ÿå¤ªæ…¢äº†å§ï¼Î˜(nm)\\Theta(nm)Î˜(nm) çš„å¤æ‚åº¦ï¼Œè°é¡¶å¾—ä½å•Šï¼ è§£å†³æ–¹æ³•æ˜¯ä½¿ç”¨ SPFAï¼ˆSPFA æ˜¯ Shortest Path Fast Algorithm çš„ç¼©å†™ï¼Œåœ¨ä¸­å›½å¤§é™†ä½¿ç”¨è¿™ä¸€ç§°è°“ã€‚ç”±äºè¿™ç©æ„çš„å¤æ‚åº¦æ˜¯é”™çš„ï¼Œæ‰€ä»¥åœ¨å›½é™…ä¸Šç§°ä¹‹ä¸ºâ€œé˜Ÿåˆ—ä¼˜åŒ–çš„ Bellman-Ford ç®—æ³•â€ï¼‰ã€‚ Bellman-Ford æ¯æ¬¡éƒ½è¦å°†æ‰€æœ‰ç‚¹å¯¹åº”çš„æ‰€æœ‰è¾¹æ¾å¼›ä¸€éï¼Œè¿™å½“ä¸­æœ‰å¾ˆå¤šæµªè´¹ï¼Œå› ä¸ºä¸æ˜¯æ¯ä¸€æ¡è¾¹éƒ½è¦æ¾å¼›çš„ï¼ å°±æ˜¯è¯´ï¼Œå¦‚æœä¸Šä¸€è½®è¿™ä¸ªç‚¹çš„æœ€çŸ­è·¯æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆè¿™ä¸€è½®æˆ‘ä»¬å°±ä¸ç”¨å¯¹è¿™ä¸€ä¸ªç‚¹è¿›è¡Œæ¾å¼›äº†ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¼€ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå¦‚æœèŠ‚ç‚¹åœ¨é˜Ÿåˆ—ä¸­ï¼Œè¡¨ç¤ºæœ€çŸ­è·¯å‘ç”Ÿæ”¹å˜ï¼Œéœ€è¦é‡æ–°è®¡ç®—è¯¥ç‚¹ã€‚ æ¨¡æ¿ã€‚ ä¸ºæ–¹ä¾¿ï¼Œè¿™é‡Œä¹Ÿç»™å‡ºå°è£…å¥½çš„æ•°æ®ç»“æ„ï¼Œä¹‹åä»‹ç» Dijkstra æ—¶ä¹Ÿä¼šä½¿ç”¨ç›¸åŒçš„æ•°æ®ç»“æ„ï¼Œè¿™é‡Œä½¿ç”¨ vectorï¼Œå› ä¸ºå®ƒå¾ˆæ–¹ä¾¿ï¼Œè€Œä¸”åœ¨å„å¤§ç«èµ›éƒ½æ™®éä½¿ç”¨ O2 åï¼Œvector ç”šè‡³æ¯”é“¾å¼å‰å‘æ˜Ÿæ›´å¿«ï¼Œå¯ä»¥çœ‹ä¸€ä¸‹ riteme çš„è¿™ç¯‡åšå®¢ï¼Œç»ç¬”è€…æµ‹è¯•å¼€ O2 åŸºæœ¬æ˜¯ç›¸åŒçš„æ•ˆæœã€‚è‡³äº vector ä¼šå¼€äºŒå€ç©ºé—´ï¼Œä¸€èˆ¬ä¸ä¼šè¢«å¡ã€‚ ä»£ç å¦‚ä¸‹ï¼š void SPFA(void) &#123; memset(d, 0x3f, sizeof d); d[s] = 0; inq[s] = 1; queue &lt;int> q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (auto [v, w] : G[u]) if (d[v] > d[u] + w) &#123; d[v] = d[u] + w; if (!inq[v]) inq[v] = 1, q.push(v); &#125; &#125; &#125; å¹²æ‰ SPFA R.I.P. SPFA 1994~2018 å¯æ€œçš„ SPFA å‘æ˜äººâ€”â€”æ®µå‡¡ä¸. 2018 å¹´ 7 æœˆ 19 æ—¥ï¼ŒæŸä½åŒå­¦åœ¨ NOIDay1T1 å½’ç¨‹ ä¸€é¢˜é‡Œéå¸¸ç†Ÿç»ƒåœ°ä½¿ç”¨äº†ä¸€ä¸ªå¹¿ä¸ºäººçŸ¥çš„ç®—æ³•æ±‚æœ€çŸ­è·¯ã€‚ç„¶åå‘¢ï¼Ÿ100â†’60100 \\rightarrow 60100â†’60Agâ†’Cu\\text{Ag} \\rightarrow \\text{Cu}Agâ†’Cuæœ€ç»ˆï¼Œä»–å› æ­¤æ²¡èƒ½ä¸ç†æƒ³çš„å¤§å­¦è¾¾æˆå¥‘çº¦ã€‚è¿™æ˜¯ NOI2018 çš„çœŸå®ç…§ç‰‡ï¼Œè®²é¢˜äººå…¬å¼€å®£ç§° SPFA å·²æ­» SPFA çš„å¤æ‚åº¦æ˜¯ Î©(kn)\\Omega(kn)Î©(kn)ã€‚å…¶ä¸­ kkk æ˜¯ä¸€ä¸ªè¾ƒå°çš„å¸¸æ•°ï¼Œä½†æ˜¯æ³¨æ„ï¼è¿™é‡Œçš„æ—¶é—´å¤æ‚åº¦ç¬¦å·ä¸å¯¹ï¼Œå®ƒçš„ä¸‹ç•Œæ˜¯è¾ƒå¿«çš„ï¼Œä¸€èˆ¬åœ¨éšæœºå›¾ä¸­ï¼ŒSPFA æ˜¯æœ€å¿«çš„æœ€çŸ­è·¯ç®—æ³•ï¼Œä½†å¦‚æœæ„é€ ç‰¹æ®Šæ•°æ®ï¼ŒSPFA ä¼šè¾¾åˆ° O(nm)O(nm)O(nm) çš„ä¸Šç•Œå¤æ‚åº¦ï¼Œå³é€€åŒ–æˆ Bellman-Fordï¼ˆè€Œä¸”å¸¸æ•°æ›´å¤§ï¼‰ã€‚ å®é™…ä¸Š SPFA åœ¨å›½é™…ä¸Šé€šç§°é˜Ÿåˆ—ä¼˜åŒ–çš„ Bellman-Ford ç®—æ³•ï¼Œå› ä¸ºæ®µå‡¡ä¸æå…¶ä¸è´Ÿè´£ä»»åœ°æå‡ºäº†ä¸€ä¸ªé”™è¯¯çš„è¯æ˜ï¼Œç»™å‡ºå®ƒçš„å¤æ‚åº¦æ˜¯ Î˜(kn)\\Theta(kn)Î˜(kn)ã€‚ æ€ä¹ˆå¹²æ‰ SPFA å‘¢ï¼Ÿæ ¸å¿ƒæ€è·¯æ˜¯ï¼šè®©èŠ‚ç‚¹é¢‘ç¹å…¥é˜Ÿã€‚å¯ä»¥çœ‹ä¸€ä¸‹ fstqwq åœ¨çŸ¥ä¹ä¸Šçš„å›ç­”ã€‚ è´Ÿç¯ SPFA ä¹Ÿä¸æ˜¯ä»€ä¹ˆç”¨ä¹Ÿæ²¡æœ‰ï¼Œå®ƒå¯ä»¥åˆ¤è´Ÿç¯ï¼ˆç›¸æ¯”äº Floydï¼Œå®ƒæ˜¾ç„¶æ›´å¿«ï¼‰ã€‚ å½“ç„¶ Bellman-Ford ä¹Ÿå¯ä»¥åˆ¤æ–­è´Ÿç¯ï¼Œå¦‚æœ nnn è½®ä¹‹åè¿˜æ˜¯æœ‰æ›´æ–°çš„å†…å®¹ï¼Œå°±è¯´æ˜æœ‰äººåœ¨åˆ·åˆ†ï¼Œæœ‰è´Ÿç¯ã€‚ SPFA æœ‰ä¸‰ç§æ–¹æ³•åˆ¤æ–­è´Ÿç¯ã€‚ ç¬¬ä¸€ç§æ–¹æ³•æ˜¯ cnt[v]cnt[v]cnt[v] è¡¨ç¤ºä» sss åˆ° vvv çš„æœ€çŸ­è·¯ç»è¿‡äº†å¤šå°‘ä¸ªç‚¹ï¼Œå¦‚æœ u-&gt;v æ¾å¼›äº† s-&gt;vï¼Œé‚£ä¹ˆå°±è®© cnt[v]cnt[v]cnt[v] æ›´æ–°ä¸º cnt[u]+1cnt[u]+1cnt[u]+1ã€‚ ä¹‹å‰æåˆ°è¿‡ï¼Œä¸€ä¸ªæ­£å¸¸çš„æœ€çŸ­è·¯æ˜¯ä¸åº”è¯¥æœ‰è¶…è¿‡ nnn ä¸ªç‚¹çš„ï¼Œå› æ­¤å½“ cnt[v]&gt;ncnt[v]&gt;ncnt[v]&gt;n çš„æ—¶å€™è¯´æ˜æœ‰å†…é¬¼ï¼Œç»ˆæ­¢äº¤æ˜“ã€‚ ç¬¬äºŒç§æ˜¯è¿™æ ·çš„ï¼šè¿˜æ˜¯è¯´æœ€çŸ­è·¯æœ€å¤šç»è¿‡ nnn ä¸ªç‚¹ï¼Œcnt[v]cnt[v]cnt[v] è¡¨ç¤ºä» vvv å…¥äº†å¤šå°‘æ¬¡é˜Ÿï¼Œå¦‚æœä¸€ä¸ªç‚¹è¶…è¿‡äº† nnn æ¬¡å…¥é˜Ÿï¼Œé‚£ä¹ˆå°±è¯´æ˜è¿˜æ˜¯æœ‰å†…é¬¼ï¼Œå°±æ˜¯æœ‰è´Ÿç¯ï¼ ç¬¬ä¸‰ç§æ–¹å¼æ˜¯ dfs ç‰ˆçš„ SPFA åˆ¤ç¯ã€‚å¦‚æœä¸€ä¸ªç‚¹è¢«æ¾å¼›äº†ï¼Œå°±ç›´æ¥é€’å½’è¿›è¿™ä¸ªç‚¹å»æ¾å¼›åˆ«äººå°±è¡Œäº†ã€‚è€Œå¦‚æœä¸€ä¸ªç‚¹é€’å½’ä¸€åœˆåˆå›åˆ°è‡ªå·±äº†ï¼Œé‚£æ˜¾ç„¶æ˜¯æœ‰è´Ÿç¯çš„ã€‚ ä¸€èˆ¬ç¬¬äºŒç§æ–¹æ³•å¾ˆæ…¢ï¼ˆéœ€è¦ç»•ç€ç¯è·‘ nnn æ¬¡æ‰èƒ½æ‰¾åˆ°è´Ÿç¯ï¼‰ï¼Œè€Œç¬¬ä¸‰ç§æ–¹æ³•æ¯”ç¬¬ä¸€ç§å¿«ã€‚ä½†æ˜¯å¾ˆå°‘æœ‰ç¬¬ä¸€ç§ä¸å¤Ÿå¿«çš„æ—¶å€™ï¼Œè€Œä¸”ç¬¬ä¸‰ç§æ–¹æ³•å¾ˆå¯èƒ½ä¼šä¸¥é‡é™ä½è´Ÿç¯ä¸å­˜åœ¨æ—¶çš„æœ€çŸ­è·¯è®¡ç®—æ•ˆç‡ï¼Œè¿˜æœ‰å¯èƒ½æœ‰å…¶å®ƒå‰¯ä½œç”¨ï¼Œä¸å»ºè®®ä½¿ç”¨ã€‚è¿™é‡Œç»™å‡ºç¬¬ä¸€ç§æ–¹æ³•çš„ä»£ç ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nm)O(nm)O(nm)ã€‚ å¯ä»¥å‚è€ƒæ¨¡æ¿ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; struct edge &#123; int from, to, dist; edge(int from = 0, int to = 0, int dist = 0) : from(from), to(to), dist(dist) &#123;&#125; &#125;; int n, m; int d[10005], inq[10005]; vector &lt;edge> G[10005]; int cnt[100005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(u, v, d)); &#125; bool SPFA() &#123; memset(d, 0x3f, sizeof(d)); memset(cnt, 0, sizeof(cnt)); memset(inq, 0, sizeof(inq)); d[1] = 0; inq[1] = true; queue &lt;int> q; q.push(1); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; cnt[e.to] = cnt[u] + 1; if (cnt[e.to] > n) return true; if (!inq[e.to]) &#123; inq[e.to] = 1; q.push(e.to); &#125; &#125; &#125; &#125; return false; &#125; int main(void) &#123; int T = read(); while (T--) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) G[i].clear(); while (m--) &#123; int u = read(), v = read(), w = read(); addedge(u, v, w); if (w >= 0) addedge(v, u, w); &#125; puts(SPFA() ? \"YES\" : \"NO\"); &#125; return 0; &#125; è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœå›¾ä¸­æœ‰è´Ÿç¯ä½†æ˜¯èµ·ç‚¹ sss èµ°ä¸åˆ°è¿™ä¸ªè´Ÿç¯ï¼Œé‚£ä¹ˆæ— æ³•æ‰¾åˆ°ã€‚è§£å†³æ–¹æ³•æ˜¯å¤–æŒ‚ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè·Ÿæ¯ä¸€ä¸ªç‚¹éƒ½è¿ä¸€æ¡è¾¹ï¼Œç„¶åå¯¹è¿™ä¸ªç‚¹è·‘ SPFAã€‚ Dijkstra æ—¢ç„¶ SPFA éƒ½ä¼šè¢«å¡ï¼Œé‚£æˆ‘ä»¬ç”¨ä»€ä¹ˆï¼Ÿç­”æ¡ˆæ˜¯ï¼šDijkstraã€‚ åŸç†ä¸å®ç° Dijkstra åŸºäºè´ªå¿ƒçš„æ€æƒ³ã€‚å¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š åˆå§‹åŒ– d[s]=0d[s]=0d[s]=0ï¼Œå…¶ä½™ä¸º INFã€‚ æ‰¾å‡ºä¸€ä¸ªæ²¡æœ‰è¢«è®¿é—®çš„ï¼Œd[x]d[x]d[x] æœ€å°çš„ xxxï¼Œç„¶åè®¿é—® xxxã€‚ æ‰«æ xxx æ‰€æœ‰çš„å‡ºè¾¹ï¼Œè¿›è¡Œæ¾å¼›ã€‚ è¿­ä»£æ­¥éª¤ 2~3 nâˆ’1n-1nâˆ’1 æ¬¡ã€‚ æ‰€ä»¥è¯´ï¼ŒDijkstra çš„æ€è·¯å°±æ˜¯â€œæˆ‘æ‰¾å½“å‰æœ€è¿‘çš„è·¯èµ°ï¼Œä¸€å®šèƒ½æ‰¾åˆ°æœ€çŸ­è·¯â€ã€‚ä½†è¿™æ„å‘³ç€ï¼Œå¦‚æœå›¾ä¸­å­˜åœ¨è´Ÿæƒè¾¹ï¼Œé‚£ä¹ˆ Dijkstra å¯èƒ½ä¼šé¼ ç›®å¯¸å…‰ï¼Œå¿½ç•¥äº†å‰æ–¹è¿˜æœ‰å¾ˆå°çš„è´Ÿæƒè¾¹çš„å¯èƒ½ï¼Œæ‰€ä»¥ Dijkstra åªå¯ç”¨äºæ­£æƒå›¾ï¼ å…·ä½“è¯æ˜è¯·è¯»è€…è‡ªè¡ŒæŸ¥æ‰¾ï¼ˆåœ¨ OI-wiki ä¸Šæœ‰ï¼‰ã€‚ ä¸‹é¢æ˜¯ä»£ç ï¼š int v[5005], d[5050]; memset(d, 0x3f, sizeof(d)); memset(a, 0x3f, sizeof(a)); read_graph(); memset(v, 0, sizeof(v)); d[1] = 0; for (int op = 1; op &lt; n; ++op) // è¿­ä»£ n-1 æ¬¡ &#123; int x = 0; // æ‰¾ x for (int i = 1; i &lt;= n; ++i) if (v[i] == 0 &amp;&amp; (x == 0 || d[i] &lt; d[x])) x = i; v[x] = 1; // æ¾å¼› for (int i = 1; i &lt;= n; ++i) d[i] = min(d[i], d[x] + a[x][i]); &#125; è€Œä¸”ç”±äº Dijkstra çš„è´ªå¿ƒæ€æƒ³ï¼Œä½¿ç”¨å‰å¿…é¡»æ»¡è¶³å½“å‰çš„æœ€ä¼˜å†³ç­–å°±æ˜¯æœ€ç»ˆçš„æœ€ä¼˜å†³ç­–ã€‚ ä¼˜åŒ– ç„¶è€Œè¿˜æ˜¯å¾ˆæ…¢ï¼Œä¸Šè¿°ä»£ç çš„å¤æ‚åº¦é«˜è¾¾ Î˜(n2)\\Theta(n^2)Î˜(n2)ï¼Œn=105n = 10^5n=105 çš„æ—¶å€™ç›´æ¥å‘Šè¾ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆä¸Šè¿°ä»£ç é‡‡ç”¨é‚»æ¥çŸ©é˜µçš„åŸå› ã€‚ ä½†æ˜¯æœ‰ä¼˜åŒ–ï¼ˆå•Šï¼Œå°å¿ƒåœ¨ä¸åŒçš„æ•°æ®èŒƒå›´ä¸‹å¯èƒ½æ˜¯è´Ÿä¼˜åŒ–ï¼Œæ¯”å¦‚ m=n2m = n^2m=n2ï¼‰ï¼ å› ä¸ºâ€æ‰¾å‡ºä¸€ä¸ªæ²¡æœ‰è¢«è®¿é—®çš„ï¼Œd[x]d[x]d[x] æœ€å°çš„ xxxï¼Œç„¶åè®¿é—® xxxâ€œè¿™ä¸€æ“ä½œå®å±è´¹æ—¶è´¹åŠ›ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨æ•°æ®ç»“æ„ä»£æ›¿ï¼Œä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ä¸º O((n+m)logâ¡n)O((n+m)\\log n)O((n+m)logn)ã€‚ ç”±äºé™¤äº†ä¼˜å…ˆé˜Ÿåˆ—æ˜¯ STL å°±æœ‰çš„ï¼Œå‰©ä¸‹çš„æ•°æ®ç»“æ„æ‰‹å†™å·¨å¤æ‚ï¼Œè¶…çº§éš¾å†™ä¸”å®¹æ˜“çˆ†ç‚¸ï¼Œè€Œä¸”æ•ˆç‡å·®ä¸äº†å¤ªå¤šï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜æ˜¯ç”¨ä¼˜å…ˆé˜Ÿåˆ—å§ã€‚ ä¸‹é¢æ˜¯ä»£ç ï¼Œè¿™å¥—ä»£ç å¯ä»¥é€šè¿‡ æ¨¡æ¿ï¼š void Dijkstra(void) &#123; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; // å°æ ¹å † memset(d, 0x3f, sizeof(d)); q.emplace(0, d[s] = 0); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (v[u) continue; // æ²¡æœ‰è¢«è®¿é—®è¿‡ v[u] = true; for (auto [v, w] : G[u]) if (d[v] > d[u] + w) q.emplace(d[v] = d[u] + w, v); &#125; &#125; å€¼å¾—æ³¨æ„çš„æ˜¯è¿™ä¸ªå…¥é˜Ÿçš„æ–¹å¼ã€‚æ­£å¸¸æ¥è®²æˆ‘ä»¬åº”è¯¥ä¿®æ”¹é˜Ÿåˆ—ä¸­çš„ d[e.to]d[e.to]d[e.to]ï¼Œä½†æ˜¯ STL ä¸æ”¯æŒè¿™ç§æ“ä½œã€‚æ‰€ä»¥æˆ‘ä»¬å†å…¥ä¸€ä¸ªé˜Ÿï¼Œå€¼å°çš„è‡ªç„¶ä¼šå…ˆå‡ºé˜Ÿï¼Œæ‰€ä»¥æ­£ç¡®æ€§æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚å½“ç„¶ä¹Ÿå¯ä»¥åˆ¤æ–­å½“å‰åˆ°æ­¤çš„è·ç¦»æ˜¯å¦å°äºæœ€çŸ­è·¯ï¼Œä»è€Œçœæ‰ä¸€ä¸ª v æ•°ç»„ï¼Œæ¥ä¸‹æ¥çš„æ¬¡çŸ­è·¯ä¹Ÿç”¨åˆ°äº†ç±»ä¼¼çš„æ€æƒ³ã€‚ æˆ‘ç©¶ç«Ÿç”¨ä»€ä¹ˆç®—æ³•ï¼Ÿ è¿™ä¸ªé—®é¢˜å·²ç»å¾ˆæ˜¾ç„¶äº†ï¼Œè¿™é‡Œåˆ—å‡ºè¡¨æ ¼ç»™å¤§å®¶å‚è€ƒï¼ˆç»¿è‰²å­—ä½“æ„ä¸ºè¿™ç±»é¢˜ç›®å°‘è§ï¼Œåˆå­¦é˜¶æ®µå¯ä¸å¿…å­¦ä¹ ï¼›è“è‰²æ„ä¸ºè¦æ±‚æ•°æ®éšæœºï¼‰ï¼š æœ€çŸ­è·¯ nâ‰¤300n \\le 300nâ‰¤300 nâ‰¤103,mâ‰¤104n\\le 10^3, m\\le 10^4nâ‰¤103,mâ‰¤104 nâ‰¤105,mâ‰¤106n\\le 10^5, m\\le 10^6nâ‰¤105,mâ‰¤106 å¤šæº Floyd Johnson N/A æ— è´Ÿæƒå•æº Floyd Dijkstra ä¼˜å…ˆé˜Ÿåˆ— Dijkstra æœ‰è´Ÿæƒå•æº Floyd Belman-Ford æˆ– SPFA SPFA å¦‚æœè¿™é¢˜è¦æ±‚æœ‰è´Ÿæƒå•æºæœ€çŸ­è·¯ï¼Œè€Œä¸”æ²¡ä¿è¯æ•°æ®éšæœºï¼Œåˆ™æœ‰ä¸¤ç§å¯èƒ½ï¼šä¸€æ˜¯æ¯’ç˜¤å‡ºé¢˜äººå°±æ˜¯æ²¡å†™ï¼ŒäºŒæ˜¯ä½ çœŸçš„å»ºé”™æ¨¡å‹äº†ï¼Œè¿™é¢˜å¯ä»¥è½¬åŒ–ä¸ºæ— è´Ÿæƒå•æºæœ€çŸ­è·¯æˆ–è€…å®ƒå‹æ ¹å°±ä¸æ˜¯æœ€çŸ­è·¯ã€‚ æ³¨æ„ï¼å¦‚æœä¸€å¼ å›¾æ˜¯ç¨ å¯†å›¾ï¼ˆå›¾çš„è¾¹æ•°æ¥è¿‘ç‚¹æ•°çš„å¹³æ–¹ï¼Œå¦åˆ™å°±æ˜¯ç¨€ç–å›¾ï¼‰ï¼Œé‚£ä¹ˆè¿™æ—¶å°±ä½¿ç”¨ä¸ä¼˜åŒ–çš„ Dijkstraï¼Œåè€Œæ¯”ä¼˜åŒ–çš„å¥½ã€‚ å°±æ˜¯è¿™ä¹ˆç®€å•ã€‚ æœ€çŸ­è·¯çš„æŠ€å·§ è™½ç„¶æœ€çŸ­è·¯çš„ç®—æ³•æˆ‘ä»¬éƒ½å­¦ä¹ å®Œæ¯•äº†ï¼Œä½†æ˜¯è¿˜è¿œè¿œä¸å¤Ÿã€‚å¦‚æœæœ€çŸ­è·¯åªæœ‰ä»¥ä¸Šé‚£äº›å†…å®¹ï¼Œé‚£ä¹ˆå®ƒå¾ˆç®€å•ï¼Œä½†äº‹å®ä¸Šå¹¶ä¸æ˜¯ã€‚æœ€çŸ­è·¯æœ‰å¾ˆå¤šæŠ€å·§ï¼Œæˆ‘ä»¬æ¥çœ‹å‡ ä¸ªç»å…¸çš„ã€‚ æœ€çŸ­è·¯çš„æ‰“å° å—¯ï¼Œæœ€çŸ­è·¯è¿˜å¯ä»¥æ‰“å°ã€‚ æ€ä¹ˆæ‰“ï¼Ÿæ¯æ¬¡æ¾å¼›çš„æ—¶å€™è®°å½•ä¸€ä¸‹ä¸å°±å®Œäº‹äº†ï¼Ÿ ä»¥ Dijkstra ä¸ºä¾‹ï¼š int p[100005]; void dijkstra(void) &#123; #define pii pair&lt;int, int> priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii> > q; memset(d, 0x3f, sizeof(d)); d[s] = 0; q.push(make_pair(0, s)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (v[u] == 0) &#123; v[u] = 1; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[u] + e.dist &lt; d[e.to]) &#123; d[e.to] = d[u] + e.dist; p[e.to] = u; // è®°å½•ä»å“ªä¸ªç‚¹æ¥ q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; &#125; void print(int s, int t) // æ‰“å° s åˆ° t çš„æœ€çŸ­è·¯ &#123; if (s == t) // æ˜¯èµ·ç‚¹ &#123; printf(\"%d \", s); return; &#125; print(s, p[t]); // æ‰“å°å‰ä¸€ä¸ªç‚¹ printf(\"%d \", t); //æ‰“å°å½“å‰çš„ç‚¹ &#125; å›ºå®šç»ˆç‚¹çš„æœ€çŸ­è·¯ [Luogu 1629] é‚®é€’å‘˜é€ä¿¡ã€‚ å¯ä»¥çœ‹å‡ºé¢˜ç›®è¦åˆ†åˆ«æ±‚å›ºå®šèµ·ç‚¹ï¼ˆä» 111 èµ°ï¼‰å’Œå›ºå®šç»ˆç‚¹ï¼ˆèµ°å› 111ï¼‰çš„æœ€çŸ­è·¯ã€‚å‰è€…å¯ä»¥ç›´æ¥ä½¿ç”¨ Dijkstra ç®—æ³•ï¼Œä½†åè€…æ€ä¹ˆåŠï¼Ÿ æƒ³ä¸€æƒ³ï¼Œæ­£å¸¸çš„å•æºæœ€çŸ­è·¯æ±‚çš„æ˜¯ä»ä¸€ä¸ªèµ·ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯ï¼Œå¦‚æœè¿™æ˜¯æ— å‘å›¾ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠè¿™ä¸ªæœ€çŸ­è·¯åè¿‡æ¥å°±æ˜¯æ‰€æœ‰ç‚¹åˆ°è¿™ä¸ªèµ·ç‚¹çš„æœ€çŸ­è·¯ï¼ˆå°±æ˜¯è·¯å¾„æ˜¯åç€çš„ï¼‰ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œä» iii èµ°åˆ° 111 çš„æœ€çŸ­è·¯ï¼Œå°±æ˜¯ä» 111 èµ°åˆ° iii çš„æœ€çŸ­è·¯å¾„å€’ç€èµ°ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #include &lt;queue> using namespace std; struct edge &#123; int from, to, dist; edge(int from = 0, int to = 0, int dist = 0) : from(from), to(to), dist(dist) &#123;&#125; &#125;; struct solver &#123; vector &lt;edge> G[1005]; int d[1005]; bool v[1005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(u, v, d)); &#125; void Dijkstra(void) &#123; memset(d, 0x3f, sizeof(d)); d[1] = 0; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.push(make_pair(0, 1)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!v[u]) &#123; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; &#125; &#125;A, B; int main(void) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); A.addedge(u, v, d); B.addedge(v, u, d); &#125; A.Dijkstra(); B.Dijkstra(); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += A.d[i] + B.d[i]; printf(\"%d\\n\", ans); return 0; &#125; åˆ†å±‚å›¾æœ€çŸ­è·¯ [JLOI2011] é£è¡Œè·¯çº¿ã€‚ æ³¨æ„åˆ° kkk çš„èŒƒå›´å¾ˆå°ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨åˆ†å±‚å›¾ï¼Œä¸‹é¢ä»‹ç»ä»€ä¹ˆæ˜¯åˆ†å±‚å›¾ã€‚ å°†åŸå›¾å¤åˆ¶ kkk æ¬¡ï¼ŒåŸæ¥ç¼–å·ä¸º iii çš„èŠ‚ç‚¹å¤åˆ¶ä¸ºç¼–å· i+jni+jni+jn çš„èŠ‚ç‚¹ã€‚ç„¶åç¬¬ jjj å±‚å’Œç¬¬ j+1j+1j+1 å±‚çš„å¯¹åº”èŠ‚ç‚¹ä¹Ÿè¦è¿ä¸Šè¾¹ï¼Œè¾¹æƒå€¼ä¸º 000ï¼Œè€Œä¸”æ˜¯å•å‘è¾¹ï¼ˆæœ€å¤šå…è´¹ä¹˜å kkk æ¬¡ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; int n, m, k, s, t; int d[110005]; bool v[110005]; vector &lt;edge> G[110005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(v, d)); &#125; void Dijkstra(void) &#123; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; memset(d, 0x3f, sizeof(d)); d[s] = 0; q.push(make_pair(0, s)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!v[u]) &#123; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;s, &amp;t); for (int i = 0, u, v, d; i &lt; m; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); addedge(u, v, d); addedge(v, u, d); for (int j = 1; j &lt;= k; ++j) &#123; addedge(u + j * n, v + j * n, d); addedge(v + j * n, u + j * n, d); addedge(u + (j - 1) * n, v + j * n, 0); addedge(v + (j - 1) * n, u + j * n, 0); &#125; &#125; Dijkstra(); int ans = 0x7fffffff; for (int i = 0; i &lt;= k; ++i) ans = min(ans, d[t + i * n]); printf(\"%d\\n\", ans); return 0; &#125; æœ€çŸ­è·¯çš„æ€§è´¨ æœ€çŸ­è·¯æœ‰ä¸€æ¡é‡è¦çš„æ€§è´¨ï¼šæœ€çŸ­è·¯ä¸­çš„ä¸€éƒ¨åˆ†ä¾ç„¶æ˜¯æœ€çŸ­è·¯ã€‚é‡‡ç”¨åè¯æ³•ï¼Œå¦‚æœå­˜åœ¨ä¸€æ¡è·¯å¾„æ¯”é‚£ä¸€éƒ¨åˆ†æ›´çŸ­ï¼Œé‚£ä¹ˆå¯ä»¥ç”¨è¿™æ¡è·¯å¾„æ›¿æ¢é‚£ä¸€éƒ¨åˆ†ï¼ŒåŸå…ˆçš„æ•´æ¡è·¯å°±ä¸æ˜¯æœ€çŸ­è·¯ã€‚ æœ€çŸ­è·¯æ ‘ï¼ˆSPTï¼‰ èƒ½å½¢æˆæœ€çŸ­è·¯çš„è·¯å¾„æ„æˆäº†ä¸€æ£µæ ‘ï¼Œæ±‚è§£çš„æ–¹æ³•æ˜¯åœ¨æ¾å¼›æ—¶è®°å½•æ¥çš„è¾¹ï¼ˆè·Ÿæœ€çŸ­è·¯çš„æ‰“å°æ˜¯ä¸€æ ·çš„ï¼‰ï¼Œç„¶åæŠŠå®ƒå½“ä½œçˆ¶æŒ‡é’ˆå°±å¯ä»¥æ±‚è§£å‡ºæ•´æ£µæœ€çŸ­è·¯æ ‘ã€‚ æˆ–è€…ä¹Ÿå¯ä»¥åœ¨ dfs æŸ¥æ‰¾æ ‘çš„æ—¶å€™ç›´æ¥æ‰«ææ‰€æœ‰è¾¹ï¼Œè™½ç„¶ä¼šæ…¢ä¸€ç‚¹ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦æ˜¯æ²¡æœ‰å˜çš„ã€‚ [CF1076D] Edge Deletion.ç»™ä¸€ä¸ª nnn ä¸ªç‚¹ï¼Œmmm æ¡è¾¹çš„æ— å‘ç®€å•å¸¦æƒè¿é€šå›¾, è¦æ±‚åˆ è¾¹è‡³æœ€å¤šå‰©ä½™ kkk æ¡è¾¹ã€‚å®šä¹‰&quot;å¥½ç‚¹&quot;æ˜¯æŒ‡åˆ è¾¹åï¼Œ111 å·èŠ‚ç‚¹åˆ°å®ƒçš„æœ€çŸ­è·¯é•¿åº¦ä»ç„¶ç­‰äºåŸå›¾æœ€çŸ­è·¯é•¿åº¦çš„èŠ‚ç‚¹ã€‚æœ€å¤§åŒ–åˆ è¾¹åçš„å¥½ç‚¹ä¸ªæ•°ã€‚ æ˜¾ç„¶è¦å°½å¯èƒ½åœ°ä¿ç•™æœ€çŸ­è·¯æ ‘ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; typedef long long i64; typedef pair&lt;i64, int> pii; int n, m, k; struct edge &#123; int v, d, id; &#125;; vector&lt;edge> G[300005]; bool vis[300005]; i64 d[300005]; void Dijkstra(void) &#123; memset(d, 0x3f, sizeof(d)); d[1] = 0; priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii> > q; q.push(&#123;0, 1&#125;); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!vis[u]) &#123; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].v, w = G[u][i].d; if (d[v] > d[u] + w) &#123; d[v] = d[u] + w; q.push(&#123;d[v], v&#125;); &#125; &#125; &#125; &#125; &#125; int ans[300005], tot = 0; void dfs(int x) &#123; if (tot >= k) return; vis[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int v = G[x][i].v, id = G[x][i].id, w = G[x][i].d; if (!vis[v] &amp;&amp; d[v] == d[x] + w) &#123; ans[++tot] = id; dfs(v); if (tot >= k) return; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].push_back(&#123;v, w, i&#125;); G[v].push_back(&#123;u, w, i&#125;); &#125; printf(\"%d\\n\", k = min(n - 1, k)); Dijkstra(); memset(vis, 0, sizeof(vis)); dfs(1); for (int i = 1; i &lt;= k; ++i) printf(\"%d \", ans[i]); putchar('\\n'); return 0; &#125; æ¬¡çŸ­è·¯ æ¨¡æ¿ã€‚ ç›´æ¥å¥—ç”¨ Dijkstra ç®—æ³•ï¼Œä½†æ˜¯è¦è®°å½•ä¸¤ä¸ª ddd æ•°ç»„ï¼Œåˆ†åˆ«ä¿å­˜æœ€çŸ­è·¯å’Œæ¬¡çŸ­è·¯ã€‚ å…·ä½“ä¸€ç‚¹ï¼Œå¦‚æœå‘ç°äº†ä¸€æ¡æ–°çš„ 1â†’i1\\rightarrow i1â†’i çš„æœ€çŸ­è·¯ï¼Œé‚£ä¹ˆå­˜åœ¨ä»¥ä¸‹å‡ ç§å¯èƒ½ï¼š è¿™æ˜¯æœ€çŸ­è·¯ï¼Œåˆ™æ›´æ–°æœ€çŸ­è·¯ï¼Œå¹¶å°†æ¬¡çŸ­è·¯æ›¿æ¢ä¸ºåŸæ¥çš„æœ€çŸ­è·¯ï¼› ç­‰äºæœ€çŸ­è·¯ï¼Œæ²¡ç”¨ï¼ˆå› ä¸ºæ˜¯ä¸¥æ ¼æ¬¡çŸ­è·¯ï¼‰ï¼› å¤§äºæœ€çŸ­è·¯ä½†æ˜¯å°äºæ¬¡çŸ­è·¯ï¼Œåˆ™æ›¿æ¢æ¬¡çŸ­è·¯ï¼› å¦åˆ™æ²¡ç”¨ã€‚ æ— è®ºå¦‚ä½•ï¼Œæ›´æ–°ä¹‹åéƒ½è¦ pushï¼Œå› ä¸ºæ¥ä¸‹æ¥éƒ½å¯èƒ½éœ€è¦æ›´æ–°ï¼ˆå³ä½¿æ˜¯æ¬¡çŸ­è·¯ï¼‰ã€‚åˆ¤æ–­æ˜¯å¦å·²ç»æ›´æ–°è¿‡çš„æ¡ä»¶å°±æ˜¯å½“å‰çš„è·ç¦»æ˜¯å¦å·²ç»æ¯”æ¬¡çŸ­è·¯è¿˜è¦å¤§ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; struct edge &#123; int from, to, dist; edge(int from = 0, int to = 0, int dist = 0) : from(from), to(to), dist(dist) &#123;&#125; &#125;; int n, m; int d[2][5005]; vector &lt;edge> edges; vector &lt;int> G[5005]; inline void addedge(int u, int v, int d) &#123; edges.push_back(edge(u, v, d)); G[u].push_back(edges.size() - 1); &#125; void Dijkstra2(void) &#123; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; memset(d, 0x3f, sizeof(d)); d[0][1] = 0; q.push(make_pair(0, 1)); while (!q.empty()) &#123; int dis = q.top().first, u = q.top().second; q.pop(); if (dis > d[1][u]) continue; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (d[0][e.to] > dis + e.dist) &#123; d[1][e.to] = d[0][e.to]; d[0][e.to] = dis + e.dist; // åŸæ¥æœ€çŸ­è·¯å˜æˆæ¬¡çŸ­è·¯ q.push(make_pair(d[0][e.to], e.to)); &#125; else if (d[1][e.to] > dis + e.dist &amp;&amp; d[0][e.to] &lt; dis + e.dist) &#123; d[1][e.to] = dis + e.dist; q.push(make_pair(d[1][e.to], e.to)); // æ¬¡çŸ­è·¯å¯èƒ½è¢«ç”¨äºæ¥ä¸‹æ¥çš„æ¬¡çŸ­è·¯æ›´æ–° &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); addedge(u, v, d); addedge(v, u, d); &#125; Dijkstra2(); printf(\"%d\\n\", d[1][n]); return 0; &#125; å½“ç„¶è¿˜æœ‰ k çŸ­è·¯ï¼Œä¸è¿‡éå¸¸çš„éº»çƒ¦ï¼Œä¼šåœ¨ä¸“é—¨çš„åœ°æ–¹è¿›è¡Œè®¨è®ºã€‚ å·®åˆ†çº¦æŸç³»ç»Ÿ è¿˜è®°å¾—è´Ÿç¯å—ï¼Ÿè´Ÿç¯èƒ½åšä»€ä¹ˆå‘¢ï¼Ÿå°±åœ¨è¿™é‡Œï¼Œå·®åˆ†çº¦æŸç³»ç»Ÿã€‚ æ¦‚è¿° æ¨¡æ¿ã€‚ è¿™ç±»é—®é¢˜æ˜¯è¯´ï¼Œç»™å®šä¸€ä¸ªåŒ…å« mmm ä¸ªä¸ç­‰å¼çš„ä¸ç­‰å¼ç»„ï¼Œæœ‰ nnn ä¸ªå˜é‡ x1â€¦xnx_1\\dots x_nx1â€‹â€¦xnâ€‹ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰è§£ï¼Œæœ‰è§£è¾“å‡ºä¸€ç»„è§£ã€‚ä¸ç­‰å¼ç»„å¦‚ä¸‹ï¼š {xc1âˆ’xc1â€²â‰¤y1xc2âˆ’xc2â€²â‰¤y2â‹¯xcmâˆ’xcmâ€²â‰¤ym\\begin{cases} x_{c_1}-x_{c&#x27;_1}\\leq y_1 \\\\x_{c_2}-x_{c&#x27;_2} \\leq y_2 \\\\ \\cdots\\\\ x_{c_m} - x_{c&#x27;_m}\\leq y_m\\end{cases} â©â¨â§â€‹xc1â€‹â€‹âˆ’xc1â€²â€‹â€‹â‰¤y1â€‹xc2â€‹â€‹âˆ’xc2â€²â€‹â€‹â‰¤y2â€‹â‹¯xcmâ€‹â€‹âˆ’xcmâ€²â€‹â€‹â‰¤ymâ€‹â€‹ æˆ‘ä»¬å°†ä¸€ä¸ªä¸ç­‰å¼å†™ä½œ xiâˆ’xjâ‰¤yx_i-x_j\\le yxiâ€‹âˆ’xjâ€‹â‰¤yï¼Œé‚£ä¹ˆå¯ä»¥å˜å½¢ä¸º xiâ‰¤xj+ckx_i \\le x_j+c_kxiâ€‹â‰¤xjâ€‹+ckâ€‹ï¼Œè¿™ä¸å•æºæœ€çŸ­è·¯å¾„ä¸­çš„ä¸ç­‰å¼éå¸¸ç›¸ä¼¼ï¼Œå› æ­¤å¯ä»¥è¿ä¸€æ¡ä» jjj åˆ° iii çš„é•¿åº¦ä¸º ckc_kckâ€‹ çš„æœ‰å‘è¾¹ã€‚æˆ‘ä»¬åˆ©ç”¨ä¹‹å‰æ‰€è®²çš„å¤–æŒ‚ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ 000ï¼Œä½œä¸ºèµ·ç‚¹ï¼Œå°†å®ƒå‘æ‰€æœ‰ç‚¹è¿ä¸€æ¡é•¿åº¦ä¸º 000 çš„æœ‰å‘è¾¹ï¼Œç”¨äºæ–¹ä¾¿ä¸‹é¢æ±‚è§£æ•´ä¸ªå›¾çš„è´Ÿç¯ã€‚é‚£ä¹ˆ 000 åˆ° iii çš„è·ç¦»å¿…å®šå°äº 000 åˆ° jjj å†åˆ° iiiï¼Œæ»¡è¶³ä¸ç­‰å¼ã€‚ æ˜¾ç„¶è¿™ä¸ª ccc ä¸€èˆ¬æ˜¯æœ‰ä¸€ä¸ªè´Ÿæ•°å€¼çš„ï¼Œå¦åˆ™éšä¾¿éƒ½èƒ½æ•´ä¸€ç»„è§£ã€‚ å¦‚æœå›¾ä¸­ä¸å­˜åœ¨è´Ÿç¯ï¼Œé‚£ä¹ˆå¯ä»¥ä»¤ xi=dix_i=d_ixiâ€‹=diâ€‹ å°±æ˜¯ä¸€ç»„è§£ã€‚å¦‚æœæœ‰è´Ÿç¯ï¼Œè®¾è´Ÿç¯å¯¹åº”çš„æ‰€æœ‰ä¸ç­‰å¼æ˜¯ xaiâˆ’xai+1â‰¤ybix_{a_i}-x_{a_{i+1}}\\le y_{b_i}xaiâ€‹â€‹âˆ’xai+1â€‹â€‹â‰¤ybiâ€‹â€‹ï¼Œå°†æ‰€æœ‰ä¸ç­‰å¼ç›¸åŠ å¾—åˆ° 0â‰¤âˆ‘ybi0\\le \\sum y_{b_i}0â‰¤âˆ‘ybiâ€‹â€‹ï¼Œä½†æ˜¯è¿™ä¸ªæ˜¯è´Ÿç¯ï¼Œâˆ‘ybi&lt;0\\sum y_{b_i} &lt; 0âˆ‘ybiâ€‹â€‹&lt;0ï¼ŒçŸ›ç›¾ï¼Œå› æ­¤å·®åˆ†çº¦æŸç³»ç»Ÿæ— è§£ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; int n, m; int d[5005], cnt[5005]; bool inq[5005]; vector &lt;edge> G[5005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(v, d)); &#125; bool SPFA(void) &#123; memset(d, 0x3f, sizeof(d)); d[0] = 0, cnt[0] = 1, inq[0] = true; queue &lt;int> q; q.push(0); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; cnt[e.to] = cnt[u] + 1; if (cnt[e.to] > n + 1) return false; // æ€»å…±æœ‰ n+1 ä¸ªç‚¹ï¼Œè¶…è¿‡å®ƒæœ‰è´Ÿç¯ if (!inq[e.to]) &#123; inq[e.to] = true; q.push(e.to); &#125; &#125; &#125; &#125; return true; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int i, j, c; scanf(\"%d%d%d\", &amp;i, &amp;j, &amp;c); addedge(j, i, c); &#125; for (int i = 1; i &lt;= n; ++i) addedge(0, i, 0); if (SPFA()) &#123; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", d[i]); putchar('\\n'); &#125; else puts(\"NO\"); return 0; &#125; å°æ‚é¡¹ æœ‰çš„çº¦æŸæ¡ä»¶ä¼šå‡ºç°ä¸º xiâˆ’xjâ‰¥yx_i-x_j \\ge yxiâ€‹âˆ’xjâ€‹â‰¥yï¼Œé‚£ä¹ˆåªéœ€è¦ä¸¤è¾¹ä¹˜ âˆ’1-1âˆ’1 å¾—åˆ° xjâˆ’xiâ‰¤âˆ’yx_j-x_i \\le -yxjâ€‹âˆ’xiâ€‹â‰¤âˆ’yã€‚å¦‚æœå‡ºç°äº†ç›¸ç­‰ï¼Œåªéœ€è¦å°†å…¶æ‹†åˆ†æˆ xiâˆ’xjâ‰¥yx_i-x_j \\ge yxiâ€‹âˆ’xjâ€‹â‰¥y å’Œ xiâˆ’xjâ‰¤yx_i-x_j \\le yxiâ€‹âˆ’xjâ€‹â‰¤y å³å¯ã€‚ å¦‚æœè¦æ±‚æ­£æ•°è§£ï¼Œæˆ‘ä»¬åªéœ€è¦ç»™æ‰€æœ‰å€¼åŠ ä¸Šä¸€ä¸ªè¶³å¤Ÿå¤§çš„æ•°å³å¯ï¼Œè¿™æ ·ä¸ç­‰å¼ç»„ä¾ç„¶æˆç«‹ã€‚ è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œåªèƒ½è·‘æœ€çŸ­è·¯å—ï¼Ÿæˆ‘è·‘æœ€é•¿è·¯æ‰¾æ­£ç¯å¯ä¸å¯ä»¥ï¼Ÿå½“ç„¶è¡Œï¼è¿™æ ·çš„çº¦æŸæ¡ä»¶å½¢å¦‚ xiâˆ’xjâ‰¥yx_i-x_j\\ge yxiâ€‹âˆ’xjâ€‹â‰¥yï¼Œé‚£ä¹ˆå˜å½¢ä¸º xiâ‰¥xj+yx_i\\ge x_j+yxiâ€‹â‰¥xjâ€‹+yï¼Œéœ€è¦è¿ä¸€æ¡ jâ†’ij\\rightarrow ijâ†’i çš„é•¿åº¦ä¸º yyy çš„æœ‰å‘è¾¹ï¼Œè·‘æœ€é•¿è·¯å³å¯ã€‚å½“æœ‰æ­£ç¯æ—¶æ— è§£ï¼Œå‰©ä¸‹å†…å®¹ç›¸åŒã€‚ Problemset æˆ‘ä»¬æ¥çœ‹ä¸€äº›ä¹ é¢˜ï¼Œå®ƒä»¬æ­£æ˜¯æœ€çŸ­è·¯ä¸­æœ€æœ‰è¶£çš„å†…å®¹ï¼Œå…¶ä¸­æœ‰äº›é¢˜ç›®ä¼šä¸å›¾è®ºçš„å…¶å®ƒå†…å®¹ç»¼åˆã€‚ ç®€å•æœ€çŸ­è·¯ ä¸éœ€è¦ä»€ä¹ˆè½¬åŒ–ï¼Œå°±æ˜¯èµ¤è£¸çš„æ¨¡æ¿ã€‚ [Cnoi2020] é›·é›¨ Portal. æˆ‘ä»¬å¯ä»¥æšä¸¾è¿™ä¸ªä¸­è½¬ç‚¹ï¼Œåˆ©ç”¨ Dijkstra åˆ†åˆ«æ±‚å‡ºä¸‰ä¸ªç‚¹åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯ï¼Œåœ¨å»ºæ¨¡çš„æ—¶å€™å°†ä¸€ä¸ªæœ‰åºæ•°å¯¹ä½œä¸ºç‚¹çš„ç¼–å·ï¼Œç„¶åè¿™ä¸ªç‚¹çš„ç­”æ¡ˆå°±æ˜¯ d1(i,j)+d2(i,j)+d3(i,j)âˆ’r(i,j)Ã—2d1(i,j)+d2(i,j)+d3(i,j)-r(i,j)\\times 2d1(i,j)+d2(i,j)+d3(i,j)âˆ’r(i,j)Ã—2ã€‚æ¨èè¯»è€…è‡ªè¡Œå®ç°ä»£ç ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;queue> #include &lt;vector> #define i64 long long using namespace std; const int dx[] = &#123;0, 0, 1, -1&#125;, dy[] = &#123;1, -1, 0, 0&#125;; int n, m, a, b, c; int R[1005][1005]; i64 d[3][1001][1001]; bool v[1005][1005]; struct node &#123; int x, y; i64 d; node(int x = 0, int y = 0, i64 d = 0) : x(x), y(y), d(d) &#123;&#125; bool operator &lt; (const node &amp;a) const &#123; return d > a.d; &#125; &#125;; void Dijkstra(int sx, int sy, int k) &#123; memset(v, 0, sizeof(v)); priority_queue &lt;node> q; q.push(node(sx, sy, R[sx][sy])); d[k][sx][sy] = R[sx][sy]; while (!q.empty()) &#123; int x = q.top().x, y = q.top().y; q.pop(); if (!v[x][y]) &#123; v[x][y] = true; for (int i = 0; i &lt; 4; ++i) &#123; int xx = x + dx[i], yy = y + dy[i]; if (xx &lt; 1 || xx > n || yy &lt; 1 || yy > n) continue; if (d[k][xx][yy] > d[k][x][y] + R[xx][yy]) &#123; d[k][xx][yy] = d[k][x][y] + R[xx][yy]; q.push(node(xx, yy, d[k][xx][yy])); &#125; &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;a, &amp;b, &amp;c); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;R[i][j]); memset(d, 0x3f, sizeof(d)); Dijkstra(1, a, 0); Dijkstra(n, b, 1); Dijkstra(n, c, 2); i64 ans = 2e18; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) ans = min(ans, d[0][i][j] + d[1][i][j] + d[2][i][j] - (R[i][j] &lt;&lt; 1)); printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P1144] æœ€çŸ­è·¯è®¡æ•° Portal. è®° cnt[i]cnt[i]cnt[i] ä»£è¡¨èµ°åˆ° iii çš„æœ€çŸ­è·¯æ•°ç›®ï¼Œé‚£ä¹ˆå¦‚æœ iii è¢« uâ†’iu\\rightarrow iuâ†’i æ¾å¼›ï¼Œé‚£ä¹ˆ cnt[u]=cnt[i]+1cnt[u]=cnt[i]+1cnt[u]=cnt[i]+1ï¼Œå¦‚æœæ°å¥½ç›¸ç­‰è€Œä¸èƒ½è¢«æ¾å¼›ï¼Œé‚£ä¹ˆ cnt[i]cnt[i]cnt[i] è¦åŠ ä¸Š cnt[u]cnt[u]cnt[u]ã€‚ æŸ¥çœ‹ä»£ç  // ç¬”è€…ä¸ºäº†ç»ƒä¹ è€Œä½¿ç”¨çš„ SPFAï¼Œæ­£å¸¸ä¸è¦ä½¿ç”¨ #include &lt;bits/stdc++.h> using namespace std; const int MOD = 100003; int n, m; int d[1000005], cnt[1000005]; bool inq[1000005]; vector &lt;int> G[1000005]; void SPFA(void) &#123; memset(d, 0x3f, sizeof(d)); d[1] = 0, cnt[1] = 1, inq[1] = true; queue &lt;int> q; q.push(1); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) if (d[G[u][i]] > d[u] + 1) &#123; d[G[u][i]] = d[u] + 1; cnt[G[u][i]] = cnt[u]; if (!inq[G[u][i]]) &#123; inq[G[u][i]] = true; q.push(G[u][i]); &#125; &#125; else if (d[G[u][i]] == d[u] + 1) cnt[G[u][i]] = (cnt[G[u][i]] + cnt[u]) % MOD; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); G[y].push_back(x); &#125; SPFA(); for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", cnt[i]); return 0; &#125; [Luogu P1875] ä½³ä½³çš„é­”æ³•è¯æ°´ Portal. ç›´æ¥ä½¿ç”¨ä¸åŠ ä¼˜åŒ–çš„ Dijkstra ç®—æ³•ï¼Œç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„è®°å½•è¾¹ï¼Œåœ¨è½¬ç§»çš„æ—¶å€™è¦ä¿è¯å¦ä¸€ä¸ªç‚¹ä¹Ÿå·²ç»è¢«è®¿é—®ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #define i64 long long using namespace std; int n; int d[1005]; i64 cnt[1005]; int G[3005][3005]; bool v[1005]; int main(void) &#123; memset(G, 0xff, sizeof G); scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", d + i), cnt[i] = 1; int a, b, c; while (scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c) == 3) G[a][b] = G[b][a] = c; for (int op = 1; op &lt; n; ++op) &#123; int x = 0; for (int i = 0; i &lt; n; ++i) if (!v[i] &amp;&amp; (x == 0 || d[i] &lt; d[x])) x = i; v[x] = true; for (int y = 0; y &lt; n; ++y) if (v[y] &amp;&amp; G[x][y] != -1) &#123; if (d[G[x][y]] > d[x] + d[y]) d[G[x][y]] = d[x] + d[y], cnt[G[x][y]] = cnt[x] * cnt[y]; else if (d[G[x][y]] == d[x] + d[y]) cnt[G[x][y]] += cnt[x] * cnt[y]; &#125; &#125; printf(\"%d %lld\\n\", d[0], cnt[0]); return 0; &#125; [Luogu P1462] é€šå¾€å¥¥æ ¼ç‘ç›çš„é“è·¯ Portal. æˆ‘ä»¬å¯ä»¥äºŒåˆ†éœ€è¦äº¤çš„æœ€å¤§è¿‡è·¯è´¹ï¼Œåœ¨é™å®šå†…æ‰å…è®¸æ¾å¼›ï¼Œç„¶åè·‘æœ€çŸ­è·¯åˆ¤æ–­è¡€é‡æ˜¯å¦å…è®¸ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;vector> #include &lt;queue> using namespace std; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; vector &lt;edge> edges; vector &lt;int> G[10005]; inline void addedge(int u, int v, int d) &#123; edges.push_back(edge(v, d)); G[u].push_back(edges.size() - 1); &#125; int n, m, b; int f[10005]; int d[10005]; bool v[10005]; bool Dijkstra(int maxx) &#123; if (f[1] > maxx) return false; #define pii pair&lt;int, int> memset(d, 0x3f, sizeof(d)); memset(v, 0, sizeof(v)); d[1] = 0; priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.push(make_pair(0, 1)); while (!q.empty()) &#123; int x = q.top().second; q.pop(); if (!v[x]) &#123; v[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; edge &amp;e = edges[G[x][i]]; if (d[e.to] > d[x] + e.dist &amp;&amp; f[e.to] &lt;= maxx) &#123; d[e.to] = d[x] + e.dist; q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; return d[n] &lt;= b; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;b); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", f + i); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); addedge(u, v, d); addedge(v, u, d); &#125; int L = 0, R = 1000000002; while (L + 1 != R) // äºŒåˆ†éœ€è¦äº¤çš„æœ€å¤šçš„è¿‡è·¯è´¹ &#123; int mid = L + R >> 1; if (Dijkstra(mid)) R = mid; else L = mid; &#125; if (L == 1000000001) puts(\"AFK\"); else printf(\"%d\\n\", R); return 0; &#125; [UVa 11374] Airport Express Portalã€‚ æ³¨æ„åˆ°å•†ä¸šçº¿åªèƒ½åä¸€ç«™ï¼Œæ‰€ä»¥æšä¸¾åå“ªä¸ªå•†ä¸šçº¿å³å¯ã€‚åœ¨èµ·ç‚¹å’Œé‡ç‚¹å„è·‘ä¸€æ¬¡æœ€çŸ­è·¯ï¼ˆå› ä¸ºæ˜¯æ— å‘å›¾ï¼‰ã€‚ä»£ç è¾ƒä¸ºå¤æ‚ï¼Œæ¨èè‡ªè¡Œå®ç°ã€‚æ³¨æ„æœ¬é¢˜æœ‰å‘ï¼Œè¾“å‡ºçš„è¡Œæœ«ä¸èƒ½æœ‰ç©ºæ ¼ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> #include &lt;algorithm> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; struct edge &#123; int u, v, d; edge(int u, int v, int d) : u(u), v(v), d(d) &#123;&#125; &#125;; vector &lt;edge> edges; vector &lt;int> G[505]; inline void addedge(int u, int v, int d) &#123; edges.push_back(edge(u, v, d)); G[u].push_back(edges.size() - 1); &#125; int n, s, e, m, k; int dist[505], p[505]; bool vis[505]; inline void dijkstra(int S) &#123; memset(dist, 0x3f, sizeof(dist)); memset(vis, 0, sizeof(vis)); memset(p, 0, sizeof(p)); dist[S] = 0; priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii> > q; q.push(make_pair(0, S)); while (!q.empty()) &#123; int u = q.top().Y; q.pop(); if (vis[u] == 0) &#123; vis[u] = 1; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (dist[u] + e.d &lt; dist[e.v]) &#123; dist[e.v] = dist[u] + e.d; p[e.v] = G[u][i]; q.push(make_pair(dist[e.v], e.v)); &#125; &#125; &#125; &#125; &#125; int d1[505], d2[505]; vector &lt;int> path1[505], path2[505]; inline void calcShortestPath(int S, int *d, vector&lt;int> *paths) &#123; dijkstra(S); for (int i = 1; i &lt;= n; ++i) &#123; d[i] = dist[i]; paths[i].clear(); int t = i; paths[i].push_back(t); while (S != t) &#123; paths[i].push_back(edges[p[t]].u); t = edges[p[t]].u; &#125; reverse(paths[i].begin(), paths[i].end()); &#125; &#125; int main(void) &#123; int kase = 0; while (scanf(\"%d%d%d\", &amp;n, &amp;s, &amp;e) == 3) &#123; for (int i = 0; i &lt;= n; ++i) G[i].clear(); edges.clear(); m = read(); while (m--) &#123; int u = read(), v = read(), d = read(); addedge(u, v, d); addedge(v, u, d); &#125; calcShortestPath(s, d1, path1); calcShortestPath(e, d2, path2); int ans = d1[e], midpoint = -1; vector &lt;int> path = path1[e]; k = read(); while (k--) &#123; int x = read(), y = read(), val = read(); for (int op = 0; op &lt; 2; ++op) &#123; if (d1[x] + d2[y] + val &lt; ans) &#123; ans = d1[x] + d2[y] + val; midpoint = x; path = path1[x]; for (int j = path2[y].size() - 1; j >= 0; --j) path.push_back(path2[y][j]); &#125; swap(x, y); &#125; &#125; if (kase) putchar('\\n'); ++kase; for (int i = 0; i &lt; path.size() - 1; ++i) printf(\"%d \", path[i]); printf(\"%d\\n\", e); if (midpoint == -1) puts(\"Ticket Not Used\"); else printf(\"%d\\n\", midpoint); printf(\"%d\\n\", ans); &#125; return 0; &#125; [Luogu P2829] å¤§é€ƒç¦» Portal.æ±‚ä» xxx åˆ° yyyï¼Œä¸èƒ½è¿›å…¥å‡ºåº¦å°äº kkk çš„ç‚¹ï¼ˆèµ·ç‚¹ç»ˆç‚¹é™¤å¤–ï¼‰çš„æ¬¡çŸ­è·¯ã€‚ æ ¹æ®æœ€çŸ­è·¯çš„æ€§è´¨ï¼Œæ¬¡çŸ­è·¯è¿˜æœ‰å¦ä¸€ç§æ±‚æ³•ï¼šè·‘å‡ºä»¥ 1,n1,n1,n ä¸ºèµ·ç‚¹çš„æœ€çŸ­è·¯ï¼ˆå½“ç„¶æœ‰å‘å›¾è¿˜éœ€è¦å»ºåå›¾ï¼‰ï¼Œç„¶åæšä¸¾æ¯ä¸€æ¡è¾¹ï¼Œä»¥è¿™ä¸€æ¡è¾¹ä¸ºæ¬¡çŸ­è·¯ä¸­çš„ä¸€æ¡ï¼Œä¸¤ç«¯çš„æœ€çŸ­è·¯æ˜¯å‰©ä¸‹çš„éƒ¨åˆ†ã€‚æŒ‰ä¸Šè¿°æ–¹å¼å®ç°å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #include &lt;queue> using namespace std; const int INF = 1e9; struct edge &#123; int u, v, d; &#125;; int n, m, k; bool vis[5005]; int d1[5005], d2[5005], out[5005]; vector&lt;edge> edges; vector&lt;int> G[5005]; inline void addedge(int u, int v, int w) &#123; edges.push_back(&#123;u, v, w&#125;); G[u].push_back(edges.size() - 1); &#125; void Dijkstra(int s, int *d) &#123; #define pii pair&lt;int, int> priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii> > q; memset(vis, 0, sizeof(vis)); d[s] = 0; q.push(&#123;0, s&#125;); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!vis[u]) &#123; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = edges[G[u][i]].v, w = edges[G[u][i]].d; if (d[v] > d[u] + w &amp;&amp; out[v] >= k) &#123; d[v] = d[u] + w; q.push(&#123;d[v], v&#125;); &#125; &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; out[1] = out[n] = INF; for (int i = 2; i &lt; n; ++i) &#123; memset(vis, 0, sizeof(vis)); for (int j = 0; j &lt; G[i].size(); ++j) &#123; int v = edges[G[i][j]].v; if (!vis[v]) &#123; vis[v] = true; ++out[i]; &#125; &#125; &#125; memset(d1, 0x3f, sizeof(d1)); memset(d2, 0x3f, sizeof(d2)); Dijkstra(1, d1); Dijkstra(n, d2); int ans = INF; for (int i = 0; i &lt; edges.size(); ++i) &#123; int u = edges[i].u, v = edges[i].v, w = edges[i].d; int len = d1[u] + d2[v] + w; if (len > d1[n]) ans = min(ans, len); &#125; if (ans != INF) printf(\"%d\\n\", ans); else puts(\"-1\"); return 0; &#125; å·®åˆ†çº¦æŸç®—æ³• å·®åˆ†çº¦æŸç³»ç»Ÿå¾ˆæœ‰ç”¨ã€‚ [Luogu P1993] å° K çš„å†œåœº Portal. å¯ä»¥çœ‹å‡ºæ˜¯å·®åˆ†çº¦æŸï¼Œåªéœ€è¦åˆ©ç”¨ä¹‹å‰æ‰€è®²çš„éšä¾¿è½¬åŒ–ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #include &lt;queue> using namespace std; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; int n, m; vector &lt;edge> G[5005]; void addedge(int u, int v, int d) &#123; G[u].push_back(edge(v, d)); &#125; int d[5005], cnt[5005]; bool inq[5005]; bool SPFA(void) &#123; memset(d, 0x3f, sizeof(d)); d[0] = 0; inq[0] = true; queue &lt;int> q; q.push(0); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; cnt[e.to] = cnt[u] + 1; if (cnt[e.to] >= n + 1) return true; if (!inq[e.to]) &#123; inq[e.to] = true; q.push(e.to); &#125; &#125; &#125; &#125; return false; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int a, b, c, d; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); if (a == 3) addedge(b, c, 0), addedge(c, b, 0); else &#123; scanf(\"%d\", &amp;d); if (a == 1) addedge(b, c, -d); else addedge(c, b, d); &#125; &#125; for (int i = 0; i &lt;= n; ++i) addedge(0, i, 0); if (SPFA()) puts(\"No\"); else puts(\"Yes\"); return 0; &#125; Floyd æ±‚è§£ | [SCOI2008] å¤©å¹³ Portal.ä½ æœ‰ nnn ä¸ªç ç ï¼Œå‡ä¸º 111 å…‹ï¼Œ222 å…‹æˆ–è€… 333 å…‹ã€‚ä½ å¹¶ä¸æ¸…æ¥šæ¯ä¸ªç ç çš„é‡é‡ï¼Œä½†ä½ çŸ¥é“å…¶ä¸­ä¸€äº›ç ç é‡é‡çš„å¤§å°å…³ç³»ã€‚ä½ æŠŠå…¶ä¸­ä¸¤ä¸ªç ç  AAA å’Œ BBB æ”¾åœ¨å¤©å¹³çš„å·¦è¾¹ï¼Œéœ€è¦å¦å¤–é€‰å‡ºä¸¤ä¸ªç ç æ”¾åœ¨å¤©å¹³çš„å³è¾¹ã€‚é—®ï¼šæœ‰å¤šå°‘ç§é€‰æ³•ä½¿å¾—å¤©å¹³çš„å·¦è¾¹é‡ã€ä¸€æ ·é‡ã€å³è¾¹é‡ï¼ˆåªæœ‰ç»“æœä¿è¯å”¯ä¸€çš„é€‰æ³•æ‰ç»Ÿè®¡åœ¨å†…ï¼‰ï¼Ÿ è€ƒè™‘æ¯ä¸€ä¸ªé™åˆ¶å…³ç³»ï¼Œç›¸å½“äºæ˜¯ç»™å‡ºäº† aâ‰¤xiâˆ’xjâ‰¤ba\\le x_i-x_j\\le baâ‰¤xiâ€‹âˆ’xjâ€‹â‰¤bã€‚æŒ‰ç…§çº¦æŸæ¡ä»¶è®¨è®ºä¹‹åå¯ä»¥å¾—å‡º a,ba,ba,b çš„å€¼ï¼ˆè¯¦è§ä»£ç ï¼‰ã€‚ è¿™ä¸ªä¸œè¥¿ä¸€çœ‹å°±è€å·®åˆ†çº¦æŸäº†ã€‚æˆ‘ä»¬è·‘ä¸€ä¸ªæœ€çŸ­è·¯ï¼ˆç”¨äºé™åˆ¶ â‰¤b\\le bâ‰¤bï¼‰ï¼Œä¸€ä¸ªæœ€é•¿è·¯ï¼ˆç”¨äºé™åˆ¶ â‰¥a\\ge aâ‰¥aï¼‰ï¼Œä½†æ˜¯ç”¨ Folyd è·‘ï¼å¾—å‡ºçš„è·ç¦»å¯ä»¥è½¬åŒ–å›ä¸ç­‰å¼ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„å›ç­”é—®é¢˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, a, b; int maxd[55][55], mind[55][55]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b); char c = getchar(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; while (!ispunct(c)) c = getchar(); if (i == j || c == '=') maxd[i][j] = mind[i][j] = 0; else if (c == '?') maxd[i][j] = 2, mind[i][j] = -2; else if (c == '+') maxd[i][j] = 2, mind[i][j] = 1; else maxd[i][j] = -1, mind[i][j] = -2; c = getchar(); &#125; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; maxd[i][j] = min(maxd[i][j], maxd[i][k] + maxd[k][j]); mind[i][j] = max(mind[i][j], mind[i][k] + mind[k][j]); &#125; int c1 = 0, c2 = 0, c3 = 0; for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123; if (i == a || i == b) continue; if (j == a || j == b) continue; if (mind[a][i] > maxd[j][b] || mind[a][j] > maxd[i][b]) ++c1; if ((maxd[a][i] == mind[a][i] &amp;&amp; mind[a][i] == maxd[j][b] &amp;&amp; maxd[j][b] == mind[j][b]) || (maxd[a][j] == mind[a][j] &amp;&amp; mind[a][j] == maxd[i][b] &amp;&amp; maxd[i][b] == mind[i][b])) ++c2; if (maxd[a][i] &lt; mind[j][b] || maxd[a][j] &lt; mind[i][b]) ++c3; &#125; printf(\"%d %d %d\\n\", c1, c2, c3); return 0; &#125; [1007] å€æ€æµ‹é‡è€… Portal. è§‚å¯Ÿåˆ°ç­”æ¡ˆå…·æœ‰å•è°ƒæ€§ï¼Œå› æ­¤å¯ä»¥äºŒåˆ†ã€‚é™åˆ¶æ¡ä»¶æ˜¯ä¹˜æ³•ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥å–ä¸€ä¸ª logâ¡\\loglog åŒ–ä¹˜ä¸ºåŠ ï¼Œå¯¹äºç»™å®šçš„æ•°å€¼å°±æ˜¯ç›¸ç­‰çš„é™åˆ¶æ¡ä»¶ï¼Œç”¨ä¸¤ä¸ªä¸ç­‰å¼å¤¹æ­»ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥ç”¨å·®åˆ†çº¦æŸæ±‚è§£äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const double eps = 1e-6; const double INF = 1e9; int n, m, t; bool inq[1005]; struct edge &#123; int v, type; double w; edge(int v = 0, double w = 0, int type = 0) : v(v), w(w), type(type) &#123;&#125; &#125;; vector&lt;edge> G[1005]; double d[1005]; int cnt[1005]; bool SPFA(double T) &#123; for (int i = 0; i &lt;= n; ++i) cnt[i] = 0, d[i] = -INF; d[n + 1] = 0; queue&lt;int> q; q.push(n + 1); inq[n + 1] = true; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].v, type = G[u][i].type; double w = G[u][i].w; if (type == 1) w = log2(w - T); else if (type == 2) w = -log2(w + T); if (d[v] &lt; d[u] + w) &#123; d[v] = d[u] + w, inq[v] = true, q.push(v); if ((cnt[v] = cnt[u] + 1) > n + 1) return 1; // è‚¯å®šæœ‰äººå¥³è£… &#125; &#125; &#125; return 0; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;t); for (int i = 0; i &lt;= n; ++i) G[n + 1].emplace_back(i, 0); while (m--) &#123; int o, a, b, k; scanf(\"%d%d%d%d\", &amp;o, &amp;a, &amp;b, &amp;k); G[b].emplace_back(a, k, o); &#125; while (t--) &#123; int c; double x; scanf(\"%d%lf\", &amp;c, &amp;x); G[0].emplace_back(c, log2(x)); G[c].emplace_back(0, -log2(x)); &#125; double L = 0, R = 10, mid; if (!SPFA(0)) return puts(\"-1\"), 0; while (L + eps &lt; R) &#123; if (SPFA(mid = (L + R) / 2)) L = mid; else R = mid; &#125; printf(\"%.6lf\\n\", L); return 0; &#125; [Luogu P5590] èµ›è½¦æ¸¸æˆ Portal.james1 å’Œ Mr. V æ‰“ç®—ä¸€èµ·ç©èµ›è½¦ã€‚ä½†ä»–ä»¬è¢« Solaris éª—å»äº†ç§‹åå±±ã€‚ç§‹åå±±ä¸Šæœ‰ nnn ä¸ªç‚¹å’Œ mmm æ¡è¾¹ï¼Œjames1 å’Œ Mr. V è¦ä»ç‚¹ 111 å‡ºå‘å¼€å¾€ç‚¹ nnnï¼Œæ¯æ¡è¾¹éƒ½æœ‰ä¸€ä¸ªåˆå§‹çš„æ–¹å‘ã€‚Solaris æ‹¿åˆ°äº†ç§‹åå±±çš„åœ°å›¾ä½†å´ä¸çŸ¥é“æ¯æ¡è·¯æœ‰å¤šé•¿ã€‚æ˜¾ç„¶ï¼Œä¸ºäº†èµ›è½¦æ¸¸æˆçš„å…¬å¹³ï¼Œæ¯æ¡ 111 åˆ° nnn çš„è·¯å¾„åº”å½“æ˜¯ç­‰é•¿çš„ã€‚Solaris æƒ³ï¼Œæˆ‘å°±éšä¾¿ç»™è¾¹è¡¨ä¸Šä¸€ä¸ª 1â€¦91\\dots 91â€¦9 çš„é•¿åº¦ï¼Œåæ­£å‚»å‚»çš„ james1 ä¹Ÿçœ‹ä¸å‡ºæ¥ã€‚ç°åœ¨ Solaris è¦æ±‚ä½ æ ‡å‡ºé•¿åº¦ï¼Œå¦åˆ™ Mr. V åœ¨èµ›è½¦æ¯”èµ›ä¸­å¯èƒ½ä¼šå°† james1 æ’æ­»ã€‚nâ‰¤1000 mâ‰¤2000n \\leq 1000\\, m \\leq 2000nâ‰¤1000mâ‰¤2000ã€‚ é™åˆ¶è¾¹æƒè¿™ä»¶äº‹æ¯”è¾ƒç‰›é©¬ï¼Œå› æ­¤è€ƒè™‘ç›´æ¥é™åˆ¶è·ç¦»ã€‚æˆ‘ä»¬åªéœ€è¦æ»¡è¶³ 1â‰¤dvâˆ’duâ‰¤91\\le d_v-d_u\\le 91â‰¤dvâ€‹âˆ’duâ€‹â‰¤9ï¼Œè½¬åŒ–ä¸º dvâ‰¤du+9,duâ‰¤dvâˆ’1d_v\\le d_u+9,d_u\\le d_v-1dvâ€‹â‰¤duâ€‹+9,duâ€‹â‰¤dvâ€‹âˆ’1ï¼Œå·®åˆ†çº¦æŸæ„é€ å³å¯ï¼Œæ³¨æ„ä¸åœ¨è·¯å¾„ä¸Šçš„è¾¹ä¸èƒ½è€ƒè™‘ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; int n, m, u[2005], v[2005], d[1005], cnt[1005]; bool inq[1005], vis[1005], f[1005]; vector&lt;pair&lt;int, int> > G[1005]; vector&lt;int> e[1005]; void dfs(int x) &#123; vis[x] = 1; for (int y : e[x]) &#123; if (!vis[y]) dfs(y); f[x] |= f[y]; &#125; &#125; bool SPFA(void) &#123; memset(d, 0x3f, sizeof d); queue&lt;int> q; q.push(1); d[1] = 0; inq[1] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (auto [v, w] : G[u]) if (d[v] > d[u] + w) &#123; d[v] = d[u] + w, cnt[v] = cnt[u] + 1; if (cnt[v] > n) return 1; if (!inq[v]) q.push(v), inq[v] = 1; &#125; &#125; return 0; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", u + i, v + i); e[u[i]].emplace_back(v[i]); &#125; f[n] = 1; dfs(1); for (int i = 1; i &lt;= m; ++i) &#123; if (!f[u[i]] || !f[v[i]]) continue; G[u[i]].emplace_back(v[i], 9); G[v[i]].emplace_back(u[i], -1); &#125; if (!f[1] || SPFA()) return puts(\"-1\"), 0; printf(\"%d %d\\n\", n, m); for (int i = 1; i &lt;= m; ++i) &#123; int w = d[v[i]] - d[u[i]]; if (!f[u[i]] || !f[v[i]]) w = 1; printf(\"%d %d %d\\n\", u[i], v[i], w); &#125; return 0; &#125; æœ€çŸ­è·¯å»ºæ¨¡ä¸ç»¼åˆåº”ç”¨ è¿™é‡Œçš„é¢˜å¯èƒ½éœ€è¦ä¸€äº›è„‘å­ï¼Œä½†æ˜¯ç¬”è€…æ²¡æœ‰ã€‚ [SDOI2009] Elaxia çš„è·¯çº¿ Portal.ç»™å®šä¸€å¼ æœ‰å‘å›¾ï¼Œåˆ†åˆ«ç»™å®šä¸¤ä¸ªäººçš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œæ±‚å®ƒä»¬èµ°æœ€çŸ­è·¯çš„é‡åˆè·¯å¾„çš„æœ€å¤§é•¿åº¦ã€‚ æˆ‘ä»¬å¯¹å››ä¸ªç‚¹å„è·‘ä¸€æ¬¡æœ€çŸ­è·¯ï¼Œç„¶åä¾æ¬¡åˆ¤æ–­æ¯ä¸€æ¡è¾¹æ˜¯å¦åŒæ—¶æ˜¯ä¸¤ä¸ªæœ€çŸ­è·¯ä¸­çš„ä¸€æ¡è¾¹ï¼Œè¿™äº›è¾¹å°†æ„æˆä¸€ä¸ª DAGã€‚ç„¶åè¿›è¡Œ DAG ä¸Šçš„ DPï¼Œè®¡ç®—æœ€é•¿çš„å…¬å…±æ—¶é—´ã€‚ è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸¤ä¸ªäººèµ°çš„å…¬å…±è·¯å¾„é‡åˆï¼Œæ–¹å‘æ˜¯åçš„ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œè¿™ç§æƒ…å†µéœ€è¦å†ç®—ä¸€éã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, m; int x_, y_, x__, y__; struct edge &#123; int from, to, dist; edge(int from = 0, int to = 0, int dist = 0) : from(from), to(to), dist(dist) &#123;&#125; &#125;; vector &lt;edge> edges; vector &lt;int> G[1505]; int d[4][1505]; bool v[1505]; inline void addedge(int u, int v, int w) &#123; edges.push_back(edge(u, v, w)); G[u].push_back(edges.size() - 1); &#125; void Dijkstra(int s, int id) &#123; memset(d[id], 0x3f, sizeof(d[id])); memset(v, 0, sizeof(v)); d[id][s] = 0; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.push(make_pair(0, s)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!v[u]) &#123; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (d[id][e.to] > d[id][u] + e.dist) &#123; d[id][e.to] = d[id][u] + e.dist; q.push(make_pair(d[id][e.to], e.to)); &#125; &#125; &#125; &#125; &#125; int in[1505], len[1505]; vector &lt;edge> G2[1505]; inline void addedge2(int u, int v, int w) &#123; G2[u].push_back(edge(u, v, w)); ++in[v]; &#125; void Kahn(void) &#123; queue &lt;int> q; for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) q.push(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G2[u].size(); ++i) &#123; edge &amp;e = G2[u][i]; --in[e.to]; len[e.to] = max(len[e.to], len[e.from] + e.dist); if (in[e.to] == 0) q.push(e.to); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;x_, &amp;y_, &amp;x__, &amp;y__); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; Dijkstra(x_, 0), Dijkstra(y_, 1); Dijkstra(x__, 2), Dijkstra(y__, 3); int ans = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; G[i].size(); ++j) &#123; edge &amp;e = edges[G[i][j]]; // x_ -> i + i -> to + y_ -> to == x_ -> y_ // x__ -> i + i -> to + y__ -> to == x__ -> y__ if (d[0][i] + e.dist + d[1][e.to] == d[0][y_] &amp;&amp; d[2][i] + e.dist + d[3][e.to] == d[2][y__]) addedge2(e.from, e.to, e.dist); &#125; Kahn(); for (int i = 1; i &lt;= n; ++i) ans = max(ans, len[i]); for (int i = 1; i &lt;= n; ++i) G2[i].clear(); memset(len, 0, sizeof(len)), memset(in, 0, sizeof(in)); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; G[i].size(); ++j) &#123; edge &amp;e = edges[G[i][j]]; // x_ -> i + i -> to + y_ -> to == x_ -> y_ // y__ -> i + i -> to + x__ -> to == y__ -> x__ if (d[0][i] + e.dist + d[1][e.to] == d[0][y_] &amp;&amp; d[3][i] + e.dist + d[2][e.to] == d[3][x__]) addedge2(e.from, e.to, e.dist); &#125; Kahn(); for (int i = 1; i &lt;= n; ++i) ans = max(ans, len[i]); printf(\"%d\\n\", ans); return 0; &#125; [GXOI/GZOI2019] æ—…è¡Œè€… Portal.ç»™å®šä¸€å¼  n(1â‰¤nâ‰¤105)n(1\\le n \\le 10^5)n(1â‰¤nâ‰¤105) ç‚¹ m(1â‰¤mâ‰¤105)m(1\\le m\\le 10^5)m(1â‰¤mâ‰¤105) è¾¹çš„æœ‰å‘å¸¦æƒå›¾ï¼Œç»™å®šå…¶ä¸­ k(2â‰¤kâ‰¤n)k(2\\le k\\le n)k(2â‰¤kâ‰¤n) ä¸ªç‚¹ï¼Œé—®è¿™ kkk ä¸ªç‚¹ä¸¤ä¸¤ä¹‹é—´çš„æœ€çŸ­è·¯çš„æœ€å°ä¸€ä¸ªçš„é•¿åº¦ã€‚ å¦‚æœæˆ‘ä»¬æŠŠç‰¹æ®Šç‚¹åˆ†æˆ A,BA,BA,B ä¸¤ä¸ªé›†åˆï¼Œæ–°å»ºèµ·ç‚¹ sss è¿æ¥åˆ° AAA ä¸Šçš„æ‰€æœ‰ç‚¹ï¼ŒBBB ä¸­æ‰€æœ‰ç‚¹è¿åˆ° tttï¼Œé‚£ä¹ˆ s,ts,ts,t çš„æœ€çŸ­è·¯å°±æ˜¯ A,BA,BA,B ä¹‹é—´ç‚¹å¯¹çš„æœ€å°æœ€çŸ­è·¯ã€‚ æˆ‘ä»¬æšä¸¾äºŒè¿›åˆ¶ä½ï¼Œå°†ç¬¬ iii ä½ä¸º 111 çš„æ”¾åœ¨ AAAï¼Œå…¶ä½™æ”¾åœ¨ 000ï¼Œè¿™æ ·å°±èƒ½ä¿è¯æ€»æœ‰ä¸€ç§æƒ…å†µä¸¤ä¸ªç‚¹ä¸åœ¨ä¸€ä¸ªé›†åˆé‡Œï¼Œå¯ä»¥è¦†ç›–æ‰€æœ‰çš„æƒ…å†µã€‚ ç„¶è€Œè¿™æ ·å¾ˆæ…¢ï¼Œæˆ‘ä»¬æ¢ä¸€ç§æ€è·¯ã€‚æˆ‘ä»¬æ±‚å‡ºç‚¹ iii åˆ°æŸä¸ªå…³é”®ç‚¹çš„æœ€çŸ­è·ç¦» tit_itiâ€‹ å’Œåˆ°çš„å…³é”®ç‚¹ toito_itoiâ€‹ï¼Œä»¥åŠåˆ°ç‚¹ iii æœ€è¿‘çš„å…³é”®ç‚¹ frifr_ifriâ€‹ å’Œè·ç¦» fif_ifiâ€‹ã€‚æˆ‘ä»¬åªéœ€è¦ç”¨ä¸€æ¡è¾¹æŠŠä¸¤ä¸ªæœ€çŸ­æ‹¼æ¥åœ¨ä¸€èµ·å³å¯ã€‚æ˜¾ç„¶ä¸å­˜åœ¨ä¸€æ¡æ¯”è¿™æ›´çŸ­çš„è·¯å¾„ï¼Œå¦åˆ™æˆ‘ä»¬ä¸€å®šå¯ä»¥å°†åŸæ¥æœ€çŸ­è·¯ä¸­çš„ä¸€æ¡è¾¹æ›¿æ¢ï¼Œå˜æˆæ›´çŸ­çš„è·¯ã€‚è€Œä¸”ä¹Ÿè‚¯å®šä¸ä¼šæ¼è§£ï¼Œå› ä¸ºæœ€ä¼˜è§£ä¸€å®šæ˜¯â€œä»ä¸€ä¸ªå…³é”®ç‚¹å‡ºå‘ï¼Œç»è¿‡ä¸€æ¡è¾¹ï¼Œå†åˆ°å¦ä¸€ä¸ªå…³é”®ç‚¹â€ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; using pii = pair&lt;int, int>; using pli = pair&lt;i64, int>; int n, m, k; int u[500005], v[500005], d[500005]; int a[100005]; struct Dijkstra &#123; i64 d[100005]; int f[100005]; bool vis[100005]; vector&lt;pii> G[100005]; void init(void) &#123; for (int i = 1; i &lt;= n; ++i) G[i].clear(); &#125; void dijkstra(void) &#123; memset(d, 0x1f, sizeof(d)); memset(vis, 0, sizeof(vis)); priority_queue&lt;pli, vector&lt;pli>, greater&lt;pli>> q; for (int i = 1; i &lt;= k; ++i) &#123; d[a[i]] = 0; f[a[i]] = a[i]; q.push(make_pair(0, a[i])); &#125; while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!vis[u]) &#123; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].first, w = G[u][i].second; if (d[v] > d[u] + w) &#123; d[v] = d[u] + w; q.push(make_pair(d[v], v)); f[v] = f[u]; &#125; &#125; &#125; &#125; &#125; &#125; S1, S2; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); S1.init(), S2.init(); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d%d\", u + i, v + i, d + i); S1.G[u[i]].push_back(&#123;v[i], d[i]&#125;); S2.G[v[i]].push_back(&#123;u[i], d[i]&#125;); &#125; for (int i = 1; i &lt;= k; ++i) scanf(\"%d\", a + i); S1.dijkstra(); S2.dijkstra(); // S1 ä¸ºå…³é”®ç‚¹åˆ°ç‚¹ iï¼ŒS2 ä¸ºä»ç‚¹ i åˆ°å…³é”®ç‚¹ i64 ans = 4e18; for (int i = 1; i &lt;= m; ++i) if (S1.f[u[i]] != S2.f[v[i]]) ans = min(ans, S1.d[u[i]] + S2.d[v[i]] + d[i]); printf(\"%lld\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [Code+#4] æœ€çŸ­è·¯ Portal. å¼‚æˆ–è¿™ç§è·ç¦»å¤„ç†æ–¹å¼è®©äººæƒ³åˆ°æœ‰äº›è¾¹æ˜¯ä¸å¿…è¦çš„ã€‚å¯¹äºä¸€ä¸ªäºŒè¿›åˆ¶æ•°ï¼Œæˆ‘ä»¬å°†å…¶ä¸­ä¸€ä½å–åï¼Œå†å°†å¦ä¸€ä½å–åï¼Œè·ŸåŒæ—¶å°†è¿™ä¸¤ä½å–åçš„ä»£ä»·æ˜¯ä¸€æ ·çš„ï¼Œå› æ­¤åªè¦æšä¸¾æ¯ä¸€ä¸ªç‚¹çš„æ¯ä¸€ä¸ªäºŒè¿›åˆ¶ä½å»ºå›¾å³å¯ï¼Œè¾¹çš„æ•°é‡åœ¨ O(nlogâ¡n+m)O(n\\log n+m)O(nlogn+m) çº§åˆ«ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> using namespace std; int n, m, c, S, T; int d[200005]; bool vis[200005]; vector&lt;pair&lt;int, int>> G[200005]; void dijkstra(void) &#123; priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii>> q; memset(d, 0x3f, sizeof d); q.emplace(d[S] = 0, S); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = true; for (auto [v, w] : G[u]) if (d[v] > d[u] + w) q.emplace(d[v] = d[u] + w, v); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].emplace_back(v, d); &#125; scanf(\"%d%d\", &amp;S, &amp;T); for (int i = 0; i &lt;= 16; ++i) for (int u = 1; u &lt;= n + (1 &lt;&lt; i); ++u) &#123; int v = u ^ (1 &lt;&lt; i); G[u].emplace_back(v, (1 &lt;&lt; i) * c); &#125; dijkstra(); return printf(\"%d\\n\", d[T]), 0; &#125; [NOIP2017 æé«˜ç»„] é€›å…¬å›­ Portal. æ±‚å‡ºæœ€çŸ­è·¯ï¼Œç„¶åè®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨åˆ°è¾¾èŠ‚ç‚¹ iiiï¼Œè·ç¦»ä¸º d[i]+j(0â‰¤jâ‰¤k)d[i]+j(0\\le j\\le k)d[i]+j(0â‰¤jâ‰¤k) çš„æ–¹æ¡ˆæ•°ï¼Œåˆå§‹ f(1,0)=1f(1,0)=1f(1,0)=1ï¼Œåœ¨åå›¾ä¸Šè¿›è¡Œ DPï¼Œé€šè¿‡æ ‡è®°ä¸€ä¸ªè®¿é—®æ•°ç»„æ¥åˆ¤æ–­æ˜¯å¦æœ‰é›¶ç¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> using namespace std; int n, m, k, P; vector&lt;pair&lt;int, int>> G1[100005], G2[100005]; bool done[100005]; int d[100005]; void dijkstra(void) &#123; memset(done, 0, sizeof done); memset(d, 0x3f, sizeof d); priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.emplace(d[1] = 0, 1); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (done[u]) continue; done[u] = true; for (auto [v, w] : G1[u]) if (d[v] > d[u] + w) q.emplace(d[v] = d[u] + w, v); &#125; &#125; bool flag, vis[100005][51]; int f[100005][51]; int dp(int u, int k) &#123; if (flag || k &lt; 0) return 0; if (vis[u][k]) return flag = 1, 0; if (f[u][k]) return f[u][k]; int ans = 0; vis[u][k] = 1; for (auto [v, w] : G2[u]) &#123; ans = (ans + dp(v, d[u] + k - w - d[v])) % P; if (flag) return 0; &#125; vis[u][k] = 0; return f[u][k] = ans; &#125; void solve(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;P); for (int i = 1; i &lt;= n; ++i) G1[i].clear(), G2[i].clear(); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G1[u].emplace_back(v, d); G2[v].emplace_back(u, d); &#125; dijkstra(); memset(vis, 0, sizeof vis); memset(f, 0, sizeof f); flag = 0; dp(1, 0); f[1][0] = 1; int ans = 0; for (int i = 0; i &lt;= k; ++i) ans = (ans + dp(n, i)) % P; printf(\"%d\\n\", flag ? -1 : ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [AHOI2014/JSOI2014] éª‘å£«æ¸¸æˆ Portal. å¦‚æœä¸€ä¸ªæ€ªå…½çš„é­”ä¼¤æ˜¯æ‰€æœ‰æ€ªå…½ä¸­æœ€å°çš„ï¼Œé‚£ä¹ˆæ˜¾ç„¶å°±ç”¨é­”æ³•æ‰“æ­»å®ƒäº†ï¼ˆRiâ‰¥1R_i\\ge 1Riâ€‹â‰¥1ï¼‰ã€‚æŒ‰ç…§è¿™ä¸ªé¡ºåºè¿›è¡Œè´ªå¿ƒï¼Œå¦‚æœæ‰“æ­» xxx ç”Ÿæˆä¸€ä¸ªæ€ªå…½ yyyï¼Œé‚£ä¹ˆè¿ä¸€æ¡ yâ†’xy\\rightarrow xyâ†’x çš„è¾¹ï¼Œè¡¨ç¤ºå¦‚æœæƒ³ç”¨ç‰©æ”»æ€æ­» xxx éœ€è¦å…ˆæ‰“æ­» yyyï¼Œè·ç¦»å¯ä»¥å¾ˆæ–¹ä¾¿çš„ç»Ÿè®¡ï¼Œæ˜¯ä¸€ä¸ªç±»ä¼¼äº Dijkstra çš„è´ªå¿ƒè¿‡ç¨‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> #define i64 long long #define pli pair&lt;i64, int> using namespace std; int n; i64 dis[200005], s[200005], deg[200005]; bool vis[200005]; vector&lt;int> G[200005]; priority_queue&lt;pli, vector&lt;pli>, greater&lt;pli> > q; void Dijkstra(void) &#123; while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int v : G[u]) &#123; --deg[v]; s[v] += dis[u]; if (!deg[v] &amp;&amp; s[v] &lt; dis[v]) q.emplace(dis[v] = s[v], v); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x, m; scanf(\"%lld%lld%d\", s + i, dis + i, &amp;m); q.emplace(dis[i], i); deg[i] = m; while (m--) scanf(\"%d\", &amp;x), G[x].emplace_back(i); &#125; Dijkstra(); return !printf(\"%lld\\n\", dis[1]); &#125; [CF375C] Circling Round Treasures Portal. å‘ç°ä¸œè¥¿å¾ˆå°‘ï¼ŒçŠ¶å‹å³å¯ã€‚è®¾ fx,y,Sf_{x,y,S}fx,y,Sâ€‹ è¡¨ç¤ºèµ°åˆ°è¿™ä¸ªçŠ¶æ€çš„æœ€å°æ­¥æ•°ï¼ŒBFS æœ€çŸ­è·¯å³å¯ã€‚ ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œå¦‚ä½•åˆ¤æ–­ä¸€ä¸ªç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…ï¼Ÿ å°„çº¿æ³•ï¼šä»¥ç‚¹ AAA ä¸ºç«¯ç‚¹çš„ä¸€æ¡å°„çº¿ä¸å¤šè¾¹å½¢çš„äº¤ç‚¹ä¸ªæ•°ï¼Œä¸ºå¥‡æ•°åœ¨å¤šè¾¹å½¢å†…ï¼Œä¸ºå¶æ•°ä¸åœ¨ã€‚ ä»¤å°„çº¿æ–¹å‘éƒ½å¾€å·¦ï¼Œè¿™æ ·å°±å¯ä»¥å¾ˆæ–¹ä¾¿çš„ç»Ÿè®¡äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e7; const int DX[] = &#123;0, 0, 1, -1&#125;, DY[] = &#123;1, -1, 0, 0&#125;; int n, m, t; int sx, sy, px[15], py[15], v[15]; char a[25][25]; int f[25][25][1024], sum[1024]; inline bool check(int x, int y, int xx, int yy, int i) &#123; if (xx == px[i] &amp;&amp; yy &lt; py[i] &amp;&amp; x &lt; xx) return 1; if (x == px[i] &amp;&amp; y &lt; py[i] &amp;&amp; x > xx) return 1; return 0; &#125; int bfs(void) &#123; int ans = -INF; struct state &#123; int x, y, s; state(int x = 0, int y = 0, int s = 0) : x(x), y(y), s(s) &#123;&#125; &#125;; memset(f, 0xff, sizeof f); f[sx][sy][0] = 0; queue&lt;state> q; q.emplace(sx, sy, 0); while (!q.empty()) &#123; state u = q.front(); q.pop(); int x = u.x, y = u.y, s = u.s; if (x == sx &amp;&amp; y == sy) ans = max(ans, sum[s] - f[x][y][s]); for (int i = 0; i &lt; 4; ++i) &#123; int xx = x + DX[i], yy = y + DY[i], ss = s; if (xx &lt; 1 || xx > n || yy &lt; 1 || yy > m) continue; if (a[xx][yy] != '.' &amp;&amp; a[xx][yy] != 'S') continue; for (int j = 0; j &lt; t; ++j) if (check(x, y, xx, yy, j)) ss ^= 1 &lt;&lt; j; if (f[xx][yy][ss] == -1) f[xx][yy][ss] = f[x][y][s] + 1, q.emplace(xx, yy, ss); &#125; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", a[i] + 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; char &amp;c = a[i][j]; if (c == 'S') sx = i, sy = j; else if (isdigit(c)) px[c - '0' - 1] = i, py[c - '0' - 1] = j, ++t; &#125; for (int i = 0; i &lt; t; ++i) scanf(\"%d\", v + i); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (a[i][j] == 'B') px[t] = i, py[t] = j, v[t] = -INF, ++t; for (int i = 0; i &lt; 1 &lt;&lt; t; ++i) for (int j = 0; j &lt; t; ++j) if (i >> j &amp; 1) sum[i] += v[j]; return !printf(\"%d\\n\", bfs()); &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"æœ€çŸ­è·¯","slug":"æœ€çŸ­è·¯","permalink":"https://james1badcreeper.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"å·®åˆ†çº¦æŸ","slug":"å·®åˆ†çº¦æŸ","permalink":"https://james1badcreeper.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"}]},{"title":"åŒºé—´ DP ä¸é«˜ç»´ DP","slug":"notes/DP/range-dp","date":"2022-07-28T00:00:00.000Z","updated":"2022-07-28T00:00:00.000Z","comments":true,"path":"1177a5e3/","link":"","permalink":"https://james1badcreeper.github.io/1177a5e3/","excerpt":"åŒºé—´ DP æ˜¯çº¿æ€§ DP çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ï¼Œå®ƒåœ¨åˆ†é˜¶æ®µåœ°åˆ’åˆ†é—®é¢˜æ—¶ï¼Œä¸é˜¶æ®µä¸­å…ƒç´ å‡ºç°çš„é¡ºåºå’Œç”±å‰ä¸€é˜¶æ®µçš„å“ªäº›å…ƒç´ åˆå¹¶è€Œæ¥æœ‰å¾ˆå¤§çš„å…³ç³»ã€‚é«˜ç»´ DP åˆ™æ˜¯çº¿æ€§ DP çš„æ‰©å±•ï¼Œå¤§éƒ¨åˆ†æ˜¯ä»ä¸€æ¡é“¾æ‰©å±•ä¸ºäº†äºŒç»´ç»“æ„ã€‚","text":"åŒºé—´ DP æ˜¯çº¿æ€§ DP çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ï¼Œå®ƒåœ¨åˆ†é˜¶æ®µåœ°åˆ’åˆ†é—®é¢˜æ—¶ï¼Œä¸é˜¶æ®µä¸­å…ƒç´ å‡ºç°çš„é¡ºåºå’Œç”±å‰ä¸€é˜¶æ®µçš„å“ªäº›å…ƒç´ åˆå¹¶è€Œæ¥æœ‰å¾ˆå¤§çš„å…³ç³»ã€‚é«˜ç»´ DP åˆ™æ˜¯çº¿æ€§ DP çš„æ‰©å±•ï¼Œå¤§éƒ¨åˆ†æ˜¯ä»ä¸€æ¡é“¾æ‰©å±•ä¸ºäº†äºŒç»´ç»“æ„ã€‚ è¿™ä¸¤ä¸ªå†…å®¹éƒ½å±äºéƒ½å±äºçº¿æ€§ DP çš„å˜å½¢ã€‚ åŒºé—´ DP åŒºé—´ç±»åŠ¨æ€è§„åˆ’æ˜¯çº¿æ€§åŠ¨æ€è§„åˆ’çš„æ‰©å±•ã€‚ å®ƒåœ¨åˆ†é˜¶æ®µåœ°åˆ’åˆ†é—®é¢˜æ—¶ï¼Œä¸é˜¶æ®µä¸­å…ƒç´ å‡ºç°çš„é¡ºåºå’Œç”±å‰ä¸€é˜¶æ®µçš„å“ªäº›å…ƒç´ åˆå¹¶è€Œæ¥ç”±å¾ˆå¤§çš„å…³ç³»ã€‚å…¶è½¬ç§»æ–¹ç¨‹ä¸€èˆ¬å½¢å¦‚ fi,j=maxâ¡{fi,k+fk+1,j+costâˆ£iâ‰¤k&lt;j}f_{i,j}=\\max\\{f_{i,k}+f_{k+1,j}+cost\\mid i \\le k &lt; j\\}fi,jâ€‹=max{fi,kâ€‹+fk+1,jâ€‹+costâˆ£iâ‰¤k&lt;j}ï¼Œcostcostcost ä¸ºå°†è¿™ä¸¤ç»„å…ƒç´ åˆå¹¶èµ·æ¥çš„ä»£ä»·ã€‚ ä¹Ÿæœ‰å¦ä¸€ç±»åŒºé—´ DP çš„è½¬ç§»æ–¹ç¨‹å½¢å¦‚ fi,j=maxâ¡{fi+1,j+costi,fi,jâˆ’1+costj}f_{i,j}=\\max\\{f_{i+1,j}+cost_i,f_{i,j-1}+cost_j\\}fi,jâ€‹=max{fi+1,jâ€‹+costiâ€‹,fi,jâˆ’1â€‹+costjâ€‹}ï¼Œè¿™ä¸€ç±»çš„åŒºé—´æ˜¯é€šè¿‡å·¦å³ç«¯ç‚¹é€ä¸ªæ‰©å±•çš„ã€‚ ç”±äºå¤§åŒºé—´çš„ç­”æ¡ˆä¾èµ–äºå°åŒºé—´çš„ç­”æ¡ˆï¼Œæ‰€ä»¥è¦å°†åŒºé—´çš„é•¿åº¦ä½œä¸ºâ€œé˜¶æ®µâ€æ¥è¿›è¡Œ DPã€‚ ä½†æ˜¯è¿™ä¹ˆè¯´å¾ˆé—¹é¬¼ï¼Œæˆ‘ä»¬é€šè¿‡é¢˜ç›®æ¥è®¤è¯†åŒºé—´ DPã€‚ æ¨¡æ¿ æˆ‘ä»¬åˆ†åˆ«æ¥çœ‹ä¸€çœ‹åˆšæ‰æ‰€è¯´çš„ä¸¤ç§è½¬ç§»çš„å…·ä½“å®ä¾‹ã€‚ [NOI1995] çŸ³å­åˆå¹¶ Portal. ä»¥æœ€å¤§å¾—åˆ†ä¸ºä¾‹ã€‚ å…ˆå‡è®¾æ’æˆä¸€æ’ï¼Œè®¾ f[l][r]f[l][r]f[l][r] è¡¨ç¤ºåˆå¹¶åŒºé—´ [l,r][l,r][l,r] çš„æœ€å¤§å¾—åˆ†ï¼Œåˆ™æœ‰ f[l][r]=maxâ¡lâ©½k&lt;r{f[l,k]+f[k+1][r]}+âˆ‘i=lraif[l][r]=\\max\\limits_{l \\leqslant k &lt; r}\\{f[l,k]+f[k+1][r]\\}+\\sum\\limits_{i=l}^r a_if[l][r]=lâ©½k&lt;rmaxâ€‹{f[l,k]+f[k+1][r]}+i=lâˆ‘râ€‹aiâ€‹ã€‚ ç¼–ç¨‹æ—¶æœ‰ä¸¤ç§æ€è·¯ï¼Œä¸€æ˜¯è®°å¿†åŒ–æœç´¢ï¼ŒäºŒæ˜¯é€’æ¨ï¼Œä½†æ³¨æ„é€’æ¨æ—¶è¦ä»¥åŒºé—´é•¿åº¦é€’å¢çš„é¡ºåºæ¥æ¨ï¼Œå› ä¸ºå¤§åŒºé—´çš„ç­”æ¡ˆä¾èµ–äºå°åŒºé—´çš„ç­”æ¡ˆã€‚ æ¥ä¸‹æ¥è€ƒè™‘å¦‚ä½•å¤„ç†ç¯ã€‚æˆ‘ä»¬å°†è¿™æ¡é“¾å»¶é•¿ä¸¤å€ï¼Œå˜æˆ nÃ—2n \\times 2nÃ—2 å †ï¼Œè¿™æ ·å°±å¯ä»¥è½¬åŒ–æˆ nnn æ¡é“¾ï¼Œåˆ†åˆ«ä¸º [1,n],[2,n+1][3,n+2],â‹¯ ,[n,2nâˆ’1][1,n],[2,n+1][3,n+2],\\cdots,[n,2n-1][1,n],[2,n+1][3,n+2],â‹¯,[n,2nâˆ’1]ã€‚è¿™ç§å¤åˆ¶äºŒå€é“¾æ˜¯å¤„ç†ç¯å½¢ DP æä¸ºæœ‰æ•ˆçš„æ–¹å¼ï¼ˆå› ä¸ºç¯å½¢é—®é¢˜ä¸­è‚¯å®šæœ‰ä¸€æ¡è¾¹æ˜¯ç”¨ä¸åˆ°çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†å®ƒä»ä»»æ„ä½ç½®æ–­å¼€ï¼Œç„¶åå°±ç›¸å½“äºä»æ¯ä¸ªä½ç½®æ–­å¼€çš„æƒ…å†µéƒ½æ±‚äº†ï¼‰ã€‚ ä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int a[205], sum[205]; int f[205][205]; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = a[n + i] = read(); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) sum[i] = sum[i-1] + a[i]; int ans = 1000000000; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) f[i][i] = 0; for (int len = 2; len &lt;= n; ++len) // æˆ‘ä»¬åªéœ€è¦å¤„ç†åˆ° len = n å³å¯ for (int i = 1; i &lt;= (n &lt;&lt; 1) - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + sum[j] - sum[i-1]); &#125; for (int i = 1; i &lt;= n; ++i) ans = min(ans, f[i][i + n - 1]); printf(\"%d\\n\", ans); ans = 0; memset(f, 0, sizeof(f)); for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= (n &lt;&lt; 1) - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = max(f[i][j], f[i][k] + f[k+1][j] + sum[j] - sum[i-1]); &#125; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i][i + n - 1]); printf(\"%d\\n\", ans); return 0; &#125; çŠ¶æ€æœ‰ O(n2)O(n^2)O(n2) ä¸ªï¼Œæ¯ä¸ªçŠ¶æ€çš„å†³ç­–æœ‰ O(n)O(n)O(n) ä¸ªï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(n3)O(n^3)O(n3)ã€‚ [IOI2000] å›æ–‡å­—ä¸² Portal. è®¾ f[l][r]f[l][r]f[l][r] è¡¨ç¤ºå¤„ç†åŒºé—´ [l,r][l,r][l,r] çš„æœ€å°ä»£ä»·ï¼Œé‚£ä¹ˆæ˜¾ç„¶å¯ä»¥èŠ±è´¹ 111 æ¥å¤„ç†å·¦ç«¯ç‚¹æˆ–å³ç«¯ç‚¹ï¼Œå¦‚æœå·¦å³ç«¯ç‚¹ç›¸ç­‰çš„è¯è¿˜å¯ä»¥ç­‰ä»·äºå¤„ç† [l+1,râˆ’1][l+1,r-1][l+1,râˆ’1]ã€‚æ˜¾ç„¶ï¼Œè¿™æ˜¯ç¬¬äºŒç§è½¬ç§»ã€‚ #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; char s[1005]; int f[1005][1005]; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) f[i][i] = 0, f[i][i - 1] = 0; for (int len = 2; len &lt;= n; ++len) &#123; for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = min(f[i][j - 1], f[i + 1][j]) + 1; if (s[i] == s[j]) f[i][j] = min(f[i][j], f[i + 1][j - 1]); &#125; &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; çŠ¶æ€æœ‰ O(n2)O(n^2)O(n2) ä¸ªï¼Œæ¯ä¸ªçŠ¶æ€çš„å†³ç­–åªæœ‰æœ‰ O(1)O(1)O(1) ä¸ªï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(n2)O(n^2)O(n2)ã€‚ ç®€å•åº”ç”¨ è¿™é‡Œæ˜¯ä¸€äº›ç®€å•çš„åŒºé—´ DP é¢˜ç›®ã€‚ [CQOI2007] æ¶‚è‰² Portal. è®¾ f(i,j)f(i,j)f(i,j) ä¸ºå®Œæˆ [i,j][i,j][i,j] æ¶‚è‰²éœ€è¦çš„æœ€å°‘æ­¥æ•°ã€‚é¦–å…ˆæœ‰ f(i,i)=1f(i,i)=1f(i,i)=1ã€‚ å½“ s[i]=s[j]s[i] = s[j]s[i]=s[j] æ—¶ï¼Œf(i,j)=minâ¡{f(i,jâˆ’1),f(i+1,j)}f(i,j)=\\min\\{f(i,j-1),f(i+1,j)\\}f(i,j)=min{f(i,jâˆ’1),f(i+1,j)}ï¼ˆåªéœ€è¦åœ¨æ¶‚å…¶ä¸­æŸä¸€ä¸ªæ—¶ï¼Œå…ˆæ¶‚è¿™ç§é¢œè‰²ï¼Œå°†æ¶‚è‰²çš„åŒºé—´æ”¹ä¸º [i,j][i,j][i,j]ï¼Œå†è€ƒè™‘ [i+1,jâˆ’1][i+1,j-1][i+1,jâˆ’1] å³å¯ï¼‰ã€‚ åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œ[i,j][i,j][i,j] éƒ½èƒ½ç”± [i,k][i,k][i,k] å’Œ [k+1,j][k+1,j][k+1,j] æ‹¼å‡ºæ¥ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; char s[55]; int f[55][55]; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) f[i][i] = 1; for (int len = 1; len &lt; n; ++len) for (int i = 1; i &lt;= n - len; ++i) &#123; int j = i + len; if (s[i] == s[j]) f[i][j] = min(f[i][j - 1], f[i + 1][j]); for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; [NOIP2007 æé«˜ç»„] çŸ©é˜µå–æ•°æ¸¸æˆ Portal. æ¯ä¸€è¡Œçš„æ“ä½œéƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œå› æ­¤å¯ä»¥ä¸€è¡Œä¸€è¡Œçš„æ€è€ƒã€‚è®¾ f[i][j]f[i][j]f[i][j] ä¸ºä¸€è¡Œä¸­å–åˆ°åªå‰©ä¸‹ [i,j][i,j][i,j] çš„æœ€å¤§å€¼ï¼Œè½¬ç§»åªæœ‰ä¸¤ç§æ–¹å¼ï¼šå·¦å–å’Œå³å–ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(nm2)\\mathcal{O}(n{m}^2)O(nm2)ã€‚æ³¨æ„éœ€è¦é«˜ç²¾ï¼ˆå½“ç„¶å¯ä»¥ç”¨ __int128ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> #define LL __int128 using namespace std; inline LL read(void) &#123; LL x = 0; int c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar(); return x; &#125; inline void print(LL x) &#123; if (x > 9) print(x / 10); putchar(x % 10 + '0'); &#125; int n, m; LL a[85]; LL f[85][85]; int main(void) &#123; n = read(), m = read(); LL ans = 0; while (n--) &#123; for (int i = 1; i &lt;= m; ++i) a[i] = read(); memset(f, 0, sizeof(f)); f[1][m] = 0; LL k = 1; for (int len = m - 1; len >= 0; --len) &#123; k &lt;&lt;= 1; for (int i = 1; i &lt;= m - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = max(f[i - 1][j] + a[i - 1] * k, f[i][j + 1] + a[j + 1] * k); &#125; &#125; LL res = -1; for (int i = 1; i &lt;= m; ++i) res = max(res, f[i][i] + a[i] * k); ans += res; &#125; print(ans); putchar('\\n'); return 0; &#125; [CF245H] Queries for Number of Palindromes Portal. å°½ç®¡ç”¨ä¸“é—¨çš„å­—ç¬¦ä¸²ç®—æ³•å¯ä»¥å¾ˆé«˜æ•ˆåœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯è¿˜å¯ä»¥ç”¨åŒºé—´ DP æ¥è§£å†³ã€‚æ ¹æ®ç»éªŒï¼Œæˆ‘ä»¬è®¾ f(l,r)f(l,r)f(l,r) è¡¨ç¤ºè¿™ä¸ªèŒƒå›´å†…çš„å›æ–‡å­ä¸²ä¸ªæ•°ã€‚é‚£ä¹ˆæ ¹æ®å®¹æ–¥åŸç†æ˜¾ç„¶æœ‰ï¼š f(l,r)=f(l,râˆ’1)+f(l+1,r)âˆ’f(l+1,râˆ’1)+is_pal(slâ‹¯r)f(l,r) = f(l,r-1) + f(l+1,r) - f(l+1,r-1) + \\text{is\\_pal}(s_{l\\cdots r}) f(l,r)=f(l,râˆ’1)+f(l+1,r)âˆ’f(l+1,râˆ’1)+is_pal(slâ‹¯râ€‹) ç°åœ¨çš„é—®é¢˜å°±æ˜¯å¦‚ä½•å¤„ç† is_palã€‚è™½ç„¶å­—ç¬¦ä¸² Hash å¯ä»¥åœ¨çº¿æ€§å¤æ‚åº¦å†…è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ²¡å¿…è¦ï¼Œå› ä¸ºæˆ‘ä»¬çš„ DP æ˜¯å¹³æ–¹å¤æ‚åº¦ã€‚å®é™…ä¸Šè¿™ä¸ªé—®é¢˜ä¹Ÿå¯ä»¥ä»¥å¹³æ–¹å¤æ‚åº¦ç”¨åŒºé—´ DP æ¥æ±‚è§£ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; char s[5005]; int n, f[5005][5005]; bool is_pal[5005][5005]; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (s[i] == s[j] &amp;&amp; (i + 1 >= j || is_pal[i + 1][j - 1])) is_pal[i][j] = true; &#125; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = f[i + 1][j] + f[i][j - 1] - f[i + 1][j - 1] + is_pal[i][j]; &#125; int q, l, r; scanf(\"%d\", &amp;q); while (q--) &#123; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d\\n\", f[l][r]); &#125; return 0; &#125; [IOI1998] Polygon Portal. ç‰¹åˆ«åœ°ï¼Œè¯·å°†æ•°æ®èŒƒå›´çœ‹ä½œ nâ©½150n\\leqslant 150nâ©½150ã€‚ æˆ‘ä»¬å¯ä»¥æšä¸¾åˆ å“ªä¸€æ¡è¾¹ï¼Œæœ¬é¢˜å°±è½¬åŒ–ä¸ºé“¾ä¸Šé—®é¢˜ã€‚è®¾ f[l,r]f[l,r]f[l,r] è¡¨ç¤ºåŒºé—´ [l,r][l,r][l,r] çš„æœ€å¤§å€¼è¡Œå—ï¼Ÿä¸è¡Œï¼ç”±äºè´Ÿè´Ÿå¾—æ­£çš„å­˜åœ¨ï¼Œè¿™æ ·çš„çŠ¶æ€è®¾è®¡ä¸æ»¡è¶³æœ€ä¼˜å­ç»“æ„æ€§è´¨ï¼Œé‚£æ€ä¹ˆåŠï¼Ÿåœ¨è®°å½•ä¸€ä¸ªè®°å½•æœ€å°å€¼çš„å°±è¡Œäº†ï¼ è®¾ f[l,r,0],f[l,r,1]f[l,r,0],f[l,r,1]f[l,r,0],f[l,r,1] åˆ†åˆ«ä»£è¡¨åŒºé—´çš„æœ€å¤§æœ€å°å€¼ã€‚å½“è¿ç®—ä¸ºæ±‚å’Œæ˜¯ï¼Œæ­£å¸¸æ›´æ–°å³å¯ã€‚ä¹˜æ³•éœ€è¦æ³¨æ„ï¼Œæœ€å¤§å€¼çš„æ¥æºåªå¯èƒ½æ˜¯æœ€å¤§ä¹˜æœ€å¤§æˆ–æœ€å°ä¹˜æœ€å°ï¼Œè€Œæœ€å°å€¼çš„æ¥æºåˆ™æ˜¯æ‰€æœ‰çš„éƒ½å¯èƒ½ã€‚å®é™…ä¸Šï¼Œè¿™æ—¶å€™å¦‚æœæä¸æ¸…æ¥šï¼Œè¿˜ä¸å¦‚éƒ½å†™ä¸Šï¼Œåæ­£ä¸ä¼šå¾—å‡ºé”™è¯¯çš„è§£å°±è¡Œï¼ˆæ²¡äººä¼šå¡è¿™é‡Œçš„å¸¸æ•°å§ï¼‰ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; const int INF = 1000000000; int n; char c[105]; int a[105]; int f[105][105][2]; int main(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> c[i] >> a[i]; for (int i = n + 1; i &lt;= (n &lt;&lt; 1); ++i) c[i] = c[i - n], a[i] = a[i - n]; for (int l = 1; l &lt;= (n &lt;&lt; 1); ++l) for (int r = 1; r &lt;= (n &lt;&lt; 1); ++r) if (l != r) f[l][r][0] = -INF, f[l][r][1] = INF; else f[l][r][0] = f[l][r][1] = a[l]; for (int len = 2; len &lt;= (n &lt;&lt; 1); ++len) for (int l = 1; l &lt;= (n &lt;&lt; 1) - len + 1; ++l) &#123; int r = l + len - 1; for (int k = l; k &lt; r; ++k) &#123; if (c[k + 1] == 't') &#123; f[l][r][0] = max(f[l][r][0], f[l][k][0] + f[k + 1][r][0]); f[l][r][1] = min(f[l][r][1], f[l][k][1] + f[k + 1][r][1]); &#125; else &#123; f[l][r][0] = max(&#123;f[l][r][0], f[l][k][0] * f[k + 1][r][0], f[l][k][1] * f[k + 1][r][1]&#125;); f[l][r][1] = min(&#123;f[l][r][1], f[l][k][0] * f[k + 1][r][1], f[l][k][1] * f[k + 1][r][0], f[l][k][0] * f[k + 1][r][0], f[l][k][1] * f[k + 1][r][1]&#125;); &#125; &#125; &#125; int ans = -INF; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i][i + n - 1][0]); printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (f[i][i + n - 1][0] == ans) printf(\"%d \", i); putchar('\\n'); return 0; &#125; [SCOI2003] å­—ç¬¦ä¸²æŠ˜å  Portal. é¦–å…ˆè¿™è‚¯å®šæ˜¯ç¬¬ä¸€ç§åŒºé—´ DPï¼Œå› ä¸ºæŠ˜å å¯ä»¥ä»ä¸­é—´æŠ ï¼Œè‚¯å®šä¸æ˜¯ä»ä¸¤å¤´æ‰©å±•ã€‚ è®¾ f(i,j)f(i,j)f(i,j) ä¸º [i,j][i,j][i,j] çš„æœ€çŸ­æŠ˜å ï¼ŒæŒ‰ç…§å®ƒçš„é¢˜æ„ï¼Œåº”è¯¥æœ‰ä»¥ä¸‹ä¸‰ç§æŠ˜å æ–¹å¼ï¼š è‡ªå·±ä½œä¸ºä¸€ä¸ªæŠ˜å ï¼Œæ˜¾ç„¶è¿™æ—¶ f(i,j)=jâˆ’i+1f(i,j)=j-i+1f(i,j)=jâˆ’i+1ï¼› æŠŠè‹¥å¹²ä¸ªé‡å¤çš„ä¸œè¥¿æ‹¼æˆä¸€ä¸ªï¼Œè¿™æ€ä¹ˆæï¼Ÿä¸è¦ç´§ï¼Œæ•°æ®èŒƒå›´é‚£ä¹ˆå°ï¼Œæˆ‘ä»¬æš´åŠ›ç‚¹æƒ³ï¼Œè¿™äº›é‡å¤çš„ä¸œè¥¿é•¿åº¦è‚¯å®šæ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æšä¸¾é•¿åº¦ kkkï¼Œè€Œä¸”æ˜¾ç„¶è¦æ±‚ kâˆ£jâˆ’i+1k\\mid j-i+1kâˆ£jâˆ’i+1ï¼Œè¿™ä¸€è¿‡ç¨‹æˆ‘ä»¬ for ä¸€éæ£€æŸ¥æ˜¯ä¸æ˜¯çº¦æ•°å°±å¯ä»¥äº†ï¼Œå› ä¸ºæ£€æŸ¥èƒ½ä¸èƒ½æŠ˜å çš„æ“ä½œæ›´è´¹æ—¶é—´ï¼ŒåŠ ä¸Šæ‹¬å·å’Œæ•°å­—çš„ä»£ä»·ï¼Œæœ‰ f(i,j)=f(i,i+kâˆ’1)+2+D(jâˆ’i+1k)f(i,j)=f(i,i+k-1)+2+D\\left(\\cfrac{j-i+1}{k}\\right)f(i,j)=f(i,i+kâˆ’1)+2+D(kjâˆ’i+1â€‹)ï¼Œå…¶ä¸­ DDD è¡¨ç¤ºæ±‚ä¸€ä¸ªæ•°å­—çš„ä½æ•°ï¼Œåœ¨è¿™ä¹‹å‰æˆ‘ä»¬è¦çº¿æ€§æ‰«ä¸€éçœ‹èƒ½ä¸èƒ½æŠ˜å ï¼Œè¿›è¡Œä¸€è½®è¿™æ ·çš„è½¬ç§»çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n1.5)\\mathcal{O}(n^{1.5})O(n1.5)ï¼› æšä¸¾ä¸­é—´ç‚¹è¿›è¡Œè½¬ç§»ï¼Œå°±æ˜¯æŠŠä¸¤å¨ä¸œè¥¿æ‹¼åœ¨ä¸€èµ·ï¼Œè¿™æ—¶å€™ f(i,j)=minâ¡{f(i,k)+f(k+1,j)âˆ£kâˆˆ[i,j)}f(i,j)=\\min \\left\\{f(i,k) + f(k+1,j)\\mid k\\in [i,j)\\right\\}f(i,j)=min{f(i,k)+f(k+1,j)âˆ£kâˆˆ[i,j)}ã€‚ çŠ¶æ€æœ‰ O(n2)\\mathcal{O}(n^2)O(n2) ä¸ªï¼Œæ€»æ—¶é—´å¤æ‚åº¦ä¸º O(n3.5)\\mathcal{O}(n^{3.5})O(n3.5)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, D[105]; char s[105]; int f[105][105]; inline bool check(int l, int r, int len) &#123; for (int i = l; i &lt;= r; ++i) if (s[i] != s[(i - l) % len + l]) return false; return true; &#125; int main(void) &#123; for (int i = 0; i &lt; 10; ++i) D[i] = 1; for (int i = 10; i &lt; 100; ++i) D[i] = 2; for (int i = 100; i &lt; 103; ++i) D[i] = 3; scanf(\"%s\", s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) f[i][j] = j - i + 1; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); for (int k = 1; k &lt;= len; ++k) &#123; if (len % k != 0) continue; if (check(i, j, k)) f[i][j] = min(f[i][j], f[i][i + k - 1] + 2 + D[len / k]); &#125; &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; é«˜ç»´ DP å…¶å®åœ¨ä¹‹å‰å°±å·²ç»è§è¯†è¿‡é«˜ç»´ DP äº†ã€‚åƒ [NOIP2002 æ™®åŠç»„] è¿‡æ²³å’ã€‚è¦çŸ¥é“çš„æ˜¯å®ƒä»¬ä¹Ÿå¯ä»¥ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–ã€‚æˆ‘ä»¬ç›´æ¥ä¸Šé¢˜ï¼š ç®€å•å†…å®¹ ä¸€é“ç®€å•é¢˜ã€‚ [NOIP2009 æ™®åŠç»„] é“è·¯æ¸¸æˆ Portal. è®¾ f(i)f(i)f(i) ä»£è¡¨ç¬¬ iii ä¸ªæ—¶åˆ»è·å¾—çš„æœ€å¤§æ”¶ç›Šï¼Œè½¬ç§»çš„æ—¶å€™æšä¸¾æœºå™¨äººèµ°çš„è·ç¦»å’Œä»å“ªä¸ªä½ç½®å¼€å§‹èµ°çš„å³å¯ï¼ˆè¿™æ ·ä»·å€¼å°±å¯ä»¥è®¡ç®—å‡ºæ¥äº†ï¼Œç”¨å‰ç¼€å’Œé¢„å¤„ç†åŠ é€ŸæŸ¥è¯¢ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, p; int a[1005][1005], s[1005][1005]; int f[1005], cost[1005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;p); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[j][i % n]); for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt; n; ++j) s[i][j] = s[i - 1][(j - 1 + n) % n] + a[i][j]; for (int i = 0; i &lt; n; ++i) scanf(\"%d\", cost + i); memset(f, 0xbf, sizeof(f)); f[0] = 0; for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt; n; ++j) for (int k = 1; k &lt;= min(i, p); ++k) f[i] = max(f[i], f[i - k] + s[i][j] - s[i - k][((j - k) % n + n) % n] - cost[((j - k) % n + n) % n]); printf(\"%d\\n\", f[m]); return 0; &#125; æ™®é€šå†…å®¹ ä¸¤é“æ­£å¸¸ä¸€ç‚¹çš„é¢˜ã€‚ [NOIP2014 æé«˜ç»„] é£æ‰¬çš„å°é¸Ÿ Portal. è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨é£åˆ° iiiï¼Œé«˜åº¦ä¸º jjj çš„æœ€å°ç‚¹å‡»æ•°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int INF = 0x3f3f3f3f; int n, m, k; int x[10005], y[10005], low[10005], high[10005]; bool e[10005]; int f[10005][2005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", x + i, y + i); low[i] = 1, high[i] = m; &#125; for (int i = 1, a, b, c; i &lt;= k; ++i) &#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); e[a] = true; low[a] = b + 1; high[a] = c - 1; &#125; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= m; ++i) f[0][i] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = x[i] + 1; j &lt;= x[i] + m; ++j) f[i][j] = min(f[i - 1][j - x[i]] + 1, f[i][j - x[i]] + 1); // ä¸Šå‡ for (int j = m + 1; j &lt;= x[i] + m; ++j) f[i][m] = min(f[i][m], f[i][j]); // å°†é£åˆ°å¤©ä¸Šçš„æ‹‰å›æ¥ for (int j = 1; j &lt;= m - y[i]; ++j) f[i][j] = min(f[i][j], f[i - 1][j + y[i]]); // ä¸‹é™ // ç¦åŒº for (int j = 0; j &lt; low[i]; ++j) f[i][j] = INF; for (int j = high[i] + 1; j &lt;= m; ++j) f[i][j] = INF; &#125; int ans = INF; for (int i = 1; i &lt;= n; ++i) ans = min(ans, f[n][i]); if (ans &lt; INF) printf(\"1\\n%d\\n\", ans); else &#123; puts(\"0\"); for (int i = n; i >= 1; --i) &#123; bool flag = false; for (int j = 1; j &lt;= m; ++j) if (f[i][j] &lt; INF) &#123; flag = true; break; &#125; if (flag) &#123; ans = 0; for (int j = 1; j &lt;= i; ++j) if (e[j]) ++ans; printf(\"%d\\n\", ans); return 0; &#125; &#125; &#125; return 0; &#125; [CSP-S2019] Emiya å®¶ä»Šå¤©çš„é¥­ Portal. å¦‚æœæ²¡æœ‰ç¬¬ä¸‰ç§é™åˆ¶ï¼Œé‚£ä¹ˆç›´æ¥ä½¿ç”¨ä¹˜æ³•åŸç†ç¢¾è¿‡å»å³å¯ã€‚é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦æ±‚è§£å‡ºè¿åé™åˆ¶ä¸‰çš„æ–¹æ¡ˆæ•°ï¼Œç„¶åå‡å»å³å¯ã€‚ ä¹Ÿå°±æ˜¯è¯´è¦æ±‚ç”±é£Ÿæçš„å‡ºç°æ¬¡æ•°å¤§äº âŒŠk2âŒ‹\\left\\lfloor \\cfrac{k}{2}\\right\\rfloorâŒŠ2kâ€‹âŒ‹ï¼Œä¸éš¾å‘ç°æ»¡è¶³è¿™ä¸€æ¡ä»¶çš„é£Ÿææœ€å¤šåªæœ‰ 111 ä¸ªï¼Œå¦åˆ™ (âŒŠk2âŒ‹+1)Ã—2&gt;k\\left(\\left\\lfloor \\cfrac{k}{2}\\right\\rfloor+1\\right)\\times 2 &gt; k(âŒŠ2kâ€‹âŒ‹+1)Ã—2&gt;kã€‚äºæ˜¯æˆ‘ä»¬å¯ä»¥æšä¸¾è¿™ä¸€ä¸ªé£Ÿæï¼Œè®¾è¯¥é£Ÿæä¸º xxxï¼Œæ¯ä¸€ä¸ªé£Ÿæéƒ½è¿›è¡Œ DPï¼š è®¾ f(i,k,c)f(i,k,c)f(i,k,c) ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªçƒ¹é¥ªæ–¹æ³•ï¼Œæ€»å…±é€‰å‡º kkk é“èœï¼Œå…¶ä¸­ ccc ä¸ªèœä½¿ç”¨é£Ÿæ xxxï¼Œé‚£ä¹ˆï¼š f(i,k,c)=maxâ¡{f(iâˆ’1,k,c),f(iâˆ’1,kâˆ’1,câˆ’1)Ã—ai,j,j=x,f(iâˆ’1,kâˆ’1,c)Ã—ai,j,jâ‰ x.f(i,k,c)=\\max\\begin{cases} f(i-1,k,c),\\\\ f(i-1,k-1,c-1)\\times a_{i,j},&amp;j=x,\\\\ f(i-1,k-1,c)\\times a_{i,j},&amp;j\\ne x. \\end{cases} f(i,k,c)=maxâ©â¨â§â€‹f(iâˆ’1,k,c),f(iâˆ’1,kâˆ’1,câˆ’1)Ã—ai,jâ€‹,f(iâˆ’1,kâˆ’1,c)Ã—ai,jâ€‹,â€‹j=x,jî€ =x.â€‹ ä½†æ˜¯è¿™æ ·çš„çŠ¶æ€æ•°çˆ†ç‚¸äº†ï¼Œæœ‰ O(n3)O(n^3)O(n3) ä¸ªï¼Œè½¬ç§»æœ‰ O(m)O(m)O(m) ä¸ªï¼Œè¿˜è¦è¿›è¡Œ O(m)O(m)O(m) æ¬¡ DPï¼Œæ—¶é—´å¤æ‚åº¦ O(n3m2)O(n^3 m^2)O(n3m2)ï¼Œæ— æ³•é€šè¿‡ã€‚ c&gt;âŒŠk2âŒ‹c&gt;\\left\\lfloor \\cfrac{k}{2}\\right\\rfloorc&gt;âŒŠ2kâ€‹âŒ‹ æ„å‘³ç€ä»€ä¹ˆï¼Ÿæ³¨æ„å®ƒç­‰ä»·äº c&gt;k2c&gt;\\cfrac{k}{2}c&gt;2kâ€‹ï¼Œä¹Ÿå°±æ˜¯ câˆ’(kâˆ’c)&gt;0c-(k-c)&gt;0câˆ’(kâˆ’c)&gt;0ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨ xxx çš„èœè‚´æ•°é‡å‡å»æœªä½¿ç”¨ xxx çš„èœè‚´æ•°é‡ã€‚è®¾ f(i,Î”c)f(i,\\Delta c)f(i,Î”c) ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªçƒ¹é¥ªæ–¹æ³•ï¼Œxxx ç”¨çš„æ¬¡æ•°å‡æ‰ xxx æœªè¢«ç”¨çš„æ¬¡æ•°ä¸º Î”c\\Delta cÎ”cï¼Œé‚£ä¹ˆï¼š è‹¥ j=xj=xj=xï¼Œåˆ™ f(i,Î”c+1)â†f(i,Î”c+1)+f(iâˆ’1,Î”c)Ã—ai,jf(i,\\Delta c + 1)\\leftarrow f(i,\\Delta c+1)+f(i-1,\\Delta c)\\times a_{i,j}f(i,Î”c+1)â†f(i,Î”c+1)+f(iâˆ’1,Î”c)Ã—ai,jâ€‹ï¼› è‹¥ jâ‰ xj\\ne xjî€ =xï¼Œåˆ™ f(i,Î”câˆ’1)â†f(i,Î”câˆ’1)+f(iâˆ’1,Î”c)Ã—ai,jf(i,\\Delta c - 1)\\leftarrow f(i,\\Delta c-1)+f(i-1,\\Delta c)\\times a_{i,j}f(i,Î”câˆ’1)â†f(i,Î”câˆ’1)+f(iâˆ’1,Î”c)Ã—ai,jâ€‹ï¼› ä¸é€‰ï¼Œ f(i,Î”c)â†f(i,Î”c)+f(iâˆ’1,Î”c)f(i,\\Delta c)\\leftarrow f(i,\\Delta c) + f(i-1,\\Delta c)f(i,Î”c)â†f(i,Î”c)+f(iâˆ’1,Î”c)ã€‚ æœ€åçš„ç­”æ¡ˆå°±æ˜¯æ‰€æœ‰ Î”\\DeltaÎ” ä¸ºæ­£çš„ f(n,Î”c)f(n,\\Delta c)f(n,Î”c) å’Œï¼Œè¿™æ ·å°±æ»¡è¶³ câˆ’(kâˆ’c)&gt;0c-(k-c)&gt;0câˆ’(kâˆ’c)&gt;0ã€‚ è¿˜å¯ä»¥è¿›ä¸€æ­¥è¿›è¡Œä¼˜åŒ–ï¼šå¯¹äºç¬¬äºŒç§è½¬ç§»ï¼Œæˆ‘ä»¬ä¸éœ€è¦æšä¸¾ jjjï¼Œè€Œæ˜¯ç›´æ¥ä½¿ç”¨ aia_iaiâ€‹ çš„å‰ç¼€å’Œå‡å» ai,xa_{i,x}ai,xâ€‹ å³å¯ã€‚ å®ç°æ—¶ç”±äºæ•°ç»„çš„ä¸‹æ ‡ä¸èƒ½æ˜¯è´Ÿçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ç»™ä¸‹æ ‡åŠ ä¸Š 100100100 å³å¯ã€‚æœ€ç»ˆæ—¶é—´å¤æ‚åº¦ä¸º O(mÃ—n2)O(m\\times n^2)O(mÃ—n2)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int MOD = 998244353; int n, m; int S[105]; int a[105][2005]; int f[105][205]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[i][j]), S[i] = (S[i] + a[i][j]) % MOD; ans = 1ll * ans * (S[i] + 1) % MOD; &#125; ans = (ans - 1 + MOD) % MOD; for (int x = 1; x &lt;= m; ++x) &#123; memset(f, 0, sizeof(f)); f[0][0 + 100] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int re = (S[i] + MOD - a[i][x]) % MOD; // åˆ©ç”¨å‰ç¼€å’Œè¿›è¡Œè®¡ç®— for (int j = 1; j &lt;= 201; ++j) &#123; f[i][j + 1] = (f[i][j + 1] + 1ll * a[i][x] * f[i - 1][j]) % MOD; f[i][j - 1] = (f[i][j - 1] + 1ll * re * f[i - 1][j]) % MOD; f[i][j] = (f[i][j] + f[i - 1][j]) % MOD; &#125; &#125; int no = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans - f[n][i + 100] + MOD) % MOD; &#125; printf(\"%d\\n\", ans); return 0; &#125; Problemset å—¯ï¼Œé¢˜çœŸå¤šã€‚ åŒºé—´ DP è¿™é‡Œæ˜¯åŒºé—´ DP çš„å†…å®¹ã€‚ [CF607B] Zuma Portal. è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨æ¶ˆæ‰åŒºé—´ [i,j][i,j][i,j] çš„ç­”æ¡ˆï¼Œè½¬ç§»å¯¹äºè¯»åˆ°è¿™é‡Œçš„è¯»è€…æ¥è¯´ä¸æ˜¯å›°éš¾ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; int a[505]; int f[505][505]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) f[i][i] = 1, f[i][i - 1] = 1; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (a[i] == a[j]) f[i][j] = f[i + 1][j - 1]; for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; [NOIP2003 æé«˜ç»„] åŠ åˆ†äºŒå‰æ ‘ Portal. è®¾ f[i][j]f[i][j]f[i][j] ä»£è¡¨åŒºé—´ [i,j][i,j][i,j] çš„æœ€å¤§ç­”æ¡ˆï¼Œé‚£ä¹ˆ f[i][j]=maxâ¡{f[i,kâˆ’1]Ã—f[k+1][j]+f[k][k]}f[i][j]=\\max\\{f[i,k-1]\\times f[k+1][j]+f[k][k]\\}f[i][j]=max{f[i,kâˆ’1]Ã—f[k+1][j]+f[k][k]}ã€‚åˆå§‹æ¡ä»¶è¦æ³¨æ„ï¼Œç”±äºç©ºæ ‘çš„è´¡çŒ®æ˜¯ 111ï¼Œæ‰€ä»¥è¦ä»¤ f(i,iâˆ’1)=1f(i,i-1)=1f(i,iâˆ’1)=1ã€‚æœ¬é¢˜éœ€è¦æ‰“å°è§£ï¼Œç”¨ root[i][j]root[i][j]root[i][j] è®°å½•åŒºé—´ [i,j][i,j][i,j] æ‰€é€‰å–çš„æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’éå†äºŒå‰æ ‘å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int n; int a[35], root[35][35]; i64 f[35][35]; void print_ans(int l, int r) &#123; if (l > r) return; printf(\"%d \", root[l][r]); if (l == r) return; print_ans(l, root[l][r] - 1); print_ans(root[l][r] + 1, r); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;a[i]); f[i][i] = a[i]; f[i][i - 1] = 1; root[i][i] = i; &#125; f[n + 1][n] = 1; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) if (f[i][j] &lt; f[i][k - 1] * f[k + 1][j] + a[k]) &#123; f[i][j] = f[i][k - 1] * f[k + 1][j] + a[k]; root[i][j] = k; &#125; &#125; printf(\"%lld\\n\", f[1][n]); print_ans(1, n); putchar('\\n'); return 0; &#125; [NOIP2006 æé«˜ç»„] èƒ½é‡é¡¹é“¾ Portal. ç¯ä¸Šé—®é¢˜è‚¯å®šè¦å¤åˆ¶æˆäºŒå€é“¾ï¼Œè€Œä¸”ä¸ºäº†æ–¹ä¾¿è®¡ç®—æˆ‘ä»¬æœ€å¥½ç°äºˆå¤„ç†å‡ºèƒ½é‡ç çš„å¤´å°¾æ ‡è®°ã€‚è½¬ç§»æ—¶ f[i,j]=maxâ¡{f[i,k]+f[k+1,j]+head[i]Ã—head[k+1]Ã—tail[j]}f[i,j]=\\max\\{f[i,k]+f[k+1,j]+head[i]\\times head[k+1]\\times tail[j]\\}f[i,j]=max{f[i,k]+f[k+1,j]+head[i]Ã—head[k+1]Ã—tail[j]}ã€‚ç›¸ä¹˜çš„ä¸‰ä¸ªæ•°åˆ†åˆ«æ˜¯å·¦åŒºé—´å¯¹åº”çš„å¤´æ ‡è®°ï¼Œå³åŒºé—´å¯¹åº”çš„å¤´æ ‡è®°å’Œå³åŒºé—´å¯¹åº”çš„å°¾æ ‡è®°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[205], head[205], tail[205]; int f[205][205]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); head[i] = head[i + n] = a[i]; tail[i - 1] = tail[i + n - 1] = a[i]; &#125; tail[n &lt;&lt; 1] = a[1]; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= (n &lt;&lt; 1) - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + head[i] * head[k + 1] * tail[j]); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i][i + n - 1]); printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1220] å…³è·¯ç¯ Portal. è®¾ f(i,j)f(i,j)f(i,j) è¡¨ç¤ºå…³æ‰ [i,j][i,j][i,j] çš„æœ€å°åŠŸç‡ï¼Ÿä¸è¡Œï¼Œå› ä¸ºæˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“å¼ å¤§çˆ·ï¼ˆä¸æ˜¯ç¬”è€…ï¼‰çš„ä½ç½®ï¼Œåˆ°åº•æ˜¯åœ¨ iii è¿˜æ˜¯åœ¨ jjjã€‚æ‰€ä»¥ f(i,j,0)f(i,j,0)f(i,j,0) è¡¨ç¤ºå¼ å¤§çˆ·åœ¨ iiiï¼Œf(i,j,1)f(i,j,1)f(i,j,1) è¡¨ç¤ºå¼ å¤§çˆ·åœ¨ jjjã€‚è½¬ç§»å¯¹è¯»åˆ°è¿™çš„è¯»è€…æ¥è¯´ä¸æ˜¯å›°éš¾ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;cmath> using namespace std; int n, c; int p[155], w[155]; int sum[155]; int f[155][155][2]; int calc(int x, int y) &#123; // é™¤å¼€åŒºé—´ [x, y] çš„å’Œ return sum[x - 1] + sum[n] - sum[y]; &#125; int main(void) &#123; memset(f, 0x3f, sizeof(f)); scanf(\"%d%d\", &amp;n, &amp;c); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", p + i, w + i); sum[i] = sum[i - 1] + w[i]; &#125; f[c][c][0] = f[c][c][1] = 0; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j][0] = min(f[i + 1][j][0] + (p[i + 1] - p[i]) * calc(i + 1, j), f[i + 1][j][1] + (p[j] - p[i]) * calc(i + 1, j)); f[i][j][1] = min(f[i][j - 1][0] + (p[j] - p[i]) * calc(i, j - 1), f[i][j - 1][1] + (p[j] - p[j - 1]) * calc(i, j - 1)); &#125; printf(\"%d\\n\", min(f[1][n][0], f[1][n][1])); return 0; &#125; [USACO07OPEN] Cheapest Palindrome G Portal. è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨å®Œæˆ [i,j][i,j][i,j] çš„æœ€å°ä»£ä»·ï¼Œç„¶ååˆ†ç±»è½¬ç§»ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m; char s[2005]; int f[2005][2005]; int a[30], b[30]; int main(void) &#123; cin >> n >> m; scanf(\"%s\", s + 1); for (int i = 1; i &lt;= n; ++i) &#123; char x; int y, z; cin >> x >> y >> z; a[x - 'a'] = y, b[x - 'a'] = z; &#125; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= m; ++i) f[i][i] = 0, f[i][i - 1] = 0; f[m + 1][m] = 0; for (int len = 2; len &lt;= m; ++len) for (int i = 1; i &lt;= m - len + 1; ++i) &#123; int j = i + len - 1; if (s[i] == s[j]) f[i][j] = min(f[i][j], f[i + 1][j - 1]); f[i][j] = min(f[i][j], f[i][j - 1] + min(b[s[j] - 'a'], a[s[j] - 'a'])); f[i][j] = min(f[i][j], f[i + 1][j] + min(b[s[i] - 'a'], a[s[i] - 'a'])); &#125; printf(\"%d\\n\", f[1][m]); return 0; &#125; [HNOI2010] åˆå”±é˜Ÿ Portal. è®¾ f(i,j)f(i,j)f(i,j) è¡¨ç¤ºå½¢æˆç†æƒ³é˜Ÿåˆ—ä¸­åŒºé—´ [i,j][i,j][i,j] çš„æ–¹æ¡ˆæ•°ï¼Ÿä½†æ˜¯è¿™æ ·æˆ‘ä»¬ä¸çŸ¥é“ä¸Šä¸€ä¸ªäººæ˜¯è°ï¼Œé‚£ä¹ˆå°±è®¾ f(i,j,0)f(i,j,0)f(i,j,0) ä»£è¡¨ä¸Šä¸€ä¸ªäººä»å·¦è¾¹åŠ ï¼Œf(i,j,1)f(i,j,1)f(i,j,1) ä»£è¡¨ä¸Šä¸€ä¸ªäººä»å³è¾¹åŠ ï¼Œåˆå§‹æ¡ä»¶ä»…è®¾å…¶ä¸­ä¸€ä¸ªä¸º 111 å³å¯ï¼ˆå¦åˆ™ä¼šç®—é‡ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stc++.h> using namespace std; const int MOD = 19650827; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar(); return x; &#125; int n; int a[1005]; int f[1005][1005][2]; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); f[i][i][0] = 1; &#125; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (a[i] &lt; a[i + 1]) f[i][j][0] += f[i + 1][j][0]; if (a[i] &lt; a[j]) f[i][j][0] += f[i + 1][j][1]; f[i][j][0] %= MOD; if (a[j] > a[i]) f[i][j][1] += f[i][j - 1][0]; if (a[j] > a[j - 1]) f[i][j][1] += f[i][j - 1][1]; f[i][j][1] %= MOD; &#125; cout &lt;&lt; (f[1][n][0] + f[1][n][1]) % MOD &lt;&lt; endl; return 0; &#125; [UVA1336] Fixing the Great Wall Portal. å’Œâ€œå…³è·¯ç¯â€å¾ˆç›¸ä¼¼ã€‚è¿™ç§ä¸çŸ¥åˆ°å½“å‰çš„æ—¶é—´ï¼Œè€Œåœ¨è½¬ç§»æ—¶å°†â€œæœªæ¥å¢åŠ çš„è´¹ç”¨â€è®¡ç®—å¥½ï¼Œç„¶åâ€œæ—¶é—´å½’é›¶â€çš„æŠ€å·§å¾ˆæœ‰ç”¨ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; int n, x; double v; double f[1005][1005][2]; // k = 0 åœ¨ i, k = 1 åœ¨ j int s[1005]; struct mouse &#123; int x, c, d; mouse(int x = 0, int c = 0, int d = 0) : x(x), c(c), d(d) &#123;&#125; bool operator &lt; (const mouse &amp;a) const &#123; return x &lt; a.x; &#125; &#125; a[1005]; int g(int x, int y) &#123; return s[n] - (s[y] - s[x - 1]); &#125; int main(void) &#123; // è®¡ç®—æœªå‘ç”Ÿï¼Œä½†æ˜¯è‚¯å®šä¼šå‘ç”Ÿçš„ä»£ä»·ï¼Œç„¶åâ€œæ—¶é’Ÿå½’é›¶â€ while (scanf(\"%d%lf%d\", &amp;n, &amp;v, &amp;x) == 3 &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d%d\", &amp;a[i].x, &amp;a[i].c, &amp;a[i].d); a[++n] = mouse(x); sort(a + 1, a + n + 1); int t, sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].x == x) t = i; s[i] = s[i - 1] + a[i].d; sum += a[i].c; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) f[i][j][0] = f[i][j][1] = 1e9; f[t][t][0] = f[t][t][1] = 0; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j][0] = min(f[i + 1][j][0] + (a[i + 1].x - a[i].x) / v * g(i + 1, j), f[i + 1][j][1] + (a[j].x - a[i].x) / v * g(i + 1, j)); f[i][j][1] = min(f[i][j - 1][0] + (a[j].x - a[i].x) / v * g(i, j - 1), f[i][j - 1][1] + (a[j].x - a[j - 1].x) / v * g(i, j - 1)); &#125; printf(\"%d\\n\", int(sum + min(f[1][n][0], f[1][n][1]))); &#125; return 0; &#125; [USACO19DEC] Greedy Pie Eaters P Portal. è€ƒè™‘è®¡ç®— f(i,j)f(i,j)f(i,j) ä¸ºåƒæ‰ [i,j][i,j][i,j] çš„æ´¾æ‰€èƒ½å¾—åˆ°çš„æœ€å¤§ä½“é‡ã€‚é‚£ä¹ˆæœ‰ f(i,j)=maxâ¡{f(i,kâˆ’1)+f(k+1,j)+p(i,j,k)}f(i,j)=\\max\\{f(i,k-1)+f(k+1,j)+p(i,j,k)\\}f(i,j)=max{f(i,kâˆ’1)+f(k+1,j)+p(i,j,k)}ï¼Œå…¶ä¸­ p(i,j,k)p(i,j,k)p(i,j,k) ä»£è¡¨åŒºé—´ [i,j][i,j][i,j] ä¸­ kkk æœªè¢«åƒæ‰ï¼Œç°åœ¨åƒäº†è·å¾—çš„æœ€å¤§ä½“é‡ï¼Œå¯ä»¥é€šè¿‡åŒºé—´ DP é¢„å¤„ç†å¾—åˆ°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, m; int w[90005], l[50005], r[50005]; int f[305][305], g[305][305][305]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int w, l, r; scanf(\"%d%d%d\", &amp;w, &amp;l, &amp;r); for (int j = l; j &lt;= r; ++j) g[l][r][j] = w; &#125; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt;= j; ++k) g[i][j][k] = max(&#123;g[i][j][k], g[i + 1][j][k], g[i][j - 1][k]&#125;); &#125; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j]); for (int k = i; k &lt;= j; ++k) f[i][j] = max(f[i][j], f[i][k - 1] + f[k + 1][j] + g[i][j][k]); &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; [CSP-S 2021] æ‹¬å·åºåˆ— Portal. å¤§å‹åˆ†ç±»è®¨è®ºï¼Œæ³¨æ„ä¸è¦ç®—é‡ï¼Œæœ‰è®¸å¤šç§æ–¹æ³•å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼šç»†åˆ†çŠ¶æ€æˆ–è€…å¯¹ç‰¹åˆ«å¤„ç†ç®—é‡çš„æƒ…å†µã€‚å¯¹äºè¯»åˆ°è¿™é‡Œçš„è¯»è€…æ¥è¯´åº”è¯¥èƒ½å®Œæˆè¿™é“é¢˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 1000000007; int n, k; char s[505]; i64 f[505][505][6]; // f[0]: ** // f[1]: (..) // f[2]: (..)** // f[3]: (..)..(..) åŒ…å« 1 // f[4]: **(..) // f[5]: **(..)** åŒ…å« 0 int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;k, s + 1); for (int i = 1; i &lt;= n; ++i) f[i][i-1][0] = 1; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (len &lt;= k) f[i][j][0] = f[i][j-1][0] &amp;&amp; (s[j] == '*' || s[j] == '?'); if (len >= 2) &#123; if ((s[i] == '(' || s[i] == '?') &amp;&amp; (s[j] == ')' || s[j] == '?')) f[i][j][1] = (f[i+1][j-1][0] + f[i+1][j-1][2] + f[i+1][j-1][3] + f[i+1][j-1][4]) % MOD; for (int k = i; k &lt; j; ++k) &#123; f[i][j][2] = (f[i][j][2] + f[i][k][3] * f[k+1][j][0]) % MOD; f[i][j][3] = (f[i][j][3] + (f[i][k][2]+f[i][k][3]) * f[k+1][j][1]) % MOD; f[i][j][4] = (f[i][j][4] + (f[i][k][4]+f[i][k][5]) * f[k+1][j][1]) % MOD; f[i][j][5] = (f[i][j][5] + f[i][k][4] * f[k+1][j][0]) % MOD; &#125; &#125; f[i][j][5] = (f[i][j][5] + f[i][j][0]) % MOD; f[i][j][3] = (f[i][j][3] + f[i][j][1]) % MOD; &#125; printf(\"%lld\\n\", f[1][n][3]); return 0; &#125; é«˜ç»´ DP é«˜ç»´ DPã€‚ [SDOI2010] åœ°ç²¾éƒ¨è½ Portal.ä¸€åº§é•¿åº¦ä¸º nnn çš„å±±è„‰å¯åˆ†ä¸ºä»å·¦åˆ°å³çš„ nnn æ®µï¼Œæ¯æ®µæœ‰ä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„é«˜åº¦ hih_ihiâ€‹ï¼Œå…¶ä¸­ hih_ihiâ€‹ æ˜¯ 111 åˆ° nnn ä¹‹é—´çš„æ­£æ•´æ•°ã€‚è¿™ nnn æ®µå±±è„‰æ¯æ®µéƒ½å¿…é¡»æ˜¯ä¸€ä¸ªå±±å³°æˆ–è€…å±±è°·ï¼Œé—®è¿™æ ·çš„å±±è„‰æœ‰å¤šå°‘ç§ã€‚ç­”æ¡ˆå¯¹ ppp å–æ¨¡ã€‚3â‰¤Nâ‰¤42003 \\le N \\le 42003â‰¤Nâ‰¤4200ï¼ŒPâ‰¤109P \\le 10^9Pâ‰¤109ã€‚ è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨è€ƒè™‘å‰ iii ä¸ªæ•°ï¼Œç¬¬ä¸€ä¸ªæ•°æ˜¯å±±é¡¶ï¼Œé«˜åº¦ä¸º jjj çš„æ–¹æ¡ˆæ•°ã€‚å½“ jjj ä¸ jâˆ’1j-1jâˆ’1 ä¸ç›¸é‚»çš„æ—¶å€™ï¼Œä¸¤è€…ä½ç½®å¯ä»¥äº¤æ¢ï¼Œæ–¹æ¡ˆæ•°æ˜¯ f(i,jâˆ’1)f(i,j-1)f(i,jâˆ’1)ï¼›å½“ç›¸é‚»çš„æ—¶å€™ï¼Œç”±äº jjj æ˜¯å±±å³°ï¼Œjâˆ’1j-1jâˆ’1 æ˜¯å±±è°·ï¼Œè¿™æ—¶æˆ‘ä»¬å°†ç¬¬ 222 ä¸ªæ•°ç¿»è½¬æˆ iâˆ’(jâˆ’1)i-(j-1)iâˆ’(jâˆ’1)ï¼Œè¿™æ—¶å€™å®ƒå°±æˆäº†å±±å³°ï¼Œæ–¹æ¡ˆæ•°å°±æ˜¯ f(iâˆ’1,iâˆ’j+1)f(i-1,i-j+1)f(iâˆ’1,iâˆ’j+1)ã€‚ ç”±äºæˆ‘ä»¬å‡è®¾äº†ç¬¬ä¸€ä¸ªæ•°æ˜¯å±±é¡¶ï¼Œæ‰€ä»¥è¿˜æœ‰ç¬¬ä¸€ä¸ªæ•°æ˜¯å±±è°·çš„ç­”æ¡ˆï¼Œç­”æ¡ˆè¦ä¹˜ 222ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, p; int f[2][4205]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); f[0][2] = 1; for (int i = 3; i &lt;= n; ++i) for (int j = 2; j &lt;= i; ++j) f[i &amp; 1][j] = (f[i &amp; 1][j - 1] + f[(i - 1) &amp; 1][i - j + 1]) % p; uint ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + f[n &amp; 1][i] * 2) % p; printf(\"%u\\n\", ans); return 0; &#125; çº¿æ€§ DP çš„ç»¼åˆåº”ç”¨ è¿™é‡Œçš„é¢˜éš¾åº¦ä¼šç¨å¤§ã€‚ [UVA10559] Blocks Portal. é¢„å¤„ç†é¢œè‰²æ®µï¼Œç„¶åå®šä¹‰ f(l,r,k)f(l,r,k)f(l,r,k) ä»£è¡¨æ¶ˆé™¤ [l,r][l,r][l,r]ï¼Œä¸” rrr å³è¾¹è¿˜æœ‰ kkk ä¸ªä¸ rrr é¢œè‰²ç›¸åŒçš„æœ¨å—ã€‚é‚£ä¹ˆè¦ä¹ˆæ˜¯æ¶ˆ rrrï¼Œè¦ä¹ˆæ˜¯åœ¨ [l,râˆ’1)[l,r-1)[l,râˆ’1) ä¸­æœ‰ä¸ rrr ç›¸åŒçš„é¢œè‰²ï¼Œæ¶ˆå®Œä¸­é—´æ®µä¹‹åå°†ä¸¤æ®µé¢œè‰²åˆå¹¶å†è¿›è¡Œæ¶ˆé™¤ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, a[205]; int tot, len[205], color[205]; int f[205][205][205]; int dfs(int l, int r, int k) &#123; if (f[l][r][k]) return f[l][r][k]; if (l == r) return f[l][r][k] = (len[r] + k) * (len[r] + k); // åªæœ‰ä¸€æ®µï¼Œåªèƒ½æ¶ˆé™¤ f[l][r][k] = dfs(l, r - 1, 0) + (len[r] + k) * (len[r] + k); // å…ˆæ¶ˆé™¤ [l, r - 1] for (int i = l; i &lt; r - 1; ++i) // åœ¨ [l, r - 2] ä¸­å¯»æ‰¾ä¸ r ç›¸åŒçš„é¢œè‰² // å…ˆæ¶ˆé™¤ [i + 1, r - 1] // ç„¶å [l, i] å°±ä¼šä¸ [r, r + len[r] + k] åˆå¹¶ï¼Œå¯ä»¥ç›´æ¥æ¶ˆé™¤ if (color[i] == color[r]) f[l][r][k] = max(f[l][r][k], dfs(l, i, len[r] + k) + dfs(i + 1, r - 1, 0)); return f[l][r][k]; &#125; int main(void) &#123; int T, kase = 0; scanf(\"%d\", &amp;T); while (T--) &#123; memset(f, 0, sizeof(f)); tot = 0; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] == a[i - 1]) ++len[tot]; else ++tot, len[tot] = 1, color[tot] = a[i]; &#125; n = tot; printf(\"Case %d: %d\\n\", ++kase, dfs(1, n, 0)); &#125; return 0; &#125; [THUSC2016] æˆç»©å• Portal.æœŸæœ«è€ƒè¯•ç»“æŸäº†ï¼Œç­ä¸»ä»» L è€å¸ˆè¦å°†æˆç»©å•åˆ†å‘åˆ°æ¯ä½åŒå­¦æ‰‹ä¸­ã€‚L è€å¸ˆå…±æœ‰ nnn ä»½æˆç»©å•ï¼ŒæŒ‰ç…§ç¼–å·ä» 111 åˆ° nnn çš„é¡ºåºå æ”¾åœ¨æ¡Œå­ä¸Šï¼Œå…¶ä¸­ç¼–å·ä¸º iii çš„çš„æˆç»©å•åˆ†æ•°ä¸º WiW_iWiâ€‹ã€‚æˆç»©å•æ˜¯æŒ‰ç…§æ‰¹æ¬¡å‘æ”¾çš„ã€‚å‘æ”¾æˆç»©å•æ—¶ï¼ŒL è€å¸ˆä¼šä»å½“å‰çš„ä¸€å æˆç»©å•ä¸­æŠ½å–è¿ç»­çš„ä¸€æ®µï¼Œè®©è¿™äº›åŒå­¦æ¥é¢†å–è‡ªå·±çš„æˆç»©å•ã€‚å½“è¿™æ‰¹åŒå­¦é¢†å–å®Œæ¯•åï¼ŒL è€å¸ˆå†ä»å‰©ä½™çš„æˆç»©å•ä¸­æŠ½å–è¿ç»­çš„ä¸€æ®µï¼Œä¾›ä¸‹ä¸€æ‰¹åŒå­¦é¢†å–ã€‚ç»è¿‡è‹¥å¹²æ‰¹æ¬¡çš„é¢†å–åï¼Œæˆç»©å•å°†è¢«å…¨éƒ¨å‘æ”¾åˆ°åŒå­¦æ‰‹ä¸­ã€‚å¯¹äºä¸€ä¸ªåˆ†å‘æˆç»©å•çš„æ–¹æ¡ˆï¼Œæˆ‘ä»¬å®šä¹‰å…¶ä»£ä»·ä¸ºï¼šaÃ—k+bÃ—âˆ‘i=1k(maxiâˆ’mini)2a \\times k + b \\times \\sum_{i = 1} ^ k (max_i - min_i) ^ 2aÃ—k+bÃ—i=1âˆ‘kâ€‹(maxiâ€‹âˆ’miniâ€‹)2å…¶ä¸­ kkk æ˜¯åˆ†å‘çš„æ‰¹æ¬¡æ•°ï¼Œå¯¹äºç¬¬ iii æŠ«åˆ†å‘çš„æˆç»©å•ï¼Œmaximax_imaxiâ€‹ æ˜¯æœ€é«˜åˆ†æ•°ï¼Œminimin_iminiâ€‹ æ˜¯æœ€ä½åˆ†æ•°ï¼Œaaa å’Œ bbb æ˜¯ç»™å®šçš„è¯„ä¼°å‚æ•°ã€‚ç°åœ¨ï¼Œè¯·ä½ å¸®åŠ© L è€å¸ˆæ‰¾åˆ°ä»£ä»·æœ€å°çš„åˆ†å‘æˆç»©å•çš„æ–¹æ¡ˆï¼Œå¹¶å°†è¿™ä¸ªæœ€å°çš„ä»£ä»·å‘Šè¯‰ L è€å¸ˆã€‚å½“ç„¶ï¼Œåˆ†å‘æˆç»©å•çš„æ‰¹æ¬¡æ•° kkk æ˜¯ä½ å†³å®šçš„ã€‚nâ‰¤50n\\le 50nâ‰¤50ã€‚ è®¾ g(i,j)g(i,j)g(i,j) ä»£è¡¨åŒºé—´ [i,j][i,j][i,j] å…¨éƒ¨å–èµ°çš„ç­”æ¡ˆã€‚åˆå§‹æ—¶ g(i,i)=ag(i,i)=ag(i,i)=aï¼Œç­”æ¡ˆæ˜¯ g(1,n)g(1,n)g(1,n)ã€‚ç°åœ¨è€ƒè™‘è½¬ç§»ï¼Œæˆ‘ä»¬è®¾ f(i,j,x,y)f(i,j,x,y)f(i,j,x,y) ä»£è¡¨åŒºé—´ [i,j][i,j][i,j] ä¸­æ‰€æœ‰æˆç»©å•ï¼ˆå¯ä»¥æœ‰å‘èµ°çš„ï¼‰ä¸­çš„æœ€å¤§å€¼ä¸º yyyï¼Œæœ€å°å€¼ä¸º xxx æ—¶ï¼Œå‘æ”¾çš„æœ€å°ä»£ä»·ï¼Œé‚£ä¹ˆï¼š g(i,j)=minâ¡{f(i,j,x,y)+a+bÃ—(xâˆ’y)2}g(i,j)=\\min\\{f(i,j,x,y)+a+b\\times (x-y)^2\\} g(i,j)=min{f(i,j,x,y)+a+bÃ—(xâˆ’y)2} æ˜¾ç„¶åœ¨ DP ä¹‹å‰éœ€è¦å…ˆç¦»æ•£åŒ–ï¼Œç°åœ¨è€ƒè™‘ fff å¦‚ä½•æ±‚è§£ã€‚ fff å¯ä»¥æ˜¯ [l,râˆ’1][l,r-1][l,râˆ’1] å’Œ rrr åˆå¹¶å¾—æ¥çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯ä» f(i,k,x,y)+g(k+1,j)f(i,k,x,y)+g(k+1,j)f(i,k,x,y)+g(k+1,j) è½¬ç§»è¿‡æ¥çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> #define rep(i, l, r) for (int i = l; i &lt;= r; ++i) using namespace std; inline int F(int x) &#123; return x * x; &#125; int n, a, b; int w[55], l[55]; int f[55][55][55][55], g[55][55]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", w + i), l[i] = w[i]; sort(l + 1, l + n + 1); int m = unique(l + 1, l + n + 1) - (l + 1); for (int i = 1; i &lt;= n; ++i) w[i] = lower_bound(l + 1, l + m + 1, w[i]) - l; memset(f, 0x3f, sizeof(f)); memset(g, 0x3f, sizeof(g)); for (int i = 1; i &lt;= n; ++i) f[i][i][w[i]][w[i]] = 0, g[i][i] = a; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; rep(x, 1, m) rep(y, x, m) &#123; f[i][j][min(x, w[j])][max(y, w[j])] = min(f[i][j][min(x, w[j])][max(y, w[j])], f[i][j - 1][x][y]); for (int k = i; k &lt; j; ++k) f[i][j][x][y] = min(f[i][j][x][y], f[i][k][x][y] + g[k + 1][j]); &#125; rep(x, 1, m) rep(y, x, m) g[i][j] = min(g[i][j], f[i][j][x][y] + a + b * F(l[y] - l[x])); &#125; printf(\"%d\\n\", g[1][n]); return 0; &#125; [POI2015] Myjnie Portal.æœ‰ n(nâ‰¤50)n(n\\le 50)n(nâ‰¤50) å®¶æ´—è½¦åº—ä»å·¦å¾€å³æ’æˆä¸€æ’ï¼Œæ¯å®¶åº—éƒ½æœ‰ä¸€ä¸ªæ­£æ•´æ•°ä»·æ ¼ pip_ipiâ€‹ã€‚æœ‰ m(mâ‰¤4000)m(m\\le 4000)m(mâ‰¤4000) ä¸ªäººè¦æ¥æ¶ˆè´¹ï¼Œç¬¬ iii ä¸ªäººä¼šé©¶è¿‡ç¬¬ aia_iaiâ€‹ ä¸ªå¼€å§‹ä¸€ç›´åˆ°ç¬¬ bib_ibiâ€‹ ä¸ªæ´—è½¦åº—ï¼Œä¸”ä¼šé€‰æ‹©è¿™äº›åº—ä¸­æœ€ä¾¿å®œçš„ä¸€ä¸ªè¿›è¡Œä¸€æ¬¡æ¶ˆè´¹ã€‚ä½†æ˜¯å¦‚æœè¿™ä¸ªæœ€ä¾¿å®œçš„ä»·æ ¼å¤§äº cic_iciâ€‹ï¼Œé‚£ä¹ˆè¿™ä¸ªäººå°±ä¸æ´—è½¦äº†ã€‚è¯·ç»™æ¯å®¶åº—æŒ‡å®šä¸€ä¸ªä»·æ ¼ï¼Œä½¿å¾—æ‰€æœ‰äººèŠ±çš„é’±çš„æ€»å’Œæœ€å¤§ã€‚ å…ˆå°† ccc ç¦»æ•£åŒ–ï¼Œç„¶åè€ƒè™‘ f(i,j,k)f(i,j,k)f(i,j,k) ä»£è¡¨è€ƒè™‘ [i,j][i,j][i,j] çš„æ´—è½¦é—´ï¼Œå®ƒä»¬å½“ä¸­çš„æœ€å°æ¶ˆè´¹é¢å¤§äºç­‰äº kkkã€‚åˆå§‹æ—¶ f(i,j,k)=f(i,j,k+1)f(i,j,k)=f(i,j,k+1)f(i,j,k)=f(i,j,k+1) è½¬ç§»çš„æ—¶å€™å¾ˆç®€å•ï¼š f(i,j,k)=f(i,j,k+1),f(i,j,k)=maxâ¡{f(i,tâˆ’1,k)+f(t+1,j,k)+c}f(i,j,k)=f(i,j,k+1),\\\\ f(i,j,k)=\\max\\{f(i,t-1,k)+f(t+1,j,k)+c\\} f(i,j,k)=f(i,j,k+1),f(i,j,k)=max{f(i,tâˆ’1,k)+f(t+1,j,k)+c} å…¶ä¸­ ccc ä»£è¡¨æ»¡è¶³ iâ‰¤aâ‰¤tâ‰¤bâ‰¤ji\\le a\\le t\\le b\\le jiâ‰¤aâ‰¤tâ‰¤bâ‰¤j çš„äººçš„ä¸ªæ•°ï¼Œè¿™ä¸ªå¯ä»¥åœ¨æšä¸¾ kkk çš„æ—¶å€™é¢„å¤„ç†ã€‚éœ€è¦è¾“å‡ºæ–¹æ¡ˆï¼Œåœ¨è½¬ç§»çš„æ—¶å€™éœ€è¦è®°å½•å½“å‰è¿™ä¸ªçŠ¶æ€çš„æœ€å°æ¶ˆè´¹é¢å’Œåˆ†å‰²ç‚¹ï¼Œç„¶å dfs è¾“å‡ºï¼Œåˆ†å‰²ç‚¹çš„ç­”æ¡ˆè®°å½•ä¸ºæœ€å°æ¶ˆè´¹é¢ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, m; int a[4005], b[4005], c[4005], l[4005]; int f[55][55][4005]; // æœ€å°å€¼å¤§äºç­‰äº k int cnt[55][55]; pair&lt;int, int> p[55][55][4005]; int ans[55]; void dfs(int i, int j, int k) &#123; if (i > j) return; pair&lt;int, int> it = p[i][j][k]; ans[it.second] = l[it.first]; dfs(i, it.second - 1, it.first); dfs(it.second + 1, j, it.first); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", a + i, b + i, c + i), l[i] = c[i]; sort(l + 1, l + m + 1); int t = unique(l + 1, l + m + 1) - (l + 1); for (int i = 1; i &lt;= m; ++i) c[i] = lower_bound(l + 1, l + t + 1, c[i]) - l; for (int op = t; op >= 1; --op) &#123; for (int k = 1; k &lt;= m; ++k) if (c[k] == op) &#123; for (int i = 1; i &lt;= a[k]; ++i) for (int j = b[k]; j &lt;= n; ++j) ++cnt[i][j]; &#125; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j][op] = f[i][j][op + 1]; p[i][j][op] = p[i][j][op + 1]; for (int k = i; k &lt;= j; ++k) &#123; int v = f[i][k - 1][op] + f[k + 1][j][op] + (cnt[i][j] - cnt[i][k - 1] - cnt[k + 1][j]) * l[op]; if (v > f[i][j][op]) &#123; f[i][j][op] = v; p[i][j][op] = &#123;op, k&#125;; &#125; &#125; if (p[i][j][op].first == 0) p[i][j][op] = &#123;op, i&#125;; &#125; &#125; printf(\"%d\\n\", f[1][n][1]); dfs(1, n, 1); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", ans[i]); putchar('\\n'); return 0; &#125; å°ç»“ åŒºé—´ DP å’Œé«˜ç»´ DP æ˜¯çº¿æ€§ç»“æ„ä¸Šæ¯”è¾ƒéš¾çš„ä¸€ç±» DPï¼Œä½†åªè¦å¤šå†™é¢˜ï¼Œä¹Ÿä¸æ˜¯ä»€ä¹ˆéš¾äº‹ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"çº¿æ€§ DP","slug":"çº¿æ€§-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7-DP/"},{"name":"åŒºé—´ DP","slug":"åŒºé—´-DP","permalink":"https://james1badcreeper.github.io/tags/%E5%8C%BA%E9%97%B4-DP/"}]},{"title":"åŠ¨æ€è§„åˆ’åŸºç¡€","slug":"notes/DP/basic-dp","date":"2022-07-25T00:00:00.000Z","updated":"2022-08-11T00:00:00.000Z","comments":true,"path":"cafcfd0d/","link":"","permalink":"https://james1badcreeper.github.io/cafcfd0d/","excerpt":"åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programmingï¼ŒDPï¼‰æ˜¯è¿ç­¹å­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œæ˜¯æ±‚è§£å†³ç­–è¿‡ç¨‹æœ€ä¼˜åŒ–çš„è¿‡ç¨‹ã€‚20 ä¸–çºª 50 å¹´ä»£åˆï¼Œç¾å›½æ•°å­¦å®¶è´å°”æ›¼ï¼ˆR.Bellmanï¼‰ç­‰äººåœ¨ç ”ç©¶å¤šé˜¶æ®µå†³ç­–è¿‡ç¨‹çš„ä¼˜åŒ–é—®é¢˜æ—¶ï¼Œæå‡ºäº†è‘—åçš„æœ€ä¼˜åŒ–åŸç†ï¼Œä»è€Œåˆ›ç«‹äº†åŠ¨æ€è§„åˆ’ã€‚åŠ¨æ€è§„åˆ’é—®ä¸–ä»¥æ¥ï¼Œåœ¨ç»æµç®¡ç†ã€ç”Ÿäº§è°ƒåº¦ã€å·¥ç¨‹æŠ€æœ¯å’Œæœ€ä¼˜æ§åˆ¶ç­‰æ–¹é¢å¾—åˆ°äº†å¹¿æ³›çš„åº”ç”¨ã€‚ä¾‹å¦‚æœ€çŸ­è·¯çº¿ã€åº“å­˜ç®¡ç†ã€èµ„æºåˆ†é…ã€è®¾å¤‡æ›´æ–°ã€æ’åºã€è£…è½½ç­‰é—®é¢˜ï¼Œç”¨åŠ¨æ€è§„åˆ’æ–¹æ³•æ¯”ç”¨å…¶å®ƒæ–¹æ³•æ±‚è§£æ›´ä¸ºæ–¹ä¾¿ã€‚æ‰€ä»¥åŠ¨æ€è§„åˆ’ä¸ä»…åœ¨ OI ä¸­åº”ç”¨å¹¿æ³›ï¼Œåœ¨ç”Ÿæ´»å®é™…åŒæ ·åº”ç”¨å¹¿æ³›ã€‚æœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ ç®€å•çš„åŠ¨æ€è§„åˆ’ã€‚","text":"åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programmingï¼ŒDPï¼‰æ˜¯è¿ç­¹å­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œæ˜¯æ±‚è§£å†³ç­–è¿‡ç¨‹æœ€ä¼˜åŒ–çš„è¿‡ç¨‹ã€‚20 ä¸–çºª 50 å¹´ä»£åˆï¼Œç¾å›½æ•°å­¦å®¶è´å°”æ›¼ï¼ˆR.Bellmanï¼‰ç­‰äººåœ¨ç ”ç©¶å¤šé˜¶æ®µå†³ç­–è¿‡ç¨‹çš„ä¼˜åŒ–é—®é¢˜æ—¶ï¼Œæå‡ºäº†è‘—åçš„æœ€ä¼˜åŒ–åŸç†ï¼Œä»è€Œåˆ›ç«‹äº†åŠ¨æ€è§„åˆ’ã€‚åŠ¨æ€è§„åˆ’é—®ä¸–ä»¥æ¥ï¼Œåœ¨ç»æµç®¡ç†ã€ç”Ÿäº§è°ƒåº¦ã€å·¥ç¨‹æŠ€æœ¯å’Œæœ€ä¼˜æ§åˆ¶ç­‰æ–¹é¢å¾—åˆ°äº†å¹¿æ³›çš„åº”ç”¨ã€‚ä¾‹å¦‚æœ€çŸ­è·¯çº¿ã€åº“å­˜ç®¡ç†ã€èµ„æºåˆ†é…ã€è®¾å¤‡æ›´æ–°ã€æ’åºã€è£…è½½ç­‰é—®é¢˜ï¼Œç”¨åŠ¨æ€è§„åˆ’æ–¹æ³•æ¯”ç”¨å…¶å®ƒæ–¹æ³•æ±‚è§£æ›´ä¸ºæ–¹ä¾¿ã€‚æ‰€ä»¥åŠ¨æ€è§„åˆ’ä¸ä»…åœ¨ OI ä¸­åº”ç”¨å¹¿æ³›ï¼Œåœ¨ç”Ÿæ´»å®é™…åŒæ ·åº”ç”¨å¹¿æ³›ã€‚æœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ ç®€å•çš„åŠ¨æ€è§„åˆ’ã€‚ æ›´æ–°æ—¥å¿— 2022/08/08å®Œæˆäº†é¢„å®šçš„æ‰€æœ‰å†…å®¹ã€‚2022/08/11å¢è¡¥äº† LIS çš„ O(nlogâ¡n)O(n\\log n)O(nlogn) ç®—æ³•åŠå…¶å˜å½¢ã€‚ ä¸ºæ–¹ä¾¿ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å‡ç”¨ DP æŒ‡ä»£åŠ¨æ€è§„åˆ’ã€‚ å¼•å­ æˆ‘ä»¬å…ˆæ¥çœ‹è¿™æ ·ä¸€ä¸ªé—®é¢˜ã€‚ james1 è¦å†™ä¸€å°æ°å¥½æœ‰ nnn ä¸ªå­—çš„å…¥å›¢ç”³è¯·ä¹¦ï¼Œä½†ç”±äº james1 éå¸¸æ‡’ï¼ˆå‡çš„ï¼‰ï¼Œæ‰€ä»¥ä»–ä¼šåœ¨ä¸€å¼€å§‹æœ‰ 111 ä¸ªå­—çš„æ–‡ç¨¿é‡Œè¿›è¡Œä»¥ä¸‹ä¸¤ç§æ“ä½œï¼š å†™å­—ï¼šåœ¨æ–‡ç¨¿æœ«å°¾å†™ 111 ä¸ªå­—ï¼Œå°±æ˜¯è¯´å¦‚æœæ–‡ç¨¿æœ‰ kkk ä¸ªå­—ï¼Œé‚£ä¹ˆå†™å­—åæ–‡ç¨¿ä¼šæœ‰ k+1k+1k+1 ä¸ªå­—ã€‚ å¤è¯»ï¼šå°†å†™å®Œè¿™æ–‡ç¨¿å¤åˆ¶ï¼Œç²˜è´´åˆ°æ–‡ç¨¿æœ«å°¾ï¼Œå°±æ˜¯è¯´å¦‚æœæ–‡ç¨¿æœ‰ kkk ä¸ªå­—ï¼Œé‚£ä¹ˆå¤åˆ¶åæ–‡ç¨¿ä¼šæœ‰ kÃ—2k \\times 2kÃ—2 ä¸ªå­—ã€‚ é—® james1 æœ€å°‘è¦è¿›è¡Œå¤šå°‘æ¬¡æ“ä½œï¼Œæ‰èƒ½å®Œæˆè¿™å°å…¥å›¢ç”³è¯·ä¹¦ï¼Ÿ çœŸå®æƒ…å†µä¸‹å…¥å›¢ç”³è¯·ä¹¦å¯åˆ«è¿™ä¹ˆå†™ï¼Œå¦åˆ™å…¥ä¸è¿›å»åˆ«æ‰¾æˆ‘ã€‚ è´ªå¿ƒçš„æœ«æ—¥ æ„Ÿè§‰è¿™é“é¢˜é•¿å¾—å¾ˆåƒè´ªå¿ƒï¼Œç„¶è€Œä¸€èˆ¬äººå†™çš„è´ªå¿ƒæ˜¯é”™çš„ã€‚ ä¸ºä»€ä¹ˆè¯´æ˜¯ä¸€èˆ¬äººå‘¢ï¼Ÿå› ä¸ºä¸€èˆ¬äººéƒ½ä¸ä¼šå€’ç€æƒ³é¢˜ã€‚å¦‚æœæ­£ç€è´ªå¿ƒï¼Œå› ä¸ºæ˜¯æ°å¥½ nnn ä¸ªå­—ï¼Œæ¯”å¦‚æˆ‘è¦å†™ 313131ï¼Œé‚£ä¹ˆæˆ‘ä¼šè¿™æ · 1â†’2â†’4â†’8â†’16â†’17â†’18â†’...â†’311 \\rightarrow 2 \\rightarrow 4 \\rightarrow 8 \\rightarrow 16 \\rightarrow 17 \\rightarrow 18 \\rightarrow ... \\rightarrow 311â†’2â†’4â†’8â†’16â†’17â†’18â†’...â†’31 è€—è´¹äº†å¤§é‡çš„æ“ä½œï¼Œè¿™æ ·æ˜¾ç„¶ä¸æ˜¯æœ€ä¼˜ã€‚ å†³ç­– æ—¢ç„¶è´ªå¿ƒä¸è¡Œï¼Œé‚£ä¹ˆæˆ‘ä»¬åˆ™ä¹ˆåŠå‘¢ï¼Ÿ james1 æ˜¾ç„¶æ‹¥æœ‰â€œé€‰æ‹©çš„æƒåˆ©â€ã€‚ æ¯ä¸€ç§’é’Ÿï¼Œä»–è¦ä¹ˆå†³å®šâ€œå†™å­—â€ï¼Œè¦ä¹ˆå†³å®šâ€œå¤è¯»â€ã€‚ james1 å†™å®Œæ–‡ç¨¿çš„è¿‡ç¨‹ï¼Œå¯ä»¥ç†è§£æˆä¸€ç³»åˆ—å†³ç­–ï¼šæœ€å¼€å§‹æ˜¯ 111 ä¸ªå­—ï¼Œé€šè¿‡ä¸€æ¬¡æ¬¡å†³ç­–ï¼Œæ–‡ç¨¿å˜å¾—è¶Šæ¥è¶Šé•¿ï¼Œæœ€ç»ˆè¾¾åˆ° nnn ä¸ªå­—ã€‚ è¿™é‡Œåˆ—å‡ºäº†ä¸¤ç§å‡‘å‡º 101010 ä¸ªå­—çš„æ–¹æ¡ˆã€‚ç¬¬ä¸€ç§æ­¥æ•°æ›´å°‘ï¼Œæ‰€ä»¥æ˜¯ä¼˜ç§€çš„æ–¹æ¡ˆï¼›åè€…æ˜¯ä¸ä¼˜çš„æ–¹æ¡ˆã€‚ åœ¨æˆ‘ä»¬æ‰‹ä¸Šæœ‰ 444 ä¸ªå­—çš„æ—¶å€™ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•é€‰æ‹©ï¼Ÿ ç„¶è€Œï¼Œæˆ‘ä»¬å¾ˆéš¾ä»¥åœ¨â€œæ‰‹ä¸Šæœ‰ 444 ä¸ªå­—â€çš„æƒ…å†µä¸‹ï¼Œé€‰å‡ºâ€œæ¥ä¸‹æ¥æ˜¯å˜æˆ 555 ä¸ªå­—è¿˜æ˜¯ 888 ä¸ªå­—â€ã€‚è¿™éœ€è¦æˆ‘ä»¬æœ‰é¢„åˆ¤æœªæ¥çš„èƒ½åŠ›ï¼ è¿™æ˜¾ç„¶ä¸æ˜¯æ­£å¸¸äººèƒ½åšåˆ°çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æ¢ä¸€ç§æ€ç»´æ–¹å¼ã€‚ å­é—®é¢˜çš„æ‹†åˆ† æˆ‘ä»¬æ¥è€ƒè™‘å¦ä¸€ç§æ€ç»´ã€‚ç°åœ¨æˆ‘ä»¬ç›®æ ‡æ˜¯å‡‘å‡º nnn ä¸ªå­—ï¼Œæˆ‘ä»¬å°è¯•å…ˆå†³å®šâ€œæœ€åä¸€ æ­¥æ˜¯å†™å­—è¿˜æ˜¯å¤è¯»â€ï¼ˆæŸäººï¼šç»ˆäºå­¦ä¼šå€’ç€æƒ³äº†ï¼‰ã€‚ è¿™ä¸ªé—®é¢˜ä¼¼ä¹ç®€å•å¾ˆå¤šã€‚é¦–å…ˆï¼Œå¦‚æœ nnn æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ²¡å¾—é€‰ï¼Œå®ƒåªèƒ½æ˜¯å†™å­—ä¹‹åçš„ç»“æœï¼›å¦‚æœ nnn æ˜¯å¶æ•°ï¼Œåªè¦æˆ‘ä»¬çŸ¥é“â€œå‡‘å‡º nâˆ’1n-1nâˆ’1 ä¸ªå­—çš„æ—¶é—´â€å’Œâ€œå‡‘å‡º n2\\cfrac{n}{2}2nâ€‹ ä¸ªå­—çš„æ—¶é—´â€ï¼Œå°±å¯ä»¥é€‰å‡ºè€—æ—¶æ›´çŸ­çš„æ–¹æ¡ˆã€‚å…·ä½“è€Œè¨€ï¼š cost(n)={cost(nâˆ’1)+1,n æ˜¯å¥‡æ•°,min{cost(n2)+1, cost(nâˆ’1)+1},n æ˜¯å¶æ•°.cost(n)=\\begin{cases} cost(n-1)+1 &amp; ,n \\text{ æ˜¯å¥‡æ•°} ,\\\\ \\text{min}\\{cost(\\cfrac{n}{2})+1,~cost(n-1)+1\\} &amp; ,n \\text{ æ˜¯å¶æ•°}. \\end{cases} cost(n)=â©â¨â§â€‹cost(nâˆ’1)+1min{cost(2nâ€‹)+1, cost(nâˆ’1)+1}â€‹,n æ˜¯å¥‡æ•°,,n æ˜¯å¶æ•°.â€‹ ä¾‹å¦‚ï¼Œåœ¨ n=10n=10n=10 çš„æ—¶å€™å†³ç­–ï¼Œå¦‚æœçŸ¥é“â€œå‡‘å‡º 555 çš„ä»£ä»·æ˜¯ 333â€ä»¥åŠâ€œå‡‘å‡º 999 çš„ä»£ä»·æ˜¯ 888â€ï¼Œæˆ‘ä»¬å°±ä¼šé€‰æ‹©â€œä» 555 å¤è¯»å¾—åˆ° 101010â€ï¼Œä»£ä»·æ˜¯ 3+1=43+1=43+1=4ã€‚ å®ç° æ ¹æ®åˆšæ‰æ¨å‡ºçš„å…¬å¼ï¼Œå®ç°å˜å¾—éå¸¸ç®€å•ï¼š int n, cost[105]; int main(void) &#123; scanf(\"%d\", &amp;n); cost[1] = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (n % 2 == 1) cost[i] = cost[i-1]+1; else cost = min(cost[i/2]+1, cost[i-1]+1); printf(\"cost[%d] = %d\\n\", i, cost[i]); &#125; &#125; å¯ä»¥å‘ç°å°±æ˜¯å¯¹ç€åˆšæ‰çš„å…¬å¼ç…§æŠ„ï¼Œæ—¶ç©ºå¤æ‚åº¦å‡ä¸º O(n)\\mathcal{O}(n)O(n)ã€‚ ä¼˜åŒ– ç„¶è€Œè¿™ä¸œè¥¿ä¸æ˜¯æœ€ä¼˜ï¼Œä¹‹å‰è¯´äº†ï¼Œæ­£ç€è´ªå¿ƒæ˜¯é”™çš„ï¼Œä½†å€’ç€è´ªå¿ƒæ˜¯å¯¹çš„ã€‚ ä½†ä¸ºä»€ä¹ˆå€’ç€è´ªå¿ƒæ˜¯å¯¹çš„ï¼Ÿå¾ˆç®€å•ï¼Œå› ä¸º cost(n2)+1â©½cost(nâˆ’1)+1cost(\\cfrac{n}{2})+1\\leqslant cost(n-1)+1cost(2nâ€‹)+1â©½cost(nâˆ’1)+1 æ’æˆç«‹ã€‚ ä»£ç æ›´ç®€å•äº†ï¼š int ans = 0; while (n != 1) &#123; if (n % 2 == 1) --n; else n /= 2; ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; æ—¶é—´å¤æ‚åº¦ Î˜(logâ¡n)\\Theta(\\log n)Î˜(logn)ï¼Œç©ºé—´ O(1)\\mathcal{O}(1)O(1) ã€‚ çŠ¶æ€å’Œå­é—®é¢˜ æˆ‘ä»¬åˆšåˆšè°ˆåˆ°äº†â€œæ‹†åˆ†å­é—®é¢˜â€ï¼Œå°±æ˜¯æˆ‘ä»¬ç°åœ¨éœ€è¦å›ç­”ä¸€ä¸ªå¤§é—®é¢˜ï¼ˆå‡‘ nnn ä¸ªå­—ï¼‰ã€‚ æˆ‘ä»¬å…ˆè§£å†³å‡ ä¸ªå°é—®é¢˜ï¼ˆå‡‘ n2\\cfrac{n}{2}2nâ€‹ ä¸ªå­—ã€å‡‘ nâˆ’1nâˆ’1nâˆ’1 ä¸ªå­—ï¼‰ï¼ŒæŠŠè¿™äº›å°é—®é¢˜çš„ç»“è®ºç»¼åˆèµ·æ¥ï¼Œè·å¾—å¤§é—®é¢˜çš„ç­”æ¡ˆã€‚DP ä¸­ï¼Œä¸€èˆ¬æŠŠæˆ‘ä»¬é¢å¯¹æŸä¸ªé—®é¢˜çš„æƒ…æ™¯ä¹Ÿå«åšâ€œçŠ¶æ€â€ã€‚ä¾‹å¦‚æˆ‘ä»¬æ‰‹ä¸Šæœ‰ kkk ä¸ªå­—ï¼Œè¿™æ˜¯ä¸€ä¸ªçŠ¶æ€ã€‚æˆ‘ä»¬å¯ä»¥ä½œå‡ºâ€œå¤è¯»â€çš„å†³ç­–ï¼Œè½¬ç§»åˆ° 2k2k2k è¿™ä¸ªçŠ¶æ€ï¼›ä¹Ÿå¯ä»¥ä½œå‡ºâ€œå†™å­—â€çš„å†³ç­–ï¼Œè½¬ç§»åˆ° k+1k+1k+1 è¿™ä¸ªçŠ¶æ€ã€‚ å¼•å…¥åè¯æ˜¯ä¸ºäº†ä»¥åèƒ½æ›´åŠ ç®€ä¾¿åœ°æè¿°ç®—æ³•ã€‚ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ cost(n)={cost(nâˆ’1)+1,n æ˜¯å¥‡æ•°,min{cost(n2)+1, cost(nâˆ’1)+1},n æ˜¯å¶æ•°.cost(n)=\\begin{cases} cost(n-1)+1 &amp; ,n \\text{ æ˜¯å¥‡æ•°} ,\\\\ \\text{min}\\{cost(\\cfrac{n}{2})+1,~cost(n-1)+1\\} &amp; ,n \\text{ æ˜¯å¶æ•°}. \\end{cases} cost(n)=â©â¨â§â€‹cost(nâˆ’1)+1min{cost(2nâ€‹)+1, cost(nâˆ’1)+1}â€‹,n æ˜¯å¥‡æ•°,,n æ˜¯å¶æ•°.â€‹ åˆšæ‰è¿™ä¸ªå¼å­ä¾¿æ˜¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚ ç¡¬å¸é—®é¢˜ Luogu B3635.ä»Šæœ‰ä¸‰ç§é¢é¢çš„é’±å¸ï¼Œ111ã€555 å’Œ 111111ã€‚ç°åœ¨è¦å‡‘å‡º nnn å…ƒé’±ï¼Œé—®æœ€å°‘éœ€è¦å¤šå°‘å¼ é’±æ‰èƒ½è¾¾åˆ°ç›®çš„ï¼Ÿ å¯ä»¥è¯æ˜ï¼Œè´ªå¿ƒæ˜¯é”™è¯¯çš„ï¼Œæˆ‘ä»¬éœ€è¦ç”¨ DP æ¥è§£å†³è¿™é“é¢˜ã€‚ çŠ¶æ€çš„è®¾è®¡ æ˜¾ç„¶ï¼Œf(i)f(i)f(i) è¡¨ç¤ºå‡‘å‡º iii å…ƒæœ€å°‘éœ€è¦å¤šå°‘å¼ é’±ã€‚ çŠ¶æ€çš„è½¬ç§» é™¤äº†åˆšæ‰çš„æ–¹æ³•ï¼Œæˆ‘ä»¬è¿˜å°†ä»‹ç»ä¸€ç§æ–°çš„æ–¹æ³•ã€‚ ä¼ ç»Ÿæ–¹æ³•ï¼ˆå¡«è¡¨æ³•ï¼‰ æ ¹æ®ä¹‹å‰çš„ç»éªŒï¼Œæˆ‘ä»¬å¯ä»¥è®¾è®¡å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š f(i)=minâ¡{f(iâˆ’1)+1, f(iâˆ’5)+1, f(iâˆ’11)+1}f(i)=\\min\\{f(i-1)+1,~f(i-5)+1,~f(i-11)+1\\} f(i)=min{f(iâˆ’1)+1, f(iâˆ’5)+1, f(iâˆ’11)+1} ç¨‹åºä¹Ÿå¾ˆå¥½å†™ï¼š int n, f[1005]; memset(f, 0x3f, sizeof(f)); f[0] = 0; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; if(i-1 >= 0) f[i] = min(f[i], f[i-1] + 1); if(i-5 >= 0) f[i] = min(f[i], f[i-5] + 1); if(i-11 >= 0) f[i] = min(f[i], f[i-11] + 1); printf(\"f[%d] = %d\\n\", i, f[i]); &#125; åƒè¿™æ ·ï¼Œå¯¹äºæ¯ä¸ªçŠ¶æ€ iiiï¼Œè®¡ç®— f(i)f(i)f(i) çš„æ–¹å¼ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œå¡«è¡¨æ³•â€ï¼Œæˆ–å½¢è±¡åœ°ç§°ä¹‹ä¸ºâ€œæˆ‘ä»å“ªé‡Œæ¥â€ï¼Œä¹Ÿå°±æ˜¯ pull å‹çš„è½¬ç§»ã€‚ åˆ·è¡¨æ³• æ—¢ç„¶æœ‰â€œæˆ‘ä»å“ªé‡Œæ¥â€ï¼Œé‚£ä¹ˆå¿…å®šæœ‰â€œæˆ‘åˆ°å“ªé‡Œå»â€ï¼Œä¹Ÿå°±æ˜¯åˆ·è¡¨æ³•ï¼Œpush å‹çš„è½¬ç§»ï¼Œå³å¯¹äºæ¯ä¸ªçŠ¶æ€ iiiï¼Œæ›´æ–° f(i)f(i)f(i) æ‰€å½±å“çš„çŠ¶æ€ï¼Œå¯¹äºæ­¤é¢˜è€Œè¨€ï¼š int n, f[1015]; // æƒ³æƒ³è¿™é‡Œä¸ºä»€ä¹ˆè¦æŠŠç©ºé—´å¼€å¤§ // åˆå§‹åŒ–å’Œè¯»å…¥ç•¥ for (int i = 0; i &lt;= n; ++i) // ä» 0 å¼€å§‹ &#123; // æ›´æ–°æ‰€å½±å“çš„çŠ¶æ€ f[i+1] = min(f[i+1], f[i] + 1); f[i+5] = min(f[i+5], f[i] + 1); f[i+11] = min(f[i+11], f[i] + 1); printf(\"f[%d] = %d\\n\", i, f[i]); &#125; é€šå¸¸æˆ‘ä»¬ä¸æŠŠåˆ·è¡¨æ³•çš„å¼å­ç§°ä½œçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œå› ä¸ºå®ƒåªæ˜¯ä¸€ä¸ªæ›´æ–°å…¬å¼ã€‚ ä¸€èˆ¬åœ°ï¼ˆå—¯ï¼ŒçœŸæœ‰ä¸ä¸€èˆ¬åœ°ï¼‰ï¼Œå¡«è¡¨æ³•å’Œåˆ·è¡¨æ³•å¯ä»¥äº’ç›¸è½¬åŒ–ï¼Œåªæ˜¯ä¸€ç§æ¯”è¾ƒå®¹æ˜“äº›ï¼Œå¦ä¸€ç§æ¯”è¾ƒéš¾å†™ã€‚éœ€æ ¹æ®å®é™…æƒ…å†µåˆ¤æ–­ç”¨ä»€ä¹ˆæ–¹æ³•ã€‚ è§£çš„æ‰“å° è™½ç„¶å¤§å¤šæ•°é¢˜ç›®éƒ½ä¸è¦æ±‚æ‰“å°è§£ï¼Œä½†æˆ‘ä»¬è¿˜æ˜¯å¾—ä¼šã€‚ æœ‰å“ªä½ç¥ä»™çŸ¥é“æ€ä¹ˆåšå˜›ï¼Ÿ æˆ‘ä¸ä¼šï¼Œä½†æˆ‘ä¸€å®šæ˜¯å¯¹çš„ã€‚ â€”â€” æœç´¢ å¥½ï¼Œé‚£æˆ‘ä»¬æ¥è¯•è¯•å§ï¼ æ¯”å¦‚æˆ‘ä»¬ç”¨ print_ans(n) æ¥æ‰“å°å‡‘ nnn å—é’±æ—¶çš„è§£ã€‚ print_ans(n) ä»å“ªé‡Œæ¥ï¼Ÿå½“ç„¶æ˜¯ä» print_ans(n-1)ã€print_ans(n-5) æˆ– print_ans(n-11) æ¥ã€‚ é‚£ä¹ˆæ˜¯è¿™ä¸‰ä¸ªä¸­çš„é‚£ä¸ªå‘¢ï¼Ÿå¾ˆç®€å•ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ® f æ•°ç»„æ¥åˆ¤æ–­ã€‚ åƒè¿™æ ·ï¼š void print_ans(int x) &#123; if (x >= 1 &amp;&amp; f[x] == f[x-1] + 1) //f[x] == f[x-1] + 1 åˆ¤æ–­æˆ‘ä»¬é€’æ¨æ—¶æ˜¯ä¸æ˜¯è¿™ä¹ˆå¹²çš„ &#123; printf(\"1 \"); print_ans(x-1); &#125; else if (x >= 5 &amp;&amp; f[x] == f[x-5] + 1) &#123; printf(\"5 \"); print_ans(x-5); &#125; else if (x >= 11 &amp;&amp; f[x] == f[x-11] + 1) &#123; printf(\"11 \"); print_ans(x-11); &#125; &#125; è®°å¿†åŒ–æœç´¢ æ–æ³¢é‚£å¥‘æ•°åˆ—ã€‚è¾“å‡ºæ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬ nnn é¡¹ã€‚ï¼ˆ1â©½nâ©½1071\\leqslant n \\leqslant 10^71â©½nâ©½107ï¼‰ è¿™é‡Œæˆ‘ä»¬ç”¨é€’å½’æ¥å®ç°ï¼š int fib(int n) &#123; if(n &lt;= 2) return 1; return fib(n-2) + fib(n-1); &#125; int main(void) &#123; int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", fib(n)); return 0; &#125; å•è¯´è¿™ä»½ç¨‹åºï¼Œè°éƒ½å†™å¾—å‡ºæ¥ï¼Œä½†æ˜¯ï¼Œå®ƒå¾ˆæ…¢ï¼æ…¢åˆ°ä»€ä¹ˆç¨‹åº¦ï¼Ÿ å› ä¸ºæ–æ³¢é‚£å¥‘æ•°åˆ—æ˜¯æŒ‡æ•°çº§çš„ï¼Œæ‰€ä»¥å®ƒçš„æ—¶é—´å¤åº¦æ˜¯ Î˜(2n)\\Theta (2^n)Î˜(2n)ï¼Œæ‰€ä»¥åœ¨ n=107n=10^7n=107 çš„æ—¶å€™ï¼Œç®—åˆ°å®‡å®™æ¯ç­å®ƒä¹Ÿç®—ä¸å®Œã€‚ å¯ä¸ºä»€ä¹ˆå®ƒè¿™ä¹ˆæ…¢ï¼Ÿå¾ˆç®€å•ï¼Œé‡å¤è®¡ç®—ã€‚æ¯”å¦‚æˆ‘è¦ç®— fib(10)fib(10)fib(10)ï¼Œæƒ³çŸ¥é“ fib(10)fib(10)fib(10)ï¼Œæˆ‘éœ€è¦çŸ¥é“ fib(8)fib(8)fib(8) å’Œ fib(9)fib(9)fib(9)ã€‚è€Œä¸ºæ­¤éœ€è¦çŸ¥é“ fib(6)fib(6)fib(6)ã€fib(7)fib(7)fib(7) å’Œ fib(8)fib(8)fib(8)ï¼Œè€Œ fib(7)fib(7)fib(7) éœ€è¦è®¡ç®—ä¸¤æ¬¡ï¼Œå¦‚æ­¤çœ‹æ¥ï¼Œé‡å¤è®¡ç®—é‡æ˜¯éå¸¸å¤§çš„ï¼ é‚£ä¹ˆæˆ‘ä»¬åŠ ä¸ªæ•°ç»„è®°å½•ä¸‹æ¥ä¹‹å‰ç®—çš„ç»“æœä¸å°±è¡Œäº†ï¼Ÿåƒè¿™æ ·ï¼š int f[10000005]; bool vis[10000005]; int fib(int n) &#123; if(n &lt;= 2) return 1; if (vis[n]) return f[n]; vis[n] = 1; return f[n] = fib(n-2) + fib(n-1); &#125; int main(void) &#123; int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", fib(n)); return 0; &#125; ä¸ºä»€ä¹ˆä½¿ç”¨ visvisvis æ•°ç»„ï¼Ÿåªæ˜¯å› ä¸ºæ–æ³¢é‚£å¥‘æ•°åˆ—æ¯ä¸€é¡¹éƒ½æ˜¯æ­£çš„ï¼Œæ‰€ä»¥æœ‰çš„äººä¼šé€šè¿‡ f[i]=âˆ’1f[i]=-1f[i]=âˆ’1 çš„æ–¹å¼æ¥åˆ¤æ–­ iii æ²¡è®¿é—®è¿‡ï¼Œä½†æœ‰è´Ÿæ•°å°±è¡Œä¸é€šäº†ï¼Œæ‰€ä»¥é‡‡ç”¨ visvisvis è¿™ç§æ›´åŠ é€šç”¨çš„æ–¹å¼ã€‚ è¿™ç§æœç´¢æ—¶è®°å½•ä»¥å‰ç­”æ¡ˆçš„å½¢å¼ï¼Œç§°ä¹‹ä¸ºè®°å¿†åŒ–æœç´¢ã€‚ DP è§£é¢˜æ€è·¯ æˆ‘ä»¬é€šè¿‡ä¸¤é“é¢˜ç›®æ„Ÿå—ä¸€ä¸‹ DP çš„è§£é¢˜æ€è·¯ã€‚ [IOI1994] æ•°å­—ä¸‰è§’å½¢ Portal. é¢˜é¢ è§‚å¯Ÿä¸‹é¢çš„æ•°å­—é‡‘å­—å¡”ã€‚å†™ä¸€ä¸ªç¨‹åºæ¥æŸ¥æ‰¾ä»æœ€é«˜ç‚¹åˆ°åº•éƒ¨ä»»æ„å¤„ç»“æŸçš„è·¯å¾„ï¼Œä½¿è·¯å¾„ç»è¿‡æ•°å­—çš„å’Œæœ€å¤§ã€‚æ¯ä¸€æ­¥å¯ä»¥èµ°åˆ°å·¦ä¸‹æ–¹çš„ç‚¹ä¹Ÿå¯ä»¥åˆ°è¾¾å³ä¸‹æ–¹çš„ç‚¹ã€‚ 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 åœ¨ä¸Šé¢çš„æ ·ä¾‹ä¸­,ä» 7â†’3â†’8â†’7â†’57 \\to 3 \\to 8 \\to 7 \\to 57â†’3â†’8â†’7â†’5 çš„è·¯å¾„äº§ç”Ÿäº†æœ€å¤§ã€‚ è®¾è®¡çŠ¶æ€ ç”¨ä¸€ä¸ªçŠ¶æ€æ¥æè¿°ç›®å‰éœ€è¦æ±‚è§£çš„æƒ…æ™¯ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºè®¾è®¡çŠ¶æ€ã€‚ æœ¬é¢˜å¯ä»¥è¿™æ ·è®¾è®¡çŠ¶æ€ï¼šf(x,y)f(x,y)f(x,y) è¡¨ç¤ºâ€œèµ°åˆ° (x,y)(x,y)(x,y) çš„ä½ç½®ï¼Œèƒ½è·å–çš„æœ€å¤§æ”¶ç›Šâ€ã€‚æ³¨æ„ï¼Œèµ°åˆ°ç¬¬ rrr è¡Œçš„ä»»æ„ä¸€ä¸ªéƒ½å¯ä»¥ã€‚ è®¾è®¡è½¬ç§» è®¾è®¡å®ŒçŠ¶æ€ä¹‹åï¼Œæˆ‘ä»¬è¦å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼ˆæˆ–æ›´æ–°å…¬å¼ï¼‰ã€‚è¿™ä¸ªæ­¥éª¤å«åšâ€œè®¾è®¡è½¬ç§»â€ã€‚è¿™é‡Œé‡‡ç”¨çš„æ˜¯â€åˆ·è¡¨æ³•â€ã€‚ ç”±äºçŠ¶æ€ (x,y)(x,y)(x,y) è¦ä¹ˆèµ°åˆ°ä¸‹é¢çš„ (x+1,y)(x+1, y)(x+1,y) èµ°è¿‡æ¥ï¼Œè¦ä¹ˆä»å³ä¸‹è§’ (x+1,y+1)(x+1,y+1)(x+1,y+1) èµ°è¿‡æ¥ã€‚æ‰€ä»¥å¯ä»¥è¿™æ ·ï¼š f(x+1,y)=maxâ¡{f(x+1,y),f(x,y)+a[x+1][y]}f(x+1,y+1)=maxâ¡{f(x+1,y+1),f(x,y)+a[x+1][y+1]}f(x+1,y)=\\max\\{f(x+1,y),f(x,y)+a[x+1][y]\\} \\\\ f(x+1,y+1)=\\max\\{f(x+1,y+1),f(x,y)+a[x+1][y+1]\\}f(x+1,y)=max{f(x+1,y),f(x,y)+a[x+1][y]}f(x+1,y+1)=max{f(x+1,y+1),f(x,y)+a[x+1][y+1]} å®ç° æ³¨æ„ç­”æ¡ˆè¦å–æœ€å¤§å€¼å³å¯ã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; int r; int a[1005][1005], f[1005][1005]; int main(void) &#123; scanf(\"%d\", &amp;r); for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= i; ++j) scanf(\"%d\", &amp;a[i][j]); f[1][1] = a[1][1]; for (int i = 1; i &lt; r; ++i) for (int j = 1; j &lt;= i; ++j) &#123; f[i + 1][j] = max(f[i + 1][j], f[i][j] + a[i + 1][j]); f[i + 1][j + 1] = max(f[i + 1][j + 1], f[i][j] + a[i + 1][j + 1]); &#125; int ans = 0; for (int i = 1; i &lt;= r; ++i) ans = max(ans, f[r][i]); printf(\"%d\\n\", ans); return 0; &#125; ç”¨ dfs è§£å†³ æˆ‘ä»¬æ¥çœ‹ï¼š int dfs(int x, int y) // ä»£è¡¨ä» [x,y] å‡ºå‘ &#123; if (x == n) return a[x][y]; return max(dfs(x + 1, y), dfs(x + 1, y + 1)) + a[x][y]; &#125; è¿˜è¦åŠ ä¸Šè®°å¿†åŒ–ï¼š int g[1005][1005]; // å…ˆæ‰§è¡Œ memset(g, 0xff, sizeof(g)); int dfs(int x, int y) // ä»£è¡¨ä» [x,y] å‡ºå‘ &#123; if (g[x][y] != -1) return g[x][y]; if (x == n) return g[x][y] = a[x][y]; return g[x][y] = max(dfs(x + 1, y), dfs(x + 1, y + 1)) + a[x][y]; &#125; å…¶å®è¿™æ ·æ˜¯å®šä¹‰äº†çŠ¶æ€ï¼šf(x,y)f(x,y)f(x,y) ä»£è¡¨ä» (x,y)(x,y)(x,y) å‡ºå‘ã€‚è½¬ç§»æ–¹ç¨‹ä¸ºï¼šf(x,y)=max(f(x+1,y),f(x+1,y+1))+a[x][y]f(x,y)=max(f(x + 1, y), f(x + 1, y + 1)) + a[x][y]f(x,y)=max(f(x+1,y),f(x+1,y+1))+a[x][y]ã€‚è€ƒè™‘åˆ°ä¾èµ–æ€§çš„é—®é¢˜ï¼Œæ‰€ä»¥è¦å€’åº DPã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; int r; int a[1005][1005], f[1005][1005]; int main(void) &#123; scanf(\"%d\", &amp;r); for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= i; ++j) scanf(\"%d\", &amp;a[i][j]); for (int i = 1; i &lt;= r; ++i) f[r][i] = a[r][i]; for (int i = r - 1; i >= 1; --i) for (int j = 1; j &lt;= i; ++j) f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]; printf(\"%d\\n\", f[1][1]); return 0; &#125; æœ€å¤§å­æ®µå’Œ Portal. è®¾ f(i)f(i)f(i) ä»£è¡¨ä»¥ iii ç»“å°¾ï¼ˆå¿…é¡»å« iiiï¼‰çš„æœ€å¤§å­æ®µå’Œï¼Œé‚£ä¹ˆæœ‰ f(i)=maxâ¡{f(iâˆ’1)+a[i],a[i]}f(i)=\\max\\{f(i-1)+a[i],a[i]\\}f(i)=max{f(iâˆ’1)+a[i],a[i]}ã€‚ç›®æ ‡ä¸º maxâ¡{f(i)}\\max\\{f(i)\\}max{f(i)}ã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, a[200005], f[200005], ans = -10005; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; f[i] = 0; scanf(\"%d\", &amp;a[i]); f[i] = max(f[i - 1] + a[i], a[i]); ans = max(f[i], ans); &#125; printf(\"%d\", ans); return 0; &#125; DP äºŒè¦ç´  DP æœ‰äºŒè¦ç´ ï¼Œæœ€ä¼˜å­ç»“æ„å’Œæ— åæ•ˆæ€§ã€‚ æœ€ä¼˜å­ç»“æ„ å¤§é—®é¢˜çš„æœ€ä¼˜è§£ï¼Œä¸€å®šæ˜¯ä»å°é—®é¢˜çš„æœ€ä¼˜è§£æ¨å‡ºæ¥çš„ã€‚æ¯”å¦‚ç¡¬å¸é—®é¢˜ï¼Œæˆ‘ä»¬åªå…³å¿ƒ f(15)f(15)f(15) çš„æœ€ä¼˜è§£ï¼Œä»è€Œæ¨å‡ºä¾èµ– f(15)f(15)f(15) çš„ f(16)f(16)f(16)ã€f(20)f(20)f(20)ã€f(26)f(26)f(26) çš„è§£ï¼ˆå¡«è¡¨æ³•ï¼‰ã€‚ æ— åæ•ˆæ€§ ç°åœ¨çš„å†³ç­–ï¼Œåªä¸è¿‡å»çš„ç»“æœæœ‰å…³ï¼Œè€Œä¸è¿‡å»çš„å†³ç­–æ— å…³ã€‚è¿™è·Ÿ DP çš„æœ¬è´¨å¾ˆåƒï¼Œåœ¨æ¯ä¸€ä¸ªé˜¶æ®µæ ¹æ®ä»¥å‰çš„ç­”æ¡ˆï¼ˆä¸æ˜¯å†³ç­–ï¼‰æ¨å‡ºå½“å‰é˜¶æ®µçš„ç­”æ¡ˆã€‚ä¸ºä»€ä¹ˆå¿…é¡»æ»¡è¶³æ— åæ•ˆæ€§ï¼Œæˆ‘ä»¬æ¥çœ‹ï¼š [NOIP2010 æé«˜ç»„] ä¹Œé¾Ÿæ£‹ã€‚ å•Šï¼Œæˆ‘çŸ¥é“äº†ï¼Œæˆ‘æ¥è®¾è®¡çŠ¶æ€ï¼Œåƒè¿™æ ·ï¼šf(i)f(i)f(i) è¡¨ç¤ºèµ°åˆ°ä½ç½® iii èƒ½è·å¾—çš„æœ€å¤§åˆ†æ•°ã€‚ But waitï¼æ³¨æ„è¿™æ ·æˆ‘ä»¬ä¸çŸ¥é“ä¹‹å‰ç”¨äº†å“ªäº›çˆ¬è¡Œå¡ç‰‡ï¼Œæ‰€ä»¥çŠ¶æ€æ˜¯æœ‰åæ•ˆæ€§çš„ï¼æ¢å¥è¯è¯´ï¼Œä¹‹å‰çš„å†³ç­–ä¼šå½±å“ç°åœ¨çš„ç»“æœã€‚æ‰€ä»¥çŠ¶æ€å®šä¹‰çš„ä¸å¤Ÿå¥½ï¼Œæ— æ³•è½¬ç§»ã€‚ å¯ä¸å°±æ˜¯ä¸çŸ¥é“ç”¨äº†å“ªäº›å¡ç‰‡å˜›ï¼é‚£æˆ‘è¿™ä¹ˆå¹²ï¼šf(p,i,j,k,l)f(p,i,j,k,l)f(p,i,j,k,l) ä»£è¡¨èµ°åˆ°ç¬¬ ppp ä¸ªä½ç½®ï¼Œç”¨äº†å¡ç‰‡ 1,2,3,41,2,3,41,2,3,4 åˆ†åˆ« i,j,k,li,j,k,li,j,k,l å¼ ã€‚ å®é™…ä¸Šæ²¡å¿…è¦ï¼Œå› ä¸ºçŸ¥é“ç”¨äº†å“ªäº›å¡ç‰‡å°±çŸ¥é“èµ°åˆ°é‚£ä¸ªä½ç½®äº†ï¼Œæ‰€ä»¥åªéœ€å®šä¹‰ f(i,j,k,l)f(i,j,k,l)f(i,j,k,l)ã€‚å› ä¸ºæœ¬é¢˜æ•°æ®èŒƒå›´å¾ˆå°ï¼Œæ‰€ä»¥ä¸ä¼šçˆ†ç©ºé—´ã€‚ #include &lt;iostream> #include &lt;cstdio> #include &lt;cctype> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m; int a[355], b[5]; int dp[45][45][45][45]; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); while (m--) ++b[read()]; //æ¯ç§å¡ç‰Œçš„æ•°é‡ dp[0][0][0][0] = a[1]; //è¿™é‡Œä½¿ç”¨å¡«è¡¨æ³•ï¼Œå½“ç„¶ï¼Œåˆ·è¡¨æ³•ä¹Ÿæ˜¯å¯ä»¥çš„ for (int i = 0; i &lt;= b[1]; ++i) for (int j = 0; j &lt;= b[2]; ++j) for (int k = 0; k &lt;= b[3]; ++k) for (int l = 0; l &lt;= b[4]; ++l) &#123; int c = i + j*2 + k*3+ l*4 + 1; //è®¡ç®—ä» 1 ç”¨è¿™äº›å¡ç‰Œèµ°åˆ°äº†å“ªé‡Œ #define f dp[i][j][k][l] //ç®€åŒ–ä»£ç çš„æŠ€å·§ if (i != 0) f = max(f, dp[i-1][j][k][l] + a[c]); if (j != 0) f = max(f, dp[i][j-1][k][l] + a[c]); if (k != 0) f = max(f, dp[i][j][k-1][l] + a[c]); if (l != 0) f = max(f, dp[i][j][k][l-1] + a[c]); &#125; printf(\"%d\", dp[b[1]][b[2]][b[3]][b[4]]); return 0; &#125; åƒè¿™æ ·ï¼ŒæŠŠå¼•èµ·åæ•ˆæ€§çš„å› ç´ ç›´æ¥åŠ å…¥åˆ°çŠ¶æ€é‡Œï¼Œæ˜¯å¤„ç†åæ•ˆæ€§çš„æ‰‹æ®µä¹‹ä¸€ï¼ˆå…¶å®ƒä»¥åä¼šè§åˆ°ï¼‰ï¼Œå½¢è±¡åœ°ç§°ä¹‹ä¸ºâ€œæ‰“ä¸è¿‡å°±åŠ å…¥â€ã€‚ çº¿æ€§ DP ä»¥ä¸Šå¯ä»¥è¯´éƒ½æ˜¯ DP çš„å¼•å­ï¼ŒçœŸæ­£çš„æŒ‘æˆ˜ç°åœ¨æ‰åˆšåˆšå¼€å§‹ã€‚ çº¿æ€§ DP æ˜¯æŒ‡â€œå…·æœ‰çº¿æ€§é˜¶æ®µâ€çš„ DPï¼Œä¹ŸåŒ…å«å…·æœ‰å¤šç»´åº¦é˜¶æ®µçš„ DPï¼Œæ¯”å¦‚ä¸Šä¸€é“ä¾‹é¢˜â€œä¹Œé¾Ÿæ£‹â€ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹æ›´å¤šçš„ç»å…¸é—®é¢˜ã€‚ ä¸€ç»´ç»“æ„ä¸Šçš„åŠ¨æ€è§„åˆ’ å®ƒä»¬çš„ç»“æ„åªæœ‰ä¸€ç»´ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯è¯´çŠ¶æ€ä¸€å®šåªæœ‰ä¸€ç»´ã€‚ [Luogu P1192] å°é˜¶é—®é¢˜ Portal. è®¾ f(i)f(i)f(i) ä»£è¡¨è·³åˆ°ç¬¬ iii çº§å°é˜¶çš„æ–¹æ¡ˆæ•°ï¼Œåˆå§‹ f(0)=0f(0)=0f(0)=0ï¼Œæœ‰ f(i)=âˆ‘max(0,iâˆ’k)iâˆ’1f(j)f(i)=\\sum_{max(0,i-k)}^{i-1}f(j)f(i)=âˆ‘max(0,iâˆ’k)iâˆ’1â€‹f(j)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 100003; int n, k; int f[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); f[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = max(i - k, 0); j &lt; i; ++j) f[i] = (f[i] + f[j]) % MOD; printf(\"%d\\n\", f[n]); return 0; &#125; æœ€é•¿ä¸Šå‡å­åºåˆ— æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLongest Increasing Subsequenceï¼ŒLISï¼‰é—®é¢˜ï¼šç»™å®šä¸€ä¸ªé•¿åº¦ä¸º NNN çš„åºåˆ—ï¼Œæ±‚æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼Œå³è¿™ä¸ªé•¿åº¦ä¸º M(Mâ‰¤N)M(M \\le N)M(Mâ‰¤N) çš„å­åºåˆ— BBB æ»¡è¶³ âˆ€iâˆˆ[1,M),Bi&lt;Bi+1\\forall i \\in [1,M), B_i &lt;B_{i+1}âˆ€iâˆˆ[1,M),Biâ€‹&lt;Bi+1â€‹ã€‚å­åºåˆ—æŒ‡åœ¨åŸåºåˆ—ä¸­ä»»æ„åˆ æ‰å‡ ä¸ªæ•°ï¼ˆå¯ä»¥æ˜¯ 000 ä¸ªæ•°ï¼‰æ‰€å¾—åˆ°çš„åºåˆ—ã€‚æ³¨æ„ï¼Œè¿™é‡Œæ˜¯ä¸¥æ ¼ä¸Šå‡ã€‚ ä½ å¯ä»¥åœ¨ POJ2533 æäº¤è¿™é“é¢˜ã€‚ æ€ä¹ˆæ±‚å‘¢ï¼Ÿè®¾ f[i]f[i]f[i] ä¸º iii ç»“å°¾çš„ LIS é•¿åº¦ï¼Œé‚£ä¹ˆå¯ä»¥è®¾è®¡å‡ºè½¬ç§»ï¼šf[i]=maxâ¡{f[j]+1},0â‰¤j&lt;i,Aj&lt;Aif[i] = \\max\\{f[j]+1\\}, 0\\le j &lt; i,A_j&lt; A_if[i]=max{f[j]+1},0â‰¤j&lt;i,Ajâ€‹&lt;Aiâ€‹ã€‚ ä»£ç å¾ˆç®€å•ï¼š int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = 1; // æœ‰æ—¶å€™è¿™ä¸€æ­¥æ˜¯å¿…è¦çš„ï¼ˆå½“æ±‚çš„ä¸æ˜¯æœ€é•¿ä¸Šå‡è€Œæ˜¯æœ€é•¿ä¸å‡ä¹‹ç±»çš„ï¼‰ï¼Œ // å¦‚æœæ±‚çš„æ˜¯æœ€é•¿ä¸Šå‡ï¼Œf[i] å¿…å®šå¯ä»¥åœ¨ j = 0 æ—¶å–åˆ° 1 // ä½†æ˜¯æœ€é•¿ä¸å‡æ²¡æœ‰è¿™ç§ç‰¹ç‚¹ // ä¸ºé˜²æ­¢å‡ºé”™ï¼Œå»ºè®®ä½•æ—¶éƒ½è¦æŠŠè¿™ä¸€æ­¥å†™ä¸Šå»ã€‚ for (int j = 0; j &lt; i; ++j) if (a[i] > a[j]) f[i] = max(f[j] + 1, f[i]); ans = max(ans, f[i]); &#125; ä½†æ˜¯è¿™ç§åšæ³•å¤ªæ…¢äº†ï¼Œå¤æ‚åº¦é«˜è¾¾ O(n2)O(n^2)O(n2)ï¼Œè¿˜æœ‰ä¸€ç§åŸºäºäºŒåˆ†çš„ä¼˜åŒ–åˆ° O(nlogâ¡n)O(n\\log n)O(nlogn) çš„åšæ³•ã€‚ è®¾ g(i)g(i)g(i) è¡¨ç¤º f(j)=if(j)=if(j)=i æ—¶æœ€å°çš„ AjA_jAjâ€‹ï¼Œä¹Ÿå°±æ˜¯é•¿åº¦ä¸º iii çš„ LIS çš„ç»“å°¾æ•°æœ€å°çš„å€¼ã€‚å¯ä»¥è¯æ˜ gig_igiâ€‹ æ˜¯é€’å¢çš„ï¼ˆå­åºåˆ—éƒ½å˜é•¿äº†è¿™ç©æ„æ€ä¹ˆå¯èƒ½å‡å°ï¼‰ï¼Œå…·æœ‰å•è°ƒæ€§ã€‚é‚£ä¹ˆå¯¹äºå½“å‰æ‰«æçš„ f(i)f(i)f(i)ï¼Œå¯ä»¥åœ¨ä¹‹å‰å·²ç»æ‰¾åˆ°çš„ ggg ä¸­ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äº AiA_iAiâ€‹ çš„ g(k)g(k)g(k)ï¼Œåˆ™æ­¤æ—¶ f(i)=kf(i)=kf(i)=kã€‚ å®é™…ä¸Šæ˜¯å› ä¸º LIS é—®é¢˜è¦æ±‚ Ai&gt;AjA_i &gt; A_jAiâ€‹&gt;Ajâ€‹ï¼Œæˆ‘ä»¬ç”¨ AiA_iAiâ€‹ å»åœ¨ ggg æ•°ç»„ä¸­æ£€ç´¢ï¼Œæ£€ç´¢åˆ°äº†ä¸€ä¸ªå¤§äºç­‰äºçš„ä¸‹æ ‡ï¼Œè®¾è¿™ä¸ªä¸‹æ ‡å¯¹åº”çš„æœ€å°çš„ AjA_jAjâ€‹ æ˜¯ xxxï¼Œæ»¡è¶³ xâ‰¥Ajx\\ge A_jxâ‰¥Ajâ€‹ï¼Œç”±äº xxx çš„æœ€å°æ€§ï¼Œxxx çš„å‰ä¸€ä¸ªæ•° yyy ä¸€å®šæ»¡è¶³ y&lt;Ajy&lt;A_jy&lt;Ajâ€‹ã€‚ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å®é™…ä¸Šè¦æ‰¾æ»¡è¶³ g[kâ€²]&lt;Aig[k&#x27;]&lt;A_ig[kâ€²]&lt;Aiâ€‹ çš„æœ€åä¸€ä¸ªä¸‹æ ‡ kâ€²k&#x27;kâ€²ï¼Œå°±æœ‰ f(i)=kâ€²+1f(i)=k&#x27;+1f(i)=kâ€²+1ï¼Œè€Œ kkk æ˜¯ç¬¬ä¸€ä¸ªæ»¡è¶³ g[k]â‰¥Aig[k]\\ge A_ig[k]â‰¥Aiâ€‹ çš„ï¼Œè€Œæˆ‘ä»¬çš„è¿™ç§æ±‚æ³•ä¼šä½¿ k=kâ€²+1k=k&#x27;+1k=kâ€²+1ï¼Œä¹Ÿå°±æœ‰äº† f(i)=kf(i)=kf(i)=kã€‚ç”±äºåœ¨æŸ¥æ‰¾çš„æ—¶å€™ g[k]â‰¥Aig[k]\\ge A_ig[k]â‰¥Aiâ€‹ï¼Œè€Œæˆ‘ä»¬ä¹Ÿè¦æ‰¾æœ€å°çš„ AjA_jAjâ€‹ï¼Œå°±å°† g[k]g[k]g[k] æ›´æ–°ä¸º AiA_iAiâ€‹ å³å¯ã€‚ for (int i = 1; i &lt;= n; ++i) g[i] = INF; // INF è¡¨ç¤ºä¸å­˜åœ¨ for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + n + 1, a[i]) - g; f[i] = k; g[k] = a[i]; &#125; [NOIP1999 æ™®åŠç»„] å¯¼å¼¹æ‹¦æˆªã€‚ æŸå›½ä¸ºäº†é˜²å¾¡æ•Œå›½çš„å¯¼å¼¹è¢­å‡»ï¼Œå‘å±•å‡ºä¸€ç§å¯¼å¼¹æ‹¦æˆªç³»ç»Ÿã€‚ä½†æ˜¯è¿™ç§å¯¼å¼¹æ‹¦æˆªç³»ç»Ÿæœ‰ä¸€ä¸ªç¼ºé™·ï¼šè™½ç„¶å®ƒçš„ç¬¬ä¸€å‘ç‚®å¼¹èƒ½å¤Ÿåˆ°è¾¾ä»»æ„çš„é«˜åº¦ï¼Œä½†æ˜¯ä»¥åæ¯ä¸€å‘ç‚®å¼¹éƒ½ä¸èƒ½é«˜äºå‰ä¸€å‘çš„é«˜åº¦ã€‚æŸå¤©ï¼Œé›·è¾¾æ•æ‰åˆ°æ•Œå›½çš„å¯¼å¼¹æ¥è¢­ã€‚ç”±äºè¯¥ç³»ç»Ÿè¿˜åœ¨è¯•ç”¨é˜¶æ®µï¼Œæ‰€ä»¥åªæœ‰ä¸€å¥—ç³»ç»Ÿï¼Œå› æ­¤æœ‰å¯èƒ½ä¸èƒ½æ‹¦æˆªæ‰€æœ‰çš„å¯¼å¼¹ã€‚ è¾“å…¥å¯¼å¼¹ä¾æ¬¡é£æ¥çš„é«˜åº¦ï¼ˆé›·è¾¾ç»™å‡ºçš„é«˜åº¦æ•°æ®æ˜¯ â‰¤5Ã—104\\le 5\\times 10^4â‰¤5Ã—104 çš„æ­£æ•´æ•°ï¼‰ï¼Œè®¡ç®—è¿™å¥—ç³»ç»Ÿæœ€å¤šèƒ½æ‹¦æˆªå¤šå°‘å¯¼å¼¹ï¼Œå¦‚æœè¦æ‹¦æˆªæ‰€æœ‰å¯¼å¼¹æœ€å°‘è¦é…å¤‡å¤šå°‘å¥—è¿™ç§å¯¼å¼¹æ‹¦æˆªç³»ç»Ÿã€‚ï¼ˆä¸ªæ•° â‰¤105\\le 10^5â‰¤105ï¼‰ã€‚ ç¬¬ä¸€é—®æ±‚çš„æ˜¯æœ€é•¿ä¸å‡å­åºåˆ—ï¼Œéå¸¸ç®€å•ã€‚ ç¬¬äºŒé—®æ€ä¹ˆåšï¼Ÿæƒ³ä¸€æƒ³åœ¨å¯¼å¼¹ä¸åœé£æ¥çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¼šå°è¯•ç”¨ç¬¬ä¸€å¥—æ‹¦æˆªç³»ç»Ÿå»æ‹¦æˆªè¿™ä¸ªå¯¼å¼¹ï¼Œä½†ä¸‡ä¸€æˆ‘ä»¬æ‹¦æˆªä¸äº†ï¼Œå°±åªèƒ½å†ä¸Šä¸€å¥—æ‹¦æˆªç³»ç»Ÿã€‚è¿™æ ·éœ€è¦ä¸Šçš„æ‹¦æˆªç³»ç»Ÿå°±æ˜¯åŸåºåˆ—çš„ LIS é•¿åº¦ã€‚è¿™å°±æ˜¯ Dilworth å®šç†ï¼šå°†ä¸€ä¸ªåºåˆ—å‰–æˆè‹¥å¹²ä¸ªå•è°ƒä¸å‡å­åºåˆ—çš„æœ€å°ä¸ªæ•°ç­‰äºè¯¥åºåˆ—æœ€é•¿ä¸Šå‡å­åºåˆ—çš„ä¸ªæ•°ã€‚ è¿™é‡Œåˆ†åˆ«ç»™å‡º O(n2)O(n^2)O(n2) å’Œ O(nlogâ¡n)O(n\\log n)O(nlogn) çš„ä»£ç ï¼š // O(n^2) #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[100005]; int f1[100005], f2[100005]; int main(void) &#123; int x; while (cin >> x) a[++n] = x; int ans1 = 0, ans2 = 0; for (int i = 1; i &lt;= n; ++i) &#123; f1[i] = f2[i] = 1; for (int j = 0; j &lt; i; ++j) &#123; if (a[i] &lt;= a[j]) f1[i] = max(f1[j] + 1, f1[i]); if (a[i] > a[j]) f2[i] = max(f2[j] + 1, f2[i]); &#125; ans1 = max(ans1, f1[i]); ans2 = max(ans2, f2[i]); &#125; cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2 &lt;&lt; endl; return 0; &#125; // O(nlogn) #include &lt;iostream> #include &lt;algorithm> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; int a[100005], f[100005], g[100005]; int main(void) &#123; int x, ans = 0; while (cin >> x) a[++n] = x; memset(g, 0x3f, sizeof(g)); for (int i = n; i >= 1; --i) // è¿™é‡Œæ±‚çš„æ˜¯æœ€é•¿ä¸é™å­åºåˆ—äº†ï¼Œå€’è¿‡æ¥çœ‹å°±æ˜¯æœ€é•¿ä¸å‡å­åºåˆ— &#123; int k = upper_bound(g + 1, g + n + 1, a[i]) - g; f[i] = k; g[k] = a[i]; ans = max(ans, f[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; memset(g, 0x3f, sizeof(g)); ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + n + 1, a[i]) - g; f[i] = k; g[k] = a[i]; ans = max(ans, f[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; [NOIP2004 æé«˜ç»„] åˆå”±é˜Ÿå½¢ã€‚ è¿™é‡Œçš„å‰åŠéƒ¨åˆ†æ˜¯æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ŒååŠéƒ¨åˆ†æ˜¯åç€çš„æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆå› ä¸ºæˆ‘ä»¬çš„ç®—æ³•å®šä¹‰çš„æ˜¯ä»¥ iii ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼‰ã€‚åªéœ€è¦åˆ†åˆ«è®¡ç®—ï¼Œç„¶åæ‹¼èµ·æ¥å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[105], f[105], g[105]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = 1; for (int j = 0; j &lt; i; ++j) if (a[i] > a[j]) f[i] = max(f[i], f[j] + 1); &#125; for (int i = n; i >= 1; --i) &#123; g[i] = 1; for (int j = n; j > i; --j) if (a[i] > a[j]) g[i] = max(g[i], g[j] + 1); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i] + g[i] - 1); printf(\"%d\\n\", n - ans); return 0; &#125; ä¸Šè¿°å†…å®¹å¯èƒ½ç¨æ˜¾æŠ½è±¡ï¼Œè¿™é‡Œç»™å‡ºä»£ç ä¾›èƒŒè¯µã€‚ å·²ä¸ºæ‚¨æŠ˜å è¿‡é•¿çš„å†…å®¹ // æœ€é•¿ä¸å‡ï¼ˆéä¸¥æ ¼ä¸‹é™ï¼‰ memset(g, 0xbf, sizeof(g)); // è¦æ‰¾å°äºï¼ˆç­‰äºï¼‰å®ƒçš„ï¼Œåˆå§‹åŒ–ä¸ºè´Ÿæ— ç©· for (int i = 1; i &lt;= n; ++i) &#123; int k = upper_bound(g + 1, g + n + 1, a[i], greater&lt;int>()) - g; // æ‰¾åˆ°ç¬¬ä¸€ä¸ª a[i] &lt;= g[k] f[i] = k; g[k] = a[i]; &#125; // æœ€é•¿ä¸Šå‡ï¼ˆä¸¥æ ¼ä¸Šå‡ï¼‰ memset(g, 0x3f, sizeof(g)); for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + n + 1, a[i]) - g; // æ‰¾åˆ°ç¬¬ä¸€ä¸ª a[i] >= g[k] f[i] = k; g[k] = a[i]; &#125; // æœ€é•¿ä¸é™ï¼ˆéä¸¥æ ¼ä¸Šå‡ï¼‰ memset(g, 0x3f, sizeof(g)); for (int i = 1; i &lt;= n; ++i) &#123; int k = upper_bound(g + 1, g + n + 1, a[i]) - g; // æ‰¾åˆ°ç¬¬ä¸€ä¸ª a[i] > g[k] f[i] = k; g[k] = a[i]; &#125; // æœ€é•¿ä¸‹é™ï¼ˆä¸¥æ ¼ä¸‹é™ï¼‰ memset(g, 0xbf, sizeof(g)); for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + n + 1, a[i], greater&lt;int>()) - g; // æ‰¾åˆ°ç¬¬ä¸€ä¸ª a[i] &lt; g[k] f[i] = k; g[k] = a[i]; &#125; ç»å…¸ç»“è®º å°†ä¸€ä¸ªåºåˆ—æ”¹ä¸ºéä¸¥æ ¼å•è°ƒé€’å¢çš„ï¼Œè‡³å°‘éœ€è¦ä¿®æ”¹è¿™ä¸ªåºåˆ—é•¿åº¦å‡å»å•è°ƒä¸é™å­åºåˆ—çš„é•¿åº¦ã€‚ è€Œä¸¥æ ¼å•è°ƒé€’å¢å‘¢ï¼Ÿè€ƒè™‘ 1 1 2 2 3 3ï¼Œç”¨åºåˆ—é•¿åº¦å‡å»å®ƒçš„ LIS é•¿åº¦æ˜¯é”™è¯¯çš„ã€‚å› æ­¤æ„é€  Bi=Aiâˆ’iB_i=A_i-iBiâ€‹=Aiâ€‹âˆ’i å¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸ºéä¸¥æ ¼å•è°ƒé€’å¢ã€‚ [CF713C] Sonya and Problem Wihtout a Legend.ç»™å®šä¸€ä¸ªæœ‰ n(nâ‰¤106)n(n\\le 10^6)n(nâ‰¤106) ä¸ªæ­£æ•´æ•°çš„æ•°ç»„ï¼Œä¸€æ¬¡æ“ä½œä¸­ï¼Œå¯ä»¥æŠŠä»»æ„ä¸€ä¸ªå…ƒç´ åŠ ä¸€æˆ–å‡ä¸€ï¼Œæ±‚ä½¿å¾—åŸåºåˆ—ä¸¥æ ¼é€’å¢çš„æ±‚æœ€å°æ“ä½œæ¬¡æ•°ã€‚ å…ˆè½¬åŒ–ä¸ºè¦å˜æˆéä¸¥æ ¼å•è°ƒé€’å¢ã€‚å¯¹äºä¹‹å‰çš„æ•°ç»´æŠ¤ä¸€ä¸ªå¤§æ ¹å †ï¼Œå¦‚æœå½“å‰çš„ aia_iaiâ€‹ æ¯”ä¹‹å‰æœ€å¤§çš„æ•°å°ï¼Œé‚£ä¹ˆå°±å°†é‚£ä¸ªæœ€å¤§çš„æ•°å¼ºè¡Œæ”¹ä¸º aia_iaiâ€‹ã€‚å‘ç°è¿™æ ·æ„é€ å‡ºæ¥çš„ç­”æ¡ˆä¸€å®šä¸ä¼šæ›´åŠ£ï¼Œä½†æ˜¯æ˜¯å¦åˆæ³•å‘¢ï¼Ÿ å®šä¹‰â€œå¾®è°ƒâ€ä¸ºåœ¨ä¸æ”¹å˜èŠ±è´¹çš„å‰æä¸‹æ”¹å˜æ•°å¯¹çš„å€¼ã€‚æˆ‘ä»¬ç°åœ¨è¦æ‰¾å°† yyy ä¿®æ”¹ä¸º xxx åæ˜¯å¦ä¼šä½¿å¾—ä¸€ä¸ª yyy å‰é¢çš„ zzz æ»¡è¶³ z&gt;yz&gt;yz&gt;yã€‚ å½“ z&gt;yz&gt;yz&gt;y æ—¶çŸ›ç›¾ï¼Œé‚£ä¹ˆè€ƒè™‘å°† x,yx,yx,y å¾®è°ƒæˆ zzzï¼Œæ­¤æ—¶èŠ±è´¹ä¸º (yâˆ’z)+(zâˆ’x)=yâˆ’x(y-z)+(z-x)=y-x(yâˆ’z)+(zâˆ’x)=yâˆ’xï¼Œè¿™æ ·ç­”æ¡ˆä¾ç„¶åˆæ³•ã€‚ å¦‚ä½•è¾“å‡ºç­”æ¡ˆï¼Ÿä»¤ bib_ibiâ€‹ ä¸º iii æ—¶åˆ»çš„å †é¡¶ï¼Œå¯¹ bbb å–ä¸€éåç¼€æœ€å°å€¼å³å¯ã€‚ æœ€é•¿å…¬å…±å­åºåˆ— ç»™å®šä¸¤ä¸ªåºåˆ— AAA å’Œ BBBï¼Œæ±‚å®ƒä»¬é•¿åº¦æœ€å¤§çš„å…¬å…±å­åºåˆ—ï¼ˆå³æ—¢æ˜¯ AAA çš„å­åºåˆ—ä¹Ÿæ˜¯ BBB çš„å­åºåˆ—ï¼‰çš„é•¿åº¦ã€‚å¦‚ 1, 5, 2, 6, 8, 7 å’Œ 2, 3, 5, 6, 9, 8, 4 çš„æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLongest Common Subsequenceï¼ŒLCSï¼‰æ˜¯ 5, 6, 8 æˆ– 2, 6, 8ã€‚ æ€ä¹ˆåšå‘¢ï¼Ÿè®¾ f(i,j)f(i,j)f(i,j) ä¸º A1,A2,â‹¯ ,AiA_1,A_2,\\cdots,A_iA1â€‹,A2â€‹,â‹¯,Aiâ€‹ å’Œ B1,B2,â‹¯ ,BjB_1,B_2,\\cdots,B_jB1â€‹,B2â€‹,â‹¯,Bjâ€‹ çš„ LCS é•¿åº¦ï¼Œé‚£ä¹ˆæ˜¾ç„¶æœ‰ f(i,0)=f(0,i)=0f(i,0)=f(0,i)=0f(i,0)=f(0,i)=0ï¼Œä¸”ï¼š f(i,j)=maxâ¡{f(iâˆ’1,j),f(i,jâˆ’1),f(iâˆ’1,jâˆ’1)+1,A[i]=B[j].f(i,j) =\\max\\begin{cases} f(i-1,j),&amp;\\\\ f(i,j-1),&amp;\\\\ f(i-1,j-1)+1,&amp;A[i]=B[j]. \\end{cases} f(i,j)=maxâ©â¨â§â€‹f(iâˆ’1,j),f(i,jâˆ’1),f(iâˆ’1,jâˆ’1)+1,â€‹A[i]=B[j].â€‹ ä½†æ˜¯è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦å¤ªé«˜äº†ï¼Œæˆ‘ä»¬éœ€è¦ç”¨æ›´å¿«çš„æ–¹æ³•ã€‚å¦‚ä¸‹ï¼š æ¨¡æ¿ã€‚ æ¯”å¦‚ï¼š A: 3 2 1 4 5 B: 1 2 3 4 5 æˆ‘ä»¬æŠŠ A é‡æ–°ç¼–å·æˆæœ‰åºçš„ï¼š A: a b c d e B: c b a d e è¿™æ ·æ ‡å·ä¹‹å LCS æ˜¾ç„¶ä¸å˜ï¼Œå› ä¸ºç›¸å¯¹å…ƒç´ æ²¡å˜ï¼Œä½†æ˜¯å‘ç°å¦‚æœè¿™ä¸ª LCS æƒ³è¦æˆç«‹ï¼Œé‚£ä¹ˆå®ƒå¿…é¡»æ˜¯ A çš„å­åºåˆ—ï¼Œè€Œ A åˆæ˜¯å•è°ƒé€’å¢çš„ï¼Œä¹Ÿå°±ç›¸å½“äºæ˜¯åœ¨ B ä¸­çš„å­åºåˆ—æ˜¯å•è°ƒé€’å¢çš„ï¼Œä¹Ÿå°±æ˜¯è¦æ±‚ B çš„ LISã€‚ #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int n, ans; int p[100005], a[100005], f[100005], g[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); p[x] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); a[i] = p[x]; &#125; memset(g, 0x3f, sizeof(g)); for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + i + 1, a[i]) - g; f[i] = k; g[k] = a[i]; ans = max(ans, f[i]); &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1944] æœ€é•¿æ‹¬å·åŒ¹é… Portal. è®¾ f(i)f(i)f(i) ä¸ºä»¥ iii ç»“æŸçš„æœ€é•¿çš„æ‹¬å·åŒ¹é…å­ä¸²ï¼Œé‚£ä¹ˆ f(i)=f(iâˆ’1)+2+f(iâˆ’f(iâˆ’1)âˆ’2)f(i)=f(i-1)+2+f(i-f(i-1)-2)f(i)=f(iâˆ’1)+2+f(iâˆ’f(iâˆ’1)âˆ’2)ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; string s; int f[1000005]; int main(void) &#123; cin >> s; int ans = 0; for (int i = 1; i &lt; s.length(); ++i) &#123; if ((s[i] == ')' &amp;&amp; s[i - f[i-1] - 1] == '(') || (s[i] == ']' &amp;&amp; s[i - f[i-1] - 1] == '[')) &#123; f[i] = f[i-1] + 2 + (i - 2 - f[i-1] >= 0 ? f[i - 2 - f[i-1]] : 0); ans = max(ans, f[i]); &#125; &#125; if (ans == 0) return 0; for (int i = 1; i &lt; s.length(); ++i) if (f[i] == ans) &#123; for (int j = i - ans + 1; j &lt;= i; ++j) putchar(s[j]); break; &#125; putchar('\\n'); return 0; &#125; [NOIP2000 æé«˜ç»„] ä¹˜ç§¯æœ€å¤§ Portal. è®¾è®¡çŠ¶æ€ã€‚è®¾ f[i][j]f[i][j]f[i][j] ä¸ºå‰ iii ä½ï¼ˆä¸å« iiiï¼‰ç”¨ jjj ä¸ªä¹˜å·çš„ç­”æ¡ˆï¼Œè½¬ç§»ä¹Ÿå¾ˆç®€å•ï¼Œf[i][j]=maxâ¡x&lt;i{f[i][jâˆ’1]Ã—a[i,x)}f[i][j]=\\max\\limits_{x&lt;i}\\{f[i][j-1]\\times a_{[i,x)}\\}f[i][j]=x&lt;imaxâ€‹{f[i][jâˆ’1]Ã—a[i,x)â€‹}ã€‚ P.S. æ³¨æ„ï¼è¿™é¢˜çš„ä»£ç ç»†èŠ‚å·¨å¤šï¼Œä¸€å®šè¦æŒ‰ç…§å·¥ç¨‹æ ‡å‡†ç¼–å†™è¿™é“é¢˜ï¼šå¤„ç†å­—ç¬¦ä¸²ç”¨å·¦é—­å³å¼€åŒºé—´ï¼ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; string dp[45][8]; int n, k; string a; inline string get(int x, int y) // è·å–å­ä¸² &#123; string res = \"\"; for (int i = x; i &lt; y; ++i) res = res + a[i]; return res; &#125; inline string choose(string x, string y) &#123; if (x.length() != y.length()) return x.length() > y.length() ? x : y; for (int i = 0; i &lt; x.length(); ++i) if (x[i] != y[i]) return x[i] > y[i] ? x : y; return x; &#125; int p[5005], q[5005], res[5005]; inline string mul(string x, string y) &#123; int lenx = x.length(), leny = y.length(); for (int i = lenx - 1; i >= 0; --i) p[lenx - i - 1] = x[i] - '0'; for (int i = leny - 1; i >= 0; --i) q[leny - i - 1] = y[i] - '0'; memset(res, 0, sizeof(res)); for (int i = 0; i &lt; lenx; ++i) for (int j = 0; j &lt; leny; ++j) res[i+j] += p[i] * q[j]; int len = lenx + leny; for (int i = 0; i &lt; len; ++i) &#123; res[i+1] += res[i] / 10; res[i] %= 10; &#125; while (res[len] == 0 &amp;&amp; len >= 0) --len; if (len == -1) return \"0\"; string ans = \"\"; for (int i = 0; i &lt;= len; ++i) ans = char(res[i] + '0') + ans; return ans; &#125; int main(void) &#123; cin >> n >> k >> a; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= k; ++j) dp[i][j] = \"0\"; for (int i = 1; i &lt;= n; ++i) // é•¿åº¦ä¸º 1ï¼Œç”¨ 0 ä¸ªä¹˜å· dp[i][0] = get(0, i); for (int i = 2; i &lt;= n; ++i) // ä»é•¿åº¦ä¸º 2 å¼€å§‹è®¡ç®— for (int j = 1; j &lt;= min(k, i - 1); ++j) // i ä¸ªæ•°ï¼Œæœ€å¤š i-1 ä¸ªä¹˜å· for (int pos = j; pos &lt; i; ++pos) dp[i][j] = choose(dp[i][j], mul(dp[pos][j-1], get(pos, i))); cout &lt;&lt; dp[n][k] &lt;&lt; endl; return 0; &#125; [Luogu P1868] é¥¥é¥¿çš„å¥¶ç‰› Portal. ç»™å®š nnn ä¸ªåŒºé—´ï¼Œæ‰¾å‡ºä¸é‡å¤çš„åŒºé—´ï¼Œä½¿å¾—åŒºé—´æ€»é•¿åº¦å°½é‡çš„é•¿ã€‚ æ ¹æ®æ•°æ®èŒƒå›´å’Œç»éªŒï¼Œè®¾ f(i)f(i)f(i) ä»£è¡¨å‰ iii çš„é•¿åº¦åºåˆ—çš„æœ€å¤§ç­”æ¡ˆï¼Œé‚£ä¹ˆæ˜¾ç„¶æœ‰å¯¹äºåŒºé—´ (j,i)(j,i)(j,i)ï¼š f(i)=maxâ¡(f(i),maxâ¡(f(jâˆ’1)+jâˆ’i+1))f(i) = \\max(f(i), \\max(f(j-1)+j-i+1)) f(i)=max(f(i),max(f(jâˆ’1)+jâˆ’i+1)) ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int f[3000005]; vector &lt;int> a[3000005]; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int l = read(), r = read(); a[r].push_back(l); &#125; for (int i = 1; i &lt;= 3000000; ++i) &#123; f[i] = f[i - 1]; for (auto x : a[i]) f[i] = max(f[i], f[x - 1] + i - x + 1); &#125; printf(\"%d\\n\", f[3000000]); return 0; &#125; å¤šç»´ç»“æ„ä¸Šçš„åŠ¨æ€è§„åˆ’ å®ƒä»¬æœ¬èº«å°±æ˜¯é«˜ç»´é—®é¢˜ã€‚ [NOIP2002 æ™®åŠç»„] è¿‡æ²³å’ Portal. è®¾ ans[i][j] ä»£è¡¨èµ°åˆ° (i,j)(i,j)(i,j) çš„æ–¹æ¡ˆæ•°ï¼Œæœ‰ ans(i,j)=ans(iâˆ’1,j)+ans(i,jâˆ’1)ans(i,j)=ans(iâˆ’1,j)+ans(i,jâˆ’1)ans(i,j)=ans(iâˆ’1,j)+ans(i,jâˆ’1)ï¼Œå…·ä½“å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define ll long long using namespace std; const int h[9][2] = &#123;&#123;0, 0&#125;, &#123;1, 2&#125;, &#123;2, 1&#125;, &#123;-1, 2&#125;, &#123;2, -1&#125;, &#123;-1, -2&#125;, &#123;-2, -1&#125;, &#123;1, -2&#125;, &#123;-2, 1&#125;&#125;; bool flag[25][25]; ll ans[25][25]; int main(void) &#123; int n, m, x, y; cin >> n >> m >> x >> y; for (int i = 0; i &lt; 9; i++) &#123; int tx = x + h[i][0], ty = y + h[i][1]; if (tx >= 0 &amp;&amp; tx &lt;= n &amp;&amp; ty >= 0 &amp;&amp; ty &lt;= m) flag[tx][ty] = 1; &#125; if (flag[0][0] == 1) &#123; puts(\"0\"); return 0; &#125; ans[0][0] = 1; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) &#123; if (flag[i][j]) continue; if (i != 0) ans[i][j] += ans[i - 1][j]; if (j != 0) ans[i][j] += ans[i][j - 1]; &#125; cout &lt;&lt; ans[n][m] &lt;&lt; '\\n'; return 0; &#125; [NOIP2000 æé«˜ç»„] æ–¹æ ¼å–æ•° Portal. èµ°ä¸¤å›ç›¸å½“äºä¸¤ä¸ªäººåŒæ—¶èµ°ï¼ˆå¸¸è§å¥—è·¯ï¼‰ï¼Œé‚£ä¹ˆå®šä¹‰ dp[i][j][k][l] ä¸ºå…¶ä¸­ä¸€äººå‘å³èµ° iiiï¼Œå‘ä¸‹èµ° jjjï¼›å¦ä¸€äººå‘å³èµ° kkkï¼Œå‘ä¸‹èµ° lllã€‚ å½“ i+j=k+li+j=k+li+j=k+l æ—¶ï¼Œè½¬ç§»ï¼š dp[i][j][k][l]=gold+maxâ¡{dp[iâˆ’1][j][kâˆ’1][l],dp[iâˆ’1][j][k][lâˆ’1],dp[i][jâˆ’1][kâˆ’1][l],dp[i][jâˆ’1][k][lâˆ’1].dp[i][j][k][l]=gold+\\max \\begin{cases} dp[i-1][j][k-1][l],\\\\ dp[i-1][j][k][l-1],\\\\ dp[i][j-1][k-1][l],\\\\ dp[i][j-1][k][l-1].\\\\ \\end{cases}dp[i][j][k][l]=gold+maxâ©â¨â§â€‹dp[iâˆ’1][j][kâˆ’1][l],dp[iâˆ’1][j][k][lâˆ’1],dp[i][jâˆ’1][kâˆ’1][l],dp[i][jâˆ’1][k][lâˆ’1].â€‹ å…¶ä¸­ goldgoldgold æŒ‡å½“å‰èƒ½è·å¾—çš„åˆ†æ•°ã€‚ å¯ä»¥è¯æ˜è¿™ä¸€è®¾è®¡æ²¡æœ‰åæ•ˆæ€§ï¼Œæ»¡è¶³æœ€ä¼˜å­ç»“æ„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[15][15]; int dp[15][15][15][15]; int main(void) &#123; scanf(\"%d\", &amp;n); int x, y, z; while (scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z) == 3 &amp;&amp; x) a[x][y] = z; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int k = 1; k &lt;= n; ++k) for (int l = 1; l &lt;= n; ++l) if (i + j == k + l) // å®é™…ä¸Šæ˜¯ i+j-2 == k+l-2ï¼Œè¿™æ˜¯ dp çš„å‰æ &#123; #define f dp[i][j][k][l] f = max(f, dp[i-1][j][k-1][l]); f = max(f, dp[i-1][j][k][l-1]); f = max(f, dp[i][j-1][k-1][l]); f = max(f, dp[i][j-1][k][l-1]); f += a[i][j] + a[k][l]; if (i == k &amp;&amp; j == l) f -= a[i][j]; // æƒ³ä¸€æƒ³ï¼Œä¸ºä»€ä¹ˆ #undef f &#125; printf(\"%d\\n\", dp[n][n][n][n]); return 0; &#125; è¿˜å¯ä»¥å†™ä¸€ä¸‹ [NOIP2008 æé«˜ç»„] ä¼ çº¸æ¡ åŠ ä»¥å·©å›ºã€‚ Problemset åŠ¨æ€è§„åˆ’çš„å®è·µæ€§å¾ˆå¼ºï¼Œéœ€è¦åšå¤§é‡çš„é¢˜ç›®ã€‚è¿™é‡Œä¼šç»™å‡ºä¸€äº›ã€‚ä¸ºäº†æ›´å¥½çš„è§£å†³ä¸€ä¸‹é¢˜ç›®ï¼Œè¯·å…ˆäº†è§£èƒŒåŒ…é—®é¢˜çš„åŸºç¡€æ¦‚å¿µéƒ¨åˆ†ï¼ˆä»…ç¬¬ 111 èŠ‚å³å¯ï¼‰ï¼š èƒŒåŒ… DP/b2626942/ ç®€å•é¢˜ è¿™é‡Œçš„é—®é¢˜æ¯”è¾ƒç®€å•ã€‚ [ABC261D] Flipping and Bonus Portal. å½“å‰çš„çŠ¶æ€ç”± f[i,j]f[i,j]f[i,j] æ¥å®šä¹‰ï¼Œè¡¨ç¤ºç¿»åˆ°äº†ç¬¬ iii ä¸ªç¡¬å¸ï¼Œåˆ†æ•°ä¸º jjj æ—¶æ‰€è·å¾—çš„æœ€å¤§é’±æ•°ï¼Œæ²¡æœ‰åæ•ˆæ€§ã€‚ è½¬ç§»å¾ˆç®€å•ï¼šè¦ä¹ˆæ˜¯æ­£é¢ï¼Œè¦ä¹ˆåé¢ï¼Œå¯¹åº”å³å¯ï¼ˆè¯¦è§ä»£ç ï¼‰ã€‚æ»¡è¶³æœ€ä¼˜å­ç»“æ„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x; &#125; int n, m; int x[5005], y[5005]; i64 f[5005][5005], ans; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) x[i] = read(); for (int i = 1; i &lt;= m; ++i) &#123; int c = read(); y[c] = read(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) // æ³¨æ„æœ€å¤šæ‹¿ i-1 åˆ† f[i][0] = max(f[i][0], f[i - 1][j]); // f[i][0] æ˜¯ä» f[i-1][x] ä¸­çš„ä»»æ„ä¸€ä¸ªä¸é€‰åé¢çš„ for (int j = 1; j &lt;= i; ++j) f[i][j] = f[i - 1][j - 1] + x[i] + y[j]; // ä¸€å®šæ˜¯é€‰æ­£é¢äº† &#125; for (int i = 0; i &lt;= n; ++i) ans = max(ans, f[n][i]); printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P1280] å°¼å…‹çš„ä»»åŠ¡ Portal. è®¾ f(i)f(i)f(i) ä»£è¡¨ä» iii æ—¶é—´å¼€å§‹èƒ½è·å¾—çš„æœ€å¤šä¼‘æ¯æ—¶é—´ï¼Œé‚£ä¹ˆï¼š f(i)={f(i+1)+1,maxâ¡{f(i+tj)}.f(i) = \\begin{cases} f(i+1)+1,\\\\ \\max\\{f(i+t_j)\\}. \\end{cases} f(i)={f(i+1)+1,max{f(i+tjâ€‹)}.â€‹ è¿™ä¸ªæ—¶åˆ»æœ‰ä»»åŠ¡é‡‡ç”¨ç¬¬ä¸€ç§è½¬ç§»ï¼Œå¦åˆ™é‡‡ç”¨ç¬¬äºŒç§ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, k, f[10005]; vector &lt;int> v[10005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= k; ++i) &#123; int p, t; scanf(\"%d%d\", &amp;p, &amp;t); v[p].push_back(t); &#125; for (int i = n; i >= 1; --i) &#123; if (v[i].size() == 0) f[i] = f[i + 1] + 1; else &#123; for (int j = 0; j &lt; v[i].size(); ++j) f[i] = max(f[i], f[i + v[i][j]]); &#125; &#125; printf(\"%d\\n\", f[1]); return 0; &#125; [UVa 1025] A spy in the Metro Portal. å½±å“å†³ç­–çš„åªæœ‰å½“å‰æ—¶é—´å’Œæ‰€å¤„çš„è½¦ç«™ã€‚è®¾ f(i,j)f(i,j)f(i,j) è¡¨ç¤ºæ—¶åˆ» iiiï¼Œä½äºè½¦ç«™ jjjï¼Œæœ€å°‘éœ€è¦ç­‰å¾…çš„æ—¶é—´ã€‚æœ‰å¦‚ä¸‹ä¸‰ç§å†³ç­–ï¼š ç­‰ 111 åˆ†é’Ÿï¼› ä¹˜å·¦è¾¹æ¥çš„è½¦ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼› ä¹˜å³è¾¹æ¥çš„è½¦ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚ ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, T, m1, m2, kase = 0; int t[55]; bool has_train[205][55][2]; int f[205][55]; int main(void) &#123; while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; memset(f, 0x3f, sizeof(f)); memset(has_train, 0, sizeof(has_train)); f[0][1] = 0; T = read(); for (int i = 1; i &lt; n; ++i) t[i] = read(); m1 = read(); for (int i = 1; i &lt;= m1; ++i) &#123; int x = read(); for (int j = 1; j &lt;= n; ++j) &#123; has_train[x][j][0] = true; x += t[j]; if (x > T) break; &#125; &#125; m2 = read(); for (int i = 1; i &lt;= m2; ++i) &#123; int x = read(); for (int j = n; j >= 1; --j) &#123; has_train[x][j][1] = true; x += t[j-1]; if (x > T) break; &#125; &#125; for (int i = 1; i &lt;= T; ++i) for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = f[i-1][j] + 1; if (j > 1 &amp;&amp; has_train[i][j][0] &amp;&amp; i >= t[j - 1]) f[i][j] = min(f[i][j], f[i - t[j - 1]][j - 1]); if (j &lt; n &amp;&amp; has_train[i][j][1] &amp;&amp; i >= t[j]) f[i][j] = min(f[i][j], f[i - t[j]][j + 1]); &#125; printf(\"Case Number %d: \", ++kase); if (f[T][n] >= 0x3f3f3f3f) puts(\"impossible\"); else printf(\"%d\\n\", f[T][n]); &#125; return 0; &#125; [UVA10943] How do you add? Portal. è®¾ f(i,k)f(i,k)f(i,k) ä»£è¡¨å°† iii åˆ’åˆ†ä¸º kkk ä¸ªæ•°ã€‚ç›´æ¥æš´åŠ›è½¬ç§»å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 1000000; int n, k; int f[105][105]; int main(void) &#123; for (int i = 0; i &lt;= 100; ++i) &#123; f[i][1] = 1; for (int j = 0; j &lt;= 100; ++j) for (int k = 0; k &lt;= i; ++k) f[i][j] = (f[i][j] + f[i - k][j - 1]) % MOD; &#125; while (scanf(\"%d%d\", &amp;n, &amp;k) == 2 &amp;&amp; n) printf(\"%d\\n\", f[n][k]); return 0; &#125; è¾ƒå¤æ‚å†…å®¹ ä»è¿™é‡Œå¼€å§‹çš„é¢˜ç›®ä¼šæ¯”è¾ƒæœ‰è¶£ã€‚ [Luogu P4310] ç»ä¸–å¥½é¢˜ Portal. æŒ‰ç…§æ±‚è§£ LIS é—®é¢˜çš„ç»éªŒï¼Œå¾ˆå®¹æ˜“è®¾è®¡å‡ºä¸€ä¸ª O(n2)O(n^2)O(n2) çš„æš´åŠ› DPã€‚ç”±äº bi&amp;biâˆ’1â‰ 0b_i\\&amp;b_{i-1}\\ne 0biâ€‹&amp;biâˆ’1â€‹î€ =0ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨äºŒè¿›åˆ¶æ„ä¹‰ä¸‹è‡³å°‘æœ‰ä¸€ä½ç›¸åŒã€‚è®¾ f(i)f(i)f(i) ä»£è¡¨ä»¥åœ¨äºŒè¿›åˆ¶ä¸­ç¬¬ iii ä½ä¸º 111 çš„æ•°ç»“å°¾çš„æ»¡è¶³é¢˜æ„çš„å­åºåˆ—é•¿åº¦ï¼Œé‚£ä¹ˆæ‰«æåˆ°ä¸€ä¸ª aia_iaiâ€‹ï¼Œå°±å¯ä»¥è®¡ç®—ä»¥ aia_iaiâ€‹ ç»“å°¾çš„æœ€é•¿å­åºåˆ—é•¿åº¦ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = 0; int a[100005], f[32]; // f[i] ä»£è¡¨ä»¥åœ¨äºŒè¿›åˆ¶ä¸­ç¬¬ i ä½ä¸º 1 çš„æ•°ç»“å°¾çš„æ»¡è¶³é¢˜æ„çš„å­åºåˆ—é•¿åº¦ int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); int k = 1; // k ä»£è¡¨ä»¥ a[i] ç»“å°¾çš„æœ€é•¿å­åºåˆ—é•¿åº¦ for (int j = 0; j &lt;= 30; ++j) if ((1 &lt;&lt; j) &amp; a[i]) k = max(k, f[j] + 1); // a[i] çš„ç¬¬ j ä½æ˜¯ 1ï¼Œa[i] å¯ä»¥ä¸ç¬¬ j ä½ä¸º 1 çš„æ•°ç»“å°¾çš„å­åºåˆ—è¿èµ·æ¥ for (int j = 0; j &lt;= 30; ++j) if ((1 &lt;&lt; j) &amp; a[i]) f[j] = max(f[j], k); // a[i] çš„ç¬¬ j ä½æ˜¯ 1ï¼Œf[j] å¯¹åº”çš„å­åºåˆ—å¯ä»¥ä»¥ a[i] ç»“å°¾ ans = max(ans, k); &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1385] å¯†ä»¤ Portal. å¯ä»¥å‘ç°ä¸€æ¡ç¥å¥‡çš„æ€§è´¨ï¼šä¸è®ºæ€æ ·ï¼Œè¿™ä¸ªå­—ç¬¦ä¸²çš„å­—ç¬¦å’Œæ°¸è¿œä¸å˜ï¼Œè€Œä¸”ä»»æ„å’Œç›¸ç­‰çš„å­—ç¬¦ä¸²éƒ½å¯ä»¥å˜å‡ºæ¥ã€‚ è¯æ˜ï¼šé‡‡ç”¨æ„é€ æ–¹æ³•ã€‚æˆ‘ä»¬ä»å‰å¾€åæ„é€ æ–°çš„å­—ç¬¦ä¸²ï¼Œè€ƒè™‘ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æœæ¯”ç›®æ ‡å¤§å°±ç”¨ (âˆ’1,+1)(âˆ’1, +1)(âˆ’1,+1) å˜æ¢ï¼Œæ¯”ç›®æ ‡å°å°±ç”¨ (+1,âˆ’1)(+1,âˆ’1)(+1,âˆ’1) å˜æ¢ã€‚ç„¶åå»æç¬¬äºŒä¸ªå­—ç¬¦â€¦â€¦ä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°æå®Œå‰ nâˆ’1n âˆ’ 1nâˆ’1 ä½ã€‚è‡³äºæœ€åä¸€ä½ï¼Œæˆ‘ä»¬æ–­è¨€å®ƒæ­¤æ—¶å¿…å®šç­‰äºç›®æ ‡ä¸²çš„æœ€åä¸€ä½ã€‚è¿™æ˜¯å› ä¸ºä¸¤ç§å˜æ¢å‡ä¸ä¼šæ”¹å˜å­—æ¯å’Œ sumsumsumã€‚ äºæ˜¯æ•´ä¸ªé—®é¢˜è¢«ç®€åŒ–ä¸ºï¼šç»™å®š sumsumsumï¼Œæœ‰å¤šå°‘ç§é•¿åº¦ä¸º nnn çš„åºåˆ—æ»¡è¶³ï¼š æ¯ä¸ªå…ƒç´ åœ¨ [1,26][1, 26][1,26] ä¹‹é—´ï¼› åºåˆ—å’Œä¸º sumsumsumã€‚ è®¾ dp[k][x]dp[k][x]dp[k][x] è¡¨ç¤ºé•¿åº¦ä¸º kkk çš„åºåˆ—ä¹‹å’Œä¸º xxx çš„æ–¹æ¡ˆæ•°ï¼Œç­”æ¡ˆæ˜¾ç„¶æ˜¯ dp[n][sum]dp[n][sum]dp[n][sum]ã€‚è½¬ç§»æ˜¯æ˜¾ç„¶çš„ï¼š dp[k][x]=âˆ‘1â‰¤iâ‰¤minâ¡{26,x}dp[kâˆ’1][xâˆ’i]dp[k][x] = \\sum\\limits_{1\\le i\\le\\min\\{26,x\\}}dp[k âˆ’ 1][x âˆ’ i] dp[k][x]=1â‰¤iâ‰¤min{26,x}âˆ‘â€‹dp[kâˆ’1][xâˆ’i] æˆ‘ä»¬ä¸éœ€è¦æƒ§æ€•å¤šç»„è¯¢é—®ï¼Œé¢„å¤„ç†ä¹‹åå°±èƒ½ç›´æ¥å‡ºç­”æ¡ˆã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #define MOD 1000000007 using namespace std; char s[105]; int f[105][3000]; int main(void) &#123; for (int i = 0; i &lt;= 26; ++i) f[1][i] = 1; for (int i = 2; i &lt;= 102; ++i) &#123; for (int j = 1; j &lt;= 2602; ++j) for (int k = 1; k &lt;= 26; ++k) if (j > k) f[i][j] = (f[i][j] + f[i-1][j-k]) % MOD; &#125; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int sum = 0; string s; cin >> s; for (int i = 0; i &lt; s.length(); ++i) sum += s[i] - 'a' + 1; cout &lt;&lt; (f[s.length()][sum] - 1) % MOD &lt;&lt; '\\n'; &#125; return 0; &#125; [CF1061C] Multiplicity Portal. ä»åºåˆ— {a1,a2,â‹¯ ,an}\\{a_1, a_2,\\cdots,a_n\\}{a1â€‹,a2â€‹,â‹¯,anâ€‹} ä¸­é€‰å‡ºéç©ºå­åºåˆ— {b1,b2,â‹¯ ,bk}\\{b_1,b_2,\\cdots,b_k\\}{b1â€‹,b2â€‹,â‹¯,bkâ€‹}ï¼Œä¸€ä¸ªå­åºåˆ—åˆæ³•éœ€è¦æ»¡è¶³ âˆ€ iâˆˆ[1,k],iâˆ£b\\forall\\ i \\in [1,k],i\\mid bâˆ€ iâˆˆ[1,k],iâˆ£bã€‚æ±‚æœ‰å¤šå°‘äº’ä¸ç›¸ç­‰çš„åˆæ³•å­åºåˆ—ï¼Œç­”æ¡ˆå¯¹ 109+710^9+7109+7 å–æ¨¡ã€‚ ç”±äºäººç±»å°šä¸çŸ¥é“ç´ æ•°åˆ†å¸ƒè§„å¾‹ä¹‹ç±»çš„å†…å®¹ï¼Œæ‰€ä»¥ OI ä¸­çš„æ•°å­¦é¢˜å¾ˆå¤šéƒ½å»ºç«‹åœ¨æšä¸¾ä¹‹ä¸Šã€‚è¿™é“é¢˜å°±æ˜¯ä¸€ä¸ªå…¸å‹çš„ä¾‹å­ã€‚ å¾€å¾€çº¿æ€§ DP çš„çŠ¶æ€è®¾è®¡éƒ½å¾ˆæš´åŠ›ï¼Œæ±‚ä»€ä¹ˆå°±ä»€ä¹ˆã€‚æˆ‘ä»¬ä»¤ f[i,j]f[i,j]f[i,j] ä»£è¡¨å‰ iii ä¸ªæ•°ä¸­é€‰æ‹© jjj ä¸ªæ•°çš„æ–¹æ¡ˆæ•°ã€‚æ˜¾ç„¶æœ‰ï¼š f[i][j]={f[iâˆ’1][j]+f[iâˆ’1][jâˆ’1],jâˆ£a[i]f[iâˆ’1][j]f[i][j] = \\begin{cases} f[i-1][j]+f[i-1][j-1]&amp;,j\\mid a[i]\\\\ f[i-1][j] \\end{cases} f[i][j]={f[iâˆ’1][j]+f[iâˆ’1][jâˆ’1]f[iâˆ’1][j]â€‹,jâˆ£a[i] ä½†æ˜¯è¿™æ ·æ˜¾ç„¶æ˜¯ TLE + MLEã€‚å¦‚ä½•ä¼˜åŒ–ï¼Ÿç”±äº jâˆ£a[i]j\\mid a[i]jâˆ£a[i]ï¼Œæˆ‘ä»¬å¯ä»¥ä¸æšä¸¾ jjj è€Œæ˜¯æšä¸¾ a[i]a[i]a[i] çš„çº¦æ•°ï¼ˆæ–¹æ³•ã€‚åŒæ—¶æˆ‘ä»¬è¿˜å¯ä»¥æŠŠç¬¬ä¸€ç»´ç»™æ»šæ‰ã€‚ ä½†æ˜¯æšä¸¾çº¦æ•°æ—¶ï¼Œç”±äºè½¬ç§»å¿…é¡»è¦æœ‰é¡ºåºï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ’ä¸ªåºã€‚æ»šåŠ¨æ—¶ä¹Ÿè¦æ³¨æ„ï¼Œç”±äºæˆ‘ä»¬éœ€è¦ (iâˆ’1,jâˆ’1)(i-1,j-1)(iâˆ’1,jâˆ’1) çš„å†…å®¹ï¼Œæ‰€ä»¥éœ€è¦å€’åºæšä¸¾ã€‚å› ä¸ºæˆ‘ä»¬éœ€è¦çš„æ˜¯ä¸Šä¸€é˜¶æ®µå‰é¢çš„è§£ï¼Œç¬¬äºŒç§è½¬ç§»å·²ç»ä¸éœ€è¦äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cmath> #include &lt;algorithm> #define MOD 1000000007 using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int a[100005]; int dp[1000005]; int main(void) &#123; n = read(); dp[0] = 1; for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= n; ++i) &#123; vector &lt;int> v; // å…ˆæ±‚çº¦æ•° for (int j = 1; j * j &lt;= a[i]; ++j) &#123; if (a[i] % j == 0) &#123; v.push_back(j); if (j * j != a[i]) v.push_back(a[i] / j); &#125; &#125; sort(v.begin(), v.end()); // æ’åº for (int j = min(int(v.size() - 1), i); j >= 0; --j) dp[v[j]] = (dp[v[j] - 1] + dp[v[j]]) % MOD; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + dp[i]) % MOD; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; [Luogu P3861] æ‹†åˆ† Portal. ç»™å®šä¸€ä¸ªæ•´æ•° n(nâ‰¤1012)n(n\\le 10^{12})n(nâ‰¤1012)ï¼Œæ±‚å°† nnn åˆ†è§£ä¸ºäº’ä¸ç›¸åŒçš„ä¸å°äº 222 çš„æ•°çš„ä¹˜ç§¯çš„æ–¹æ¡ˆæ•°ã€‚ç­”æ¡ˆæ¨¡ 998244353998244353998244353ã€‚ é¢„å¤„ç†å‡º nnn çš„çº¦æ•°æ•°ç»„ dddï¼Œä»¥åŠç”¨ pos[i]pos[i]pos[i] ä»£è¡¨çº¦æ•° iii åœ¨ ddd ä¸­çš„ä½ç½®ã€‚ç”±äºçº¦æ•°å¾ˆå¤§ï¼Œæ‰€ä»¥å¦‚æœ i&gt;ni&gt;\\sqrt{n}i&gt;nâ€‹ï¼Œå°±ç”¨ nÃ·in\\div inÃ·i ä»£è¡¨å…¶ä½ç½®ã€‚è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨å°† did_idiâ€‹ æ‹†åˆ†æˆä¸å¤§äº djd_jdjâ€‹ çš„çº¦æ•°ä¸ªæ•°æ–¹æ¡ˆæ•°ï¼Œè½¬ç§»æ–¹ç¨‹ä¸éš¾å†™å‡ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cmath> using namespace std; typedef long long i64; const int MOD = 998244353; int tot, pos1[1000005], pos2[1000005], f[6721][6721]; i64 n, d[7000]; int main(void) &#123; int T; cin >> T; while (T--) &#123; tot = 0; cin >> n; int sqrtn = sqrt(n); for (i64 i = 1; i * i &lt;= n; ++i) if (n % i == 0) &#123; d[++tot] = i; if (i * i != n) d[++tot] = n / i; &#125; sort(d + 1, d + tot + 1); for (int i = 1; i &lt;= (tot + 1) / 2; ++i) pos1[d[i]] = i, pos2[d[i]] = tot - i + 1; for (int i = 1; i &lt;= tot; ++i) &#123; f[i][1] = (i == 1 ? 1 : 0); for (int j = 2; j &lt;= tot; ++j) &#123; f[i][j] = f[i][j - 1]; if (d[i] % d[j] == 0) &#123; i64 tmp = d[i] / d[j]; i64 pos = tmp &lt;= sqrtn ? pos1[tmp] : pos2[n / tmp]; f[i][j] = (f[i][j] + f[pos][j - 1]) % MOD; &#125; &#125; &#125; printf(\"%d\\n\", f[tot][tot] - 1); &#125; return 0; &#125; [CF10D] LCIS Portal. æ±‚æœ€é•¿å…¬å…±ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ï¼Œå¹¶ç»™å‡ºè§£ã€‚ æ ¹æ®ä¹‹å‰æ±‚è§£ LIS ä¸ LCS çš„ç»éªŒï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºè¿™æ ·ä¸€ä¸ªåšæ³•ï¼š è®¾ f(i,j)f(i,j)f(i,j) è¡¨ç¤º A1âˆ¼AiA_1\\sim A_iA1â€‹âˆ¼Aiâ€‹ ä¸ B1âˆ¼BjB_1\\sim B_jB1â€‹âˆ¼Bjâ€‹ çš„ LCIS é•¿åº¦ã€‚è¿™æ ·è¡Œå—ï¼Ÿä¸è¡Œï¼å› ä¸ºæˆ‘ä»¬ä¸çŸ¥é“ LCIS ç»“å°¾çš„æ•°æ˜¯ä»€ä¹ˆï¼Œæ— æ³•è½¬ç§»ï¼Œæœ‰åæ•ˆæ€§ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±è§„å®šä»¥ BjB_jBjâ€‹ ç»“å°¾ï¼ˆBjB_jBjâ€‹ ä¹Ÿç­‰äº AiA_iAiâ€‹ï¼‰ã€‚å½“ Aiâ‰ BjA_i \\ne B_jAiâ€‹î€ =Bjâ€‹ æ—¶ï¼Œæœ‰ f(i,j)=f(iâˆ’1,j)f(i,j)=f(i-1,j)f(i,j)=f(iâˆ’1,j)ï¼›å½“ Ai=BjA_i = B_jAiâ€‹=Bjâ€‹ æ—¶ï¼Œf(i,j)=maxâ¡0â‰¤k&lt;j,Bk&lt;Bj{f(iâˆ’1,k)}+1f(i,j)=\\max\\limits_{0\\le k&lt;j,B_k&lt;B_j}\\{f(i-1,k)\\}+1f(i,j)=0â‰¤k&lt;j,Bkâ€‹&lt;Bjâ€‹maxâ€‹{f(iâˆ’1,k)}+1ã€‚ä»£ç ä¾¿ä¸éš¾å†™å‡ºï¼ˆæ‰“å°è§£çš„æ–¹æ³•å°†åœ¨ä¸‹æ–‡ä»‹ç»ï¼‰ã€‚for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (a[i] == b[j]) &#123; for (int k = 0; k &lt; j; ++k) if (b[k] &lt; b[j]) f[i][j] = max(f[i][j], f[i-1][k] + 1); &#125; else f[i][j] = f[i-1][j]; è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n3)\\mathcal{O}(n^3)O(n3)ï¼Œè¶³ä»¥é€šè¿‡åŸé¢˜ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜å¯ä»¥åšå¾—æ›´å¥½ã€‚Bk&lt;BjB_k&lt;B_jBkâ€‹&lt;Bjâ€‹ ç›¸å½“äº Bk&lt;AiB_k&lt;A_iBkâ€‹&lt;Aiâ€‹ã€‚éšç€ iii çš„å¢å¤§ï¼Œkkk å¯ä»¥å–çš„å€¼åªå¤šä¸å°‘ã€‚ä¸€æ—¦æ¥äº†ä¸ªæ›´å¥½çš„å†³ç­–ï¼Œæˆ‘ä»¬åªéœ€ä¿ç•™å®ƒå³å¯ã€‚ç»¼ä¸Šï¼Œæˆ‘ä»¬åªéœ€è¦åŠ¨æ€æ›´æ–°å†³ç­–ã€‚ä»£ç å¦‚ä¸‹ï¼š for (int i = 1; i &lt;= n; ++i) &#123; int val = 0; // val ä»£è¡¨ä¹‹å‰ä»£ç ä¸­â€œf[i-1][k]â€œçš„æœ€å¤§å€¼ï¼Œä¸€å¼€å§‹ä¸º 0ï¼ˆå‰ææ˜¯åºåˆ—ä¸­çš„æ•°éƒ½æ˜¯æ­£æ•°ï¼Œå¦åˆ™å®ƒè¦ä¸º â€”INFï¼‰ if (b[0] &lt; a[i]) val = f[i-1][0]; for (int j = 1; j &lt;= m; ++j) &#123; if (a[i] == b[j]) f[i][j] = val + 1; else f[i][j] = f[i-1][j]; if (b[j] &lt; a[i]) val = max(val, f[i-1][j]); // è¿™ä¸ª j ç›¸å½“äº kï¼Œç›¸å½“äºåŸå§‹ä»£ç ä¸­çš„ f[i-1][k] &#125; &#125; ç°åœ¨çš„é—®é¢˜å°±æˆäº†å¦‚ä½•æ‰“å°è§£ï¼Œè¿™é‡Œç»™å‡º DP æ‰“å°è§£çš„ä¸€èˆ¬æ–¹å¼ï¼šè®°å½•æ¯ä¸ªçŠ¶æ€ä»å“ªé‡Œæ¥ï¼Œç„¶åç”¨é€’å½’è¾“å‡ºã€‚å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m; int a[505], b[505]; int f[505][505], g[505][505]; // g[i][j] è®°å½•é•¿åº¦ä¸º i çš„åºåˆ—é€‰å–çš„ç¬¬ j ä¸ªæ•°çš„ç¼–å·ä»å“ªä¸ªç¼–å·è½¬ç§»è¿‡æ¥ï¼ˆåœ¨ b ä¸­çš„ç¼–å·ï¼‰ void print(int s) // é€’å½’è¾“å‡º &#123; if (s == 0) return; // å›åˆ°äº† 0ï¼Œä¹Ÿå°±æ˜¯ä»€ä¹ˆéƒ½æ²¡æœ‰ print(g[n][s]); printf(\"%d \", b[s]); &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); m = read(); for (int i = 1; i &lt;= m; ++i) b[i] = read(); for (int i = 1; i &lt;= n; ++i) &#123; int t = 0; // è®°å½•æœ€åé€‰å–çš„æ•°çš„ç¼–å·ï¼ˆä¸ä¹‹å‰ä¸åŒï¼‰ for (int j = 1; j &lt;= m; ++j) &#123; if (a[i] == b[j]) &#123; f[i][j] = f[i-1][t] + 1; // å°†è¿™ä¸ªç¼–å·å¯¹åº”çš„ f[i-1][j] è¿›è¡Œè½¬ç§» g[i][j] = t; // ä» t æ¥ &#125; else &#123; f[i][j] = f[i-1][j]; g[i][j] = g[i-1][j]; // ä» g[i-1][j] å¯¹åº”çš„ç¼–å·æ¥ &#125; if (b[j] &lt; a[i]) t = j; // ç¼–å·å¯ä»¥å– j &#125; &#125; // æ³¨æ„ä»¥ä¸‹ï¼Œç”±äºçŠ¶æ€å®šä¹‰äº†ç»“å°¾ï¼Œæ‰€ä»¥è¦å–æœ€å¤§å€¼ int s = 0; for (int i = 1; i &lt;= m; ++i) if (f[n][i] > f[n][s]) s = i; printf(\"%d\\n\", f[n][s]); print(s); putchar('\\n'); return 0; &#125; [NOIP2005 æé«˜ç»„] è¿‡æ²³ Portal. å½“ LLL æ¯”è¾ƒå°ï¼Œç›´æ¥æš´åŠ› DP å³å¯ã€‚å½“ LLL æ¯”è¾ƒå¤§æ€ä¹ˆåŠå‘¢ï¼Ÿå‘ç°å…¶å® S,T,MS,T,MS,T,M éƒ½å¾ˆå°ï¼Œå®é™…ä¸Šå½“ä¸¤ä¸ªçŸ³å­çš„é—´éš”è¶…è¿‡ SÃ—TS\\times TSÃ—T ä¹‹åï¼Œéƒ½æ˜¯å¯ä»¥è·³è¿‡å»çš„ï¼Œå› æ­¤å¯ä»¥æ ¹æ®æ­¤å‹ç¼©çŠ¶æ€ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> using namespace std; int L; int S, T, M; int A[105], stone[105]; bool flag[4000005]; int f[4000005]; int main(void) &#123; memset(f, 0x7f, sizeof(f)); scanf(\"%d%d%d%d\", &amp;L, &amp;S, &amp;T, &amp;M); for (int i = 1; i &lt;= M; ++i) scanf(\"%d\", stone + i); sort(stone + 1, stone + M + 1); if (S == T) // ç‰¹åˆ¤ &#123; int ans = 0; for (int i = 1; i &lt;= M; ++i) if (stone[i] % S == 0) ++ans; printf(\"%d\\n\", ans); return 0; &#125; for (int i = 1; i &lt;= M; ++i) &#123; int d = stone[i] - stone[i - 1]; A[i] = A[i - 1] + min(d, S * T); // åœ¨ä¸Šä¸€ä¸ªçŸ³å­çš„åŸºç¡€ä¸Š flag[A[i]] = true; &#125; L = A[M] + S * T; // æœ€è¿œè·³è¿™ä¹ˆè¿œ f[0] = 0; for (int i = 1; i &lt;= L; ++i) for (int j = S; j &lt;= T; ++j) if (i >= j) f[i] = min(f[i], f[i - j] + flag[i]); int ans = 1e9; for (int i = A[M]; i &lt;= L; ++i) ans = min(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; [CF41D] Pawn Portal. ç”±äºè§„æ¨¡å¾ˆå°ï¼Œæ‰€ä»¥çŠ¶æ€å¯ä»¥è®¾è®¡çš„æš´åŠ›ä¸€ç‚¹ã€‚ä¸çŸ¥é“å€æ•°æ— æ³•è¿›è¡Œè½¬ç§»ï¼Œé‚£ä¹ˆå°±å°†å¯¹ k+1k+1k+1 å–æ¨¡åçš„ç»“æœåŠ å…¥çŠ¶æ€ã€‚ æœ¬é¢˜éœ€è¦æ‰“å°è§£ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨æ›´æ–°çš„æ—¶å€™çœ‹ä¸€ä¸‹è¿™ä¸ªçŠ¶æ€ä»å“ªé‡Œæ¥çš„å°±å¯ä»¥äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, k; char s[105]; int a[105][105]; int f[105][105][15]; char d[105][105][15]; void dfs(int x, int y, int back) &#123; if (x == n) return printf(\"%d\\n\", y), void(); if (d[x][y][back] == 'R') dfs(x + 1, y - 1, ((back - a[x][y]) % k + k) % k); else dfs(x + 1, y + 1, ((back - a[x][y]) % k + k) % k); putchar(d[x][y][back]); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); ++k; memset(f, 0xff, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", s + 1); for (int j = 1; j &lt;= m; ++j) a[i][j] = int(s[j] - '0'); &#125; for (int i = 1; i &lt;= m; ++i) f[n][i][a[n][i] % k] = a[n][i]; for (int i = n - 1; i >= 1; --i) for (int j = 1; j &lt;= m; ++j) for (int x = 0; x &lt; k; ++x) &#123; int back = ((x - a[i][j]) % k + k) % k; int &amp;dp = f[i][j][x], &amp;val = a[i][j]; #define check(x) (x != -1 &amp;&amp; x + val > dp) if (j > 1 &amp;&amp; check(f[i + 1][j - 1][back])) &#123; d[i][j][x] = 'R'; f[i][j][x] = f[i + 1][j - 1][back] + val; &#125; if (j &lt; m &amp;&amp; check(f[i + 1][j + 1][back])) &#123; d[i][j][x] = 'L'; f[i][j][x] = f[i + 1][j + 1][back] + val; &#125; &#125; int ans = -1, pos; for (int i = 1; i &lt;= m; ++i) if (f[1][i][0] > ans) ans = f[1][i][0], pos = i; printf(\"%d\\n\", ans); if (ans != -1) dfs(1, pos, 0); return 0; &#125; [UVA116] Unidirectional TSP Portal. ç”±äºéœ€è¦æ‰“å°å­—å…¸åºæœ€å°çš„è§£ï¼Œæ‰€ä»¥è®¾ f(i,j)f(i,j)f(i,j) ä»£è¡¨ä» (i,j)(i,j)(i,j) å‡ºå‘çš„æœ€å°ä»£ä»·æ¯”è¾ƒæ–¹ä¾¿ï¼ˆå­—å…¸åºæ˜¯ä»å‰å¾€åæ¯”çš„ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int m, n; int a[15][105]; int f[15][105], nxt[15][105]; int main(void) &#123; while (scanf(\"%d%d\", &amp;m, &amp;n) == 2) &#123; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[i][j]); int ans = 1e9, first; for (int j = n; j >= 1; --j) for (int i = 1; i &lt;= m; ++i) &#123; if (j == n) f[i][j] = a[i][j]; else &#123; int rows[3] = &#123;i, (i == 1 ? m : i - 1), (i == m ? 1 : i + 1)&#125;; sort(rows, rows + 3); f[i][j] = 1e9; for (int k = 0; k &lt; 3; ++k) &#123; int v = f[rows[k]][j + 1]; if (v &lt; f[i][j]) &#123; f[i][j] = v; nxt[i][j] = rows[k]; &#125; &#125; f[i][j] += a[i][j]; &#125; if (j == 1 &amp;&amp; f[i][j] &lt; ans) ans = f[first = i][j]; &#125; printf(\"%d\", first); for (int i = nxt[first][1], j = 2; j &lt;= n; i = nxt[i][j], ++j) printf(\" %d\", i); printf(\"\\n%d\\n\", ans); &#125; return 0; &#125; [UVA1625] Color Length Portal. çŠ¶æ€ç›´æ¥ f(i,j)f(i,j)f(i,j) è¡¨ç¤ºå½“å‰å–åˆ°çš„ä½ç½®ï¼Œç”¨çš„æœ€å°ä»£ä»·ã€‚ç°åœ¨å°±æ˜¯è¦ææ¸…æ¥šä»£ä»·ã€‚ä»£ä»·éœ€è¦é¢„å¤„ç†å¥½æ¯ä¸€ä¸ªå­—ç¬¦é¦–æ¬¡å‡ºç°å’Œæœ€åå‡ºç°çš„ä½ç½®ï¼Œåœ¨æ‰«æçš„æ—¶å€™ç»´æŠ¤ï¼ŒæŠŠâ€œå·²ç»å‡ºç°ä½†å°šæœªç»“æŸâ€çš„å€¼ +1ã€‚å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–ç©ºé—´ã€‚ æ‰«ææ—¶ç»´æŠ¤ä¸€ä¸ª ccc æ•°ç»„ï¼Œä»£è¡¨å½“å‰æ–°å¢çš„ä»£ä»·ã€‚æ­£å¸¸æ¥è®²æ–°å¢çš„ä»£ä»·æ˜¯ä¸å˜çš„ï¼Œå½“æœ‰æ–°çš„å­—æ¯å‡ºç°æ—¶ï¼Œä»£ä»·å°±å¢åŠ  111ï¼Œä¸€ä¸ªå­—æ¯ç»ˆç»“æ—¶ï¼Œä»£ä»·å°± âˆ’1-1âˆ’1ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int INF = 1e9; int n, m; char a[5005], b[5005]; int f[2][5005], c[2][5005]; int sa[26], sb[26], ea[26], eb[26]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s%s\", a + 1, b + 1); n = strlen(a + 1), m = strlen(b + 1); memset(sa, 0x3f, sizeof(sa)); memset(sb, 0x3f, sizeof(sb)); memset(ea, 0, sizeof(ea)); memset(eb, 0, sizeof(eb)); memset(c, 0, sizeof(c)); memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; a[i] -= 'A'; sa[a[i]] = min(sa[a[i]], i); ea[a[i]] = i; &#125; for (int i = 1; i &lt;= m; ++i) &#123; b[i] -= 'A'; sb[b[i]] = min(sb[b[i]], i); eb[b[i]] = i; &#125; int t = 0; for (int i = 0; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= m; ++j) &#123; if (!i &amp;&amp; !j) continue; f[i &amp; 1][j] = min(i ? (f[(i - 1) &amp; 1][j] + c[(i - 1) &amp; 1][j]) : INF, (j ? (f[i &amp; 1][j - 1] + c[i &amp; 1][j - 1]) : INF)); if (i) &#123; c[i &amp; 1][j] = c[(i - 1) &amp; 1][j]; if (sa[a[i]] == i &amp;&amp; sb[a[i]] > j) ++c[i &amp; 1][j]; // é¦–ä¸ª a[i] if (ea[a[i]] == i &amp;&amp; eb[a[i]] &lt;= j) --c[i &amp; 1][j]; // a[i] å®Œå…¨ç»“æŸ &#125; else if (j) &#123; c[i][j] = c[i][j - 1]; if (sb[b[j]] == j &amp;&amp; sa[b[j]] > i) ++c[i &amp; 1][j]; if (eb[b[j]] == j &amp;&amp; ea[b[j]] &lt;= i) --c[i &amp; 1][j]; &#125; &#125; &#125; printf(\"%d\\n\", f[n &amp; 1][m]); &#125; return 0; &#125; [Luogu P1412] ç»è¥ä¸å¼€å‘ Portal. æ­£åºå¾ˆéš¾åšï¼Œä½†æ˜¯å€’åºå¯ä»¥ã€‚è®¾ f(i)f(i)f(i) ä»£è¡¨ä» iii å¼€å§‹çš„æœ€å¤§æ”¶å…¥ï¼Œè½¬ç§»ä¸éš¾å†™å‡ºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, type[100005], a[100005]; double k, c, w, f[100005]; int main(void) &#123; cin >> n >> k >> c >> w; for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;type[i], &amp;a[i]); for (int i = n; i >= 1; --i) &#123; if (type[i] == 1) f[i] = max(f[i + 1], f[i + 1] * (1 - 0.01 * k) + a[i]); else f[i] = max(f[i + 1], f[i + 1] * (1 + 0.01 * c) - a[i]); &#125; printf(\"%.2lf\\n\", f[1] * w); return 0; &#125; [ZJOI2006] ç‰©æµè¿è¾“ Portal. æ³¨æ„åˆ°æ•°æ®èŒƒå›´å°çš„å“äººï¼Œæ‰€ä»¥å¯ä»¥æƒ³çš„æš´åŠ›ä¸€ç‚¹ã€‚è®¾ f(i)f(i)f(i) ä»£è¡¨å‰ iii å¤©çš„æœ€å°æˆæœ¬ï¼Œé‚£ä¹ˆè½¬ç§»çš„æ—¶å€™ç›´æ¥æš´åŠ›æšä¸¾ä»ä»€ä¹ˆæ—¶é—´å¼€å§‹èµ°åŒä¸€æ¡æœ€çŸ­è·¯ï¼ˆèµ°ä¸é€šå°±æ˜¯ INF çš„ä»£ä»·ï¼‰ã€‚æœ€çŸ­è·¯çš„å¤„ç†ç›´æ¥å¤šæ¬¡ Dijkstraã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> #define pii pair&lt;int, int> #define i64 long long using namespace std; const int INF = 0x3f3f3f3f; int n, m, k, e; int f[105]; bool ban[25][205]; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; vector &lt;edge> G[25]; bool v[25], die[25]; int d[25]; void Dijkstra(void) &#123; priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii> > q; memset(v, 0, sizeof(v)); memset(d, 0x3f, sizeof(d)); d[1] = 0; q.push(make_pair(0, 1)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!v[u]) &#123; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].to, w = G[u][i].dist; if (die[v]) continue; if (d[v] > d[u] + w) &#123; d[v] = d[u] + w; q.push(make_pair(d[v], v)); &#125; &#125; &#125; &#125; &#125; int cost[105][105]; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;e); while (e--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(edge(v, d)); G[v].push_back(edge(u, d)); &#125; int dx; scanf(\"%d\", &amp;dx); for (int i = 1; i &lt;= dx; ++i) &#123; int p, a, b; scanf(\"%d%d%d\", &amp;p, &amp;a, &amp;b); for (int j = a; j &lt;= b; ++j) ban[p][j] = true; &#125; // i åˆ° j èµ°åŒä¸€æ¡æœ€çŸ­è·¯ for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) &#123; memset(die, 0, sizeof(die)); for (int k = 1; k &lt;= m; ++k) for (int t = i; t &lt;= j; ++t) if (ban[k][t]) die[k] = true; Dijkstra(); cost[i][j] = d[m]; &#125; memset(f, 0x3f, sizeof(f)); f[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (cost[1][i] != INF) f[i] = cost[1][i] * i; else f[i] = INF; for (int j = 1; j &lt; i; ++j) if (cost[j + 1][i] != INF &amp;&amp; f[j] != INF) f[i] = min(f[i], f[j] + cost[j + 1][i] * (i - j) + k); &#125; printf(\"%d\\n\", f[n]); return 0; &#125; [HAOI2006] æ•°å­—åºåˆ— Portal.ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n(nâ‰¤3.5Ã—104)n(n\\le 3.5\\times 10^4)n(nâ‰¤3.5Ã—104) çš„æ•´æ•°åºåˆ—ï¼Œé—®å°†å®ƒæ”¹æˆä¸€ä¸ªå•è°ƒä¸¥æ ¼ä¸Šå‡åºåˆ—æœ€å°‘è¦ä¿®æ”¹å¤šå°‘æ•°ï¼Ÿå’Œåœ¨è¿™ä¸ªå‰æä¸‹æ¯ä¸ªæ•°æ”¹å˜çš„ç»å¯¹å€¼ä¹‹å’Œçš„æœ€å°å€¼ï¼Ÿ æ„é€  b[i]=a[i]âˆ’ib[i]=a[i]-ib[i]=a[i]âˆ’iï¼Œé‚£ä¹ˆè¦ä¿®æ”¹çš„æ•°å°±ç­‰äº nnn å‡å» bbb çš„æœ€é•¿ä¸é™å­åºåˆ—é•¿åº¦ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæ¯”å¦‚è¯´ï¼š4 8 8 8 7ï¼Œæƒ³ä¿ç•™ 444 å’Œ 777 æ˜¯ä¸æˆçš„ï¼Œå› ä¸º 7âˆ’4âˆ’1&lt;37-4-1&lt;37âˆ’4âˆ’1&lt;3ã€‚æ‰€ä»¥å†™ä¸€ä¸ªæ–¹ç¨‹ï¼šf(i)=maxâ¡{f(j)+1âˆ£aiâˆ’ajâ‰¥iâˆ’j}f(i)=\\max\\{f(j)+1|a_i-a_j\\ge i-j\\}f(i)=max{f(j)+1âˆ£aiâ€‹âˆ’ajâ€‹â‰¥iâˆ’j}ï¼Œå› æ­¤æ„é€  bbb æ•°ç»„ã€‚ ç›´æ¥åœ¨ bbb ä¸Šæ±‚è§£ç¬¬äºŒä½ã€‚è®¾ dp(i)dp(i)dp(i) ä»£è¡¨è€ƒè™‘åˆ° iii çš„æœ€å°ç­”æ¡ˆï¼Œæ˜¾ç„¶æœ‰ dp(i)=minâ¡{dp(j)+w(j+1,i)âˆ£f(i)=f(j)+1}dp(i)=\\min\\{dp(j)+w(j+1,i)|f(i)=f(j)+1\\}dp(i)=min{dp(j)+w(j+1,i)âˆ£f(i)=f(j)+1}ï¼Œå…¶ä¸­ w(l,r)w(l,r)w(l,r) ä»£è¡¨å°† w(l,r)w(l,r)w(l,r) æ”¹æˆåˆæ³•çš„æœ€å°ä»£ä»·ã€‚æ€ä¹ˆæ”¹ï¼Ÿæ‰¾åˆ°ä¸€ä¸ªåˆ†å‰²ç‚¹ï¼Œåˆ†å‰²ç‚¹å‰ bjb_jbjâ€‹ï¼Œåˆ†å‰²ç‚¹åå…¨éƒ¨å˜æˆ bib_ibiâ€‹ ä¸€å®šèƒ½æ‰¾åˆ°æœ€ä¼˜è§£ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> #include &lt;vector> #define int long long using namespace std; int n, ans; int a[35005], b[35005], g[35005], f[35005]; int dp[30005], sl[30005], sr[30005]; vector&lt;int> v[30005]; signed main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i] - i; memset(g, 0x3f, sizeof(g)); b[0] = -1e9; b[n + 1] = 1e9; for (int i = 1; i &lt;= n + 1; ++i) &#123; int k = upper_bound(g + 1, g + n + 1, b[i]) - g; f[i] = k, g[k] = b[i]; if (i &lt;= n) ans = max(ans, f[i]); &#125; printf(\"%d\\n\", n - ans); v[0].emplace_back(0); for (int i = 1; i &lt;= n + 1; ++i) &#123; dp[i] = 1e9; for (int j : v[f[i] - 1]) &#123; if (b[j] > b[i]) continue; sl[j] = sr[i - 1] = 0; for (int k = j + 1; k &lt;= i - 1; ++k) sl[k] = sl[k - 1] + abs(b[k] - b[j]); for (int k = i - 2; k >= j; --k) sr[k] = sr[k + 1] + abs(b[k+ 1] - b[i]); for (int k = j; k &lt;= i - 1; ++k) dp[i] = min(dp[i], dp[j] + sl[k] + sr[k]); &#125; v[f[i]].emplace_back(i); &#125; printf(\"%lld\\n\", dp[n + 1]); return 0; &#125; å°ç»“ åŠ¨æ€è§„åˆ’çš„åšæ³•éœ€è¦åœ¨å®è·µä¸­ç§¯ç´¯ç»éªŒã€‚å¯ä»¥çœ‹å‡ºï¼Œçº¿æ€§ DP çš„çŠ¶æ€è®¾è®¡å’Œè½¬ç§»å¾€å¾€éƒ½æ¯”è¾ƒæš´åŠ›ï¼Œæ²¡æœ‰å¤ªå¤šæŠ€å·§å¯è¨€ã€‚ä½†ç»†èŠ‚å¾ˆå¤šï¼Œç»¼åˆæ€§å¼ºã€‚å­¦å®Œçº¿æ€§ DP åï¼Œæ¥ä¸‹æ¥å¯ä»¥é˜…è¯»èƒŒåŒ…é—®é¢˜çš„å‰©ä½™å†…å®¹ï¼š èƒŒåŒ… DP/b2626942/","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"çº¿æ€§ DP","slug":"çº¿æ€§-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7-DP/"}]},{"title":"èƒŒåŒ…é—®é¢˜","slug":"notes/DP/pack-dp","date":"2022-07-25T00:00:00.000Z","updated":"2022-07-25T00:00:00.000Z","comments":true,"path":"b2626942/","link":"","permalink":"https://james1badcreeper.github.io/b2626942/","excerpt":"èƒŒåŒ…æ˜¯ DP ä¸­ä¸€ç±»é‡è¦è€Œç‰¹æ®Šçš„æ¨¡å‹ã€‚æœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ å„ç±»èƒŒåŒ…ã€‚","text":"èƒŒåŒ…æ˜¯ DP ä¸­ä¸€ç±»é‡è¦è€Œç‰¹æ®Šçš„æ¨¡å‹ã€‚æœ¬æ–‡å°†å¼•å¯¼ä½ å­¦ä¹ å„ç±»èƒŒåŒ…ã€‚ å…³äºèƒŒåŒ…é—®é¢˜æœ‰ä¸€ä¸ªç‰¹åˆ«è‘—åçš„è®²ä¹‰ï¼šå´”æ·»ç¿¼çš„èƒŒåŒ…ä¹è®²ã€‚æƒ³è¦å­¦å¥½æ›´å¤šå¤æ‚çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œå¯¹èƒŒåŒ…é—®é¢˜çš„æ·±å…¥ç†è§£å¿…ä¸å¯å°‘ã€‚ä½ å¯ä»¥é€‰æ‹©å°†èƒŒåŒ…ä¹è®²å’Œæœ¬æ–‡æ­é…ç€é˜…è¯»ã€‚ 01 èƒŒåŒ… è¿™ç±»é—®é¢˜çš„å½¢å¼æ˜¯ï¼š ä½ æœ‰ nnn ä¸ªç‰©å“ï¼Œè¦æŠŠå…¶ä¸­ä¸€äº›ç‰©å“è£…è¿›å®¹é‡ä¸º VVV çš„èƒŒåŒ…ï¼› ç¬¬ iii ä¸ªç‰©å“è‡ªå·±çš„ä½“ç§¯æ˜¯ viv_iviâ€‹ï¼› å¦‚æœæŠŠç¬¬ iii ä¸ªç‰©å“æ”¾è¿›èƒŒåŒ…ï¼Œä¼šè·å¾— wiw_iwiâ€‹ çš„æ”¶ç›Šï¼› è¦æ±‚åœ¨ä¸è¶…è¿‡å®¹é‡çš„æƒ…å†µä¸‹ï¼Œæœ€å¤§åŒ–æ”¶ç›Šã€‚ 01 èƒŒåŒ…å°±æ˜¯è¿™ä¸ªç‰©å“è¦ä¹ˆé€‰ï¼Œè¦ä¹ˆä¸é€‰ã€‚ è¿™æ˜¯æ¨¡æ¿ã€‚ å®ç° è¿™ä¸ªé—®é¢˜åˆå­¦è€…è¾ƒå®¹æ˜“è®¾è®¡å‡ºé”™è¯¯çš„çŠ¶æ€ï¼Œå¦‚ä¸‹ï¼š dpndp_ndpnâ€‹ è¡¨ç¤ºå‰ nnn ä¸ªç‰©å“å–å¾—çš„æœ€å¤§ä»·å€¼ã€‚ç„¶è€Œå‰é¢çš„ç‰©å“å ç”¨äº†ç©ºé—´ï¼Œæ‰€ä»¥ä¼šå½±å“æˆ‘ç°åœ¨å†³å®šèƒ½ä¸èƒ½æ”¾ç¬¬ nnn ä¸ªç‰©å“ã€‚æœ‰åæ•ˆæ€§ã€‚ dpkdp_kdpkâ€‹ è¡¨ç¤ºå ç”¨ kkk çš„ç©ºé—´å–å¾—çš„ä»·å€¼ã€‚ç„¶è€Œæ¯ä¸ªç‰©å“åªèƒ½ç”¨ä¸€æ¬¡ï¼Œå†³ç­–çš„æ—¶å€™å¿…é¡»è€ƒè™‘å“ªäº›ç‰©å“ç”¨äº†ã€å“ªäº›æ²¡ç”¨ã€‚æœ‰åæ•ˆæ€§ã€‚ é‚£ä¹ˆæˆ‘ä»¬å°±è®¾è®¡çŠ¶æ€ï¼šdp[k,m]dp[k,m]dp[k,m] è¡¨ç¤ºâ€œåªè€ƒè™‘å‰ kkk ä¸ªç‰©å“ï¼Œæ°å¥½ç”¨ mmm çš„å®¹é‡èƒ½è£…ä¸‹çš„æœ€å¤§ä»·å€¼â€ã€‚è¿™ä¸ªçŠ¶æ€æ²¡æœ‰åæ•ˆæ€§ã€‚ è½¬ç§»æ–¹ç¨‹ï¼š dp[k][m]=maxâ¡{dp[kâˆ’1][m]dp[kâˆ’1][mâˆ’vk]+wk,mâ©¾vkdp[k][m] = \\max\\begin{cases} dp[k-1][m] \\\\ dp[k-1][m-v_k]+w_k &amp; ,m \\geqslant v_k \\end{cases}dp[k][m]=max{dp[kâˆ’1][m]dp[kâˆ’1][mâˆ’vkâ€‹]+wkâ€‹â€‹,mâ©¾vkâ€‹â€‹ åˆå§‹ dp[0][0]=0dp[0][0]=0dp[0][0]=0ï¼Œç›®æ ‡ï¼ˆæ³¨æ„ç”±äºçŠ¶æ€çš„è®¾è®¡ï¼Œå¿…é¡»è¦å–æœ€å¤§å€¼ï¼Œæˆ‘ä»¬å®šä¹‰çš„æ˜¯â€æ°å¥½â€œï¼Œä¸æ˜¯â€è‡³å¤šâ€œï¼‰ï¼šmaxâ¡0â‰¤mâ‰¤Vdp[n][m]\\max\\limits_{0 \\le m \\le V}{dp[n][m]}0â‰¤mâ‰¤Vmaxâ€‹dp[n][m]ã€‚ ä¹‹æ‰€ä»¥çŠ¶æ€ä¸å®šä¹‰ä¸ºâ€œè‡³å¤šç”¨ mmm çš„å®¹é‡â€ï¼Œæ˜¯å› ä¸ºè¿™æ ·æ— æ³•ç¡®å®šè¿˜å‰©å¤šå°‘ç©ºé—´ï¼ˆä½†å®é™…ä¸Šè¿™ä¹ˆåšæ˜¯å¯è¡Œçš„ï¼Œå…·ä½“æ–¹æ³•è¯·è¯»è€…è‡ªè¡Œæ€è€ƒï¼‰ã€‚ memset(dp, 0xcf, sizeof(dp)); // -INFï¼Œå› ä¸ºè¦ææœ€å¤§å€¼ dp[0][0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= V; ++j) &#123; dp[i][j] = dp[i-1][j]; if (j >= v[i]) dp[i][j] = max(dp[i][j], dp[i-1][j-v[i]] + w[i]); &#125; &#125; int ans = -1; for (int i = 0; i &lt;= V; ++i) ans = max(ans, dp[n][i]); æ³¨æ„åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œjjj çš„å¾ªç¯æ¬¡åºæ˜¯æ— å…³ç´§è¦çš„ï¼Œè¿™ä¸ä¼šå½±å“ç»“æœã€‚ å®é™…ä¸Šï¼Œç¬”è€…ç›®å‰æ²¡æœ‰æ‰¾åˆ°ä»»ä½•èƒ½è¯æ˜ä¸ç”¨å–æœ€å¤§å€¼æ˜¯é”™è¯¯çš„åä¾‹ï¼Œä¹Ÿè®¸è¿™æ ·çš„åä¾‹æ ¹æœ¬ä¸å­˜åœ¨ï¼Œå› ä¸ºåœ¨æ›´æ–°æ—¶ï¼Œç”±äºä½“ç§¯æ›´å¤§ï¼Œè‚¯å®šèƒ½æˆåŠŸæ›´æ–°ã€‚å®é™…ä¸Šè¿™ä¸ªä»£ç å®ç°æ˜¯å°†é‚£äº›ç”¨ä¸æ‰çš„ä½“ç§¯å¡«è¿›å»äº†ç©ºæ°”ï¼Œä¾‹å¦‚æˆ‘ä»¬çœ‹è¿™æ ·ä¸€ç»„æ•°æ®ï¼š n &#x3D; 2, V &#x3D; 4 ç‰©å“ A: v &#x3D; 3, w &#x3D; 10 ç‰©å“ B: v &#x3D; 4, w &#x3D; 1 å®ƒçš„ DP æ•°ç»„é•¿è¿™æ ·ï¼š j&#x3D; 0 1 2 3 4 i &#x3D; 1: 0 0 0 10 10 i &#x3D; 2: 0 0 0 10 10 è¿™ä¸ª dp[1][4] = 10 ä»å“ªæ¥çš„ï¼Ÿæ˜¾ç„¶ï¼Œå®ƒæ˜¯ä» dp[1][1] æ›´æ–°æ¥çš„ï¼Œæˆ‘ä»¬å¡«è¿›å»äº†ä½“ç§¯ä¸º 111 çš„ç©ºæ°”ã€‚ ä½†è€ƒè™‘åˆ°å®é™…ä¸­æ˜¯ä¸åœ¨æ„è¿™ç‚¹æ—¶é—´ï¼ˆå–æœ€å¤§å€¼æ‰çº¿æ€§ï¼‰ï¼Œä¸”ä¸¥æ ¼ç¬¦åˆçŠ¶æ€è½¬ç§»çš„è¿‡ç¨‹ï¼Œå¼ºçƒˆå»ºè®®å–æœ€å¤§å€¼ã€‚æ¥ä¸‹æ¥çš„å±€éƒ¨ä»£ç ä¸ºäº†ä¸å½±å“é˜…è¯»å‡ä¸ä¼šå–æœ€å¤§å€¼ï¼Œä½†æ˜¯å®Œæ•´é¢˜ç›®çš„ä»£ç å‡ä¼šå–æœ€å¤§å€¼ã€‚ æ»šåŠ¨æ•°ç»„ æ›´å¥‡å¦™çš„æ˜¯ï¼Œè¿˜å¯ä»¥æŠŠ dpdpdp æ•°ç»„å˜æˆä¸€ç»´çš„ã€‚ for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;v, &amp;w); for (int j = V; j >= v; --j) dp[j] = max(dp[j], dp[j-v] + w); &#125; ä¸ºä»€ä¹ˆè¿™æ ·æ˜¯å¯¹çš„ï¼Ÿåœ¨è®¡ç®— dp(i,j)dp(i,j)dp(i,j) å‰ï¼Œdp[j]dp[j]dp[j] é‡Œä¿å­˜çš„æ˜¯ dp(iâˆ’1,j)dp(i-1,j)dp(iâˆ’1,j)ï¼Œè€Œ dp[jâˆ’v]dp[j-v]dp[jâˆ’v] ä¿å­˜çš„æ˜¯ dp(iâˆ’1,jâˆ’v)dp(i-1,j-v)dp(iâˆ’1,jâˆ’v)ï¼ˆæ³¨æ„ jjj çš„å¾ªç¯æ¬¡åºï¼‰ï¼Œç„¶å dp[j]dp[j]dp[j] å¯ä»¥é¡ºåˆ©æ›´æ–°æˆ dp(i,j)dp(i,j)dp(i,j) çš„å†…å®¹ï¼Œè¦†ç›–æ‰çš„å†…å®¹å†ä¹Ÿä¸ä¼šä½¿ç”¨ï¼Œå€’åºçš„å¾ªç¯é¡ºåºå¯ä»¥ä½¿å¾—è®¡ç®— dp(i,j)dp(i,j)dp(i,j) æ—¶ dp(i,jâˆ’v)dp(i,j-v)dp(i,jâˆ’v) è¿˜æœªè¢«è®¡ç®—ï¼Œä¿å­˜çš„æ˜¯ dp(iâˆ’1,jâˆ’v)dp(i-1,j-v)dp(iâˆ’1,jâˆ’v)ã€‚æ‰€ä»¥è¿™æ ·æ˜¯å¯ä»¥çš„ï¼ ä¸€ä¸ª DP å¯ä»¥é€šè¿‡æ»šåŠ¨æ•°ç»„æ¥ä¼˜åŒ–ï¼Œå½“ä¸”ä»…å½“å…¶çŠ¶æ€å›¾æ˜¯åˆ†å±‚çš„ï¼Œä¸‹ kkk å±‚çš„ç»“æœï¼Œç”±ä¸Š ddd å±‚ç»“æœå”¯ä¸€ç¡®å®šã€‚ åœ¨ 01 èƒŒåŒ…ä¸­ï¼Œç¬¬ iii å±‚çš„ç»“æœç”±ç¬¬ iâˆ’1i-1iâˆ’1 å±‚å”¯ä¸€ç¡®å®šï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ã€‚è€Œä¸”ç”±äºé¡ºåºçš„ç‰¹æ®Šæ€§ï¼Œæ‰€ä»¥åªç”¨äº†ä¸€ç»´ã€‚ ä½†æ˜¯å¦‚æœæ²¡æœ‰è¿™ç§ç‰¹æ®Šæ€§æ€ä¹ˆåŠï¼Ÿå¾ˆç®€å•ï¼š int dp[2][MAXV]; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= V; ++j) &#123; dp[i &amp; 1][j] = dp[(i-1) &amp; 1][j]; if (j >= v[i]) dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[(i-1) &amp; 1][j-v[i]] + w[i]); &#125; &#125; çœ‹åˆ°äº†å—ï¼Ÿè¿™æ ·å°±ä¸å¾ªç¯é¡ºåºæ²¡æœ‰å…³ç³»äº†ï¼Œè®© DP åœ¨ä¸¤ç»´ä¸­äº¤æ›¿è¿›è¡Œã€‚ è§£çš„æ‰“å° ä½¿ç”¨æ»šåŠ¨æ•°ç»„åï¼Œè§£çš„æ‰“å°å‡ ä¹å˜æˆå¤©æ–¹å¤œè°­äº†ã€‚äº‹å®ä¸Šå³ä½¿ä¸ç”¨æ»šåŠ¨æ•°ç»„ï¼Œæƒ³æ‰“å°è§£è¿˜æ˜¯å¾ˆå›°éš¾ï¼ˆè¯•ä¸€è¯•ä¼šå‘ç°æ— æ³•æ‰“å°å­—å…¸åºæœ€å¤§çš„è§£ï¼‰ï¼Œæ­¤æ—¶åº”è¯¥ä½¿ç”¨ dp[k,m]dp[k,m]dp[k,m] è¡¨ç¤ºâ€œåªè€ƒè™‘å kkk ä¸ªç‰©å“ï¼Œæ°å¥½ç”¨ mmm çš„å®¹é‡èƒ½è£…ä¸‹çš„æœ€å¤§ä»·å€¼â€ã€‚æ–¹æ³•ç›¸åŒï¼Œæ‰“å°æ—¶ä½¿ç”¨å›æº¯æ³•æ‰“å°å³å¯ã€‚å®é™…ä¸Šè¦æ±‚è¾“å‡ºè§£çš„èƒŒåŒ…é—®é¢˜å¾ˆå°‘ï¼Œä½†ä¸ºäº†é˜²ä½æ¯’ç˜¤å¯ä»¥è€ƒè™‘å­¦ä¹ ã€‚ å®Œå…¨èƒŒåŒ… è¿™ç±»é—®é¢˜çš„å½¢å¼æ˜¯ï¼š ä½ æœ‰ nnn ç§ç‰©å“ï¼Œæ¯ç§æœ‰æ— é™å¤šï¼Œè¦æŠŠå…¶ä¸­ä¸€äº›ç‰©å“è£…è¿›å®¹é‡ä¸º VVV çš„èƒŒåŒ…ï¼› ç¬¬ iii ç§ç‰©å“è‡ªå·±çš„ä½“ç§¯æ˜¯ viv_iviâ€‹ï¼› å¦‚æœæŠŠç¬¬ iii ä¸ªç‰©å“æ”¾è¿›èƒŒåŒ…ï¼Œä¼šè·å¾— wiw_iwiâ€‹ çš„æ”¶ç›Šï¼› è¦æ±‚åœ¨ä¸è¶…è¿‡å®¹é‡çš„æƒ…å†µä¸‹ï¼Œæœ€å¤§åŒ–æ”¶ç›Šã€‚ è¿™æ˜¯æ¨¡æ¿ã€‚ æ ¹æ®ç»éªŒï¼Œè®¾ f[i,j]f[i,j]f[i,j] è¡¨ç¤ºé€‰å‰ iii ç§ç‰©å“ï¼Œä½“ç§¯ä¸º jjjï¼Œç‰©å“æœ€å¤§ä»·å€¼ï¼Œåˆ™æœ‰ï¼š f[i,j]=maxâ¡{f[iâˆ’1,j]f[i,jâˆ’vi]+wi,jâ©¾vif[i,j] = \\max\\begin{cases} f[i-1,j] \\\\ f[i,j-v_i]+w_i &amp;, j \\geqslant v_i \\end{cases}f[i,j]=max{f[iâˆ’1,j]f[i,jâˆ’viâ€‹]+wiâ€‹â€‹,jâ©¾viâ€‹â€‹ åˆå§‹ f[0][0]=0f[0][0]=0f[0][0]=0ï¼Œç›®æ ‡ï¼šmaxâ¡0â©½mâ©½Vf[n][m]\\max\\limits_{0 \\leqslant m \\leqslant V}{f[n][m]}0â©½mâ©½Vmaxâ€‹f[n][m]ã€‚ ä»£ç å¦‚ä¸‹ï¼š for (int i = 1; i &lt;= n; ++i) &#123; int v = read(), w = read(); for (int j = 0; j &lt;= V; ++j) f[i][j] = f[i-1][j]; // è¿™æ˜¯å¦ä¸€ç§åˆå§‹åŒ–çš„å†™æ³•ï¼Œä»£ç è¾ƒé•¿ä½†æ˜¯æ•ˆç‡è¾ƒé«˜ for (int j = v; j &lt;= V; ++j) f[i][j] = max(f[i][j], f[i][j-v] + w); &#125; è¿˜æ˜¯è®¡ç®—é¡ºåºçš„åŸå› ï¼Œåœ¨è®¡ç®— f(i,j)f(i,j)f(i,j) æ—¶ï¼Œf[j]f[j]f[j] ä¿å­˜çš„æ˜¯ f(iâˆ’1,j)f(i-1,j)f(iâˆ’1,j)ï¼Œè€Œ f[jâˆ’v]f[j-v]f[jâˆ’v] ä¿å­˜çš„æ˜¯ f(i,jâˆ’v)f(i, j-v)f(i,jâˆ’v)ï¼Œè®¡ç®— f(i,j)f(i,j)f(i,j) æ—¶ï¼Œf(i,jâˆ’v)f(i,j-v)f(i,jâˆ’v) å·²ç»è®¡ç®—å®Œæ¯•ã€‚æ»šåŠ¨æ•°ç»„ä»£ç å¦‚ä¸‹ï¼š for (int i = 1; i &lt;= m; ++i) &#123; int v = read(), w = read(); for (int j = v; j &lt;= V; ++j) f[j] = max(f[j], f[j-v] +w); &#125; å¤šé‡èƒŒåŒ… è¿™ç±»é—®é¢˜çš„å½¢å¼æ˜¯ï¼š ä½ æœ‰ nnn ç§ç‰©å“ï¼Œæ¯ç§æœ‰ CiC_iCiâ€‹ ä¸ªï¼Œè¦æŠŠå…¶ä¸­ä¸€äº›ç‰©å“è£…è¿›å®¹é‡ä¸º VVV çš„èƒŒåŒ…ï¼› ç¬¬ iii ç§ç‰©å“è‡ªå·±çš„ä½“ç§¯æ˜¯ viv_iviâ€‹ï¼› å¦‚æœæŠŠç¬¬ iii ä¸ªç‰©å“æ”¾è¿›èƒŒåŒ…ï¼Œä¼šè·å¾— wiw_iwiâ€‹ çš„æ”¶ç›Šï¼› è¦æ±‚åœ¨ä¸è¶…è¿‡å®¹é‡çš„æƒ…å†µä¸‹ï¼Œæœ€å¤§åŒ–æ”¶ç›Šã€‚ å¦‚æœæˆ‘ä»¬æŠŠæ¯ç§ç‰©å“éƒ½æ‹†æˆ MiM_iMiâ€‹ ä¸ªç‰©å“ï¼Œè¿™å‡ ä¹å°±è·Ÿ 01 èƒŒåŒ…ä¸€æ¨¡ä¸€æ ·äº†ã€‚ä½†é—æ†¾çš„æ˜¯ï¼Œè¿™æ ·åšå¾ˆæ…¢ï¼Œæ—¶é—´å¤æ‚åº¦é«˜è¾¾ O(Vâˆ‘Mi)\\mathcal{O}(V\\sum M_i)O(Vâˆ‘Miâ€‹)ã€‚ é¢å¯¹è¿™ä¸€æƒ…å†µæœ‰ä¸¤ç§åšæ³•ï¼šäºŒè¿›åˆ¶æ‹†åˆ†æ³•å’Œå•è°ƒé˜Ÿåˆ—ä¼˜åŒ–æ³•ï¼Œæ—¶é—´å¤æ‚åº¦åˆ†åˆ«ä¸º O(Vâˆ‘logâ¡Mi)\\mathcal{O}(V\\sum \\log M_i)O(Vâˆ‘logMiâ€‹) å’Œ O(VN)\\mathcal{O}(VN)O(VN)ã€‚å…¶ä¸­å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–æ³•æˆ‘ä»¬ä¼šåœ¨åç»­çš„åŠ¨æ€è§„åˆ’æ•™ç¨‹ä¸­è¿›è¡Œè®¨è®ºï¼Œä¹Ÿå¯ä»¥é˜…è¯»èƒŒåŒ…ä¹è®²æ¥å­¦ä¹ ã€‚ äºŒè¿›åˆ¶æ‹†åˆ†æ³•åŸºäºè¿™æ ·ä¸€ä¸ªäº‹å®ï¼šä» 20,21,22,â‹¯ ,2kâˆ’12^0,2^1,2^2,\\cdots,2^{k-1}20,21,22,â‹¯,2kâˆ’1 è¿™ kkk ä¸ªæ•´æ•°ä¸­é€‰å‡ºè‹¥å¹²ä¸ªç›¸åŠ ï¼Œå¯ä»¥å¾—åˆ° 0âˆ¼2kâˆ’10\\sim 2^{k}-10âˆ¼2kâˆ’1 ä¹‹é—´çš„æ‰€æœ‰æ•°ã€‚ä¸ºä»€ä¹ˆï¼Ÿæƒ³ä¸€æƒ³è®¡ç®—æœºæ˜¯æ€ä¹ˆç”¨äºŒè¿›åˆ¶è¡¨ç¤ºæ•°çš„å§ï¼ è¿›ä¸€æ­¥åœ°ï¼Œæˆ‘ä»¬å¯ä»¥æ±‚å‡ºæ»¡è¶³ âˆ‘i=0p2iâ©½Ci\\sum\\limits_{i=0}^{p}2^i\\leqslant C_ii=0âˆ‘pâ€‹2iâ©½Ciâ€‹ çš„æœ€å¤§æ•´æ•° pppï¼Œè®¾ Ri=Ciâˆ’âˆ‘i=0p2iR_i=C_i-\\sum\\limits_{i=0}^{p}2^iRiâ€‹=Ciâ€‹âˆ’i=0âˆ‘pâ€‹2iï¼Œé‚£ä¹ˆï¼š æ ¹æ® ppp çš„æœ€å¤§æ€§ï¼Œæœ‰ âˆ‘i=0p+12i&gt;Ci\\sum\\limits_{i=0}^{p+1}2^i &gt; C_ii=0âˆ‘p+1â€‹2i&gt;Ciâ€‹ï¼Œå°† Ri+âˆ‘i=0p2i=CiR_i+\\sum\\limits_{i=0}^{p}2^i=C_iRiâ€‹+i=0âˆ‘pâ€‹2i=Ciâ€‹ ä»£å…¥å¾— âˆ‘i=0p+12i&gt;Ri+âˆ‘i=0p2i\\sum\\limits_{i=0}^{p+1}2^i &gt; R_i+\\sum\\limits_{i=0}^{p}2^ii=0âˆ‘p+1â€‹2i&gt;Riâ€‹+i=0âˆ‘pâ€‹2iï¼Œå¯æ¨å‡º 2p+1&gt;Ri2^{p+1} &gt; R_i2p+1&gt;Riâ€‹ï¼ˆä¸¤è¾¹åŒæ—¶å‡å» âˆ‘i=0p2i\\sum\\limits_{i=0}^{p}2^ii=0âˆ‘pâ€‹2iï¼‰ï¼Œæ‰€ä»¥ 2p+1âˆ’1â‰¥Ri2^{p+1}-1 \\ge R_i2p+1âˆ’1â‰¥Riâ€‹ï¼Œå› æ­¤ä» 20,21,22,â‹¯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,â‹¯,2p ä¸­é€‰å‡ºè‹¥å¹²ä¸ªç›¸åŠ å¯ä»¥å¾—åˆ° 0âˆ¼Ri0\\sim R_i0âˆ¼Riâ€‹ ä¹‹é—´çš„ä»»ä½•æ•´æ•°ï¼ˆå®é™…ä¸Šæ˜¯å¯ä»¥å¾—åˆ° 0âˆ¼2p+1âˆ’10\\sim 2^{p+1}-10âˆ¼2p+1âˆ’1 ä¹‹é—´çš„ä»»æ„æ•´æ•°ï¼‰ã€‚ ä» 20,21,22,â‹¯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,â‹¯,2p ä»¥åŠ RiR_iRiâ€‹ ä¸­é€‰æ‹©è‹¥å¹²ä¸ªæ•°ç›¸åŠ ï¼ˆæ³¨æ„å¤šäº†ä¸ª RiR_iRiâ€‹ï¼‰ï¼Œå¯ä»¥å¾—åˆ° Riâˆ¼Ri+2p+1âˆ’1R_i\\sim R_i + 2^{p+1}-1Riâ€‹âˆ¼Riâ€‹+2p+1âˆ’1 ä¹‹é—´çš„ä»»ä½•æ•´æ•°ï¼ˆå°±æ˜¯æŠŠ 111 ä¸­æœ€åçš„ç»“è®ºç”¨ä¸ç­‰å¼æ€§è´¨ä¸€å˜å½¢ï¼‰ï¼Œè€Œç”±äº RiR_iRiâ€‹ çš„å®šä¹‰ï¼ŒåŠ ä¸Šæ•°å­¦ç»“è®º âˆ‘i=0p2i=2p+1âˆ’1\\sum\\limits_{i=0}^{p}2^i=2^{p+1}-1i=0âˆ‘pâ€‹2i=2p+1âˆ’1ï¼Œå¯å¾—åˆ° Ri+2p+1âˆ’1=Ri=Ciâˆ’âˆ‘i=0p2i+âˆ‘i=0p2i+1âˆ’1=CiR_i+2^{p+1}-1=R_i=C_i-\\sum\\limits_{i=0}^{p}2^i+\\sum\\limits_{i=0}^{p}2^i+1-1=C_iRiâ€‹+2p+1âˆ’1=Riâ€‹=Ciâ€‹âˆ’i=0âˆ‘pâ€‹2i+i=0âˆ‘pâ€‹2i+1âˆ’1=Ciâ€‹ï¼Œæ‰€ä»¥ç­‰é‡ä»£æ¢åå¯ä»¥è¯æ˜ä» 20,21,22,â‹¯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,â‹¯,2p ä»¥åŠ RiR_iRiâ€‹ ä¸­é€‰æ‹©è‹¥å¹²ä¸ªæ•°ç›¸åŠ ï¼Œå¯ä»¥å¾—åˆ° Riâˆ¼CiR_i\\sim C_iRiâ€‹âˆ¼Ciâ€‹ ä¹‹é—´çš„ä»»ä½•æ•´æ•°ã€‚è€Œåˆæœ‰ä» 20,21,22,â‹¯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,â‹¯,2p ä¸­é€‰å‡ºè‹¥å¹²ä¸ªç›¸åŠ å¯ä»¥å¾—åˆ° 0âˆ¼Ri0\\sim R_i0âˆ¼Riâ€‹ ä¹‹é—´çš„ä»»ä½•æ•´æ•°ï¼Œå› æ­¤ä» 20,21,22,â‹¯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,â‹¯,2p ä»¥åŠ RiR_iRiâ€‹ ä¸­é€‰æ‹©è‹¥å¹²ä¸ªæ•°ç›¸åŠ ï¼Œå¯ä»¥å¾—åˆ° 0âˆ¼Ci0\\sim C_i0âˆ¼Ciâ€‹ ä¹‹é—´çš„ä»»ä½•æ•´æ•°ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠæ•°é‡ä¸º CiC_iCiâ€‹ çš„ç¬¬ iii ç§ç‰©å“æ‹†æˆ p+2p+2p+2 ä¸ªç‰©å“ï¼Œä½“ç§¯ä¸º 20Ã—Vi,21Ã—Vi,â‹¯ ,2pÃ—Vi,RiÃ—Vi2^0\\times V_i, 2^1\\times V_i,\\cdots,2^p\\times V_i,R_i\\times V_i20Ã—Viâ€‹,21Ã—Viâ€‹,â‹¯,2pÃ—Viâ€‹,Riâ€‹Ã—Viâ€‹ï¼Œå®ƒä»¬å¯ä»¥å‡‘æˆ 0âˆ¼CiÃ—Vi0\\sim C_i\\times V_i0âˆ¼Ciâ€‹Ã—Viâ€‹ ä¹‹é—´æ‰€æœ‰èƒ½è¢« ViV_iViâ€‹ æ•´é™¤çš„æ•°ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  // æ³¨ï¼šæˆ‘ä»¬é€šå¸¸ç”¨ v ä»£è¡¨ä½“ç§¯ï¼Œw ä»£è¡¨ä»·å€¼ï¼Œä½†æ˜¯æ­¤é¢˜ä¸­æ˜¯åçš„ã€‚ç¬”è€…åœ¨ç¼–ç æ—¶éµç…§çš„æ—¶å¸¸è§„è€Œä¸æ˜¯åŸé¢˜ã€‚ #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, V; int f[40005]; struct BadCreeper // ( &#123; int v, w; BadCreeper(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; int main(void) &#123; n = read(), V = read(); for (int i = 1; i &lt;= n; ++i) &#123; int w = read(), v = read(), m = read(), c = 1; vector &lt;BadCreeper> a; while (m - c >= 0) &#123; m -= c; a.push_back(BadCreeper(c * v, c * w)); c &lt;&lt;= 1; &#125; if (m != 0) a.push_back(BadCreeper(m * v, m * w)); // R = 0ï¼Œæ²¡å¿…è¦æ·»åŠ  for (int j = 0; j &lt; a.size(); ++j) // æšä¸¾ç‰©å“ for (int k = V; k >= a[j].v; --k) // 01 è½¬ç§» f[k] = max(f[k], f[k - a[j].v] + a[j].w); &#125; int ans = -1; for (int i = 0; i &lt;= V; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; æ··åˆèƒŒåŒ… å…¶å®å°±æ˜¯å°†å‰é¢ä¸‰ç§èƒŒåŒ…æ··èµ·æ¥ä¸€èµ·ä¹±ç‚–ï¼Œæœ‰çš„ç‰©å“åªèƒ½å– 111 æ¬¡ï¼Œæœ‰çš„èƒ½å– kkk æ¬¡ï¼Œæœ‰çš„èƒ½å–æ— é™æ¬¡ã€‚è¿™æ€ä¹ˆåŠï¼Ÿä¸€ç§æ–¹æ³•æ˜¯å°†æ— é™æ¬¡åŒ–ä¸ºæœ€å¤šèƒ½å–å¾—æ¬¡æ•°ï¼Œè¿™æ ·å°±è½¬åŒ–æˆå¤šé‡èƒŒåŒ…äº†ã€‚ä½†å®é™…ä¸Šæ²¡å¿…è¦ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­æ¯ç§æƒ…å†µï¼Œç„¶åå¥—ç”¨ä¸åŒç§èƒŒåŒ…å¯¹åº”çš„å¾ªç¯å³å¯ã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  // æ³¨ï¼šæ­¤ä»£ç ç¼–å†™æ—¶ä»æŒ‰ç…§æ ‡å‡†èƒŒåŒ…çš„å®šä¹‰ #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #include &lt;vector> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, V; inline int calc(string s) &#123; pii res; bool flag = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (s[i] == ':') &#123; flag = 1; continue; &#125; if (flag) res.Y = res.Y * 10 + (s[i] - '0'); else res.X = res.X * 10 + (s[i] - '0'); &#125; return res.X * 60 + res.Y; &#125; int f[1005]; int main(void) &#123; string B, E; cin >> B >> E; V = calc(E) - calc(B); n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int v = read(), w = read(), p = read(); if (p == 0) &#123; for (int j = v; j &lt;= V; ++j) f[j] = max(f[j], f[j - v] + w); &#125; else // ä½ ä¹Ÿå¯ä»¥æŠŠ 01 èƒŒåŒ…çš„æƒ…å†µå•ç‹¬æ‰”å‡ºæ¥ï¼Œä¸è¿‡æ²¡å¿…è¦ &#123; vector &lt;pii> a; int s = 1; while (p > s) &#123; p -= s; a.push_back(make_pair(v * s, w * s)); s &lt;&lt;= 1; &#125; a.push_back(make_pair(v * p, w * p)); for (int j = 0; j &lt; a.size(); ++j) for (int k = V; k >= a[j].X; --k) f[k] = max(f[k], f[k - a[j].X] + a[j].Y); &#125; &#125; int ans = 0; for (int i = 0; i &lt;= V; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; äºŒç»´è´¹ç”¨èƒŒåŒ… äºŒä½è´¹ç”¨èƒŒåŒ…æ˜¯ä¸€ç±»ä¸€ä¸ªç‰©å“ä¼šæ¶ˆè€—ä¸¤ç§ä»·å€¼ï¼ˆæ¯”å¦‚æ±½æ°´å°±æ˜¯ä¸€ç§æ¶ˆè€—é‡‘é’±å’Œå¯¿å‘½çš„ä¸œè¥¿ï¼‰ã€‚ è®¾ f(i,u,v)f(i,u,v)f(i,u,v) è¡¨ç¤ºåªè€ƒè™‘å‰ iii ç“¶æ±½æ°´ï¼Œæ¶ˆè€—çš„é‡‘é’±æ°å¥½ä¸º uuuï¼Œæ¶ˆè€—çš„é˜³å¯¿æ°å¥½ä¸º vvvï¼Œè·å¾—çš„è„‚è‚ªæ˜¯ www ï¼Œé‚£ä¹ˆè½¬ç§»æ–¹ç¨‹ä¾¿æ˜¯ï¼š f(i,u,v)=maxâ¡{f(iâˆ’1,u,v)f(iâˆ’1,uâˆ’ui,vâˆ’vi)+w,uâ©¾ui,vâ©¾vif(i,u,v) = \\max\\begin{cases} f(i-1,u,v) \\\\ f(i-1,u-u_i,v-v_i)+w &amp; ,u \\geqslant u_i, v \\geqslant v_i \\end{cases}f(i,u,v)=max{f(iâˆ’1,u,v)f(iâˆ’1,uâˆ’uiâ€‹,vâˆ’viâ€‹)+wâ€‹,uâ©¾uiâ€‹,vâ©¾viâ€‹â€‹ åŒæ ·å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–ç©ºé—´ï¼ˆåªæœ‰ç¬¬ä¸€ç»´æ˜¯é˜¶æ®µï¼Œå‰©ä¸‹çš„æ˜¯çŠ¶æ€ï¼Œä¸èƒ½æ»šï¼‰ï¼Œæ³¨æ„ç›¸åº”çš„å¾ªç¯é¡ºåºã€‚ æ¨¡æ¿ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, M, T; int f[205][205]; int main(void) &#123; n = read(), M = read(), T = read(); for (int i = 1; i &lt;= n; ++i) &#123; int m = read(), t = read(); for (int j = M; j >= m; --j) for (int k = T; k >= t; --k) f[j][k] = max(f[j][k], f[j-m][k-t] + 1); // æ¯ä¸ªæ„¿æœ›å¸¦æ¥çš„ä»·å€¼éƒ½æ˜¯ç›¸ç­‰çš„ï¼Œéƒ½æ˜¯å•ä½ 1 &#125; int ans = 0; for (int i = 0; i &lt;= M; ++i) for (int j = 0; j &lt;= T; ++j) ans = max(ans, f[i][j]); cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; ä¹Ÿå¾ˆå®¹æ˜“è½¬åŒ–åˆ°äºŒç»´å®Œå…¨èƒŒåŒ…ã€å¤šé‡èƒŒåŒ…ç­‰é—®é¢˜ï¼Œè¿™é‡Œä¸åšèµ˜è¿°ã€‚ åˆ†ç»„èƒŒåŒ… è¿™ç±»é—®é¢˜è·Ÿ 01 èƒŒåŒ…çš„æœ¬è´¨åŒºåˆ«æ˜¯ï¼šç‰©å“å¯ä»¥åˆ†ä¸º kkk ç»„ï¼Œæ¯ç»„ä¸­çš„ç‰©å“ç›¸äº’å†²çªï¼Œå³æ¯ç»„ä¸­æœ€å¤šåªèƒ½é€‰ä¸€ä¸ªç‰©å“ã€‚é—®æœ€å¤§ä»·å€¼ã€‚æ¨¡æ¿ã€‚ è®¾ f(i,j)f(i,j)f(i,j) è¡¨ç¤ºåœ¨å‰ iii ç»„ä¸­é€‰å‡ºæ€»ä½“ç§¯ä¸º jjj çš„ç‰©å“æ”¾å…¥èƒŒåŒ…ï¼Œç‰©å“çš„æœ€å¤§ä»·å€¼å’Œã€‚é‚£ä¹ˆï¼š f(i,j)=maxâ¡{f(iâˆ’1,j)maxâ¡1â©½kâ©½Cif(iâˆ’1,jâˆ’v(i,k))+w(i,k),jâ©¾v(i,k)f(i,j) = \\max\\begin{cases} f(i-1,j) \\\\ \\max\\limits_{1\\leqslant k \\leqslant C_i} f(i-1,j-v_{(i,k)})+w_{(i,k)} &amp; , j \\geqslant v_{(i,k)} \\end{cases}f(i,j)=max{f(iâˆ’1,j)1â©½kâ©½Ciâ€‹maxâ€‹f(iâˆ’1,jâˆ’v(i,k)â€‹)+w(i,k)â€‹â€‹,jâ©¾v(i,k)â€‹â€‹ åŒæ ·å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„æ»šæ‰ç¬¬ä¸€ç»´ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, V, f[1005]; vector &lt;pii> a[1005]; int main(void) &#123; V = read(), n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int v = read(), w = read(), c = read(); a[c].push_back(make_pair(v, w)); &#125; for (int i = 0; i &lt; 1000; ++i) &#123; if (a[i].size() == 0) continue; // è¿™ç»„æ²¡æœ‰ä¸œè¥¿å°±ä¸ç®—äº† for (int j = V; j >= 0; --j) for (int k = 0; k &lt; a[i].size(); ++k) // å†³ç­– if (j >= a[i][k].X) f[j] = max(f[j], f[j - a[i][k].X] + a[i][k].Y); &#125; int ans = 0; for (int i = 0; i &lt;= V; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; æ³¨æ„å¾ªç¯é¡ºåºï¼Œå› ä¸º i,j æ˜¯çŠ¶æ€ï¼Œk æ˜¯å†³ç­–ï¼Œé¡ºåºä¸èƒ½æ··æ·†ã€‚ ä¾èµ–æ€§èƒŒåŒ… è¿™ç±»é—®é¢˜é•¿è¿™æ ·ï¼šåœ¨ 01 èƒŒåŒ…çš„åŸºç¡€ä¸Šï¼ŒæŸäº›ç‰©å“ä¾èµ–äºä¸€ä¸ªä¸»ç‰©å“ï¼Œæ¯”å¦‚ä½ æƒ³è´­ä¹° Minecraft Java Editionï¼Œä½ å°±éœ€è¦æ³¨å†Œ Microsoft è´¦å·ï¼Œå¦åˆ™æ˜¯ä¸èƒ½è´­ä¹° Minecraft Java Edition çš„ã€‚ è¿™é‡Œæˆ‘ä»¬è®¨è®ºåŸºç¡€çš„ä¾èµ–æ€§èƒŒåŒ…ï¼Œè§æ¨¡æ¿ã€‚ æˆ‘ä»¬å¯¹è¿™ä¸ªé¢˜åšä¸€ä¸ªæ‰©å±•ï¼šæ¯ä¸ªä¸»ä»¶å¯ä»¥æ‹¥æœ‰æ— é™ä¸ªé™„ä»¶ï¼Œè¿™æ€ä¹ˆåŠå‘¢ï¼Ÿå¯ä»¥å°†æ¯ä¸ªä¸»ä»¶å’Œå®ƒçš„é™„ä»¶ä½œä¸ºåˆ†ç»„èƒŒåŒ…ä¸­çš„ä¸€ä¸ªç»„ï¼Œæƒ³è¦å¯¹è¿™ä¸ªç»„è¿›è¡ŒèƒŒåŒ…é—®é¢˜çš„æ±‚è§£ï¼Œå°±å¿…é¡»é€‰æ‹©ä¸»ä»¶ã€‚å¯¹äºåŒ…å«ä¸€ä¸ªä¸»ä»¶å’Œè‹¥å¹²ä¸ªé™„ä»¶çš„é›†åˆæœ‰ä»¥ä¸‹å¯èƒ½æ€§ï¼šä»…é€‰æ‹©ä¸»ä»¶ï¼Œé€‰æ‹©ä¸»ä»¶åå†é€‰æ‹©ä¸€ä¸ªé™„ä»¶ï¼Œé€‰æ‹©ä¸»ä»¶åå†é€‰æ‹©ä¸¤ä¸ªé™„ä»¶â€¦â€¦éœ€è¦å°†ä»¥ä¸Šå¯èƒ½æ€§çš„å®¹é‡å’Œä»·å€¼è½¬æ¢æˆä¸€ä»¶ä»¶ç‰©å“ã€‚å› ä¸ºè¿™å‡ ç§å¯èƒ½æ€§åªèƒ½é€‰ä¸€ç§ï¼Œæ‰€ä»¥å¯ä»¥å°†è¿™çœ‹æˆåˆ†ç»„èƒŒåŒ…ã€‚è™½ç„¶è¿™æ ·åšå¾ˆæ…¢ï¼Œä½†è¶³ä»¥é€šè¿‡åŸé¢˜ï¼ˆæ¯•ç«Ÿæœ€å¤šæ‰ä¸¤ä¸ªé™„ä»¶ï¼‰ã€‚å¯¹äºæœ¬é¢˜è€Œè¨€ï¼Œåªéœ€è¦ä¾æ¬¡åˆ¤æ–­æ¯ç§æƒ…å†µå³å¯ã€‚ ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; struct BadCreeper &#123; int v, w; BadCreeper(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; int n, V, f[32005]; vector &lt;BadCreeper> a[65]; int main(void) &#123; V = read(), n = read(); for (int i = 0; i &lt; n; ++i) &#123; int v = read(), p = read(), q = read(); if (q == 0) a[i].push_back(BadCreeper(v, v * p)); else a[q - 1].push_back(BadCreeper(v, v * p)); &#125; for (int i = 0; i &lt; n; ++i) for (int j = V; j >= 0; --j) &#123; if (a[i].size() > 0 &amp;&amp; j >= a[i][0].v) f[j] = max(f[j], f[j - a[i][0].v] + a[i][0].w); if (a[i].size() > 1 &amp;&amp; j >= a[i][0].v + a[i][1].v) f[j] = max(f[j], f[j - a[i][0].v - a[i][1].v] + a[i][0].w + a[i][1].w); if (a[i].size() > 2) &#123; if (j >= a[i][0].v + a[i][2].v) f[j] = max(f[j], f[j - a[i][0].v - a[i][2].v] + a[i][0].w + a[i][2].w); if (j >= a[i][0].v + a[i][1].v + a[i][2].v) f[j] = max(f[j], f[j - a[i][0].v - a[i][1].v - a[i][2].v] + a[i][0].w + a[i][1].w + a[i][2].w); &#125; &#125; int ans = 0; for (int i = 0; i &lt;= V; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; è¿™ç±»é—®é¢˜çš„æ›´å¤æ‚å½¢æ€æˆ‘ä»¬ä¼šåœ¨æ ‘å½¢ DP ä¸­è®¨è®ºã€‚ Problemset è¿™é‡Œæ˜¯ä¸€äº›ç®€å•å„ç±»èƒŒåŒ…é—®é¢˜çš„åˆé›†ã€‚å®ƒä»¬æœ¬èº«ä¸éš¾ï¼Œä¸»è¦æ˜¯å¸®åŠ©è¯»è€…è¿›ä¸€æ­¥äº†è§£èƒŒåŒ…ï¼Œä¸ºæ¥ä¸‹æ¥æ›´å›°éš¾çš„ DP å­¦ä¹ åšå‡†å¤‡ã€‚å¼ºçƒˆè¯»è€…ä»”ç»†é˜…è¯»è¿™ä¸€éƒ¨åˆ†ï¼Œå…¶ä¸­ä¼šå‡ºç°ä¸€äº›å‰é¢çš„ä¸“é¢˜æ²¡æœ‰è®²è¿°çš„å†…å®¹ã€‚ ç®€å•é—®é¢˜ è¿™é‡Œçš„é—®é¢˜éƒ½æ¯”è¾ƒç®€å•ï¼Œå¯ä»¥å½“ä½œå¤ä¹ çš„é¢˜ç›®ã€‚ [NOIP2001 æ™®åŠç»„] è£…ç®±é—®é¢˜ Portal. ç”±äºæˆ‘ä»¬å¸Œæœ›å‰©ä½™ç©ºé—´å°½å¯èƒ½åœ°å°ï¼Œé‚£ä¹ˆå¯ä»¥å°†ç‰©å“çš„ä½“ç§¯è§†ä½œç‰©å“çš„ä»·å€¼ï¼Œé‚£ä¹ˆæœ¬é¢˜å°±æ˜¯æ ‡å‡†çš„ 01 èƒŒåŒ…é—®é¢˜ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int v, n, w; int f[30005]; int main(void) &#123; scanf(\"%d%d\", &amp;v, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;w); for (int j = v; j >= w; j--) f[j] = max(f[j], f[j - w] + w); &#125; printf(\"%d\", v - f[v]); // æ ¹æ®ä¹‹å‰çš„æ¨è®ºï¼Œè¿™ä¹ˆåšä¹Ÿå¯ return 0; &#125; [CH5201] æ•°å­—ç»„åˆ Portal. è¿™ä¸ªé—®çš„æ˜¯å°†èƒŒåŒ…è£…æ»¡çš„æ–¹æ¡ˆæ€»æ•°ã€‚è®¾è®¡çŠ¶æ€ï¼šf[i,j]f[i,j]f[i,j] è¡¨ç¤ºç”¨å‰ iii ä¸ªç‰©å“ï¼Œæ°å¥½å¡«æ»¡ jjj çš„ä½“ç§¯çš„æ–¹æ¡ˆæ€»æ•°ã€‚é¦–å…ˆ f[i,0]f[i,0]f[i,0] å¿…å®šä¸º 111ã€‚è½¬ç§»ï¼šf[i,j]=f[iâˆ’1,j]+f[iâˆ’1,jâˆ’v]f[i,j]=f[i-1,j]+f[i-1,j-v]f[i,j]=f[iâˆ’1,j]+f[iâˆ’1,jâˆ’v]ï¼Œè·Ÿ 01 èƒŒåŒ…å¾ˆåƒï¼Ÿçš„ç¡®å¦‚æ­¤ï¼Œå¯¹äºè¿™ç±»æ”¹å˜é—®æ³•çš„é—®é¢˜ï¼Œä¸€èˆ¬åªéœ€å°†çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸­çš„ max æ”¹æˆ sum å³å¯ã€‚äº‹å®ä¸Šï¼Œè¿™æ ·åšå¯è¡Œçš„åŸå› åœ¨äºçŠ¶æ€è½¬ç§»æ–¹ç¨‹å·²ç»è€ƒå¯Ÿäº†æ‰€æœ‰å¯èƒ½çš„èƒŒåŒ…ç»„æˆæ–¹æ¡ˆã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int f[10005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); f[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int w; scanf(\"%d\", &amp;w); for (int j = m; j >= w; --j) // æ•°å­—åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œå¯¹åº” 01 èƒŒåŒ…çš„é¡ºåº f[j] += f[j - w]; &#125; printf(\"%d\\n\", f[m]); return 0; &#125; But WAIT! è¿™æ ·ä¸ä¼šäº§ç”Ÿä¹‹å‰æ‰€è¯´çš„â€œä¸ç”¨å–æœ€å¤§å€¼ä¹Ÿæ˜¯å¯¹çš„â€çš„å¡«è¿›å»ç©ºæ°”çš„æƒ…å†µå—ï¼Ÿä¸ä¼šï¼Œæˆ‘ä»¬åªè®© f[i,0]f[i,0]f[i,0] ä¸º 111ï¼Œè€Œ f[i,1]f[i,1]f[i,1] è¿™ç§ç©ºæ°”æ˜¯ 000ï¼Œæ²¡æœ‰æ–¹æ¡ˆã€‚ [CH5202] è‡ªç„¶æ•°æ‹†åˆ† Lunatic ç‰ˆ Portal. å°±æ˜¯æ±‚æ–¹æ¡ˆæ€»æ•°çš„å®Œå…¨èƒŒåŒ…ï¼šå®¹é‡ä¸º nnnï¼Œæœ‰ 1â‹¯n1\\cdots n1â‹¯n çš„ç‰©å“ä½“ç§¯ã€‚æ³¨æ„è¦ä½¿ç”¨è‹¥å¹²ä¸ªï¼Œä¸èƒ½æ˜¯ 111 ä¸ªï¼ˆæˆ‘æ‹†æˆæˆ‘è‡ªå·±ï¼‰ï¼Œæ‰€ä»¥æœ€ç»ˆç»“æœè¦ -1ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; const unsigned int MOD = 2147483648u; int n; unsigned int f[4005]; int main(void) &#123; scanf(\"%d\", &amp;n); f[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) f[j] = (f[j - i] + f[j]) % MOD; printf(\"%u\\n\", (f[n] - 1 + MOD) % MOD); return 0; &#125; [NOI Online #3 å…¥é—¨ç»„] ä¹°è¡¨ Portal. ç›´æ¥ä½¿ç”¨å¤šé‡èƒŒåŒ…çš„æ¨¡æ¿å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, m; bool f[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); f[0] = true; for (int i = 1; i &lt;= n; ++i) &#123; int k, a, c = 1; scanf(\"%d%d\", &amp;k, &amp;a); while (a - c >= 0) &#123; a -= c; int v = k * c; for (int j = 500000; j >= v; --j) f[j] |= f[j - v]; c &lt;&lt;= 1; &#125; &#125; while (m--) &#123; int x; scanf(\"%d\", &amp;x); puts(f[x] ? \"Yes\" : \"No\"); &#125; return 0; &#125; [BJOI2019] æ’å…µå¸ƒé˜µ Portal. å‡è®¾ s=1ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯æ™®é€šçš„èƒŒåŒ…é—®é¢˜äº†ã€‚ç°åœ¨å°†æ¯ä¸ªåŸå ¡æ’åºä¸€ä¸‹ï¼Œæšä¸¾è¦æ‰“è¿‡å¤šå°‘ä¸ªç©å®¶ï¼Œå°±å¯ä»¥è½»æ¾ç®—å‡ºè´¡çŒ®äº†ã€‚ æŸ¥çœ‹ä»£ç  // ç”šè‡³è¿æ»šåŠ¨æ•°ç»„éƒ½ä¸ç”¨ #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int s, n, m; int a[105][105]; int f[105][20005]; // åªè€ƒè™‘å‰ i åº§åŸå ¡ï¼Œæ°å¥½ä½¿ç”¨ j ä½å£«å…µæ‰€è·å¾—çš„æœ€å¤§æ”¶ç›Š int main(void) &#123; scanf(\"%d%d%d\", &amp;s, &amp;n, &amp;m); for (int i = 1; i &lt;= s; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[j][i]); for (int i = 1; i &lt;= n; ++i) sort(a[i] + 1, a[i] + s + 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) // è‹¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ï¼Œéœ€è¦å€’åº &#123; f[i][j] = f[i - 1][j]; for (int k = 1; k &lt;= s; ++k) if (j >= a[i][k] * 2 + 1) f[i][j] = max(f[i][j], f[i - 1][j - a[i][k] * 2 - 1] + k * i); // è´¡çŒ®ä¸º k * i &#125; int ans = 0; for (int j = 0; j &lt;= m; ++j) ans = max(ans, f[n][j]); printf(\"%d\\n\", ans); return 0; &#125; è¾ƒå¤æ‚é¢˜ç›® è¿™äº›é¢˜ç›®ä¼šæ¯”è¾ƒå¤æ‚ã€‚ [NOIP2018 æé«˜ç»„] è´§å¸ç³»ç»Ÿ Portal. å¤§å‡¯çš„ç–‘æƒ‘ã€‚ å¯ä»¥çŒœæµ‹ (m,b)(m,b)(m,b) çš„æ‰€æœ‰è´§å¸é¢é¢åœ¨ (n,a)(n,a)(n,a) ä¸­ä¸€å®šéƒ½æœ‰ï¼Œæˆ‘ä»¬åªéœ€è¦çœ‹å“ªäº›æ²¡æœ‰ã€‚å…ˆæ’åºï¼Œç„¶åæ‰«æï¼Œä½¿ç”¨å®Œå…¨èƒŒåŒ…ï¼Œå¯ä»¥æ‹¼æˆçš„å°±èµ‹å€¼ä¸º 111ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> using namespace std; int n; int a[105]; bool f[25005]; int main(void) &#123; int T; cin >> T; while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); int ans = n; memset(f, 0, sizeof(f)); f[0] = true; for (int i = 1; i &lt;= n; ++i) &#123; if (f[a[i]]) &#123; --ans; continue; &#125; for (int j = a[i]; j &lt;= 25000; ++j) f[j] |= f[j - a[i]]; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [CSP-J2019] çºªå¿µå“ Portal. ç”±äºå½“æ—¥è´­ä¹°çš„çºªå¿µå“ä¹Ÿå¯ä»¥å½“æ—¥å–å‡ºæ¢å›é‡‘å¸ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¼ºåˆ¶è®©ç¬¬ iii å¤©ä¹°çš„çºªå¿µå“åœ¨ç¬¬ i+1i+1i+1 å¤©å–æ‰ã€‚ä½†å¦‚æœå®ƒåº”è¯¥åœ¨ i+2i+2i+2 å¤©å–æ‰æ€ä¹ˆåŠï¼Ÿä¸è¦ç´§ï¼Œåœ¨ç¬¬ i+1i+1i+1 å¤©å†ä¹°å›æ¥ï¼Œä»·æ ¼æ˜¯ä¸€æ ·çš„ã€‚ äºæ˜¯ç›´æ¥å®Œå…¨èƒŒåŒ…æ¿å­æ‹ä¸Šå»å°±è¡Œäº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int t, n, m; int p[105][105]; int f[10005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;t, &amp;n, &amp;m); for (int i = 1; i &lt;= t; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", p[i] + j); for (int i = 1; i &lt; t; ++i) &#123; memset(f, 0, sizeof(f)); for (int j = 1; j &lt;= n; ++j) for (int k = p[i][j]; k &lt;= m; ++k) f[k] = max(f[k], f[k - p[i][j]] + p[i + 1][j] - p[i][j]); m += f[m]; &#125; printf(\"%d\\n\", m); return 0; &#125; [Luogu P1441] ç ç ç§°é‡ Portal. ä½¿ç”¨æœç´¢æšä¸¾åˆ æ‰å“ªäº›ç ç ï¼Œç„¶åå¯¹å‰©ä¸‹çš„ç ç ä½¿ç”¨èƒŒåŒ…ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, sum = 0, ans = 0; int a[25]; bool f[2005], del[25]; void dfs(int o, int cnt) &#123; if (cnt == m) &#123; memset(f, 0, sizeof(f)); f[0] = true; int ret = 0; for (int i = 1; i &lt;= n; ++i) if (!del[i]) &#123; for (int j = 2000; j >= 0; --j) if (f[j] &amp;&amp; !f[j + a[i]]) f[j + a[i]] = true, ++ret; &#125; ans = max(ans, ret); return; &#125; if (o > n || cnt > m) return; dfs(o + 1, cnt); del[o] = true; dfs(o + 1, cnt + 1); del[o] = false; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); sum += a[i]; &#125; dfs(1, 0); printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1782] æ—…è¡Œå•†çš„èƒŒåŒ… Portal. å°±æ˜¯å°†å¤šé‡èƒŒåŒ…å’Œåˆ†ç»„èƒŒåŒ…æ··åœ¨äº†ä¸€èµ·ï¼ˆå°†å¥‡è´§æ‹†å¼€ï¼‰ï¼Œä½†æ˜¯æœ¬é¢˜æ—¶é—´å¾ˆç´§ï¼Œéœ€è¦å¤§åŠ›å¡å¸¸ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #define V first #define W second using namespace std; typedef long long i64; inline int read(void) &#123; int x = 0, c = getchar_unlocked(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar_unlocked();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar_unlocked(); return x * f; &#125; int n, m, C, tot = 0; i64 f[100005]; pair&lt;i64, i64> a[2000005]; int main(void) &#123; n = read(), m = read(), C = read(); while (n--) &#123; i64 v = read(), w = read(), d = read(), c = 1; // è¿™ä¸ªäºŒè¿›åˆ¶ä¼˜åŒ–éå¸¸çš„å¼ºåŠ›ï¼Œå…ˆå¤„ç†ç‰©å“å†ç»Ÿä¸€è®¡ç®— while (d) &#123; if (d >= c) d -= c; else c = d, d = 0; a[++tot].V = v * c, a[tot].W = w * c; c &lt;&lt;= 1; &#125; &#125; // æ”¾åˆ°å¤–é¢ç»Ÿä¸€è®¡ç®— for (int i = 1; i &lt;= tot; ++i) for (int j = C; j >= a[i].V; --j) f[j] = max(f[j], f[j - a[i].V] + a[i].W); while (m--) &#123; i64 a = read(), b = read(), c = read(); for (int j = C; j >= 0; --j) for (int v = 0; v &lt;= j; ++v) f[j] = max(f[j], f[j - v] + a * v * v + b * v + c); &#125; printf(\"%lld\\n\", f[C]); return 0; &#125; [Luogu P1284] ä¸‰è§’å½¢ç‰§åœº Portal. æ³¨æ„åˆ°æ‰€æœ‰çš„æœ¨æ¿éƒ½éœ€è¦ä½¿ç”¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦ç¡®å®šä¸‰è§’å½¢ä¸¤æ¡è¾¹çš„é•¿åº¦å°±å¯ä»¥çŸ¥é“ç¬¬ä¸‰è¾¹ï¼Œç„¶åä½¿ç”¨æµ·ä¼¦å…¬å¼è®¡ç®—ä¸‰è§’å½¢é¢ç§¯ã€‚åªéœ€è¦é…åˆä¸€ä¸ªäºŒç»´çŠ¶æ€çš„ 01 èƒŒåŒ…å°±å¯ä»¥è®¡ç®—è¿™æ ·çš„é•¿åº¦æ˜¯å¦å¯ä»¥å¾—åˆ°æ»¡è¶³ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; double S(double a, double b, double c) &#123; double p = (a + b + c) / 2; return sqrt(p * (p - a) * (p - b) * (p - c)); &#125; bool check(int a, int b, int c) &#123; if (a &lt;= 0 || b &lt;= 0 || c &lt;= 0) return false; if (a + b &lt;= c || a + c &lt;= b || b + c &lt;= a) return false; return true; &#125; int n; int l[45]; bool f[805][805]; int main(void) &#123; scanf(\"%d\", &amp;n); int sum = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", l + i), sum += l[i]; f[0][0] = true; for (int i = 1; i &lt;= n; ++i) for (int j = 800; j >= 0; --j) for (int k = 800; k >= 0; --k) &#123; if (j - l[i] >= 0) f[j][k] |= f[j - l[i]][k]; if (k - l[i] >= 0) f[j][k] |= f[j][k - l[i]]; &#125; double ans = -1.0; for (int i = 0; i &lt;= 800; ++i) for (int j = 0; j &lt;= 800; ++j) if (f[i][j] &amp;&amp; check(i, j, sum - i - j)) ans = max(ans, S(i, j, sum - i - j)); if (ans == -1.0) puts(\"-1\"); else printf(\"%d\\n\", int(ans * 100)); return 0; &#125; [Luogu P1156] åƒåœ¾é™·é˜± Portal. è®¾ f(j)f(j)f(j) ä»£è¡¨é«˜åº¦ä¸º jjj æ—¶çš„æœ€é•¿å­˜æ´»æ—¶é—´ï¼Œç„¶åå°±æ˜¯ 01 èƒŒåŒ…äº†ï¼ˆé‡‡ç”¨åˆ·è¡¨æ³•ï¼‰ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; struct Rubbish &#123; int t, f, h; bool operator &lt; (const Rubbish &amp;a) const &#123; return t &lt; a.t; &#125; &#125; a[105]; int D, G; int f[105]; int main(void) &#123; scanf(\"%d%d\", &amp;D, &amp;G); for (int i = 1; i &lt;= G; ++i) scanf(\"%d%d%d\", &amp;a[i].t, &amp;a[i].f, &amp;a[i].h); sort(a + 1, a + G + 1); f[0] = 10; for (int i = 1; i &lt;= G; ++i) for (int j = D; j >= 0; --j) if (f[j] >= a[i].t) &#123; if (j + a[i].h >= D) &#123; printf(\"%d\\n\", a[i].t); return 0; &#125; f[j + a[i].h] = max(f[j + a[i].h], f[j]); f[j] += a[i].f; &#125; printf(\"%d\\n\", f[0]); return 0; &#125; [USACO03FALL] Cow Exhibition G Portal. è€ƒè™‘å°†æ™ºå•†è®¾å®šä¸ºä½“ç§¯ï¼Œæƒ…å•†è®¾å®šä¸ºä»·å€¼ï¼Œç­”æ¡ˆè®¡ç®—çš„æ—¶å€™æšä¸¾æ™ºå•†ã€‚æ³¨æ„æ»šåŠ¨çš„æ—¶å€™çš„è½¬ç§»é¡ºåºã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int E = 400000, C = 400000; int n; int f[900005]; int main(void) &#123; scanf(\"%d\", &amp;n); memset(f, 0xbf, sizeof(f)); f[E] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if (a >= 0) &#123; for (int j = C + E; j >= a; --j) f[j] = max(f[j], f[j - a] + b); &#125; else &#123; for (int j = 0; j &lt;= C + E - a; ++j) f[j] = max(f[j], f[j - a] + b); &#125; &#125; int ans = 0; for (int i = 0; i &lt;= C; ++i) if (f[i + E] >= 0) ans = max(ans, i + f[i + E]); printf(\"%d\\n\", ans); return 0; &#125; [SCOI2009] ç²‰åˆ·åŒ  Portal.windy æœ‰ NNN æ¡æœ¨æ¿éœ€è¦è¢«ç²‰åˆ·ã€‚æ¯æ¡æœ¨æ¿è¢«åˆ†ä¸º MMM ä¸ªæ ¼å­ã€‚æ¯ä¸ªæ ¼å­è¦è¢«åˆ·æˆçº¢è‰²æˆ–è“è‰²ã€‚windy æ¯æ¬¡ç²‰åˆ·ï¼Œåªèƒ½é€‰æ‹©ä¸€æ¡æœ¨æ¿ä¸Šä¸€æ®µè¿ç»­çš„æ ¼å­ï¼Œç„¶åæ¶‚ä¸Šä¸€ç§é¢œè‰²ã€‚ æ¯ä¸ªæ ¼å­æœ€å¤šåªèƒ½è¢«ç²‰åˆ·ä¸€æ¬¡ã€‚å¦‚æœ windy åªèƒ½ç²‰åˆ· TTT æ¬¡ï¼Œä»–æœ€å¤šèƒ½æ­£ç¡®ç²‰åˆ·å¤šå°‘æ ¼å­ï¼Ÿä¸€ä¸ªæ ¼å­å¦‚æœæœªè¢«ç²‰åˆ·æˆ–è€…è¢«ç²‰åˆ·é”™é¢œè‰²ï¼Œå°±ç®—é”™è¯¯ç²‰åˆ·ã€‚1â‰¤N,Mâ‰¤50,0â‰¤Tâ‰¤25001\\le N,M \\le 50, 0 \\le T \\le 25001â‰¤N,Mâ‰¤50,0â‰¤Tâ‰¤2500ã€‚ è€ƒè™‘ä½¿ç”¨åˆ†ç»„èƒŒåŒ…ï¼Œæ¯ä¸€ä¸ªç»„æ˜¯æ¯ä¸€ä¸ªæœ¨æ¿ï¼Œç»„å†…çš„ç‰©å“æ˜¯ä¸åŒçš„ç²‰åˆ·æ¬¡æ•°ã€‚ç‰©å“çš„ä»·å€¼å¯ä»¥ä½¿ç”¨ DP é¢„å¤„ç†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, m, T; vector&lt;int> a[55]; int f[55][55][55][2]; // f(id,i,j,flag) ç¬¬ id å—æœ¨æ¿ï¼Œè€ƒè™‘åˆ°ç¬¬ i ä¸ªï¼ŒæŸ“äº† j æ¬¡ï¼Œç¬¬ i å—æ˜¯å¦æ­£å¸¸æŸ“è‰² int g[2505]; void work(int id) &#123; int siz = a[id].size() - 1; for (int i = 1; i &lt;= siz; ++i) for (int j = siz; j >= 1; --j) &#123; f[id][i][j][0] = max(f[id][i - 1][j][0], f[id][i - 1][j][1]); f[id][i][j][1] = max(f[id][i - 1][j - 1][0], f[id][i - 1][j - 1][1]) + a[id][i]; if (i >= 2) f[id][i][j][1] = max(f[id][i][j][1], f[id][i - 2][j][1] + a[id][i]); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;T); for (int i = 1; i &lt;= n; ++i) &#123; a[i].push_back(0); static char s[55]; scanf(\"%s\", s + 1); for (int j = 1; j &lt;= m; ++j) if (a[i].empty() || s[j] != s[j - 1]) a[i].push_back(1); else ++a[i][a[i].size() - 1]; &#125; for (int id = 1; id &lt;= n; ++id) work(id); for (int i = 1; i &lt;= n; ++i) &#123; int siz = a[i].size() - 1; for (int j = T; j >= 0; --j) for (int k = 0; k &lt;= siz; ++k) if (j >= k) g[j] = max(g[j], g[j - k] + max(f[i][siz][k][0], f[i][siz][k][1])); &#125; printf(\"%d\\n\", g[T]); return 0; &#125; [HEOI2013] Eden çš„æ–°èƒŒåŒ…é—®é¢˜ Portal.å¤šé‡èƒŒåŒ…ï¼Œä½†æ˜¯å¤šç»„è¯¢é—®ï¼Œæ¯æ¬¡ç»™å®šä½“ç§¯ï¼Œå¹¶åˆ å»ä¸€ä¸ªç‰©å“ã€‚è¯¢é—®ç›¸äº’ç‹¬ç«‹ã€‚ ç”¨å‰åç¼€åˆå¹¶çš„åšæ³•ï¼Œåˆ†åˆ«å¤„ç†åˆ†ç»„èƒŒåŒ…å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define pii pair&lt;int, int> #define V first #define W second using namespace std; int n, q; int f1[1005][1005], f2[1005][1005]; vector&lt;pii> a[1005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int v, w, m, c = 1; scanf(\"%d%d%d\", &amp;v, &amp;w, &amp;m); while (m >= c) &#123; m -= c; a[i].push_back(&#123;c * v, c * w&#125;); c &lt;&lt;= 1; &#125; if (m) a[i].push_back(&#123;m * v, m * w&#125;); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= 1000; ++j) f1[i][j] = f1[i - 1][j]; for (pii x : a[i]) for (int j = 1000; j >= x.V; --j) f1[i][j] = max(f1[i][j], f1[i][j - x.V] + x.W); &#125; for (int i = n; i >= 1; --i) &#123; for (int j = 0; j &lt;= 1000; ++j) f2[i][j] = f2[i + 1][j]; for (pii x : a[i]) for (int j = 1000; j >= x.V; --j) f2[i][j] = max(f2[i][j], f2[i][j - x.V] + x.W); &#125; scanf(\"%d\", &amp;q); while (q--) &#123; int d, e; scanf(\"%d%d\", &amp;d, &amp;e); ++d; int ans = 0; for (int j = 0; j &lt;= e; ++j) ans = max(ans, f1[d - 1][j] + f2[d + 1][e - j]); printf(\"%d\\n\", ans); &#125; return 0; &#125; [Luogu P4141] æ¶ˆå¤±ä¹‹ç‰© Portal.èƒŒåŒ…ï¼Œæ¯æ¬¡å»æ‰ä¸€ä¸ªç‰©å“ï¼Œé—®æœ‰å¤šå°‘ç§æ–¹å¼å¡«æ»¡ã€‚ è€ƒè™‘æ¯æ¬¡è½¬ç§»çš„æ—¶å€™åŠ ä¸Šäº†ä»€ä¹ˆï¼Œæˆ‘ä»¬å€’åºåŠ äº†ï¼Œé‚£ä¹ˆæŸ¥è¯¢çš„æ—¶å€™æ­£åºå‡å»å°±å¥½äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m; int a[2005], f[2005], g[2005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); f[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = m; j >= a[i]; --j) f[j] = (f[j] + f[j - a[i]]) % 10; for (int i = 1; i &lt;= n; ++i) &#123; memcpy(g, f, sizeof(g)); for(int j = a[i]; j &lt;= m; ++j) g[j] = (f[j] - g[j - a[i]] + 10) % 10; for (int j = 1; j &lt;= m; ++j) printf(\"%d\", g[j]); putchar('\\n'); &#125; return 0; &#125; å°ç»“ èƒŒåŒ…é—®é¢˜ä¸»è¦ä»¥ç®—æ³•æ¨¡æ¿çš„å½¢å¼å‡ºç°åœ¨è€ƒè¯•ä¸­ï¼Œéš¾åœ¨ä¸€é“é¢˜å¦‚ä½•è½¬åŒ–æˆèƒŒåŒ…é—®é¢˜ï¼Œä½†è¿™ä¸æ˜¯æœ¬æ–‡è®²è§£çš„é‡ç‚¹ã€‚æƒ³è¦å­¦ä¼šè¿™ä¸€ç‚¹ï¼Œåªèƒ½é€šè¿‡å­¦ä¹ å„ç§å„æ ·çš„ DPï¼Œåšå¤§é‡çš„é¢˜ç›®ï¼Œç§¯ç´¯ç»éªŒã€‚è¯·è¯»è€…åŠ¡å¿…è®°ä½å„ç§èƒŒåŒ…çš„åŸç†ï¼Œè€Œä¸æ˜¯èƒŒä½å¾ªç¯é¡ºåºã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"èƒŒåŒ…","slug":"èƒŒåŒ…","permalink":"https://james1badcreeper.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"æé«˜ä¼˜åŒ–æŠ€å·§","slug":"notes/æ‚é¡¹/tg-tricks","date":"2022-07-24T00:00:00.000Z","updated":"2022-07-24T00:00:00.000Z","comments":true,"path":"37f7d707/","link":"","permalink":"https://james1badcreeper.github.io/37f7d707/","excerpt":"æé«˜çº§åˆ«çš„å¸¸è§ç®€å•æŠ€å·§åŒ…æ‹¬å‰ç¼€å’Œä¸å·®åˆ†ï¼Œ2-pointers ç­‰ï¼Œæœ¬æ–‡ç®€å•ä»‹ç»äº†å®ƒä»¬ã€‚","text":"æé«˜çº§åˆ«çš„å¸¸è§ç®€å•æŠ€å·§åŒ…æ‹¬å‰ç¼€å’Œä¸å·®åˆ†ï¼Œ2-pointers ç­‰ï¼Œæœ¬æ–‡ç®€å•ä»‹ç»äº†å®ƒä»¬ã€‚ åŒæŒ‡é’ˆ åŒæŒ‡é’ˆé‡Œçš„æŒ‡é’ˆå¹¶ä¸æ˜¯æŒ‡ C è¯­è¨€ä¸­çš„æŒ‡é’ˆï¼Œè€Œæ˜¯ä¸€ä¸ªæŠ½è±¡çš„æŒ‡é’ˆã€‚æˆ‘ä¸€ä¸ªæŒ‡é’ˆâ€œæŒ‡â€åœ¨äº†åºåˆ—ä¸­çš„æŸä¸ªåœ°æ–¹ï¼Œä¸€æ–¹é¢è¡¨ç¤ºç›®å‰æšä¸¾åˆ°äº†è¿™é‡Œï¼Œå¦ä¸€æ–¹é¢è¡¨ç¤ºæ­£åœ¨å…³æ³¨è¿™ä¸ªæ•°ï¼Œä¸¤ä¸ªæŒ‡é’ˆä¹Ÿç»å¸¸æœ‰åŒºé—´å·¦å³ç«¯ç‚¹çš„æ„ä¹‰ã€‚ä¸€èˆ¬æ˜¯æšä¸¾ä¸€ä¸ªæŒ‡é’ˆï¼Œç„¶åå¦ä¸€ä¸ªæŒ‡é’ˆéšç€è¿™ä¸ªæŒ‡é’ˆçš„ç§»åŠ¨è€Œç§»åŠ¨ã€‚ ç®€å•åœ°æ¥è¯´ï¼Œ2-pointer å…¶å®å°±æ˜¯ç”¨ä¸¤ä¸ªæŒ‡é’ˆæ‰«ææ•°ç»„ã€‚ å¤§æ¦‚åˆ†ä¸ºä¸¤ç§ï¼Œä¸¤ä¸ªæŒ‡é’ˆçš„è¡Œè¿›æ–¹å‘æ˜¯ç›¸åŒçš„ï¼Œæˆ–æ˜¯ç›¸å‘çš„ã€‚ æ™®é€šåŒæŒ‡é’ˆ å› ä¸ºå¾ˆå¸¸è§„ï¼Œæ‰€ä»¥å®ƒæ²¡æœ‰åå­—ã€‚ [Luogu P1102] A-B æ•°å¯¹ Portal. Aâˆ’B=CA-B=CAâˆ’B=C å¯ä»¥åŒ–ä¸º Aâˆ’C=BA-C=BAâˆ’C=Bï¼Œä¹Ÿå°±æ˜¯è¯´å¯ä»¥æ‰¾åˆ°åºåˆ—ä¸­çš„ä¸€ä¸ªæ•°å‡æ‰ CCC ç­‰äºåºåˆ—ä¸­çš„å¦ä¸€ä¸ªæ•°ã€‚æ˜¾ç„¶å¯¹äºä¸€ä¸ª AAA, BBB æ˜¯å”¯ä¸€çš„ã€‚ å½“ç„¶å¯ä»¥æ’åºåä½¿ç”¨äºŒåˆ†æ¥æ‰¾è¿™ä¸ª BBB çš„æ•°é‡ï¼Œä¸è¿‡ä»Šå¤©æˆ‘ä»¬ä»‹ç»å¦ä¸€ç§åšæ³•ã€‚æˆ‘ä»¬è¿˜æ˜¯å…ˆæ’åºï¼Œè¿™äº› BBB ä¸€å®šæ˜¯è¿ç»­çš„ã€‚ä»å·¦åˆ°å³æ‰«æåºåˆ—ï¼Œè®°å½“å‰æ‰«æåˆ° aia_iaiâ€‹ï¼Œå½“ç»§ç»­å‘å³æ‰«ï¼Œaia_iaiâ€‹ ä¼šå¢åŠ ï¼Œæ‰€å¯¹åº”çš„ BBB çš„ä¸‹æ ‡ä¸ä¼šå‡å°ã€‚åˆ©ç”¨è¿™ä¸ªæ€§è´¨æ‰«æä¸€æ¬¡å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ï¼ˆéœ€è¦ä½¿ç”¨åŸºæ•°æ’åºï¼‰ã€‚ ç»´æŠ¤ä¸¤ä¸ªä¸‹æ ‡ l,rl,rl,rï¼Œä½¿å¾—ä½¿å¾—ä»»æ„æ—¶åˆ» lll æ˜¯ç¬¬ä¸€ä¸ªæ»¡è¶³ Aâˆ’C=BA-C=BAâˆ’C=B çš„ä½ç½®ï¼Œrrr æ˜¯ç¬¬ä¸€ä¸ªä¸æ»¡è¶³ Aâˆ’C=BA-C=BAâˆ’C=B çš„ä½ç½®ï¼Œé‚£ä¹ˆä¸ªæ•°å°±æ˜¯ râˆ’lr-lrâˆ’lã€‚ #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; using i64 = long long; int n, c; int a[200005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;c); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); int l = 1, r = 1; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (a[l] &lt; a[i] - c &amp;&amp; l &lt;= n) ++l; // æ‰¾åˆ°ç¬¬ä¸€ä¸ª B çš„ä¸‹æ ‡ while (a[r] &lt;= a[i] - c &amp;&amp; r &lt;= n) ++r; // æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯ B çš„ä¸‹æ ‡ ans += r - l; // l &lt;= r æ’æˆç«‹ï¼Œç›´æ¥åŠ å³å¯ &#125; printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P1115] æœ€å¤§å­æ®µå’Œ Portal. å…ˆè®¡ç®—å‰ç¼€å’Œã€‚ä¸€ä¸ªå­æ®µå’Œç­‰äº S[r]âˆ’S[lâˆ’1]S[r]-S[l-1]S[r]âˆ’S[lâˆ’1]ï¼Œå½“ S[r]S[r]S[r] ä¸€å®šæ—¶ï¼Œæ‰¾åˆ°æœ€å°çš„ S[lâˆ’1]S[l-1]S[lâˆ’1] å°±å¯ä»¥äº†ã€‚å¯ä»¥ç®€å•åœ°è®°å½• S[lâˆ’1]S[l-1]S[lâˆ’1]ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x * f; &#125; int sum[200005]; int main(void) &#123; int n = read(), ans = -2000000000, minn = 0; for (int i = 1; i &lt;= n; ++i) sum[i] = read() + sum[i-1]; for (int R = 1; R &lt;= n; ++R) &#123; ans = max(ans, sum[R] - minn); minn = min(minn, sum[R]); &#125; printf(\"%d\\n\", ans); return 0; &#125; [USACO16OPEN] Diamond Collector S Portal. æ ¹æ®ç›´è§‰è‚¯å®šè¦å…ˆæ’åºã€‚ç”±äºæ€»å…±æœ‰ä¸¤ä¸ªæ¶å­ï¼Œç„¶åå®¹æ˜“å‘ç°ï¼Œå¦‚æœä¸¤ä¸ªé’»çŸ³æ”¾åˆ°åŒä¸€ä¸ªç›’å­ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªé’»çŸ³ä¸­é—´çš„ä¹Ÿå¯ä»¥æ”¾åˆ°åŒä¸€ä¸ªç›’å­ã€‚é—®é¢˜å®é™…ä¸Šæ˜¯è¦æ‰¾å‡ºä¸¤ä¸ªä¸ç›¸äº¤çš„åŒºé—´ï¼Œä½¿å¾—æœ€å¤§å€¼å’Œæœ€å°å€¼ä¹‹å·®éƒ½å°äº KKKï¼Œä¸”åŒºé—´é•¿åº¦ä¹‹å’Œæœ€å¤§ã€‚ è¿™æ—¶å°±æœ‰ä¸¤ç§æ€è·¯ï¼Œä¸€ä¸ªæ˜¯å‰åå„åšä¸¤è¾¹åŒæŒ‡é’ˆï¼Œç„¶ååˆå¹¶ã€‚ æ‰«ä¸¤é #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, k; int a[50005]; int f[50005], g[50005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); // æ­¤æ—¶ f[i] ä»£è¡¨ä» i å¼€å§‹ï¼ˆå¿…é¡»å« iï¼‰å‘å³å¯ä»¥é€‰çš„æœ€é•¿åŒºé—´ for (int L = 1, R = 1; L &lt;= n; ++L) &#123; while (R &lt; n &amp;&amp; a[R + 1] &lt;= k + a[L]) ++R; // R å°½é‡å¾€å·¦èµ° f[L] = R - L + 1; // ä» L å¼€å§‹çš„æœ€å¤§åŒºé—´é•¿åº¦ &#125; // æ¥ä¸‹æ¥è®© f[i] ä»£è¡¨åœ¨ [i,n] ä¸­é€‰ä¸€æ®µåŒºé—´çš„æœ€å¤§é•¿åº¦ï¼ˆå¯ä»¥ä¸å« iï¼‰ for (int i = n - 1; i >= 1; --i) f[i] = max(f[i], f[i + 1]); // æ­¤æ—¶ g[i] ä»£è¡¨ä» i å¼€å§‹ï¼ˆå« iï¼‰å‘å·¦å¯ä»¥é€‰çš„æœ€é•¿åŒºé—´ for (int L = n, R = n; R >= 1; --R) &#123; while (L > 1 &amp;&amp; a[R] - a[L - 1] &lt;= k) --L; // L å°½é‡å¾€å·¦èµ° g[R] = R - L + 1; // ä» R å¼€å§‹çš„æœ€å¤§åŒºé—´é•¿åº¦ &#125; // æ¥ä¸‹æ¥è®© g[i] ä»£è¡¨åœ¨ [1,i] ä¸­é€‰ä¸€æ®µåŒºé—´çš„æœ€å¤§é•¿åº¦ï¼ˆå¯ä»¥ä¸å« iï¼‰ for (int i = 2; i &lt;= n; ++i) g[i] = max(g[i], g[i - 1]); int ans = 0; for (int i = 1; i &lt; n; ++i) // åˆå¹¶ç­”æ¡ˆï¼Œæšä¸¾åˆ†ç•Œç‚¹ iï¼Œåˆ†åˆ«æ±‚ [1,i], [i+1,n] ä¸¤ç«¯åŒºé—´ä¸­é€‰ä¸€æ®µæœ€é•¿åŒºé—´çš„é•¿åº¦ï¼Œç„¶åç›¸åŠ  ans = max(ans, f[i + 1] + g[i]); printf(\"%d\\n\", ans); return 0; &#125; å¦ä¸€ç§æ˜¯åªæ‰«ä¸€éï¼ŒåŒæ—¶ç»Ÿè®¡ï¼š æ‰«ä¸€é #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, k, ans = 0, res = 0; // ans è®°å½•æœ€å¤§ç­”æ¡ˆï¼Œres è®°å½• [0,i-1] ä¸­çš„æœ€é•¿åŒºé—´ int a[50005], c[50005]; // c[i] è®°å½•ä» i å¼€å§‹å‘å·¦èµ°ï¼Œæœ€é•¿çš„åŒºé—´ï¼Œå°±æ˜¯æ»¡è¶³æ¡ä»¶çš„ [x,i] çš„æœ€å¤§é•¿åº¦ int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); c[1] = 1; for (int i = 1, R = 1; i &lt;= n; ++i) // [i,R] æ”¾åœ¨ç¬¬äºŒä¸ªæ¶å­ï¼Œèƒ½æ”¾å¤šå°‘æ”¾å¤šå°‘ // åœ¨ [0,i - 1] ä¸­æŒ‘ä¸€æ®µåŒºé—´æ”¾åœ¨ç¬¬ä¸€ä¸ªæ¶å­ // åœ¨ i å³è¾¹é€‰ä¸€æ®µåŒºé—´æ”¾æ²¡æœ‰æ„ä¹‰ï¼Œå› ä¸ºè¿Ÿæ—©èƒ½æ‰«åˆ° // ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªç®—æ³•ç›¸å½“äºæšä¸¾ iï¼Œæ‰¾åˆ°æœ€å¤§çš„ Rï¼Œå¹¶è®¡ç®—åœ¨ [0,i - 1] ä¸­æŒ‘ä¸€æ®µåŒºé—´çš„æœ€å¤§é•¿åº¦ &#123; while (R &lt; n &amp;&amp; a[R + 1] &lt;= a[i] + k) &#123; ++R; // R è¶Šå¤§è¶Šå¥½ /* c[R] è¡¨ç¤ºä» R å¼€å§‹å‘å·¦èµ°çš„æœ€å¤§é•¿åº¦ R èƒ½è·‘åˆ°è¿™é‡Œï¼Œæ˜¯åœ¨å½“å‰è¿™ä¸ª i ä¹‹å‰å‰æ‰€æœªæœ‰çš„ ä¹Ÿå°±æ˜¯å½“å‰è¿™ä¸ª i æ˜¯ç¬¬ä¸€ä¸ªèƒ½ä½¿ R è·‘åˆ°è¿™é‡Œçš„ é‚£ä¹ˆè¿™ä¸ª i ä¸€å®šæ˜¯ä½¿å¾—åŒºé—´é•¿åº¦æœ€é•¿çš„æœ€å° i */ c[R] = R - i + 1; &#125; res = max(res, c[i - 1]); // æ›´æ–° resï¼Œres å°±æ˜¯ max(c[0],c[1]...c[i-1]) ans = max(ans, R - i + 1 + res); // R - i + 1 ä¸º [i,R] çš„é•¿åº¦ &#125; printf(\"%d\\n\", ans); return 0; &#125; å°ºå–æ³• æˆ‘ä¹Ÿä¸çŸ¥é“è¿™æ˜¯ä¸ªä»€ä¹ˆä¸œè¥¿ï¼Œä½†æ˜¯ç»™çš„é¢˜å•æ˜¯è¿™æ ·çš„ï¼Œç¬”è®°æˆ‘å°±è¿™ä¹ˆå†™äº†ã€‚ æ„Ÿè§‰å°±æ˜¯æ»‘åŠ¨çª—å£ï¼Œä½†å¯èƒ½è¿˜ä¸å¤ªä¸€æ ·ã€‚ å®é™…ä¸ŠæŒ‡çš„å°±æ˜¯ä¸¤ä¸ªç§»åŠ¨æ–¹å‘ç›¸åŒçš„åŒæŒ‡é’ˆï¼Œç„¶åç»Ÿè®¡å®ƒä»¬ä¹‹é—´çš„ä¿¡æ¯ã€‚ [Luogu P1638] é€›ç”»å±• Portal. ä½¿ç”¨æ»‘åŠ¨çª—å£ï¼ˆåŒå‘åŒæŒ‡é’ˆï¼‰ï¼Œå¹¶å¼€ä¸€ä¸ªæ¡¶è®°å½•çœ‹çš„å„ä¸ªç”»å®¶çš„ç”»çš„æ•°é‡ï¼Œåœ¨è¿™ä¸ªæ•°é‡åˆ° mmm é’±è®© R++ï¼Œåˆ°äº†ä¹‹åè®© L++ ç›´åˆ°ä¸æ»¡è¶³æ¡ä»¶ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m, cnt = 0; int ans = 1000005, ansL = 1, ansR = 1000000; int a[1000005], b[2005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); int L = 1, R = 1; while (R &lt;= n) &#123; if (b[a[R]] == 0) ++cnt; ++b[a[R]]; while (L &lt; R &amp;&amp; cnt == m &amp;&amp; b[a[L]] > 1) --b[a[L]], ++L; if (cnt == m &amp;&amp; R - L &lt; ansR - ansL) &#123; ansL = L; ansR = R; &#125; ++R; &#125; printf(\"%d %d\\n\", ansL, ansR); return 0; &#125; [UVa 11572] Unique Snowflakes Portal. ç›´æ¥ä½¿ç”¨æ»‘åŠ¨çª—å£ï¼Œç„¶ååˆ©ç”¨ä¸€ä¸ª set åˆ¤é‡å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;unordered_set> using namespace std; int n; int a[1000005]; unordered_set &lt;int> s; void solve(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); s.clear(); int L = 1, R = 1, ans = 0; while (R &lt;= n) &#123; while (R &lt;= n &amp;&amp; s.find(a[R]) == s.end()) s.insert(a[R++]); ans = max(ans, R - L); s.erase(a[L++]); &#125; printf(\"%d\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; æ’åº æ˜¯æ™®åŠç»„å†…å®¹ï¼Œä½†æ˜¯ç¬”è€…ä¸ä¼šã€‚ æ’åºç®—æ³•ï¼ˆè‹±è¯­ï¼šSorting algorithmï¼‰æ˜¯ä¸€ç§å°†ä¸€ç»„ç‰¹å®šçš„æ•°æ®æŒ‰æŸç§é¡ºåºè¿›è¡Œæ’åˆ—çš„ç®—æ³•ã€‚æ’åºç®—æ³•å¤šç§å¤šæ ·ï¼Œæ€§è´¨ä¹Ÿå¤§å¤šä¸åŒã€‚ ç¨³å®šæ€§ã€‚ç¨³å®šæ€§æ˜¯æŒ‡ç›¸ç­‰çš„å…ƒç´ ç»è¿‡æ’åºä¹‹åç›¸å¯¹é¡ºåºæ˜¯å¦å‘ç”Ÿäº†æ”¹å˜ã€‚æ‹¥æœ‰ç¨³å®šæ€§è¿™ä¸€ç‰¹æ€§çš„ç®—æ³•ä¼šè®©åŸæœ¬æœ‰ç›¸ç­‰é”®å€¼çš„çºªå½•ç»´æŒç›¸å¯¹æ¬¡åºï¼Œå³å¦‚æœä¸€ä¸ªæ’åºç®—æ³•æ˜¯ç¨³å®šçš„ï¼Œå½“æœ‰ä¸¤ä¸ªç›¸ç­‰é”®å€¼çš„çºªå½• AAA å’Œ BBBï¼Œä¸”åœ¨åŸæœ¬çš„åˆ—è¡¨ä¸­ AAA å‡ºç°åœ¨ BBB ä¹‹å‰ï¼Œåœ¨æ’åºè¿‡çš„åˆ—è¡¨ä¸­ AAA ä¹Ÿå°†ä¼šæ˜¯åœ¨ BBB ä¹‹å‰ã€‚ å…³äºç¨³å®šæ€§çš„æ„ä¹‰ï¼š å¦‚æœåªæ˜¯ç®€å•çš„è¿›è¡Œæ•°å­—çš„æ’åºï¼Œé‚£ä¹ˆç¨³å®šæ€§å°†æ¯«æ— æ„ä¹‰ã€‚ å¦‚æœæ’åºçš„å†…å®¹ä»…ä»…æ˜¯ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„æŸä¸€ä¸ªå±æ€§ï¼ˆæ¯”å¦‚æ’åºçš„æ˜¯ç»“æ„ä½“ï¼Œå…¶ä¸­ä¸€ä¸ªæ•°å­—ä½œä¸ºæ’åºä¾æ®ï¼‰ï¼Œé‚£ä¹ˆç¨³å®šæ€§ä¾æ—§å°†æ¯«æ— æ„ä¹‰ã€‚ å¦‚æœè¦æ’åºçš„å†…å®¹æ˜¯ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„å¤šä¸ªå±æ€§ï¼ˆæ¯”å¦‚æ’åºçš„æ˜¯ç»“æ„ä½“ï¼Œå…¶ä¸­å‡ ä¸ªæ•°å­—å‚ä¸è¿ç®—ä½œä¸ºæ’åºä¾æ®ï¼‰ï¼Œä½†æ˜¯å…¶åŸæœ¬çš„åˆå§‹é¡ºåºæ¯«æ— æ„ä¹‰ï¼Œé‚£ä¹ˆç¨³å®šæ€§ä¾æ—§å°†æ¯«æ— æ„ä¹‰ã€‚ é™¤éè¦æ’åºçš„å†…å®¹æ˜¯ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„å¤šä¸ªå±æ€§ï¼Œä¸”å…¶åŸæœ¬çš„åˆå§‹é¡ºåºå­˜åœ¨æ„ä¹‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦åœ¨è¿›è¡Œæ’åºçš„åŸºç¡€ä¸Šä¿æŒåŸæœ‰é¡ºåºçš„æ„ä¹‰ï¼Œæ‰éœ€è¦ä½¿ç”¨åˆ°ç¨³å®šæ€§çš„ç®—æ³•ã€‚ä¾‹å¦‚è¦æ’åºçš„å†…å®¹æ˜¯ä¸€ç»„åŸæœ¬æŒ‰ç…§ä»·æ ¼é«˜ä½æ’åºçš„å¯¹è±¡ï¼Œå¦‚ä»Šéœ€è¦æŒ‰ç…§é”€é‡é«˜ä½æ’åºï¼Œä½¿ç”¨ç¨³å®šæ€§ç®—æ³•ï¼Œå¯ä»¥ä½¿å¾—ç›¸åŒé”€é‡çš„å¯¹è±¡ä¾æ—§ä¿æŒç€ä»·æ ¼é«˜ä½çš„æ’åºå±•ç°ï¼Œåªæœ‰é”€é‡ä¸åŒçš„æ‰ä¼šé‡æ–°æ’åºã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œé™¤éè¦æ’åºçš„å†…å®¹å…·æœ‰å¤šä¸ªå±æ€§ï¼Œè€Œä¸”åœ¨ç›¸ç­‰æ—¶è¦ä¿è¯åŸæœ‰çš„é¡ºåºï¼Œæ‰éœ€è¦ä½¿ç”¨ç¨³å®šæ€§æ’åºã€‚ æ’åºçš„æ–¹æ³•ã€‚æ’åºè¦ä¹ˆæ˜¯åŸºäºæ¯”è¾ƒï¼Œè¦ä¹ˆæ˜¯åŸºäºåˆ†ç±»ã€‚ä¸‹æ–‡ä¼šè¿›è¡Œä»‹ç»ã€‚ å¤æ‚åº¦ã€‚åŒ…æ‹¬æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ã€‚æœ‰æœ€åå¤æ‚åº¦ï¼Œå¹³å‡å¤æ‚åº¦å’Œæœ€ä¼˜å¤æ‚åº¦ã€‚ä¸€èˆ¬æ¥è®²ç®—æ³•ç«èµ›ä¸­åªçœ‹æœ€åã€‚ å†’æ³¡æ’åº å·¥ä½œåŸç†æ˜¯æ¯æ¬¡æ£€æŸ¥ç›¸é‚»ä¸¤ä¸ªå…ƒç´ ï¼Œå¦‚æœå‰é¢çš„å…ƒç´ ä¸åé¢çš„å…ƒç´ æ»¡è¶³ç»™å®šçš„æ’åºæ¡ä»¶ï¼Œå°±å°†ç›¸é‚»ä¸¤ä¸ªå…ƒç´ äº¤æ¢ã€‚å½“æ²¡æœ‰ç›¸é‚»çš„å…ƒç´ éœ€è¦äº¤æ¢æ—¶ï¼Œæ’åºå°±å®Œæˆäº†ã€‚ æ‰«äº†ä¸€æ¬¡åï¼Œæœ€åä¸€é¡¹å¿…å®šæ˜¯æœ€å¤§çš„ã€‚æ‰« nâˆ’1n-1nâˆ’1 æ¬¡å°±è¡Œäº†ã€‚ æ—¶é—´å¤æ‚åº¦ O(n2)O(n^2)O(n2)ï¼Œæ˜¯ä¸€ç§ç¨³å®šçš„æ’åºç®—æ³•ã€‚ for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt;= n - i; ++j) if (a[j] > a[j + 1]) swap(a[j], a[j + 1]); è¿™ä¸ªä¸œè¥¿å¯ä»¥ä¼˜åŒ–ï¼Œå¦‚æœæ‰«å®Œäº†ä¹‹åå‘ç°æ²¡æœ‰äº¤æ¢çš„å†…å®¹ï¼Œé‚£ä¹ˆè¯´æ˜å·²ç»æ’å¥½åºäº†ã€‚ä»£ç å¦‚ä¸‹ï¼š for (int i = 1; i &lt; n; ++i) &#123; bool flag = false; for (int j = 1; j &lt;= n - i; ++j) if (a[j] > a[j + 1]) &#123; swap(a[j], a[j + 1]); flag = true; &#125; if (!flag) break; &#125; å†’æ³¡æ’åºä¸é€†åºå¯¹ã€‚æˆ‘ä»¬çŸ¥é“é€†åºå¯¹æ˜¯æŒ‡ a[i]&gt;a[j],i&lt;ja[i]&gt;a[j],i&lt;ja[i]&gt;a[j],i&lt;jï¼Œå®ƒä¹Ÿæ˜¯å†’æ³¡æ’åºçš„æœ€å°äº¤æ¢æ¬¡æ•°ã€‚éœ€è¦çŸ¥é“çš„æ˜¯ï¼Œå†’æ³¡æ’åºäº¤æ¢å…ƒç´ çš„æ¬¡æ•°å°±ç­‰äºåŸåºåˆ—çš„é€†åºå¯¹æ•°ã€‚ å¯ä»¥è¿™æ ·ç†è§£ï¼šäº¤æ¢æ¡ä»¶æ˜¯ a[j] &gt; a[j + 1]ï¼Œè¿™å°±æ˜¯æŒ‡ä¸€ä¸ªé€†åºå¯¹ï¼Œäº¤æ¢äº†ä¹‹åå¦‚æœä¸äº§ç”Ÿæ–°çš„é€†åºå¯¹ï¼Œé‚£ä¹ˆé€†åºå¯¹æ•°å¿…ç„¶ä¼šå‡å°‘ä¸€ï¼›ç”±äºäº¤æ¢å jjj å‰é¢çš„ä¾ç„¶åœ¨ jjj å‰é¢ï¼Œj+1j+1j+1 åé¢çš„ä¾ç„¶åœ¨åé¢ï¼Œæ‰€ä»¥é€†åºå¯¹æ•°æ²¡æœ‰æ”¹å˜ã€‚ç»¼ä¸Šå¯å¾—å†’æ³¡æ’åºäº¤æ¢å…ƒç´ çš„æœ€å°æ¬¡æ•°å°±ç­‰äºåŸåºåˆ—çš„é€†åºå¯¹æ•°ã€‚ é€‰æ‹©æ’åº åŸç†æ˜¯æ¯æ¬¡å¯»æ‰¾ç¬¬ iii å°çš„å…ƒç´ ï¼Œä¸ç¬¬ iii ä¸ªä½ç½®ä¸Šçš„ä¸œè¥¿äº¤æ¢ï¼Œæ—¶é—´å¤æ‚åº¦ O(n2)O(n^2)O(n2)ã€‚ æ˜¯ä¸€ç§ä¸ç¨³å®šçš„æ’åºç®—æ³•ï¼Œå¦‚ 3 3 1ï¼Œå°†æ–œä½“ 3 å’Œ 1 æ¯”è¾ƒï¼Œå˜æˆäº† 1 3 3ï¼Œæ–œä½“ 3 åˆ°äº†ç›´ä½“ 3 åé¢ã€‚ for (int i = 1; i &lt; n; ++i) &#123; int ith = i; // å°±æ˜¯å¯»æ‰¾åé¢æœ€å°çš„å…ƒç´ ï¼Œé‚£ä¸ªä¸€å®šæ˜¯ç¬¬ i å° for (int j = i + 1; j &lt;= n; ++j) if (a[j] &lt; a[ith]) ith = j; swap(a[i], a[ith]); &#125; æ’å…¥æ’åº æ’å…¥æ’åºçš„å·¥ä½œåŸç†æ˜¯å°†å¾…æ’åˆ—å…ƒç´ åˆ’åˆ†ä¸ºâ€œå·²æ’åºâ€å’Œâ€œæœªæ’åºâ€ä¸¤éƒ¨åˆ†ï¼Œæ¯æ¬¡ä»â€œæœªæ’åºçš„â€å…ƒç´ ä¸­é€‰æ‹©ä¸€ä¸ªæ’å…¥åˆ°â€œå·²æ’åºçš„â€å…ƒç´ ä¸­çš„æ­£ç¡®ä½ç½®ã€‚ ä¸€ä¸ªä¸æ’å…¥æ’åºç›¸åŒçš„æ“ä½œæ˜¯æ‰“æ‰‘å…‹ç‰Œæ—¶ï¼Œä»ç‰Œæ¡Œä¸ŠæŠ“ä¸€å¼ ç‰Œï¼ŒæŒ‰ç‰Œé¢å¤§å°æ’åˆ°æ‰‹ç‰Œåï¼Œå†æŠ“ä¸‹ä¸€å¼ ç‰Œã€‚ æ˜¯ä¸€ç§ç¨³å®šçš„æ’åºç®—æ³•ã€‚å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º O(n2)O(n^2)O(n2)ã€‚ for (int i = 2; i &lt;= n; ++i) &#123; int now = a[i], j = i - 1; for (; j >= 1; --j) &#123; if (a[j] > now) a[j + 1] = a[j]; else break; &#125; a[j + 1] = now; &#125; å¿«é€Ÿæ’åº åŸºäºåˆ†æ²»ï¼Œä½†æ˜¯å‡å¯ä»¥ä½¿ç”¨ STL æ›¿ä»£ï¼š sort(a + 1, a + n + 1); // æ’åº nth_element(a + 1, a + k, a + n + 1); // æŸ¥æ‰¾ k å°å…ƒç´  å½’å¹¶æ’åº æ˜¯åˆ†æ²»æ³•çš„åŸºç¡€ï¼Œåˆ©ç”¨å…¶å®Œç¾çš„æ€§è´¨å¯ä»¥é«˜æ•ˆæ±‚é€†åºå¯¹ã€‚ ç¦»æ•£åŒ– å°±æ˜¯å°†æ— ç©·å¤§é›†åˆä¸­çš„è‹¥å¹²å…ƒç´ æ˜ å°„ä¸ºæœ‰é™é›†åˆæ¥æ–¹ä¾¿ç»Ÿè®¡ã€‚å½“æœ‰äº›æ•°æ®å› ä¸ºæœ¬èº«å¾ˆå¤§æˆ–è€…ç±»å‹ä¸æ”¯æŒï¼Œè‡ªèº«æ— æ³•ä½œä¸ºæ•°ç»„çš„ä¸‹æ ‡æ¥æ–¹ä¾¿åœ°å¤„ç†ï¼Œè€Œå½±å“æœ€ç»ˆç»“æœçš„åªæœ‰å…ƒç´ ä¹‹é—´çš„ç›¸å¯¹å¤§å°å…³ç³»æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†åŸæ¥çš„æ•°æ®æŒ‰ç…§ä»å¤§åˆ°å°ç¼–å·æ¥å¤„ç†é—®é¢˜ï¼Œå³ç¦»æ•£åŒ–ã€‚ ä½†æ˜¯è¿™ä¸ªä¸ºä»€ä¹ˆä¸œè¥¿å«ç¦»æ•£åŒ–ï¼Ÿæˆ‘ä¹Ÿä¸çŸ¥é“ã€‚ æœ€å¸¸è§çš„æ˜¯æœ‰ nnn ä¸ª int èŒƒå›´å†…çš„æ•´æ•°ï¼Œå¯èƒ½æœ‰é‡å¤ï¼Œå‡å®šå»é‡åæœ‰ mmm ä¸ªæ•´æ•°ã€‚æˆ‘ä»¬è¦æŠŠæ¯ä¸ª a[i]a[i]a[i] ç”¨ 1âˆ¼m1\\sim m1âˆ¼m ä¹‹é—´çš„æ•´æ•°ä»£æ›¿ï¼Œå¹¶ä¸”ä¿è¯é¡ºåºå¤§å°ä¸å˜ã€‚å½“ç„¶å¯ä»¥ä½¿ç”¨ mapï¼Œä½†æ˜¯æˆ‘ä»¬æ¥æ¢è®¨ä¸€ä¸ªå¸¸æ•°æ›´å°çš„ç®—æ³•ã€‚ æˆ‘ä»¬å¯ä»¥æŠŠ aaa æ’åºå¹¶å»é‡ï¼Œå¾—åˆ°æœ‰åºæ•°ç»„ b[1]âˆ¼b[m]b[1]\\sim b[m]b[1]âˆ¼b[m]ï¼Œè‹¥æŸ¥è¯¢ iii ä»£è¡¨çš„æ•°å€¼ï¼Œè¿”å› b[i]b[i]b[i] å³å¯ã€‚è‹¥è¦æŸ¥è¯¢æ•´æ•° a[j]a[j]a[j] è¢«é‚£ä¸ª 1âˆ¼m1\\sim m1âˆ¼m ä¹‹é—´çš„æ•´æ•°ä»£æ›¿ï¼Œåªéœ€è¦åœ¨ bbb ä¸­äºŒåˆ†æŸ¥æ‰¾å®ƒçš„ä½ç½®ã€‚ void discrete(void) &#123; // ç¦»æ•£åŒ– sort(b + 1, b + n + 1); // å…ˆæ’åº m = unique(b + 1, b + n + 1) - (b + 1); // å†å»é‡ &#125; int P(int x) &#123; // æŸ¥è¯¢è°æ›¿ä»£äº† x return lower_bound(b + 1, b + n + 1, x) - b; &#125; [CF670C] Cinema. è¿™äº›è¯­è¨€çš„æ•°æ¯”è¾ƒå¤§ï¼Œå¯ä»¥æŠŠå®ƒä»¬éƒ½æ”¾åˆ°ä¸€ä¸ªæ•°ç»„é‡Œï¼Œç¦»æ•£åŒ–åå°±å®¹æ˜“ç»Ÿè®¡äº†ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m, size; int a[200005], b[200005], c[200005]; int d[800005]; int cnt[800005]; inline int P(int x) &#123; return lower_bound(d+1, d+size+1, x) - d; &#125; int main(void) &#123; n = read(); int tot = 0; for (int i = 1; i &lt;= n; ++i) a[i] = read(), d[++tot] = a[i]; m = read(); for (int i = 1; i &lt;= m; ++i) b[i] = read(), d[++tot] = b[i]; for (int i = 1; i &lt;= m; ++i) c[i] = read(), d[++tot] = c[i]; sort(d+1, d+tot+1); size = unique(d+1, d+tot+1) - (d+1); for (int i = 1; i &lt;= n; ++i) ++cnt[P(a[i])]; int ans = 0, ret = -1, res = -1; for (int i = 1; i &lt;= m; ++i) &#123; int x = cnt[P(b[i])], y = cnt[P(c[i])]; if (x > ret || (x == ret &amp;&amp; y > res)) ans = i, ret = x, res = y; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; å•è°ƒæ ˆä¸å•è°ƒé˜Ÿåˆ— å¦‚æœæ ˆæˆ–é˜Ÿåˆ—ä¸­çš„å…ƒç´ å…·æœ‰å•è°ƒæ€§ï¼Œé‚£ä¹ˆå®ƒä»¬å°±åˆ†åˆ«è¢«æˆä¸ºå•è°ƒæ ˆå’Œå•è°ƒé˜Ÿåˆ—ï¼Œå¯ä»¥åŠæ—¶å¸®æˆ‘ä»¬æ’é™¤ä¸å¯èƒ½çš„å†³ç­–ã€‚ å•è°ƒæ ˆ æ¨¡æ¿ã€‚ ç”±äºæ±‚çš„æ˜¯ä¹‹åï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä»åå¾€å‰è€ƒè™‘ã€‚ ç¬¬ä¸€ä¸ªå¤§äºï¼Ÿæƒ³åˆ°äº†ä»€ä¹ˆï¼Ÿå¦‚æœè¿™ä¸ªæ•°æ˜¯åè¢«è€ƒè™‘åˆ°çš„ï¼ˆå³ä¸‹æ ‡å°ï¼‰ï¼Œè€Œä¸”å®ƒè¿˜æ¯”å‰é¢è€ƒè™‘åˆ°çš„æ•°å¤§ï¼Œé‚£ä¹ˆè¿™äº›æ•°å°±ä¸å¯èƒ½ç§°ä¸ºç­”æ¡ˆäº†ã€‚ç”¨ä¿—è¯­æ¥è¯´å°±æ˜¯ï¼š å¦‚æœä¸€ä¸ªäººæ¯”ä½ å°ï¼Œè¿˜æ¯”ä½ å¼ºï¼Œé‚£ä¹ˆä½ å°±æ°¸è¿œä¹Ÿæ‰“ä¸è¿‡ä»–äº†ã€‚ æˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸€ä¸ªæ ˆï¼Œè®°å½•ç¼–å·ï¼Œå¦‚æœå‘ç°æ»¡è¶³è¿™ç§æ¡ä»¶çš„ä¸œè¥¿ï¼Œé‚£ä¹ˆå°±å¼¹æ ˆï¼Œæœ€å push å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š int n; int a[3000005]; int ans[3000005]; stack&lt;int> s; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = n; i >= 1; --i) &#123; // å€’åºæ‰« while (!s.empty() &amp;&amp; a[s.top()] &lt;= a[i]) s.pop(); // å¼¹æ ˆ ans[i] = s.empty() ? 0 : s.top(); // è®°å½•ç­”æ¡ˆ s.push(i); // å°†è¿™ä¸ªæ•°å‹è¿›æ ˆé‡Œ &#125; // æœ€åè¾“å‡ºç­”æ¡ˆå³å¯ return 0; &#125; æ³¨æ„ï¼Œstack å¾ˆæ…¢ï¼Œå¦‚æœå¯ä»¥å»ºè®®æ‰‹å†™ã€‚ å•è°ƒé˜Ÿåˆ— æ¨¡æ¿ã€‚ è¿™å›å¯ä¸ä¸€æ ·äº†ï¼Œå®ƒè¿˜è¦æ±‚åŒºé—´çš„é•¿åº¦ã€‚å¦‚æœæˆ‘ä»¬å¼€ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ï¼Œé‚£ä¹ˆä¸å°±å¯ä»¥åŠæ—¶å¼¹æ‰ä¸ç¬¦åˆè¦æ±‚çš„æ•°äº†å—ï¼Ÿ æ‰€ä»¥è¯´ï¼Œå•è°ƒé˜Ÿåˆ—ç›¸æ¯”å•è°ƒæ ˆå¢åŠ äº†å¼¹å‡ºè¶…è¿‡æ—¶é—´çš„æ•°çš„åŠŸèƒ½ã€‚ deque &lt;int> q; for (int i = 1; i &lt;= n; ++i) &#123; while (!q.empty() &amp;&amp; a[q.back()] >= a[i]) q.pop_back(); while (!q.empty() &amp;&amp; q.front() &lt;= i - k) q.pop_front(); q.push_back(i); // print(a[q.front()]) &#125; for (int i = 1; i &lt;= n; ++i) &#123; while (!q.empty() &amp;&amp; a[q.back()] &lt;= a[i]) q.pop_back(); while (!q.empty() &amp;&amp; q.front() &lt;= i - k) q.pop_front(); q.push_back(i); // print(a[q.front()]) &#125; å‰ç¼€å’Œä¸å·®åˆ† è¿™æ˜¯å¾ˆç®€å•ä½†å¾ˆé‡è¦çš„ä¼˜åŒ–æŠ€å·§ã€‚ å‰ç¼€å’Œ å‰ç¼€å’Œæ˜¯ä¸€ç§é‡è¦çš„é¢„å¤„ç†ï¼Œèƒ½å¤§å¤§é™ä½æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦ã€‚å¯ä»¥ç®€å•ç†è§£ä¸ºâ€œæ•°åˆ—çš„å‰ nnn é¡¹çš„å’Œâ€ã€‚ å®ç° æ¨¡æ¿ã€‚ è®¾ Si=âˆ‘j=1iAiS_i=\\sum_{j=1}^{i}A_iSiâ€‹=âˆ‘j=1iâ€‹Aiâ€‹ï¼Œåˆ™ âˆ‘i=lr=Srâˆ’Slâˆ’1\\sum_{i=l}^{r} = S_r-S_{l-1}âˆ‘i=lrâ€‹=Srâ€‹âˆ’Slâˆ’1â€‹ã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; i64 sum[100005]; int main(void) &#123; int n = read(); for (int i = 1; i &lt;= n; ++i) sum[i] = read() + sum[i-1]; int m = read(); while (m--) &#123; int l = read(), r = read(); printf(\"%lld\\n\", sum[r] - sum[l - 1]); &#125; return 0; &#125; [Luogu P1115] æœ€å¤§å­æ®µå’Œ Portal. æœ€å¤§å­æ®µå’Œé—®é¢˜æœ‰å¾ˆå¤šç§è§£å†³æ–¹å¼ï¼Œæ¯”å¦‚åŠ¨æ€è§„åˆ’ã€‚è¿™é‡Œæˆ‘ä»¬ç”¨å‰ç¼€å’Œå†å®ç°ä¸€ä¸ªçº¿æ€§ç®—æ³•ï¼ˆè™½ç„¶åº”è¯¥ç®—æ»‘åŠ¨çª—å£ï¼‰ã€‚ ä¸€ä¸ªå­æ®µå’Œç­‰äº S[r]âˆ’S[lâˆ’1]S[r]-S[l-1]S[r]âˆ’S[lâˆ’1]ï¼Œå½“ S[r]S[r]S[r] ä¸€å®šæ—¶ï¼Œæ‰¾åˆ°æœ€å°çš„ S[lâˆ’1]S[l-1]S[lâˆ’1] å°±å¯ä»¥äº†ã€‚å¯ä»¥ç®€å•åœ°è®°å½• S[lâˆ’1]S[l-1]S[lâˆ’1]ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x * f; &#125; int sum[200005]; int main(void) &#123; int n = read(), ans = -2000000000, minn = 0; for (int i = 1; i &lt;= n; ++i) sum[i] = read() + sum[i-1]; for (int R = 1; R &lt;= n; ++R) &#123; ans = max(ans, sum[R] - minn); minn = min(minn, sum[R]); &#125; printf(\"%d\\n\", ans); return 0; &#125; å·®åˆ† å·®åˆ†æ˜¯å‰ç¼€å’Œçš„é€†è¿ç®—ã€‚å¯¹äºä¸€ä¸ªæ•°ç»„ AAAï¼Œå®šä¹‰å®ƒçš„å·®åˆ†æ•°ç»„ BBBï¼Œæ»¡è¶³ B1=A1,Bi=Aiâˆ’Aiâˆ’1(iâ‰¥2)B_1=A_1, B_i=A_i-A_{i-1}(i\\ge 2)B1â€‹=A1â€‹,Biâ€‹=Aiâ€‹âˆ’Aiâˆ’1â€‹(iâ‰¥2)ã€‚å¯¹è¿™ä¸ªå·®åˆ†æ•°ç»„æ±‚å‰ç¼€å’Œå¾—åˆ°çš„å°±æ˜¯åŸæ•°ç»„ï¼Œå¯¹å‰ç¼€å’Œæ±‚å·®åˆ†ä¹Ÿèƒ½å¾—åˆ°åŸæ•°ç»„ã€‚ å®ç° [Luogu P2367] è¯­æ–‡æˆç»©ã€‚ æ±‚å‡ºåŸåºåˆ— AAA çš„å·®åˆ†åºåˆ— BBBã€‚æ±‚å‡ºå°† bxb_xbxâ€‹ å¢åŠ  111ï¼Œé‚£ä¹ˆ Axâ‹¯AnA_x \\cdots A_nAxâ€‹â‹¯Anâ€‹ éƒ½ä¼šå¢åŠ  111ã€‚åˆ©ç”¨è¿™ä¸ªè§„å¾‹å°±å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜äº†ã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; int n, p; i64 a[5000005], b[5000005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) b[i] = a[i] - a[i - 1]; while (p--) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); b[x] += z, b[y + 1] -= z; &#125; i64 ans = 1000000000000; for (int i = 1; i &lt;= n; ++i) // æ­¤æ—¶çš„ a ç”¨äºè®¡ç®—å‰ç¼€å’Œ a[i] = a[i - 1] + b[i], ans = min(ans, a[i]); printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P3406] æµ·åº•é«˜é“ Portal. æˆ‘ä»¬åªéœ€è¦ç»Ÿè®¡å‡ºåæ¯è¾†è½¦çš„æ¬¡æ•°å°±å¯ä»¥è¿›è¡Œè®¡ç®—äº†ã€‚ç»´æŠ¤ä¸€ä¸ªå·®åˆ†æ•°ç»„ï¼Œå¯¹äºå°† [l,râˆ’1]+1[l,r-1]+1[l,râˆ’1]+1 çš„æ“ä½œï¼Œåªéœ€è¦è®© Sl+1,Srâˆ’1+1S_l+1, S_{r-1}+1Slâ€‹+1,Srâˆ’1â€‹+1 å³å¯ï¼Œæœ€åç®—ä¸€éå‰ç¼€å’Œå°±è¡Œäº†ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; int m, n, a, b, c, p[100005]; i64 sum[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", p + i); for (int i = 2; i &lt;= m; ++i) ++sum[min(p[i - 1], p[i])], --sum[max(p[i - 1], p[i])]; for (int i = 2; i &lt;= n; ++i) sum[i] += sum[i - 1]; i64 ans = 0; for (int i = 1; i &lt; n; ++i) &#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); ans += min(a * sum[i], b * sum[i] + c); &#125; printf(\"%lld\\n\", ans); return 0; &#125; é«˜ç»´é—®é¢˜ å‰ç¼€å’Œå’Œå·®åˆ†ä¸ä»…èƒ½å¤Ÿåœ¨ä¸€ç»´çº¿æ€§ç©ºé—´ä¸Šå·¥ä½œï¼Œè¿˜å¯ä»¥åœ¨é«˜ç»´ç©ºé—´ä¸Šå·¥ä½œã€‚ä¸»è¦åº”ç”¨æ˜¯äºŒä½å‰ç¼€å’Œå’ŒäºŒç»´å·®åˆ†ï¼ˆä¸‰ç»´å¯ä»¥è‡ªå·±ç±»æ¯”ï¼Œéœ€è¦ä¸€å®šçš„ç©ºé—´æƒ³è±¡èƒ½åŠ›ï¼Œè¿™é‡Œä¸åšä»‹ç» å®é™…ä¸Šä½ ä¹Ÿç”¨ä¸ç€ï¼‰ã€‚ äºŒç»´å‰ç¼€å’Œ [Luogu P1719] æœ€å¤§åŠ æƒçŸ©å½¢ã€‚è¦æ±‚ç»™å‡ºä¸€ä¸ª O(n3)O(n^3)O(n3) çš„ç®—æ³•ã€‚ æˆ‘ä»¬å¯ä»¥æšä¸¾çŸ©å½¢çš„å››ä¸ªç«¯ç‚¹åæ ‡ï¼Œç„¶åä½¿ç”¨äºŒç»´å‰ç¼€å’Œåœ¨å¸¸æ•°æ—¶é—´å†…è§£å†³é—®é¢˜ã€‚åˆ©ç”¨å®¹æ–¥åŸç†å¾ˆå®¹æ˜“å¾—åˆ°ç»“æœï¼Œå…·ä½“è¿‡ç¨‹è¯·è¯»è€…è‡ªè¡Œæ¨¡æ‹Ÿï¼šè®° s[i,j]=âˆ‘p=1iâˆ‘q=1jAi,js[i,j]=\\sum\\limits_{p=1}^i\\sum\\limits_{q=1}^j A_{i,j} s[i,j]=p=1âˆ‘iâ€‹q=1âˆ‘jâ€‹Ai,jâ€‹ åˆ™ âˆ‘x1=1x2âˆ‘y1=1y2Ai,j=s[x2,y2]âˆ’s[x1âˆ’1,y2]âˆ’s[x2,y1âˆ’1]+s[x1âˆ’1,y1âˆ’1]\\sum\\limits_{x_{1}=1}^{x_{2}}\\sum\\limits_{y_{1}=1}^{y_{2}} A_{i,j}= s[x_{2},y_{2}]-s[x_{1}-1,y_{2}]-s[x_{2},y_{1}-1]+s[x_{1}-1,y_{1}-1] x1â€‹=1âˆ‘x2â€‹â€‹y1â€‹=1âˆ‘y2â€‹â€‹Ai,jâ€‹=s[x2â€‹,y2â€‹]âˆ’s[x1â€‹âˆ’1,y2â€‹]âˆ’s[x2â€‹,y1â€‹âˆ’1]+s[x1â€‹âˆ’1,y1â€‹âˆ’1] é‚£ä¹ˆ O(n4)O(n^4)O(n4) çš„ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = -1000000000; int sum[125][125]; int solve(int x1, int y1, int x2, int y2) &#123; return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; int x; scanf(\"%d\", &amp;x); sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + x - sum[i - 1][j - 1]; &#125; for (int x1 = 1; x1 &lt;= n; x1++) for (int y1 = 1; y1 &lt;= n; y1++) for (int x2 = x1; x2 &lt;= n; x2++) for (int y2 = y1; y2 &lt;= n; y2++) ans = max(ans, solve(x1, y1, x2, y2)); printf(\"%d\\n\", ans); return 0; &#125; è€ƒè™‘ä¼˜åŒ–ã€‚è¿˜è®°å¾—ã€Šæœ€å¤§å­æ®µå’Œã€‹å—ï¼Ÿå¯ä»¥æšä¸¾ä¸Šä¸‹è¾¹ç•Œï¼Œä¸­é—´çš„è¿™ä¸€å¤§æ’å°±æ˜¯ä¸ªæœ€å¤§å­æ®µå’Œé—®é¢˜ï¼å¯ä»¥ä½¿ç”¨æ»‘åŠ¨çª—å£æˆ– DP å®ç°æœ€å¤§å­æ®µå’Œã€‚è¿™é‡Œç”¨ä¸€ä¸ªå¾ˆèªæ˜çš„æ–¹å¼ï¼šå¦‚æœå½“å‰ç´¯è®¡å’Œæ˜¯éè´Ÿæ•°å°±ä¿ç•™ï¼Œè´Ÿæ•°å°±æ‰”æ‰ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = -1000000000; int sum[125][125]; int solve(int x1, int y1, int x2, int y2) &#123; return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; int x; scanf(\"%d\", &amp;x); sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + x - sum[i - 1][j - 1]; &#125; for (int x1 = 1; x1 &lt;= n; x1++) for (int x2 = x1; x2 &lt;= n; x2++) &#123; int s = 0; for (int i = 1; i &lt;= n; i++) &#123; s += solve(x1, i, x2, i); ans = max(ans, s); if (s &lt; 0) s = 0; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P2004] é¢†åœ°é€‰æ‹© Portal. ä½¿ç”¨äºŒç»´å‰ç¼€å’Œï¼Œç®€å•æšä¸¾å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m, c; int sum[1005][1005]; int ans = -1000000000, ansx, ansy; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; int x; scanf(\"%d\", &amp;x); sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + x; &#125; for (int i = 1; i &lt;= n - c + 1; i++) for (int j = 1; j &lt;= m - c + 1; j++) &#123; if (sum[i + c - 1][j + c - 1] + sum[i - 1][j - 1] - sum[i + c - 1][j - 1] - sum[i - 1][j + c - 1] >= ans) &#123; ans = sum[i + c - 1][j + c - 1] + sum[i - 1][j - 1] - sum[i + c - 1][j - 1] - sum[i - 1][j + c - 1]; ansx = i; ansy = j; &#125; &#125; printf(\"%d %d\\n\", ansx, ansy); return 0; &#125; [HNOI2003] æ¿€å…‰ç‚¸å¼¹ Portal. ç›´æ¥ç”¨äºŒä½å‰ç¼€å’Œå¤„ç†ï¼Œç„¶åæšä¸¾æ¿€å…‰ç‚¸å¼¹æŠ•æ”¾çš„ä½ç½®å³å¯ã€‚ç©ºé—´è¾ƒä¸ºç´§å¼ ï¼Œæœ€å¥½ç›´æ¥åœ¨å‰ç¼€å’Œæ•°ç»„ä¸Šè¿›è¡Œè¯»å…¥ã€‚è™½ç„¶ç›®æ ‡æ˜¯ä¸€ä¸ªè´¨ç‚¹ï¼Œä½†æˆ‘ä»¬å¯ä»¥æŠŠå®ƒçœ‹æˆä¸€ä¸ªå—å—ï¼Œå‰ç¼€å’Œå°±å¯ä»¥åšäº†ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m; int s[5005][5005]; int main(void) &#123; n = read(), m = read(); while (n--) &#123; int x = read(), y = read(), w = read(); s[x + 1][y + 1] += w; &#125; for (int i = 1; i &lt;= 5001; ++i) for (int j = 1; j &lt;= 5001; ++j) s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; int ans = 0; for (int i = m; i &lt;= 5001; ++i) for (int j = m; j &lt;= 5001; ++j) ans = max(ans, s[i][j] - s[i - m][j] - s[i][j - m] + s[i - m][j - m]); printf(\"%d\\n\", ans); return 0; &#125; äºŒç»´å·®åˆ† [Luogu P3397] åœ°æ¯¯ã€‚ å°†å·®åˆ†æ‰©å±•åˆ°äºŒç»´å³å¯ã€‚è¯·è¯»è€…è‡ªè¡Œç”¨å®¹æ–¥åŸç†è¿›è¡Œæ¨¡æ‹Ÿã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int a[1005][1005]; int ans[1005][1005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int x1, y1, x2, y2; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); a[x2 + 1][y2 + 1]++; a[x1][y1]++; a[x1][y2 + 1]--; a[x2 + 1][y1]--; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) ans[i][j] = ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1] + a[i][j]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) printf(\"%d \", ans[i][j]); putchar('\\n'); &#125; return 0; &#125; é«˜ç»´é—®é¢˜çš„ DP è§£æ³• è¿™æ˜¯ä»€ä¹ˆï¼Ÿ ä½ èƒ½å¤Ÿè½»æ¾æƒ³è±¡ä¸‰ç»´å‰ç¼€å’Œç”šè‡³å››ç»´å‰ç¼€å’Œçš„åšæ³•ç ï¼Ÿåæ­£ç¬”è€…ä¸èƒ½ã€‚ ç”¨ DP è®¡ç®—å¯ä»¥ä½¿è¿‡ç¨‹å˜å¾—ç®€å•è®¸å¤šã€‚è¿™ç§ DP æ˜¯ sosDPï¼ˆSum over Subsets DPï¼Œå­é›†å’Œ DPï¼Œæ˜¯çŠ¶å‹ DP çš„ä¸€ç§ï¼‰ã€‚ é‰´äºæœ¬æ–‡çš„å†…å®¹æ°´å¹³ï¼Œè¿™é‡Œä¸ç»™å‡ºå…·ä½“åŸç†ï¼Œè¯·è¯»è€…è‡ªè¡Œæ¨¡æ‹Ÿã€‚ äºŒç»´å‰ç¼€å’Œ// è¯»å…¥æ—¶ç›´æ¥è¯»åˆ°å‰ç¼€å’Œæ•°ç»„é‡Œ for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;s[i][j]); // è¿›è¡Œä¸¤æ¬¡è¿ç®—ï¼Œæ³¨æ„ +=ï¼Œä¸€æ¬¡æ˜¯ i - 1ï¼Œä¸€æ¬¡æ˜¯ j - 1 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) s[i][j] += s[i - 1][j]; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) s[i][j] += s[i][j - 1]; ä¸‰ç»´å‰ç¼€å’Œ// å’ŒäºŒç»´åŸºæœ¬ç›¸åŒ for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= k; ++j) for (int k = 1; k &lt;= n; ++k) scanf(\"%d\", &amp;s[i][j][k]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++) s[i][j][k] += s[i - 1][j][k]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++) s[i][j][k] += s[i][j - 1][k]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++) s[i][j][k] += s[i][j][k - 1]; ä½†æ˜¯æŸ¥è¯¢å¥½åƒè¿˜æ˜¯è¦ç”¨å®¹æ–¥ã€‚è¿™é‡Œç»™å‡ºå…¬å¼ä¾›èƒŒè¯µï¼š ä¸‰ç»´ç»´æŠ¤ï¼šs[i][j][k] = s[i-1][j][k] + s[i][j-1][k] + s[i][j][k-1] - s[i-1][j-1][k] - s[i-1][j][k-1] - s[i][j-1][k-1] + s[i-1][j-1][k-1] + a[i][j][k] ä¸‰ç»´æ±‚å’Œï¼šs[x2][y2][z2] - s[x1-1][y2][z2] - s[x2][y1-1][z2] - s[x2][y2][z1-1] + s[x1-1][y1-1][z2] + s[x1-1][y2][z1-1] + s[x2][y1-1][z1-1] - s[x1-1][y1-1][z1-1] å·®åˆ†å¤§æ¦‚ä¹Ÿæ˜¯åŒæ ·çš„åŸç†ï¼š ä¸‰ç»´å·®åˆ†ï¼š b[x1][y1][z1] += c , b[x2+1][y1][z1] -=c , b[x1][y2+1][z1] -= c , b[x1][y1][z2+1] -= c , b[x2+1][y2+1][z1] += c , b[x2+1][y1][z2+1] += c , b[x1][y2+1][z2+1] += c , b[x2+1][y2+1][z2+1] -= c ç„¶åå‘¢ï¼Ÿnnn ç»´å‰ç¼€å’Œçš„é—®é¢˜è¾ƒä¸ºå›°éš¾ï¼Œéœ€è¦ä½¿ç”¨ sosDPï¼Œè¯·è¯»è€…é˜…è¯»ç¬”è€…çš„ã€ŠåŸºäºçŠ¶æ€è¿›è¡Œä¼˜åŒ–çš„ DPã€‹ä¸€æ–‡ã€‚ è´ªå¿ƒçš„åº”ç”¨ çœŸçš„ä¸æ˜¯ç®€å•è´ªå¿ƒäº†ã€‚ è´ªå¿ƒæ–¹æ³• å¿…é¡»æ»¡è¶³å½“å‰ä¸€æ­¥æ˜¯æœ€ä¼˜è§£ï¼Œé‚£ä¹ˆå…¨å±€å°±æ˜¯æœ€ä¼˜è§£ã€‚ æ’åºè´ªå¿ƒã€‚è¿™ç§åšæ³•æ˜¯ç¦»çº¿çš„ï¼Œé€šè¿‡æ’åºæ‰¾å‡ºæœ€ä¼˜çš„ã€‚ åæ‚”è´ªå¿ƒã€‚è¿™ç§åšæ³•æ˜¯åœ¨çº¿çš„ï¼Œæ— è®ºå½“å‰çš„é€‰æ‹©æ˜¯ä»€ä¹ˆéƒ½æ¥å—ï¼Œå¦‚æœä¹‹åå‘ç°è¿™ä¸ªé€‰é¡¹ä¸ä¼˜äº†ï¼Œé‚£ä¹ˆå°±åºŸå¼ƒæ‰ã€‚ è´ªå¿ƒè¯æ˜ å¾®æ‰°æ³•ã€‚å¯¹å±€éƒ¨çš„ä»»ä½•æ”¹å˜éƒ½ä¸ä¼šä½¿å¾—ç»“æœå˜å¥½ã€‚ èŒƒå›´ç¼©æ”¾ã€‚è¯æ˜å±€éƒ¨çš„æœ€ä¼˜ç­–ç•¥å¿…å®šæ˜¯å…¨å±€çš„æœ€ä¼˜ç­–ç•¥ï¼Œæˆ–è€…æ˜¯å±€éƒ¨æœ€ä¼˜å†³ç­–å·²ç»åŒ…å«äº†æ‰€æœ‰å¯èƒ½çš„æƒ…å†µã€‚ åè¯æ³•ã€‚ æ•°å­¦å½’çº³æ³•ã€‚n=1n=1n=1 æ—¶æˆç«‹ï¼›n=mn=mn=m æˆç«‹æ—¶ï¼Œn=m+1n=m+1n=m+1 ä¹Ÿæˆç«‹ã€‚é‚£ä¹ˆå¯¹äºä»»æ„çš„ nnn å°±éƒ½æˆç«‹ã€‚ ç®€å•é¢˜ æ›´å¤šçš„é¢˜ä¼šåœ¨ Problemset ä¸­å‡ºç°ã€‚ [USACO07NOV] Sunscreen G Portal. æŒ‰ç…§ minSPF é€’å‡è¿›è¡Œæ’åºï¼Œæ¯æ¬¡æ‰¾èƒ½ç”¨çš„æœ€å¤§çš„é˜²æ™’éœœã€‚å¾®æ‰°å¯ä»¥è¯æ˜ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #define pint pair&lt;int, int> using namespace std; int c, l; pint a[2505], b[2505]; int main(void) &#123; scanf(\"%d%d\", &amp;c, &amp;l); for (int i = 1; i &lt;= c; ++i) scanf(\"%d%d\", &amp;a[i].first, &amp;a[i].second); for (int i = 1; i &lt;= l; ++i) scanf(\"%d%d\", &amp;b[i].first, &amp;b[i].second); sort(a + 1, a + c + 1, greater&lt;pint>()); sort(b + 1, b + l + 1, greater&lt;pint>()); int ans = 0; for (int i = 1; i &lt;= c; ++i) &#123; for (int j = 1; j &lt;= l; ++j) if (b[j].second &amp;&amp; b[j].first >= a[i].first &amp;&amp; b[j].first &lt;= a[i].second) &#123; b[j].second -= 1; ans += 1; break; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; [USACO06FEB] Stall Reservations S Portal. å°†æ¯ä¸€ä¸ªäº‹ä»¶æ‹†åˆ†æˆå¼€åƒå’Œç»“æŸåƒï¼Œç„¶åæ‰¾èƒ½åƒçš„æ”¾è¿›å»ã€‚å¯ä»¥è¯æ˜å†å¼€ä¸€ä¸ªçš„è¯ç»“æœä¸ä¼šæ›´å¥½ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;queue> #include &lt;algorithm> #include &lt;map> using namespace std; struct event &#123; int id, type, time; event(int id = 0, int type = 0, int time = 0) : id(id), type(type), time(time) &#123;&#125; bool operator &lt; (const event &amp;a) const &#123; return time &lt; a.time; &#125; &#125; a[100005]; struct fence &#123; int id, time; fence(int id = 0, int time = 0) : id(id), time(time) &#123;&#125; bool operator &lt; (const fence &amp;a) const &#123; return time > a.time; &#125; &#125;; int n, cnt; int use[100005]; priority_queue &lt;fence> q; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); a[(i &lt;&lt; 1) - 1] = event(i, 1, x); a[i &lt;&lt; 1] = event(i, 2, y); &#125; sort(a + 1, a + n * 2 + 1); cnt = 1; q.push(&#123;1, 0&#125;); for (int i = 1; i &lt;= n * 2; ++i) &#123; if (a[i].type == 1) &#123; if (q.empty() || q.top().time > a[i].time) &#123; cnt += 1; q.push(&#123;cnt, 0&#125;); &#125; int u = q.top().id; q.pop(); use[a[i].id] = u; &#125; else q.push(&#123;use[a[i].id], a[i].time + 1&#125;); &#125; printf(\"%d\\n\", cnt); for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", use[i]); return 0; &#125; [UVA1193] Radar Installation Portal. æ¯ä¸€ä¸ªå»ºç­‘èƒ½è¢«å“ªä¸ªåŒºé—´çš„ç›‘è§†å™¨ç›‘è§†æ˜¯å¯ä»¥é¢„å¤„ç†çš„ï¼Œç„¶åå°†èŒƒå›´æŒ‰ç…§å·¦ç«¯ç‚¹æ’åºï¼Œä»¥æ­¤è€ƒè™‘æ˜¯å¦èƒ½ç›‘è§†ï¼Œèƒ½ç›‘è§†å°±ç›‘è§†ã€‚ å› ä¸ºå¦‚æœä¸ç›‘è§†è€Œè¦æ–°å»ºçš„è¯ï¼Œæœªæ¥ä¹Ÿæ˜¯å¯ä»¥æ–°å»ºçš„ï¼Œç°åœ¨å°±ç›‘è§†å¹¶ä¸ä¼šä¸¢å¤±è§£ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> #include &lt;algorithm> #define pdb pair&lt;double, double> #define L first #define R second using namespace std; int n, d; pdb a[1005]; int main(void) &#123; int kase = 0; while (scanf(\"%d%d\", &amp;n, &amp;d) == 2 &amp;&amp; n) &#123; bool flag = true; for (int i = 1; i &lt;= n; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); double t = d * d - y * y; if (t &lt; 0) flag = false; t = sqrt(t); a[i].L = x - t, a[i].R = x + t; &#125; if (!flag) &#123; printf(\"Case %d: -1\\n\", ++kase); continue; &#125; sort(a + 1, a + n + 1); int ans = 1; double pos = a[1].R; for (int i = 2; i &lt;= n; ++i) &#123; if (pos >= a[i].L) pos = min(pos, a[i].R); else pos = a[i].R, ++ans; &#125; printf(\"Case %d: %d\\n\", ++kase, ans); &#125; return 0; &#125; [NOIP2012 æé«˜ç»„] å›½ç‹æ¸¸æˆ Portal. æ°é€¢ H å›½å›½åº†ï¼Œå›½ç‹é‚€è¯· n(nâ‰¤1000)n(n\\le 1000)n(nâ‰¤1000) ä½å¤§è‡£æ¥ç©ä¸€ä¸ªæœ‰å¥–æ¸¸æˆã€‚é¦–å…ˆï¼Œä»–è®©æ¯ä¸ªå¤§è‡£åœ¨å·¦ã€å³æ‰‹ä¸Šé¢åˆ†åˆ«å†™ä¸‹ä¸€ä¸ªæ•´æ•°ï¼Œå›½ç‹è‡ªå·±ä¹Ÿåœ¨å·¦ã€å³æ‰‹ä¸Šå„å†™ä¸€ä¸ªæ•´æ•°ã€‚ç„¶åï¼Œè®©è¿™ nnn ä½å¤§è‡£æ’æˆä¸€æ’ï¼Œå›½ç‹ç«™åœ¨é˜Ÿä¼çš„æœ€å‰é¢ã€‚æ’å¥½é˜Ÿåï¼Œæ‰€æœ‰çš„å¤§è‡£éƒ½ä¼šè·å¾—å›½ç‹å¥–èµçš„è‹¥å¹²é‡‘å¸ï¼Œæ¯ä½å¤§è‡£è·å¾—çš„é‡‘å¸æ•°åˆ†åˆ«æ˜¯ï¼šæ’åœ¨è¯¥å¤§è‡£å‰é¢çš„æ‰€æœ‰äººçš„å·¦æ‰‹ä¸Šçš„æ•°çš„ä¹˜ç§¯é™¤ä»¥ä»–è‡ªå·±å³æ‰‹ä¸Šçš„æ•°ï¼Œç„¶åå‘ä¸‹å–æ•´å¾—åˆ°çš„ç»“æœã€‚å›½ç‹ä¸å¸Œæœ›æŸä¸€ä¸ªå¤§è‡£è·å¾—ç‰¹åˆ«å¤šçš„å¥–èµï¼Œæ‰€ä»¥ä»–æƒ³è¯·ä½ å¸®ä»–é‡æ–°å®‰æ’ä¸€ä¸‹é˜Ÿä¼çš„é¡ºåºï¼Œä½¿å¾—è·å¾—å¥–èµæœ€å¤šçš„å¤§è‡£ï¼Œæ‰€è·å¥–èµå°½å¯èƒ½çš„å°‘ã€‚æ³¨æ„ï¼Œå›½ç‹çš„ä½ç½®å§‹ç»ˆåœ¨é˜Ÿä¼çš„æœ€å‰é¢ã€‚ å¤§èƒ†å‡è®¾ï¼Œå°å¿ƒæ±‚è¯ï¼šæŒ‰ç…§å·¦å³æ‰‹ä¸Šçš„æ•°çš„ä¹˜ç§¯ä»å°åˆ°å¤§æ’åºã€‚ æˆ‘ä»¬é‡‡ç”¨å¾®æ‰°æ³•æ¥è¯æ˜ï¼Œäº¤æ¢å¤§è‡£ iii å’Œ i+1i+1i+1ï¼ŒåŸæ¥çš„å¥–åŠ±æ˜¯ï¼š 1B[i]âˆj=0iâˆ’1A[j]A[i]B[i+1]âˆj=0iâˆ’1A[j]\\frac{1}{B[i]}\\prod_{j=0}^{i-1} A[j]\\\\ \\frac{A[i]}{B[i+1]}\\prod_{j=0}^{i-1} A[j] B[i]1â€‹j=0âˆiâˆ’1â€‹A[j]B[i+1]A[i]â€‹j=0âˆiâˆ’1â€‹A[j] äº¤æ¢åçš„å¥–åŠ±æ˜¯ï¼š 1B[i+1]âˆj=0iâˆ’1A[j]A[i+1]B[i]âˆj=0iâˆ’1A[j]\\frac{1}{B[i+1]}\\prod_{j=0}^{i-1}A[j]\\\\ \\frac{A[i+1]}{B[i]}\\prod_{j=0}^{i-1}A[j] B[i+1]1â€‹j=0âˆiâˆ’1â€‹A[j]B[i]A[i+1]â€‹j=0âˆiâˆ’1â€‹A[j] å…¶å®ƒå¥–åŠ±å¹¶ä¸å˜ï¼Œæˆ‘ä»¬åªéœ€è¦æ¯”è¾ƒä¸Šé¢ä¸¤ä¸ªï¼Œå³æ¯”è¾ƒï¼š maxâ¡{1B[i],A[i]B[i+1]}maxâ¡{1B[i+1],A[i+1]B[i]}\\max\\left\\{\\frac{1}{B[i]},\\frac{A[i]}{B[i+1]}\\right\\}\\\\ \\max\\left\\{\\frac{1}{B[i+1]},\\frac{A[i+1]}{B[i]}\\right\\} max{B[i]1â€‹,B[i+1]A[i]â€‹}max{B[i+1]1â€‹,B[i]A[i+1]â€‹} é€šåˆ†å¾—åˆ°ï¼š maxâ¡{B[i+1],A[i]Ã—B[i]}maxâ¡{B[i],A[i+1]Ã—B[i+1]}\\max\\{B[i+1],A[i]\\times B[i]\\}\\\\ \\max\\{B[i],A[i+1]\\times B[i+1]\\} max{B[i+1],A[i]Ã—B[i]}max{B[i],A[i+1]Ã—B[i+1]} åˆ†ç±»è®¨è®ºæ¯”è¾ƒå¤§å°åå‘ç°å‰è€…ä¸ä¼šæ¯”åè€…å·®ã€‚ æœ¬é¢˜éœ€è¦é«˜ç²¾ï¼Œä»£ç å·æ‡’äº†ã€‚ æŸ¥çœ‹ä»£ç  n = int(input()) a, b = map(int, input().split()) ans = [] for i in range(n): ans.append([int(ii) for ii in input().split()]) ans.sort(key=lambda x: (x[0] * x[1])) s = 0 for i in range(n): s = max(s, a // ans[i][1]) a *= ans[i][0] print(s) Problemset æˆ‘ä»¬æ¥çœ‹ä¸€äº›é¢˜ç›®ã€‚ åŒæŒ‡é’ˆ è¿™é‡Œçš„åŒæŒ‡é’ˆå¯èƒ½ä¼šç¨å¾®éš¾ä¸€äº›ã€‚ [Luogu P5745] æ•°åˆ—æ±‚å’Œ Portal. è™½ç„¶å¯ä»¥ç”¨äºŒåˆ†åšåˆ° O(nlogâ¡n)O(n \\log n)O(nlogn)ï¼Œç„¶è€Œå¹¶ä¸æ¨èè¿™æ ·åšï¼Œå› ä¸ºè¿˜æœ‰å†™èµ·æ¥æ›´ç®€å•è·‘èµ·æ¥ä¹Ÿæ›´å¿«çš„ O(n)O(n)O(n) åšæ³•ã€‚ æˆ‘ä»¬å…ˆå®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ l=r=1l=r=1l=r=1ï¼Œå¦‚æœâˆ‘i=lri&lt;m\\sum\\limits_{i=l}^{r}i &lt; mi=lâˆ‘râ€‹i&lt;mï¼Œé‚£ä¹ˆä»¤ r++ï¼Œå¦åˆ™ä»¤ l++ï¼Œå¯çœ‹å‡ºæ•°åˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½è¢«æ‰«äº†å¸¸æ•°æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦O(n)O(n)O(n)ã€‚ ç›¸æ¯” O(n2)O(n^2)O(n2) çš„æšä¸¾ï¼Œå°‘æšä¸¾äº†ä¸å°‘ä¸å¯èƒ½æˆä¸ºç­”æ¡ˆçš„è§£ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #define LL long long using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m; int a[4000005]; LL sum[4000005]; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(), sum[i] = sum[i-1] + a[i]; //è®¡ç®—å‰ç¼€å’Œ int l = 1, r = 1, L, R; LL ans = -1; while (r &lt;= n) &#123; while (sum[r] - sum[l-1] &lt;= m) &#123; if (sum[r] - sum[l-1] > ans) &#123; ans = sum[r] - sum[l-1]; L = l, R = r; &#125; ++r; &#125; ++l; &#125; printf(\"%d %d %lld\", L, R, ans); return 0; &#125; [ARC 098B] Xor Sum 2 Portal. ä»€ä¹ˆæ—¶å€™åŠ å’Œå’Œå¼‚æˆ–å’Œç›¸ç­‰ï¼Ÿåªæœ‰å½“å¼‚æˆ–çš„æ—¶å€™ä¸å­˜åœ¨ä¸¤ä¸ªäºŒè¿›åˆ¶ä½éƒ½æ˜¯ 111 çš„æ—¶å€™ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœå³ç«¯ç‚¹å›ºå®šï¼Œç¼©å°å·¦ç«¯ç‚¹ï¼Œé‚£ä¹ˆè¿™æ ·ä¸¤ä¸ªäºŒè¿›åˆ¶ä½éƒ½æ˜¯ 111 çš„æƒ…å†µæ˜¯åªèƒ½å˜å°‘æˆ–ä¸å˜ï¼Œä¸èƒ½å˜å¤šçš„ã€‚é‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨å°ºå–æ³•äº†ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, s1, s2; int a[200005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); i64 ans = 0; for (int L = 1, R = 0; L &lt;= n; ++L) &#123; while (R &lt; n &amp;&amp; s1 + a[R + 1] == (s2 ^ a[R + 1])) ++R, s1 += a[R], s2 ^= a[R]; ans += R - L + 1; s1 -= a[L], s2 ^= a[L]; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [CEOI2017] Sure Bet Portal. å¦‚æœéƒ½å–ä¸€ä¸ªç¯æ³¡ï¼Œæˆ‘ä»¬è‚¯å®šæ˜¯å–æƒå€¼æ›´å¤§çš„æ›´å¥½ï¼Œæ‰€ä»¥å…ˆæ’åºã€‚Aã€B çš„å’Œè‚¯å®šæ˜¯å¹³å‡å¥½ï¼Œæ‰€ä»¥ç”¨åŒæŒ‡é’ˆåŒæ—¶æ‰«æ ABï¼Œè®°å½•å½“å‰çš„å’Œï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªå¤§äº†å°±ç§»åŠ¨å¦ä¸€ä¸ªæŒ‡é’ˆã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n; double a[100005], b[100005], suma[100005], sumb[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lf%lf\", a + i, b + i); sort(a + 1, a + n + 1, greater&lt;double>()); sort(b + 1, b + n + 1, greater&lt;double>()); for (int i = 1; i &lt;= n; ++i) &#123; suma[i] = suma[i - 1] + a[i]; sumb[i] = sumb[i - 1] + b[i]; &#125; double ans = 0.0; for (int i = 1, j = 1; i &lt;= n &amp;&amp; j &lt;= n;) &#123; ans = max(ans, min(suma[i] - i - j, sumb[j] - i - j)); if (suma[i] &lt;= sumb[j]) ++i; else ++j; &#125; printf(\"%.4lf\\n\", ans); return 0; &#125; [CF939E] Maximize! Portal. æœ€å¤§çš„è‚¯å®šè¦é€‰ï¼Œå†é€‰è‹¥å¹²ä¸ªæœ€å°çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; int n, L = -1, maxn = 0; i64 sum = 0; vector &lt;int> a; int main(void) &#123; scanf(\"%d\", &amp;n); while (n--) &#123; int op, x; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%d\", &amp;x); a.push_back(x); sum += x - maxn; maxn = x; while (L + 1 &lt; a.size() &amp;&amp; 1ll * a[L + 1] * (L + 2) &lt; sum) sum += a[++L]; &#125; else &#123; if (L == -1) puts(\"0\"); else printf(\"%.6lf\\n\", maxn - (double)sum / double(L + 2)); &#125; &#125; return 0; &#125; [NOIP2011 æé«˜ç»„] é€‰æ‹©å®¢æ ˆ Portal. æšä¸¾å³æŒ‡é’ˆï¼Œå½“ä¸€ä¸ªå®¢æ ˆå¯ä»¥è¢«ç”¨æ¥å–å’–å•¡æ—¶ï¼Œå°±ç§»åŠ¨å·¦æŒ‡é’ˆæ›´æ–°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, k, p, t = 1; int color[200005]; int cnt[200005]; // å½“å‰ cnt[i] è¡¨ç¤ºé¢œè‰²ä¸º i çš„å®¢æ ˆçš„æ•°ç›® i64 ans = 0; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;k, &amp;p); for (int i = 1, money; i &lt;= n; ++i) &#123; scanf(\"%d%d\", color + i, &amp;money); if (money &lt;= p) &#123; // åˆ° i ä¸ºæ­¢çš„å®¢æ ˆéƒ½å¯ä»¥æ»¡è¶³å–å’–å•¡çš„æ¡ä»¶äº† for (int j = t; j &lt;= i; ++j) ++cnt[color[j]]; t = i + 1; ans += cnt[color[i]] - 1; // ä¸èƒ½é€‰æ‹©åŒä¸€ä¸ªå®¢æ ˆ &#125; else ans += cnt[color[i]]; &#125; printf(\"%lld\\n\", ans); return 0; &#125; å‰ç¼€å’Œä¸å·®åˆ† å‰ç¼€å’Œä¸å·®åˆ†å¾ˆé‡è¦ï¼Œå‡ºç°æ¦‚ç‡å¾ˆé«˜ã€‚ [USACO05JAN] Moo Volume S Portal. ç»å¯¹å€¼å¾ˆçƒ¦äººï¼Œæ‰€ä»¥è€ƒè™‘æ’åºã€‚åªè®¡ç®—å½“å‰ iii åŠä»¥å‰çš„ï¼Œæœ€åå°†ç»“æœä¹˜ä»¥äºŒã€‚é€šè¿‡æ‰¾è§„å¾‹å‘ç° ansi=aiÃ—(iâˆ’1)âˆ’siâˆ’1ans_i=a_i\\times (i-1)-s_{i-1}ansiâ€‹=aiâ€‹Ã—(iâˆ’1)âˆ’siâˆ’1â€‹ï¼Œä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n; int a[100005]; long long sum[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + a[i]; long long ans = 0; for (int i = 1; i &lt;= n; ++i) ans += (long long)a[i] * (i - 1) - sum[i - 1]; printf(\"%lld\\n\", ans * 2); return 0; &#125; [USACO16JAN] Subsequences Summing to Sevens S Portal. åŒºé—´å’Œï¼Œå‰ç¼€å’Œï¼ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬è¦ä½¿å¾— 7âˆ£(s[r]âˆ’s[lâˆ’1])7\\mid (s[r]-s[l-1])7âˆ£(s[r]âˆ’s[lâˆ’1])ï¼Œè¦æ±‚æœ€å¤§çš„ râˆ’lr-lrâˆ’lã€‚ æ ¹æ®å–æ¨¡çš„æ€§è´¨ï¼Œå¯ä»¥è½¬åŒ–ä¸º s[r]â‰¡s[lâˆ’1](mod7)s[r]\\equiv s[l-1] \\pmod 7s[r]â‰¡s[lâˆ’1](mod7)ï¼Œé‚£ä¹ˆå¼€ä¸¤ä¸ªæ•°ç»„ L, Rï¼Œæ‰«åˆ° s[i]ï¼Œå°±å°†å…¶è®¡å…¥æ•°ç»„ä¸­ã€‚å…·ä½“è¿‡ç¨‹è§ä»£ç ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, x, sum = 0, ans = 0; int l[7] = &#123;0, -1, -1, -1, -1, -1, -1&#125;, r[7] = &#123;0, -1, -1, -1, -1, -1, -1&#125;; // l[i] å­˜ mod 7 ä¸º i çš„æœ€å° l - 1 , r[i] å­˜ mod 7 ä¸º i çš„æœ€å¤§ r // å¼€å§‹æ—¶ s[0] = 0, s[0] mod 7 = 0ï¼Œæ‰€ä»¥ l[0] = r[0] = 0 scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); sum = (sum + x) % 7; // åˆ©ç”¨éšæ—¶å–æ¨¡æ€§è´¨ if (l[sum] == -1) l[sum] = i; // ç¬¬ä¸€æ¬¡æ‰«åˆ°çš„è‚¯å®šæœ€å° r[sum] = i; // æœ€åä¸€æ¬¡æ‰«åˆ°çš„è‚¯å®šæœ€å¤§ &#125; for (int i = 0; i &lt; 7; ++i) ans = max(ans, r[i] - l[i]); printf(\"%d\\n\", ans); return 0; &#125; [NOIP2012 æé«˜ç»„] å€Ÿæ•™å®¤ Portal. å€Ÿæ•™å®¤çš„è¿™ä¸€è¿‡ç¨‹å¾ˆå®¹æ˜“ç”¨å·®åˆ†æ¥è¿›è¡Œã€‚æˆ‘ä»¬åªéœ€è¦çŸ¥é“éœ€è¦é€šçŸ¥å“ªä¸€ä¸ªç”³è¯·äººä¿®æ”¹è®¢å•ã€‚å¯ä»¥ä½¿ç”¨äºŒåˆ†ç­”æ¡ˆçš„æ–¹å¼æ¥åˆ¤æ–­æ˜¯å“ªä¸€ä¸ªäººã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m, r[1000005]; int c[1000005], sum[1000005], d[1000005], s[1000005], t[1000005]; bool solve(int x) &#123; for (int i = 1; i &lt;= n; ++i) c[i] = r[i] - r[i - 1]; for (int i = 1; i &lt;= x; ++i) &#123; c[s[i]] -= d[i]; c[t[i] + 1] += d[i]; &#125; for (int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + c[i]; for (int i = 1; i &lt;= n; ++i) if (sum[i] &lt; 0) return 0; return 1; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) r[i] = read(); for (int i = 1; i &lt;= m; ++i) d[i] = read(), s[i] = read(), t[i] = read(); if (solve(m)) puts(\"0\"); else &#123; puts(\"-1\"); int L = 0, R = m + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (solve(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", R); &#125; return 0; &#125; [NOIP2011 æé«˜ç»„] èªæ˜çš„è´¨ç›‘å‘˜ Portal. æ³¨æ„åˆ°è¿™ä¸ªæ¡ä»¶ï¼šwjâ‰¥Ww_j \\ge Wwjâ€‹â‰¥Wã€‚WWW è¶Šå°ï¼Œå¾—åˆ°çš„ yyy å°±è¶Šå¤§ï¼Œå…·æœ‰å•è°ƒæ€§ï¼Œå› æ­¤å¯ä»¥äºŒåˆ†ç­”æ¡ˆï¼Œæˆ‘ä»¬åªè¦æ‰¾åˆ° y,sy,sy,s å¤§å°çš„åˆ†ç•Œç‚¹å³å¯ã€‚ç°åœ¨çš„é—®é¢˜å°±æ˜¯å¦‚ä½•åœ¨çº¿æ€§æ—¶é—´å†…è®¡ç®—å‡º yyyã€‚ å‰ç¼€å’Œå°±å¯ä»¥è½»æ¾å®Œæˆã€‚æŸ¥è¯¢çš„å†…å®¹æ˜¯å…¸å‹çš„å¤šæ¬¡æŸ¥è¯¢åŒºé—´å’Œï¼ˆæ¯ä¸ª yyy éƒ½æ˜¯ä¸¤ä¸ªåŒºé—´å’Œç›¸ä¹˜ï¼‰ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; using i64 = long long; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m; i64 s, ans = 1000000000005; int w[200005], v[200005]; int l[200005], r[200005]; i64 sum[200005], sumv[200005]; bool P(int W) &#123; for (int i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i-1] + (w[i] >= W); sumv[i] = sumv[i-1] + (w[i] >= W ? v[i] : 0); &#125; i64 y = 0; for (int i = 1; i &lt;= m; ++i) y += (sum[r[i]] - sum[l[i] - 1]) * (sumv[r[i]] - sumv[l[i] - 1]); i64 ret = llabs(y - s); if (ret &lt; ans) ans = ret; if (y > s) return 1; else return 0; &#125; int main(void) &#123; n = read(), m = read(); cin >> s; int minw = 1000005, maxw = 0; for (int i = 1; i &lt;= n; ++i) &#123; w[i] = read(), v[i] = read(); minw = min(minw, w[i]); maxw = max(maxw, w[i]); &#125; for (int i = 1; i &lt;= m; ++i) l[i] = read(), r[i] = read(); int L = minw - 1, R = maxw + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) L = mid; else R = mid; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [USACO07MAR] Face The Right Way G Portal. æ³¨æ„åˆ°æ•°æ®èŒƒå›´åªæœ‰ 500050005000ï¼Œå®¹æ˜“æƒ³åˆ°è¦ç”¨ä¸€ä¸ª O(n2)O(n^2)O(n2) ç®—æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æšä¸¾ KKKï¼Œé—®é¢˜å°±å˜æˆäº†å¦‚ä½•åœ¨çº¿æ€§æ—¶é—´å†…è®¡ç®—è¿™ä¸ª KKK èƒ½å¦å®Œæˆä»»åŠ¡ã€‚ ä»å‰åˆ°åè¿›è¡Œæ‰«æã€‚å¦‚æœé‡åˆ°äº†ä¸€ä¸ª Bï¼Œé‚£ä¹ˆè‚¯å®šè¦è¿›è¡Œä»¥å®ƒä¸ºèµ·ç‚¹çš„ç¿»è½¬ï¼Œå¦åˆ™æ‰«æåˆ°åé¢å®ƒå°±å†ä¹Ÿæ— åŠ›ç¿»èº«äº†ã€‚è¿™æ ·å¯ä»¥è¿›è¡Œæ¨¡æ‹Ÿï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n2)O(n^2)O(n2)ï¼Œéœ€è¦è¿›è¡Œä¼˜åŒ–ã€‚ è€ƒè™‘å·®åˆ†ã€‚å·®åˆ†è¿˜å¯ä»¥è¿™ä¹ˆåšï¼šå»ºç«‹å¦ä¸€ä¸ªæ•°ç»„æ¥è®°å½•å˜åŒ–ï¼Œè€Œä¸æ˜¯å¯¹ç€åŸåºåˆ—è¿›è¡Œå·®åˆ†ã€‚ç”±äºåªæœ‰ 0, 1 ä¸¤ç§æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å¼‚æˆ–æ¥ç®€åŒ–è¿ç®—ã€‚è®¾ b[i]b[i]b[i] ä»£è¡¨ iii ä»¥åçš„å…ƒç´ éƒ½è¦å¼‚æˆ–ä¸Š b[i]b[i]b[i]ï¼Œç»™ [i,i+kâˆ’1][i, i + k - 1][i,i+kâˆ’1] è¿›è¡Œç¿»è½¬ï¼Œåªéœ€è¦ b[i] ^= 1, b[i + k] ^= 1 å³å¯ï¼Œå¦å¤–å†ç”¨ä¸€ä¸ª c è®°å½•å½“å‰çš„çŠ¶æ€ï¼Œæ¥åˆ¤æ–­å½“å‰æ‰«æåˆ°çš„æ˜¯ 1 è¿˜æ˜¯ 0ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; int a[5005], b[5005]; int main(void) &#123; scanf(\"%d\", &amp;n); char s[5]; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", s); a[i] = (s[0] == 'F'); &#125; int mink = 0, minres = 1000000; for (int k = 1; k &lt;= n; ++k) &#123; memset(b, 0, sizeof(b)); bool c = 0, flag = true; int res = 0; for (int i = 1; i &lt;= n; ++i) &#123; c ^= b[i]; if ((a[i] ^ c) == 0) &#123; if (i + k - 1 > n) &#123; flag = false; break; &#125; b[i] ^= 1, b[i + k] ^= 1; c ^= 1, ++res; &#125; &#125; if (flag &amp;&amp; res &lt; minres) minres = res, mink = k; &#125; printf(\"%d %d\\n\", mink, minres); return 0; &#125; [Poetize6] IncDec Sequence Portal. åŒºé—´åŠ å‡è¿™ç§æ“ä½œå·²ç»å¾ˆç†Ÿæ‚‰äº†ï¼Œè‚¯å®šæ˜¯æŠŠåŸåºåˆ—åšæˆå·®åˆ†åºåˆ—è¿›è¡Œè®¡ç®—ï¼Œé—®é¢˜å°±å˜æˆäº†ï¼šç»™å®šä¸€ä¸ªåºåˆ— BBBï¼Œå¯ä»¥æ¯æ¬¡é€‰æ‹©ä¸€å¯¹æ•°ï¼Œä¸€ä¸ª +1ï¼Œä¸€ä¸ª -1ï¼Œä½¿å¾— B2â‹¯BnB_2\\cdots B_nB2â€‹â‹¯Bnâ€‹ éƒ½ä¸º 000ã€‚æ³¨æ„ B1B_1B1â€‹ å¯¹ç»“æœæ²¡æœ‰å½±å“ï¼Œæˆ‘ä»¬è®¡ç®—æ—¶ä¹Ÿå¯ä»¥é€‰æ‹© Bn+1B_{n+1}Bn+1â€‹ã€‚ æˆ‘ä»¬å°½å¯èƒ½åœ°é€‰æ‹© B2â‹¯BnB_2\\cdots B_nB2â€‹â‹¯Bnâ€‹ è¿›è¡Œæ“ä½œï¼Œè¿™æ ·å¯ä»¥å°½å¿«åœ°æ¥è¿‘ç›®æ ‡ã€‚è¿˜æœ‰å‰©ä½™æ€ä¹ˆåŠï¼Ÿé‚£å°±è·Ÿ B1B_1B1â€‹ æˆ– Bn+1B_{n+1}Bn+1â€‹ é…å¯¹å°±å¯ä»¥äº†ã€‚è®¾ B2â‹¯BnB_2\\cdots B_nB2â€‹â‹¯Bnâ€‹ ä¸­æ­£æ•°å’Œä¸º pppï¼Œè´Ÿæ•°å’Œä¸º qqqï¼Œåˆ™å‰è€…å¯ä»¥è¿›è¡Œ minâ¡(p,q)\\min(p,q)min(p,q) æ¬¡ï¼Œåè€…è¿›è¡Œ âˆ£pâˆ’qâˆ£\\left|p-q\\right|âˆ£pâˆ’qâˆ£ æ¬¡ï¼Œæ€»å…±æ˜¯ maxâ¡(p,q)\\max(p,q)max(p,q) æ¬¡ã€‚æ ¹æ®æ˜¯å¦é€‰æ‹© B1B_1B1â€‹ è¿›è¡Œé…å¯¹ï¼Œå¾—åˆ°çš„åºåˆ—å…±æœ‰ âˆ£pâˆ’qâˆ£+1\\left|p-q\\right|+1âˆ£pâˆ’qâˆ£+1 ç§ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cmath> using namespace std; using i64 = long long; int n; i64 a[100005], b[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) b[i] = a[i] - a[i - 1]; int p = 0, q = 0; for (int i = 2; i &lt;= n; ++i) if (b[i] >= 0) p += b[i]; else q -= b[i]; printf(\"%lld\\n%lld\\n\", max(p, q), abs(p - q) + 1); return 0; &#125; [CF1700C] Helping the Nature Portal. ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— AAAï¼Œæ”¯æŒä»¥ä¸‹ä¸‰ç§æ“ä½œï¼šå°† A1,â€¦,AiA_1,\\dots,A_iA1â€‹,â€¦,Aiâ€‹ éƒ½å‡å»ä¸€ï¼›å°† Ai,â€¦,AnA_i,\\dots,A_nAiâ€‹,â€¦,Anâ€‹ éƒ½å‡å»ä¸€ï¼›å…¨å±€åŠ ä¸Šä¸€ã€‚ å°†åºåˆ—å·®åˆ†ï¼Œé‚£ä¹ˆå‰ä¸¤ç§æ“ä½œå¯¹åº”ï¼š Bi+1B_{i+1}Bi+1â€‹ åŠ ä¸Šä¸€ï¼› BiB_{i}Biâ€‹ å‡å»ä¸€ã€‚ é‚£ä¹ˆé™¤äº†ç¬¬ä¸€ä¸ªæ•°ï¼Œå‰©ä¸‹çš„æ‰€æœ‰æ•°æˆ‘ä»¬éƒ½å¯ä»¥å°†å…¶å˜æˆ 000ï¼Œè¿™æ ·åºåˆ—ä¸­çš„æ‰€æœ‰æ•°éƒ½ç›¸ç­‰ï¼ŒæŠŠç¬¬ä¸€ä¸ªæ•°ä½œä¸ºâ€œæ ‡å‡†â€è¿›è¡Œç»´æŠ¤å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[200005], b[200005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; b[i] = a[i] - a[i - 1]; &#125; i64 ans = 0, h = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; ans += abs(b[i]); if (b[i] &lt; 0) h += b[i]; &#125; cout &lt;&lt; ans + abs(h) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; [USACO07JAN] Tallest Cow S Portal. è¦æ±‚æ‰€æœ‰çš„å¥¶ç‰›éƒ½å°½å¯èƒ½çš„é«˜ã€‚å› æ­¤ç»™äº† a,ba,ba,bï¼Œå°±æ„å‘³ç€å®ƒä»¬ä¹‹é—´çš„å¥¶ç‰›éƒ½æ¯”ä»–ä»¬ä½ 111ï¼Œç”¨å·®åˆ†ç»´æŠ¤å³å¯ã€‚æ³¨æ„å¯èƒ½æœ‰é‡å¤çš„æ¡ä»¶ï¼Œæ‰€ä»¥è¦ç”¨ä¸€ä¸ª set åˆ¤é‡ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;set> #include &lt;algorithm> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; int n, p, h, r, d[10005], s[10005]; set &lt;pii> us; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;p, &amp;h, &amp;r); while (r--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if (a > b) swap(a, b); if (us.find(make_pair(a, b)) != us.end()) continue; us.insert(make_pair(a, b)); --d[a + 1], ++d[b]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; s[i] = s[i - 1] + d[i]; printf(\"%d\\n\", s[i] + h); &#125; return 0; &#125; [Codeforcs 1703F] Yet Another Problem About Pairs Satisfying an Inequality Portal. å¯¹ä¸ç­‰å¼è¿›è¡Œæ‹†è§£ï¼Œå¾—åˆ° ai&lt;ia_i&lt;iaiâ€‹&lt;iï¼Œaj&lt;ja_j&lt;jajâ€‹&lt;j å’Œ i&lt;aji &lt; a_ji&lt;ajâ€‹ ä¸‰ä¸ªä¸ç­‰å¼ã€‚å‰ä¸¤ä¸ªå¾ˆå®¹æ˜“åˆ¤æ–­ï¼Œç¬¬ä¸‰ä¸ªè€ƒè™‘æš´åŠ›ç®—æ³•ï¼Œæšä¸¾ i,ji,ji,j å¯ä»¥è½»æ¾å¾—åˆ°ç­”æ¡ˆã€‚ å¯¹æ­¤è¿›è¡Œä¼˜åŒ–ã€‚i&lt;aji &lt; a_ji&lt;ajâ€‹ å˜å½¢ä¸º ajâ‰¥i+1a_j\\ge i+1ajâ€‹â‰¥i+1ï¼ˆå› ä¸ºéƒ½æ˜¯æ•´æ•°ï¼‰ã€‚ é™¤äº†å‰ç¼€å’Œï¼Œè¿˜æœ‰åç¼€å’Œï¼Œå°±æ˜¯è¡¨ç¤ºå®ƒåé¢è€Œä¸æ˜¯å‰é¢çš„å’Œã€‚ajâ‰¥i+1a_j\\ge i+1ajâ€‹â‰¥i+1 å…·æœ‰æ˜æ˜¾çš„è¿™ç§æ€§è´¨ï¼Œè¦æ±‚çš„å°±æ˜¯æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„æ•°çš„ä¸ªæ•°ï¼Œç»´æŠ¤å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; using i64 = long long; int n, t; int a[200005]; i64 sum[200005]; int main(void) &#123; scanf(\"%d\", &amp;t); while (t--) &#123; memset(sum, 0, sizeof(sum)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] &lt; i) ++sum[a[i]]; // æ»¡è¶³åŸºæœ¬æ¡ä»¶ï¼Œå°†è¿™ä¸ª sum +1 &#125; for (int i = n; i >= 1; --i) // è®¡ç®—åç¼€å’Œ sum[i] += sum[i + 1]; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &lt; i) ans += sum[i + 1]; // a[j] >= i+1 printf(\"%lld\\n\", ans); &#125; return 0; &#125; [USACO11MAR] Brownie Slicing G Portal. åˆ‡çš„åˆ€è¶Šå¤šï¼Œæ¯å¤´ç‰›åˆ†çš„å°±è¶Šå°‘ï¼Œæ»¡è¶³å•è°ƒæ€§ï¼Œè€ƒè™‘äºŒåˆ†ç­”æ¡ˆã€‚ äºŒåˆ† Bessie èƒ½å¾—åˆ°çš„ç¢å±‘æ•°ç›®ã€‚é€šè¿‡æš´åŠ›è®¡ç®—ä½¿å¾—å…¶å®ƒå¥¶ç‰›åˆ†çš„æ•°ç›®éƒ½å¤§äºç­‰äºå¥¹ï¼Œè‹¥æœ€åæ¨ªç€åˆ‡çš„åˆ€æ•°å¤§äº aaaï¼ˆè¯´æ˜è¿™äº›è›‹ç³•å¤Ÿåˆ†ç»™æ›´å¤šçš„å¥¶ç‰›ï¼ŒBessie åˆ†å°‘äº†ï¼‰ï¼Œå°±å¯ä»¥ã€‚å…¶ä¸­éœ€è¦ç”¨äºŒç»´å‰ç¼€å’Œæ¥ä¼˜åŒ–ã€‚ä»£ç å¦‚ä¸‹ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int r, c, a, b; int s[505][505]; int calc(int x1, int y1, int x2, int y2) &#123; return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; &#125; bool P(int x) &#123; int cuta = 0, row = 1; for (int i = 1; i &lt;= r; ++i) &#123; int col = 1, cutb = 0; for (int j = 1; j &lt;= c; ++j) &#123; if (calc(row, col, i, j) >= x) col = j + 1, ++cutb; &#125; if (cutb >= b) ++cuta, row = i + 1; &#125; return cuta >= a; &#125; int main(void) &#123; r = read(), c = read(), a = read(), b = read(); for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + read(); int L = -1 , R = s[r][c] + 1; while (L + 1 != R) &#123; int mid = (L + R) / 2, ss; if (P(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", L); return 0; &#125; å•è°ƒæ ˆ æ¯”è¾ƒç®€å•ã€‚ [USACO06NOV] Bad Hair Day S Portal. å¯ä»¥çœ‹å‡ºè¿™æ˜¯ä¸€ä¸ªå•è°ƒæ ˆï¼Œæ¯ä¸ªæ•°çš„ç­”æ¡ˆå°±æ˜¯æ ˆçš„å¤§å°ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, tot; int a[80005], s[80005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); i64 ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (tot &amp;&amp; s[tot] &lt;= a[i]) --tot; ans += tot; s[++tot] = a[i]; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [POI2008] PLA-Postering Portal. æ³¨æ„åˆ°å®½åº¦ä¸ç­”æ¡ˆæ²¡æœ‰å…³ç³»ï¼Œè€Œé«˜åº¦ç›¸åŒçš„å¯ä»¥ä½¿ç”¨ä¸€å¼ æµ·æŠ¥ã€‚æˆ‘ä»¬ä½¿ç”¨å•è°ƒæ ˆæ¥è¿›è¡Œç»´æŠ¤ï¼Œå¦‚æœè¿›æ¥äº†ä¸€ä¸ªå…ƒç´ ä¸æ¯”æ ˆé¡¶å¤§ï¼Œé‚£ä¹ˆæ˜¯æœ‰æœºä¼šåˆå¹¶çš„ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int w[250005]; int s[250005], tot = 0; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, d; i &lt;= n; ++i) scanf(\"%d%d\", &amp;d, w + i); int ans = n; for (int i = 1; i &lt;= n; ++i) &#123; while (tot &amp;&amp; w[i] &lt;= s[tot]) &#123; if (w[i] == s[tot]) --ans; --tot; &#125; s[++tot] = w[i]; &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1950] é•¿æ–¹å½¢ Portal. ä»ä¸Šåˆ°ä¸‹æ‰«ææ¯ä¸€è¡Œï¼Œç»Ÿè®¡â€œå‘ä¸Šæœ€å¤šèƒ½å»¶ä¼¸çš„é«˜åº¦â€ï¼Œç„¶åæ‰¾åˆ°å·¦é¢ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„ï¼Œå³é¢ç¬¬ä¸€ä¸ªå°äºç­‰äºçš„ï¼Œå°±å¯ä»¥è®¡ç®—å‡ºå½“å‰è´¡çŒ®ã€‚å•è°ƒæ ˆå¯ä»¥å®Œæˆè¿™ä¸€è¿‡ç¨‹ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; int n, m, h[1005], l[1005], r[1005]; int s[1005], tot = 0; bool a[1005][1005]; i64 ans = 0; void work(void) &#123; tot = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (tot &amp;&amp; h[i] &lt;= h[s[tot]]) --tot; l[i] = tot ? s[tot] : 0; s[++tot] = i; &#125; tot = 0; for (int i = m; i >= 1; --i) &#123; while (tot &amp;&amp; h[i] &lt; h[s[tot]]) --tot; r[i] = tot ? s[tot] : m + 1; s[++tot] = i; &#125; for (int i = 1; i &lt;= m; ++i) ans += h[i] * (i - l[i]) * (r[i] - i); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; char c = getchar(); while (c != '.' &amp;&amp; c != '*') c = getchar(); a[i][j] = (c == '*'); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; h[j] += 1; if (a[i][j]) h[j] = 0; &#125; work(); &#125; printf(\"%lld\\n\", ans); return 0; &#125; å•è°ƒé˜Ÿåˆ— å…¶å®å°±æ˜¯å¤šäº†ä¸ªæ’é™¤ä¸åˆæ³•æ—¶é—´åŠŸèƒ½çš„å•è°ƒæ ˆã€‚ [Luogu P1714] åˆ‡è›‹ç³• Portal. è¿™æ˜¯ç»å…¸çš„è¦æ±‚é•¿åº¦çš„æœ€å¤§å­æ®µå’Œé—®é¢˜ï¼Œæˆ‘ä»¬æšä¸¾å³ç«¯ç‚¹ï¼Œåˆ©ç”¨æ»‘åŠ¨çª—å£ç»´æŠ¤ç›®å‰é‡åˆ°è¿‡çš„æœ€å°çš„ S[lâˆ’1]S[l-1]S[lâˆ’1] å³å¯ã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int a[500005], sum[500005]; int L = 1, R = 0, Q[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), sum[i] = sum[i - 1] + a[i]; int ans = -1e9; Q[++R] = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (L &lt;= R &amp;&amp; Q[L] + m &lt; i) ++L; ans = max(ans, sum[i] - sum[Q[L]]); while (L &lt;= R &amp;&amp; sum[Q[R]] >= sum[i]) --R; Q[++R] = i; &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1419] å¯»æ‰¾æ®µè½ Portal. æ˜¾ç„¶å¯ä»¥äºŒåˆ†ã€‚ å¦‚ä½•å®ç° check(x)ï¼Ÿæ¡ä»¶æ˜¯ s[lâ€¦r]â‰¥xÃ—(râˆ’l+1)s[l\\dots r]\\ge x\\times (r-l+1)s[lâ€¦r]â‰¥xÃ—(râˆ’l+1)ï¼Œé‚£ä¹ˆå°±å°†åºåˆ—æ•´ä¸ªå‡å» xxxï¼Œç”¨å•è°ƒé˜Ÿåˆ—åˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸€ä¸ªå’Œå¤§äºç­‰äºé›¶çš„å­æ®µã€‚ æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, a[100005]; double S[100005]; int s, t; int Q[100005], L = 1, R = 0; bool calc(double x) &#123; L = 1, R = 0; for (int i = 1; i &lt;= n; ++i) S[i] = S[i - 1] + a[i] - x; for (int i = s; i &lt;= n; ++i) &#123; while (L &lt;= R &amp;&amp; S[Q[R]] >= S[i - s]) --R; while (L &lt;= R &amp;&amp; Q[L] &lt; i - t) ++L; Q[++R] = i - s; if (L &lt;= R &amp;&amp; S[i] - S[Q[L]] >= 0) return true; &#125; return false; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;s, &amp;t); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); double L = -10000, R = 10000; for (int op = 0; op &lt; 200; ++op) &#123; double mid = (L + R) / 2; if (calc(mid)) L = mid; else R = mid; &#125; printf(\"%.3lf\\n\", R); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"å•è°ƒé˜Ÿåˆ—","slug":"å•è°ƒé˜Ÿåˆ—","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"åŒæŒ‡é’ˆ","slug":"åŒæŒ‡é’ˆ","permalink":"https://james1badcreeper.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"å‰ç¼€å’Œ","slug":"å‰ç¼€å’Œ","permalink":"https://james1badcreeper.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"å·®åˆ†","slug":"å·®åˆ†","permalink":"https://james1badcreeper.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"å•è°ƒæ ˆ","slug":"å•è°ƒæ ˆ","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"[Luogu2671][NOIP2015 æ™®åŠç»„] æ±‚å’Œ","slug":"default/old/LuoguP2671","date":"2022-07-18T00:00:00.000Z","updated":"2022-07-18T00:00:00.000Z","comments":true,"path":"e1d941a1/","link":"","permalink":"https://james1badcreeper.github.io/e1d941a1/","excerpt":"ä¸€é“æ‰¾è§„å¾‹ä¸æ¨å¯¼çš„é¢˜ç›®ã€‚","text":"ä¸€é“æ‰¾è§„å¾‹ä¸æ¨å¯¼çš„é¢˜ç›®ã€‚ é¢˜ç›® Portal. å±•å¼€é¢˜ç›® é¢˜ç›®æè¿°è¾“å…¥è¾“å‡ºæ ¼å¼è¾“å…¥è¾“å‡ºæ ·ä¾‹æ ·ä¾‹è¯´æ˜ä¸€æ¡ç‹­é•¿çš„çº¸å¸¦è¢«å‡åŒ€åˆ’åˆ†å‡ºäº†nnnä¸ªæ ¼å­ï¼Œæ ¼å­ç¼–å·ä»111åˆ°nnnã€‚æ¯ä¸ªæ ¼å­ä¸Šéƒ½æŸ“äº†ä¸€ç§é¢œè‰²coloricolor_icoloriâ€‹ç”¨[1,m][1,m][1,m]å½“ä¸­çš„ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºï¼‰ï¼Œå¹¶ä¸”å†™äº†ä¸€ä¸ªæ•°å­—numberinumber_inumberiâ€‹ã€‚å®šä¹‰ä¸€ç§ç‰¹æ®Šçš„ä¸‰å…ƒç»„ï¼š(x,y,z)(x,y,z)(x,y,z)ï¼Œå…¶ä¸­x,y,zx,y,zx,y,zéƒ½ä»£è¡¨çº¸å¸¦ä¸Šæ ¼å­çš„ç¼–å·ï¼Œè¿™é‡Œçš„ä¸‰å…ƒç»„è¦æ±‚æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼šxyzxyzxyzæ˜¯æ•´æ•°,x&lt;y&lt;z,yâˆ’x=zâˆ’yx&lt;y&lt;z,y-x=z-yx&lt;y&lt;z,yâˆ’x=zâˆ’ycolorx=colorzcolorx=colorzcolorx=colorzæ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„ä¸‰å…ƒç»„çš„åˆ†æ•°è§„å®šä¸º(x+z)Ã—(numberx+numberz)(x+z) \\times (number_x+number_z)(x+z)Ã—(numberxâ€‹+numberzâ€‹)ã€‚æ•´ä¸ªçº¸å¸¦çš„åˆ†æ•°è§„å®šä¸ºæ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„ä¸‰å…ƒç»„çš„åˆ†æ•°çš„å’Œã€‚è¿™ä¸ªåˆ†æ•°å¯èƒ½ä¼šå¾ˆå¤§ï¼Œä½ åªè¦è¾“å‡ºæ•´ä¸ªçº¸å¸¦çš„åˆ†æ•°é™¤ä»¥10,00710,00710,007æ‰€å¾—çš„ä½™æ•°å³å¯ã€‚ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œæ˜¯ç”¨ä¸€ä¸ªç©ºæ ¼éš”å¼€çš„ä¸¤ä¸ªæ­£æ•´æ•°nnnå’Œm,nm,nm,nè¡¨çº¸å¸¦ä¸Šæ ¼å­çš„ä¸ªæ•°ï¼Œmmmè¡¨çº¸å¸¦ä¸Šé¢œè‰²çš„ç§ç±»æ•°ã€‚ç¬¬äºŒè¡Œæœ‰nnnç”¨ç©ºæ ¼éš”å¼€çš„æ­£æ•´æ•°ï¼Œç¬¬iiiæ•°å­—numbernumbernumberè¡¨çº¸å¸¦ä¸Šç¼–å·ä¸ºiiiæ ¼å­ä¸Šé¢å†™çš„æ•°å­—ã€‚ç¬¬ä¸‰è¡Œæœ‰nnnç”¨ç©ºæ ¼éš”å¼€çš„æ­£æ•´æ•°ï¼Œç¬¬iiiæ•°å­—colorcolorcolorè¡¨çº¸å¸¦ä¸Šç¼–å·ä¸ºiiiæ ¼å­æŸ“çš„é¢œè‰²ã€‚ è¾“å‡ºæ ¼å¼ ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæ‰€æ±‚çš„çº¸å¸¦åˆ†æ•°é™¤ä»¥100071000710007æ‰€å¾—çš„ä½™æ•°ã€‚ æ ·ä¾‹è¾“å…¥#16 25 5 3 2 2 22 2 1 1 2 1æ ·ä¾‹è¾“å‡º#182æ ·ä¾‹è¾“å…¥#215 45 10 8 2 2 2 9 9 7 7 5 6 4 2 42 2 3 3 4 3 3 2 4 4 4 4 1 1 1æ ·ä¾‹è¾“å‡º#21388ã€è¾“å…¥è¾“å‡ºæ ·ä¾‹ 1 è¯´æ˜ã€‘çº¸å¸¦å¦‚é¢˜ç›®æè¿°ä¸­çš„å›¾æ‰€ç¤ºã€‚æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„ä¸‰å…ƒç»„ä¸ºï¼š (1,3,5),(4,5,6)(1, 3, 5), (4, 5, 6)(1,3,5),(4,5,6)ã€‚æ‰€ä»¥çº¸å¸¦çš„åˆ†æ•°ä¸º(1+5)Ã—(5+2)+(4+6)Ã—(2+2)=42+40=82(1 + 5) \\times (5 + 2) + (4 + 6) \\times (2 + 2) = 42 + 40 = 82(1+5)Ã—(5+2)+(4+6)Ã—(2+2)=42+40=82ã€‚å¯¹äºç¬¬ 111 ç»„è‡³ç¬¬ 222 ç»„æ•°æ®ï¼Œ 1â‰¤nâ‰¤100,1â‰¤mâ‰¤51 \\le n \\le 100, 1 \\le m \\le 51â‰¤nâ‰¤100,1â‰¤mâ‰¤5ï¼›å¯¹äºç¬¬ 333 ç»„è‡³ç¬¬ 444 ç»„æ•°æ®ï¼Œ 1â‰¤nâ‰¤3000,1â‰¤mâ‰¤1001 \\le n \\le 3000, 1 \\le m \\le 1001â‰¤nâ‰¤3000,1â‰¤mâ‰¤100ï¼›å¯¹äºç¬¬ 555 ç»„è‡³ç¬¬ 666 ç»„æ•°æ®ï¼Œ 1â‰¤nâ‰¤100000,1â‰¤mâ‰¤1000001 \\le n \\le 100000, 1 \\le m \\le 1000001â‰¤nâ‰¤100000,1â‰¤mâ‰¤100000ï¼Œä¸”ä¸å­˜åœ¨å‡ºç°æ¬¡æ•°è¶…è¿‡ 202020 çš„é¢œè‰²ï¼›å¯¹äºå…¨éƒ¨ 101010 ç»„æ•°æ® ï¼Œ 1â‰¤nâ‰¤100000,1â‰¤mâ‰¤100000,1â‰¤coloriâ‰¤m,1â‰¤numberiâ‰¤1000001 \\le n \\le 100000, 1 \\le m \\le 100000, 1 \\le color_i \\le m,1\\le number_i\\le 1000001â‰¤nâ‰¤100000,1â‰¤mâ‰¤100000,1â‰¤coloriâ€‹â‰¤m,1â‰¤numberiâ€‹â‰¤100000 è§£ç­” x&lt;y&lt;z,yâˆ’x=zâˆ’yx&lt;y&lt;z,y-x=z-yx&lt;y&lt;z,yâˆ’x=zâˆ’y è¡¨ç¤ºçš„æ˜¾ç„¶æ˜¯è·ç¦»ç›¸ç­‰ï¼Œä¹Ÿå°±æ˜¯ yyy æ˜¯ x,zx,zx,z çš„å¹³å‡æ•°ï¼Œè€Œä¸” yyy æ˜¯ä¸ªæ•´æ•°ï¼Œæ‰€ä»¥ x,zx,zx,z å¥‡å¶æ€§ç›¸åŒï¼Œåˆ†åˆ«è¿›è¡Œè®¡ç®—å³å¯ã€‚ åˆå› ä¸ºé¢œè‰²ä¸ç­”æ¡ˆæ— å…³ï¼Œæ‰€ä»¥é¢œè‰²ä¹Ÿå¯ä»¥åˆ†åˆ«è®¡ç®—ã€‚ç°åœ¨çš„é—®é¢˜å°±è½¬åŒ–ä¸ºäº†æ±‚ï¼š âˆ‘i=1nâˆ‘j=i+1n(Ai+Aj)(Bi+Bj)\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=i+1}^{n}(A_i+A_j)(B_i+B_j) i=1âˆ‘nâ€‹j=i+1âˆ‘nâ€‹(Aiâ€‹+Ajâ€‹)(Biâ€‹+Bjâ€‹) å±•å¼€åä¼šå‘ç°å½“ä¸­æœ‰ nâˆ’1n-1nâˆ’1 ä¸ª AiBiA_i B_iAiâ€‹Biâ€‹ï¼Œå’Œæ‰€æœ‰ A,BA,BA,B ç›¸ä¹˜ã€‚åˆ©ç”¨å¤šé¡¹å¼ä¹˜æ³•çš„ç‰¹æ€§ï¼Œå¯å¾—åŸå¼ç­‰äºï¼š âˆ‘i=1nAiÃ—âˆ‘i=1nBi+âˆ‘i=1n(nâˆ’2)AiBi\\sum\\limits_{i=1}^{n}A_i \\times \\sum\\limits_{i=1}^{n}B_i + \\sum\\limits_{i=1}^{n}(n-2)A_iB_i i=1âˆ‘nâ€‹Aiâ€‹Ã—i=1âˆ‘nâ€‹Biâ€‹+i=1âˆ‘nâ€‹(nâˆ’2)Aiâ€‹Biâ€‹ ä»£ç å°±å¾ˆç®€å•äº†ï¼š æŸ¥çœ‹ä»£ç  #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; const int MOD = 10007; int n, m; int number[100005], color[100005]; vector &lt;pii> v[100005][2]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", number + i), number[i] %= MOD; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", color + i); for (int i = 1; i &lt;= n; ++i) v[color[i]][i &amp; 1].push_back(make_pair(i, number[i])); int ans = 0; for (int op = 0; op &lt; 2; ++op) &#123; for (int i = 1; i &lt;= m; ++i) &#123; int R = v[i][op].size(); if (R >= 2) &#123; int res = 0, ret = 0; for (int j = 0; j &lt; R; ++j) res = (res + v[i][op][j].X) % MOD, ret = (ret + v[i][op][j].Y) % MOD; ans = (ans + res * ret % MOD) % MOD; for (int j = 0; j &lt; R; ++j) ans = (ans + (R - 2) % MOD * v[i][op][j].X % MOD * v[i][op][j].Y % MOD) % MOD; &#125; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125;","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"æ‰¾è§„å¾‹","slug":"æ‰¾è§„å¾‹","permalink":"https://james1badcreeper.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"è§£é¢˜","slug":"è§£é¢˜","permalink":"https://james1badcreeper.github.io/tags/%E8%A7%A3%E9%A2%98/"}]},{"title":"Codeforces Round #806 Div.4 è§£é¢˜è®°å½•","slug":"default/old/cf806-4","date":"2022-07-15T00:00:00.000Z","updated":"2022-07-15T00:00:00.000Z","comments":true,"path":"a947015c/","link":"","permalink":"https://james1badcreeper.github.io/a947015c/","excerpt":"å›å½’ OI äº†ï¼æ‰“ç®—ç”¨è¿™å¥—é¢˜æ¥ç»ƒæ‰‹ï¼Œæ¥æ‰¾ä¸€æ‰¾æ„Ÿè§‰ï¼Œç„¶åå¼€å§‹å­¦ä¹ ã€‚","text":"å›å½’ OI äº†ï¼æ‰“ç®—ç”¨è¿™å¥—é¢˜æ¥ç»ƒæ‰‹ï¼Œæ¥æ‰¾ä¸€æ‰¾æ„Ÿè§‰ï¼Œç„¶åå¼€å§‹å­¦ä¹ ã€‚ è¿™æ˜¯ä¸€åœº Div.4ï¼Œéš¾åº¦è¾ƒä½ã€‚ A. YES or YES? Portal. åˆ©ç”¨å¸¸é‡æ•°ç»„å¯ä»¥ç®€å•åœ°å®ç°ã€‚ä»¥æ­¤åˆ¤æ–­ä¸‰ä¸ªå­—æ¯ï¼Œä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;string> #include &lt;cstdio> using namespace std; int main(void) &#123; const string a = \"YES\", b = \"yes\"; int t; cin >> t; while (t--) &#123; string s; bool flag = true; cin >> s; for (int i = 0; i &lt; 3; ++i) if (s[i] != a[i] &amp;&amp; s[i] != b[i]) flag = false; if (flag) puts(\"YES\"); else puts(\"NO\"); &#125; return 0; &#125; B. ICPC Balloons Portal. åˆ©ç”¨ä¸€ä¸ªæ•°ç»„è®°å½•è¿™ä¸ªå­—æ¯ä¹‹å‰æ˜¯å¦å‡ºç°è¿‡å³å¯ï¼Œä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;string> #include &lt;cstring> using namespace std; int main(void) &#123; int T, n; string s; bool flag[30]; cin >> T; while (T--) &#123; cin >> n >> s; int ans = 0; memset(flag, 0, sizeof(flag)); for (int i = 0; i &lt; n; ++i) &#123; if (!flag[s[i] - 'A']) ++ans, flag[s[i] - 'A'] = true; ++ans; &#125; cout &lt;&lt; ans &lt;&lt; '\\n'; &#125; return 0; &#125; C. Cypher Portal. æŒ‰é¡ºåºæ¨¡æ‹Ÿå³å¯ï¼Œä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; int main(void) &#123; int T, n, b, a[105]; cin >> T; string s; while (T--) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1; i &lt;= n; ++i) &#123; cin >> b >> s; for (int j = 0; j &lt; b; ++j) &#123; a[i] += (s[j] == 'D') ? (1) : (-1); if (a[i] == 10) a[i] = 0; if (a[i] == -1) a[i] = 9; &#125; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; putchar('\\n'); &#125; return 0; &#125; D. Double Strings Portal. æ³¨æ„åˆ°å­—ç¬¦ä¸²çš„é•¿åº¦å¾ˆçŸ­ï¼Œç›´æ¥æšä¸¾å‰ç¼€åŒæ—¶è®¡ç®—åç¼€ï¼Œå†åˆ©ç”¨é›†åˆï¼ˆå½“ç„¶å¯ä»¥å†™å­—ç¬¦ä¸²å“ˆå¸Œï¼‰åˆ¤æ–­æ˜¯å¦å­˜åœ¨å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š #include &lt;iostream> #include &lt;string> #include &lt;unordered_set> using namespace std; string s[100005]; unordered_set &lt;string> us; int main(void) &#123; ios::sync_with_stdio(false); cin.tie(0); int t, n; cin >> t; while (t--) &#123; us.clear(); cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> s[i], us.insert(s[i]); for (int i = 1; i &lt;= n; ++i) &#123; bool flag = false; string a = \"\", b = s[i]; for (int j = 0; j &lt; s[i].length() - 1; ++j) &#123; a += s[i][j], b.erase(b.begin()); if (us.find(a) != us.end() &amp;&amp; us.find(b) != us.end()) &#123; flag = true; break; &#125; &#125; putchar(flag ? '1' : '0'); &#125; putchar('\\n'); &#125; return 0; &#125; E. Mirror Grid Portal. ç»å…¸é¢˜ã€‚æ‰¾è§„å¾‹æ‰¾åˆ°æ—‹è½¬åçš„åæ ‡ï¼Œæ¨¡æ‹Ÿå³å¯ã€‚ #include &lt;cstdio> #include &lt;string> #include &lt;iostream> using namespace std; bool a[105][105]; int main(void) &#123; int t, n; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%d\", &amp;n); string s; for (int i = 0; i &lt; n; ++i) &#123; cin >> s; for (int j = 0; j &lt; n; ++j) a[i][j] = s[j] - '0'; &#125; int ans = 0; for (int i = 0; i &lt; n / 2 + 1; ++i) for (int j = 0; j &lt; n / 2 + 1; ++j) &#123; int s = a[i][j] + a[j][n - i - 1] + a[n - i - 1][n - j - 1] + a[n - j - 1][i]; if (s &lt;= 2) &#123; a[i][j] = a[j][n - i - 1] = a[n - i - 1][n - j - 1] = a[n - j - 1][i] = 0; ans += s; &#125; else &#123; a[i][j] = a[j][n - i - 1] = a[n - i - 1][n - j - 1] = a[n - j - 1][i] = 1; ans += 4 - s; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; F. Yet Another Problem About Pairs Satisfying an Inequality Portal. å¯¹ä¸ç­‰å¼è¿›è¡Œæ‹†è§£ï¼Œå¾—åˆ° ai&lt;ia_i&lt;iaiâ€‹&lt;iï¼Œaj&lt;ja_j&lt;jajâ€‹&lt;j å’Œ i&lt;aji &lt; a_ji&lt;ajâ€‹ ä¸‰ä¸ªä¸ç­‰å¼ã€‚è€ƒè™‘æš´åŠ›ç®—æ³•ï¼Œæšä¸¾ i,ji,ji,j å¯ä»¥è½»æ¾å¾—åˆ°ç­”æ¡ˆã€‚ å¯¹æ­¤è¿›è¡Œä¼˜åŒ–ã€‚i&lt;aji &lt; a_ji&lt;ajâ€‹ å˜å½¢ä¸º ajâ‰¥i+1a_j\\ge i+1ajâ€‹â‰¥i+1ï¼ˆå› ä¸ºéƒ½æ˜¯æ•´æ•°ï¼‰ï¼Œæ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„æ•°çš„ä¸ªæ•°å…·æœ‰å•è°ƒæ€§ï¼Œå¯ä»¥ç”¨ä¸€ä¸ª sum æ•°ç»„è®°å½•ï¼Œç»´æŠ¤åç¼€å’Œå³å¯ã€‚ #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; using i64 = long long; int n, t; int a[200005]; i64 sum[200005]; int main(void) &#123; scanf(\"%d\", &amp;t); while (t--) &#123; memset(sum, 0, sizeof(sum)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] &lt; i) ++sum[a[i]]; // æ»¡è¶³åŸºæœ¬æ¡ä»¶ï¼Œå°†è¿™ä¸ª sum +1 &#125; for (int i = n; i >= 1; --i) // è®¡ç®—åç¼€å’Œ sum[i] += sum[i + 1]; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &lt; i) ans += sum[i + 1]; // a[j] >= i+1 printf(\"%lld\\n\", ans); &#125; return 0; &#125; G. Good Key, Bad Key Portal. ç”¨ Bad Key å‡åŠè¿™ç§äº‹æƒ…è¶Šåœ¨åé¢å‘ç”Ÿè¶Šå¥½ã€‚å› ä¸º âŒŠAi2âŒ‹+âŒŠAi+12âŒ‹âˆ’kâ‰¤âŒŠAiâŒ‹+âŒŠAi+12âŒ‹âˆ’k\\left\\lfloor \\cfrac{A_i}{2}\\right\\rfloor + \\left\\lfloor \\cfrac{A_{i+1}}{2}\\right\\rfloor - k \\le \\left\\lfloor A_i\\right\\rfloor + \\left\\lfloor \\cfrac{A_{i+1}}{2}\\right\\rfloor - kâŒŠ2Aiâ€‹â€‹âŒ‹+âŒŠ2Ai+1â€‹â€‹âŒ‹âˆ’kâ‰¤âŒŠAiâ€‹âŒ‹+âŒŠ2Ai+1â€‹â€‹âŒ‹âˆ’k æ’æˆç«‹ã€‚ äº¤æ›¿ä½¿ç”¨ Good Key, Bad Key æ²¡æœ‰æ„ä¹‰ã€‚ç†ç”±åŸºæœ¬åŒä¸Šï¼Œåœ¨ Bad Key åé¢å‡ºç°ä¸€ä¸ª Good Key ä¸å¦‚å°†è¿™ä¸ª Good Key ç§»åˆ° Bad Key å‰ã€‚èŠ±è´¹çš„é’±éƒ½æ˜¯ kkkï¼Œè€Œå…ˆç”¨ Good Key å´èƒ½é¿å…ç¬¬ä¸€ä¸ªç®±å­ä¸­é’±å‡åŠçš„æƒ¨æ¡ˆã€‚ è€Œä¸”ç”¨äº† 303030 ä¸ª Bad Key ä¹‹åå°±æ— æ„ä¹‰äº†ã€‚å› ä¸º 230&gt;1092^{30} &gt; 10^9230&gt;109ã€‚ #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const i64 MAX = 1000000005; int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x; &#125; int n, k; int a[100005]; int main(void) &#123; int t = read(); while (t--) &#123; n = read(), k = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); i64 ans = 0, res = 0; for (int i = 0; i &lt;= n; ++i) &#123; if (i >= 1) res += a[i] - k; i64 ret = 1, cur = 0; for (int j = i + 1, R = min(n, i + 31); j &lt;= R; ++j) // ä¸ºé˜²æ­¢å‡ºé”™ï¼Œå¼€äº† 31 cur += a[j] / (ret *= 2); ans = max(ans, res + cur); &#125; printf(\"%lld\\n\", ans); &#125; return 0; &#125; æ€»ç»“ ä¸»è¦æ˜¯è€ƒå¯Ÿäº†ä¸€äº›ç¼–ç¨‹åŸºæœ¬åŠŸï¼Œç»ƒä¸€ä¸‹æ‰‹è¿˜æ˜¯ä¸é”™çš„ã€‚","categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"æ¯”èµ›è®°å½•","slug":"ç®—æ³•ç«èµ›/æ¯”èµ›è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"},{"name":"æ¯”èµ›","slug":"æ¯”èµ›","permalink":"https://james1badcreeper.github.io/tags/%E6%AF%94%E8%B5%9B/"},{"name":"Div.4","slug":"Div-4","permalink":"https://james1badcreeper.github.io/tags/Div-4/"}]},{"title":"è®° 2022 å¤§è¿ä¸­è€ƒ","slug":"summaries/æ¸¸è®°/ä¸­è€ƒ","date":"2022-07-15T00:00:00.000Z","updated":"2022-07-15T00:00:00.000Z","comments":false,"path":"3f40bc15/","link":"","permalink":"https://james1badcreeper.github.io/3f40bc15/","excerpt":"å¤§è¿ä¸­è€ƒæ»¡åˆ† 695 åˆ†ï¼Œå…¶ä¸­è¯­æ•°å„ 150 åˆ†ï¼Œè‹±è¯­ 140 åˆ†ï¼Œç†ç»¼ 160 åˆ†ï¼ˆç‰©ç† 90ï¼ŒåŒ–å­¦ 70ï¼‰ï¼Œä½“è‚² 50 åˆ†ï¼Œç­‰çº§å­¦ç§‘ç´¯è®¡æˆç»© 45 åˆ†ã€‚ç”±äºè¾½å®æ˜¯ä¿¡æ¯å­¦ç«èµ›çš„å¼±çœï¼Œå¤§è¿å¸‚å”¯ä¸€ä¸€æ‰€å¯ä»¥æ‰“ä¿¡ç«çš„å­¦æ ¡å°±æ˜¯å¤§è¿å¸‚ç¬¬äºŒåå››ä¸­å­¦ï¼ŒåŒæ—¶æ˜¯å…¨å¸‚æœ€ä¼˜ç§€çš„é«˜ä¸­ï¼Œæ¸…åŒ—ç‡é«˜è¾¾ 10%ã€‚æˆ‘å¤§æ¦‚å°±æ˜¯è¦è€ƒè¿™é‡Œã€‚","text":"å¤§è¿ä¸­è€ƒæ»¡åˆ† 695 åˆ†ï¼Œå…¶ä¸­è¯­æ•°å„ 150 åˆ†ï¼Œè‹±è¯­ 140 åˆ†ï¼Œç†ç»¼ 160 åˆ†ï¼ˆç‰©ç† 90ï¼ŒåŒ–å­¦ 70ï¼‰ï¼Œä½“è‚² 50 åˆ†ï¼Œç­‰çº§å­¦ç§‘ç´¯è®¡æˆç»© 45 åˆ†ã€‚ç”±äºè¾½å®æ˜¯ä¿¡æ¯å­¦ç«èµ›çš„å¼±çœï¼Œå¤§è¿å¸‚å”¯ä¸€ä¸€æ‰€å¯ä»¥æ‰“ä¿¡ç«çš„å­¦æ ¡å°±æ˜¯å¤§è¿å¸‚ç¬¬äºŒåå››ä¸­å­¦ï¼ŒåŒæ—¶æ˜¯å…¨å¸‚æœ€ä¼˜ç§€çš„é«˜ä¸­ï¼Œæ¸…åŒ—ç‡é«˜è¾¾ 10%ã€‚æˆ‘å¤§æ¦‚å°±æ˜¯è¦è€ƒè¿™é‡Œã€‚ æˆ‘æ‰€åœ¨çš„åˆä¸­æ˜¯ä¸€æ‰€å››æµåˆä¸­ï¼Œæ‰€ä»¥è€ƒäºŒåå››å°±æ˜¯æŠ¢æŒ‡æ ‡ã€‚è€Œä¸”æˆ‘è¯­æ–‡å¥‡çƒ‚ï¼Œå¯èƒ½ä¼šæœ‰æ„æƒ³ä¸åˆ°çš„å›°éš¾ã€‚ å¯’å‡çš„æœ€å ä¸ºäº†ä¸­è€ƒåœæ­¢äº†ç«èµ›ï¼Œå¹¶å»äº†ä¸€è¶Ÿä¹¦åŸçœ‹æ•™è¾…ã€‚ä¸å¾—ä¸è¯´å¤§è¿è¿™é‡Œæ•™è¾…æ˜¯çœŸçš„å¤šï¼ˆé™¤éåŒæ—¶åšç†æƒ³æ ‘å’Œä¸‡å”¯ï¼‰ã€‚å¤§è¿è¿™é‡Œçš„ä¸¤ä¸ªæ•™è¾…å“ç‰Œâ€å­¦ä¹ ä¹‹æ˜Ÿâ€œå’Œâ€ç‚¹çŸ³æˆé‡‘â€œå·²ç»å¤Ÿå¿™æ´»äº†ã€‚ ç‚¹çŸ³æˆé‡‘çš„ã€Šä¸­è€ƒå†²åˆºã€‹ï¼ˆç”¨äºä¸€äºŒè½®å¤ä¹ çš„å¤§æœ¬ï¼‰æ˜¯æˆ‘ä»¬çš„å¯’å‡ä½œä¸šã€‚å¤§æ¦‚é•¿è¿™æ ·ï¼š ä»¥ä¸Šå±•ç¤ºäº†å‡ æœ¬ï¼Œæœ‰çš„æ‰¾ä¸åˆ°äº†ï¼ˆæˆ–è€…æ˜¯åœ¨ç­çº§å–åºŸå“äº†ï¼‰ æ‰€ä»¥ï¼Œè¦å¼€æˆ˜äº†ã€‚ å¼€å§‹äº†ï¼Ÿ æ˜æ˜å¼€å­¦äº†ï¼Œä½†æ„Ÿè§‰è¿˜æ˜¯æ²¡å¼€å­¦ã€‚ å¼€å­¦äº† å’Œé¢„æƒ³çš„ä¸ä¸€æ ·ï¼Œè€å¸ˆå¹¶æ²¡æœ‰èŠ±å¤§é‡çš„æ—¶é—´è¯´æ˜ä¸­è€ƒçš„é‡è¦æ€§ï¼ˆå› ä¸ºæˆ‘ä»¬æ˜¯å°ç­ï¼‰ï¼Œå¾ˆå¿«åœ°è¿›å…¥äº†æ­£é¢˜ã€‚å¼€å§‹è®²æ²¡æœ‰è®²å®Œçš„è¯¾ï¼ˆæ•°å­¦å·²ç»è®²å®Œäº†ï¼‰ã€‚ å‘Šè¯‰äº†æˆ‘ä»¬ç†åŒ–å®éªŒå’Œè®¡ç®—æœºä¸è€ƒäº†ï¼Œæ€»å…± 15 åˆ†é€ç»™æˆ‘ä»¬äº†ã€‚ å¼€å­¦å…¸ç¤¼ä»€ä¹ˆçš„è¿˜æ˜¯ç…§å¸¸æœ‰ï¼Œä¹Ÿè®°ä¸æ¸…äº†ã€‚ çªæ¥çš„ç–«æƒ… æ‰å¼€å­¦ä¸¤å‘¨ï¼Œå¤§è¿å°±åˆå‡ºç°äº†ç–«æƒ…ã€‚è¿™å¯ä¸æ˜¯ä¸€ä¸ªå¥½äº‹æƒ…ã€‚æœ¬æ¥æˆ‘ä»¬åœ¨åˆä¸€ã€åˆäºŒå·²ç»å› ä¸ºç–«æƒ…åœäº†å¥½å¤šè¯¾äº†ã€‚ç°åœ¨åœ¨åˆä¸‰ä¸‹åœè¯¾ï¼Œåªèƒ½è¯´æ˜¯å¯¹è‡ªå¾‹æ€§çš„ä¸€æ¬¡è€ƒéªŒå§ã€‚ ç½‘è¯¾æœŸé—´ç­ä¸»ä»»è€å¸ˆé€šè¿‡é’‰é’‰çœ‹æˆ‘ä»¬è‡ªä¹ åˆ°æ™š 10 ç‚¹ï¼Œè®©æˆ‘å¤šå­¦äº†ä¸å°‘ä¸œè¥¿ï¼ˆå› ä¸ºè‡ªä¹ çš„æ—¶å€™åŒ–å­¦è€å¸ˆç»å¸¸è¿‡æ¥è®²è¯¾ï¼Œæ°å¥½æˆ‘åŒ–å­¦å¾ˆå·®ï¼‰ã€‚ åˆä¹°äº†ä¸å°‘å·å­åšã€‚åŒ…æ‹¬å­¦ä¹ ä¹‹æ˜Ÿçš„ã€Šé¢†è·‘ã€‹ï¼š å®šä½è·Ÿã€Šä¸­è€ƒå†²åˆºã€‹å·®ä¸å¤šï¼Œè¿™é‡Œæœ‰çš„æ˜¯ä½œä¸šï¼Œæœ‰çš„æ˜¯è‡ªå·±åšçš„ è¿˜æœ‰å­¦ä¹ ä¹‹æ˜Ÿçš„ã€Šå¤‡è€ƒã€‹ï¼š è·Ÿä¸‡å”¯çš„ã€Šè¯•é¢˜ç ”ç©¶ã€‹å¾ˆåƒï¼Œéƒ½æ˜¯ç ”ç©¶çœŸé¢˜ï¼Œæ¯ç§‘é™„èµ å››å¥—æ¨¡æ‹Ÿå· å­¦ä¹ ä¹‹æ˜Ÿçš„ã€Šæ˜Ÿé˜…è¯»ã€‹ï¼š è¯­æ–‡å¾ˆå·®ï¼Œä¹°äº†è¿™ä¸ª è¿˜æœ‰å­¦ä¹ ä¹‹æ˜Ÿçš„ã€Šå¿…åˆ·å·ã€‹ï¼š ä¸€ç§‘åå¥—å·ï¼Œé…å•è‰²ç­”é¢˜å¡ï¼Œåªå±•ç¤ºäº†ä¸‰æœ¬ï¼Œå‰©ä¸‹ä¸¤æœ¬ä¸¢äº† è¿˜æœ‰ä¸€äº›å¥‡å¥‡æ€ªæ€ªçš„å·å­ï¼Œæ‰¾ä¸åˆ°äº†ï¼Œè¿™é‡Œä¸æ”¾å›¾äº†ã€‚ åŒå­¦è¯´ç‚¹çŸ³æˆé‡‘çš„ã€Šå¤§è¿ä¸­è€ƒå†²åˆºæ¨¡æ‹Ÿè¯•å·ã€‹ä¸é”™ï¼Œä¸€ç§‘å…«å¥—å·ï¼Œä½†å®åœ¨æ˜¯åšä¸è¿‡æ¥äº†ï¼ˆæ‰‹é‡Œè¿™äº›è¿˜æ²¡åšå®Œï¼‰ã€‚ å¤è¯¾å¦‚æ­¤è‰°éš¾ æœ¬æ¥æ˜¯å››æœˆä¸­æ—¬å¤è¯¾ï¼Œä½†æ˜¯æ ¸é…¸æ£€æµ‹æ—¶åˆæŸ¥å‡ºäº†ä¸ªé˜³æ€§ï¼Œäºæ˜¯åˆåœäº†ä¸€å‘¨è¯¾ï¼Œç»ˆäºå¤å­¦äº†ã€‚ è€å¸ˆå‘Šè¯‰æˆ‘ä»¬ä¸€å‘¨åå°±é ç”˜åŒºæ¨¡æ‹Ÿï¼ˆåŒåŸºæµ‹è¯•ï¼‰ï¼Œè¿™æ‰å¼€å§‹æ…Œäº†ã€‚è¿™å°±è€ƒè¯•äº†ï¼Ÿæˆ‘çœŸçš„æ²¡æœ‰æƒ³åˆ°ã€‚ å¥½æ¶ˆæ¯æ˜¯ï¼Œè€å¸ˆå‘Šè¯‰æˆ‘ä»¬ä½“è‚²å’Œè‹±è¯­å¬åŠ›ä¸è€ƒäº†ï¼Œç›´æ¥é€ 35 åˆ†ã€‚ æ¨¡æ‹Ÿè€ƒè¯• ä¸‡ä¼—æœŸå¾…çš„æ¨¡æ‹Ÿè€ƒè¯•æ¥äº†ï¼ï¼ï¼ ç”˜åŒºæ¨¡æ‹Ÿ å››æœˆæœ«å°±ç›´æ¥æ˜¯ç”˜åŒºæ¨¡æ‹Ÿï¼Œè¯´æ˜¯ä¸ºäº”æœˆåä¸€æ—¥çš„å¸‚ä¸€æ¨¡åšå‡†å¤‡ã€‚ä¹ä¸ŠæœŸæœ«å¹´çº§æ’åç¬¬ä¸ƒï¼Œè€ŒäºŒåå››ä¸­åªæœ‰å››ä¸ªæŒ‡æ ‡ï¼Œä¹Ÿå°±æ˜¯è¯´å¿…é¡»è¿›å¹´çº§å‰ 4ã€‚ æœ€ååˆ†æ•°å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š è¯­æ–‡ æ•°å­¦ å¤–è¯­ ç‰©ç† åŒ–å­¦ æ€»åˆ†ï¼ˆåŠ  95ï¼‰ 121 135 131 82 65 629 ç»“æœè¿˜æ˜¯å¹´çº§ç¬¬ä¸ƒã€‚ä¸å¾—ä¸è¯´è¿™ä¸ªåˆ†æ•°çœŸçš„å¾ˆçƒ‚ï¼Œæ¥ç€åŠªåŠ›å§ã€‚ ä¸€æ¨¡çš„èƒœåˆ© æ„Ÿè§‰ç­”çš„ä¸æ˜¯å¾ˆå¥½ï¼Œä½†æ˜¯æ²¡æƒ³åˆ°æœ€åæ’åˆ°äº†å¹´çº§ç¬¬äºŒï¼Œé«˜å…´äº†å¥½ä¸€é˜µå­ã€‚ è¯­æ–‡ æ•°å­¦ å¤–è¯­ ç‰©ç† åŒ–å­¦ æ€»åˆ†ï¼ˆåŠ  95ï¼‰ 129 139.5 131 88 60 642.5 ç„¶åè€å¸ˆå¼€å§‹å®šå·äº†ï¼åŒ…æ‹¬å­¦ä¹ ä¹‹æ˜Ÿã€Šä¸­è€ƒå†³èƒœå·ã€‹ã€ç‚¹çŸ³æˆé‡‘ã€Šä¸­è€ƒå†²åˆºä»¿çœŸæµ‹è¯•å·ã€‹å’Œã€Šæºåˆ›æ€ç»´ã€‹ã€‚å·çœŸå¤šã€‚ äºŒæ¨¡çš„å¤±è´¥ æœ¬æ¥å¬è¯´æ²¡æœ‰äºŒæ¨¡ï¼Œç»“æœäºŒæ¨¡åˆå‡ºç°äº†ã€‚æƒ³å¥½å¥½ç­”ç„¶åä½¿å¾—å…¶ä»–äººä¸æ•¢æŠ¥äºŒåå››ï¼Œç»“æœè¿‡äºç´§å¼ ï¼Œç›´æ¥å¹²åˆ°äº†å¹´çº§ç¬¬åå…­ã€‚ è¯­æ–‡ æ•°å­¦ å¤–è¯­ ç‰©ç† åŒ–å­¦ æ€»åˆ†ï¼ˆåŠ  95ï¼‰ 125 140 128 88 63 639 å†³èƒœä¸­è€ƒ è¿˜å‰©äºŒåå¤šå¤©å°±ä¸­è€ƒäº†ï¼ŒåŠ æ²¹å§ã€‚ æŠ¼é¢˜å· ä¸å‡ºæ„å¤–çš„ï¼Œç‚¹çŸ³æˆé‡‘å’Œå­¦ä¹ ä¹‹æ˜Ÿå„å‡ºäº†ä¸€å¥—æŠ¼é¢˜å·ï¼ˆç±»ä¼¼ä¸‡å”¯çš„é»‘ç™½å·ï¼‰ï¼Œä¹°äº†ä¸€å¥—å¤å°äº†ä¸€å¥—ï¼Œåªèƒ½è¯´æ˜¯ä¸€ä¸ªå¿ƒç†å®‰æ…°å§ã€‚ æœ€åçš„å¤‡è€ƒ ä½“æ´»çš„æ—¶å€™ä¹Ÿç•™åœ¨æ•™å®¤å†™é¢˜ï¼Œå¾ˆç—›è‹¦ã€‚ å£®è¡Œä»ªå¼ ä¸ºåˆä¸‰å£®è¡Œã€‚æˆ‘ä»¬è€å¸ˆè¿˜ç»™æˆ‘ä»¬å‘äº†çº¢åŒ…ï¼Œç™¾äº‹å¯ä¹ï¼Œæ‰‹ç¯å’Œé‡‘æ¦œé¢˜åçš„å£ç½©ã€‚ç”šè‡³å­¦æ ¡è¿˜ç»™äº†å£«åŠ›æ¶ã€‚å¸Œæœ›èƒ½è€ƒå¥½å§ã€‚ ä¸­è€ƒæ¸¸è®° çœŸçš„å¼€å§‹ç´§å¼ äº†ã€‚ Day 1 ä¸Šåˆè€ƒè¯­æ–‡ï¼Œä¸‹åˆè€ƒç†ç»¼ã€‚ è¯­æ–‡æ„Ÿè§‰è¿˜è¡Œï¼Ÿç†ç»¼è¿˜æ˜¯å¾ˆæœ‰è‡ªä¿¡çš„ï¼Œæ¯•ç«ŸäºŒæ¨¡å¤±åˆ©ä¹‹ååˆ·äº†é‚£ä¹ˆå¤šå·å­ï¼Œæ„Ÿè§‰æ²¡æœ‰ä»»ä½•é—®é¢˜ã€‚ Day 2 ä¸Šåˆè€ƒæ•°å­¦ï¼Œä¸‹åˆè€ƒè‹±è¯­ã€‚ æ•°å­¦åªæœ‰ 26(3) æ²¡åšå‡ºæ¥ï¼ˆå¤ªéš¾ç®—äº†ï¼‰ï¼Œä½†æ˜¯æ„Ÿè§‰åšå‡ºæ¥çš„äººåº”è¯¥å¾ˆå°‘ï¼Œä¸å¤ªè¦ç´§ã€‚ è‹±è¯­å¾ˆç®€å•ï¼ˆè‚¯å®šæ¯”æºåˆ›æ€ç»´çš„æ­»å·ç®€å•ï¼‰ï¼Œä½œæ–‡è®¤çœŸåœ°æ‰“äº†è‰ç¨¿ï¼Œæ„Ÿè§‰æŒºå¥½ã€‚ Day 3 è™½ç„¶è¿™å¤©ä¸‹é›¨ï¼Œä½†æ˜¯æ²¡ä»€ä¹ˆæ„Ÿè§‰ï¼ˆç”šè‡³è¿ä¼éƒ½æ²¡æ‹¿å°±è¿›äº†è€ƒåœºï¼‰ã€‚è€ƒæ”¿æ²»å†å²ï¼Œè€Œä¸”æ˜¯å¼€å·è€ƒè¯•ï¼Œèƒ¡ä¹±ä½œç­”å°±æ»¡åˆ†äº†ã€‚ è€ƒåç„¦è™‘ç—‡ æœ€å¯æ€•çš„äº‹æƒ…æ˜¯ï¼Œæ˜æ˜æ„Ÿè§‰è¶…é•¿å‘æŒ¥äº†ï¼Œå´è¿˜æ˜¯è€ƒä¸ä¸Šã€‚ è€ƒå®Œäº†ï¼Ÿ ä¸€ç›´å¾ˆç„¦è™‘ã€‚è™½ç„¶æ„Ÿè§‰ç­”å¾—æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œä½†æ˜¯æ€»æ„Ÿè§‰è€ƒä¸ä¸Šã€‚ çƒ¦èºçš„å¿ƒæƒ…åŠ ä¸Šç‚çƒ­çš„å¤©æ°”ï¼Œæ ¹æœ¬ç¡ä¸ç€ã€‚ ç”šè‡³æœ‰ä¸€æ¬¡åšæ¢¦æ¢¦åˆ°æˆ‘è¯­æ–‡ä½œæ–‡åªå†™äº† 53 åˆ†ï¼ˆæ»¡åˆ† 70ï¼‰ï¼Œç›´æ¥å“é†’ã€‚ ä¸Šå±±å’¯ï¼ ç­ä¸»ä»»è€å¸ˆé¢†æˆ‘ä»¬ä¸Šå±±ï¼Œå¿ƒæƒ…å¥½äº†ä¸å°‘ã€‚è¿™é‡Œä»…æ”¾ä¸€å¼ ç…§ç‰‡è¿™å¼ ç…§ç‰‡æ˜¯ç”¨ä¸‡å…ƒçº§çš„ä¸“ä¸šç›¸æœºç…§çš„ï¼Œä½†æ˜¯å› ä¸ºå‹ç¼©è€Œæ•ˆæœæŸ¥äº†è®¸å¤šï¼š æˆ‘ä»¬ç­æŠ¥äºŒåå››çš„å››ä½åŒå­¦ä¸­çš„ä¸‰ä½ï¼Œå¦ä¸€ä½é‡æ„Ÿå†’æ²¡æ¥ ã€Šé«˜è€ƒå¿…åˆ·é¢˜ã€‹ å› ä¸ºæŸäº›åŸå› ï¼Œå‡†é«˜ä¸€å°±ä¹°äº†ã€Šé«˜è€ƒå¿…åˆ·é¢˜ã€‹ï¼Œçœ‹åˆ°è¿™ä¹ˆä¸€æ®µè¯ï¼š é«˜è€ƒï¼Œæ— éå°±æ˜¯å¾ˆå¤šäººåŒæ—¶åšåŒä¸€ä»½å·å­ç„¶åå†³å®šå»å“ªä¸€åº§åŸå’Œè°èµ°å››å¹´å’Œè°èµ°ä¸€è¾ˆå­æœ€ç»ˆå‘ç°é”™çš„æ¯ä¸€é“é¢˜éƒ½æ˜¯ä¸ºäº†é‡è§å¯¹çš„äººè€Œå¯¹çš„æ¯ä¸€é“é¢˜è®©ä½ é‡è§æ›´å¥½çš„è‡ªå·± ä¸­è€ƒå¤§æ¦‚ä¹Ÿæ˜¯è¿™ä¸ªé“ç†å§ã€‚ å‡ºåˆ†äº† å‡ºåˆ†å‰å‡ºé—¨äº†ï¼Œæƒ³åœ¨å¤–é¢æŸ¥åˆ†ã€‚ç»“æœå¦‚ä¸‹ï¼š æŸ¥çœ‹åˆ†æ•° æŸ¥åˆ†çš„æ—¶å€™çœŸçš„æ‰‹æŠ–è¿™ä¸ªè¯­æ–‡åˆ†â€¦â€¦è¯­æ–‡è¿˜æ˜¯å¤ªå·®äº†ï¼Œé«˜ä¸­å¿…é¡»è®¤çœŸå­¦äº†ï¼è¯­æ–‡ä½œæ–‡å¾—äº† 53.5ï¼Œå¤ªå·§äº†å§ çœ‹åˆ°è¿™ä¸ªåˆ†çš„æ—¶å€™çœŸæ„Ÿè§‰å‡‰äº†ã€‚ä½†æ˜¯é—®äº†å…¶ä»–äººçš„æˆç»©ä¹‹åè¿›è¡Œæ¯”è¾ƒï¼Œå‘ç°å±…ç„¶ä¸Šäº†ï¼ çœŸæ²¡æƒ³åˆ°ï¼ŒçœŸæ²¡æƒ³åˆ°â€¦â€¦ ä½†æ˜¯è¿™ä¸ªåˆ†æ•°å»äº†ä¹Ÿè¦è¢«è™å§ï¼Œé«˜ä¸­éœ€è¦æ›´åŠ åŠªåŠ›æ‰è¡Œã€‚ å½•å–ç»“æœ æŸ¥çœ‹å½•å–ç»“æœ ä¸è´Ÿä¼—æœ›ï¼Ÿè€ƒå‰è¿˜ä¿¡èª“æ—¦æ—¦èƒ½ç»Ÿæ‹›ï¼Œç»“æœâ€¦â€¦ç»Ÿæ‹›çº¿é«˜è¾¾ 667.5â€¦â€¦ æ€»ç»“ é«˜ä¸€é«˜äºŒçš„æ—¶å€™å°±è¦æŒ‰é«˜ä¸‰çš„çŠ¶æ€å­¦ä¹ ï¼Œå¦åˆ™è¿˜ä¼šåƒä¸­è€ƒæ—¶é‚£æ ·æ‰‹å¿™è„šä¹±ã€å†…å¿ƒç„¦è™‘ã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"Goodbye 2021, Hello 2022!","slug":"summaries/hello2022","date":"2021-12-31T00:00:00.000Z","updated":"2021-12-31T00:00:00.000Z","comments":false,"path":"bec2b773/","link":"","permalink":"https://james1badcreeper.github.io/bec2b773/","excerpt":"å†è§ï¼Œ2021ã€‚ä½ å¥½ï¼Œ2022ï¼","text":"å†è§ï¼Œ2021ã€‚ä½ å¥½ï¼Œ2022ï¼ å¼•å­ ç­çº§æäº†æ–°å¹´è”æ¬¢ä¼šï¼Œè€Œä¸”æˆ‘æ˜¯ 1 æœˆä»½ç”Ÿæ—¥ï¼Œè€å¸ˆç›´æ¥ç»™æˆ‘ä»¬å¼€ç”Ÿæ—¥æ´¾å¯¹ï¼Œä¸è¿‡çœŸçš„æŒºå¼€å¿ƒçš„ã€‚ å€Ÿæ­¤ï¼Œå°±åœ¨è¿™é‡Œå†™ä¸€äº›å¥‡è°ˆé¬¼è®ºå§ã€‚ å›é¦– çœŸçš„å°±è¿™ä¹ˆè¿‡å»äº†ã€‚æ—¶é—´æ˜¯æœ€æ¨çš„ä¸œè¥¿ï¼Œåœ¨è½¬ç¬é—´å°±æ€æ‰äº†ä¸€åˆ‡ã€‚è¿™ä¸€å¹´å¾—åˆ°äº†ä»€ä¹ˆï¼Ÿå¯èƒ½çœŸè¯´ä¸å‡ºå£ã€‚è‡ªå·±æƒ³è¦è¾¾æˆçš„ç›®æ ‡æ²¡æœ‰è¾¾æˆï¼Œä½†æ—¶é—´ä¸åœ¨ä¹è¿™ä¸€åˆ‡ã€‚å®ƒåªæ˜¯æ— å£°åœ°é£ï¼Œè€Œä¸”é£å¾—è¶Šæ¥è¶Šå¿«ã€‚ ä½†æ—¶é—´æµé€çš„è¿¹è±¡è¿˜æ˜¯å‡ºç°äº†ï¼šæ˜¯æˆ‘ä»¬æ•™å®¤çš„ä¸­è€ƒå€’è®¡æ—¶ï¼ˆé¡ºå¸¦ä¸€æï¼Œé‚£ç©æ„å„¿è¿˜æ˜¯æˆ‘å†™çš„ï¼‰ï¼Œå®ƒä» 300 å¤šå¤©è½¬ç¬å˜æˆäº† 90 å¤©ï¼ˆ300 å¤©æ˜¯æŒ‡æ€»æ—¶é—´ï¼Œ90 å¤©æ˜¯åœ¨æ ¡æ—¶é—´ï¼Œè¿™ä¸ªå»ºè®®æ˜¯åŒ–å­¦è€å¸ˆæçš„ï¼Œåœ¨æ­¤è‡´æ•¬ï¼‰ã€‚ä¸­è€ƒç¦»è‡ªå·±è¶Šæ¥è¶Šè¿‘äº†ï¼Œå†æ²¡æœ‰å‹‡æ°”è¯´â€œæˆ‘è¿˜æœ‰æ—¶é—´â€äº†ï¼ŒæŒ‰è¿™ä¸ªæ—¶é—´æµé€çš„é€Ÿåº¦ï¼Œå¯èƒ½çœŸçš„å°±ï¼Œä¸€çœ¨çœ¼ï¼Œå³æ˜¯ä¸­è€ƒã€‚ æœªæ¥ è™½ç„¶å°±åœ¨ä¸åˆ°ä¸¤ä¸ªå°æ—¶ä¹‹åå°±ä¼šå‘ç”Ÿï¼Œä½†è¯¥è€ƒè™‘çš„äº‹æƒ…è¿˜æ˜¯éœ€è¦è€ƒè™‘çš„ã€‚è™½ç„¶ä»çºªå¹´ä¸Šæ¥çœ‹æ˜å¹´ä¼šæ˜¯äºŒé€¼çš„ä¸€å¹´ï¼ˆé›¾ï¼‰ï¼Œä½†ä»å¸Œæœ›è‡ªå·±èƒ½ä¸å¿˜åˆå¿ƒï¼Œç ¥ç ºå‰è¡Œã€‚ åœ¨æ­¤ç®€å•åˆ—ä¸€ä¸‹æ˜å¹´è¦å¹²çš„äº‹æƒ…ï¼ŒæŒ‰é‡è¦åº¦æ’åºï¼š ç»Ÿæ‹›äºŒåå››ä¸­ï¼ˆäºŒåå››æ˜¯æˆ‘ä»¬å¸‚å”¯ä¸€æ OI çš„æœ€å¥½é‡ç‚¹ï¼Œè€Œä¸”ä¿¡ç«ä¹Ÿæ˜¯å…¨çœæœ€å¼ºï¼ˆè™½ç„¶åœ¨å…¨å›½è¿˜æ˜¯å¾ˆå¼±ï¼‰ å®Œæˆ OI è®¡åˆ’å†…å®¹ï¼ˆåœ¨ä¸ªäººæ–‡ä»¶å¤¹é‡Œï¼Œä¸å…¬å¼€ï¼‰ è¯»ä¸€äº›ä¹¦ï¼Œå¯èƒ½å¯’å‡æœŸé—´ä¼šåœ¨è¿™ä¸ªåšå®¢é‡Œå¼€ä¸€ä¸ªè¯»ä¹¦è®¡åˆ’ å­¦ä¹ é«˜ä¸­çš„ç‰©ç†ï¼Œä»¥åŠé«˜ç­‰æ•°å­¦çº¿æ€§ä»£æ•°çš„éƒ¨åˆ†é‡è¦å†…å®¹ï¼Œé˜…è¯»ç§‘æ™®æ€§é‡å­åŠ›å­¦çš„ä¹¦ çœ‹èµ·æ¥ä¸å¤šï¼Œä½†ä¹Ÿå¤Ÿå¿™å¥½ä¸€é˜µå­çš„äº†ã€‚ æŠ¥ä¸€ä¸‹ç»“æœï¼Œä¸€ä¸ªä¸œè¥¿éƒ½æ²¡æœ‰å®Œæˆã€‚ä¸è¿‡äºŒåå››æ˜¯ä¸Šäº†ï¼ˆæŒ‡æ ‡ï¼‰ã€‚ æœ€å è¿™ç¯‡æ–‡ç« åœ¨åŒ†å¿™ä¸­å†™ä¸‹ï¼Œä¹Ÿæ²¡ä»€ä¹ˆå†…å®¹ã€‚æœ€åç¥æ„¿å¤§å®¶åœ¨ 2022 èƒ½æ‰¾åˆ°æ–°çš„è‡ªå·±ï¼Œå®ç°æ™¯é˜³å†ˆæ‰“è™çš„æ¢¦æƒ³ï¼Œä¸ºè‡ªå·±äº‰å–ä¸€ä¸ªæ›´ç¾å¥½çš„æœªæ¥ï¼","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"éšç¬”","slug":"éšç¬”","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"CSP-S2021 æ¸¸è®°","slug":"summaries/æ¸¸è®°/CSP2021","date":"2021-10-19T00:00:00.000Z","updated":"2021-10-19T00:00:00.000Z","comments":false,"path":"16c563fe/","link":"","permalink":"https://james1badcreeper.github.io/16c563fe/","excerpt":"CSP-S 2021 çš„æ™ºéšœçˆ†é›¶é€‰æ‰‹çš„æ¸¸è®°ï¼Œåæ ‡ï¼šLNã€‚","text":"CSP-S 2021 çš„æ™ºéšœçˆ†é›¶é€‰æ‰‹çš„æ¸¸è®°ï¼Œåæ ‡ï¼šLNã€‚ åˆèµ› å‡ ä¹å¿˜å…‰äº†ï¼Œå†™å•¥æ˜¯å•¥å§ã€‚ è€ƒè¯•é‚£å¤©ä¸‹ç€å°é›¨ï¼Œrpâ€“ æ€»æ„Ÿè§‰é¢˜ç›®å¾ˆä¸æ­£å¸¸ï¼Œæ¯”å¦‚å‡ºç°äº† base64ï¼Œç¬›å¡å°”æ ‘ Î˜(n)\\Theta(n)Î˜(n) æ±‚ RMQ ç­‰å¥‡æ€ªçš„é—®é¢˜ï¼ˆç¬›å¡å°”æ ‘é‚£é¢˜æˆ‘å¥½åƒå®Œç¾çš„é¿å¼€äº†æ­£ç¡®ç­”æ¡ˆï¼Œä¸æ„§æ˜¯ï¼ˆè¯­æ°”è¯ï¼‰è‹¦åŠ›æ€•ï¼‰ã€‚ ä½†å³ä½¿æ„Ÿè§‰è‡ªå·±ä»€ä¹ˆéƒ½ç­”é”™äº†ï¼Œè¿˜æ˜¯è€ƒäº† 67.567.567.5ï¼Œå¥½åƒæ¯”å»å¹´ä½äº†â€¦â€¦ å›½åº†æœŸé—´ æŠ¥åäº†æ´›è°·ç§‹ä»¤è¥ï¼Œè´¨é‡è‚¯å®šæ˜¯æ²¡é—®é¢˜ï¼ˆä¸æ˜¯å¹¿å‘Šï¼‰ï¼Œä½†æˆ‘å¥½åƒå¤ªè ¢äº†æœ‰äº›ä¸œè¥¿æ˜æ˜å¤ä»¤è¥è®²äº†ç§‹ä»¤è¥å†è®²ä¸€éå±…ç„¶ä¹Ÿæ²¡å¬æ‡‚ï¼ˆæ•°è®ºæ˜¯ç½ªé­ç¥¸é¦– çœ‹æ¥è¿™æ¬¡å¹¶ä¸ä¼šæ¯”å»å¹´é¡ºåˆ©äº†ï¼ŒåŠ æ²¹å§â€¦â€¦ Day -5ï¼ˆ10/18ï¼‰ å°è¯•å†™ UVA10966 3KP-BASH Projectï¼Œç»“æœæ‰å†™äº†å¤§æ¦‚ä¸€ç™¾è¡Œå°±å†™ä¸åŠ¨äº†ï¼ˆè¿™æ‰å†™äº†ä¸ªæ¡†æ¶ æ„Ÿè§‰è¶Šæ¥è¶Šä¸å¦™ï¼ˆæ‹¿ä¸åˆ°å‰ 20%20\\%20% äº†ï¼Œä¹‹å‰è¿˜å¹»æƒ³å‰ 10%10\\%10%ï¼Œå”‰â€¦â€¦ï¼‰ Day -4ï¼ˆ10/19ï¼‰ æ„Ÿè§‰å¾ˆä¸å¥½ï¼Œäºæ˜¯å†™ä¸‹äº†è¿™ç¯‡æ¸¸è®°ï¼Œä½œä¸ºé¢“åºŸæ—¶çš„å¿«ä¹ï¼ˆ æ€ä¹ˆæ„Ÿè§‰è‡ªå·±è¿˜æ˜¯ä»€ä¹ˆéƒ½ä¸ä¼šå•Šï¼ˆ Day -3ï¼ˆ10/20ï¼‰ å› ä¸ºè€ƒè¯•å‰æ€»å¾—å†™å¤§æ¨¡æ‹Ÿï¼Œæ‰€ä»¥å†™äº† [CSP-S2020] å„’ç•¥æ—¥ï¼Œç»ˆäºå†™è¿‡äº†ï¼Œå®åœ¨ä¸æƒ³å†™ 3KP-BASH Project äº†ğŸ˜¥ã€‚ Day -2ï¼ˆ10/21ï¼‰ Windows Subsystem For Android å…¬æµ‹äº†ï¼ä½†æ˜¯æˆ‘æ˜¯ devï¼Œæ‰€ä»¥æŠ˜è…¾äº†å¥½é•¿æ—¶é—´ã€‚ æå®Œæ²¡å‰©å¤šå°‘æ—¶é—´äº†ï¼Œæ‰€ä»¥å¼€å§‹è¿‡æ¨¡æ¿ã€‚ Day -1 é¢“åºŸã€‚ CSP 2021 RP++ã€‚ Day 1 è€ƒçš„æ˜¯ S ç»„ï¼Œè€Œä¸”è·Ÿè€ƒåœºåŒå¸‚ï¼Œæ‰€ä»¥å‡ºå‘å‰è¿˜æœ‰ä¸€ç‚¹æ—¶é—´å†™ä¸‹äº†è¿™ç‚¹æ–‡å­—ã€‚RP++ï¼ŒScore++ã€‚ è€ƒè¯•å‰åˆç¡äº†ä¸€ä¸ªå°æ—¶ã€‚ å¦è¯´ä¸€å¥ï¼Œæˆ‘ä¹‹å‰ä¸€ç›´ä»¥ä¸º nth_element æ˜¯ logâ¡\\loglog å¤æ‚åº¦â€¦â€¦ æˆ‘ä»¬ 14:30 æ‰è¿›çš„è€ƒåœºï¼Œå»¶è¿Ÿäº”åˆ†é’Ÿè€ƒè¯•ï¼Œåˆšæ‰“å®Œ VScode çš„ä»£ç ç‰‡æ®µå°±å¼€å§‹äº†ã€‚ T1 çœ‹äº†ä¹‹åæ„Ÿè§‰ä¸å¯¹åŠ²ï¼Œå…ˆå†™äº† O(n2m)\\mathcal{O}(n^2m)O(n2m) çš„æš´åŠ›ï¼Œåæ¥æƒ³ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–åˆ° O(nmlogâ¡n)\\mathcal{O}(nm\\log n)O(nmlogn)ï¼Œä¸è¿‡å¥½åƒæ²¡ä»€ä¹ˆç”¨ã€‚ è¿™æ—¶å¤§çº¦è¿‡äº†ä¸€ä¸ªå°æ—¶ï¼Œå¼€å§‹æ…Œäº†ï¼Œå»å¼€ T2ï¼Œä½†å‘ç° T2 å‹æ ¹å°±ä¸ä¼šå†™ï¼Œæ‰€ä»¥æœæ–­å¼ƒæ‰ï¼Œå»çœ‹ T3ã€‚ è®²ä¸ªç¬‘è¯ï¼Œè¿™æ—¶æˆ‘æ—è¾¹åŒå­¦çš„ Code::Blocks æ­»æœºäº†ï¼Œä»–è¢«å¡äº†å¤§æ¦‚äº”åˆ†é’Ÿã€‚ T3 å†™äº† 404040 åˆ†çš„æš´åŠ›åå°±èµ°äººäº†ï¼Œçœ‹äº†ä¸€çœ¼ T4 å‘ç°é¢˜ç›®å¾ˆé•¿ï¼Œä¸æ•¢å¼€ï¼Œå°±æ¥ç€å»æ T1ã€‚ T1 çš„ 404040 åˆ†åšæ³•æƒ³äº†å¥½ä¹…ï¼Œæƒ³åˆ°å¯ä»¥æ‰«ææ¯ä¸€æ¶é£æœºçœ‹æ˜¯å¦æœ‰ç©ºä½ï¼Œç„¶åæŠŠç­”æ¡ˆåŠ åˆ°å¯¹åº”çš„ç©ºä½ä¸­ï¼Œæœ€ååšä¸€éå‰ç¼€å’Œã€‚ ä½†æ»¡åˆ†åšæ³•å§‹ç»ˆæƒ³ä¸å‡ºæ¥ï¼Œæ…Œäº†ï¼Œå»ä¸Šäº†ç¬¬ä¸€è¶Ÿå•æ‰€ã€‚ å†è®²ä¸ªç¬‘è¯ï¼Œè¿™æ—¶æˆ‘æ—è¾¹åŒå­¦çš„ Code::Blocks åˆæ­»æœºäº†ï¼Œä»–è¢«å¡äº†å¤§æ¦‚å››åˆ†é’Ÿã€‚ ä¸Šå®Œå•æ‰€æ¥ç€å›æ¥æ T1ï¼Œå‘ç°ä¸ç”¨æ‰«æç©ºä½ï¼Œå¯ä»¥ç”¨ nth_element æ¥æ‰¾ï¼Œä½†ä¸çŸ¥æ€å¾—è°ƒäº†å¥½é•¿æ—¶é—´éƒ½æ²¡æœ‰è°ƒå‡ºæ¥ï¼Œè¿™æ—¶å·²ç»è¿‡å»äº†ä¸‰ä¸ªå°æ—¶ï¼Œè…¿å¼€å§‹å‘æŠ–ï¼Œå»ä¸Šäº†ç¬¬äºŒè¶Ÿå•æ‰€ã€‚ è¿™æ—¶æ—è¾¹åŒå­¦çš„ Code::Blocks åˆç‚¸äº†ï¼Œäºæ˜¯ä»–æ¢äº† Windowsï¼ˆè¿™æ˜¯ç‰¹ä¾‹ï¼Œæ­£å¸¸æˆ‘ä»¬è¿™é‡Œåªè®©ç”¨ NOILinux ç‰©ç†æœºï¼‰ã€‚ åˆè¿‡äº† 151515 åˆ†é’Ÿ T1 ç»ˆäºæŠŠå¤§æ ·ä¾‹è¿‡äº†ï¼Œè…¿ä¸å†æŠ–äº†ï¼Œå¼€å§‹çœ‹ T4ã€‚ ä½†æ˜¯æˆ‘æ²¡çœ‹æ‡‚ T4ï¼Œäºæ˜¯æŠŠ T4 ä¹Ÿç»™å¼ƒæ‰äº†ã€‚ æˆ‘æ—è¾¹åŒå­¦çš„ Windows ä¹Ÿå´©äº†ï¼Œä»–çš„ä»£ç å…¨ä¸¢äº†ï¼Œé»˜å“€ã€‚ åˆå»çœ‹ T3ï¼Œæ„Ÿè§‰é‚£ä¸ªç‰¹æ®Šæƒ…å†µå¯ä»¥æä¸€æï¼Œæƒ³äº†ä¸ªä¸çŸ¥é“æ˜¯å¯¹æ˜¯é”™çš„åšæ³•æ•²äº†ä¸Šå»ã€‚ åˆå»çœ‹ T2ï¼Œå‘ç°è¿˜æ˜¯ä¸ä¼šï¼ˆ äºæ˜¯ 100+0+(40âˆ¼55)+0=140âˆ¼155100+0+(40\\sim 55)+0=140\\sim 155100+0+(40âˆ¼55)+0=140âˆ¼155 ï¼ˆå‰§æƒ…åè½¬ æ„Ÿè§‰æ¯”å»å¹´éš¾çš„å¤šã€‚ å›æ¥çš„è·¯ä¸Šæ–°è®¤è¯†äº†ä¸€ä½åŒå¸‚çš„å¤§ä½¬ Cat_shaoï¼ŒèŠå¾—éå¸¸æ„‰å¿«ï¼ˆå¹¶ç¬¬ä¸€æ¬¡å†å½’ç¨‹ä¸­æ²¡æœ‰ç¡è§‰ï¼‰ã€‚ ç„¶åä»–è·Ÿæˆ‘è¯´ nth_element æ˜¯çº¿æ€§å¤æ‚åº¦ï¼Œå®Œï¼Œç‚¸äº†ã€‚ æ‰€ä»¥æˆ‘çš„åˆ†æ²»æ˜¯æ€ä¹ˆå­¦çš„å•Šâ€¦â€¦ äºæ˜¯ 40+0+(40âˆ¼55)+0=80âˆ¼9540+0+(40\\sim 55)+0=80\\sim 9540+0+(40âˆ¼55)+0=80âˆ¼95ï¼Œæˆ‘æ˜¯å‚»é€¼ã€‚ èµ›åæ€»ç»“ é—®é¢˜è¿˜æ˜¯å¾ˆä¸¥é‡ï¼Œä¸€æ˜¯åšé¢˜åšå°‘äº†ï¼Œå¯¼è‡´é¢˜æ ¹æœ¬æƒ³ä¸å‡ºæ¥ï¼Œä»¥åéœ€è¦ç‹‚åˆ·é¢˜ã€‚ å†è€…æœ‰äº›çŸ¥è¯†çš„ç†è§£è¿˜æ˜¯æœ‰åå·®ï¼Œåšå®¢è¦å‹¤å†™ï¼Œå†™çš„æ—¶å€™å¯¹ç€æ–‡æ¡£æˆ–ä¹¦ä¿è¯æ­£ç¡®æ€§ã€‚ æœ€ååƒä¸‡ä¸è¦ä»¥ä¸ºåœ¨å¼±çœå°±å¾ˆè½»æ¾ï¼Œæœ‰çš„æ—¶å€™ä½ è¿›æ­¥çš„é€Ÿåº¦è¿˜æ²¡ CCF é¢˜ç›®å˜éš¾çš„é€Ÿåº¦å¿«ã€‚ å¯æ€œå¤©ä¸‹äººå•Šâ€¦â€¦ èµ›å æœ€ååˆ†æ•° 606060ï¼Œä¸è¯´å…·ä½“é—®ä»€ä¹ˆäº†ï¼Œæ¥ä¸‹æ¥æ˜¯ä¸€äº›æ€»ç»“ï¼Œå¸Œæœ›èƒ½å¸®åŠ©åˆ°æˆ‘å’Œå¤§å®¶ã€‚ é¦–å…ˆæ˜¯è®­ç»ƒæ–¹å¼çš„é—®é¢˜ã€‚æ„Ÿè§‰å¤§çº²ä¸Šçš„çŸ¥è¯†ç‚¹éƒ½å­¦å¾—å·®ä¸å¤šï¼Œä½†è€ƒåœºä¸Šå´ä¹Ÿä»€ä¹ˆéƒ½ä¸ä¼šï¼Œæ ¹æœ¬åŸå› åœ¨äºé¢˜åˆ·çš„å®åœ¨å¤ªå°‘ã€‚æ¯”å¦‚ T1 çš„â€œæ‰«æç®—æ³•â€ï¼Œåœ¨ã€Šè®­ç»ƒæŒ‡å—ã€‹ä¸­ç¬¬ä¸€ç« çš„ä¾‹é¢˜ä¸­å‡ºç°è¿‡ï¼Œç»Ÿè®¡å‰ç¼€å’Œçš„æ€è·¯ä¹Ÿåœ¨ Codeforces çš„ä¸€åœºæ¯”èµ›ä¸­å‡ºç°è¿‡ï¼ˆæƒ³è¿™ä¸ªè·¯åœ¨è€ƒåœºä¸ŠèŠ±äº†å¤§é‡çš„æ—¶é—´ï¼‰ã€‚å†å¦‚ T3 æ·±å…¥åˆ†æ + è´ªå¿ƒï¼Œå¹³æ—¶å¤šåšç‚¹é¢˜å°±ä¸ä¼šå†è€ƒåœºä¸Šå‡„æƒ¨çš„æ­»äº¡ã€‚è¿›è€ƒåœºä¹‹å‰å……æ»¡ä¿¡å¿ƒï¼Œå‡ºæ¥ä¹‹åå› è‡ªå·±å¯¹çŸ¥è¯†ç‚¹çš„è¯¯è§£è€Œä¿¡å¿ƒæ»¡æ»¡åœ°è¸ä¸Šäº†å½’ç¨‹ï¼Œä»¥ä¸ºè‡ªå·±å¾—äº† 155155155 åˆ†ï¼Œå®é™…ä¸Šå°±æ˜¯ä¸ªå‚»é€¼ã€‚è¿™ç§æ€åº¦ï¼Œåªèƒ½ä½¿è‡ªå·±æ¶ˆäº¡åœ¨å†å²é•¿æ²³ä¹‹ä¸­ã€‚ æ‰€ä»¥ï¼Œç«¯æ­£è‡ªå·±çš„æ€åº¦å§ï¼Œåˆ«å†æé‚£äº›æ²¡ç”¨çš„äº†ã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"LNOI2021 æ¸¸è®°","slug":"summaries/æ¸¸è®°/LNOI2021","date":"2021-04-10T00:00:00.000Z","updated":"2021-04-10T00:00:00.000Z","comments":false,"path":"1f5836f2/","link":"","permalink":"https://james1badcreeper.github.io/1f5836f2/","excerpt":"åæ ‡ï¼šLN-DLã€‚","text":"åæ ‡ï¼šLN-DLã€‚ Day ? ç”±äº NOIP ä¸ç†æƒ³çš„æˆç»©ï¼ŒåŠ ä¸ŠçŸ¥é“è‡ªå·±åŸºæœ¬ä»€ä¹ˆä¹Ÿä¸ä¼šï¼Œæ‰€ä»¥è¿™æ¬¡çœé€‰æ˜¯æŠ±ç€å»ç©çš„å¿ƒæ€å»çš„ã€‚ è™½ç„¶å£å¤´è¯´ç€æ˜¯å»ç©ï¼Œä½†æ˜¯å¿ƒé‡Œå´æœ‰ä¸€ç§è«åçš„ç´§å¼ ï¼Œæ¯•ç«Ÿæ˜¯ç¬¬ä¸€æ¬¡å‚åŠ çœé€‰ï¼ Day -1 è¿™ä¸€å¤©ï¼ˆå‘¨äº”ï¼‰è¿›æ ¡çš„æ—¶å€™å‘ç°è¯¾ç¨‹è¡¨ä¸å¯¹ï¼Œå¤–è¯­ä¸ºä»€ä¹ˆè¢«è°ƒåˆ°äº†ä¸‹åˆç¬¬ 777 èŠ‚è¯¾ï¼Ÿï¼ˆç­ä¸»ä»»æ˜¯å¤–è¯­è€å¸ˆï¼Œè€Œä¸”ç¬¬ 888 èŠ‚æ™šè¯¾ï¼ˆçŸ­è¾¾ 909090 åˆ†é’Ÿï¼‰ä¹Ÿæ˜¯è‹±è¯­ã€‚ ç”±äºç›®å‰åˆäºŒåœ¨è¯»ï¼Œå­¦æ ¡æ˜¯ä¸å¯èƒ½ç»™åœè¯¾å»è®­ç»ƒ OI çš„ï¼Œä¸­åˆè‡ªä¹ æ—¶é—´å°±æŠ±ç€æç…œä¸œçš„ã€Šç®—æ³•ç«èµ›è¿›é˜¶æŒ‡å—ã€‹ç¿»æ¥ç¿»å»åœ°çœ‹ï¼Œä½†å®é™…ä¸Šä¸€ä¸ªå­—ä¹Ÿæ²¡çœ‹è¿›å»ã€‚ æœˆè€ƒåœ¨ä¸¤å¤©å‰ç»“æŸï¼Œä¸Šåˆå¬è€å¸ˆå¿µäº†ç¬¬ä¸€ç§‘å‡ºæ¥çš„æ•°å­¦çš„åˆ†æ•°ï¼Œæˆ‘ä»…è€ƒäº† 138138138 åˆ†ï¼ŒçœŸçš„éå¸¸ç³Ÿç³•ï¼Œè™½ç„¶åªæœ‰ 5 åˆ†çš„é¢˜æ˜¯çœŸå¿ƒä¸ä¼šï¼ˆæˆ‘çœŸæ²¡æƒ³åˆ°è½¬å®Œé‚£ä¸ªç›´è§’ä¸‰è§’å½¢åè¦è¿å››æ¡çº¿ï¼‰ï¼Œæ­¥éª¤è¢«æ‰£äº† 777 åˆ†ï¼Ÿ ä¸­åˆæˆ‘åœ¨å‘æœ¬ã€‚ç”±äºæ˜¯å¼±çœå¼±æ ¡ï¼Œå‘¨å›´åŒå­¦ç´ è´¨æå·®ï¼Œä¸­åˆæœ‰æŠŠè‹¹æœå½“æˆç‚¸å¼¹æ‰”çš„ï¼Œæœ‰æ‰“æ¶çš„ï¼Œæœ‰åœ¨è®²å°å‰è¸±æ¥è¸±å»åœ°å”±ç€æ­Œçš„ï¼ˆé›¾ï¼‰ã€‚ ç„¶è€Œåˆé—´è‡ªä¹ å¼€å§‹çš„æ—¶å€™è€å¸ˆå«æˆ‘ä»¬åå¥½ï¼Œå¼„å¾—æˆ‘æ‘¸ä¸ç€å¤´è„‘ã€‚ ç»“æœæ˜¯ï¼Œè€å¸ˆæ‰“ç®—ä»Šå¤©ä¸‹åˆå¸¦æˆ‘ä»¬å»å¤§è¿è‘—åçš„æ˜Ÿæµ·å…¬å›­å»çœ‹è‘—åçš„åœ£äºšæµ·æ´‹ä¸–ç•Œï¼ ä¿—è¯è¯´çš„çœŸå¥½ï¼Œè¿‘å¤„æ²¡æœ‰å¥½çœ‹çš„é£æ™¯â€¦â€¦ å¤©å“ªï¼Œè¿™æ˜¯ä¸“é—¨ä¸ºæˆ‘æ•£å¿ƒè€Œå‡†å¤‡çš„å—ï¼Ÿ æ‰€ä»¥ç•™ä¸‹äº†ä¸€äº›éå¸¸ç¾å¥½çš„å›å¿†ã€‚æˆ‘ç¬é—´æ„Ÿè§‰å¯¹çœé€‰å……æ»¡äº†ä¿¡å¿ƒã€‚ ä¸€äº›å›å¿† å—¯ï¼Œè¿™æ˜¯ã€Šæµ·è±šæ¹¾ä¹‹æ‹ã€‹ï¼Œä¸è¿‡æˆ‘è®°å¾—ä»¥å‰æ˜¯æœ‰æµ·ç›—çš„ï¼Œç°åœ¨è¢«åˆ äº†qaqåŠŸ å¤« æµ· è±¡è¿™é‡Œå¯æ˜¯å›½å®¶çº§çš„ä¼é¹…ç¹æ®–åŸºåœ°å‘¢ï¼é—¹ é¬¼ ç³» åˆ—ï¼ˆå·¦è¾¹çš„åŒå­¦åä¸ºâ€œå¦å…‹â€ï¼‰è¿™äº›æ˜¯æˆ‘ä»¬è€å¸ˆæ‹æ‘„çš„ç…§ç‰‡ï¼Œåœ¨æ­¤è¡¨ç¤ºæœ€å´‡é«˜çš„æ•¬æ„ï¼ LNOI2021 åŠ æ²¹ï¼æœˆè€ƒåˆ†åœ¨æ™šä¸Šå…¨å‡ºæ¥äº†ï¼šè¯­æ–‡ï¼ˆ83/100ï¼‰ï¼Œæ•°å­¦ï¼ˆ138/150ï¼‰ï¼Œå¤–è¯­ï¼ˆ131/140ï¼‰ï¼Œç‰©ç†ï¼ˆ87/90ï¼‰ï¼Œä½†æ˜¯ä¸çŸ¥é“å¹´çº§æ’åâ€¦â€¦ Day 1 è¿˜å¥½åœ¨å¤§è¿å¤§å­¦è€ƒï¼Œå¦åˆ™å‘¨äº”ä¸‹åˆçš„æ´»åŠ¨æˆ‘å°±ä¸èƒ½å»äº†ï¼Œéœ€è¦è¯·å‡èµ¶å¾€æ²ˆé˜³ä¹‹ç±»çš„åœ°æ–¹ã€‚ ç­‰å¾…çš„æ—¶å€™çœ‹åˆ°äº†è®¸å¤šç¥ä»™ï¼Œé™¤äº†ä¸€ä¸ª wmh æ¯”æˆ‘å°ï¼Œå‰©ä¸‹éƒ½æ˜¯é«˜ä¸­ç”Ÿï¼Ÿæ„Ÿè§‰ä»–ä»¬å¥½å‰å®³çš„æ ·å­ï¼ˆå…¶å®çœŸçš„å¾ˆå‰å®³ï¼‰ã€‚ è¿›è€ƒåœºäº†ï¼ è™½ç„¶é¢˜ç›®è¦æ¯”æˆ‘é¢„æƒ³ä¸­çš„ç®€å•ä¸å°‘ï¼Œä½†æˆ‘è¿˜æ˜¯ä»€ä¹ˆä¹Ÿä¸ä¼šã€‚ T1 æ‹¿äº† 202020 åˆ†çš„æš´åŠ›æ»šè›‹äº†ã€‚ T2 å¯èƒ½åšå‡ºäº† m=2 çš„æƒ…å†µæ‹¿äº† 303030 åˆ†ï¼Œä½†ç”±äºæ„Ÿè§‰è‡ªå·±å†™çš„æœ‰ç‚¹é—®é¢˜ï¼Œæ‰€ä»¥ä¹Ÿå¯èƒ½æ˜¯ 0 åˆ†ã€‚ T3 åšäº†ä¸ª 161616 åˆ†çš„æš´åŠ›ç„¶ååˆæ»šè›‹äº†ã€‚ Day 1 ä¼°åˆ†ï¼ˆæœ€æ‚²è§‚ï¼‰ï¼š20+0+16=3620 + 0 + 16 = 3620+0+16=36 å—¯ï¼Œæˆ‘çœŸèœã€‚ Day 2 å¿ƒ æƒ… æ ä¸º éƒ é—·ã€‚ T1 å—¯ï¼Œè¿™é¢˜æˆ‘ä¸ä¼šï¼Œæ‰€ä»¥æˆ‘é€‰æ‹©ç›´æ¥æ‰“æš´åŠ›ï¼Œä»¥ä¸ºåªæœ‰ 101010 åˆ†çš„æš´åŠ›ç«Ÿç„¶æ‹¿äº† 252525 åˆ†ï¼Ÿ T2 å—¯ï¼Œè¿™é¢˜æˆ‘ä¹Ÿä¸ä¼šã€‚ è€Œä¸”å¥½åƒè¿æš´åŠ›ä¹Ÿä¸ä¼šäº†ï¼ˆç”Ÿæˆæ’ååä¸çŸ¥é“æ€ä¹ˆåˆ¤æ–­æ˜¯å¦æˆç«‹ï¼‰ï¼Œæœ€åèƒ¡ä¹±å†™ä¸Šå»äº†ä¸€ä¸ªï¼Œé¢„æœŸå¾—åˆ† 000 åˆ†ã€‚ T3 å—¯ï¼Œè¿™é¢˜æˆ‘è¿˜æ˜¯ä¸ä¼šã€‚ ï¼ˆæŸäººï¼šä½ ç©¶ç«Ÿä¼šå•¥ï¼Ÿï¼‰ è€Œä¸”è¿æš´åŠ›ä¹Ÿä¸ä¼šäº†qwqã€‚ æœ€åä¼¼ä¹æå‡ºäº†è¿™å›¾æ˜¯æ ‘çš„æƒ…å†µå¾—äº† 151515 åˆ†ï¼ˆä½†ä¹Ÿå¯èƒ½æ˜¯é”™çš„ï¼‰ï¼Œé¢„æœŸå¾—åˆ† 000 åˆ†ã€‚ âˆ´\\thereforeâˆ´ Day2 ä¼°åˆ†ä¸º 10+0+0=1010+0+0=1010+0+0=10ã€‚ âˆ´\\thereforeâˆ´ æœ€ååˆ†æ•°ä¸º 20+0+16+10+0+0=4620+0+16+10+0+0=4620+0+16+10+0+0=46ã€‚ ä½ å¯ä»¥é€€å½¹äº†ï¼Œä½ è¿™ä¸ªæ¾é¥¼è„‘è¢‹ã€‚â€”â€”è·¯äººç”²ã€‚ Day 4 æœˆè€ƒç­çº§æ’å Rk2ï¼Œå¹´çº§ Rk4ã€‚ Day 6 or 7 æœ€ç»ˆåˆ†æ•°ä¸º 102102102 ï¼ˆæˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆæ˜¯è¿™ä¸ªåˆ†æ•°ï¼Œé€ƒ ä½†å³ä½¿æ¯”é¢„æœŸçš„é«˜äº†ä¸å°‘ï¼Œæ’åä¾ç„¶æ˜¯å«åº•ï¼Œåœ¨å 10%10\\%10% çš„ä½ç½®ã€‚ å”‰ï¼Œè¿˜æ˜¯å¤ªèœäº†ï¼Œä½†æ²¡å…³ç³»ï¼Œæ˜å¹´æ¥ç€æ¥ï¼ ä¸ç®¡æ€æ ·ï¼Œæˆ‘ä¸€å®šè¦å˜å¼ºã€‚ æˆ‘ä¼°è®¡ä½ æ˜å¹´è¿˜æ˜¯å€’æ•°ï¼Œä½ è¿™ä¸ªæ¾é¥¼è„‘è¢‹ã€‚â€”â€”è·¯äººç”²ã€‚","categories":[{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]}],"categories":[{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"åšé¢˜è®°å½•","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"åŠ è®­","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/åŠ è®­","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"},{"name":"æ–‡ç« ","slug":"æ–‡ç« ","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"è®°å½•","slug":"æ–‡ç« /è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI å¤ä¹ ","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/NOI-å¤ä¹ ","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"},{"name":"æ¯”èµ›è®°å½•","slug":"ç®—æ³•ç«èµ›/æ¯”èµ›è®°å½•","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"},{"name":"Codeforces","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/Codeforces","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/Codeforces/"},{"name":"ATCoder","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/ATCoder","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ATCoder/"},{"name":"ICPC","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/ICPC","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ICPC/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/categories/%E9%97%B2%E8%AF%9D/"},{"name":"JOI","slug":"ç®—æ³•ç«èµ›/åšé¢˜è®°å½•/JOI","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/JOI/"},{"name":"é—²è¯","slug":"æ–‡ç« /é—²è¯","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"æ•°æ®ç»“æ„","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"å›¾è®º","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/å›¾è®º","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"},{"name":"æ•°å­¦","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/æ•°å­¦","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"},{"name":"å­—ç¬¦ä¸²","slug":"ç®—æ³•ç«èµ›/å­¦ä¹ ç¬”è®°/å­—ç¬¦ä¸²","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"é—²è¯","slug":"é—²è¯","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"éšç¬”","slug":"éšç¬”","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"ç®—æ³•ç«èµ›","slug":"ç®—æ³•ç«èµ›","permalink":"https://james1badcreeper.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"ç¾¤è®º","slug":"ç¾¤è®º","permalink":"https://james1badcreeper.github.io/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"åšå¼ˆè®º","slug":"åšå¼ˆè®º","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"å•è°ƒé˜Ÿåˆ—","slug":"å•è°ƒé˜Ÿåˆ—","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"wqs äºŒåˆ†","slug":"wqs-äºŒåˆ†","permalink":"https://james1badcreeper.github.io/tags/wqs-%E4%BA%8C%E5%88%86/"},{"name":"æ–œç‡ä¼˜åŒ–","slug":"æ–œç‡ä¼˜åŒ–","permalink":"https://james1badcreeper.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"},{"name":"å››è¾¹å½¢ä¸ç­‰å¼","slug":"å››è¾¹å½¢ä¸ç­‰å¼","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/"},{"name":"æ•°æ®ç»“æ„ä¼˜åŒ–","slug":"æ•°æ®ç»“æ„ä¼˜åŒ–","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/"},{"name":"åˆ†å—","slug":"åˆ†å—","permalink":"https://james1badcreeper.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"æ•°æ®ç»“æ„f","slug":"æ•°æ®ç»“æ„f","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84f/"},{"name":"æ•°è®º","slug":"æ•°è®º","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"å¯æŒä¹…åŒ–","slug":"å¯æŒä¹…åŒ–","permalink":"https://james1badcreeper.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"æ ‘å¥—æ ‘","slug":"æ ‘å¥—æ ‘","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"å¹³è¡¡æ ‘","slug":"å¹³è¡¡æ ‘","permalink":"https://james1badcreeper.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"Treap","slug":"Treap","permalink":"https://james1badcreeper.github.io/tags/Treap/"},{"name":"Splay","slug":"Splay","permalink":"https://james1badcreeper.github.io/tags/Splay/"},{"name":"FHQ-Treap","slug":"FHQ-Treap","permalink":"https://james1badcreeper.github.io/tags/FHQ-Treap/"},{"name":"ç»„åˆæ•°å­¦","slug":"ç»„åˆæ•°å­¦","permalink":"https://james1badcreeper.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"å¤šé¡¹å¼","slug":"å¤šé¡¹å¼","permalink":"https://james1badcreeper.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"ç½‘ç»œæµ","slug":"ç½‘ç»œæµ","permalink":"https://james1badcreeper.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"æäº¤ç­”æ¡ˆ","slug":"æäº¤ç­”æ¡ˆ","permalink":"https://james1badcreeper.github.io/tags/%E6%8F%90%E4%BA%A4%E7%AD%94%E6%A1%88/"},{"name":"äº¤äº’é¢˜","slug":"äº¤äº’é¢˜","permalink":"https://james1badcreeper.github.io/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/"},{"name":"æ„é€ ","slug":"æ„é€ ","permalink":"https://james1badcreeper.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"éšæœºåŒ–","slug":"éšæœºåŒ–","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"https://james1badcreeper.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"åˆ·","slug":"åˆ·","permalink":"https://james1badcreeper.github.io/tags/%E5%88%B7/"},{"name":"Div.2","slug":"Div-2","permalink":"https://james1badcreeper.github.io/tags/Div-2/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"},{"name":"æ¯”èµ›","slug":"æ¯”èµ›","permalink":"https://james1badcreeper.github.io/tags/%E6%AF%94%E8%B5%9B/"},{"name":"å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†","permalink":"https://james1badcreeper.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"ATCoder","slug":"ATCoder","permalink":"https://james1badcreeper.github.io/tags/ATCoder/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"æ ‘çŠ¶æ•°ç»„","slug":"æ ‘çŠ¶æ•°ç»„","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"æ ‘å½¢ DP","slug":"æ ‘å½¢-DP","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E5%BD%A2-DP/"},{"name":"å›¾ä¸Š DP","slug":"å›¾ä¸Š-DP","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E4%B8%8A-DP/"},{"name":"ç”Ÿæˆæ ‘","slug":"ç”Ÿæˆæ ‘","permalink":"https://james1badcreeper.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"æ¦‚ç‡","slug":"æ¦‚ç‡","permalink":"https://james1badcreeper.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"æœŸæœ›","slug":"æœŸæœ›","permalink":"https://james1badcreeper.github.io/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"çº¿æ€§ä»£æ•°","slug":"çº¿æ€§ä»£æ•°","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"çŸ©é˜µå¿«é€Ÿå¹‚","slug":"çŸ©é˜µå¿«é€Ÿå¹‚","permalink":"https://james1badcreeper.github.io/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"é«˜æ–¯æ¶ˆå…ƒ","slug":"é«˜æ–¯æ¶ˆå…ƒ","permalink":"https://james1badcreeper.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"çŠ¶å‹ DP","slug":"çŠ¶å‹-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%8A%B6%E5%8E%8B-DP/"},{"name":"æ ‘","slug":"æ ‘","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91/"},{"name":"LCA","slug":"LCA","permalink":"https://james1badcreeper.github.io/tags/LCA/"},{"name":"æ ‘çš„ç›´å¾„","slug":"æ ‘çš„ç›´å¾„","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"æ ‘çš„é‡å¿ƒ","slug":"æ ‘çš„é‡å¿ƒ","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"æ ‘é“¾å‰–åˆ†","slug":"æ ‘é“¾å‰–åˆ†","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"æ ‘ä¸Šå·®åˆ†","slug":"æ ‘ä¸Šå·®åˆ†","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"},{"name":"æœ€çŸ­è·¯","slug":"æœ€çŸ­è·¯","permalink":"https://james1badcreeper.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"å·®åˆ†çº¦æŸ","slug":"å·®åˆ†çº¦æŸ","permalink":"https://james1badcreeper.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"çº¿æ€§ DP","slug":"çº¿æ€§-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7-DP/"},{"name":"åŒºé—´ DP","slug":"åŒºé—´-DP","permalink":"https://james1badcreeper.github.io/tags/%E5%8C%BA%E9%97%B4-DP/"},{"name":"èƒŒåŒ…","slug":"èƒŒåŒ…","permalink":"https://james1badcreeper.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"åŒæŒ‡é’ˆ","slug":"åŒæŒ‡é’ˆ","permalink":"https://james1badcreeper.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"å‰ç¼€å’Œ","slug":"å‰ç¼€å’Œ","permalink":"https://james1badcreeper.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"å·®åˆ†","slug":"å·®åˆ†","permalink":"https://james1badcreeper.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"å•è°ƒæ ˆ","slug":"å•è°ƒæ ˆ","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"æ‰¾è§„å¾‹","slug":"æ‰¾è§„å¾‹","permalink":"https://james1badcreeper.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"è§£é¢˜","slug":"è§£é¢˜","permalink":"https://james1badcreeper.github.io/tags/%E8%A7%A3%E9%A2%98/"},{"name":"Div.4","slug":"Div-4","permalink":"https://james1badcreeper.github.io/tags/Div-4/"}]}