{"meta":{"title":"james1 的博客","subtitle":"","description":"james1","author":"james1BadCreeper","url":"https://james1badcreeper.github.io","root":"/"},"pages":[{"title":"","date":"2024-04-21T08:35:39.251Z","updated":"2024-04-21T08:35:39.251Z","comments":true,"path":"404.html","permalink":"https://james1badcreeper.github.io/404.html","excerpt":"","text":"无相幽闭蒙蔽了你的双眼。很抱歉，您访问的页面丢失了。可能输入地址有误或该地址已被移动或删除。如果您认为您输入的地址没有问题，可以通过下方的评论来告诉我们是哪里发生了灵异事件。以下是可能导致 404 的原因：我们于 2023/10/3 取消了文章绝对路径的年份，如果您输入的地址带有年份，那么删除它们就应该能正常访问了。 无内鬼，搞点图片鉴赏，为 bing 每日壁纸"},{"title":"","date":"2024-04-21T08:35:39.275Z","updated":"2024-04-21T08:35:39.275Z","comments":true,"path":"about/index.html","permalink":"https://james1badcreeper.github.io/about/index.html","excerpt":"","text":"我们终将从时光归来，为宇宙奏响遗忘的镇魂曲。 欢迎您，旅行者！ 希望您可以在这个简陋的地方度过一个愉快的夜晚~ 动态友链关于 这是什么？我在哪里？ 我也不知道。 这里是 james1BadCreeper 的博客。免费搭建，极不可靠。 主要记录奇怪的东西。当东西奇怪到一定程度，就不再是东西了。 参数如下： Key Value Generator Hexo Theme Volantis Wiki，Repo Deploy on Github Pages CDN jsdelivr 图床 路过图床 &amp; 聚合图床 公式渲染 KaTeX\\KaTeXKATE​X 你是什么？ 一只苦力怕，而且是来自远古的机器人。 一名普通的 OIer，就读于大连市第二十四中学。 您可以叫我 james1，或者也可以叫我 iznomia。 成分可能比较复杂，人可能比较抽象。 16personalities 人格类型 音乐游戏其它这里放一个歌单（别问我为什么没有链接，这是 LX 导出的 txt），应该可以看出个大概，不定期更新。 已为您折叠过长的内容 曲名艺术家专辑10000ColBreakz10000彩虹山文雀彩虹山大梦想家TFBOYS大梦想家登神 (GODS)NewJeans登神 (GODS)冬の花宮本浩次冬の花二向箔Bo Peep、CDY二向箔风之海华晨宇风之海疯人院华晨宇新世界NEW WORLD父亲筷子兄弟父亲歌者·时间童话凑诗【三体】歌者·时间童话孤勇者 (Live)张杰时光音乐会老友记 第6期红日李克勤红日花に亡霊ヨルシカ花に亡霊骄傲的少年南征北战NZBZ骄傲的少年今、歩き出す君へ。 (献给此刻迈步前行的你。)CeuiPCゲーム いますぐお兄ちゃんに妹だっていいたい! ボーカルアルバム九龙赞群星热门华语259恋愛サーキュレーション花澤香菜恋愛サーキュレーション &amp; あとがたり恋心-Rest in Peace-rionos恋心-Rest in Peace-輪廻山本美禰子さくら、もゆ。-as the Night’s, Reincarnation- ミュージックコレクション裸の勇者 (赤身勇者)Vaundy裸の勇者面壁者G.E.M.邓紫棋面壁者秒針を噛むずっと真夜中でいいのに。正しい偽りからの起床南方文雀看风景的人平凡之路朴树猎户星座起风了周深起风了青春修炼手册TFBOYS青春修炼手册群青YOASOBI群青人是_周深人是_如果菠萝赛东、Bo Peep如果杀死那个石家庄人万能青年旅店万能青年旅店 同名专辑沙漠骆驼展展与罗罗沙漠骆驼深海少女のぶなが、ゆうゆvoices in a bottle ～海を越え届いた歌声～神的传说谭咏麟让我们做得更好水手郑智化私房歌死にゆく季節のきみへ麻枝准、やなぎなぎ死にゆく季節のきみへ塑料袋乔杉缝纫机乐队 电影原声音乐她说林俊杰她说 概念自选辑网络热门科普工作者鉴定Bo Peep网络热门科普工作者鉴定心拍数#0822H△G声 ~VOCALOID Cover Album~星空Richard ClaydermanRichard Clayderman星星点灯郑智化星星点灯星の墓標麻枝准、やなぎなぎ星の墓標嘘月ヨルシカ創作寻华晨宇寻烟火里的尘埃华晨宇烟火里的尘埃夜航星 (Night Voyager)不才、三体宇宙我的三体之章北海传 原声音乐集夜空中最亮的星逃跑计划世界夜未央谭咏麟难舍难分夜行ヨルシカ夜行夜に駆けるYOASOBI夜に駆ける异邦人の刃佐藤直紀ストレンヂア-无皇刃谭-オリジナル・サウンドトラック异类华晨宇异类永恒孤独周深三体 电视剧影视原声带追光者 (Live)张杰时光音乐会老友记 第7期最后一首歌迪克牛仔忘记我还是忘记他左脑右脑洛天依、阿良良木健恋爱理论A Historic ReckoningBackground Music LabEpic Cinematic Background (Heroic, Inspiring, Dramatic Trailer Music)A Historic ReckoningRubric、Kyle PrestonA Historic ReckoningA New DayMark Petrie1M1 Music Volume 1AbiogenesisJuggernaut.AD:PIANO VII -Alternative-After You SleeprionosAfter You SleepAge of WondersBrunuhVilleAge of WondersaLIEz瑞葵(mizuki)、SawanoHiroyuki[nZk]A/ZAmerican IdiotGreen DayAmerican Idiot (Deluxe)AnimalsMartin GarrixHardwell Presents Revealed Volume 4AnomalyLights &amp; MotionDear AvalancheAnother WorldRazorrekkerAnother WorldApolloThomas BergersenHumanity - Chapter IVArise (Trailer Music)Mark PetrieEpic Action AdventureBad Apple!! feat. nomicoのみこEXSERENSBe What You Wanna BeDarinDarinBecause of YouKelly ClarksonBecause Of YouBefore I Riseやなぎなぎ、麻枝准Before I RiseBelieve In Myself (相信我自己)EDGE of LIFEEDGE of LIFEBlackheartTwo Steps From Hell、Thomas BergersenSkyworldBreatheTwo Steps From HellLegend OriginsBrotherhoodJohn DreamerBrotherhoodCalamityTwo Steps From HellLegendCelestialEd SheeranCelestialChildren of the SunThomas Bergersen、Merethe SoltvedtChildren Of The SunCollapsing WorldLightscapeCollapsing WorldConnected SkyKARUTBlue Archive Original Soundtrack Vol.1 ~Longing for the Memorable Days ~Constant ModeratoミツキヨBlue Archive Original Soundtrack Vol.1 ~Longing for the Memorable Days ~Croatian Rhapsody (Arr. Bratos &amp; Kazinoti)Maksim、Nikša Bratoš、Remi Kazinoti、Craig Pruess、OrchestraThe Piano PlayerDamnationReally Slow MotionSupremacyDemonsImagine DragonsTransports en communDepend on meVIXXDepend on me(初回限定盤A)DragonheartedTryHardNinjaDragonheartedDragonwingTwo Steps From Hell、Thomas BergersenDragonDream ChasersFuture World MusicReign of VengeanceDream It PossibleDelaceyDream It PossibleEl DoradoTwo Steps From Hell、Thomas BergersenSkyworldEmerald PrincessTwo Steps From Hell、Thomas BergersenDragonEmpire Of AngelsTwo Steps From HellEternalEndless WarWithin TemptationResist (Extended Deluxe)Energetic Indie RockKLM MusicKlm Music, Vol. 8EntropyNick MurrayAeonExperienceLudovico Einaudi、Daniel Hope、I Virtuosi ItalianiRoyalcoreExtinctionBrand X MusicBrand X Music Vol. 11Extreme Ways (Bourne’s Ultimatum)MobyThe Bourne UltimatumFadedAlan WalkerFadedFake Love (Orchestral Version)MDPOriginsFallen KingdomTryHardNinjaFallen KingdomFalling AgainNurko、RoniitFalling Again (feat. Roniit)Far Beyond the MountainsPeter RoeFrozen WildsFinal Days of RomeTwo Steps From HellUnleashedFind the PiecesTryHardNinjaPick a UniverseFool For YouKASTRAFool For YouFool For You (VIP Mix)KASTRAFool For You (VIP Mix)For The WinTwo Steps From Hell、Thomas BergersenSkyworldForever (Epic Edition)PIKASONICForever (Epic Edition)Fractures (Trivecta Remix)ILLENIUM、Nevve、TrivectaAwake (Remixes)Freedom Is OursEpic ScoreVengeance - ES033Future FunkVarienPick Your Poison Vol. 01Go SoloTom RosenthalThe Pleasant TreesHe’s a PirateKlaus BadeltPirates of the Caribbean: The Curse of the Black PearlHellbreakerSub Pub MusicEquilibriumHotel California (2013 Remaster)EaglesThe Studio Albums 1972-1979 (2013 Remaster)HumanityThomas Bergersen、Audrey CallahanHumanity - Chapter II’m A Star周深I’m A Star (电影《星愿》许愿星之歌)IcarusIvan TorrentIcarusImmortalThomas BergersenIllusionsImpossibleTwo Steps From HellUnleashedIn the EndTommee Profitt、Jung Youth、FleurieIN THE END (Cinematic Cover)Into YouMatisse &amp; Sadko、Hanne MjøenInto YouIt Wouldn’t Be RightChasing JonahPreludeIt’s My LifeBon JoviCrushLast Reunion (Epicmusicvn Series)Peter RoeLast Reunion (Epicmusicvn Series)Last TransmissionNINJA TRACKSA Million Stars FallingLegends Never DieAgainst the CurrentLegends Never DieLemon米津玄師LemonLiberatorsEpic ScoreVengeance - ES033Light Years麻枝准、やなぎなぎLight YearsLost FlowersrionosLost FlowersLove The Way You LieEminem、RihannaRecovery (Explicit)Luminous memoryミツキヨ( • ̀ω•́ )✧MILABOずっと真夜中でいいのに。朗らかな皮膚とて不服Minecraft Pigstep (Remix)FlyxTheKidMinecraft PigstepMinecraft StyleTryHardNinjaMinecraft StyleMonody (Radio Edit)TheFatRat、Laura BrehmMonody (Radio Edit)MonstersTimeflies、Katie SkyAfter HoursMountain CallThomas BergersenHumanity - Chapter IMythTwo Steps From Hell、Thomas BergersenMythNevadaVicetone、Cozi ZuehlsdorffNevadaNever Back DownTwo Steps From HellBattlecryNever Give up on Your DreamsTwo Steps From HellUnleashedNew LightMark Petrie1M1 Music Volume 8On My OwnAshes RemainWhat I’ve BecomeOnly My RailgunfripSideonly my railgunOther WorldsReally Slow MotionOther WorldsothersideLena RaineMinecraft: Caves &amp; Cliffs (Original Game Soundtrack)Out of Time (Sagan Remix)Sagan、Shane 54、Cubicore、Eric LumiereOut of TimePastel Subliminala_hisacolorsPitcairn StoryMichael ConnGlobe Trekker - EpicPromise of HopeInside Tracks、Liquid CinemaMusic Featured in “Aladdin” TrailerRadiant塞壬唱片-MSR、Mary ClareRadiantRenegadesX AmbassadorsVHSRequiem For A DreamJennifer ThomasIlluminationResuscitated HopeコミネリサResuscitated Hope/unityRevengeCaptainSparklezRevengeRicochetRob GasserRicochetRISEThe Glitch Mob、Mako、The Word AliveRISERise - Epic MusicJohn DreamerRise - Epic MusicRise of the EmpireCharles Ian EvansHeroesRising SunCody SorensonRising SunRun FreeTwo Steps From HellUnleashedScarborough FairSarah BrightmanThe Very Best of Sarah Brightman 1990-2000Season 2019英雄联盟Season 2019SkyfireLiquid CinemaLumina Epic Emotional TrailersSpecial OpsSilver ScreenUnder SiegeStallionThomas BergersenVanquishStar SkyTwo Steps From HellBattlecrySTAR WALKIN’ (League of Legends Worlds Anthem)Lil Nas XSTAR WALKIN’ (League of Legends Worlds Anthem)Strength of a Thousand MenTwo Steps From HellArchangelsummertimecinnamons、evening cinemasummertimeTake Back the NightTryHardNinjaIn Real LifeTake Me HandCécile CorbelTake Me HandTh3 Awak3n1ngIvan Torrent“Th3 Awak3n1ng”The Black DepthsReally Slow MotionValiant RecordThe DawnDreamtaleBeyond Reality (Japanese Edition)The New York NightfallPosition MusicVolume 55 Epic Hip-HopThe One to SurviveHidden CitizensObsidianThe PromiseGlobusShire Music Greatest Hits VOL 2:Lost QueenThe UntoldSecession StudiosThe UntoldThe Untold IISecession Studios、Greg DombrowskiThe Untold IIThe WinnerAPM MusicVideo Game Music (As Featured In FIFA Manager 13)Time Will Remember UsEpic ScoreEpic Action &amp; Adventure Vol. 6To GloryTwo Steps From HellInvincibleUmbrella (Matte Remix)Matte、Ember IslandUmbrella (Matte Remix)unityコミネリサResuscitated Hope/unityVictoryTwo Steps From HellBattlecryViva La VidaColdplayViva La Vida or Death and All His FriendsWhisper of HopeGothic StormEpic Emotional PianoWhite Spell麻枝准、やなぎなぎWhite SpellWinning Together1 Revolution MusicFamily Oriented &amp; Feel GoodWolf KingTwo Steps From HellBattlecryYouApproaching NirvanaYOUアイロニ(カバー)majikoContrastアスタロア鈴木このみPCゲーム『Summer Pockets REFLECTION BLUE』オープニングテーマ「アスタロア」あてもなくAimerあてもなくアルカテイル鈴木このみShake Up!いろとりどりの世界忍紅い瞳に映るセカイ オリジナルサウンドトラック プラスエミヤ_UBW Extended深澤秀行Fate/stay night [Unlimited Blade Works] オリジナルサウンドトラック IIきみの横顔麻枝准、やなぎなぎきみの横顔ただ声一つロクデナシただ声一つフリージアUruフリージアフロム唐沢美帆フロムまた夏を追うあたらよまた夏を追うもう少しだけYOASOBIもう少しだけユキトキやなぎなぎやなぎなぎ ベストアルバム -LIBRARY-ライムライトの残火アヤネライムライトの残火リテラチュアYuumiリテラチュア 由于没有什么时间，所以不怎么玩游戏。 喜欢血染钟楼，不过是云玩家。 曾经是 Minecraft 玩家，现在是云玩家。 喜欢不肝的、有挑战性的、可创造性强的、剧情引人入胜的游戏。但是我找不太到这种东西。想要研究的东西很多，包括但不限于： 历史 基因工程，机械生命 天文学 哲学！其实是带有哲学色彩的科幻，会对类似于以下问题感到好奇： 宇宙中的终极逻辑，是否是真是存在的宇宙，还是被刻意编辑过的逻辑学？ 时间旅行，悖论？ 生命以何种方式存在？ 各类计算机科学相关的内容 旅行，但不知道目的地是哪里 怎么找你？ 短期联系使用 Outlook 邮箱，长期你可以通过发邮件我索要我的联系方式。只要不是恶意骚扰，随便戳。 Outlook: CN__james1@outlook.com，如果您认为事情很重要请直接使用 iznomia@outlook.com。 在其它平台上可以找到我： Luogu：james1BadCreeper Bilibili：iznomia Zhihu：iznomia QQ：61121481 What is the answer to Life, the Universe, and Everything? 42。证明如下： 如何证明一切的答案是 42 这里没有我要找的东西？ 可以使用搜索功能。同时，欢迎大家在下方的评论中灌水！"},{"title":"","date":"2024-04-21T08:35:39.275Z","updated":"2024-04-21T08:35:39.275Z","comments":true,"path":"categories/index.html","permalink":"https://james1badcreeper.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-04-21T08:35:39.275Z","updated":"2024-04-21T08:35:39.275Z","comments":true,"path":"friends/index.html","permalink":"https://james1badcreeper.github.io/friends/index.html","excerpt":"我们终将从时光归来，为宇宙奏响遗忘的镇魂曲。 欢迎您，旅行者！ 希望您可以在这个简陋的地方度过一个愉快的夜晚~ 动态友链关于","text":"我们终将从时光归来，为宇宙奏响遗忘的镇魂曲。 欢迎您，旅行者！ 希望您可以在这个简陋的地方度过一个愉快的夜晚~ 动态友链关于 与我交换友链的方式： 拥有一个可以放置友链的博客。 站点没有营利性。 然后发邮件给我：iznomia@outlook.com，如果不方便也可以试试下面的评论。 我的信息（根据您能支持的信息选取，或者有缺的在换的时候告诉我，我会回复）： title: james1 # 如果您高兴也可以写 iznomia avatar: https://s3.bmp.ovh/imgs/2022/07/15/832a039463fab678.png url: https://james1badcreeper.github.io/ description: Fool for You. 如果您需要更改您的信息，直接联系我就行！"},{"title":"标签列表","date":"2024-04-21T08:35:39.275Z","updated":"2024-04-21T08:35:39.275Z","comments":true,"path":"tags/index.html","permalink":"https://james1badcreeper.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-04-21T08:35:39.275Z","updated":"2024-04-21T08:35:39.275Z","comments":true,"path":"timeline/index.html","permalink":"https://james1badcreeper.github.io/timeline/index.html","excerpt":"","text":"我们终将从时光归来，为宇宙奏响遗忘的镇魂曲。 欢迎您，旅行者！ 希望您可以在这个简陋的地方度过一个愉快的夜晚~ 动态友链关于 如果您有什么看法，请点击动态下方的评论按钮留言！ 动态短博文动态主要用于记录生活中发生的大大小小的事，比较轻松愉快。 更远古的动态短博文用于发布不适合发成博文的小文章，但又比动态更长，其通常比较有实质性意义。 更远古的博文"}],"posts":[{"title":"2024/04/17(#31)：风吹过耳旁 古远的歌唱啊","slug":"default/记录/2024/4/2024-04-17","date":"2024-04-17T00:00:00.000Z","updated":"2024-04-17T00:00:00.000Z","comments":true,"path":"a65f0e35/","link":"","permalink":"https://james1badcreeper.github.io/a65f0e35/","excerpt":"—— 周深《浮光》","text":"—— 周深《浮光》 16 CF1098D Eels 长成一个倍增的结构。我为什么慢一拍来着。 17 JOISC 2023 Council 枚举一个主席，考虑副主席对答案的影响：那些只要副主席不投票就无法通过的东西。设这个集合为 SSS，那么所有 SSS 的子集都可以为 SSS 更新答案。还有 SSS 的超集！一开始先跑高维后缀和来将后缀 SSS 移到当前位置上，然后再跑高维前缀 max⁡\\maxmax 即可。代码。 18 带插入区间 k 小 设 si,js_{i,j}si,j​ 代表前 iii 个块落在第 jjj 个值域块的数的个数，vi,jv_{i,j}vi,j​ 代表 iii 块内值为 jjj 的个数。然后所有信息都能够统计，块大的时候直接分裂即可。 19 AT_wtf19_b Multiple of Nine Portal. 将 l−1,rl-1,rl−1,r 离散化，排序之后算相邻之间的差，贡献是 10y−x−19\\dfrac{10^{y-x}-1}{9}910y−x−1​，要么是 10y−x−19+1\\dfrac{10^{y-x}-1}{9} + 1910y−x−1​+1，当且仅当 sr=sl−1s_r=s_{l-1}sr​=sl−1​。 相当于我们只需要考虑有哪些等价类。那么枚举 999 轮子集，第 kkk 轮代表新增一个集合满足 sr=sl−1=ks_r=s_{l-1}=ksr​=sl−1​=k，直接计算贡献即可。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/12(#30)：像那呼啸而来的狂风中高歌的海燕","slug":"default/记录/2024/4/2024-04-12","date":"2024-04-12T00:00:00.000Z","updated":"2024-04-14T00:00:00.000Z","comments":true,"path":"4eb89962/","link":"","permalink":"https://james1badcreeper.github.io/4eb89962/","excerpt":"发现可以把 To Do List 直接列在这里，第二天强迫自己完成！","text":"发现可以把 To Do List 直接列在这里，第二天强迫自己完成！ 有点想【】了，总感觉少了点什么。 自己渺小得如蜉蝣，也曾想仰望宇宙。 然后被现实所打击。 一定要保护好自己的精神世界啊，我们都是。 谢谢大家的陪伴，希望我们都能走到最后。 我们就是我们，最好的自己，是宇宙中的唯一！ 一些歌词： 昨天被匆匆地裁剪 与前日白昼梦拼贴谁需要这不解风情又潦草的总结—— 《世界沉睡童话》想过离开 当阳光败给阴霾没想到你会拼命为我拨开—— 《好想爱这个世界啊》等不到天黑烟火不会太完美回忆烧成灰还是等不到结尾她曾说的无所谓我怕一天一天被摧毁—— 《她说》梦未枯 就算夜有 尽头醒来后 开怀享受 所有那坚守 某一刻化 作 乌 有却还有 那些洗礼 那几句问候 那份温柔将某个我 拯救—— 《虚幻与现实》 4 [POI 2023/2024 R1] Zapobiegliwy student Portal. 模拟题。代码。 5 [POI 2023/2024 R1] Satelity Portal. 特技卡常数题，写到 M=n+2M=n+2M=n+2 摆烂了。代码。 6 不强制在线的动态快速排序 Portal. 这个东西可以直接计算，动态开点线段树维护一下即可。代码。 7 CF698F Coprime Permutation Portal. 两个质因数集合相同的数可以随便换，再就是 n/pn/pn/p 相同的质数 ppp 可以将倍数一起换（特判 n/p=1n/p=1n/p=1 还可以和 111 换）。 处理的时候直接判断除了大质数因子是否相等，后面记录是否已经交换即可。代码。 ByteDance-Moscow Workshops Camp 2022. The Final Contest 的题。感觉质量还是比较高的。 草摆大了写不完了，明天在这里接着写。 8 B. Longest Increasing Subsequence 挺好的签到题，当时在干什么呢？ 设每次操作生成的数列为 Si,0,⋯ ,Si,ciS_{i,0},\\cdots,S_{i,c_i}Si,0​,⋯,Si,ci​​，那么 ci=log⁡(ai+1−ai)c_i=\\log (a_{i+1}-a_i)ci​=log(ai+1​−ai​)。直接 DP，注意一列可以将两个 Si,j−1,Si,jS_{i,j-1},S_{i,j}Si,j−1​,Si,j​ 拼起来（其中一个选一个）。代码。 9 C. New Equipments III 该完善一下网络流的部分了。 10 G. Factor 11 H. Graph Operation 12 I. Optimal Assortment 发现相当于动态 01 分数规划，直接线段树二分，注意特判 R0=0R_0=0R0​=0。代码。 13 J. Cell Tower 看上去不错的题，做完之后把合并书本也给做了。 有效状态只有 2×1062\\times 10^62×106 个，直接转移即可。map 会 TLE，unordered_map 不会，真的是太优秀啦！代码。 14 K. Xiangqi 15 D. Interesting String Problem 我会去学习一下字符串知识。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/08(#29)：我感应这海啸悲凉 拆碎这座万籁的牢房","slug":"default/记录/2024/4/2024-04-08","date":"2024-04-08T00:00:00.000Z","updated":"2024-04-08T00:00:00.000Z","comments":true,"path":"1ef201c2/","link":"","permalink":"https://james1badcreeper.github.io/1ef201c2/","excerpt":"Come on！","text":"Come on！ 1 CF1364E X-OR Portal. 之前见过。直接随机就行。 2 CF1439B Graph Subset Problem Portal. 如果团存在，kkk 只有 O(m)O(\\sqrt{m})O(m​)，那么可以暴力。最后只留下度数 ≥k\\ge k≥k 的点即可。 3 CF925D Aztec Catacombs Portal. 如果最短路 ≤4\\le 4≤4 就直接用最短路，否则 1→n1\\to n1→n 的边不存在，可能存在一组形如 1→x→y→x→n1\\to x\\to y\\to x\\to n1→x→y→x→n 的解，否则就只能存在 1→x→y→z→x→n1\\to x\\to y\\to z\\to x\\to n1→x→y→z→x→n 的解了。 此时的 1→x1\\to x1→x 能到达所有的 xxx，因为如果不能直接到达，可以在 1→x1\\to x1→x 的路径中间找一个 yyy 形成 1→y→x→1→n1\\to y\\to x\\to 1\\to n1→y→x→1→n 的更优答案，因此这样做可以遍历所有的三元环，正确性得到保证。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/07(#28)：用渗透的墨水来轻轻描绘","slug":"default/记录/2024/4/2024-04-05","date":"2024-04-05T00:00:00.000Z","updated":"2024-04-07T00:00:00.000Z","comments":true,"path":"4b668530/","link":"","permalink":"https://james1badcreeper.github.io/4b668530/","excerpt":"该卷卷了。","text":"该卷卷了。 [CF293C] Cube Problem Dino Bot 昨天的日推题。代码。 [Ynoi2011] ODT Portal. 每个点维护一棵 Treap，然后只维护轻儿子的信息即可。 [CF715E] Complete the Permutations Portal. 边可以分为四种类型，a→b,a→0,0→b,0→0a\\rightarrow b,a\\rightarrow 0,0\\rightarrow b,0\\rightarrow 0a→b,a→0,0→b,0→0。 记后三种边的数量为 n1,n2,mn_1,n_2,mn1​,n2​,m。a→0a\\rightarrow 0a→0 边有两种选择，融进 0→00\\rightarrow 00→0，或者自我合并。方案数是： F1[k]=∑i=kn1(n1i)[ik](n1+m−i−1)n1−i‾F_1[k]=\\sum\\limits_{i=k}^{n_1}\\dbinom{n_1}{i}\\begin{bmatrix}i\\\\k\\end{bmatrix}(n_1+m-i-1)^{\\underline{n_1-i}} F1​[k]=i=k∑n1​​(in1​​)[ik​](n1​+m−i−1)n1​−i​ F3F_3F3​ 直接算第一类斯特林数，然后可以全排列 mmm。暴力卷即可。代码。 [AGC040F] Two Pieces Portal. 代数推导天地灭。 考虑没有 222 操作怎么做。为了避免重复计数，强制让 a,ba,ba,b 距离 ≥1\\ge 1≥1（我们只区分操作时的位置，因此 =0=0=0 的会在考虑 222 操作时统计）。反射容斥做一下即可。 考虑加入操作 222。考虑枚举一次操作 222 造成的移点贡献，也就是枚举最后一次进行操作 222 时的 k=x−yk=x-yk=x−y，那么可以视作将终点拉到 (A,B−k)(A,B-k)(A,B−k)，将此视为新的格路。 将剩余的 n−A−(B−k)−1n-A-(B-k)-1n−A−(B−k)−1 个 333 操作分配到操作序列中，实际上是要给到 k+1k+1k+1 个点（在它们身上进行 333 操作），它们是直线 y=x−dy=x-dy=x−d（d∈[0,k]d\\in [0,k]d∈[0,k]，d&gt;kd&gt;kd&gt;k 越过了之前钦定的最后一次 333 操作）与新的格路的最后一个交点，只有最后一个交点是合法的，否则会有将 yyy 坐标 +1 类的操作无法进行。分配之后，会将移动 kkk 的贡献分摊掉。 特判 A+B=nA+B=nA+B=n 的情况即可。代码。 L. Completely Multiplicative Function Portal. 直接从小质数贪即可，不知道为什么是对（或者数据水）的。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/03(#27)：弹指间湮灭我 但命运打不败活着","slug":"default/记录/2024/4/2024-04-02","date":"2024-04-02T00:00:00.000Z","updated":"2024-04-03T00:00:00.000Z","comments":true,"path":"bb2987d9/","link":"","permalink":"https://james1badcreeper.github.io/bb2987d9/","excerpt":"摘要：无。","text":"摘要：无。 让生命如剧烈的烟火 / 璀璨熄灭前也将点亮 / 孩童的双眸 感觉还是被负能量主导了啊。 我未曾想过自己会有这个问题，曾夸下海口说自己“比一般人的抗挫能力更强”，但现在看来，我也只是臭鱼烂虾罢了。 为什么会这样？我能想到的是自己的能力与现实的巨大差距，但这时候理应爆发出更加强大的执行力，而不是在原地等待。 不吃饭？还有对入眠的恐惧感？ 没有选择“在当前局面下更优的解决办法”，用一个我非常不想用在我自己身上的形容词，自暴自弃。 将它们修复、抹除掉。没有什么是我做不到的。 神罚并没有停止，空前的绝望如期而至。但是很可惜，我的名字叫不死之人。 [USACO20OPEN] Circus P | AGC066E Portal. 首先，奶牛之间没有区别，我们总可以移动这些奶牛使得它们到达前 KKK 个点。 K=iK=iK=i 时，答案的上界是 i!i!i!，但是无法达到，原因是存在一些位置对 (x,y)(x,y)(x,y) 它们可以在不改变其它奶牛的位置的前提下进行交换，那么对它们连边，它们会构成一些团，设团的大小为 sis_isi​，那么答案是 k!/∏si!k!/\\prod s_i!k!/∏si​!。 考虑一条路径，两端不为二度点，中间全为二度点。设其左端点的子树大小为 AAA 右边为 BBB 链上有 CCC 个点，当 x→yx\\rightarrow yx→y 上的所有链都满足 k&lt;A−1+B−1=n−Ck&lt;A-1+B-1=n-Ck&lt;A−1+B−1=n−C 则可以连通。 将树上的二度点路径缩起来成为一棵新树。将所有 k≥n−Ck\\ge n-Ck≥n−C 的边断掉，剩下的每个连通块就都是团，我们需要计算每个连通块对应的团的大小（有多少个奶牛在这里面可以互换）。 设连通块内的子树为 BBB，那么我们让其填满，无法连接到连通块的点的数量为： k−∑(k−(B−1))= k−∑(k−(n−C−A+1))= k−∑(k−(n−1−p))\\begin{aligned} &amp; k - \\sum (k-(B-1))\\\\ =\\ &amp; k-\\sum(k-(n-C-A+1))\\\\ =\\ &amp; k-\\sum(k-(n-1-p))\\\\ \\end{aligned} = = ​k−∑(k−(B−1))k−∑(k−(n−C−A+1))k−∑(k−(n−1−p))​ 其中 ppp 连接到当前连通块外的那个的子树大小，111 是连接点（在连通块内），不难发现 ∑p=∑n−x\\sum p=\\sum n - x∑p=∑n−x。 最后用 kkk 减去就是团的大小。由于链长总和是 O(n)O(n)O(n) 的，因此时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。代码。 对于 AGC066E，没有本质区别。答案的下界是 (nk)\\binom n k(kn​)（哪些位置放石头），到最终局面下每个团内部可以任意排列的。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/04/01(#26)：渺小得如蜉蝣 也仰望着宇宙","slug":"default/记录/2024/4/2024-04-01","date":"2024-04-01T00:00:00.000Z","updated":"2024-04-01T00:00:00.000Z","comments":true,"path":"dfe8ff4c/","link":"","permalink":"https://james1badcreeper.github.io/dfe8ff4c/","excerpt":"周深太牛了。","text":"周深太牛了。 有那种上帝感了。 生命何尝不是从乌有到乌有，对得起自己吗？ 没有退路可言。 [ABC347F] Non-overlapping Squares Portal. 卡 C，卡 C [ABC347G] Grid Coloring 2 Portal. 切糕。 [AGC066A] Adjacent Difference Portal. 怎么这么抽象。 由 12\\frac 1 221​ 的限制不难想到进行黑白染色，那么只需要改成 mod 2d=0 or d\\bmod\\ 2d=0 \\text{ or } dmod 2d=0 or d 即可。由于代价和是 dn2dn^2dn2，因此必有一种黑白染色方案满足。代码。 [AGC066B] Decreasing Digit Sums Portal. ans=550ans=5^{50}ans=550 的时候很像答案，但是有噪声。可以选择 ∑k×550\\sum k\\times 5^{50}∑k×550 作为答案，其中 kkk 是几百个随机整数。 也可以简单的选择 5,52,535,5^2,5^35,52,53 的拼接作为答案，这可以视为噪声的消除。由于 nnn 只有 505050，因此这样完全没问题。 [AGC066C] Delete AAB or BAA Portal. 不难考虑对这个东西设计 DP。设 fif_ifi​ 代表考虑前 iii 个字符还剩多少不能删掉的东西。那么如果 [i+1,j][i+1,j][i+1,j] 都能删掉，那么 fj←fif_j\\leftarrow f_ifj​←fi​。 如何找到能完整删掉的段？充要条件是，可以分解成若干个能删除的子段，并且子段的左端或者右端是 B。直接维护即可。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/03/25(#25)：经受的一切，绝对是有意义的","slug":"default/记录/2024/3/2024-03-25","date":"2024-03-25T00:00:00.000Z","updated":"2024-03-25T00:00:00.000Z","comments":true,"path":"6d4ac666/","link":"","permalink":"https://james1badcreeper.github.io/6d4ac666/","excerpt":"被打爆了。","text":"被打爆了。 [USACO24OPEN] Identity Theft P Portal. 建出 Trie，然后相当于所有的点都需要移动到叶子，贪心即可。代码。 [ARC111D] Orientation Portal. 直接定向，否则就是有环。代码。 [ARC114C] Sequence Scores Portal. 考虑给序列 AAA 末尾加上一个数 jjj 的贡献，只有当 ∀p&gt;lsti\\forall p&gt;lst_i∀p&gt;lsti​，都有 ap&gt;ja_p&gt;jap​&gt;j，最小操作数才不变，那么贡献 fi,xf_{i,x}fi,x​ 可以表达为： fi,x=mi−1−∑k=1i−1(m−x)i−k−1×mk−1f_{i,x} = m^{i-1}-\\sum_{k=1}^{i-1}(m-x)^{i-k-1} \\times m^{k-1} fi,x​=mi−1−k=1∑i−1​(m−x)i−k−1×mk−1 然后根据 fff 计算出 ansansans 即可。代码。 [ARC114E] Paper Cutting 2 Portal. 和 CF1924E 几乎一致。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/03/23(#24)：向命运拒绝在黑暗中湮灭","slug":"default/记录/2024/3/2024-03-15","date":"2024-03-15T00:00:00.000Z","updated":"2024-03-23T00:00:00.000Z","comments":true,"path":"4f7132d9/","link":"","permalink":"https://james1badcreeper.github.io/4f7132d9/","excerpt":"再来一次吧！","text":"再来一次吧！ [CF1707E] Replace Portal. 首先答案上界是 2n2n2n，大概是先转一圈然后再依次扩展。 我们可以维护一个 f2k(l,r)f^{2^k}(l,r)f2k(l,r) 来用于在询问的时候快速回答，但是 (l,r)(l,r)(l,r) 的数量是爆炸的 O(n2)O(n^2)O(n2)。现在的问题是如何减少 f(l,r)f(l,r)f(l,r) 需要的数量。 所以要找性质。我们有在 [l1,r1][l_1,r_1][l1​,r1​] 和 [l2,r2][l_2,r_2][l2​,r2​] 有交时，令 [l,r]=[l1,r1]∪[l2,r2][l,r] = [l_1,r_1]\\cup [l_2,r_2][l,r]=[l1​,r1​]∪[l2​,r2​]，那么 fk([l,r])=fk([l1,r1])∪fk([l2,r2])f^k ([l,r])=f^k ([l_1,r_1]) \\cup f^k ([l_2,r_2])fk([l,r])=fk([l1​,r1​])∪fk([l2​,r2​])。 因为它们的值域相交，所以 f(l1,r1)∩f(l2,r2)≠∅f (l_1,r_1) \\cap f (l_2,r_2)\\ne \\varnothingf(l1​,r1​)∩f(l2​,r2​)=∅，而在它们有交集的前提下，有 f(l1,r1)∪f(l2,r2)=f(min⁡{l1,l2},max⁡{r1,r2})f (l_1,r_1) \\cup f (l_2,r_2)=f(\\min\\{l_1,l_2\\},\\max\\{r_1,r_2\\})f(l1​,r1​)∪f(l2​,r2​)=f(min{l1​,l2​},max{r1​,r2​})，对这个东西进行数学归纳，所以上面的那个是对的。 也就是说我们使用 ST 表维护每个 f2kf^{2^k}f2k 的值即可，内部的数量级从 O(n2)O(n^2)O(n2) 降低到了 O(nlog⁡n)O(n\\log n)O(nlogn)，总时间复杂度 O((n+q)log⁡2n)O((n+q)\\log ^2 n)O((n+q)log2n)。代码。 [CF1844G] Tree Weights Portal. 考虑依次对方程在模 2k2^k2k 意义下进行求解，然后递推即可。代码。 [CF1918F] Caterpillar on a Tree Portal. 直接贪心就行了。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/03/13(#23)：星解","slug":"default/记录/2024/3/2024-03-13","date":"2024-03-13T00:00:00.000Z","updated":"2024-03-13T00:00:00.000Z","comments":true,"path":"3eb73673/","link":"","permalink":"https://james1badcreeper.github.io/3eb73673/","excerpt":"加训。","text":"加训。 [CF1091G] New Year and the Factorisation Collaboration Portal. 询问 sqrt(x * x)，我们有 (x−y)(x+y)≡0(modn)(x-y)(x+y)\\equiv 0\\pmod n(x−y)(x+y)≡0(modn)。排除其中有 000 和 nnn 的情况，这样我们将 nnn 的质因子分成两组 S1S_1S1​。 一个质因数 pip_ipi​ 能被求出，仅当所有 pj(j≠i)p_j(j\\ne i)pj​(j=i)，存在一个 SSS 使得 pjp_jpj​ 在 SSS 中出现但 pip_ipi​ 未出现（注意 S=1S=1S=1 是废票）。 分解成 kkk 个 x2−x′2≡0(modpi)x^2-x&#x27;^2\\equiv 0\\pmod {p_i}x2−x′2≡0(modpi​)，可以得知模 nnn 意义下的二次剩余有 2k2^k2k 个，但是交互库并不知道我们的 xxx 是哪个，因此有 1−2−k1-2^{-k}1−2−k 的概率返回一个不同的。 同时，pip_ipi​ 在 x−x′x-x&#x27;x−x′ 里时，pjp_jpj​ 也在 x−x′x-x&#x27;x−x′ 的概率是 50%50\\%50%，因此 SSS 是随机分配的。 随机做 ttt 次，一个 (i,j)(i,j)(i,j) 的正确率为 1−2−t1-2^{-t}1−2−t。最终正确率是 (1−2−t)k2(1-2^{-t})^{k^2}(1−2−t)k2。 [CF1286C2] Madhouse (Hard version) Portal. 没补过 Hard ver.，我是摆怪。 Easy Ver. 做过，这个也差不多，就问 [1,n2],[1,n2+1][1,\\frac n 2],[1,\\frac n 2 + 1][1,2n​],[1,2n​+1]，然后剩下的依次考虑长度为 2∼n22\\sim \\frac n 22∼2n​ 的子串，222 的时候排除掉在 [1,n2+1][1,\\frac n 2 + 1][1,2n​+1] 里的，然后删掉 n2+1\\frac n 2 + 12n​+1 这个位置的数，就只有 sns_nsn​ 出现了奇数次，以此类推。 于是恰好预处理到这个位置，后半部分就可做了。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/03/11(#22)：从来没有任何蛮荒之地 能与这桃源媲美","slug":"default/记录/2024/3/2024-03-11","date":"2024-03-11T00:00:00.000Z","updated":"2024-03-11T00:00:00.000Z","comments":true,"path":"309ed68c/","link":"","permalink":"https://james1badcreeper.github.io/309ed68c/","excerpt":"——《虚幻与现实》","text":"——《虚幻与现实》 继续加油吧。 [WC2024] 代码堵塞 为什么当时不会。 [CF1835B] Lottery Portal. 这场好抽象。 首先这个鬼畜的东西到底是什么：假定 x≤cx\\le cx≤c，那么应该满足数轴上左起第 kkk 个满足 ∣c−x∣≤∣c−vl∣|c-x|\\le |c-v_l|∣c−x∣≤∣c−vl​∣，然后右面没合法的东西。 然后发现 xxx 应该取在 0,m,v0,m,v0,m,v 附近。代码。 [CF1835C] Twin Clusters Portal. 有点像 CF618F，一定有解。 然后使用 P7842 的方式优化枚举，我们按照前 kkk 位的值进行分类，总共有 2k+1+12^{k+1}+12k+1+1 个前缀异或和，会使得后缀剩下的有 2k+12^k+12k+1 对相同的，那么至少能够找到一个相同的。 于是直接线性扫过去就能找到 2k+12^k+12k+1 对相同的前 kkk 位。代码。 [CF1599A] Weights Portal. 如果是 LRLRLR 的话那么将 AAA 排序，然后交替放置即可。 否则倒着做，答案不变删最小，答案变删最大。 [CF1887D] Split Portal. 按照权值从小到大向里加作为分界点，可以算出 nnn 个矩形，扫描线计算贡献即可。代码。 [2023 Shenzhen] Two in One Portal. 所以为啥场上没过？ 一定有一个颜色是选满的，剩下那个可以选择一个 x,yx,yx,y 都有的填补一段后缀 111。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"LNOI2024 游记","slug":"summaries/游记/SX2024","date":"2024-03-07T00:00:00.000Z","updated":"2024-03-07T00:00:00.000Z","comments":true,"path":"57b83896/","link":"","permalink":"https://james1badcreeper.github.io/57b83896/","excerpt":"我就是要打破这轮回。","text":"我就是要打破这轮回。 Day -? THUWC 和 WC 全寄了。 不明白为什么会这样。 也只能向前看了。 Day -3 从 ZJ 飞了回来。回家！ 熬夜，3:00。 然后次日，0:00。 Day -1 到酒店，什么都不想。 打了一个费用流，然后想想我好像也只会这点了。 不想写比赛过程，跳过。 Day Mid 看云斗数据，我在一个很危险的边缘。 精神状态有点不太正常，幸好老师们对我还是比较宽容的。 Day ? - 1 发现我前面有两个初中生，怎么这么厉害。 这样至少能有一个 B，没死。 Day ? 2024 年 3 月 7 日。 不知道为什么苟进了 A。 一些杂谈 目前我甚至没有一个 Cu 的水平（很多弱省都有若干人过了 D2T1，但是我压根不会这个东西）。如果想要达到理想的目标，两天的 T2 需要都会。 这看上去确实十分遥远，也需要去付出更多的努力吧。 以后会尽量做到日更的，一轮复习也需要以一个更全面完整的方式去完成。 感谢同学们的鼓励与陪伴，遗憾退役的同学们文化课加油啊！！","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"2024/03/01(#22)：从来没有任何蛮荒之地 能与这桃源媲美","slug":"default/记录/2024/2/2024-02-28","date":"2024-02-27T00:00:00.000Z","updated":"2024-02-29T00:00:00.000Z","comments":true,"path":"87bbfefz/","link":"","permalink":"https://james1badcreeper.github.io/87bbfefz/","excerpt":"——华晨宇《虚幻与现实》","text":"——华晨宇《虚幻与现实》 [WC2024] 代码堵塞 所以为什么考场上不会。 [CTS2024] 水镜 [CTS2024] 线段树 [CTS2024] 众生之门 [省选联考 2023] 过河卒 Portal. [P9682] Electro Master Portal. 模拟赛有一个题是从这个改过来的，整体上来说差不多。 第 iii 个能成为到左边的 b，当且仅当初始时有至少 iii 个正的，并且它发生了奇数次碰撞。讨论 i−1,i,i+1i-1,i,i+1i−1,i,i+1 的情况： +++，---：啥也不是； LNOI2024 rp++ 在光怪陆离中，寻找内心的出口。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/24(#21)：天使帝国","slug":"default/记录/2024/2/2024-02-21","date":"2024-02-21T00:00:00.000Z","updated":"2024-02-24T00:00:00.000Z","comments":true,"path":"1a13baf9/","link":"","permalink":"https://james1badcreeper.github.io/1a13baf9/","excerpt":"便一去不回。","text":"便一去不回。 模拟赛，四天并到了一天。 最近气温是有点离谱了，达到了 Δ=−25∘C\\Delta=-25^{\\circ}\\text{C}Δ=−25∘C。 [CCO2023] Binaria Portal. 直接并查集合并就没了。代码。 [CCO2023] Real Mountains Portal. 联考考过，没补，我是摆怪。 考虑最终序列的最大值一定不会大于原序列中的最大值，那么任取一个最大值位置作为峰顶，左右两边分开处理。 对于左边来说（右边同理），一个位置的最终值是它左边所有值的最大值。每次找到还未达到最终值的所有最小值，尝试将其全部加一。发现最优情况是从两端加到中间，于是从小到大扫，直接计算贡献即可。代码。 [CF1545F] AquaMoon and Potatoes | [Ynoi2007] tmpq Portal. Techno，土豆。 暴力 DP 可以将 i,ki,ki,k 的贡献拆开然后暴力扫然后乘起来即可。 看上去就非常的离谱，以前给出的做法大概是这样的： 直接操作分块，每次只有 O(m)O(\\sqrt{m})O(m​) 个被修改的数，然后就有看每个数是否是在这个块内被修改的，888 种情况都能做，就是有点无语。 zak 有一种聪明的做法： 算了，明天写。 今天吃晚饭的时候一人顶着伞走了一圈，有种将世间万物都收在一起的感觉。视野没有那么开阔，却也不觉遮挡。 温度在心中聚集，在一个不大的世界中，像登山者看到了在山顶开放的花一般欣喜。 走吧，不管走到哪里，这一切都很美的。 天使帝国。 以上都是 21 日的，下面开始是 22 日和 23 日的。 先继续写那个土豆题。 转化为 a,b,ca,b,ca,b,c 单点修改，bi=aj=ckb_i=a_j=c_kbi​=aj​=ck​ 的个数。先写一个动态 DP 维护转移。 对于每个出现的 www 的次数进行根号分治。对于 cntw≤Bcnt_w\\le Bcntw​≤B，那么进行暴力 DP，然后差分贡献，扔到相应的位置上，询问相当于求前缀和，O(nn)O(n\\sqrt{n})O(nn​) 次修改，O(m)O(m)O(m) 次查询，使用 O(1)−O(n)O(1)-O(\\sqrt{n})O(1)−O(n​) 的分块维护。 对于 cntw&gt;Bcnt_w&gt;Bcntw​&gt;B，离线扫一遍操作序列，单点修改前缀查询，由于修改的总个数是 O(m)O(m)O(m)，询问个数是 O(mn)O(m\\sqrt n)O(mn​)，因此使用 O(n)−O(1)O(\\sqrt{n})-O(1)O(n​)−O(1) 的分块维护即可。 写起来比较方便，土豆还是很美味的！！代码。 [JOISC2020] Ruins 3 Portal. 旋风牛马大数数。 考虑从后往前扫，然后假定 1∼h1\\sim h1∼h 的石柱各出现了一根，那么接下来出现的 ≤h\\le h≤h 的柱子，都会直接震没。那些没有被震死的柱子称为“标准柱”。 继续观察性质。如果当前位置为 xxx，后面存在 x∼x−kx\\sim x-kx∼x−k，那么 xxx 会下降到 x−k−1x-k-1x−k−1。 设 fi,jf_{i,j}fi,j​ 代表后 iii 个柱子，此时 h=jh=jh=j 的方案数。 我们先假定两根高度相同的柱子实际上是不同的，那么最终答案除以 2n2^n2n 即可。 倒着 DP，设此时有 c0c_0c0​ 个钦定消失，c1c_1c1​ 个钦定存在。 iii 钦定消失，此时 jjj 不变，有 jjj 个可用高度，那么不算当前这个没消失的，这里可以填写 j−(c0−1)j-(c_0-1)j−(c0​−1) 个有效的。 iii 钦定保留，令 hih_ihi​ 代表 iii 最后的高度，分讨： 如果 hi&gt;j+1h_i&gt;j+1hi​&gt;j+1，那么从 fi+1,jf_{i+1,j}fi+1,j​ 转移，这里的贡献留给以后再计算。 否则此时 hi=j+1h_i=j+1hi​=j+1，那么此时枚举一个新增的大小 kkk，转移到 fi,j+kf_{i,j+k}fi,j+k​，系数是： 选择哪些位置的值被记入了当前 jjj。钦定除了当前位置的那 k−1k-1k−1 个位置的方案数 (c1−1−jk−1)\\dbinom{c_1-1-j}{k-1}(k−1c1​−1−j​)； j+2∼j+kj+2\\sim j+kj+2∼j+k 的高度之前均有出现过一次，这里还可以选择各一次，然后还可以选择两个 j+1j+1j+1 的高度，方案数是 k+1k+1k+1； 固定那 k−1k-1k−1 个位置上的数的排列，那些数都没有被震没。因此就是要求一个 gng_ngn​ 代表有 2n2n2n 个数进行选择，然后震成值域连续段的初始方案数。 设 gi,jg_{i,j}gi,j​ 代表用 1∼i1\\sim i1∼i 的数填 jjj 个位置，放进去的最大数不影响原来能震成的值域连续段，那么能震成值域连续段的充要条件是 i≥ji\\ge ji≥j。枚举第 iii 个数填了 0/1/20/1/20/1/2 的转移方式： gi,j=gi−1,j+2j×gi−1,j−1+j(j−1)gi−1,j−2g_{i,j}=g_{i-1,j}+2j\\times g_{i-1,j-1}+j(j-1) g_{i-1,j-2} gi,j​=gi−1,j​+2j×gi−1,j−1​+j(j−1)gi−1,j−2​ 代码。 [Ynoi1999] XM66F 就是求 ∑i=lr[aj=ar](br−bj)\\sum_{i=l}^r [a_j=a_r](b_r-b_j)∑i=lr​[aj​=ar​](br​−bj​) 直接莫队没有了，这东西为什么可以不丢 Easy Round？？？？代码。 教练领着去某个神秘的地方吃了一顿，挺开心的。 不过那里的猫一个都不理我 今天下午听了很多遍《斗牛》！！ 野性坦露着灵魂纯粹 或者肆意妄为直到亲手栽培了原罪以后 又要将它摧毁 好好休息一下呢。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/20(#20)：在无尽的黑暗之中 肆意生长着","slug":"default/记录/2024/2/2024-02-20","date":"2024-02-20T00:00:00.000Z","updated":"2024-02-20T00:00:00.000Z","comments":true,"path":"b389ed0b/","link":"","permalink":"https://james1badcreeper.github.io/b389ed0b/","excerpt":"这是宇宙原本的颜色。","text":"这是宇宙原本的颜色。 唉，对拍，暴力写挂。 能不能打出一个正常的 perf 啊（笑） [ABC314F] Breakdown 当时把 ∑\\sum∑ 看成 ∀\\forall∀ 了，不愧是我。 直接背包就行了。 [ABC314G] Highest Ratio 读错 F 干没时间了。 考虑固定的右端点对应的左端点是单调的，那么直接单调栈，后面一段不优直接扔掉。代码。 [Ynoi2011] 成都七中 Portal. 去年被长头龙病毒机惨交的题现在才补，能不能改一改宇宙超级无敌旋风牛马摆怪的毛病啊。 你直接点分治下去，一个询问第一次统计在合法路径能覆盖到它的时候，然后二维数点。时间复杂度 O((n+m)log⁡2n)O((n+m)\\log^2 n)O((n+m)log2n)。代码。 [CF983D] Arkady and Rectangles Portal. 扫描毒瘤线，线段树上开 set 维护完全覆盖当前区间的颜色，以及区间没有看到过的最大颜色和看到过的最大颜色，都能直接算。 注意没有完全覆盖的，看到过的最大颜色，pushup 的时候取的是最小值。代码。 不停地在懊悔，为什么会这样呢？ 就是说，为什么要在意那么多事情呢？","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/19(#19)：孤独被染上童话底色","slug":"default/记录/2024/2/2024-02-19","date":"2024-02-19T00:00:00.000Z","updated":"2024-02-19T00:00:00.000Z","comments":true,"path":"fc189a8d/","link":"","permalink":"https://james1badcreeper.github.io/fc189a8d/","excerpt":"今天尝试能不能效率正常一点！！","text":"今天尝试能不能效率正常一点！！ [省选联考 2023] 人员调度 Portal. 类似于 Conquer The World，直接每次反悔贪心遍历整棵树有 48 分。所以为啥去年不会啊。 删除的话套一层线段树分治就可以了，现在想一想怎么加入。 考虑模拟反悔贪心，找到 xxx 的祖先中深度最深的满足 s(u)=siz⁡us(u)=\\operatorname{siz}_us(u)=sizu​ 的 uuu，然后替换子树内的最小值。 树剖线段树维护每个节点的 sizu⁡− s(u)\\operatorname{siz_u}-\\ s(u)sizu​− s(u) 的最小值以及子树内的最小权值，直接替换即可。 sjy 能不能做个人啊，把树剖卡满的意义何在啊。代码。 半彩三重奏 今天打了一下月赛 Div.2！非常搞笑！ 以后可以尝试把 E 补了！F 是什么牛马题！ 并查集暴力模拟即可，注意询问离线来减小常数。 [HNOI2019] 校园旅行 Portal. 考虑暴力，fx,yf_{x,y}fx,y​ 是否存在 x→yx\\rightarrow yx→y 的回文路径，直接记忆化搜索 O(n2+m2)O(n^2 + m^2)O(n2+m2)。 问题是我们的边数太多了！注意到路径长度其是不太要紧，因为可以来回走刷分。首先考虑一个事情，如果我只能走同色点，那么我们好像不能改变我们当前刷的路径长度的奇偶性——除非有奇环。除非……除非不是二分图！ 那么对于二分图的同色连通块，可以只保留一棵生成树（因为子图也是二分图），其它同色连通块可以表示为一棵生成树，然后有一个自环。 而异色点是自然二分图，直接保留生成树即可。代码。 唉，大意了😅 不要让欲望侵占了意志。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/18(#18)：日落色砂糖","slug":"default/记录/2024/2/2024-02-16","date":"2024-02-16T00:00:00.000Z","updated":"2024-02-18T00:00:00.000Z","comments":true,"path":"bc00b8e/","link":"","permalink":"https://james1badcreeper.github.io/bc00b8e/","excerpt":"由于两天模拟赛没做什么题，所以一起并到 Day3 了。","text":"由于两天模拟赛没做什么题，所以一起并到 Day3 了。 30 min 过掉 T1，然后少写一个等号爆零了！ 剩下 4h T2 T3 狂砍零分！！ 哇哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈！！ 明天能不能稍微调整一下啊，否则都对不起阎王没在自己的生死簿上打叉了。 啊米诺斯又死了，没脸活了。 这是能溶解一切的黄昏。 [CF1916F] Group Division Portal. 用时 3min 想完了，不过假了 但是每次跑一遍 Tarjan 就是对的了，因为原图是个点双，所以必然能走一个，剩下的还是个类点双，其割点连在已选集合上，感觉上也差不多，代码。 [CF1437F] Emotional Fishermen Portal. 设 fi,jf_{i,j}fi,j​ 表示当前最大值是 aia_iai​，然后确定了排列的前 jjj 个，转移的时候可以新加入一个最大值，也可以加入 2ak≤ai2a_k\\le a_i2ak​≤ai​ 的值，代码。 打了 2023 Shanghai。 B. Roman Master 倒着做就好了。代码。 F. Dot Product 猜结论，两个值域相邻的数可以交换位置，用逆序对减去这些数即可。代码。 剩下的 qoj 传了之后再说。 [CF1801E] Gasoline prices Portal. 就是萌萌哒，搬到树上并查集维护正反链即可。代码。 [AGC030D] Inversion Sum Portal. 对于操作 D 不出来什么 P，所以考虑枚举逆序对。对所有的 fff 可以直接进行转移，代码。 [AGC026E] Synchronized Subsequence Portal. 正着做可能会忽略后面有更好的 bbb，考虑倒着做。 设 fif_ifi​ 为考虑 i∼ni\\sim ni∼n 个 a,ba,ba,b 的字符串，然后 ba 一定要填，在那个 a 之前出现的 ba 一定要填；对于 ab 在 b 之前出现的东西一定不能填，代码。 [集训队互测 2021]《关于因为与去年互测zjk撞题而不得不改题这回事》 Portal. 超级钢琴都做过吧？ 求的是 AND，所以把最大值搞出来就行了。线段树每个节点开一个 vector 存储所有的值，询问的时候贪心就好了。 淦 vector 越界调了一下午！！！！！！代码。 [ARC172A] Chocolate Portal. 大的一定更好分，直接贪心即可。代码。 [ARC172B] AtCoder Language Portal. 答案形如 l×(l−1)×(l−2)×⋯×(l−(n−k))xl\\times (l-1)\\times (l-2)\\times \\cdots \\times (l-(n-k))^xl×(l−1)×(l−2)×⋯×(l−(n−k))x，代码。 nmm 复习不完了，题做不完了。 怎么 To do List 的增长速度都比我做得快啊。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/15(#17)：堕入这无尽的黑夜","slug":"default/记录/2024/2/2024-02-15","date":"2024-02-15T00:00:00.000Z","updated":"2024-02-15T00:00:00.000Z","comments":true,"path":"295d17d/","link":"","permalink":"https://james1badcreeper.github.io/295d17d/","excerpt":"嘿嘿，题写不完了！","text":"嘿嘿，题写不完了！ 我卡蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了 [Ptz Winter 2020 Day3] Cells Blocking Portal. 死路一条和必经之路的贡献很好统计。 只能堵死斜线的左下或者右上，比如堵左下的时候，右上尽可能向右走，左下的右上一个尽可能往下走，这两个撞在一起就死了。代码。 [AGC012E] Camel and Oases Portal. VVV 只有 log⁡\\loglog 个，那么把这个给求出来，然后统计 L,RL,RL,R 代表每个 vvv 能扩展到的最左边和最右边，再状压出 fS,gSf_S,g_SfS​,gS​ 代表前后缀最远能走多少，然后处理出所有初始 VVV 能走到的线段，子集合并前后缀即可。代码。 还有没完成的内容！ B. Festival Decorating Portal. 看上去就是闹鬼的呢！实际上它的解法更为闹鬼！ 我们考虑对于每个灯开一个 bitset 维护距离它右边 xxx 的灯是否存在，那么时间复杂度 O(n2/w)O(n^2/w)O(n2/w)，空间开不下。我们可以有 50%50\\%50% 的误差，因此开对数个 bitset，存到对数里即可。代码。 E. Period of a String Portal. 还是很有意思的。 发现可以转化为对一个前缀字符集的限制，使用一个 vector 维护字符集被拆成的每一段，时间复杂度 O(nlog⁡∣S∣(log⁡(n)+26))O(n\\log |S|(\\log (n) + 26))O(nlog∣S∣(log(n)+26))，代码。 摆摆摆摆摆摆摆，怎么会是。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/14(#16)：玉米深海","slug":"default/记录/2024/2/2024-02-14","date":"2024-02-14T00:00:00.000Z","updated":"2024-02-14T00:00:00.000Z","comments":true,"path":"1573c055/","link":"","permalink":"https://james1badcreeper.github.io/1573c055/","excerpt":"省流：见鬼了。","text":"省流：见鬼了。 就像一幅拼图丢了一块一样，有十二座沃尔玛被洗劫一空。 据说，是空间大盗在准备年货。 玉米投手是如何生产黄油的呢？ 玉米深海的海水是由融化的黄油构成的！ H. Sugar Sweet II Portal. 统计必然发生的和必然不发生的，剩下的在基环树上跑一下即可。代码。 G. Snake Move Portal. 直接最短路扩展这个东西，记得和初始时距离蛇尾的位置取一个 max⁡\\maxmax。代码。 还有讲的题。 [ARC168E] Subsegments with Large Sums Portal. 直接 wqs，错了，因为不是凸的。 二分答案，现在是说，答案为 xxx，是否能够划出 kkk 个连续段？设 fnf_nfn​ 划出 xxx 个段满足条件，最小的代价。为 fn≤n−kf_n\\le n -kfn​≤n−k 时合法，wqs 二分即可。代码。 [Ptz 2020 Winter Day 6] The Destruction of the Crystals Portal. 除了第一个引爆的炸弹，剩下的炸弹都可以视作十字炸弹。 然后环可以直接算贡献。如果这个列只有一个那么可以横着炸，否则一定要竖着炸。并查集维护即可。注意统计环的贡献，代码。 [XXI Open Cup, GP of Korea] Query On A Tree 17 Portal. 首先是重心的性质，子树权值和一定严格大于所有点权值和的一半。 写 DFS 序，第 iii 个数写 aia_iai​ 次，最中间的数一定是子树里的，倍增跳父亲即可。代码。 剩下的写不动了，写点有意思的。 怎么明天还有啊，好想念模拟赛。 [PA2021] Poborcy podatkowi Portal. 看上去有点闹鬼，但实际上也比较闹鬼。 设 fi,0∼3f_{i,0\\sim 3}fi,0∼3​ 代表节点 iii 向上传长度的链的最大贡献，合并的时候是树形背包的形式，死了。 但是打乱儿子顺序，1,31,31,3 长度链的差值在合并的过程中不会变得很大，设一个 BBB 即可。代码。 最近应该会抽出时间补一补复习笔记，再看看吧！","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/13(#15)：火山可乐","slug":"default/记录/2024/2/2024-02-13","date":"2024-02-13T00:00:00.000Z","updated":"2024-02-13T00:00:00.000Z","comments":true,"path":"5fc9eb51/","link":"","permalink":"https://james1badcreeper.github.io/5fc9eb51/","excerpt":"小时候玩过一个名字叫做“可乐”的游戏，一个回合内可以获得一瓶可乐，摇晃一瓶可乐，喷出一瓶可乐或者防御。谁被可乐喷到了谁就死了，好像还是比较有趣的。","text":"小时候玩过一个名字叫做“可乐”的游戏，一个回合内可以获得一瓶可乐，摇晃一瓶可乐，喷出一瓶可乐或者防御。谁被可乐喷到了谁就死了，好像还是比较有趣的。 毕业典礼的时候好像把曼妥思放到了可乐里。 [Ynoi E2023] TEST_90 Portal. 扫描线，然后维护一棵线段树代表当前位置 [i,r][i,r][i,r] 的出现次数，每次相当于区间翻转，然后维护历史版本和。 常数好像有点大，把矩阵给拆了就行了，傻狗题目不写了。 VP The 2nd Universal Cup. Stage 22: Hangzhou。 一人打 ICPC，打不动。 M. V-Diagram Portal. 答案的取值只有 [1,n],[1,mn+1],[mn−1,n][1,n],[1,mn+1],[mn-1,n][1,n],[1,mn+1],[mn−1,n] 三种，直接计算。 D. Operator Precedence Portal. 构造一个 x,2,−1,2,−1,⋯ ,2,−1,1x, 2, -1, 2, -1, \\cdots, 2, -1, 1x,2,−1,2,−1,⋯,2,−1,1 即可。 J. Mysterious Tree Portal. 先问 (1,2),⋯ ,(n−1,n)(1,2),\\cdots,(n-1,n)(1,2),⋯,(n−1,n) 来检测边的存在性，如果都不存在就都不是菊花。 找一条边，然后开始四处问即可。 做点明天讲课的题。 [ARC167E] One Square in a Triangle Portal. SSS 为偶数是好造的。 奇数时用偶数的造法造出了小数，于是将 BBB 移到一个 x,yx,yx,y 都是奇数的地方重新算一个。 摆了，剩下的题明天再说。 今天学习了一下关于苍蝇的事情：https://www.bilibili.com/video/BV1ba41177Sg/。 有点可怕，双翅目太可怕了（瑟瑟发抖）！","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/12(#14)：万物生辉","slug":"default/记录/2024/2/2024-02-07","date":"2024-02-07T00:00:00.000Z","updated":"2024-02-12T00:00:00.000Z","comments":true,"path":"f7c7b48f/","link":"","permalink":"https://james1badcreeper.github.io/f7c7b48f/","excerpt":"伪造的。","text":"伪造的。 Fake Love. 最近在玩《秽翼》，感觉是非常厉害的作品！整个作品的世界观目前感觉非常震撼！ 可以联想到《斗牛》的歌词： 性向善，才是人类最后的骄傲和胜算！ 找到自己认为对的事情，然后一直坚持下去 [PKUWC2024] Caught in the Middle Portal. 发现 Bob 想要赢是非常困难的，将 R 视为左括号保留右面的东西，L 视为右括号保留左面的东西，然后完美括号匹配是后手赢，因为可以下模仿棋杀掉一个完美括号匹配，否则先手可以先把它变成完美括号匹配。代码。 [Baltic OI 2018] Love Polygon Portal. 一开始形成二元环得扔了，直接模拟即可。注意自环不能连，可能两个自环分成一组，也可能自环被其它拓扑排序时遍历到得节点拯救。代码。 以后尝试能不能将作息调整的正常一点！ 想在这里放一张图，但是不知道放什么好！ 今天还再次听了几次《神树》，似乎终于能理解一点这首歌了！！ 我淹没在万人声响眼泪已经盖不住哀伤Never Give UpNever Give Up [UOJ838] 龙门对决 Portal. 树形 DP 计算出无头骑士和有头骑士的数量就行了，注意逆元会爆炸。代码。 [BalticOI 2018] Genetics Portal. 超级无敌炫酷牛 X 乱搞题，惊讶到了。 好像只会 O(n3)O(n^3)O(n3)，事实上也的确如此。用 4×n4\\times n4×n 个 bitset 维护是一个不错的选择，随机一个顺序可以在 LG 上过掉，但是还是比较慢。代码。 需要聪明一点的做法。比如，统计差异的和？随机分几组看上去就不错，但是很可惜，会被构造一种满足有很多近似解的数据给卡掉。那么加权 Hash 给字符串加权就可以了，可以在 QOJ 上通过。代码。 [eJOI2022] Adjacent Pairs Portal. 首先，如果在修改的过程中不存在已经初始存在的对，那么直接枚举对的其中一个数几个。否则枚举最终修改对来统计答案即可。代码。 [eJOI2022] Where Is the Root? Portal. 就是你要去问 999 次一个集合的 LCA 是否在集合内去找一个 500500500 的已知树的形态的树的根。 首先是一个事实，如果我带上所有叶子去问的话，那么 LCA 一定是根。 那么直接将所有的叶子加入询问，二分即可。但是这样会有一个问题，就是在剩下两个点的时候，它们都是叶子，然后就把另一个叶子扔了，就寄了。 把到其中一个叶子的孤独链（边上不含有任何东西）给杀了，然后问剩下的就可以了。代码。 [eJOI2022] Game With Numbers Portal. 可以发现这个东西是这样的，如果 mmm 比较大，那么每次至少玩家二能杀掉一半的数，答案最后就变成 000 了。 然后只有 01 关系，O(nm)O(nm)O(nm) 建立 01 Trie，直接 DP 即可。代码。 [CF1768F] Wonderful Jump Portal. 直接 DP： fi=min⁡j&lt;i{fj+(i−j)2×min⁡ai⋯j}f_i=\\min_{j&lt;i}\\{f_j+(i-j)^2 \\times \\min a_{i\\cdots j}\\} fi​=j&lt;imin​{fj​+(i−j)2×minai⋯j​} 如何优化？首先可以发现，最小值的取值一定在跳的区间的左端或者右端，否则拆开跳一定更优。 还有一个诡异的是 aaa 的值域，考虑一个一个跳，有： (i−j)2×min⁡ai⋯j≤(i−j)×n i−j≤nmin⁡ai⋯j(i-j)^2 \\times \\min a_{i\\cdots j}\\le (i-j)\\times n\\\\ ~ \\\\ i-j \\le \\frac{n}{\\min a_{i\\cdots j}} (i−j)2×minai⋯j​≤(i−j)×n i−j≤minai⋯j​n​ 枚举每个 aia_iai​ 作为最小值进行转移，根号分治一下可以得到 O(nn)O(n\\sqrt{n})O(nn​)。代码。 [CF1764H] Doremy’s Paint 2 Portal. 首先破环成链，然后从后往前推，fif_ifi​ 表示 iii 能够存活到的时间，使用珂朵莉树维护 fff 的连续段，每次相当于 lll 取 max⁡\\maxmax，l+1∼rl+1\\sim rl+1∼r 区间染色，在 BIT 上维护答案即可。代码。 《秽翼》真的是太感人了 对我来说好像有点感人过度了。 人的一生中，最重要的就是拼命地去活着，去寻找自己生存的意义。如今，我终于明白那句话的意思，那并不是什么复杂的事情。只要做出选择就好，向着自己无论何事发生，都会奋不顾身前进的道路。 我，存在的意义是什么？ 也许现在会有些许迷茫吧，所以才要去拼命的寻找。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/02/06(#13)：一点思考","slug":"default/记录/2024/1/2024-01-28","date":"2024-01-28T00:00:00.000Z","updated":"2024-02-06T00:00:00.000Z","comments":true,"path":"5246d897/","link":"","permalink":"https://james1badcreeper.github.io/5246d897/","excerpt":"摘要：不知道写点什么。","text":"摘要：不知道写点什么。 思考少了。 好奇怪啊。 [Ptz 2022 Day 2] Ternary Search Portal. 我们只需要考虑单谷。 谷的值是可以确定的。如果我们将谷左边的数全部取相反数，那么答案就是全局的逆序对数。 也就是说，我们通过是否取相反数来确定其应该是在谷值的左边还是右边。如果取相反数，那么它在左边，它对答案的贡献是在它左边比其小的个数 LiL_iLi​；如果不取相反数，那么其对答案的贡献就是正常计入逆序对统计了。 也就是说，我们可以正常求逆序对的个数，当其走到左边的时候，我们就在树状数组上撤销它的贡献。何时它会跑到左边？当在它左边有 xxx 个比它小的数，右边有 xxx 个比它小的数的时候，就会切换，此时直接继承原来的贡献即可。树状数组上倍增即可。代码。 [Ptz 2022 Day 2] Floor Tiles in a Park Portal. 大分讨题。 k=1k=1k=1 时答案是 111，k=2k=2k=2 时答案是 w+h−1w+h-1w+h−1。k=3,k=4k=3,k=4k=3,k=4 方式和 k=5k=5k=5 一样。 k=5k=5k=5 时可以有三条横线穿过去，方案数如下： 可以有两条横线，两条竖线穿过去，对照样例即可找到系数。代码。 [CF1924C] Fractal Origami Portal. 挺有趣的。 折一折就知道了 M=∑i=0n−222i,V=22+∑i=0n−222iM=\\sum_{i=0}^{n-2} 2\\sqrt{2}^i,V=2\\sqrt{2}+\\sum_{i=0}^{n-2} 2\\sqrt{2}^iM=∑i=0n−2​22​i,V=22​+∑i=0n−2​22​i。 然和随便合一合就行了。代码。 [CF1924E] Paper Cutting Again Portal. 考虑随机出一个操作序列 ppp，是一个 1∼n+m−21\\sim n + m - 21∼n+m−2 的排列。枚举所有切的位置称为答案的最后一步，考虑计算其概率。 应该满足 [1,i−1][1,i-1][1,i−1] 的行，[1,k/i][1,k/i][1,k/i] 的列都在 iii 行后就出现，概率可以直接计算为 1m\\frac 1 mm1​，然后加上当前这一步的 111，即可求出答案。代码。 [CF1924F] Anti-Proxy Attendance Portal. Joking 基本上和这道题一致。 实际上询问告诉我们的是，不管是真是假，我们可以知道缺席的学生在某一个集合里。 允许我们猜测两次的原因是明显的：在只剩两个人的时候我们没有办法得知谁是缺席的。因此，我们看看怎么在只剩三个人的时候排除一个人。 由于这道题是对于连续三次询问的情况有限制，情况非常复杂。因此我们先一点一点来： 先问一手 Q(1,2)Q(1,2)Q(1,2)？确实，无论回答是什么，都没什么意义。那不如假定它的回答就是 111，剩下的应该是对称的。 再问一手 Q(1,1)Q(1,1)Q(1,1)？ 如果它回答了一个 111，那么我们只需要再问一个 Q(1,3)Q(1,3)Q(1,3)，如果它的回答也是 111，那么 111 就一定不是缺席的，否则连续三次回答都是真的了；如果 Q(1,3)Q(1,3)Q(1,3) 回答了一个 000，那么这是一个假的，前两问 Q(1,2)Q(1,2)Q(1,2) 和 Q(1,1)Q(1,1)Q(1,1) 一定不能都是假的，如果它们都是假的，那么就证明了 333 是缺席的，也就是说，333 一定不是缺席的。 如果它回答了一个 000，就相当于 Q(2,3)Q(2,3)Q(2,3) 回答了 111。那么这时候再问一手 Q(1,2)Q(1,2)Q(1,2)，如果此时回答的是 111，那么三次回答不能都为真，222 就一定不是缺席的；如果 Q(1,2)Q(1,2)Q(1,2) 回答了 000，就相当于 Q(3,3)Q(3,3)Q(3,3) 回答了 111。此时能确定什么吗？还真不能，只好在问一次 Q(1,3)Q(1,3)Q(1,3)，就回到了上一种情况。 即使我们排除了中间的 222，其并不会影响接下来的询问的答案，因此我们可以直接三分，每次使用四次询问来排除掉 1/31/31/3 的答案，大约会使用 112112112 次询问，而题目只允许我们使用 102102102 次询问！好像废掉了！ 但是我们真的每次必须用 444 次询问吗？我们观察一下需要使用四次询问的情况，发现它们有一个特点：排除的一定不是 222。 也就是说我们让 222 分的小一点就可以了！我们可以使用 DP 来求解 222 分多少。设 fnf_nfn​ 代表问题规模为 nnn 的时候，至少使用多少次询问，枚举 222 分的个数 jjj，那么 fn=min⁡j=1n−2{max⁡{fn−j+3,fn−(n−j)/2+4}}f_n=\\min_{j=1}^{n-2}\\{\\max\\{f_{n-j}+3,f_{n-(n-j)/2}+4\\}\\}fn​=minj=1n−2​{max{fn−j​+3,fn−(n−j)/2​+4}}，跑不动。 但是我们可以观测转移点！跑 n=104n=10^4n=104，转移点的平均值是 0.3n0.3n0.3n，于是直接按照比例分就行了。代码。 [CF1056H] Detect Robots Portal. 就是要判断是否出现过 x→a→⋯→y,x→b→⋯→yx\\rightarrow a\\rightarrow \\cdots\\rightarrow y,x\\rightarrow b\\rightarrow \\cdots\\rightarrow yx→a→⋯→y,x→b→⋯→y 的情况。 根号分治。对于小串，对于每个终点 yyy 开一个 vector，push_back 所有的起点对应的 (x,t)(x,t)(x,t) 对，总个数是 O(nn)O(n\\sqrt{n})O(nn​) 的。对于大串，记录所有点的出现位置，对于每个串从后往前扫，记录当前最大的终点位置然后判断即可。代码。 水一下 Div.3，给小号上上分！ 完蛋，大意了😅","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2024/01/23(#12)：前往末日的旅行","slug":"default/记录/2024/1/2024-01-23","date":"2024-01-23T00:00:00.000Z","updated":"2024-01-23T00:00:00.000Z","comments":true,"path":"4d6f0c5/","link":"","permalink":"https://james1badcreeper.github.io/4d6f0c5/","excerpt":"又怎能得知。","text":"又怎能得知。 最后剩下我 我什么都没有 末日的飞船 载着我的骨头 将自由和占有，摧毁得片甲不留。 [ARC106E] Medals Portal. 直接将每个人拆成 kkk 个点，向右部的二分出的答案天进行匹配，过不去。 发现我们要求完美匹配，所以直接 Hall 定理判断是否存在即可。代码。 [ARC106F] Figures Portal. 枚举每个点的度数 rir_iri​，可以计数： Ans=∑∑ri=2n−2(n−2)!∏(ri−1)!×∏Adiri=∑∑ri=2n−2(n−2)!×∏Adiri(ri−1)!\\begin{aligned} Ans&amp;=\\sum_{\\sum r_i=2n-2}\\dfrac{(n-2)!}{\\prod(r_i-1)!}\\times \\prod A_{d_i}^{r_i}\\\\ &amp;=\\sum_{\\sum r_i=2n-2}(n-2)!\\times \\prod \\frac{A_{d_i}^{r_i}}{(r_i-1)!} \\end{aligned} Ans​=∑ri​=2n−2∑​∏(ri​−1)!(n−2)!​×∏Adi​ri​​=∑ri​=2n−2∑​(n−2)!×∏(ri​−1)!Adi​ri​​​​ 把后面那个东西写成 EGF，也就是说： Fi(x)=∑k=0∞Adik(k−1)!xk=∑k=0∞(dik)k xk=di∑k=1∞(di−1k−1) xk=dix∑k=0∞(di−1k) xk=dix(1+x)di−1\\begin{aligned} F_i(x) &amp;= \\sum_{k=0}^{\\infty} \\frac{A_{d_i}^k}{(k - 1)!}x^k \\\\ &amp; = \\sum_{k=0}^{\\infty} \\binom{d_i} k k \\ x^k \\\\ &amp; = d_i \\sum_{k=1}^{\\infty} \\binom{d_i - 1} {k - 1}\\ x^k \\\\ &amp; = d_i x \\sum_{k=0}^{\\infty} \\binom{d_i - 1} {k} \\ x^k \\\\ &amp; = d_i x (1 + x)^{d_i - 1} \\end{aligned} Fi​(x)​=k=0∑∞​(k−1)!Adi​k​​xk=k=0∑∞​(kdi​​)k xk=di​k=1∑∞​(k−1di​−1​) xk=di​xk=0∑∞​(kdi​−1​) xk=di​x(1+x)di​−1​ 记 S=∑diS=\\sum d_iS=∑di​，那么： Ans=(n−2)!×[x2(n−1)]∏i=1nFi(x)=(n−2)!×[x2(n−1)]∏i=1ndix(1+x)di−1=(n−2)!×∏i=1ndi×[xn−2]∏i=1n(1+x)di−1=(n−2)!×∏i=1ndi×[xn−2](1+x)S−n=(n−2)!×∏i=1ndi×(S−nn−2)\\begin{aligned} Ans&amp;= (n - 2)!\\times [x^{2(n-1)}] \\prod_{i=1}^nF_i(x)\\\\ &amp;= (n - 2)!\\times [x^{2(n-1)}] \\prod_{i=1}^n d_i x (1 + x)^{d_i - 1}\\\\ &amp;= (n - 2)!\\times\\prod_{i=1}^n d_i \\times [x^{n - 2}] \\prod_{i=1}^n (1 + x)^{d_i - 1} \\\\ &amp;= (n - 2)!\\times\\prod_{i=1}^n d_i \\times [x^{n - 2}] (1 + x)^{S - n} \\\\ &amp;= (n - 2)!\\times\\prod_{i=1}^n d_i \\times \\binom{S - n}{n-2} \\end{aligned} Ans​=(n−2)!×[x2(n−1)]i=1∏n​Fi​(x)=(n−2)!×[x2(n−1)]i=1∏n​di​x(1+x)di​−1=(n−2)!×i=1∏n​di​×[xn−2]i=1∏n​(1+x)di​−1=(n−2)!×i=1∏n​di​×[xn−2](1+x)S−n=(n−2)!×i=1∏n​di​×(n−2S−n​)​ [QOJ 4800] Oscar’s Round Must Have a Constructive Problem Portal. 倒着构造，有不合法的直接 swap 一组即可。 [QOJ 4803] Candies Portal. 令 ai&gt;x/2a_i&gt;x/2ai​&gt;x/2 的变成 x−aix-a_ix−ai​，deque 模拟匹配即可。 [Ynoi E2024] TEST_133 Portal. 分块，每个块内正常维护历史最大 tag，然后再维护一下排序后的结果，每次查询的时候暴力二分一下，散块直接 pushdown 整块的标记。注意查询的整块没有重构，需要计算二分出的位置的历史最值。代码。 [QOJ 4807] Melborp Lacissalc Portal. 先解决判定问题。做一遍模 kkk 意义下的前缀和，然后组合数随便算一下即可。 因此可以直接对着前缀和数组进行 DP。设 fi,j,kf_{i,j,k}fi,j,k​ 表示考虑前 iii 种数，放进了 jjj 个位置，当前贡献为 kkk，直接跑即可。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"NOI 二轮复习 II：构造与创造性思维","slug":"notes/NOI 复习/noi-2-2","date":"2024-01-05T00:00:00.000Z","updated":"2024-01-09T00:00:00.000Z","comments":true,"path":"da93401a/","link":"","permalink":"https://james1badcreeper.github.io/da93401a/","excerpt":"本文是 NOI 二轮复习的第二篇，介绍了有关于非传统题目的思考方式。","text":"本文是 NOI 二轮复习的第二篇，介绍了有关于非传统题目的思考方式。 广义来说，所有问题都属于构造类问题——它们都需要构造解。 此类题目中也有较多 ad-hoc 题，需要我们从多个角度思考，发挥自己的想象力。 我们不能对于每道题都枚举所有套路逐一试错，而需要具体情况具体分析。不应当完全依靠猜或试找出来，而是主要通过线索推断出来。它们包括但不限于： 特殊的题目条件、数据范围 特殊性质、部分分 必然性、充分性 模型的观察与转化 打表的结果 注意在做此类题目时，要避免自己陷入思维死局。 常见模型 一些问题常在特定结构上出现。 DFS 树 无向图的 DFS 树是没有横叉边的，可以根据此来完成一些题目。 「PMOI-4」可怜的团主。直接跑 DFS 树，如果叶子足够就直接构造（因为没横叉边），否则依次连边即可。代码。 图论相关 图论相关的内容非常多，可以参见以下表格。 基础性质CF1444C。我们知道 ∑deg⁡=O(m)\\sum \\operatorname{deg}=O(m)∑deg=O(m)，因此内部判断完之后，直接枚举就是对的。 zig-zag pattern 即之字形构造。 P9837 汪了个汪。所有的无序数对都要恰好出现一次，那么按照顺序填，按照无序数对的差分类即可。 Coprime Matrices。构造时直接将每两列按照之字形左右来回走即可，依赖 gcd⁡(x,x+1)=1\\gcd(x,x+1)=1gcd(x,x+1)=1，因此对于 www 的处理偏移一下即可。代码。 综合应用 一些杂题。 构造题组 1 一些题。 [CF1503F] Balance the Cards Portal. 考虑对于正反面都分别连 a→−aa\\to -aa→−a，那么如果一张牌入度为一出度为一则可以缩点，否则一定入度为二或者出度为二，出度为二必须出到相同的地方，否则无解。根据此直接构造即可，能证明这是有解的充要条件，可以参考官方题解。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"NOI 二轮复习 I：深入分析问题","slug":"notes/NOI 复习/noi-2-1","date":"2024-01-04T00:00:00.000Z","updated":"2024-01-05T00:00:00.000Z","comments":true,"path":"747e9724/","link":"","permalink":"https://james1badcreeper.github.io/747e9724/","excerpt":"本文是 NOI 二轮复习的第一篇，总结了一些分析问题的基本套路。","text":"本文是 NOI 二轮复习的第一篇，总结了一些分析问题的基本套路。 问题的转化 常见的情况是：原问题不好处理，我们将其转化为其它形式的问题。 操作转化 将操作用形象的方式描述出来。 [ARC110E] Shorten ABC Portal. 如何用一种方便的方式刻画操作？考虑将 a,b,ca,b,ca,b,c 对应成 1,2,31,2,31,2,3，发现操作相当于用 x⊕yx\\oplus yx⊕y 替换 x,yx,yx,y。 那么直接倒序 DP，转移的时候注意转移最小的前缀就可以了，因为这样的方案是转移其它前缀的超集，注意如果初始时不能启动那么答案是 111。代码。 实例 我们看一些例子，来说明如何用“套路”去解决问题。 数据结构 数据结构题。 [P9152] Gauss(3500); Portal. 在集合中两个相邻的城市 i,ji,ji,j（假定 i&lt;ji&lt;ji&lt;j）应该满足 min⁡{ai,aj}&gt;max⁡k=i+1j−1ak\\min\\{a_i,a_j\\}&gt;\\max_{k=i+1}^{j-1}a_kmin{ai​,aj​}&gt;maxk=i+1j−1​ak​。 式子中后面这个东西抽搐的样子不难想到将其扔到大根笛卡尔树上。 考虑 i,ji,ji,j 在树上的位置，它们一定存在祖先关系，否则它们的 LCA 就把限制干烂了。如果说 jjj 是 iii 的祖先，那么 iii 应该在 jjj 左儿子的右儿子链上，否则这条链上的点会把限制干烂。当然这里钦定了 i&lt;ji&lt;ji&lt;j，否则在右儿子的左儿子链上也是可以的。 考虑到 SSS 的选取条件是按照高度排序，这里钦定从大到小排序，相邻的节点必然满足 aaa 是 bbb 的祖先，且 bbb 在 aaa 的左儿子的右儿子链或者右儿子的左儿子链上。 如何处理单次询问？考虑树形 DP，令 fxf_xfx​ 代表以 xxx 开头的合法子集数量，gx,0/1g_{x,0/1}gx,0/1​ 代表 xxx 左儿子链/右儿子链的 fff 值的和，直接计算 fx=gx,0+gx,1+1,gx,0=glsx,0+fxf_x=g_{x,0}+g_{x,1}+1,g_{x,0}=g_{ls_x,0}+f_xfx​=gx,0​+gx,1​+1,gx,0​=glsx​,0​+fx​ 即可，初始时只给在询问区间内的 fff 初始化，然后树形 DP 一次即可。 扫描线维护值域维，从大到小依次加入新的数并重新计算 fff 的值，然后较大数不会影响小数的答案，因此直接树状数组上查询即可。 若数据随机，那么每个数在笛卡尔树上的期望深度是 O(log⁡n)O(\\log n)O(logn) 的，因此直接暴力维护就是对的。 使用树上随机撒点分块，预处理出每个关键点 +1+1+1 后对每个点 f/g0/g1f/g_0/g_1f/g0​/g1​ 对于每个点 fff 造成的影响并统计影响的树上前缀和，然后每次修改先暴力改到关键点，这一部分是 O(n)O(\\sqrt{n})O(n​) 的，然后跳 O(n)O(\\sqrt{n})O(n​) 次，打一个标记，并同时统计 fff 的前缀和。查询的时候枚举所有关键点，将所有 fff 加起来即可。 时间复杂度 O(nn+qn)O(n\\sqrt{n}+q\\sqrt{n})O(nn​+qn​)，空间复杂度 O(nn)O(n\\sqrt{n})O(nn​) 。逐块处理可以做到 O(n)O(n)O(n) 的空间，这是最常规的思路。 也有其它做法，这里写一种。 首先我们要求出序列中每个值的左边和右边分别第一个大于它的值 li,ril_i,r_ili​,ri​。 按照高度的值域进行分块。提前预处理出从某个点出发，到达和当前点同块的所有方案数 sumisum_isumi​，以及某个点到达它左边和右边两个方向第一个和当前值不属于一个值域块的方案数 sumli,sumrisuml_i ,sumr_isumli​,sumri​，以及它们所对应的位置 lidi,ridilid_i,rid_ilidi​,ridi​。可以 O(n)O(n)O(n) 完成。 修改时将预处理好的值扔到下一个块里，更新 gig_igi​ 代表第 iii 个值域块所影响的值域前缀（1∼Ri1\\sim R_i1∼Ri​）的答案。其只会跳最多不超过两倍块数次。同时可以处理出比 iii 小的值跳到 iii 的方案数 fif_ifi​。 每次查询，因为小的值每加入，所以直接从小到大加上区间包含的所有整块的方案 gidg_{id}gid​。然后就是唯一的那个散块，直接暴力 DP 即可，时间复杂度 O((n+q)n)O((n+q)\\sqrt{n})O((n+q)n​)，空间复杂度 O(n)O(n)O(n)。代码。 综合应用 挑战自我吧！","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"2024/01/22(#11)：下方","slug":"default/记录/2024/1/2024-01-07","date":"2024-01-04T00:00:00.000Z","updated":"2024-01-20T00:00:00.000Z","comments":true,"path":"1cf7feb5/","link":"","permalink":"https://james1badcreeper.github.io/1cf7feb5/","excerpt":"是的。","text":"是的。 拖更了 INF 年，摆完了。 このまま 奪って 隠して 忘れたい 就这样被剥夺 隐藏起来 想忘却一切 ****，一篇都凑不齐了吗。 [CF1558F] Strange Sort Portal. 将数字排序转化为 01 排序，答案是最右侧的 000 的就位时间。 设第 iii 个 000 的就位时间是 fif_ifi​，如果其向左交换的过程中碰到了 000，那么答案是 fi−1+1f_{i-1}+1fi−1​+1，否则就是前面 111 的个数 pi−ip_i-ipi​−i 加上一个 pi mod 2p_i\\bmod 2pi​mod2（pip_ipi​ 代表其位置）。 考虑当前有 iii 个 000，从第 preprepre 个 000 开始没有归位，其代价暴力拆开后是 m−im-im−i，长成这样： fm=max⁡i=prem{pi−i+(pi mod 2)+(m−i)}f_m = \\max_{i=pre}^m \\{p_i-i+(p_i \\bmod 2) + (m - i)\\} fm​=i=premaxm​{pi​−i+(pi​mod2)+(m−i)} 枚举 mmm，线段树维护即可。代码。 [CF55D] Beautiful numbers Portal. 我们维护当前出现所有数的 lcm⁡\\operatorname{lcm}lcm 即可很方便地判断，直接数位 DP 即可。代码。 [CEOI2011] Matching Portal. 相当于求出 aaa 的置换再进行字符串匹配。可以动态对 bbb 进行扫描，使用权值树状数组将 KMP 的相等判定改掉，记录其值域的前驱后继的位置，然后匹配的时候要满足它们之间的位置关系。代码。 [QOJ4829] Mark on a Graph Portal. 由于它给的是随机图，因此我们要给他搞一些特殊标识使得这张图可以被我们识别。找到度数最大的五个点，然后给它上一个环即可。代码。 所以这玩意儿能过是什么鬼啊？？ #import&lt;time.h> main()&#123;int t=time(0);puts(t&amp;1?\"mark 0\":\"ok\");while(t==time(0));&#125; [Ynoi E2024] TEST_132 Portal. 直接根号分治做完了，卡常题。代码。 好像，这种东西不更新，就没有效率。 今天就这样吧，明天再加更！！","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023 年度总结：新世界","slug":"summaries/hello2024","date":"2024-01-01T00:00:00.000Z","updated":"2024-01-01T00:00:00.000Z","comments":true,"path":"1424643c/","link":"","permalink":"https://james1badcreeper.github.io/1424643c/","excerpt":"Goodbye，2023，Forever。","text":"Goodbye，2023，Forever。 元旦这天发现自己竟然没写年度总结，于是赶紧来凑数。 序曲 童真、残忍、理性、控制、浪漫、悲观、癫狂……在多重人格的纠缠中，冲破枷锁，追寻极致的自我。 虽然缺陷很多，但这是我造就的最不平凡的一年。 如果选择了不凡，那么路上必定满是荆棘。值得庆幸的是，我走过来了。接下来的路也许更为坎坷，但只要我还是那个疯子，我必然能走到我所能够走到的尽头。 需要学习的真的很多，在这一年里，认识了一些新的人，也重新认识了许多人。能遇到他们，我表示衷心的感谢。 刺客 弱小和无知不是生存的障碍，傲慢才是。——刘慈欣《三体》 败了，需要承认的。 原因已经反思过了，也已经刻在骨头里，这里没什么需要重复的。 也许当时的失败对我是一件好事，否则我可能到现在都无法理解一些事情：在那之后的文化课学习过程中，可能对我认知的影响远比一个学期的停课大。 这似乎是我第一次来到我的新班级，也许是我第一次来到我们学校的二楼的另一侧。我只去过实验楼入口的那一侧，这次我来到的是强基班的教室这一侧。 我认识了许多以前“无法理解”的内容，记得我们语文老师曾在晚课时的激情演讲。还有我的同桌（班级（还是年级，忘了）语文最高分）因不写语文作业被罚抄《促织》，然后把那幅井的插画也给画下来的故事。还有物理课上生动形象的舞蹈，数学王的谆谆教诲…… 一开始我甚至是想混过这个学期的，但是没想到我竟然学到了这么多。 那段时间就像一个刀法精准的刺客，刺死了许多东西。 旧地 我和高一的同学们一起回到了那个令人难以忘怀的地方，充满了原神、崩铁和蟑螂的地方。那里有很好吃的干豆腐。 这段时间有很多难忘的事情，比如我顶着 38 度的高温睡到了天亮，和某同学顶着暴雨从机房赶回了宿舍，凌晨的演唱会…… 我是星，利剑开刃寒光锋芒的银星，绝不消隐——《夜航星》 终章 CSP2023，NOIP 2023，成绩都不是很理想，但也许这就是我的真实水平。 需要继续努力啊，前面的挑战还很多呢。 2023 年的最后一天，24 OI 团建。 这一天显得如此匆忙，竟没有什么时间用来感慨即将逝去的 2023。很大原因是因为 74TrAkToR，这个不负责任的组织者出的垃圾场 Goodbye 2023，希望他能好好反思反思，希望他能给大家带来更好的东西，而不是“对不起，我错了，但是我坚决不改”，像曾经的我那样。 从说书人的视角来看，大家似乎都很开心，这就足够了。 参考资料 我自己写的闲话。 各个平台的年度总结。 最后，再次感谢屏幕前的你们。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"NOI 一轮复习 IX：数据结构 B","slug":"notes/NOI 复习/noi-1-9","date":"2023-12-30T00:00:00.000Z","updated":"2023-12-11T00:00:00.000Z","comments":true,"path":"ba44503d/","link":"","permalink":"https://james1badcreeper.github.io/ba44503d/","excerpt":"本文是 NOI 一轮复习的终章，包括各类根号数据结构（以及其它数据结构杂项）。","text":"本文是 NOI 一轮复习的终章，包括各类根号数据结构（以及其它数据结构杂项）。 在介绍一切内容之前，我们先介绍一种思想：平衡思想。 我们对于 ≥B\\ge B≥B 和 &lt;B&lt;B&lt;B 的问题如果都有高效做法，那么可以考虑将它们拼起来，对于不同的部分使用不同的做法，从而得到一个求解整个问题的高效做法。 序列分块 分块是一种树形结构，可以视作一棵只有三层的树。 分类 动态分块可以支持修改，本质上是通过分块达到“大块维护，小块暴力”的方式来加速数据结构。 静态分块不支持修改，通过预处理一些信息来加速查询。本身功能是莫队的子集，但是其可以在线。 例题 一些题，有些比较复杂。 [Ynoi2019 模拟赛] Yuno loves sqrt technology III Portal. 我们记录 f(i,j)f(i,j)f(i,j) 代表第 [i,j][i,j][i,j] 块的区间众数出现次数。我们对每一个数都开一个 STL vector，记录其出现的位置，并记 ax[i]ax[i]ax[i] 为第 iii 个数出现在其 vector 中的位置。 整块的答案是可以直接统计的，而对于零散块，则获取当前的数在 vector 中的位置，考虑 ansansans 是否可以变大，进行暴力更新即可。由于 ansansans 最多变大 2n2\\sqrt{n}2n​，因此询问的时间复杂度为 O(n)O(\\sqrt{n})O(n​)。 总时间复杂度为 O(nn)O(n\\sqrt{n})O(nn​)。代码。 [Ynoi2019 模拟赛] Yuno loves sqrt technology I Portal. 强制在线的区间逆序对！ 整块内部：预处理； 散块内部：用树状数组预处理前后缀； 散块对散块：处理好每个数的排名，直接归并； 散块对整块：预处理出 gi,jg_{i,j}gi,j​ 代表 1∼j1\\sim j1∼j 对 iii 块的贡献。 代码。 [CF453E] Little Pony and Lord Tirek Portal. 预处理 fi,kf_{i,k}fi,k​ 表示第 iii 块从全 000 开始，kkk 个单位时间后的和。由于区间推平操作的存在，颜色段均摊后复杂度是正确的。代码。 带插入区间 k 小 Portal. 设 si,js_{i,j}si,j​ 代表前 iii 个块落在第 jjj 个值域块的数的个数，vi,jv_{i,j}vi,j​ 代表 iii 块内值为 jjj 的个数。然后所有信息都能够统计，块大的时候直接分裂即可。代码。 莫队 莫队，即高维扫描线，用一种合理的排序方式使得复杂度可以接受。 普通莫队 如果我们能够从得知对于当前区间，增加一个数和减少一个数对答案的增量，便可以直接莫队。 莫队可以卡常数。块的编号可以按照奇偶进行排序。 莫队可以支持修改，本质上就变成了三维扫描线。 复杂度分析 对于二维扫描线，设块长为 BBB，则时间复杂度为 O(n2B+mB)O\\left(\\cfrac{n^2}{B}+mB\\right)O(Bn2​+mB)，前者是有 n/Bn/Bn/B 个块，块的移动需要 nnn 次，后者是每个询问需要 BBB 次移动。发现 BBB 取 nm\\cfrac{n}{\\sqrt{m}}m​n​ 可以做到 O(nm)O(n\\sqrt{m})O(nm​) 的最优复杂度。 对于三维扫描线，时间复杂度为 O(n2tB2+mB)O\\left(\\cfrac{n^2 t}{B^2}+mB\\right)O(B2n2t​+mB)，因此可以取 B=n23t13m13B=\\cfrac{n^{\\frac 2 3}t^{\\frac 1 3}}{m^{\\frac 1 3}}B=m31​n32​t31​​。 树上莫队 对于查询链上的信息，有两种实现方式，一种是利用括号序将其拍到链上再做处理，另一种是正经的树分块做法。一般情况下采用前者足矣。 对于查询子树信息，此时不如直接树上启发式合并。 回滚莫队 莫队二次离线 例题 一些题。 [Ynoi2015] 盼君勿忘 Portal. 考虑统计每个数 xxx 出现 yyy 次的贡献，其为 x((2y−1)×2len−y)=x(2len−2len−y)x((2^{y}-1)\\times 2^{len-y})=x(2^{len}-2^{len-y})x((2y−1)×2len−y)=x(2len−2len−y)。对于出现次数相同的数一起统计，这样的数只有 O(n)O(\\sqrt{n})O(n​) 个，链表维护即可。代码。 常见套路总结 根号分治（平衡） 考虑这样一个问题： O(1)O(1)O(1) 单点修改，O(n)O(\\sqrt{n})O(n​) 查询区间和。 简单！分块维护块内的和，每次修改的时候更新块内和即可。 O(n)O(\\sqrt{n})O(n​) 单点修改，O(1)O(1)O(1) 查询区间和。 分块维护块内块外前缀和，也就是每个块内前 xxx 个数的和和前 xxx 块的和，那么查询就是 O(1)O(1)O(1) 的了。 O(1)O(1)O(1) 区间修改，O(n)O(\\sqrt{n})O(n​) 查询单点。 将第一个差分掉直接做即可。 维护一个集合，O(n)O(\\sqrt{n})O(n​) 插入数，O(1)O(1)O(1) 查询 kkk 小。 考虑值域分块，每个数维护其所在的块，对块维护一个有序表，插入的时候直接归并，kkk 小就可以直接查询。 [IOI2009] Regions Portal. 对集合大小进行根号分治，大集合预处理出答案，小集合可以对应到时间戳区间，先排序后再双指针扫描即可。代码。 [POI2015] ODW Portal. k&gt;Bk&gt;Bk&gt;B 的部分暴力跳，k≤Bk\\le Bk≤B 预处理即可。代码。 [CF840E] In a Trap Portal. 式子中有一个树上距离不太好处理，我们考虑按照距离进行根号分治。 将每个点向上 282^828 个点（包括自己）分为一块，这样向上跳的时候，每一块的后 888 位不会产生影响。也就是说，我们预处理出 gx,i=max⁡j=0255afx,j⊕(256i+j)g_{x,i}=\\max_{j=0}^{255} a_{f_{x,j}}\\oplus (256i+j)gx,i​=maxj=0255​afx,j​​⊕(256i+j) 代表 xxx 所属的块内，iii 的值给定时的块内最大答案，其中 fff 表示 xxx 的 jjj 级父亲。 可以注意到加号前后两部分是互不影响的，那么将 aaa 拆成前 888 位和后 888 位，前半部分将块内所有数值插入 01 Trie，然后查询前半部分的最大值 ansansans，后半部分直接开个桶，查询 ans⊕ians\\oplus ians⊕i 的最大值即可。 查询的时候直接从 vvv 开始向上跳，整块直接获得答案，散块暴力即可。 时间复杂度 O(nnlog⁡n+qn)O(n\\sqrt{n}\\log n+q\\sqrt{n})O(nn​logn+qn​)。代码。 [CF1056H] Detect Robots Portal. 就是要判断是否出现过 x→a→⋯→y,x→b→⋯→yx\\rightarrow a\\rightarrow \\cdots\\rightarrow y,x\\rightarrow b\\rightarrow \\cdots\\rightarrow yx→a→⋯→y,x→b→⋯→y 的情况。 根号分治。对于小串，对于每个终点 yyy 开一个 vector，push_back 所有的起点对应的 (x,t)(x,t)(x,t) 对，总个数是 O(nn)O(n\\sqrt{n})O(nn​) 的。对于大串，记录所有点的出现位置，对于每个串从后往前扫，记录当前最大的终点位置然后判断即可。代码。 数据结构杂项 以下内容可能不太常用，但是因为某些原因我们选择将其记录在这里。随缘填坑。 根号重构 即所谓的“操作分块”：在根号次操作后重构数据结构来计算影响。 [APIO2019] 桥梁。 操作分块。块之前的修改直接处理掉，块内部的按照重量限制排序然后枚举所有询问，不需要修改的边按照重量限制依次添加，再枚举需要修改的边按照时间进行修改，然后直接可撤销并查集维护这一阶段的修改，对于一个块内这一步是 O(mlog⁡m+m+B2)O(m\\log m + m +B^2)O(mlogm+m+B2) 的。代码。 树分块 外星旅者离开了地球。Top Cluster 树分块的相关内容不会在 NOI 2024 前更新。所有树分块的相关内容不会在省选联考 2024 前更新。 倍增值域分块 减半警报器 KTT 题车 其实没什么东西了。 刷基础 一些基础题。 [CF1406E] Deleting Numbers Portal. 考虑求出 xxx 的质因数幂次。 对 n\\sqrt{n}n​ 以内的质数可以暴力搞。然后剩下的都是大质数，最多只会出现一次。如果直接扫过去需要 2m2m2m 次询问（mmm 为质数个数），那么将 BBB 个质数分为一块，一块一块地去检查，就只需要 m+2mm+2\\sqrt{m}m+2m​ 次询问。代码。 刷提升 1 全面应用数据结构！ [Ynoi2018] 未来日记 Portal. 使用带插入 kkk 小的方式来维护 kkk 小值，用并查集维护将一个数改为另一个数，整块改值，散块直接重构。 注意要跳过无效修改，这个卡常很有效。代码。 [Ynoi2018] 五彩斑斓的世界 Portal. 离线，逐块处理。我们需要一个可以在 O(m)O(m)O(m) 完成单个块内处理的算法。 记块内最大值为 kkk，那么： k≤2xk\\le 2xk≤2x，令大于 xxx 的数减去 xxx 后就没有比 xxx 大的数了，kkk 会减小至少 k−xk-xk−x； k&gt;2xk&gt;2xk&gt;2x，令小于等于 xxx 的数加上 xxx，就没有比 xxx 小的数了。然后打上全局减标记，kkk 在操作后减少至少 xxx。 发现这个 kkk 单调不增，那么时间复杂度为 O(V)O(V)O(V)。 维护数值时直接采用并查集，记录集合的大小。零散块修改直接重构，整块则直接维护。代码。 刷提升 2 进一步提升数据结构能力！！ [Ynoi2007] tmpq Portal. 暴力 DP 可以将 i,ki,ki,k 的贡献拆开然后暴力扫然后乘起来即可。 看上去就非常的离谱，以前给出的做法大概是这样的： 直接操作分块，每次只有 O(m)O(\\sqrt{m})O(m​) 个被修改的数，然后就有看每个数是否是在这个块内被修改的，888 种情况都能做，就是有点无语。 有一种聪明的做法，转化为 a,b,ca,b,ca,b,c 单点修改，bi=aj=ckb_i=a_j=c_kbi​=aj​=ck​ 的个数。先写一个动态 DP 维护转移。 对于每个出现的 www 的次数进行根号分治。对于 cntw≤Bcnt_w\\le Bcntw​≤B，那么进行暴力 DP，然后差分贡献，扔到相应的位置上，询问相当于求前缀和，O(nn)O(n\\sqrt{n})O(nn​) 次修改，O(m)O(m)O(m) 次查询，使用 O(1)−O(n)O(1)-O(\\sqrt{n})O(1)−O(n​) 的分块维护。 对于 cntw&gt;Bcnt_w&gt;Bcntw​&gt;B，离线扫一遍操作序列，单点修改前缀查询，由于修改的总个数是 O(m)O(m)O(m)，询问个数是 O(mn)O(m\\sqrt n)O(mn​)，因此使用 O(n)−O(1)O(\\sqrt{n})-O(1)O(n​)−O(1) 的分块维护即可。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"2023/12/27(#10)：Power Of Darkness","slug":"default/记录/2023/12/2023-12-27","date":"2023-12-26T00:00:00.000Z","updated":"2023-12-27T00:00:00.000Z","comments":true,"path":"c05a826b/","link":"","permalink":"https://james1badcreeper.github.io/c05a826b/","excerpt":"那便无需去怀疑。","text":"那便无需去怀疑。 在黑夜的尽头，是否充满了孤独。 其实我还想起了一些东西： 堕入这无尽的黑夜，落幕是无垠的飞雪。崩塌之间，在你身边，以什么形态致死缠绵，你说要文明诞生于岁月。 开始喜欢上了口胡，感觉自己需要想更多的东西。 [BalticOI 2017] Political Development Portal. 导出子图中的点至少有一个小于 kkk，那么我们可以从度数小的点开始跑暴力，然后把它删掉。代码。 [BalticOI 2017] Railway 处理出 DFS 序，然后经典地，相当于每条边都经过了两次。维护时记录一下边的编号，BIT 搞一下即可。 [BalticOI 2017] Toll Portal. 本质上是分成 kkk 层的图，对于每一层维护一个矩阵，然后动态 DP 的方式转移，倍增预处理即可。 怎么只有一个比较不错的题啊。 看上去 2018 年的题不错，过几天做做。 [CF526E] Transmitting Levels Portal. 直接暴力就是对的，下面是证明： 设 iii 节点跳不超过 KKK 可以到达 toito_itoi​，那么 n≤∑toi−in\\le \\sum to_i-in≤∑toi​−i，因此必有至少一个 toi−i≤n/ansto_i-i\\le n/anstoi​−i≤n/ans，枚举 n/ansn/ansn/ans 个数，每次会跳 ansansans 次。代码。 ED 杂活好多。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/24(#9)：Welcome to the Elegant World","slug":"default/记录/2023/12/2023-12-24","date":"2023-12-23T00:00:00.000Z","updated":"2023-12-24T00:00:00.000Z","comments":true,"path":"b9d6a2f8/","link":"","permalink":"https://james1badcreeper.github.io/b9d6a2f8/","excerpt":"醉也从容，我也从容。","text":"醉也从容，我也从容。 沉醉这风光讲究 明暗是假象 告别这星光黯淡 来去是假象 坐拥这掌声散去 起落是假象 笑对这冷眼观望 天地是假象 别弯腰 接受时间 躲不开的那一刀 人生渺渺 一种脚步入一山 结局没人敢赌穿 嬉笑谢幕勉为难 反复上演 难怪片刻新鲜是假象 笔墨再多渲染 明暗是假象 原谅娱乐看官 来去是假象 开场有多喧闹 起落是假象 结尾有多寂寥 天地是假象 论英雄 只有故事 从来没有后来 半晌贪欢几次 缅怀都是谈资 旁观都是一时 幸免才叫历史 不如下山 笑看万物是假象 Oh it’s a new world —— 华晨宇《新世界》 太有感觉了！ 断更无数天，我又回来了！！ [ARC104E] Random LIS Portal. 发现 n≤6n\\le 6n≤6，因此知道必定有鬼。可以 O(nn)O(n^n)O(nn) 枚举数列的相对大小关系，然后我们可以将数划分成若干值域段。对于落在相同值域段里的枚举下界，然后组合数直接算即可。代码。 [ABC176F] Brave CHAIN Portal. 设 fi,x,yf_{i,x,y}fi,x,y​ 代表考虑前 iii 次删牌留下 x,yx,yx,y 的最大分数。暴力做是 O(n3)O(n^3)O(n3) 的，统计一下前缀最值即可。代码。 [CEOI2012] 工作规划 Portal. 二分 + 贪心，然后记一下编号输出方案即可。 ED 虽然有点摆（感觉自己没进状态），但今天看了人民日报发的 2023 年度总结：https://www.bilibili.com/video/BV1HC4y1M7SE/。 好感人啊，没想到我们发展了这么多呢。 命运，取决于我们自己的抉择。 我们会继续前行！","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"NOI 一轮复习 VIII：数学 C","slug":"notes/NOI 复习/noi-1-8","date":"2023-12-19T00:00:00.000Z","updated":"2024-01-19T00:00:00.000Z","comments":true,"path":"8c95d298/","link":"","permalink":"https://james1badcreeper.github.io/8c95d298/","excerpt":"本文是 NOI 一轮复习的第八篇，主要介绍了数论、线性代数、计算几何和其它数学知识。","text":"本文是 NOI 一轮复习的第八篇，主要介绍了数论、线性代数、计算几何和其它数学知识。 正整数中的数论 主要是针对素数的研究。 素数与合数 如果一个数 x(x∈N)x(x\\in\\mathbb{N})x(x∈N) 的约数仅有 111 和它本身，那么就称 xxx 是质数（素数），特别地，000 和 111 不是质数，如果一个自然数不是质数，他就是合数。 可以用线性筛在 O(n)O(n)O(n) 的时间内筛出所有质数，用 O(r+(r−l+1)log⁡(r−l+1))O(\\sqrt{r}+(r-l+1)\\log(r-l+1))O(r​+(r−l+1)log(r−l+1)) 的时间筛出区间内的所有质数。 ppp 进赋值序列是刻画正整数的重要方式。可以将正整数表示到 ppp 维空间上。 大质因数 一个数最多只有一个 ≥v\\ge \\sqrt{v}≥v​ 的质数因子，这个思路非常经典。 [NOI2015] 寿司晚宴。最暴力的做法就是设 fS1,S2f_{S_1,S_2}fS1​,S2​​ 代表两人选的质因数状压后分别为 S1,S2S_1,S_2S1​,S2​，发现 n≤500n\\le 500n≤500，比 191919 大的质因数最多出现一次，可以单独记录这个大质因数，然后把每一个有这个大质因数的寿司设为一组，在这一组进行转移时另记 g1,g2g_1,g_2g1​,g2​ 分别代表只允许这两个人其中一个吃有这个大质因数的寿司，最后合并答案的时候还要减去最初的 fff，因为两个人都不吃的算了两次。代码。 整除性 研究整除相关的数论。 数论分块 数论分块。⌊ni⌋\\left\\lfloor\\frac{n}{i}\\right\\rfloor⌊in​⌋ 只有 O(n)O(\\sqrt{n})O(n​) 中不同的取值，并且每一种取值都是一个连续的区间。 比如光速幂是利用这一点来实现的，这个技巧也可以在 O(n)O(\\sqrt{n})O(n​) 时间内枚举到所有区间。 最经典的应用就是快速计算 ∑i=1nf(i)g(⌊ni⌋)\\sum_{i=1}^n f(i)g\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)∑i=1n​f(i)g(⌊in​⌋)，需要 O(1)O(1)O(1) 计算 ∑i=lrf(i)\\sum_{i=l}^{r}f(i)∑i=lr​f(i)，然后将 ggg 相同的打包计算。 使得 ⌊ni⌋=⌊nj⌋\\lfloor\\frac{n}{i}\\rfloor=\\lfloor\\frac{n}{j}\\rfloor⌊in​⌋=⌊jn​⌋ 成立的最大满足 i≤j≤ni\\le j\\le ni≤j≤n 的块的右端点为 ⌊n⌊ni⌋⌋\\left\\lfloor\\cfrac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor⌊⌊in​⌋n​⌋。为什么？令 k=⌊ni⌋k=\\lfloor\\frac{n}{i}\\rfloork=⌊in​⌋，可知 k≤nik\\le \\frac{n}{i}k≤in​，那么 ⌊nk⌋≥i\\lfloor\\frac{n}{k}\\rfloor\\ge i⌊kn​⌋≥i，所以 j=nij=\\frac{n}{i}j=in​。时间复杂度 O(n)O(\\sqrt{n})O(n​)。 欧几里德算法 辗转相减法可以用来求解两个数的 gcd⁡\\gcdgcd： int gcd(int a, int b) &#123; if (a == b) return a; if (!a || !b) return a | b; if (!(a &amp; 1)) &#123; if (b &amp; 1) return gcd(a >> 1, b); return gcd(a >> 1, b >> 1) &lt;&lt; 1; &#125; if (!(b &amp; 1)) return gcd(a, b >> 1); if (a > b) return gcd((a - b) >> 1, b); return gcd((b - a) >> 1, a); &#125; 辗转相减（除）是一个非常重要的结构，出现时往往伴随着与 gcd⁡\\gcdgcd 相关的结论。 类欧几里德算法 万能欧几里德算法 数论函数 定义域为整数的函数是数论函数，一般我们研究数论函数中的积性函数。对于所有积性函数 fff，都有 f(1)=1f(1)=1f(1)=1。 常见积性函数： 单位函数 ϵ(n)=[n=1]\\epsilon(n)=[n=1]ϵ(n)=[n=1]，是完全积性函数。 常数函数 1(n)=11(n)=11(n)=1，是完全积性函数。 恒等函数 id⁡k(n)=nk\\operatorname{id}_k(n)=n^kidk​(n)=nk，是完全积性函数，当 k=1k=1k=1 时可以省略不写。 除数函数 σk(n)=∑d∣ndk\\sigma_k(n)=\\sum_{d\\mid n}d^kσk​(n)=∑d∣n​dk。这样的话，σ0(n)=τ(n)\\sigma_0(n)=\\tau(n)σ0​(n)=τ(n)，σ1(n)\\sigma_1(n)σ1​(n) 代表约数和，有 σk(n)=∏i=1s(∑j=0αipijk)=∏i=1sσk(piαi)\\sigma_k(n)=\\prod_{i=1}^s\\left(\\sum_{j=0}^{\\alpha_i}p_i^{jk}\\right)=\\prod_{i=1}^s\\sigma_k(p_i^{\\alpha_i})σk​(n)=∏i=1s​(∑j=0αi​​pijk​)=∏i=1s​σk​(piαi​​)。 欧拉函数，φ(n)\\varphi(n)φ(n) 代表 1∼n1\\sim n1∼n 中与 nnn 互质的数的个数。 本质不同质因子个数函数 ω(n)=∑p[p∣n]\\omega(n)=\\sum_{p}[p\\mid n]ω(n)=∑p​[p∣n]。 线性筛可以计算所有的积性函数（前提是可以快速求出 f(pk+1)f(p^{k+1})f(pk+1)，只需要记录 lowlowlow 代表最小质因子的最高次幂： for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[++tot] = i, f[i] = ..., low[i] = i; // 单独算 f(p) for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; // i 与 p 不互质 low[i * prime[j]] = low[i] * prime[j]; if (i == low[i]) f[i * prime[j]] = ...; // i = p^k，单独算 f(p^&#123;k+1&#125;) else f[i * prime[j]] = f[i / low[i]] * f[low[i] * prime[j]]; break; &#125; low[i * prime[j]] = prime[j]; f[i * prime[j]] = f[i] * f[prime[j]]; // i 与 p 互质，f(ip) = f(i)f(p) &#125; &#125; 狄利克雷卷积是数论函数的基本运算。定义： h(n)=∑d∣nf(d)g(nd)h(n)=\\sum_{d\\mid n}f(d)g\\left(\\frac{n}{d}\\right) h(n)=d∣n∑​f(d)g(dn​) 简记为 h=f∗gh=f*gh=f∗g。 狄利克雷卷积具有交换律、结合律和分配律。 首先，ϵ∗f=f\\epsilon*f=fϵ∗f=f。因此单位函数 ϵ\\epsilonϵ 为狄利克雷卷积的单位元，那么就可以定义数论函数的逆元 f−1f^{-1}f−1，满足 f∗f−1=ϵf*f^{-1}=\\epsilonf∗f−1=ϵ。 一个 fff 存在逆元，当且仅当 f(1)≠0f(1)\\ne 0f(1)=0，并且逆元唯一。f=gf=gf=g 的充要条件是 f∗h=g∗h(h(1)≠1)f*h=g*h(h(1)\\ne 1)f∗h=g∗h(h(1)=1)。这样一来有 g(n)=−∑d∣n,d≠ng(d)f(nd)f(1)g(n) = -\\cfrac{\\sum\\limits_{d \\mid n, d \\neq n} g(d)f\\left(\\dfrac n d\\right)} {f(1)}g(n)=−f(1)d∣n,d=n∑​g(d)f(dn​)​。 积性函数的狄利克雷卷积是积性函数，积性函数的逆元也是积性函数。 以下是一些常用的狄利克雷卷积： 1∗1=τ1*1=\\tau1∗1=τ， φ∗1=id⁡\\varphi *1=\\operatorname{id}φ∗1=id。 任意数论函数 fff 卷常数函数 111 等价于做 fff 的狄利克雷前缀和，即：g=f∗1,g(n)=∑d∣nf(d)g=f*1,g(n)=\\sum_{d\\mid n}f(d)g=f∗1,g(n)=∑d∣n​f(d)。含义是对每个 nnn 计算给定数论函数在其所因数处的取值和。 将每个数写成无穷序列 an={c1,c2,⋯ }a_n=\\{c_1,c_2,\\cdots\\}an​={c1​,c2​,⋯} 表示 n=∏picin=\\prod p_i^{c_i}n=∏pici​​。由于 x∣yx\\mid yx∣y 的充要条件为 ax(ci)≤ay(ci)a_x(c_i)\\le a_y(c_i)ax​(ci​)≤ay​(ci​)，因此 f∗1f*1f∗1 可以看成对下标做其无穷序列的高维前缀和。 模板，这里是对 aaa 做狄利克雷前缀和，采用高维前缀和实现即可，代码。 欧拉函数 欧拉函数，即 φ(n)\\varphi(n)φ(n)，代表 1∼n1\\sim n1∼n 中与 nnn 互质的数的个数。 设 n=∏pikin=\\prod p_i^{k_i}n=∏piki​​，则有： φ(n)=n∏(1−1pi)=n∏pi−1pi\\varphi(n)=n\\prod(1-\\cfrac{1}{p_i})=n\\prod \\cfrac{p_i-1}{p_i} φ(n)=n∏(1−pi​1​)=n∏pi​pi​−1​ 欧拉反演：n=∑d∣nφ(d)n = \\sum_{d\\mid n} \\varphi(d)n=∑d∣n​φ(d)。 莫比乌斯函数 我们定义莫比乌斯函数： μ(n)={1,n=1,0,∃d&gt;1,d2∣n,(−1)ω(n),otherwise.\\mu(n)=\\begin{cases}1,&amp;n=1,\\\\0,&amp;\\exists d&gt;1,d^{2}\\mid n, \\\\(-1)^{\\omega(n)},&amp;\\mathrm{otherwise}. \\end{cases} μ(n)=⎩⎨⎧​1,0,(−1)ω(n),​n=1,∃d&gt;1,d2∣n,otherwise.​ 实际上它是在对 N\\mathbb{N}N 做容斥。设 g(n)=∑n∣df(d)g(n)=\\sum_{n\\mid d} f(d)g(n)=∑n∣d​f(d)，已知 ggg，要求 f(1)f(1)f(1)。f(1)f(1)f(1) 等于 ggg 在 111 的倍数处取的取值和，减去质数处的取值和，但是多减了两个质数乘积的地方，因此还要加回来。这就是容斥原理，容斥系数是 (−1)ω(n)(-1)^{\\omega(n)}(−1)ω(n)。 它不仅是积性函数，还满足： ∑d∣nμ(d)={1,n=1,0,n≠1.\\sum_{d\\mid n}\\mu(d)=\\begin{cases} 1,&amp;n=1,\\\\ 0,&amp;n\\neq 1. \\end{cases} d∣n∑​μ(d)={1,0,​n=1,n=1.​ 上述式子描述的其实是 μ∗1=ϵ\\mu*1=\\epsilonμ∗1=ϵ，也就是说 μ\\muμ 是 111 的逆元。这是莫比乌斯函数最重要的性质，其引出了性质：∑d∣nμ(d)=[n=1]\\sum_{d\\mid n}\\mu(d)=[n=1]∑d∣n​μ(d)=[n=1]，我们可以将这个艾弗森括号转化为和式，这样更加方便计算。两者的转化称之为莫比乌斯反演。 莫比乌斯反演有以下结论： 若 g=f∗1g=f*1g=f∗1，则 f=g∗μf=g*\\muf=g∗μ。 若 g(n)=∑n∣df(d)g(n)=\\sum_{n\\mid d}f(d)g(n)=∑n∣d​f(d)，则 f(n)=∑n∣dμ(dn)g(d)f(n)=\\sum_{n\\mid d} \\mu\\left(\\dfrac d n\\right) g(d)f(n)=∑n∣d​μ(nd​)g(d)。这也被称为莫比乌斯变换，实际上就是把上面那一条给写出来。 由于 φ∗1=id⁡\\varphi * 1 = \\operatorname{id}φ∗1=id，因此 id⁡∗μ=φ\\operatorname{id} * \\mu =\\varphiid∗μ=φ。 一个常见的应用是，[gcd⁡(i,j)=1]=∑d∣gcd⁡(i,j)μ(d)[\\gcd(i,j)=1]=\\sum_{d\\mid \\gcd(i,j)}\\mu(d)[gcd(i,j)=1]=∑d∣gcd(i,j)​μ(d)。虽然看起来这像是废话，但这一步将 i,ji,ji,j 互质转化为了枚举 gcd⁡(i,j)\\gcd(i,j)gcd(i,j) 的约数 ddd。如果 i,ji,ji,j 同样需要枚举，那么枚举 ddd 并计算合法的 i,ji,ji,j 个数（当且仅当 d∣i,d∣jd\\mid i,d\\mid jd∣i,d∣j）即可。具体来说： ∑i=1n∑j=1m[gcd⁡(i,j)=1]=∑i=1n∑j=1m∑d∣gcd⁡(i,j)μ(d)=∑d=1min⁡(n,m)μ(d)∑i=1n∑j=1m[d∣i∧d∣j]=∑d=1min⁡(n,m)μ(d)⌊nd⌋⌊md⌋\\begin{aligned} \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [\\gcd(i, j) = 1] &amp; = \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m \\sum\\limits_{d\\mid \\gcd(i, j)} \\mu(d) \\\\ &amp; = \\sum\\limits_{d = 1} ^ {\\min(n, m)} \\mu(d) \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [d\\mid i\\land d\\mid j] \\\\ &amp; = \\sum\\limits_{d = 1} ^ {\\min(n, m)} \\mu(d) \\left\\lfloor \\dfrac n d \\right\\rfloor \\left\\lfloor \\dfrac m d \\right\\rfloor \\\\ \\end{aligned} i=1∑n​j=1∑m​[gcd(i,j)=1]​=i=1∑n​j=1∑m​d∣gcd(i,j)∑​μ(d)=d=1∑min(n,m)​μ(d)i=1∑n​j=1∑m​[d∣i∧d∣j]=d=1∑min(n,m)​μ(d)⌊dn​⌋⌊dm​⌋​ 就可以直接使用数论分块在 O(n+m)O(\\sqrt{n}+\\sqrt{m})O(n​+m​) 的时间内计算。 杜教筛 我们要求积性函数 fff 的前缀和，设 S(n)=∑i=1nfiS(n)=\\sum_{i=1}^{n}f_iS(n)=∑i=1n​fi​，再找一个积性函数 ggg，考虑它们的狄利克雷卷积的前缀和： ∑i=1n∑d∣if(d)g(id)=∑d=1ng(d)∑i=1⌊nd⌋f(i)=∑d=1ng(d)S(⌊nd⌋)\\begin{aligned} &amp;\\sum_{i=1}^{n} \\sum_{d\\mid i} f(d)g\\left(\\frac i d\\right)\\\\ =&amp;\\sum_{d=1}^n g(d)\\sum_{i=1}^{\\left\\lfloor\\frac n d\\right\\rfloor} f(i)\\\\ =&amp;\\sum_{d=1}^n g(d)S\\left(\\left\\lfloor\\frac n d\\right\\rfloor\\right) \\end{aligned} ==​i=1∑n​d∣i∑​f(d)g(di​)d=1∑n​g(d)i=1∑⌊dn​⌋​f(i)d=1∑n​g(d)S(⌊dn​⌋)​ 而我们有： g(1)S(n)=∑i=1ng(i)S(⌊ni⌋)−∑i=2ng(i)S(⌊ni⌋)=∑i=1n(f∗g)(i)−∑i=2ng(i)S(⌊ni⌋)\\begin{aligned} g(1)S(n)&amp;=\\sum \\limits _{i=1}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor) - \\sum \\limits _{i=2}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor)\\\\ &amp;=\\sum\\limits_{i=1}^{n}(f*g)(i) - \\sum \\limits _{i=2}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor) \\end{aligned} g(1)S(n)​=i=1∑n​g(i)S(⌊in​⌋)−i=2∑n​g(i)S(⌊in​⌋)=i=1∑n​(f∗g)(i)−i=2∑n​g(i)S(⌊in​⌋)​ 时间复杂度为 O(n34)O(n^{\\frac 3 4})O(n43​)，我们先线性筛出前 mmm 个的答案，那么 m=n23m=n^{\\frac 2 3}m=n32​ 时，时间复杂度为 O(n23)O(n^{\\frac 2 3})O(n32​)。 模板。有 μ∗1=ϵ,φ∗1=id⁡\\mu * 1 =\\epsilon,\\varphi * 1 =\\operatorname{id}μ∗1=ϵ,φ∗1=id，那么直接杜教筛即可。代码。 Min_25 筛 例题 巩固一些基础内容。 [CF1656H] Equal LCM Subsets Portal. 从质因数幂次的角度考虑，思考哪些是集合中不能要的地雷。 如果 aia_iai​ 不能留在集合中，那么它至少有一个质因子的幂次比 bbb 中其它所有数都大。也就是说，如果 gcd⁡aigcd⁡(ai,bj)&gt;1\\gcd \\cfrac{a_i}{\\gcd(a_i,b_j)}&gt;1gcdgcd(ai​,bj​)ai​​&gt;1，那么 aia_iai​ 就该被从集合中删除。相当于单点修改，查询全局 gcd⁡\\gcdgcd，这个过程只能进行 O(n+m)O(n+m)O(n+m) 轮，线段树直接维护，每轮修改是 O((n+m)log⁡(n+m))O((n+m)\\log (n + m))O((n+m)log(n+m)) 的，可以接受。代码。 * [Luogu P5435] 基于值域预处理的快速 GCD Portal. 模意义下的数论 尽管数论相关的题目似乎已经退出环境，但是本身还是比较有意思的。 线性同余方程组 可以使用 CRT 解决模数互质的情况，exCRT 解决模数不互质的情况。 {x≡a1(modm1)x≡a2(modm2)⋯x≡a3(modm3)\\begin{cases} x\\equiv a_1 \\pmod {m_1}\\\\ x\\equiv a_2 \\pmod {m_2}\\\\ \\cdots\\\\ x\\equiv a_3 \\pmod {m_3}\\\\ \\end{cases} ⎩⎨⎧​x≡a1​(modm1​)x≡a2​(modm2​)⋯x≡a3​(modm3​)​ 模数互质 设 M=∏i=1nmi,Mi=m÷miM=\\prod_{i=1}^{n}m_i,M_i=m\\div m_iM=∏i=1n​mi​,Mi​=m÷mi​，tit_iti​ 是线性同余方程 Miti≡1(modmi)M_it_i\\equiv 1 \\pmod{m_i}Mi​ti​≡1(modmi​) 的一个解，也就是说 tit_iti​ 是 MiM_iMi​ 模 mim_imi​ 的逆元（显然 Mi⊥miM_i \\perp m_iMi​⊥mi​ 当且仅当 mim_imi​ 两两互质），那么 x=∑i=1naiMiti+kMx=\\sum_{i=1}^{n}a_iM_it_i + kMx=∑i=1n​ai​Mi​ti​+kM，最小非负整数解需要求 ∑i=1naiMiti mod M\\sum_{i=1}^{n}a_iM_it_i\\bmod M∑i=1n​ai​Mi​ti​modM。 i64 CRT(void) &#123; // x === a[i] (mod m[i]) i64 ans = 0, x; for (int i = 1; i &lt;= n; ++i) &#123; M[i] = mm / m[i]; t[i] = inv(M[i], m[i]); ans = (ans + a[i] * M[i] * t[i]) % mm; &#125; return (ans % mm + mm) % mm; &#125; 模数不互质 考虑如何合并两个方程组。我们先假定一定可以合并，然后看看什么时候合并之后的解是 ∅\\varnothing∅。 这玩意儿等价于 a=k1m1+r1=k2m2+r2⟹k1m1−k2m2=r2−r1a=k_1m_1+r_1=k_2m_2+r_2 \\Longrightarrow k_1m_1-k_2m_2=r_2-r_1a=k1​m1​+r1​=k2​m2​+r2​⟹k1​m1​−k2​m2​=r2​−r1​。这个熟悉！二元一次不定方程！直接使用 exgcd 计算即可。 于是： 如果 gcd⁡(m1,m2)∣(r2−r1)\\gcd(m_1,m_2)\\mid (r_2-r_1)gcd(m1​,m2​)∣(r2​−r1​)，那么可以合并； 否则，exCRT 是无解的。 现在有引理：合并之后的模数是原来两个模数的 lcm。 具体来说，设当前合并的余数为 MMM，当前答案为 ansansans，那么任意一个 ans+Mxans+Mxans+Mx 都满足答案，我们需要找到一个最小的 xxx 使得 ans+Mx≡ai(modmi)ans+Mx\\equiv a_i\\pmod {m_i}ans+Mx≡ai​(modmi​)，可以使用扩展欧几里得来解决。 i64 exCRT(void) &#123; // x === A (mod B) i64 M = 1, ans = 0; // M 为当前合并的模数，ans 为当前答案 for (int i = 1; i &lt;= n; ++i) &#123; i64 b = B[i], x, y, c = (A[i] - ans + b) % b; i64 g = exgcd(M, b, x, y); // Mx + by = gcd(M, b) if (c % g != 0) return -1; x = (__int128)x * (c / g) % (b / g); ans = ans + M * x; M = b / g * M; ans %= M; &#125; return (ans % M + M) % M; &#125; 例题 巩固一些基础内容。 [CF1848E] Vika and Stone Skipping Portal. 如果跳 ggg 次，需要满足： 2x∏Xi=(2f−g+1)g2x\\prod X_i=(2f-g+1)g 2x∏Xi​=(2f−g+1)g 求的就是 2x∏Xi2x\\prod X_i2x∏Xi​ 的奇因数个数。提前将 xxx 除掉其 lowbit⁡\\operatorname{lowbit}lowbit 即可直接统计其因数。 直接维护即可。注意模数过小时逆元的爆炸问题。代码。 [NOI2018] 屠龙勇士 Portal. 由于我们选择的武器是固定的，所以实际上依然是 exCRT，只不过方程换成了 bx≡a(modp)bx\\equiv a\\pmod pbx≡a(modp)。这样是一样的，设当前合并的模数为 MMM，答案为 ansansans，那么下一个合并要满足 b(ans+Mx)≡a(modp)b(ans+Mx)\\equiv a\\pmod pb(ans+Mx)≡a(modp)，也就是 bMx−py=a−b×ansbMx-py=a-b\\times ansbMx−py=a−b×ans。 注意一个细节：解出来的解必须能将龙打掉，也就是能将血打成小于等于 000，否则即使满足同余方程也没用。记录一个能把血量打成负数的最小攻击次数，然后如果答案小于这个攻击次数，答案就加上还需要打的次数。代码。 [CF338D] GCD Table Portal. 首先如果有解，那么那个 xxx 应该满足 lcm⁡(a1,a2,⋯ ,ak)∣x\\operatorname{lcm}(a_1,a_2,\\cdots,a_k) \\mid xlcm(a1​,a2​,⋯,ak​)∣x。实际上 xxx 就应该等于 lcm⁡\\operatorname{lcm}lcm，因为如果增加倍数，yyy 的构造只会变得更加困难。 这样我们只需要满足 ai∣y+i−1a_i\\mid y+i-1ai​∣y+i−1，exCRT 求一下即可。代码。 线性代数 概念 高斯消元法 我们可以使用高斯消元以 O(n3)O(n^3)O(n3) 的时间求解方程组的解。具体来说就是一个一个地加减消元，转化成上三角形式，然后再代入即可。 线性基 LGV 引理 对于一个 DAG， 简单计算几何 数学杂项 连分数 群论入门 博弈论 博弈论主要研究一些有竞争或对抗性质的对象，在一定规则下/产生的各种行为。 对于公平组合游戏，我们通常会选择计算 SG 函数；对于非公平游戏，我们会选择推导一些性质。 概念 我们从 Nim 游戏开始研究。有 nnn 堆石子，每人每次可从任意一堆石子里取出正整数枚石子扔掉，谁不能动谁就输了。 我们将每个状态视作一个节点，那么博弈情况就可以刻画成一张有向图。不难发现，异或和为 000 时先手必败。 大部分的公平组合游戏（所有玩家都可以操作对方能操作的东西）都可以转换为有向图游戏，对于状态 xxx 和它的 kkk 个后继状态 y1,⋯ ,yky_1,\\cdots,y_ky1​,⋯,yk​，定义 SG 函数为： SG⁡(x)=mex⁡{SG⁡(y1),SG⁡(y2),…,SG⁡(yk)}\\operatorname{SG}(x)=\\operatorname{mex}\\{\\operatorname{SG}(y_1), \\operatorname{SG}(y_2), \\ldots, \\operatorname{SG}(y_k)\\} SG(x)=mex{SG(y1​),SG(y2​),…,SG(yk​)} 对于由 nnn 个有向图游戏组成的组合游戏，当且仅当 ⊕SG⁡(s)≠0\\oplus \\operatorname{SG}(s)\\ne 0⊕SG(s)=0 的时候，先手必胜，称之为 P 态。也就是说，SG⁡(x)=0\\operatorname{SG}(x)=0SG(x)=0 是必败态，称之为 N 态。 SG 定理：一个游戏的 SG 值是其所有子游戏的 SG 值的异或和，这可以说明 Nim 游戏结论的由来。 [HNOI2007] 分裂游戏。终止状态是所有豆子在 nnn 号瓶子，而每个豆子是独立的，直接暴力 DP 即可。代码。 Anti-SG 定理 如果不能动的人获胜，那么这个游戏叫做反常游戏。同样的，有判断必胜条件的 Anti-SG 定理： 如果游戏的 SG 值为 000，那么所有子游戏的 SG 值都不超过 111 时先手必胜（还是要异或值为 000）； 如果游戏的 SG 值不是 000，那么至少有一个子游戏的 SG 值超过 111 时先手必胜。其在决策过程中可以转化为上述情况。 模板。 经典博弈模型 博弈论中有一些特别经典的问题，我们来介绍一些。 威佐夫博弈 Portal.两堆石子，可以取一堆中的任意个，也可以在两堆中都取 xxx 个。 我们可以发现以下状态是先手必败的： (0,0)(0, 0)(0,0)， (1,2)(1, 2)(1,2)， (3,5)(3, 5)(3,5)， (4,7)(4, 7)(4,7)， (6,10)(6, 10)(6,10)， (8,13)(8, 13)(8,13)。 两者的差是自然数列，第一个数是之前所有新出现的数是之前出现数的 mex。可以证明结论是 a=⌊(b−a)×5+12⌋a=\\left\\lfloor (b-a)\\times \\cfrac{\\sqrt{5}+1}{2}\\right\\rfloora=⌊(b−a)×25​+1​⌋ 时先手必败。 公平组合 博弈论除了 SG 定理外，剩下的内容几乎全部基于 DP。有时候通过打表来寻找 SG 函数的规律也是一个不错的选择。 [CF768E] Game of Stones Portal. 可以考虑一个石堆会被取多少次，发现是从 111 开始依次取，然后就转成了正常的 Nim 游戏。代码。 [HNOI2014] 江南乐 Portal. 考虑枚举所有的 mmm，那么可以计算所有 nnn 的 SG 值。发现整除分块可以优化枚举 mmm 这个过程，因为 n/mn/mn/m 和 n/m+1n/m+1n/m+1 必有一个奇偶性不变。代码。 [AGC017D] Game on Tree Portal. 问题可以分解成若干棵子树，每棵子树都带着根节点，然后发现其 SG 值是子树的 SG 值加 111，直接处理即可。代码。 [AGC010D] Decrementing Portal. 如果初始 ∑ai−1\\sum a_i-1∑ai​−1 为奇数，那么先手可以一直维持这个状态（只需要操作偶数即可，情况不会改变）。 初始为偶数呢？如果局面下只有一个奇数，那么操作它就可以出现偶公因数，模拟即可。代码。 [AGC016F] Games on DAG Portal. 不难想到按照 SG 值进行分层转移，对于新增加的 SG 值更小的部分，一定要有边连向它们中的点来保证 SG 值的大小。转移的时候直接枚举子集 SSS，判断到达的 SG 值更小的集合 TTT，此时令 SG⁡(T)=k\\operatorname{SG}(T)=kSG(T)=k，设 fif_ifi​ 代表考虑集合 iii 中的点时 SG⁡(1)=SG⁡(2)\\operatorname{SG}(1)=\\operatorname{SG}(2)SG(1)=SG(2) 的方案数，转移： 对于 T→ST\\rightarrow ST→S 的边，每一个 TTT 中的元素都至少向 SSS 中连一条边； 对于 S→TS\\rightarrow TS→T 的边，随便连即可。 直接做即可。代码。 [ABC278G] Generalized Subtraction Game Portal. 如果可以先手第一步下在中间，然后我们就下模仿棋就行了。 否则，此时选择的区间长度固定，考虑计算 SG 函数，令 SG⁡i\\operatorname{SG}_iSGi​ 代表长度为 iii 的游戏的 SG 值。 对于 i&lt;li&lt;li&lt;l，有 SG⁡i=0\\operatorname{SG}_i=0SGi​=0，否则枚举选择的长度，有 SG⁡i=mex⁡j=0i−l{SG⁡jxor⁡SG⁡i−j−l}\\operatorname{SG}_i=\\operatorname{mex}_{j=0}^{i-l}\\{\\operatorname{SG}_{j} \\operatorname{xor} \\operatorname{SG}_{i-j-l}\\}SGi​=mexj=0i−l​{SGj​xorSGi−j−l​}。 输出方案时采用 set 维护连续段，不断选择后手必败的区间即可。 [CF1458E] Nim Shortcuts Portal. 正常情况下，黑色的是先手必败的： 但如果存在限制（黄色的也是必败态，那么情况会发生改变）： 可以发现必败态是若干条斜线，初始斜线是 x=yx=yx=y，特殊点会导致斜线向下和向右平移，发现这是个二维数点，扫描线维护使其向 xxx 轴方向平移的个数，树状数组维护 yyy 轴方向，用 x−yx-yx−y 的值判断是否在斜线上即可。代码。 非公平组合 比较有趣。 [AGC048D] Pocky Game Portal. 设 fl,rf_{l,r}fl,r​ 代表 ala_lal​ 至少为多少才能使得 [l,r][l,r][l,r] 先手必胜，gl,rg_{l,r}gl,r​ 代表 ara_rar​ 至少为多少才能使得 [l,r][l,r][l,r] 后手必胜。转移时由于最后是一个一个取，直接算即可，代码。 [CF1033G] Chip Game Portal. 模 a+ba+ba+b 意义下的局面是等价的，考虑枚举 a+ba+ba+b，将 vvv 排序，计算出合法的值域 [vi−1+1,vi][v_{i-1}+1,v_i][vi−1​+1,vi​]，而且应该减去存在两个 2a≤vi2a\\le v_i2a≤vi​ 的情况，随便算算就好了。代码。 题车","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"NOI 一轮复习 VII：数学 B","slug":"notes/NOI 复习/noi-1-7","date":"2023-12-18T00:00:00.000Z","updated":"2024-03-26T00:00:00.000Z","comments":true,"path":"1bd36e32/","link":"","permalink":"https://james1badcreeper.github.io/1bd36e32/","excerpt":"本文是 NOI 一轮复习的第七篇，主要介绍了各类多项式、集合幂级数、生成函数和特殊数列的相关内容。","text":"本文是 NOI 一轮复习的第七篇，主要介绍了各类多项式、集合幂级数、生成函数和特殊数列的相关内容。 青蛙大队踏碎了此处的荒原。本文将不会在联合省选 2024 前更新。之后可能会更新集合幂级数和为了方便理解集合幂级数而写的 FFT。 基础概念 一些基本知识。 极限 这里不介绍极限的严谨定义。极限可以直接进行四则运算。根据极限的定义可以直接定义函数的极限。 我们定义自然底数 e=lim⁡n→∞(1+1n)n=lim⁡n→∞(1+1n)n+1e=\\lim\\limits_{n\\to \\infty} (1+\\frac 1 n)^n=\\lim\\limits_{n\\to \\infty} (1+\\frac 1 n)^{n+1}e=n→∞lim​(1+n1​)n=n→∞lim​(1+n1​)n+1。 导数与微分 在 x0x_0x0​ 上的导数是 x→x0x\\to x_0x→x0​ 的极限。 设 f(x),g(x)f(x),g(x)f(x),g(x) 均在 xxx 处可导，那么： (f(x)+g(x))′=f′(x)+g′(x)(f(x)+g(x))&#x27;=f&#x27;(x)+g&#x27;(x)(f(x)+g(x))′=f′(x)+g′(x)； (f(x)g(x))′=f′(x)g(x)+f(x)g′(x)(f(x)g(x))&#x27;=f&#x27;(x)g(x)+f(x)g&#x27;(x)(f(x)g(x))′=f′(x)g(x)+f(x)g′(x)； (f(x)g(x))′=f′(x)g(x)−f(x)g′(x)g2(x)\\left(\\frac{f(x)}{g(x)}\\right)&#x27;=\\frac{f&#x27;(x)g(x)-f(x)g&#x27;(x)}{g^2(x)}(g(x)f(x)​)′=g2(x)f′(x)g(x)−f(x)g′(x)​； f(g(x))′=f′(g(x))g′(x)f(g(x))&#x27;=f&#x27;(g(x))g&#x27;(x)f(g(x))′=f′(g(x))g′(x)。 积分 （待补充） 生成函数 生成函数是一种形式幂级数（它不是函数，xxx 不是自变量而是自由元），其每一项的系数可以提供关于这个序列的信息。这是个很有用的东西，是用于刻画数列的组合工具，能够将很多复杂的组合问题赋以简洁的代数形式，考场上也会出现不需要多项式算法只用生成函数就能解决的问题。 一般地，生成函数可以表示为： F(x)=∑i=0∞aiki(x)F(x)=\\sum_{i=0}^{\\infty} a_i k_i(x) F(x)=i=0∑∞​ai​ki​(x) 其中 ki(x)k_i(x)ki​(x) 被称之为核函数，对于普通的生成函数，ki(x)=xik_i(x)=x^iki​(x)=xi。注意这个 aaa 既可以是有穷序列，也可以是无穷序列。 组合对象 组合对象指要计数的对象，组合对象组成的集合叫做组合类。 将 {(a1,a2)∣a1∈A1,a2∈A2}\\{(a_1,a_2)\\mid a_1\\in A_1,a_2\\in A_2\\}{(a1​,a2​)∣a1​∈A1​,a2​∈A2​} 称为 A1,A2A_1,A_2A1​,A2​ 的笛卡尔积，记作 A1×A2A_1\\times A_2A1​×A2​。 普通生成函数（OGF） 普通生成函数的核函数为 kn(x)=xnk_n(x)=x^nkn​(x)=xn。实际上，普通生成函数的系数就是序列 aaa 的通项公式。 对于 OGF F(x)F(x)F(x)，xxx 是自由元，因此没有实际意义，只是一个占位符，xix_ixi​ 用来代表它是第 iii 个占位符，F[i]F[i]F[i] 可以表示 F(x)F(x)F(x) 的第 iii 次项系数，简称 iii 次项，000 次项称为常数项。 为了方便提取其中某一项的系数，有 [xi]F(x)=F[i][x^i]F(x)=F[i][xi]F(x)=F[i]。 生成函数中的求和符号并不是无穷项求和，它只是一个记号，代表的是序列。两个生成函数 F(x),G(x)F(x),G(x)F(x),G(x) 相等当且仅当 ∀i∈N,F[i]=G[i]\\forall i\\in\\mathbb{N}, F[i]=G[i]∀i∈N,F[i]=G[i]。 对于序列 aaa，如果从某一项开始它后面都是 000，那么可以认为它是一个有穷序列。如果它是有穷的，那么它的生成函数是一个有穷幂级数，否则是无穷幂级数。 考虑两个序列 a,ba,ba,b 的普通生成函数F(x),G(x)F(x),G(x)F(x),G(x)，那么它们的加减法和乘法运算是跟多项式一样的。因此对于生成函数 F(x),G(x)F(x),G(x)F(x),G(x)，有： F(x)±G(x)=∑n(an±bn)xn,F(x)G(x)=∑nxn∑i=0naibn−i=∑i∑jF[i]G[j]xijF(x)\\pm G(x)=\\sum_{n}(a_n\\pm b_n)x^n,\\\\ \\begin{aligned} F(x)G(x)&amp;=\\sum_{n}x^n\\sum_{i=0}^n a_i b_{n-i}\\\\ &amp;=\\sum_{i}\\sum_j F[i]G[j]x^{ij} \\end{aligned} F(x)±G(x)=n∑​(an​±bn​)xn,F(x)G(x)​=n∑​xni=0∑n​ai​bn−i​=i∑​j∑​F[i]G[j]xij​ 因此 F(x)±G(x)F(x)\\pm G(x)F(x)±G(x) 是序列 &lt;an±bn&gt;\\left&lt;a_n\\pm b_n\\right&gt;⟨an​±bn​⟩ 的普通生成函数，F(x)G(x)F(x)G(x)F(x)G(x) 是 序列&lt;∑i=0naibn−i&gt;\\left&lt;\\sum_{i=0}^n a_i b_{n-i}\\right&gt;⟨∑i=0n​ai​bn−i​⟩ 的普通生成函数。 可以发现，加法代表不相交集合的并，乘法代表笛卡尔积。 对于幂次运算，F(x)F(x)F(x) 的 nnn 次幂记作 Fn(x)F^n(x)Fn(x)，特别地，F0(x)=1F^0(x)=1F0(x)=1。 对 F(x)F(x)F(x) 的 nnn 次幂提取 mmm 次项系数，可以记 Fn[m]F^n[m]Fn[m] 为： Fn[m]=[xm]Fn(x)F^n[m]=[x^m]F^n(x) Fn[m]=[xm]Fn(x) 形式幂级数的生成函数不一定好算，有时会将其转换为封闭形式。 比如说 &lt;1,1,⋯ &gt;\\left&lt;1,1,\\cdots\\right&gt;⟨1,1,⋯⟩ 的普通生成函数为 F(x)=∑n≥0xnF(x)=\\sum_{n\\ge 0}x^nF(x)=∑n≥0​xn，发现 F(x)x+1=F(x)F(x)x+1=F(x)F(x)x+1=F(x)，因此得到 F(x)=11−xF(x)=\\cfrac{1}{1-x}F(x)=1−x1​，这就是生成函数的封闭形式。 比如说，F(x)=∑n=0∞n=11−xF(x)=\\sum_{n=0}^{\\infty} n=\\cfrac 1{1-x}F(x)=∑n=0∞​n=1−x1​。作为练习，可以看一下接下来这几个题： 010203（二项式定理）04（前缀和与差分） 写出 a=&lt;0,1,1,⋯ &gt;a=\\left&lt;0,1,1,\\cdots \\right&gt;a=⟨0,1,1,⋯⟩ 的生成函数。 有 F(x)=∑n≥1xnF(x)=\\sum_{n\\ge 1}x^nF(x)=∑n≥1​xn，因此 F(x)x+x=F(x)⇒F(x)=x1−xF(x)x+x=F(x)\\Rightarrow F(x)=\\cfrac{x}{1-x}F(x)x+x=F(x)⇒F(x)=1−xx​。 写出 a=&lt;1,0,1,0,1,0⋯ &gt;a=\\left&lt;1,0,1,0,1,0\\cdots \\right&gt;a=⟨1,0,1,0,1,0⋯⟩ 的生成函数。 有 F(x)=∑n≥0x2n=∑n≥0(x2)nF(x)=\\sum_{n\\ge 0} x^{2n}=\\sum_{n\\ge 0} (x^{2})^nF(x)=∑n≥0​x2n=∑n≥0​(x2)n，因此 F(x)x2+1=F(x)⇒F(x)=11−x2F(x)x^2+1=F(x)\\Rightarrow F(x) = \\cfrac{1}{1-x^2}F(x)x2+1=F(x)⇒F(x)=1−x21​。 写出序列 an=(mn)a_n=\\dbinom{m}{n}an​=(nm​) 的生成函数（mmm 是常数，n≥0n\\ge 0n≥0）。 F(x)=∑n≥0(mn)xn=(1+x)m\\begin{aligned} F(x)&amp;=\\sum_{n\\ge 0}\\binom{m}{n}x^n\\\\ &amp;=(1+x)^m \\end{aligned} F(x)​=n≥0∑​(nm​)xn=(1+x)m​ 写出 a=&lt;1,2,3,4,5,6⋯ &gt;a=\\left&lt;1,2,3,4,5,6\\cdots \\right&gt;a=⟨1,2,3,4,5,6⋯⟩ 的生成函数。 F(x)=∑n≥0nxn−1=∑n≥0(xn)′=(11−x)′=1(1−x)2\\begin{aligned} F(x)&amp;=\\sum_{n\\ge 0}nx^{n-1}\\\\ &amp;=\\sum_{n\\ge 0} (x^n)&#x27;\\\\ &amp;=\\left(\\frac{1}{1-x}\\right)&#x27;\\\\ &amp;=\\frac{1}{(1-x)^2} \\end{aligned} F(x)​=n≥0∑​nxn−1=n≥0∑​(xn)′=(1−x1​)′=(1−x)21​​ 可以发现求一个序列的前缀和的生成函数只需要乘上 11−x\\cfrac{1}{1-x}1−x1​，求差分只需要乘上 1−x1-x1−x。 实际上我们有： 1(1−x)n+1=∑i(n+in)xi\\frac{1}{(1-x)^{n+1}}=\\sum_{i}\\binom{n+i}{n}x^i (1−x)n+11​=i∑​(nn+i​)xi 为什么呢？当 n=1n=1n=1 时，原式成立；当 n&gt;1n&gt;1n&gt;1 时，有： 1(1−x)n+1=11−x1(1−x)n=∑ixi∑i(n+i−1n−1)xi=∑ixi∑j=0i(n+j−1j)=∑i(n+in)xi\\begin{aligned} \\frac{1}{(1-x)^{n+1}}&amp;=\\frac{1}{1-x}\\frac{1}{(1-x)^{n}}\\\\ &amp;=\\sum_{i}x^i\\sum_{i}\\binom{n+i-1}{n-1}x^i\\\\ &amp;=\\sum_{i}x^i\\sum_{j=0}^i\\binom{n+j-1}{j}\\\\ &amp;=\\sum_{i}\\binom{n+i}{n}x^i \\end{aligned} (1−x)n+11​​=1−x1​(1−x)n1​=i∑​xii∑​(n−1n+i−1​)xi=i∑​xij=0∑i​(jn+j−1​)=i∑​(nn+i​)xi​ 它还可以说明一个问题：如果 f(x)f(x)f(x) 是关于 xxx 的 kkk 次多项式，那么 f(x)f(x)f(x) 的差分是 k−1k-1k−1 次多项式，前缀和是 k+1k+1k+1 次多项式。 拯救世界。对于一种召唤方式，设 ana_nan​ 代表这种召唤方式选择 nnn 个的方案数，求出序列 aaa 的生成函数。那么两种召唤方式一共有 nnn 块石头的选择方式就是这两个生成函数的卷积 FFF 的第 nnn 项系数。 一共有 101010 个限制条件，依次写出它们的生成函数（封闭形式），然后把它们都乘起来（求的是笛卡尔积）得到 1(1−x)5\\cfrac{1}{(1-x)^5}(1−x)51​。转化成形式幂级数就是 ∑i(i+44)xi\\displaystyle\\sum_{i}\\binom{i+4}{4}x^ii∑​(4i+4​)xi。因此答案是 (n+44)\\dbinom{n+4}{4}(4n+4​)。 指数生成函数（EGF） 我们通常用以下方式表示指数生成函数： F^(x)=∑i=0∞aii!xi\\hat F(x)=\\sum_{i=0}^{\\infty} \\frac{a_i}{i!} x^i F^(x)=i=0∑∞​i!ai​​xi 就是多除了个 i!i!i!。 OGF 只能解决无序计数问题，对于有序计数，同一个组合类中的东西是不区分的，因此通过除掉一个 i!i!i! 来解决。最后再乘上 n!n!n! 就是第 nnn 项的答案。 特殊数列 我们介绍一些特殊数列。 斐波那契数列 我们有 f0=1,f1=1,fi=fi−1+fi−2f_0=1,f_1=1,f_i=f_{i-1}+f_{i-2}f0​=1,f1​=1,fi​=fi−1​+fi−2​。设它的 OGF 是 F(x)F(x)F(x)，那么： F(x)=xF(x)+x2F(x)+x+0 ⟺ F(x)=x1−x−x2\\begin{aligned} &amp; F(x)=xF(x)+x^2F(x)+x+0\\\\ \\iff &amp; F(x)=\\frac {x}{1-x-x^2} \\end{aligned} ⟺​F(x)=xF(x)+x2F(x)+x+0F(x)=1−x−x2x​​ 求出它的封闭形式，可以采用待定系数法，进而化为： F(n)=∑n=0∞(1+52)n−(1−52)n5xnF(n) = \\sum_{n=0}^{\\infty}\\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}} x^n F(n)=n=0∑∞​5​(21+5​​)n−(21−5​​)n​xn 整数 lqp 拆分。答案是 0∼i0\\sim i0∼i 个 FFF 的前缀和，那么答案的生成函数为 G(x)=∑i=0∞Fi(x)\\displaystyle G(x)=\\sum_{i=0}^{\\infty}F^i(x)G(x)=i=0∑∞​Fi(x)。 也就是： G(x)=11−F(x)=1−x−x21−2x−x2=∑x122[(1+2)x−(1−2)x]\\begin{aligned} G(x)&amp;=\\frac 1 {1 - F(x)}\\\\ &amp;= \\frac {1-x-x^2}{1-2x - x^2}\\\\ &amp;= \\sum_x \\frac{1}{2\\sqrt{2}}[(1+\\sqrt 2)^x-(1-\\sqrt 2 )^x] \\end{aligned} G(x)​=1−F(x)1​=1−2x−x21−x−x2​=x∑​22​1​[(1+2​)x−(1−2​)x]​ 直接计算即可，代码。 卡特兰数 第二类斯特林数 第二类斯特林数使用 {nk}\\begin{Bmatrix}n\\\\ k\\end{Bmatrix}{nk​} 或者 S2(n,k)S_2(n,k)S2​(n,k) 来表示，意义是将 1∼n1\\sim n1∼n 的整数划分为 kkk 个不交的无标号非空集合的方案数。显然 {n0}=[n=0]\\begin{Bmatrix}n\\\\ 0\\end{Bmatrix}=[n=0]{n0​}=[n=0]。可以采用暴力递推法求解： {nk}={n−1k−1}+k{n−1k}\\begin{Bmatrix}n\\\\ k\\end{Bmatrix}=\\begin{Bmatrix}n-1\\\\ k-1\\end{Bmatrix}+k\\begin{Bmatrix}n-1\\\\ k\\end{Bmatrix} {nk​}={n−1k−1​}+k{n−1k​} 什么意思呢？将第 nnn 个元素放入一个新的集合有 {n−1k−1}\\begin{Bmatrix}n-1\\\\ k-1\\end{Bmatrix}{n−1k−1​} 种方案，将第 nnn 个元素插入原来任意一个集合有 k{n−1k}k\\begin{Bmatrix}n-1\\\\ k\\end{Bmatrix}k{n−1k​} 的方案，根据加法原理可得递推式。 可能需要记住一些第二类斯特林数（就比如说，一个出现 1,7,6,11,7,6,11,7,6,1 的问题就很大能与第二类斯特林数有关）： 1 1 1 1 3 1 1 7 6 1 1 15 25 10 1 1 31 90 65 15 1 1 63 301 350 140 21 1 1 127 966 1701 1050 266 28 1 1 255 3025 7770 6951 2646 462 36 1 1 511 9330 34105 42525 22827 5880 750 45 1 第二类斯特林数的通项公式： {nm}=∑i=0m(−1)m−iini!(m−i)!\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\sum\\limits_{i=0}^m\\frac{(-1)^{m-i}i^n}{i!(m-i)!} {nm​}=i=0∑m​i!(m−i)!(−1)m−iin​ 不难用二项式反演去证明，令 GiG_iGi​ 为 nnn 个数放入 iii 个允许空集的有标号集合，FiF_iFi​ 为不允许空集，Fmm!\\frac{F_m}{m!}m!Fm​​ 即为答案。 第一类斯特林数 称之为斯特林轮换数，记作 [nk],S1(n,k)\\begin{bmatrix}n\\\\ k\\end{bmatrix},S_1(n,k)[nk​],S1​(n,k)，表示将 1∼n1\\sim n1∼n 的整数划分为 kkk 个互不区分的非空轮换方案数。 一个轮换是指一个首尾相接的环形排列，两个可以通过旋转而互相得到的轮换是等价的。 第一类斯特林数的递推式： [nk]=[n−1k−1]+(n−1)[n−1k]\\begin{bmatrix}n\\\\ k\\end{bmatrix}=\\begin{bmatrix}n-1\\\\ k-1\\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\\\ k\\end{bmatrix} [nk​]=[n−1k−1​]+(n−1)[n−1k​] 前者是将 nnn 放在一个单独的轮换中，后者是将其放入一个现有的轮换中。 这个玩意没有实用的通项公式。 题车 刷基础 1 一些基础题。 [CF715E] Complete the Permutations Portal. 边可以分为四种类型，a→b,a→0,0→b,0→0a\\rightarrow b,a\\rightarrow 0,0\\rightarrow b,0\\rightarrow 0a→b,a→0,0→b,0→0。 记后三种边的数量为 n1,n2,mn_1,n_2,mn1​,n2​,m。a→0a\\rightarrow 0a→0 边有两种选择，融进 0→00\\rightarrow 00→0，或者自我合并。方案数是： F1[k]=∑i=kn1(n1i)[ik](n1+m−i−1)n1−i‾F_1[k]=\\sum\\limits_{i=k}^{n_1}\\dbinom{n_1}{i}\\begin{bmatrix}i\\\\k\\end{bmatrix}(n_1+m-i-1)^{\\underline{n_1-i}} F1​[k]=i=k∑n1​​(in1​​)[ik​](n1​+m−i−1)n1​−i​ F3F_3F3​ 直接算第一类斯特林数，然后可以全排列 mmm。暴力卷即可。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"NOI 一轮复习 VI：字符串","slug":"notes/NOI 复习/noi-1-6","date":"2023-12-17T00:00:00.000Z","updated":"2024-01-08T00:00:00.000Z","comments":true,"path":"b3047747/","link":"","permalink":"https://james1badcreeper.github.io/b3047747/","excerpt":"本文是 NOI 一轮复习的第六篇，包括各类字符串算法。","text":"本文是 NOI 一轮复习的第六篇，包括各类字符串算法。 前置知识 我们记字符集为 Σ\\SigmaΣ，字符串是由若干字符集中的元素构成的序列。 字符串哈希 即序列哈希，快速比较两个序列的相等情况。一般来讲我们采用 bbb 进制方式的哈希，即 f(s)=∑i=1lsi×bl−if(s)=\\sum_{i=1}^{l}s_i\\times b^{l-i}f(s)=∑i=1l​si​×bl−i。 inline u64 q(u64 *f, int l, int r) &#123; return f[r] - f[l - 1] * p[r - l + 1]; &#125; 字典树 本质上是一种自动机结构，不再赘述。 Z 函数 例题 字符串周期结构 定义 ppp 是串 SSS 的周期，当且仅当 p≤∣S∣p\\le |S|p≤∣S∣ 且 Si=Si+pS_i=S_{i+p}Si​=Si+p​，如果满足 p∣∣S∣p\\mid |S|p∣∣S∣ 则称 ppp 是 SSS 的整周期。 称 TTT 是串 SSS 的 Border，当且仅当 TTT 是 SSS 的前缀且 TTT 是 SSS 的后缀，但是 T≠ST\\ne ST=S。 单串 Border 结构 首先，ppp 是 SSS 的周期，当且仅当 ∣S∣−p|S|-p∣S∣−p 是 SSS 的 前缀 Border 结构 KMP 算法 Aho-Corasick 自动机 例题 字符串回文结构 Manacher 回文自动机 例题 字符串子串结构 通常来说，刻画 SSS 的子串结构的方式有：后缀数组、后缀自动机、后缀树。 神风敢死队炸毁了此处的内容。本部分将在 NOI2024 前进行完善。 后缀数组 SA 例题 后缀自动机 SAM 是一个接受字符串 SSS 的所有后缀的最小 DFA。其满足从 TTT 到任意状态的路径与 sss 的所有子串一一对应，TTT 到终止状态集合 FFF 的路径与 sss 的后缀一一对应。SAM 的有向无环转移图称为 DAWG。 下图的左侧是 abcbc 的一个 SAM： 我们先给出一些定义： endpos⁡(t)\\operatorname{endpos}(t)endpos(t) 代表 sss 中所有 ttt 出现的结束位置的集合。 引理 111：字符串 sss 的两个非空子串 uuu 和 w(∣u∣≤∣w∣)w(|u|\\le |w|)w(∣u∣≤∣w∣) 的 endpos⁡\\operatorname{endpos}endpos 相同，当且仅当 uuu 在 sss 中的每次出现都是以 www 的后缀形式出现的。比较显然。引理 222：如果 uuu 是 www 的后缀，那么 endpos⁡(w)⊆endpos⁡(u)\\operatorname{endpos}(w)\\subseteq \\operatorname{endpos}(u)endpos(w)⊆endpos(u)，否则 endpos⁡(w)∩endpos⁡(u)=∅\\operatorname{endpos}(w)\\cap\\operatorname{endpos}(u)=\\varnothingendpos(w)∩endpos(u)=∅。也比较显然。 如果 endpos⁡\\operatorname{endpos}endpos 集合相等，那么这两个子串可以被成为等价类。SAM 中的每个状态对应一个等价类。 引理 333：对于一个 ppp，其对应的子串集合中，较短者一定是较长者的后缀。也比较显然。 substr⁡(p)\\operatorname{substr}(p)substr(p) 代表状态 ppp 可以代表的所有子串集合， longest⁡(p)\\operatorname{longest}(p)longest(p) 代表状态 ppp 所对应的最长子串； shortest⁡(p)\\operatorname{shortest}(p)shortest(p) 代表状态 ppp 所对应的最短子串； len⁡(p)=∣longest⁡(p)∣\\operatorname{len}(p)=|\\operatorname{longest}(p)|len(p)=∣longest(p)∣。 定义状态 ppp 的后继状态 link⁡(p)\\operatorname{link}(p)link(p) 指向 longest⁡(p)\\operatorname{longest}(p)longest(p) 最长的一个后缀 www，满足 w∉substr⁡(p)w\\not\\in \\operatorname{substr}(p)w∈substr(p)。所有的后缀链接形成一棵以 TTT 为根的有根树，另外有 ∣shortest⁡(p)∣=len⁡(link⁡(p))+1|\\operatorname{shortest}(p)|=\\operatorname{len}(\\operatorname{link}(p))+1∣shortest(p)∣=len(link(p))+1。 之前给出的图的右侧是一棵后缀链接构成的树。可以发现，如果按照 endpos⁡\\operatorname{endpos}endpos 集合构造树，那么构造出来的树是相同的。 模板，求出 endpos 大小和 len 即可，构建 SAM 的代码如下： #define cpy(x, y, s) memcpy(x, y, sizeof(x[0]) * (s)) int cnt = 1, las = 1, son[N][S], len[N], fa[N]; void ins(char s) &#123; int it = s - 'a', cur = ++cnt, p = las; len[cur] = len[p] + 1; las = cur; while (!son[p][it]) son[p][it] = cur, p = fa[p]; if (!p) return fa[cur] = 1, void(); int q = son[p][it]; if (len[q] == len[p] + 1) return fa[cur] = q, void(); int cl = ++cnt; cpy(son[cl], son[q], S); len[cl] = len[p] + 1, fa[cl] = fa[q], fa[q] = fa[cur] = cl; while (son[p][it] == q) son[p][it] = cl, p = fa[p]; &#125; 后缀树 广义 SAM SAM 例题 使用 SAM 解决更为方便。 [SDOI2016] 生成魔咒 Portal. SAM 上新增一个状态答案会增加 len⁡−(minlen⁡−1)=len⁡−falen⁡\\operatorname{len}-(\\operatorname{minlen}-1)=\\operatorname{len}-\\operatorname{falen}len−(minlen−1)=len−falen，开个 map 跑 SAM 即可。代码。 [CF235C] Cyclical Quest Portal. 将字符串破环成链，在 SAM 上跑字符串匹配，失配了就跳 link⁡\\operatorname{link}link 即可，代码。 杂技 对称压缩 SAM 无相幽闭蒙蔽了你的双眼。本部分将不会在 NOI2024 前更新。 Lyndon 理论 题车","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"考试总结","slug":"default/记录/test","date":"2023-12-14T00:00:00.000Z","updated":"2023-12-23T00:00:00.000Z","comments":true,"path":"eb162b3e/","link":"","permalink":"https://james1badcreeper.github.io/eb162b3e/","excerpt":"没写过这个东西，所以人菜！！","text":"没写过这个东西，所以人菜！！ 2023 12/14 模拟赛：没睡醒，什么都不会。关键问题是水平不够，成功倒数。 12/15 模拟赛：不会数数，不会小学游戏。鉴定为数学 A 做少了导致的。 12/16 ABC：不会 F，没看 G，G 做过原题。 12/16 Div2：D 只会卡不过去的单 log⁡\\loglog，有点搞笑。 12/22 模拟赛：没有智慧，杂题还是需要做。 12/23 ABC：不会 F。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"比赛记录","slug":"算法竞赛/比赛记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"2023/12/11(#8)：旭日再起","slug":"default/记录/2023/12/2023-12-11","date":"2023-12-11T00:00:00.000Z","updated":"2023-12-11T00:00:00.000Z","comments":true,"path":"59083b9d/","link":"","permalink":"https://james1badcreeper.github.io/59083b9d/","excerpt":"We, won’t go down. Never.","text":"We, won’t go down. Never. Rising Sun. [ARC070D] HonestOrUnkind Portal. 我们需要找到一个全场身份最高的玩家来带给我们答案。如果坏人比好人多，那么好人无法成为全场身份最高的玩家，就完蛋了。 注意到坏人一定会说好人是坏人，坏人是好人。那么直接维护一个栈，认为最上面的那个是好人，这样那个好人一定会留到最后。代码。 这么摆？？？？","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/08(#7)：流转在身边的幸运","slug":"default/记录/2023/12/2023-12-08","date":"2023-12-08T00:00:00.000Z","updated":"2023-12-08T00:00:00.000Z","comments":true,"path":"6826c041/","link":"","permalink":"https://james1badcreeper.github.io/6826c041/","excerpt":"，启动！！","text":"，启动！！ どこまでも一切将生生不息今日もどこかであなたが也不知道今天的你在何处今を生きるあなたがただ此刻的你身边是谁的心愿小さな幸せを流转在身边的小幸运見つけられますように祝愿你都能一一找寻到 随便写一点。 [CF547D] Mike and Fish Portal. 对于每个点，将横纵坐标之间连一条边。那么转化为对每条边定向使得每个点的入度和出度最多相差 111。所有奇数点可以向 000 连边，欧拉回路染色即可（因为只有偶环）。 [ARC104D] Multiset Mean Portal. 考虑一个转化：将所有数减去 xxx。然后利用背包预处理，答案便可以直接求出。 [Ynoi2078]《A Path Towards Autonomous Machine Intelligence》阅读报告（更新中…） Portal. 维护一棵长度为 qqq 的线段树，然后每个节点开一个 vector 代表连续段上的数的操作运算符，修改时直接将二进制分组结构扔到线段树上然后合并，查询时每个节点二分一次即可。 [ARC104F] Visibility Sequence Portal. 考虑令 fi,j,kf_{i,j,k}fi,j,k​ 代表区间 [l,r][l,r][l,r] 内高度都不超过 kkk 的答案，而 kkk 可以表示为 ap−va_p-vap​−v，然后枚举最值点，直接记忆化搜索就行。 ED 有些东西还是要学习的。 我怎么这么摆。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/07(#6)：时间凝聚为永恒","slug":"default/记录/2023/12/2023-12-07","date":"2023-12-07T00:00:00.000Z","updated":"2023-12-07T00:00:00.000Z","comments":true,"path":"dffcb9b5/","link":"","permalink":"https://james1badcreeper.github.io/dffcb9b5/","excerpt":"有更重要的事情，今天先随便写几个题。","text":"有更重要的事情，今天先随便写几个题。 不用跋涉到天涯 我们为你来回答 也许答案会让你感到惊讶! 遥看绚丽的朝霞 回忆从前的伤疤 也许答案就藏在你的脚下！ [APC001F] XOR Tree Portal. 考虑将边权转化为点权，可以将一个点周围的边的边权都异或在点上。当所有点的点权和为 000 时答案便满足，直接状压 DP 即可。代码。 [AT_code_festival_2017_qualb_f] Largest Smallest Cyclic Shift Portal. 设 S1,⋯ ,SnS_1,\\cdots,S_nS1​,⋯,Sn​ 组成 TTT，满足 S1&lt;S2&lt;⋯&lt;SnS_1&lt;S_2&lt;\\cdots&lt;S_nS1​&lt;S2​&lt;⋯&lt;Sn​，发现应该是将最小的字典序字符串和最大的字典序字符串拼起来得到一个更优秀的字符串。 [CF1188D] Make Equal Portal. 记 bi=max⁡a−aib_i=\\max a - a_ibi​=maxa−ai​，那么要求： ∑i=1npopcount⁡(x+bi)\\sum_{i=1}^n \\operatorname{popcount}(x+b_i) i=1∑n​popcount(x+bi​) 考虑二进制下的第 kkk 位： xxx 的第 kkk 位是否填 111； bib_ibi​ 的第 kkk 位是否填 111; 第 k−1k-1k−1 位是否进位。 第 k−1k-1k−1 位的进位情况和 bi mod 2kb_i\\bmod 2^kbi​mod2k 有关。我们按照这个东西排序，能进位的就是 bbb 的一段前缀。 设 fi,jf_{i,j}fi,j​ 代表有 jjj 个数进位到第 iii 位的答案。考虑 xxx 当前这一位填 111 还是填 000，贡献随便算一下就行了。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/06(#5)：收集着破碎的时间碎片","slug":"default/记录/2023/12/2023-12-06","date":"2023-12-04T00:00:00.000Z","updated":"2023-12-06T00:00:00.000Z","comments":true,"path":"4b85c822/","link":"","permalink":"https://james1badcreeper.github.io/4b85c822/","excerpt":"答案是，什么时候？","text":"答案是，什么时候？ 夜に咲く温度と灯るまで 当夜晚绽放的温度被点燃之前 呼吸ひとつ生きる生きる 深吸一口气 想着活下去 優しい日々の横で泣かぬように 都是为了不在美好的日子里 在你身旁哭泣啊 愛をひとつまたねまたね 让我们再相爱一次吧 [AGC052D] Equal LIS Portal. 设 LIS 长度为 mmm。如果 mmm 是偶数，那么对于 fi≤m2f_i\\le \\frac m 2fi​≤2m​。划分到一组，剩下的划分到另一组即可。 mmm 为奇数时，我们只需要找到两个长度为 ⌈m2⌉\\left\\lceil \\frac m 2 \\right\\rceil⌈2m​⌉ 的 IS 即可，构造时同样可以直接划分。具体来说，如果存在比 mmm 多的可以成为 LIS 的点，那么直接划分，当 LIS 试图变得比 ⌈m2⌉\\left\\lceil \\frac m 2 \\right\\rceil⌈2m​⌉ 大时直接扔到另一个序列即可。代码。 [AGC055C] Weird LIS Portal. 设 ppp 的 LIS 长度为 KKK，那么应该有 ai∈[K,K−1]a_i\\in [K,K-1]ai​∈[K,K−1]。我们将 ai←ai−Ka_i\\leftarrow a_i-Kai​←ai​−K。 排列上的数可以划分成四种类型： 让红黑匹配尽可能地先出现，那么 fi,kf_{i,k}fi,k​ 代表以颜色 iii 为结尾，当前 K=kK=kK=k，直接做即可。代码。 [CF895C] Square Subsets Portal. 只会做水题。 其实相当于是在求异或和为 000 的数的个数，直接线性基，然后答案是线性基内数的个数。代码。 [CF1517F] Reunion Portal. 设一种方案 SSS 的半径为 f(S)f(S)f(S)，那么答案是 ∑r=1n∑S[f(S)≥r]\\sum_{r=1}^{n}\\sum_{S}[f(S)\\ge r]∑r=1n​∑S​[f(S)≥r]。实际上我们只需要对于每个 rrr 分别计算即可。 设 fi,jf_{i,j}fi,j​ 代表 iii 的子树距离 iii 最近的黑点距离为 jjj 的方案数，记满足 j=r+1j=r+1j=r+1 的为预备点，gi,jg_{i,j}gi,j​ 表示 iii 子树内最深预备点与 iii 距离为 jjj 时的方案数。 值得注意的是，若子树内已经存在预备点，那么没有必要再考虑距离 iii 最近的黑点与 iii 的距离。不存在时，这东西才需要被记录。 考虑使用树形背包的方式合并： 合并 fx,i,fy,jf_{x,i},f_{y,j}fx,i​,fy,j​，可以转移到 fx,min⁡{i,j+1}f_{x,\\min \\{i,j+1\\}}fx,min{i,j+1}​； 合并 gx,i,gy,jg_{x,i},g_{y,j}gx,i​,gy,j​，可以转移到 gx,max⁡{j,k+1}g_{x,\\max\\{j,k+1\\}}gx,max{j,k+1}​； 合并 fx,i,gy,jf_{x,i},g_{y,j}fx,i​,gy,j​，如果 i+j+1&gt;ri+j+1&gt;ri+j+1&gt;r，那么 ggg 定义的预备点是符合限制的，其会转移到 gx,j+1g_{x,j+1}gx,j+1​，否则会转移到 fx,if_{x,i}fx,i​； 合并 gx,i,fy,jg_{x,i},f_{y,j}gx,i​,fy,j​ 大致同理。 答案是 ∑g1\\sum g_1∑g1​。 时间复杂度 O(n3)O(n^3)O(n3)。代码。 [ARC105F] Lights Out on Connected Graph Portal. 二分图可以转化为将点进行黑白染色，但是是否连通不太好搞，先不管。那这样的方案数不难直接枚举子集算出。 考虑如何处理连通。钦定点在某个顺序下的首个连通块 TTT，那么让 TTT 与剩下所有点不连通，就需要减掉这些方案。注意最后答案要除以 222，代码。 [APIO2019] 桥梁 Portal. 操作分块。块之前的修改直接处理掉，块内部的按照重量限制排序然后枚举所有询问，不需要修改的边按照重量限制依次添加，再枚举需要修改的边按照时间进行修改，然后直接可撤销并查集维护这一阶段的修改，对于一个块内这一步是 O(mlog⁡m+m+B2)O(m\\log m + m +B^2)O(mlogm+m+B2) 的。代码。 中点 好像又大意了。 [APIO2019] 路灯 Portal. 开一个 set 维护所有值为 000 的位置，然后相当于是一个二维偏序问题，加上时间之后变成了三维偏序，对于贡献的计算直接记录上一次 lll 所对应的时间，直接 CDQ 分治即可。 [APIO2019] 奇怪装置 Portal. 不难推导出让 x,yx,yx,y 循环的周期 TTT 的长度，然后直接求线段并大小即可。代码。 [ZJOI2017] 树状数组 Portal. 方向反了是什么？变成了求后缀和！也就是说，但是整个东西求的是 Sr−1−Sl−2S_{r-1}-S{l-2}Sr−1​−Sl−2。也就是说，要求 vr=vl−1v_r=v_{l-1}vr​=vl−1​ 的概率。那么可以视作区间修改，单点查询。 使用二维线段树，外层维护 lll，内层维护 rrr，新的概率是很好求的，注意 l=1l=1l=1 时只需要注意 rrr 的变化情况，直接维护即可。代码。 [CF527E] Data Center Drama Portal. 最终要满足的条件是欧拉图的充要条件，然后定向一下边即可。所以将总度数为奇数的点两两相连，然后不满足加一个自环即可。代码。 [CF538H] Summer Dichotomy Portal. 先不考虑学生数的限制，那么分别两组学生数为 min⁡r,max⁡l\\min r,\\max lminr,maxl 即可。然后可以调整出一种最优的方案，于是就做完了。代码。 [CF543E] Listening to Music Portal. 按照权值从大到小排序，对所有能够覆盖到它的左端点打标记，然后标记永久化一下（空间不足，利用差值来记录标记），就是区间查询最大值。稍微卡卡空间就行，这么出挺无聊的。 落幕 摆捏。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/03(#4)：这世界突然填满，色彩","slug":"default/记录/2023/12/2023-12-03","date":"2023-12-02T00:00:00.000Z","updated":"2023-12-03T00:00:00.000Z","comments":true,"path":"e2190/","link":"","permalink":"https://james1badcreeper.github.io/e2190/","excerpt":"这就是，这个世界啊。","text":"这就是，这个世界啊。 想过离开 当阳光败给阴霾没想到你会拼命为我拨开曾想过离开 却又坚持到现在熬过了 那些旁白 那些姿态 那些伤害不想离开 当你的笑容绽开这世界突然填满 色彩 懂得都懂。 [APC001E] Antennas on Tree Portal. 不难发现只有一个点为根的子树中有两个以上的没有选择点的时候坐标会算重，那么从度数为 111 的点随便 DFS 一下即可。代码。 [AT_cf17_final_j] Tree MST Portal. 直接点分治，然后合并的时候再跑一次 Kruskal 就可以了。代码。 [Ynoi2013] 对数据结构的爱 Portal. 考虑模拟这个过程。我们需要知道对于一段区间，到底会减去多少个 ppp。 搞一个数组 cic_ici​ 代表这段区间要减去 iii 个 ppp 的最小初始值，那么查询的时候直接二分就行。现在考虑如何计算 ccc 数组。 尝试枚举左儿子的 cxc_xcx​ 和右儿子的 cyc_ycy​ 来计算 cx+yc_{x+y}cx+y​，什么时候不能更新？cxc_xcx​ 的上界经过操作后依然小于 cyc_ycy​。 用 max⁡{cx,cy+x×p−sumls}\\max\\{c_x,c_y+x\\times p-sum_{ls}\\}max{cx​,cy​+x×p−sumls​} 更新 cx+yc_{x+y}cx+y​。由于 cx+1−cx≥pc_{x+1}-c_{x}\\ge pcx+1​−cx​≥p，因此直接双指针扫就行。 单次询问会拆成 log⁡\\loglog 个区间，每个区间用 log⁡\\loglog 时间二分，时间复杂度为 O(nlog⁡n+mlog⁡2n)O(n\\log n+m\\log^2 n)O(nlogn+mlog2n)。代码。 [AGC061B] Summation By Construction Portal. 首先明确我们到底要干什么。对于颜色 iii，iii 个左部点都各连两个连续的右部点即可。 nnn 为奇数时，不难按照 i+j=ni+j=ni+j=n 构造出方案。 [3322∣332∣233∣11]\\begin{bmatrix} 3 &amp; 3 &amp; 2 &amp; 2 &amp; | &amp; &amp; \\\\ &amp; 3 &amp; 3 &amp; 2 &amp; | &amp; 2 &amp; \\\\ &amp; &amp; 3 &amp; 3 &amp; | &amp; 1 &amp; 1 \\end{bmatrix} ​3​33​233​223​∣∣∣​21​1​​ 偶数向下扩展就可以了。 [44214412344223344−−−−−333]\\begin{bmatrix} 4 &amp;4 &amp; &amp; &amp;\\color{red}{2}\\\\ \\color{red}{1} &amp; 4 &amp; 4 &amp; &amp;\\color{red}{1}\\\\ \\color{red}{2}&amp; 3 &amp;4 &amp; 4 &amp;\\color{red}{2}\\\\ \\color{red}{2}&amp; 3&amp;3&amp; 4 &amp; 4\\\\ -&amp;-&amp;-&amp;-&amp;-\\\\ &amp;&amp;3&amp;3&amp;\\\\ &amp;&amp;&amp;3&amp; \\end{bmatrix} ​4122−​4433−​443−3​44−33​2124−​​ 代码。 ED 好摆好摆好摆好摆好摆好摆好摆好摆好摆好摆好摆。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/12/01(#3)：不要这般留我一人在世","slug":"default/记录/2023/12/2023-12-01","date":"2023-12-01T00:00:00.000Z","updated":"2023-12-01T00:00:00.000Z","comments":true,"path":"3d1eade/","link":"","permalink":"https://james1badcreeper.github.io/3d1eade/","excerpt":"请装作，还没醒来的样子。","text":"请装作，还没醒来的样子。 心は孤独だ 心是孤独的 愛は見えない 仍旧看不见爱 数値に出来ない感情 这份感情无法以数值衡量 でも震えている 但我还能动弹 脈を打ち続ける 脉搏仍在跳动 波に浮かぶ残骸のように 如同漂浮在浪中的残骸 《Before I Rise》，太感动了。 [AGC002D] Stamp Rally 无聊，建出 Kruskal 重构树就做完了。 [AGC002E] Candy Piles Portal. 挺有意思的博弈论。 将权值从大到小排序，可以转化为网格图，那么从 (0,0)(0,0)(0,0) 开始，操作就相当于向右或向上走一步。 两种操作 谁走到边界上的点谁就输了，因此如果从边界上的点开始，那么后手必胜。对于任意一个不在边界上的点，如果它的上面和右面都是后手必胜点，那么这个点一定是后手必败点，否则结果相反。 红色后手胜，蓝色先手胜 找到最大正方形，然后向上和右扩展即可。 红色 [AGC002F] Leftmost Ball Portal. 为什么我不会？？？？？？？ 考虑最终形成的合法序列，一定是 kkk 个白色球加上 nnn 中颜色的球各 k−1k-1k−1 个，合法情况是前缀白球个数大于等于其它颜色数。 fi,jf_{i,j}fi,j​ 表示 iii 个白球，放了 jjj 个颜色的方案数。 决策有两种： 放置一个白球，有 fi,j←+fi−1,jf_{i,j}\\stackrel{+}{\\leftarrow} f_{i-1,j}fi,j​←+fi−1,j​； 加入新颜色的球，即从 fi,j−1f_{i,j-1}fi,j−1​ 转移。系数是多少？首先需要在 n−j+1n-j+1n−j+1 中选择一个作为这时放置的颜色，将其中一个放置在第一个空位，然后剩下的 k−2k-2k−2 个在后面的 nk−i−(j−1)(k−1)−1nk-i-(j-1)(k-1)-1nk−i−(j−1)(k−1)−1 中找 k−2k-2k−2 个放即可。 然后就完了。代码。 中点 又大意了，上午好像有点摆。 祝各位 CTT RP++。 我也想去 CTT 怎么都老年选手了还这么菜啊。 [CF521E] Cycling City Portal. 随便找到一棵生成树，条件是存在一条树边被两条非树边覆盖掉。那么直接暴力覆盖（最多完整遍历树两次），然后暴力求就行了。代码。 [南京 2020] Fireworks 直接三分就行。 [南京 2020] Ah, It’s Yesterday Once More Portal. 有点鬼畜的题。按照阶梯构造一下就行了。 [CF526G] Spiders Evil Plan Portal. 首先 kkk 条路径可以覆盖 2k2k2k 叶子的树。也就是说，选择 yyy 个点就是能选择 2y2y2y 个叶子，然后极小连通块的边权和尽量大。 以 xxx 为根时如何选择叶子呢？考虑进行一次长链剖分，那么 xxx 所在的长链的叶子也一定选择了，然后按照边权排序贪心即可。 多次询问怎么办？由于树上经过 xxx 的最长链一定经过直径的某一端，那么以直径的两个端点分别做一次长链剖分，然后要想办法将 xxx 加入连通块，只有两种方法： 将贡献最小的长链去掉，然后加入 xxx 所在长链； 找到离 xxx 最近长链的下半部分并替换。 倍增跳长链求出替换的东西即可。代码。 ED 摆的有点抽象了，本来这篇应该再多三道题的。 感觉昨天造了一天数据之后的效率不太行，看看明后天能不能恢复一点。别，慌。 再次疯狂吧！！","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/11/29(#2)：每当我为你抬起头，连眼泪都觉得自由","slug":"default/记录/2023/11/2023-11-29","date":"2023-11-27T00:00:00.000Z","updated":"2023-11-29T00:00:00.000Z","comments":true,"path":"654b1da7/","link":"","permalink":"https://james1badcreeper.github.io/654b1da7/","excerpt":"有的爱像大雨滂沱，却依然相信彩虹","text":"有的爱像大雨滂沱，却依然相信彩虹 我可以跟在你身后 像影子追着光梦游 我可以等在这路口 不管你会不会经过 每当我为你抬起头 连眼泪都觉得自由 有的爱像大雨滂沱 却依然相信彩虹 相信彩虹 张杰这一版唱出了光的感觉，太感动了！！ 大意了，模拟赛 T2 没有测奇数的数据！ 怎么还是只会做简单题！ 我怎么还断更了一天（所以今天实际上是两天的素材，我太摆了）！ [Luogu P5351] Ruri Loves Maschera Portal. 点分治，统计信息时记录 ddd 和最大值 www，扫描线扫 www，树状数组维护 ddd 即可。代码。 [CF960H] Santa’s Gift Portal. 一开始读成了撒旦的礼物。 将贡献拆了，发现问题变成了维护子树中每个颜色的个数。由于总共能出现的颜色只有 O(n+q)O(n+q)O(n+q)，因此直接每个颜色都建一棵支持区间加的动态开点线段树维护即可。代码。 [ARC102D] Revenge of BBuBBBlesort! Portal. 迄今为止我到底见到了多少冒泡排序复仇题！ 思考一下交换意味着什么。一次交换废掉了三个逆序对，因此逆序对个数是三的倍数是必要条件之一。 然后交换时数的奇偶性是不变的，因此奇数只能在奇数位，偶数只能在偶数位。 于是不难想到把奇数位和偶数位分为两组，每次可以废掉奇数序列或者偶数序列的一个逆序对。这样看来，整个序列的逆序对个数应该是奇数序列逆序对加偶数序列逆序对的三倍。 一个操作合法当且仅当其能消除三个全局逆序对，而且一次操作最多消除三个全局逆序对，因此这个东西充分。代码。 [NOI Online 2022 提高组] 如何正确地排序 Portal. 我们考虑计算对 min⁡,max⁡\\min,\\maxmin,max 没有贡献的数，枚举三个数组 A,B,CA,B,CA,B,C，如果 BBB 没有贡献，那么应该满足 Ai+Aj≤Bi+Bj≤Ci+CjA_i+A_j\\le B_i+B_j\\le C_i+C_jAi​+Aj​≤Bi​+Bj​≤Ci​+Cj​。移项之后变成二维偏序，直接做，注意防止算重。代码。 [Ynoi E2022] TEST_105 Portal. 不会做套路题怎么办？？套路没见过怎么办？？还疯狂摆烂怎么办？？ 首先，树上邻域信息一定只能维护子树的信息，否则单点修改会导致所有儿子都需要修改，复杂度直接爆炸。 令 Ci,jC_{i,j}Ci,j​ 表示 iii 点所在子树范围内的连通块的 jjj 色连通块序列，修改时直接启发式合并，只需要更新 Cfax,yC_{fa_x,y}Cfax​,y​ 即可。 为什么中途还写挂了啊？？？？还调了半天？？？？？？ 「C.E.L.U-03」探险者笔记 III Portal. 两个和式就是唬人的，因为它们是定值，暴力转移就是 O(m2)O(m^2)O(m2) 的。然后发现第三维可以直接暴力枚举子集处理。 但是这样显然不对。修改时有两种想法，将 pjp_jpj​ 存下来，枚举 pip_ipi​ 的子集；或者处理 pjp_jpj​ 的超集，pip_ipi​ 直接计算。将 181818 位二进制数劈成两半，定义 gs,tg_{s,t}gs,t​ 表示 pip_ipi​ 前 999 位为 sss，pjp_jpj​ 后 999 位为 ttt 的最优决策即可完成平衡。代码。 ED 下午干一些比较重要的事情。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2023/11/27(#1)：点燃星，亲手点燃黑暗森林的火星","slug":"default/记录/2023/11/2023-11-27","date":"2023-11-26T00:00:00.000Z","updated":"2023-11-27T00:00:00.000Z","comments":true,"path":"6238497e/","link":"","permalink":"https://james1badcreeper.github.io/6238497e/","excerpt":"强度！强度！","text":"强度！强度！ 我是星 利剑开刃寒光锋芒的银星 绝不消隐 不回顾永难再折返的故园的光阴 决意前进 点燃星 亲手点燃黑暗森林的火星 蒙昧初醒 而我却轻声告别这新生的黎明 不像这种加训方式的创始人做的都是神仙题，我做的全是水题…… 然而即使这样还是拖到了次日（本文于 2023/11/26 动工），效率还是要提升！ 让一切，重新开始吧。朝着期望的彼岸，再次前进吧。 [ICPC 2023 Nanjing] Counter Portal. 按照时间排序，模拟即可。代码。 [ICPC 2023 Nanjing] Trapping Rain Water Portal. 本身是个经典问题。set 维护所有的极值点，线段树查询区间最大值和区间和，每次修改直接暴力删除极值点，计算贡献即可。时间复杂度 O(Tnlog⁡n)O(Tn\\log n)O(Tnlogn)。代码。 [ICPC 2023 Nanjing] Equivalent Rewriting Portal. 如果一个赋值操作最后将当前点的值确定，那么这个点向其它赋值过这个点的操作连边。如果拓扑序不唯一，那就有解。代码。 [ICPC 2023 Nanjing] Primitive Root Portal. 解的形式形如 (ip+1)⊕(p−1)(ip+1)\\oplus (p-1)(ip+1)⊕(p−1)，然后发现答案大概是 m/p+1m/p+1m/p+1，边界暴力判断即可。代码。 [CF1166D] Cute Sequences Portal. 容易发现 b=a×2k−2+r2×2k−3+⋯+rk−1+rkb=a\\times 2^{k-2}+r_2\\times 2^{k-3}+\\cdots +r_{k-1}+r_kb=a×2k−2+r2​×2k−3+⋯+rk−1​+rk​。 看上去很像一个二进制拆分状物。反手先将 rrr 全部减掉 111，然后贪心填每一位即可。代码。 「EZEC-14」众数 II Portal. 发现如果一个数 kkk 想要作为区间最小众数，那么这个区间必须以它开头，且不能碰到下一个 111 或者在下一个连续出现 kkk 的位置结尾。 我们计算一个数组 www，wiw_iwi​ 代表以第 iii 个 aia_iai​ 中的 kkk 作为结尾段的左端点个数。发现 www 的更改是区间加的形式，并查集维护区间的右端点即可。 总结一下，区间众数为 kkk 的贡献为 k∑i=1nwimax⁡{0,ai−k+1}k\\sum_{i=1}^n w_i\\max\\{0,a_i-k+1\\}k∑i=1n​wi​max{0,ai​−k+1}。维护 ∑wi\\sum w_i∑wi​ 和 ∑wiai\\sum w_i a_i∑wi​ai​ 即可计算。代码。 「EZEC-14」终点 Portal. 先考虑 fai&lt;ifa_i&lt;ifai​&lt;i。规定 fa1=2fa_1=2fa1​=2，求解 xxx 时令临时父亲 y=1y=1y=1，在 yyy 和 fayfa_yfay​ 中寻找距离为偶数的点来找到中点，然后将临时父亲改为这个中点，log⁡\\loglog 次询问即可得到结果。 对于任意树的情况，我们需要先找到一组相邻的点。先询问 111 和所有点的中点，找到和 111 能取中点次数最多的点不断取中点即可得到一个和 111 相邻的点。 使用 BFS 处理一开始所述的迭代过程。在求解一个点的父亲时需要保证它到根的路径上的所有点（除了自己）的父亲都是已知的，中点 yyy 为一个不确定父亲的点时将询问挂在 yyy 上，然后每次确定一个点的父亲处理所有挂在它上面的询问即可。代码。 [BJOI2018] 双人猜数游戏 Portal. Alice 和 Bob 怎么这么聪明啊？？ 小学时看过这种问题，然后现在在 OI 中见到了它。 设 fi,j,kf_{i,j,k}fi,j,k​ 表示在第 iii 个回合，人能否确定答案是不是 j,k(j≤k)j,k(j\\le k)j,k(j≤k)。 以 Bob 为例，情况只有三种： 如果这个人在它的上一个轮次已经知道答案，那么它这个轮次也知道，即 fi,j,k←fi−2,j,kf_{i,j,k}\\leftarrow f_{i-2,j,k}fi,j,k​←fi−2,j,k​； 从未知推出已知： fi−1,x,y(x+y=j+k)f_{i-1,x,y}(x+y=j+k)fi−1,x,y​(x+y=j+k) 中，他的对手仅有一个 fi−1,j,kf_{i-1,j,k}fi−1,j,k​ 不知道，那么他自己可以确定 j=x,y=kj=x,y=kj=x,y=k； fi−1,x,y(x+y=j+k)f_{i-1,x,y}(x+y=j+k)fi−1,x,y​(x+y=j+k) 中，他自己的上一个轮次只有 fi−2,j,kf_{i-2,j,k}fi−2,j,k​ 不知道，那么他自己可以确定 j=x,y=kj=x,y=kj=x,y=k； 从已知推出已知：fi−1,x,y(x+y=j+k)f_{i-1,x,y}(x+y=j+k)fi−1,x,y​(x+y=j+k) 中，他的对手上一回合只新增确定了一个 fi−1,j,kf_{i-1,j,k}fi−1,j,k​，那么他这回合就能确定 fi,j,kf_{i,j,k}fi,j,k​，(j,k)(j,k)(j,k) 是不是答案跟对手上一次的回答是一致的。 500500500 以内可以找到答案，直接 DP 即可。代码。 间隔 时间来到了 11/27 凌晨。 马克在群里表演了一小时 AK CF Div.2，太牛逼了。 [BJOI2018] 链上二次求和 Portal. 我们有： ans=∑k=lr∑i=knSi−Si−k=∑k=lr(∑i=knSi−∑i=0n−kSi)=∑k=lr(SSn−SSk−1−SSn−k)\\begin{aligned} ans&amp;=\\sum_{k=l}^{r}\\sum_{i=k}^{n}S_i - S_{i-k}\\\\ &amp;=\\sum_{k=l}^r\\left(\\sum_{i=k}^nS_i-\\sum_{i=0}^{n-k}S_i\\right)\\\\ &amp;=\\sum_{k=l}^r(SS_n-SS_{k-1}-SS_{n-k}) \\end{aligned} ans​=k=l∑r​i=k∑n​Si​−Si−k​=k=l∑r​(i=k∑n​Si​−i=0∑n−k​Si​)=k=l∑r​(SSn​−SSk−1​−SSn−k​)​ 然后因为是区间修改，树状数组维护三阶和四阶前缀和即可。注意链上的点可以 x&gt;yx&gt;yx&gt;y，代码。 [APIO2016] 最大差分 Portal. 子任务 111 很简单，直接一路问过去就是 ⌈n2⌉\\left\\lceil\\frac n 2\\right\\rceil⌈2n​⌉ 次询问次数。 子任务 222 的询问代价与询问的值域有关。先问出 a1,ana_1,a_na1​,an​，此时答案的最小是 ⌈an−a1n−1⌉\\left\\lceil\\cfrac{a_n-a_1}{n-1}\\right\\rceil⌈n−1an​−a1​​⌉。将值域序列分块，每块的大小是最小答案，依次查询每块的答案，只有块内最小值减去之前的最大值才可能是答案（块内自己没有答案，因为块的长度小于最小答案）。代码。 插曲 大意了，发现自己好像一个上午什么都没干，就写了两道大水题（11/27）。 听了一些比较奇怪的歌。 下午和晚上怎么办啊。 [CF1063F] String Journey Portal. 可以发现答案最大只有 O(n)O(\\sqrt{n})O(n​)，且 ttt 的长度一定是 ans,ans−1,⋯ ,1ans,ans-1,\\cdots,1ans,ans−1,⋯,1。 那么枚举答案，设 fans,if_{ans,i}fans,i​ 表示当前答案为 ansansans 时以 iii 开头的后缀是否可行。指针 iii 从后往前扫 sss，维护一个哈希表，向其中插入长度为 ans−1ans-1ans−1 的不与 [i,i+ans−1][i,i+ans-1][i,i+ans−1] 重叠的子串（前提是它的后缀是合法的）， 使用 bitset 来实现哈希表，然后搞一个比较小的模数，代码。 无知时诋毁原神 Portal. 只会做水题。 打表发现 nnn 为偶数时无解，奇数时构造 ai=n−ci−1,bi=(ci−ai) mod na_i=n-c_i-1,b_i=(c_i-a_i)\\bmod nai​=n−ci​−1,bi​=(ci​−ai​)modn 即可。代码。 [CF628D] Magic Numbers Portal. 只会做水题。 直接数位 DP 即可。代码。 [CF1063C] Dwarves, Hats and Extrasensory Abilities Portal. 只会做水题。 尝试简化问题。我们将所有点放在一条直线上，然后直接二分就行。代码。 ED 不要太晚，杂题差不多得了，晚上还有其它任务。 但感觉啥都没做啊！！希望之后能够有所改善吧！！ 同学每天都好假……一个上午一套 AGC/Div1 的说自己摆的都是什么意思。 其实也好，感谢大家的暴卷逼着我不再那么摆烂。 让命运继续轮转下去吧。不要昨天立下的誓言今天就忘记啊！！","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"NOIP2023 游记","slug":"summaries/游记/noip2023","date":"2023-11-18T00:00:00.000Z","updated":"2023-11-18T00:00:00.000Z","comments":true,"path":"59a069d8/","link":"","permalink":"https://james1badcreeper.github.io/59a069d8/","excerpt":"摘要：不知道。","text":"摘要：不知道。 Day -INF 被支原体感染了，在家躺了若干天。 Day 1 早上比较赶，到了就进考场了。 吸取上次 CSP 快读写挂的教训，这次先手把板子给写了。 开题，先扫了一眼，感觉比较常规，然后大概 15min 过掉了 T1。 看 T2，稍微想了想之后很快胡出了一个结论，写了上去之后发现是错的。 然后对着样例玩，这时大概玩出了做法，稍微总结了一些性质，大概就是普通树染色基环树判环之类的东西，然后开始写。幸运的是没怎么调试就对了（环的地方写错了一个），但是速度还是比较慢，这时大概过去了 2h。 然后打算 T3 T4 同时看。前者感觉双指针扫一下就行，但是后来发现不太对。后者直接暴力 DP 就有 363636，然后看起来像是线段树优化 DP 整体转移之类的东西，写了一下转移方程发现比较麻烦，而且离散化之后也不太清楚怎么搞，感觉不是我能写出来的东西，去想 T3 的收益比较高。 T3 先搞了个单次 O(n2)O(n^2)O(n2) 的 353535 的暴力 DP，然后想一想怎么优化，但是不会。 尝试双指针能不能扫过这个特殊性质，但是怎样都不对。于是去给 T4 补了一个不交的部分分，这时候大概还剩一个小时。 开始在 T3 和 T4 之间随机游走，但是感觉 T4 搞不出来什么东西。于是开始随即枚举 T3 特殊性质的正确做法，结果最后猜出一个充要条件（前缀最值之类的东西）过掉了大样例。 尝试扩展这个做法，但是试了几个方式都不太对，于是检查文件名，准备交卷。 听到大家都说：这次怎么这么水，T3 T4 不都是傻子题吗？于是赶紧背包走人。 赛时看错 T4 数据点的个数了，所以实际上是 100+100+70+44=314100 + 100 + 70 + 44 = 314100+100+70+44=314，后来回学校问了一圈，好像比较垃圾。 而且还挂了一堆分（大约在 48∼6848\\sim 6848∼68 之间），这下完蛋了。 描述 这次的发挥总体来说比较常规，我应该写出来的都写出来了，我不太会的也没有多会。 实际上就是没水平，问为什么没水平？练少了。 接下来的计划会发在 timeline 时间线上（不一定，也可能不发）。 更多的，不太想说了。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"Codeforces Div.1 大合集","slug":"default/做题记录/CF/d1-1","date":"2023-11-08T00:00:00.000Z","updated":"2023-11-18T00:00:00.000Z","comments":true,"path":"d0ee0fdb/","link":"","permalink":"https://james1badcreeper.github.io/d0ee0fdb/","excerpt":"希斯塔的太阳永远不会落下！","text":"希斯塔的太阳永远不会落下！ PART I 恢复！恢复！ *1893 (Div. 1) https://codeforces.com/contest/1893。 A. Anonymous Informant 考虑将 bbb 序列还原成 aaa 序列。一次移动后，移动的那个数一定跑到了序列的末尾，根据它还原即可。代码。 B. Neutral Tonality 答案的下界是 aaa 的 LIS 长度，我们看看是否能够让答案就是这个。 由于 bbb 可以随便加，因此将 bbb 从大到小排序，这样能保证 bbb 自身不会贡献 LIS 的长度。如果在 aia_iai​ 前面扔一个所有数都比 aia_iai​ 大的下降序列，那么此时将 aia_iai​ 选进 LIS 里只可能比将下降序列的任何一个数选进 LIS 的长度更长，因此这样将 bbb 扔进 aaa 里一定不会使 LIS 变长。最后将剩余的 bbb 扔到 aaa 末尾，双指针合并 a,ba,ba,b 即可。代码。 C.","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"Codeforces","slug":"算法竞赛/做题记录/Codeforces","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/Codeforces/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"ARC 专题（4 题场）","slug":"default/做题记录/AT/arc01","date":"2023-11-03T00:00:00.000Z","updated":"2023-11-23T00:00:00.000Z","comments":true,"path":"c76fc545/","link":"","permalink":"https://james1badcreeper.github.io/c76fc545/","excerpt":"“本着题是用来做的原则，我们从远古时期的 4 题场开始。”","text":"“本着题是用来做的原则，我们从远古时期的 4 题场开始。” PART I 什么东西呢。 ARC064 https://atcoder.jp/contests/arc064/tasks。 VP 通过 ABC，perf 2489，感觉一般。 A 吃了一发罚时，没注意到 a1&gt;xa_1&gt;xa1​&gt;x，注意细节！！ D 确实不是我能想出来的东西。 B. An Ordinary Game Portal. 妙哉，妙哉！ 手造几个东西发现最终之和两端的东西是否相等和长度的奇偶性有关，讨论一下不难得到答案。 代码。 C. Cosmic Rays Portal. 考虑圆外的一点如何走到圆内的距离是最短的：很简单，将它和圆心连线即可。也就是说，我们将所有圆都看作圆心一个点，求出的距离必定是最短距离。 枚举任意两个圆和起点终点，计算出它们之间的暴露在宇宙射线中的距离，然后在这张完全图上直接暴力 Dijkstra 求出最短路即可，时间复杂度 O(n2)O(n^2)O(n2)。代码。 D. Rotated Palindromes Portal. 考虑如何不重不漏地统计。如果一个回文串是由多个相同的回文串组成的，那么设它的最小循环节长度为 ttt，那么将其移动 ttt 次后就会变成原来的回文串。 设 fif_ifi​ 表示长度为 iii 的回文串个数，我们只需要考虑 iii 为 nnn 的约数的情况。 长度为 iii 的回文串有 k⌈i/2⌉k^{\\lceil i/2 \\rceil}k⌈i/2⌉ 种，根据上面所说的不重不漏，容斥得到 fi=k⌈i/2⌉−∑j∣ifjf_i=k^{\\lceil i/2 \\rceil}-\\sum_{j\\mid i} f_jfi​=k⌈i/2⌉−∑j∣i​fj​。 如何统计答案？如果 iii 是奇数，那么操作 iii 次之后所构成的串均不相同，系数为 iii；如果 iii 是偶数，那么操作 i/2i/2i/2 次之后会变成一个新的回文串，为了防止算重，其系数为 i/2i/2i/2。代码。 ARC065 https://atcoder.jp/contests/arc065/tasks。妙哉！ VP 通过 ABD，C 不知道是个什么。 perf 2762，感觉还行。 B. Connectivity Portal. 只有一个东西不难想到使用并查集维护。 两个信息只难在如何统计。只要知道其在两个信息里的编号就可以确定当前点的连通块了。那么开一个 map&lt;pair&lt;int, int&gt;, int&gt;，来代表一个 pair&lt;int, int&gt;，即分别给定其道路和地铁的连通块所对应的“大连通块”的点数。代码。 C. Manhattan Compass Portal. 给定平面上的 nnn 个点，选择两个点满足其曼哈顿距离等于 ddd，求方案数。 将曼哈顿距离转为切比雪夫距离，排序二分不难找出合法的点的区间。如何求方案数？对于 iii 所对应的合法区间 [l,r][l,r][l,r]，iii 向 lll 连边，然后区间内依次连边。对于连到了 aaa 点的点，其方案数均可以被统计。 为了避免重复统计，需要注意对于 yyy 统计时不能计算 xxx 相等的情况。代码。 D. Shuffling Portal. 考虑 O(n2)O(n^2)O(n2) 的 DP。设 fi,jf_{i,j}fi,j​ 代表前 iii 个数填了 jjj 个 111 的方案数。转移显然是 fi,j=fi−1,j+fi−1,j−1f_{i,j}=f_{i-1,j}+f_{i-1,j-1}fi,j​=fi−1,j​+fi−1,j−1​。 问题在于什么样的 jjj 是合法的。预处理出每个左端点可以“支配”到的右端点，这部分以内是可以随便交换的。显然，如果存在一个可交换区间 [l,r][l,r][l,r]，那么 ∀x∈[l,r]\\forall x\\in [l,r]∀x∈[l,r]，xxx 都能够支配到 rrr。 扫描到第 iii 个位置时，111 的个数最多是将支配范围内的 111 全部搞过来（当然不能超过 iii），最少是能扔出多少 111 到支配范围就扔多少（当然不能少于 000），直接转移即可。 代码。 ARC067 https://atcoder.jp/contests/arc067/tasks。 VP 通过 ABC。前期网有点卡，后面 C 做的太慢了，导致甚至没有见到 D，有点大失败。 perf 2121，感觉一般。 C. Grouping Portal. 发现数据范围很小，因此直接考虑暴力 DP。 设 fi,jf_{i,j}fi,j​ 代表考虑到分人数为 iii 的组，当前有 jjj 个人的方案数。决策有两种：不存在这个人数的组，这个人数的组的个数在 [c,d][c,d][c,d] 之间。那么有： fi,j=fi−1,j+∑j=cdfi−1,j−ki(n−(j−ki)ki)gi,kf_{i,j}=f_{i-1,j}+\\sum_{j=c}^d f_{i-1,j-ki}\\binom{n-(j-ki)}{ki}g_{i,k} fi,j​=fi−1,j​+j=c∑d​fi−1,j−ki​(kin−(j−ki)​)gi,k​ 组合数代表在剩余的人中选择 kikiki 个人来完成人数为 iii 的组的填充，gi,kg_{i,k}gi,k​ 代表将 kikiki 个人分成 kkk 组，一组 iii 个人的方案数。 其计算的过程是这样的：现在 kikiki 个人中选择 iii 个人，再在 (k−1)i(k-1)i(k−1)i 个人中选择 iii 个人……由于组之间不区分，因此最后除掉 k!k!k! 去重。因此： gi,k=∏j=1k(jii)(ki)!g_{i,k}=\\frac {\\prod_{j=1}^k \\binom{ji}{i}} {(ki)!} gi,k​=(ki)!∏j=1k​(iji​)​ 直接递推分子，分母在计算 fff 时除掉即可。由于枚举 jjj 的时候是调和级数复杂度，因此时间复杂度为 O(n2log⁡n)O(n^2\\log n)O(n2logn)。代码。 D. Yakiniku Restaurants Portal. 发现走的必定是一条线段。从右端点开始枚举左端点，维护数组 ansians_iansi​ 表示右端点在 iii 的最优答案。每次考虑是否将贡献换到左端点，单调栈维护前缀最大值来计算贡献即可。代码。 UPD 可能不更新了，以后的 ARC 题会放在加训记录里。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"ATCoder","slug":"算法竞赛/做题记录/ATCoder","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ATCoder/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"AGC 专题","slug":"default/做题记录/AT/agc01","date":"2023-10-27T00:00:00.000Z","updated":"2023-10-27T00:00:00.000Z","comments":true,"path":"86efec8d/","link":"","permalink":"https://james1badcreeper.github.io/86efec8d/","excerpt":"牛逼题专题。","text":"牛逼题专题。 PART I 菜是原罪。 AGC 001 https://atcoder.jp/contests/agc001/tasks。 B. Mysterious Light Portal. 先照一次之后就是平行四边形，直接递归即可。代码。 C. Shorten Diameter Portal. 按照直径的奇偶性枚举点或边即可。代码。 D. Arrays and Palindrome Portal. 出现两个以上的奇数无解，否则错位一下就行。代码。 E. BBQ Hard Portal. 可以抽象成 (0,0)→(ai+aj,bi+bj)(0,0)\\rightarrow(a_i+a_j,b_i+b_j)(0,0)→(ai​+aj​,bi​+bj​)，也就是 (−ai,−bi)→(aj,bj)(-a_i,-b_i)\\rightarrow(a_j,b_j)(−ai​,−bi​)→(aj​,bj​)，就可以直接统计了。代码。 * F. Wide Swap Portal. 两个限制看上去就不像是人能做的东西，因此考虑构造 QPi=iQ_{P_i}=iQPi​​=i，然后就变成交换相邻的数值 ≥k\\ge k≥k 的数了。 然后直接冒泡过去就 TLE 了，改成归并就好了。代码。 这里大致说一下为什么这个东西是对的，如果想要让 PPP 的字典序最小，那就应该让值 111 的下标尽可能小，也就是 菜肴制作 的排序方式，对于冒泡排序来说，我们必定会将 Qx=1Q_x=1Qx​=1 的 xxx 搞到尽可能地小。实际上是要求 QQQ 的字典序最大（翻转后）。 然后大概讲述一下本题的正常做法：如果 ∣Qi−Qj∣&lt;k|Q_i-Q_j|&lt;k∣Qi​−Qj​∣&lt;k，那么相当于它们之间的顺序无法进行更改。这样的话可以枚举两个位置，满足被定死的条件则从前面向后面的位置连边，然后建反图求字典序最大的拓扑序（但实际上这道题中这玩意儿跟求直接求最小字典序拓扑序是等价的，证明可以反证，也比较好证。也正是这个原因，排序做法才得以成立，否则让排序来做一个将其变成字典序最大的东西是做不了一点的）。 对于正常做法来说，考虑线段树优化建图。倒序枚举 iii，然后找出 [ai−k+1,ai+k−1][a_{i}-k+1,a_{i}+k-1][ai​−k+1,ai​+k−1] 中 &gt;i&gt;i&gt;i 的最小值 xxx，然后向它们连边（其实要分别找两边）。不难发现这样就可以刻画原图的连通性。代码。 AGC 002 https://atcoder.jp/contests/agc002/tasks。 D. Stamp Rally Portal. 这个东西不难想到二分答案。建立出基于点权的 Kruskal 重构树，然后直接做就行。代码。 E. Candy Piles Portal. 挺有意思的博弈论。 将权值从大到小排序，可以转化为网格图，那么从 (0,0)(0,0)(0,0) 开始，操作就相当于向右或向上走一步。 两种操作 谁走到边界上的点谁就输了，因此如果从边界上的点开始，那么后手必胜。对于任意一个不在边界上的点，如果它的上面和右面都是后手必胜点，那么这个点一定是后手必败点，否则结果相反。 红色后手胜，蓝色先手胜 找到最大正方形，然后向上和右扩展即可。 红色 代码。 F. Leftmost Ball Portal. 考虑最终形成的合法序列，一定是 kkk 个白色球加上 nnn 中颜色的球各 k−1k-1k−1 个，合法情况是前缀白球个数大于等于其它颜色数。 fi,jf_{i,j}fi,j​ 表示 iii 个白球，放了 jjj 个颜色的方案数。 决策有两种： 放置一个白球，有 fi,j←+fi−1,jf_{i,j}\\stackrel{+}{\\leftarrow} f_{i-1,j}fi,j​←+fi−1,j​； 加入新颜色的球，即从 fi,j−1f_{i,j-1}fi,j−1​ 转移。系数是多少？首先需要在 n−j+1n-j+1n−j+1 中选择一个作为这时放置的颜色，将其中一个放置在第一个空位，然后剩下的 k−2k-2k−2 个在后面的 nk−i−(j−1)(k−1)−1nk-i-(j-1)(k-1)-1nk−i−(j−1)(k−1)−1 中找 k−2k-2k−2 个放即可。 然后就完了。代码。 UPD 可能不更新了，以后的 AGC 题会放在加训记录里。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"ATCoder","slug":"算法竞赛/做题记录/ATCoder","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ATCoder/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Codeforces Div.2 大合集","slug":"default/做题记录/CF/d2-1","date":"2023-10-27T00:00:00.000Z","updated":"2023-11-20T00:00:00.000Z","comments":true,"path":"5b081a8b/","link":"","permalink":"https://james1badcreeper.github.io/5b081a8b/","excerpt":"天不生卷王，万古如长夜！","text":"天不生卷王，万古如长夜！ PART I 下次晚上早点睡！ *1809 (EDU) https://codeforces.com/contest/1809。 D. Binary String Sorting 直接枚举断点即可计算。代码。 E. Two Tanks 如果 c+dc+dc+d 固定，那么答案应该时随着 ccc 的增加先不变，再递增，最后又不变的顺序进行的，而且每次的差值只有 111。枚举 c+dc+dc+d，找出这两个位置即可。代码。 F. Traveling in Berland 如果当前位置油价是 111，那么肯定能加满就加满（会用完），222 的话能加多少加多少。设 fif_{i}fi​ 代表 iii 到下一个油价是 111 的位置的位置，sis_{i}si​ 代表代价，倍增这个过程即可。代码。 G. Prediction 对于一个合法的排列 ppp，删除 apia_{p_i}api​​ 最小的 pip_ipi​，新的 p′p&#x27;p′ 必定合法。 设 fif_{i}fi​ 代表填完 (i,n](i,n](i,n] 的方案数，初始 fn=1f_n=1fn​=1，考虑 aia_iai​ 填的位置： 不填在当前第一个位置，不影响后面元素的前缀 max⁡\\maxmax，fi−1←+fi(n−i)f_{i-1}\\stackrel{+}{\\leftarrow} f_{i}(n-i)fi−1​←+fi​(n−i)； 填在当前第一个位置。设 lstilst_ilsti​ 代表最大的 jjj 使得 ai−aj&gt;ka_i-a_j&gt;kai​−aj​&gt;k，那么 (lsti,i)(lst_i,i)(lsti​,i) 都需要出现在 iii 之前，则 i−lsti−1i-lst_i-1i−lsti​−1 需要填入 n−lsti−2n-lst_i-2n−lsti​−2 个数。 双指针求 lstlstlst，时间复杂度 O(n)O(n)O(n)。代码。 *1856 (Div. 2) https://codeforces.com/contest/1856。 C. To Become Max nnn 只有 100010001000，想的暴力一点，枚举最终成为答案的数 aia_iai​。一开始肯定要利用 ai+1a_{i+1}ai+1​ 让 aia_iai​ 变得尽可能大，这样的代价是最小的。当 ai&gt;ai+1a_i&gt;a_{i+1}ai​&gt;ai+1​ 时怎么办？利用 ai+2a_{i+2}ai+2​ 让 ai+1a_{i+1}ai+1​ 变大。 如果操作次数足够多，那么最终的序列肯定是形如 x,x−1,⋯ ,an+1,anx,x-1,\\cdots,a_n+1,a_nx,x−1,⋯,an​+1,an​ 的。也就是说，依次枚举 j∈[i+1,n]j\\in[i+1,n]j∈[i+1,n]，当 aj≥aj−1a_j\\ge a_{j-1}aj​≥aj−1​ 时，至多就可以让 aia_iai​ 变大 aj−aj−1+1a_j-a_{j-1}+1aj​−aj−1​+1，此时更新答案即可。如果不满足，aja_jaj​ 在后续的更新过程中肯定要变成 aj−1−1a_{j-1}-1aj−1​−1，否则无法使 aia_iai​ 变得更大，提前更新 aja_jaj​ 即可。代码。 D. More Wrong 看上去就很分治。当前点 rrr 在 [l,r][l,r][l,r] 中最大的充要条件是 Q(l,r−1)=Q(l,r)Q(l,r-1)=Q(l,r)Q(l,r−1)=Q(l,r)，根据此分治下去即可。代码。 E. PermuTree 只要更改子树内的权值分布，就可以达到贡献最大化，所以是个树上背包状物，可以通过 E1，代码。 对于 E2，我们要思考如何高效解决“把儿子大小构成的数集合分成差尽可能小的两部分”。子树中不同的 sizsizsiz 最多只有 n\\sqrt{n}n​ 种，二进制拆分掉保证物品个数不多于 log⁡n\\log nlogn 个，然后是可行性背包采用 bitset 优化，单次时间复杂度是 O(nnlog⁡nw)O\\left(\\dfrac{n\\sqrt{n}\\log n}{w}\\right)O(wnn​logn​) 的。 如何将其搬到树上？简单。如果存在一个重儿子，它比所有轻儿子都重，这样可以直接得出答案。否则会造成一个分治的效果，每次问题规模必定减半，时间复杂度为 O(nnlog⁡2nw)O\\left(\\dfrac{n\\sqrt{n}\\log^2 n}{w}\\right)O(wnn​log2n​)。实际效率非常高。代码。 *1354 (EDU) https://codeforces.com/contest/1354。 C2. Not So Simple Polygon Embedding 大致思路是观察获得多边形的旋转度数，然后解三角形。代码。 D. Multiset 权值树状数组直接维护。代码。 E. Graph Coloring 二分图染色，然后背包判断可行性。代码。 F. Summoning Minions 必定是放满 k−1k-1k−1 张后，拿剩下的放完就扔（会产生 b×(k−1)b\\times (k-1)b×(k−1) 的贡献），最后再放一张。 放置顺序必定满足 bbb 递增（否则可以交换），然后根据此进行 DP：fi,jf_{i,j}fi,j​ 代表前 iii 张选 jjj 张不是用完就扔的。代码。 G. Find a Gift 如果知道其中 xxx 个是石头，那么就能用这 xxx 个去确定另外 xxx 个数当中有没有石头。先找到 111 个石头，然后从头开始倍增找到第一个没有石头的区间。要确定这段有石头的区间的第 111 个石头位置，可以二分。如何找到一个石头？不知道，采用随机化。随机找到一些位置，找到当中最重的，那么可以确定那个是石头。代码。 *1848 (Div. 2) https://codeforces.com/contest/1848。 A. Vika and Her Friends 偶数能抓。代码。 B. Vika and the Bridge 存所有颜色的位置。代码。 C. Vika and Price Tags 在 (0,b)→(b,b)→(b,0)(0,b)\\rightarrow (b,b)\\rightarrow (b,0)(0,b)→(b,b)→(b,0) 中循环，辗转相除处理即可。代码。 D. Vika and Bonuses 以 202020 为循环节，暴力枚举，求抛物线的顶点。代码。 E. Vika and Stone Skipping 如果跳 ggg 次，需要满足： 2x∏Xi=(2f−g+1)g2x\\prod X_i=(2f-g+1)g 2x∏Xi​=(2f−g+1)g 求的就是 2x∏Xi2x\\prod X_i2x∏Xi​ 的奇因数个数。 直接维护即可。注意模数过小时逆元的爆炸问题。代码。 F. Vika and Wiki 次数越大一定是越趋近于全 000 的，直接倍增答案即可。代码。 *1837 (EDU) https://codeforces.com/contest/1837/。 C. Best Binary String 不难猜到将有数的东西向左右扩展就是答案。代码。 D. Bracket Coloring 不难猜到答案最大为 222，根据此构造即可。代码。 E. Playoff Fixing 不难发现 2i,2i+12i,2i+12i,2i+1 是一组的，并且这玩意儿存在子问题。 记录可以随便填的个数和可以随便排列的个数便不难计算出这一层的方案数。代码。 F. Editorial for Two 二分加贪心即可。代码。 PART II 大打出手！ *1821 (EDU) https://codeforces.com/contest/1821。 E. Rearrange Brackets 一定是删掉右边的 ()，其贡献就是其深度（外面套了多少个括号）。 操作是什么？发现能将其最外层的括号单独移动出来，贪心即可。代码。 F. Timber 一棵树倒下之后会占用 kkk 的空间，因此答案为 2m(n−mkm)2^m\\dbinom{n-mk}{m}2m(mn−mk​)。 然后发现需要容斥。其中钦定一棵树会产生左右倒的分身，那么答案是 2m−1(m1)(n−(m+1)km)2^{m-1}\\dbinom m 1 \\dbinom{n-(m+1)k}{m}2m−1(1m​)(mn−(m+1)k​)。直接做即可。代码。 *1891 (Div. 2) https://codeforces.com/contest/1891。 D. Suspicious logarithms 发现 f,gf,gf,g 的变化都不多，因此直接暴力碾过去即可。代码。 E. Brukhovich and Exams 将 gcd⁡\\gcdgcd 为 111 的和本身为 111 大段的划分成极长连续段，直接贪心即可。代码。 F. A Growing Tree 发现每次加边只需要给节点打上一个标记来抵消修改，需要查询到根的距离，用大融合一题的方式去做即可。这里选择直接拉了一个 LCT，代码。 *1661 (EDU) https://codeforces.com/contest/1661。 D. Progressions Covering 我们从后往前扫描数组，这样就可以发现贪心加就可以了，因为加的是最大的还不会浪费。那么记录总操作数 opopop 和当前加的和 sss。对于当前的数，操作数是 ⌈b[i]−sk⌉\\left\\lceil \\cfrac{b[i]-s}{k}\\right\\rceil⌈kb[i]−s​⌉（实际这个 kkk 需要根据 iii 调整），往前扫一个，当前的和就减少了操作数，操作数会减少 i+k−1i+k-1i+k−1 时增加的操作数。代码。 E. Narrow Components 看到 n=3n=3n=3 和区间查询不难想到线段树，初始假设所有点都不在一个连通块内，然后合并两段区间时暴力并查集合并即可。代码。 F. Teleporters 可以将原问题划分成几段，然后对于每一段放置传送器的话分的约均匀越好，全局的最小两相邻传送机距离应该是一个（尽可能满足平均），这样就可以用 f(x,k)f(x,k)f(x,k) 来表示 0→x0\\rightarrow x0→x 中额外插入 kkk 个的最小代价，显然是好求的。 直接二分需要安装的传送机数量？我们好像没有办法 check，只知道最多传送机数量的话没有一个合适的贪心策略。我们对另一个条件——总花费进行考虑。因为花费越大直接意味着传送机数量越少。 注意到 f(x,k−1)−f(x,k)f(x,k-1)-f(x,k)f(x,k−1)−f(x,k) 随着 kkk 的增大单调不增，这样可以在外层二分其值 vvv 来代表一个段内的最小传送机距离，找出一个 f(x,k−1)−f(x,k)≥vf(x,k-1)-f(x,k)\\ge vf(x,k−1)−f(x,k)≥v 的最大 kkk，而 kkk 越大花费越小，直接利用 kkk 来进行贪心求出每一段的最小代价，与 mmm 比较来确定二分的答案。 设二分出来的答案是 kkk，选完之后 mmm 的值还有剩余，我们尽可能多的值选择 k+1k+1k+1 来榨干 mmm 的剩余价值。 时间复杂度 O(nlog⁡2V)O(n\\log^2 V)O(nlog2V)。代码。 *1795 (EDU) https://codeforces.com/contest/1795。 A. Two Towers 实际上说的是只能有一个不满足的位置。代码。 B. Ideal Point 只选覆盖 kkk 的线段即可。代码。 C. Tea Tasting 二分出每杯茶能够被哪些人喝即可。代码。 D. Triangle Coloring 答案是固定的，乘法原理乘起来即可。代码。 E. Explosions? 总花费更少，那么我们就希望炸掉的血量更多。当变成一个严格单峰函数的时候（令 ai←ai−ia_i\\leftarrow a_i-iai​←ai​−i 变成单峰来处理），也就是搞成一段一段公差为 111 的等差数列，就可以炸了。 容易想到通过单调栈处理这个东西，正反做两遍然后合并即可。代码。 F. Blocking Chips 二分答案，如果能向下走就向下，贪心即可。代码。 G. Removal Sequences ai=0a_i=0ai​=0 一定是最后被删去的，考虑逆时旅人，令 di←deg⁡(i)−aid_i\\leftarrow \\operatorname{deg}(i)-a_idi​←deg(i)−ai​，按照这个进行拓扑排序即可求出一组合法解。 考虑求出不美好的点对，如果这张有向图的两个点直接互相可达，那么这是不美好的。bitset 直接统计即可。代码。 *1845 (EDU) https://codeforces.com/contest/1845。 F 是 NTT，不会，也不打算学。 C. Strong Password 搞两个指针分别扫两个序列即可。代码。 D. Rating System 发现其是利用 kkk 来消掉一个最小子段和的影响。代码。 E. Boxes and Balls 对于移动到目标状态，我们只需要消耗最小次数，剩下的来回交换刷分即可。 将问题抽象成这个东西： 初始前缀和序列 sss，目标前缀和序列 s′s&#x27;s′； ∑∣s′−s∣≤k\\sum |s&#x27;-s|\\le k∑∣s′−s∣≤k， ∑∣s′−s∣≡k(mod2)\\sum |s&#x27;-s|\\equiv k\\pmod 2∑∣s′−s∣≡k(mod2)。 设 fi,j,kf_{i,j,k}fi,j,k​ 代表当前填前 iii 个数，填了 jjj 个 111，∑∣s′−s∣=k\\sum |s&#x27;-s|=k∑∣s′−s∣=k 的方案数，考虑当前位填 0/10/10/1： fi,j,k=fi−1,j,k−∣j−si∣+fi−1,j−1,k−∣j−si∣f_{i,j,k}=f_{i-1,j,k-|j-s_i|}+f_{i-1,j-1,k-|j-s_i|} fi,j,k​=fi−1,j,k−∣j−si​∣​+fi−1,j−1,k−∣j−si​∣​ 注意到 ∣j−si∣|j-s_i|∣j−si​∣ 的取值范围是 O(k)O(\\sqrt{k})O(k​) 的，否则 ∑\\sum∑ 这堆东西会超过 kkk。只枚举这些值即可。代码。 PART III 话。 *1898 (Div. 2) https://codeforces.com/contest/1898。 E. Sofia and Strings 为什么赛时不仔细看看。 考虑贪心去做这个东西。扫描 ttt，维护 sss 中可用字母的位置，如果不存在字母则直接无解，然后在位置中删去不能再被利用的字符。代码。 F. Vova Escapes the Matrix 先手判断迷宫类型。如果根本走不出去，那么全堵死；如果只有一条路，那么除了最短路的全堵死；否则，考虑每个点都记一下自己可以到哪些终点，然后对于终点只有两个的点可以进行答案的计算。代码。 *1879 (EDU) https://codeforces.com/contest/1879。 D. Sum of XOR Functions 考虑拆位考虑贡献，记录所有值为 xxx 的下标和，那么 lll 的贡献减去它们即可。代码。 E. Interactive Game with Coloring 是个套着交互皮的构造。发现一般情况下只需要两种颜色，如果同时有两个深度不同的三连单链，那么才需要三种颜色。代码。 F. Last Man Standing 对于第 iii 位选手，选择难度 xxx 的题，那么它能挨的轮数是 hi⌈aix⌉h_i\\left\\lceil\\cfrac{a_i}{x}\\right\\rceilhi​⌈xai​​⌉。考虑枚举 xxx，用最大轮数和次大轮数的差来更新答案。可以想到用调和级数复杂度来枚举 ⌈aix⌉\\left\\lceil\\cfrac{a_i}{x}\\right\\rceil⌈xai​​⌉ 的值，那么问题就弱化成了区间查询 hhh 的最大次大值，ST 表维护即可。代码。 *1839 (Div. 2) https://codeforces.com/contest/1839. D. Ball Sorting 可以注意到要移动就会直接移动到目标位置，而这样的话最长上升子序列就一定会被保留。用 iii 个 000，实际上就是最长上升子序列中，允许拥有 iii 个连续子段。设 fi,jf_{i,j}fi,j​ 代表使用 iii 个 000，最长上升子序列以 jjj 结尾的最大保留数，选取答案时要以 1∼n1\\sim n1∼n 结尾均考虑。代码。 E. Decreasing Game 结论不难猜出，然后随便判判就好了。代码。 *1834 (Div. 2) https://codeforces.com/contest/1834。 E. MEX of LCM 可以发现有效 LCM 数量不会很多，因此只统计有效 LCM，暴力扫描，丢进 set 里即可。代码。 F. Typewriter 我们先来考虑答案是什么。每一轮一定是最后拿起一个 pi&lt;ip_i&lt;ipi​&lt;i 的东西，然后把它放到下一轮的位置上。也就是说需要维护 ∑[pi&lt;i]\\sum [p_i&lt;i]∑[pi​&lt;i]，差分维护即可。代码。 *1901 (EDU) https://codeforces.com/contest/1901。 F 是几何，不做。 D. Yet Another Monster Fight FST 了，呵呵。 直接输出计算的答案就好了。代码。 E. Compressed Tree 设 fif_ifi​ 代表以 iii 为根的子树形成一个被删不掉的整体的最大权值之和，然后讨论一下儿子个数转移即可。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"Codeforces","slug":"算法竞赛/做题记录/Codeforces","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/Codeforces/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CERC2015 解题报告","slug":"default/做题记录/ICPC/CERC/CERC2015","date":"2023-10-26T00:00:00.000Z","updated":"2023-10-26T00:00:00.000Z","comments":true,"path":"a2779d57/","link":"","permalink":"https://james1badcreeper.github.io/a2779d57/","excerpt":"记录了有关 CERC2015 的题目。","text":"记录了有关 CERC2015 的题目。 所有题目可以在 https://codeforces.com/gym/101480 找到。 A. ASCII Addition 将数字压成一个字符串，然后模拟。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; map&lt;string, int> pm; map&lt;int, string> mp; string a[1005], s[1005]; i64 num[1005]; int main(void) &#123; ios::sync_with_stdio(0); mp[0] = \"xxxxxx...xx...xx...xx...xx...xxxxxx\"; mp[1] = \"....x....x....x....x....x....x....x\"; mp[2] = \"xxxxx....x....xxxxxxx....x....xxxxx\"; mp[3] = \"xxxxx....x....xxxxxx....x....xxxxxx\"; mp[4] = \"x...xx...xx...xxxxxx....x....x....x\"; mp[5] = \"xxxxxx....x....xxxxx....x....xxxxxx\"; mp[6] = \"xxxxxx....x....xxxxxx...xx...xxxxxx\"; mp[7] = \"xxxxx....x....x....x....x....x....x\"; mp[8] = \"xxxxxx...xx...xxxxxxx...xx...xxxxxx\"; mp[9] = \"xxxxxx...xx...xxxxxx....x....xxxxxx\"; mp[10] = \".......x....x..xxxxx..x....x.......\"; for (int i = 0; i &lt;= 10; ++i) pm[mp[i]] = i; for (int i = 1; i &lt;= 7; ++i) cin >> s[i]; int len = s[1].length(); for (int i = 1; i &lt;= 7; ++i) &#123; int p = 1; for (int j = 0; j &lt; len; ++j) if ((j + 1) % 6 == 0) &#123; ++p; continue; &#125; else a[p].push_back(s[i][j]); &#125; len = (len + 1) / 6; for (int i = 1, u = 1; i &lt;= len; ++i) &#123; if (pm[a[i]] == 10) &#123; ++u; continue; &#125; num[u] = num[u] * 10 + pm[a[i]]; &#125; i64 ans = num[1] + num[2]; len = 0; while (ans) num[++len] = ans % 10, ans /= 10; for (int j = 1; j &lt;= 7; ++j, cout &lt;&lt; \"\\n\") for (int i = len; i >= 1; i--) &#123; for (int k = 0; k &lt; 5; k++) cout &lt;&lt; mp[num[i]][(j - 1) * 5 + k]; if (i != 1) cout &lt;&lt; \".\"; &#125; return 0; &#125; B. Book Borders 考虑直接枚举，每次跳到相应的合法单词，这样是调和级数复杂度。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; char s[500050]; int pre[500050], len[500050]; int main(void) &#123; fgets(s, 500010, stdin); n = strlen(s) - 1; s[n] = ' '; int flag = 0, lst = 0, cnt = 0; for (int i = 0; i &lt;= n; ++i) &#123; if (s[i + 1] == ' ') pre[i] = i; else pre[i] = (i == 0 ? 0 : pre[i - 1]); if (!flag &amp;&amp; s[i] != ' ') flag = 1, lst = i, cnt = 1; else if (flag &amp;&amp; s[i] == ' ') flag = 0, len[lst] = cnt; ++cnt; &#125; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); for (int i = a; i &lt;= b; ++i) &#123; int cur = 0, ans = 0; while (cur &lt; n) &#123; ans += len[cur]; cur = pre[min(cur + i - 1, n - 1)] + 2; &#125; printf(\"%d\\n\", ans - 1); &#125; return 0; &#125; * C. Cow Confinement 比较抽象的一道题，赛时居然没有人过。 一头牛的话显然是 DP（fi,j=fi+1,j+fi,j+1−fi+1,j+1f_{i,j}=f_{i+1,j}+f_{i,j+1}-f_{i+1,j+1}fi,j​=fi+1,j​+fi,j+1​−fi+1,j+1​），那么考虑用扫描线从右向左扫，线段树维护当前每个点的 DP 值。如果扫到了一个右区间，那么从上线到下一条下线都要被加在上线上的一个格子，并且线内数据清零。扫到左线线内数据清零，并把原来线外的东西加回来，最后再把右下角算重的部分减去就行。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1000001; int n, m; struct Line &#123; int x, y1, y2, id, type; bool operator&lt; (const Line &amp;a) const &#123; if (x != a.x) return x > a.x; return type &lt; a.type; &#125; &#125; Q[8000005]; struct SGT &#123; int T[4000050], tag[4000050]; inline void pushdown(int o) &#123; if (!tag[o]) return; tag[o &lt;&lt; 1] = tag[o &lt;&lt; 1 | 1] = 1; T[o &lt;&lt; 1] = T[o &lt;&lt; 1 | 1] = 0; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int v) &#123; if (l == r) return T[o] += v, void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, v); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, v); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void clear(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] = 1, T[o] = 0, void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) clear(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) clear(o &lt;&lt; 1 | 1, mid + 1, r, x, y); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; pushdown(o); int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; &#125; T; int ans[200005], tmp[200005]; multiset&lt;int> s; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2; Q[++m] = &#123;x2, y1, y2, i, 1&#125;; Q[++m] = &#123;x1 - 1, y1, y2, i, 2&#125;; &#125; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; int x, y; cin >> x >> y; Q[++m] = &#123;x, y, 0, 0, 3&#125;; &#125; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; int x, y; cin >> x >> y; Q[++m] = &#123;x, y, 0, i, 4&#125;; &#125; sort(Q + 1, Q + m + 1); s.emplace(N); for (int i = 1; i &lt;= m; ++i) if (Q[i].type == 1) &#123; // 进入框子 int nxt = *s.upper_bound(Q[i].y2); tmp[Q[i].id] = T.query(1, 0, N, Q[i].y2 + 1, nxt); T.update(1, 0, N, Q[i].y1 - 1, T.query(1, 0, N, Q[i].y1, nxt)); T.clear(1, 0, N, Q[i].y1, Q[i].y2); s.emplace(Q[i].y1 - 1); s.emplace(Q[i].y2); &#125; else if (Q[i].type == 2) &#123; // 出了框子 T.update(1, 0, N, Q[i].y1 - 1, -tmp[Q[i].id]); T.clear(1, 0, N, Q[i].y1, Q[i].y2); s.erase(s.find(Q[i].y1 - 1)); s.erase(s.find(Q[i].y2)); &#125; else if (Q[i].type == 3) T.update(1, 0, N, Q[i].y1, 1); else ans[Q[i].id] = T.query(1, 0, N, Q[i].y1, *s.lower_bound(Q[i].y1)); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; D. Digit Division 考虑所有最短的可以被 mmm 整除的部分的个数 ccc，那么答案是 2c−12^{c-1}2c−1。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, m; char a[300005]; inline int poww(int a, int b) &#123; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, a + 1); int res = 0, c = 0; for (int i = 1; i &lt;= n; ++i) &#123; res = (res * 10 + a[i] - '0') % m; if (res == 0) ++c; &#125; if (res) puts(\"0\"); else printf(\"%d\\n\", poww(2, c - 1)); return 0; &#125; E. Export Estimate Portal.给定一个带权无向图，每次询问（互相独立）时：删掉边权 &lt;t&lt;t&lt;t 的边；枚举 i∈[1,n]i\\in [1,n]i∈[1,n]，如果是个孤立点直接删去，如果它的度数为 222 则将其连接的 (u,v)(u,v)(u,v) 之间连接一条新边（可能会连出重边），然后删掉 iii 自己。回答点的个数和边的个数。 经验和输入格式几乎已经告诉我们在线不可做。考虑将边按照边权从大到小排序，这样只会有加边操作，也就是说点的度数只会增加。 表面上看，只有度数为 000 的点和度数为 222 的点会产生影响。当有点的度数 0→10\\rightarrow 10→1 时，点的个数会增加。当度数 1→21\\rightarrow 21→2 时，边、点的个数均会减少 111。当 2→32\\rightarrow 32→3 时，则复原。 理想很美好，现实很骨感。由于操作是按照顺序进行的，因此在操作过程中点的度数也会发生改变。但手搓几个情况后发现这事其实没有什么关系，只有在这个连通块自己是个环的时候会被删成一个点加一个自环。 我们发现并查集，然后再维护一下每个连通块上不同度数的点的个数可以很好地完成这个问题。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, q; struct Edge &#123; int u, v, w; bool operator&lt; (const Edge &amp;a) const &#123; if (w != a.w) return w > a.w; return u > a.u; &#125; &#125; a[600005]; int tot, an1[300005], an2[300005]; int V, E; int fa[300005], sz[300005], sz2[300005], c[300005]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; int deg[300005]; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= m; ++i) cin >> a[i].u >> a[i].v >> a[i].w; cin >> q; tot = m; for (int i = 1; i &lt;= q; ++i) &#123; int w; cin >> w; ++tot; a[tot].v = i, a[tot].w = w; &#125; sort(a + 1, a + tot + 1); for (int i = 1; i &lt;= n; ++i) fa[i] = i, sz[i] = 1; int d0 = n, d2 = 0, cyc = 0, ec = 0; for (int i = 1; i &lt;= tot; ++i) &#123; if (a[i].u == 0) &#123; an1[a[i].v] = V, an2[a[i].v] = E; continue; &#125; int u = a[i].u, v = a[i].v; // cout &lt;&lt; \"T \" &lt;&lt; u &lt;&lt; \" \" &lt;&lt; v &lt;&lt; \"\\n\"; int uu = find(u), vv = find(v); if (!deg[u]) --d0; if (deg[u] == 2) --d2, --sz2[uu]; if (!deg[v]) --d0; if (deg[v] == 2) --d2, --sz2[vv]; ++deg[u]; ++deg[v]; if (c[vv]) c[vv] = 0, --cyc; if (uu != vv) &#123; if (c[uu]) c[uu] = 0, --cyc; fa[uu] = vv, sz[vv] += sz[uu], sz2[vv] += sz2[uu]; &#125; if (deg[u] == 2) ++d2, ++sz2[vv]; if (deg[v] == 2) ++d2, ++sz2[vv]; if (sz2[vv] == sz[vv]) c[vv] = 1, ++cyc; V = n - d0 - d2 + cyc; ++ec; E = ec - d2 + cyc; // cout &lt;&lt; d0 &lt;&lt; \" \" &lt;&lt; d2 &lt;&lt; \" \" &lt;&lt; cyc &lt;&lt; \"\\n\"; // cout &lt;&lt; sz[vv] &lt;&lt; \" \" &lt;&lt; sz2[vv] &lt;&lt; \"\\n\"; &#125; for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; an1[i] &lt;&lt; \" \" &lt;&lt; an2[i] &lt;&lt; \"\\n\"; return 0; &#125; F. Frightful Formula 有点意思的计数题。 发现递推式实际上是算带权的走到当前点的方案数。 首先考虑 a,ba,ba,b 的贡献，以 (1,i)(1,i)(1,i) 为例，它相当于是 (2,i)→(n,n)(2,i)\\rightarrow (n,n)(2,i)→(n,n)，因此贡献为 (n−2+n−in−2)×an−i×bn−1×val(1,i)\\dbinom{n-2+n-i}{n-2}\\times a^{n-i}\\times b^{n-1}\\times val(1,i)(n−2n−2+n−i​)×an−i×bn−1×val(1,i)。 然后再考虑 ccc 的贡献。再 (i,j)(i,j)(i,j) 处加入一个 ccc，会加上 (2n−i−jn−i)an−jbn−ic\\dbinom{2n-i-j}{n-i}a^{n-j}b^{n-i}c(n−i2n−i−j​)an−jbn−ic 的贡献。 直接做是 O(n2)O(n^2)O(n2) 的，不难想到考虑一条一条对角线去枚举，式子长这样： ∑k=0n−2(∑i=0k(ki)ak−ibi)+∑k=n−12n−4(∑i=k−n+2n−2(ki)ak−ibi)\\sum_{k=0}^{n-2}\\left(\\sum_{i=0}^{k}\\binom k i a^{k-i}b^i\\right)+\\\\ \\sum_{k=n-1}^{2n-4}\\left(\\sum_{i=k-n+2}^{n-2}\\binom k i a^{k-i}b^i \\right) k=0∑n−2​(i=0∑k​(ik​)ak−ibi)+k=n−1∑2n−4​(i=k−n+2∑n−2​(ik​)ak−ibi) 前面的一坨可以使用二项式定理来化简，后面那一坨可以使用增量法计算： f(k)=∑i=k−n+2n−2(ki)ak−ibi=∑i=k−n+2n−2(k−1i)ak−ibi+∑i=k−n+2n−2(k−1i−1)ak−ibi=afk−1−(k−1k−n+1)bk−n+1an−1+bfk−1−(k−1n−2)bn−1ak−n+1\\begin{aligned} f(k)&amp;=\\sum_{i=k-n+2}^{n-2}\\binom k i a^{k-i}b^i\\\\ &amp;=\\sum_{i=k-n+2}^{n-2}\\binom{k-1} i a^{k-i}b^i+\\sum_{i=k-n+2}^{n-2}\\binom{k-1}{i-1} a^{k-i}b^i\\\\ &amp;=af_{k-1}-\\binom{k-1}{k-n+1}b^{k-n+1}a^{n-1}+bf_{k-1}-\\binom{k-1}{n-2}b^{n-1}a^{k-n+1} \\end{aligned} f(k)​=i=k−n+2∑n−2​(ik​)ak−ibi=i=k−n+2∑n−2​(ik−1​)ak−ibi+i=k−n+2∑n−2​(i−1k−1​)ak−ibi=afk−1​−(k−n+1k−1​)bk−n+1an−1+bfk−1​−(n−2k−1​)bn−1ak−n+1​ 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000003; const int N = 400000; inline int poww(int a, int b) &#123; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int n, a, b, c, pa[400005], pb[400005]; int l[200005], t[200005]; int fac[400005], ifac[400005]; int f[400005]; inline int C(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || n &lt; m) return 0; return 1ll * fac[n] * ifac[m] * ifac[n - m] % P; &#125; int calf(int k) &#123; int res = 0; for (int i = k - n + 2; i &lt;= n - 2; ++i) res = (res + 1ll * C(k, i) * pa[k - i] * pb[i]) % P; return res; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> a >> b >> c; for (int i = fac[0] = pa[0] = pb[0] = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % P, pa[i] = 1ll * pa[i - 1] * a % P, pb[i] = 1ll * pb[i - 1] * b % P; ifac[N] = poww(fac[N], P - 2); for (int i = N - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; int ans = 0; for (int i = 1, x; i &lt;= n; ++i) &#123; cin >> x; if (i == 1) continue; ans = (ans + 1ll * C(n - 2 + n - i, n - 2) * pa[n - 1] * pb[n - i] % P * x) % P; &#125; for (int i = 1, x; i &lt;= n; ++i) &#123; cin >> x; if (i == 1) continue; ans = (ans + 1ll * C(n - 2 + n - i, n - 2) * pa[n - i] * pb[n - 1] % P * x) % P; &#125; for (int k = 0, B = 1; k &lt;= n - 2; ++k) &#123; ans = (ans + 1ll * c * B) % P; B = 1ll * B * (a + b) % P; &#125; for (int k = n - 1; k &lt;= n * 2 - 4; ++k) &#123; if (k == n - 1) f[k] = calf(k); else &#123; f[k] = (1ll * a * f[k - 1] - 1ll * C(k - 1, k - n + 1) * pb[k - n + 1] * pa[n - 1] + 1ll * b * f[k - 1] - 1ll * C(k - 1, n - 2) * pb[n - 1] * pa[k - n + 1]) % P; &#125; ans = (ans + 1ll * c * f[k]) % P; &#125; cout &lt;&lt; (ans + P) % P &lt;&lt; \"\\n\"; return 0; &#125; G. Greenhouse Growth 空间大盗扭曲了此处的空间。我们将于未知时间完成这道题目。 H. Hovering Hornet 时间旅人逆转了此处的时间。几何。 I. Ice Igloos 死灵法师抹除了此处的灵魂。几何。 J. Juice Junctions K. Kernel Knights 类似拓扑排序，直接算就行。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 200005; int n; int a[N], in[N], vis[N]; int main(void) &#123; cin >> n; for (int i = 1; i &lt;= 2 * n; ++i) scanf(\"%d\", a + i), ++in[a[i]]; queue&lt;int> q; for (int i = 1; i &lt;= 2 * n; ++i) if (!in[i]) q.emplace(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = 1; if (vis[a[u]] == -1) continue; vis[a[u]] = -1; if (--in[a[a[u]]] == 0) q.emplace(a[a[u]]); &#125; for (int i = 1; i &lt;= n; ++i) if (vis[i] == 1) printf(\"%d \", i); for (int i = n + 1; i &lt;= n * 2; ++i) if (vis[i] >= 0) printf(\"%d \", i); putchar('\\n'); return 0; &#125; * L. Looping Labyrinth 太牛逼了。 可以使用 (rB,cB,rT,cT)(r_B,c_B,r_T,c_T)(rB​,cB​,rT​,cT​) 代表一个坐标 (n×rB+rT,m×cB+cT)(n\\times r_B+r_T,m\\times c_B+c_T)(n×rB​+rT​,m×cB​+cT​)。将 (rB,cB)(r_B,c_B)(rB​,cB​) 称为块坐标，(rT,cT)(r_T,c_T)(rT​,cT​) 称为余坐标。 考虑所有余坐标为 (0,0)(0,0)(0,0) 的点， 制毒大枭投掷了神秘的毒药。我们将于未知时间补完。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"ICPC","slug":"算法竞赛/做题记录/ICPC","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ICPC/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CSP-S 2023 游记","slug":"summaries/游记/csp2023","date":"2023-10-19T00:00:00.000Z","updated":"2023-10-20T00:00:00.000Z","comments":true,"path":"7fbff67b/","link":"","permalink":"https://james1badcreeper.github.io/7fbff67b/","excerpt":"别慌~","text":"别慌~ 我们默认 Day0 不存在。 Day -2 yx 搞了一个 24 手速大赛，然后大家合伙找了一些简单的板子题。 我打的非常搞笑，ST 表 T 了五发，缩点建成了无向图，线段树 2 写了 12min。然后变成了二逼。 有卷怪没打，我不说是谁。 yx 榜一，狂膜。 但闪耀的芝士蛋挞可能做不太出来。 Day -1 在学校非常搞笑，鉴定为我是混子。 大红的声音很尖，某人的笑声很阴间。 Day 1 在来的路上认识了某个初中的同学，感觉挺牛。 令 0:00 为开始时间。 0:00 进不去考场。 0:10 开考，但是我的机器提示硬盘空间不足。 0:25 换完机器，申请延时，不同意。 0:35 写完 T1，发现读错题了。 0:50 改完 T1。 1:10 否决了直接算和区间 DP，直接考虑线性 DP 做法。写了一会儿发现假了，然后所有真做法都是 O(n2)O(n^2)O(n2) 的。 1:50 想不出来，写了 O(n2)O(n^2)O(n2)，然后发现转移点没有规律，然后各种思考都不会优化这个东西。 2:10 这 T3 是个啥啊。 2:20 T4 看上去比较可做，想了想先二分，然后贪心，应该是可行的。但是不会解一元二次方程，就想着二分一下。反正我的贪心是优先队列，也是双 log⁡\\loglog。 2:30 感觉 T3 65pts 比较可写。 2:50 T3 读错题了。 3:20 T3 写错了。 3:30 全面崩盘。 3:40 再去看 T4，先写 c=0c=0c=0，发现贪心好像是对的。然后很快地写了二分，发现大样例要 1.04s。 卡常，卡完之后 WA 了。于是摆烂。 4:00 T3 最多 151515，给 T2 补了一个数据随机的部分分。 4:10 交卷。 Day 1 After 发现大家都很会，于是自闭。 怎么 T2 有原题啊。 会挂多少呢。 果然，我只能停留在被染灰的大地。 T4 假了啊，那没事了。 Day2 看了 dx 的游记，发现我 T4 快读没判负数，然后过了大样例？？？？？？？？ 好吧其实是我自己的问题。 Day INF 官方数据 100+50+0+90，好重的水分。 加训。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"2023/10/14：暗流涌动","slug":"default/记录/2023/10/2023-10-14","date":"2023-10-14T00:00:00.000Z","updated":"2023-10-14T00:00:00.000Z","comments":true,"path":"26f5f7d4/","link":"","permalink":"https://james1badcreeper.github.io/26f5f7d4/","excerpt":"只有那些读懂迹象的人，才能明白什么正在，暗流涌动……","text":"只有那些读懂迹象的人，才能明白什么正在，暗流涌动…… 前言 抱歉鸽了好几天！！ 最近这段时间在为某些东西攒素材（写好了会放出来），所有做杂题的时间会变少许多。 大家都好强好强……只有我什么都学不会…… 本次的闲话被放在了文末，我们先来看题！ eJOI2018 今天来补 KHIN 的传教场。由于有题做过，因此压力比较小！！ 感谢 KH 曾经不停地传教让我能在今天摆一摆烂！！ 但事后发现我错了，剩下的题也太难写了！ Day1 嘿嘿嘿。 A. Hills Portal. 唉这个好像是 NOIP 期间随机 CF 计划随到的题？反正做过了。以下是原题解。 设 f(i,j,k)f(i,j,k)f(i,j,k) 为当前考虑到 iii，kkk 代表当前是不是需要满足的，jjj 代表总共满足的个数，转移取最小值就行。 #include &lt;bits/stdc++.h> using namespace std; int n; int a[5005]; int f[5005][2505][2]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0x3f, sizeof(f)); f[0][0][0] = f[1][0][0] = f[1][1][1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; f[i][0][0] = 0; for (int j = 1; j &lt;= (i + 1) / 2; ++j) &#123; f[i][j][0] = min(f[i - 1][j][0], f[i - 1][j][1] + max(0, a[i] - a[i - 1] + 1)); f[i][j][1] = min(f[i - 2][j - 1][0] + max(0, a[i - 1] - a[i] + 1), f[i - 2][j - 1][1] + max(&#123;0, a[i - 1] - a[i - 2] + 1, a[i - 1] - a[i] + 1&#125;)); &#125; &#125; for (int i = 1; i &lt;= (n + 1) / 2; ++i) printf(\"%d \", min(f[n][i][0], f[n][i][1])); putchar('\\n'); return 0; &#125; [ERROR] B. AB-strings Portal. tourist 的题果然神！！但是真难，好毒瘤，这场的最毒瘤的题。 在网上找不到说明白的题解！！这题真的只有 *2800 吗？ KH 说可以不补，那就开摆！ * C. Passports Portal. 个人认为是这场中仅次于循环排序的好题。 不难想到状压，而且 P≤2P\\le 2P≤2，因此 P=2P=2P=2 时只需要枚举子集然后对于子集和补集合并状压 DP 数组即可，因此这里只需要考虑 P=1P=1P=1。 设 fif_ifi​ 代表集合 iii 中的签证全部办理完成后的最小结束时间。转移采用刷表法，考虑限制是什么：一个时间内，旅行和办理签证做多做一种。由于签证时间越长越难整，因此按照签证办理时间从小到大枚举。如果我们依次检查其它国家的限制，那么时间复杂度为 O(n22n)O(n^2 2^n)O(n22n)。 但这个过程显然是具有单调性的。考虑从限制本身入手： 办理签证的时间不可以撞到出国的时间。 如果 ppp 正在办理签证，那么这个时间不能考虑办理签证。 按照 lll 从小到大考虑限制，维护两个指针来限制两条限制即可。 这样就可以 O(n2n)O(n2^n)O(n2n) 完成了。 #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; int n, P; int l[24], r[24], t[24], idl[24], idt[24], f[1 &lt;&lt; 24]; int ans[24][2], fr[1 &lt;&lt; 24]; void calc(int s, int id) &#123; if (!s) return; ans[fr[s]][0] = id; ans[fr[s]][1] = f[s] - t[fr[s]]; calc(s ^ (1 &lt;&lt; fr[s]), id); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> P; int u = 1 &lt;&lt; n; for (int i = 0; i &lt; n; ++i) cin >> l[i] >> r[i] >> t[i], r[i] += l[i] - 1, idl[i] = idt[i] = i; sort(idl, idl + n, [&amp;](int x, int y) &#123; return l[x] &lt; l[y]; &#125;); sort(idt, idt + n, [&amp;](int x, int y) &#123; return t[x] &lt; t[y]; &#125;); memset(f, 0x3f, sizeof f); f[0] = 1; for (int i = 0; i &lt; u; ++i) if (f[i] != INF) &#123; int L = 0, R = 0, now = f[i]; for (int k = 0; k &lt; n; ++k) &#123; int j = idt[k]; if (i >> j &amp; 1) continue; while (1) &#123; while (L &lt; n &amp;&amp; r[idl[L]] &lt; now) ++L; while (R &lt; n &amp;&amp; (!(i >> idl[R] &amp; 1) || l[idl[R]] &lt; now)) ++R; if (L &lt; n &amp;&amp; l[idl[L]] &lt;= now) &#123; now = r[idl[L]] + 1; continue; &#125; if (R &lt; n &amp;&amp; l[idl[R]] &lt;= now + t[j]) &#123; now = r[idl[R]] + 1; continue; &#125; break; &#125; if (now + t[j] &lt; l[j] &amp;&amp; now + t[j] &lt; f[1 &lt;&lt; j | i]) f[1 &lt;&lt; j | i] = now + t[j], fr[1 &lt;&lt; j | i] = j; &#125; &#125; if (P == 1) &#123; if (f[u - 1] == INF) &#123; return puts(\"NO\"), 0; &#125; puts(\"YES\"); calc(u - 1, 1); for (int i = 0; i &lt; n; ++i) printf(\"%d %d\\n\", ans[i][0], ans[i][1]); &#125; else &#123; for (int s = 0; s &lt; u; ++s) &#123; int t = u - 1 - s; if (f[s] == INF || f[t] == INF) continue; puts(\"YES\"); calc(s, 1); calc(t, 2); for (int i = 0; i &lt; n; ++i) printf(\"%d %d\\n\", ans[i][0], ans[i][1]); return 0; &#125; puts(\"NO\"); &#125; return 0; &#125; Day2 嘻嘻嘻。 A. Chemical table 不难猜到结论，将原图构建成二分图，然后应该一个点能到达所有点，DFS 求连通块数即可。 #include &lt;bits/stdc++.h> using namespace std; int n, m, q; vector&lt;int> G[400005]; bool vis[400005]; void dfs(int x) &#123; vis[x] = 1; for (int y : G[x]) if (!vis[y]) dfs(y); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m >> q; while (q--) &#123; int x, y; cin >> x >> y; G[x].emplace_back(n + y); G[n + y].emplace_back(x); &#125; int ans = 0; for (int i = 1; i &lt;= n + m; ++i) if (!vis[i]) dfs(i), ++ans; cout &lt;&lt; ans - 1 &lt;&lt; \"\\n\"; return 0; &#125; B. Prime Tree Portal. 之前说的“准备的素材”之一，放写过的题解。 由于题目中保证存在 X=0X=0X=0，随机一个排列然后按照条件贪心往树里填都是很容易出解的，因此直接随机化加贪心即可。 #include &lt;bits/stdc++.h> using namespace std; int n, id[100005], a[100005], tmp[100005], res; vector&lt;int> G[100005]; mt19937 Rand(time(0)); set&lt;int> s; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; void dfs(int x, int fa) &#123; if (res) return; for (int i : s) if (!fa || gcd(tmp[fa], id[i]) == 1) &#123; // 给当前点填数 tmp[x] = id[i]; s.erase(i); break; &#125; if (!tmp[x]) &#123; res = 1; return; &#125; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; vector&lt;int> tmp; G[i].swap(tmp); id[i] = i; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v), G[v].emplace_back(u); &#125; int ans = n; for (int op = 1;; ++op) &#123; shuffle(id + 1, id + n + 1, Rand); s.clear(); for (int i = 1; i &lt;= n; ++i) tmp[i] = 0, s.insert(i); res = 0; dfs(1, 0); if (res == 0) &#123; ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = tmp[i]; &#125; if (!ans) break; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); &#125; return 0; &#125; * C. Cycle Sort Portal. 被称作为“简单题”的构造题，但确实是好题。放写过的题解。 实际上可以套路地分析。 弱化题目条件。最优解？我不管！我们可以只交换两个数，但是这样还是很难办，数没有放的唯一位置，那么就先做排列！ 观察样例。比如样例 555，它合并了两个操作，但是后面多出了一个操作。手玩后发现操作是可以合并的，但是最后要多出来一个长度为合并的操作数的操作。 现在考虑怎么将这个做法扩展到可以重复的数上。排列给了什么便利？每个点的入度出度都为 111，但如果它不是排列，它只会满足入度出度相等。 可以使用有向图的方式刻画这个过程：将 aia_iai​ 的最终位置向 aia_iai​ 连边，然后在这个图上找环，并且每条边经过恰好一次。这是欧拉路！在存边的时候记录一下 iii，因为这就是方案。 #include &lt;bits/stdc++.h> using namespace std; int n, s, m; int a[200005], b[200005], to[200005]; bool vis[200005]; vector&lt;pair&lt;int, int>> G[200005]; vector&lt;bool> ban[200005]; vector&lt;vector&lt;int> > ans; vector&lt;int> road; int cur[200005]; void dfs(int x) &#123; vis[x] = 1; for (; cur[x] &lt; G[x].size(); ++cur[x]) if (!ban[x][cur[x]]) &#123; int y = G[x][cur[x]].first, w = G[x][cur[x]].second; ban[x][cur[x]] = 1; dfs(y); road.emplace_back(w); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;s); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) to[i] = a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; sort(to + 1, to + n + 1); // to 为最终的 a for (int i = 1; i &lt;= n; ++i) if (a[i] != to[i]) &#123; ++m; G[to[i]].emplace_back(a[i], i); ban[to[i]].emplace_back(0); &#125; if (m > s) return puts(\"-1\"), 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i] &amp;&amp; G[i].size()) &#123; road.clear(); dfs(i); ans.push_back(road); &#125; for (int i = 0; i &lt; ans.size(); ++i) reverse(ans[i].begin(), ans[i].end()); if (min(int(ans.size()), s - m) > 1) &#123; int t = min(int(ans.size()), s - m); road.clear(); road.emplace_back(ans[0][0]); for (int i = ans.size() - t + 1; i &lt; ans.size(); ++i) &#123; for (int x : ans[i]) ans[0].emplace_back(x); road.emplace_back(ans[i][0]); ans[i].clear(); &#125; for (int i = 1; i &lt; t; ++i) ans.pop_back(); reverse(road.begin(), road.end()); ans.push_back(road); &#125; printf(\"%u\\n\", ans.size()); for (int i = 0; i &lt; ans.size(); ++i) &#123; printf(\"%u\\n\", ans[i].size()); for (int x : ans[i]) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; 总结 题目质量：循环排序 &gt; 互素树 &gt; 护照 = AB-Strings。 看来机器人也是会说谎的。可能是每个人的观点不同。 蔚蓝之海 再次重读了一些东西，越来越觉得希特勒在二战前期的运气是真的好，好到离谱了。虽然不排除就是当时时代的原因。 最近听了一些比较神秘的歌，它们给我一种“暗流涌动”的感觉。就是你，二向箔降维打击。 波澜壮阔的背后，实则是太阳系的毁灭。为什么，会是这样呢…… 《克罗地亚狂想曲》用最为欢快的节奏描述了一个饱受战火摧残的残垣断壁；诺曼底用波光粼粼的海面描述了一场人类历史上规模最大的登陆作战。 为什么呢？这是为什么呢？ 绝望到空灵的程度，这是什么？ 在被摧毁的大地上获得新生——如克罗地亚废墟上的那朵白色小花。 在天际线，不要停留 After Memories 我可以告诉你，我现在写的这些东西也是在打素材，您信吗？ 本来这篇应该两天前就发的，但是一直鸽到了今天！都怪这几天太摆了（实际上身体出了一些奇怪的问题，而且一直在打素材）！ 不过现在好的差不多了，那就开始认真摆烂吧（ 不知道为什么想哭，也许与人的离别是常态，与过去的离别也是必然，跪倒在你的墓碑前，感叹着那连神都打不败的你。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"闲话","slug":"闲话","permalink":"https://james1badcreeper.github.io/categories/%E9%97%B2%E8%AF%9D/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"闲话","slug":"闲话","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"}]},{"title":"2023/10/10：孩童的双眸","slug":"default/记录/2023/10/2023-10-9","date":"2023-10-10T00:00:00.000Z","updated":"2023-10-10T00:00:00.000Z","comments":true,"path":"5c54da09/","link":"","permalink":"https://james1badcreeper.github.io/5c54da09/","excerpt":"未来的瞳孔！","text":"未来的瞳孔！ 近在咫尺的视野盲点？! 2023/10/9 上午模拟赛，笔者被锤烂了。 但是，为什么想不到呢？ 我通常将“直觉”作为导向，如果直觉是正确的，那么大概就有了。不过我做过的题少得可怜，因此直觉真的很不靠谱。什么都想不到，即使想到了也漏洞百出。 也许只有大量的训练才能根治这一问题，但也许我也看不见什么。 我们周围的环境中有着大量的微观粒子，它们都在阻挡我们的实现。也就是说，我们和瞎子无异。 造成这种情况实属可悲，但也无法避免。这是宇宙中最坏的结果，只能说可怜。 我们是低等文明吗？显然是。我们连地球上的东西都看不全。 也许那从来就不是盲点，这个世界的规则不许我们看到它们。亡灵游荡于世间，所认知的规则已经不再成立。 既然这样，视觉还有什么用呢？ 欢迎收看十月大型新番《暂时没有名字》，上集回顾，大家非常想看续集，那么我们日更！ 空间大盗与时间旅人 空间大盗是可以转移硬盘的存储顺序，从而让数据毁坏的。 我要向 @AC_love 宣战！学习自己喜欢的知识是一个人的自由，没有任何人可以阻止！ 我要向 ACL 投出加农炮！捍卫老年高二选手的强大学习能力与做题能力，我辈义不容辞！！即使我是高二最弱战斗力，我也要站出来，不依赖时间旅人朋友的力量，大战邪恶势力！！ 可以将这段话视作玩笑，没有任何引战的意思。大家好好学习，一起进步！ Deltix Summer 2021 (Div. 1 + Div. 2) Portal. 你猜猜为什么随机到了这场呢？ 我是——傻手！ Easy Problems 如果赶时间可以跳过。 A. A Variety of Operations Portal. 发现答案是 [−1,2][-1,2][−1,2]，直接搞。 #include &lt;bits/stdc++.h> using namespace std; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int c, d; scanf(\"%d%d\", &amp;c, &amp;d); if (d > c) swap(c, d); if ((c - d) % 2 != 0) puts(\"-1\"); else &#123; if (c == 0 &amp;&amp; d == 0) puts(\"0\"); else if (c == d) puts(\"1\"); else puts(\"2\"); &#125; &#125; return 0; &#125; B. Take Your Places! Portal. 对奇偶讨论一下就行。 #include &lt;bits/stdc++.h> using namespace std; int n, even, odd; int a[100005]; inline void calc1(void) &#123; if (even != odd) return puts(\"-1\"), void(); int suma = 0, sumb = 0; int posa = 1, posb = 2; for (int i = 1; i &lt;= n; ++i) if (a[i] % 2 == 0) &#123; suma += abs(posa - i); posa += 2; sumb += abs(posb - i); posb += 2; &#125; printf(\"%d\\n\", min(suma, sumb)); &#125; inline void calc2(void) &#123; if (abs(even - odd) != 1) return puts(\"-1\"), void(); if (even > odd) &#123; int pos = 1, ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] % 2 == 0) ans += abs(pos - i), pos += 2; printf(\"%d\\n\", ans); &#125; else &#123; int pos = 1, ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] % 2 == 1) ans += abs(pos - i), pos += 2; printf(\"%d\\n\", ans); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); even = 0, odd = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] % 2 == 0) ++even; else ++odd; &#125; if (n % 2 == 0) calc1(); else calc2(); &#125; return 0; &#125; C. Compressed Bracket Sequence Portal. O(n2)O(n^2)O(n2) 枚举即可。 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; i64 ans; int n, c[1005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", c + i); for (int l = 0; l &lt; n; l += 2) &#123; i64 cur = c[l], mn = c[l]; for (int r = l + 1; r &lt; n; ++r) if (r % 2 == 0) cur += c[r]; else &#123; i64 i = max(0ll, cur - c[r]); i64 j = min(&#123;mn, cur - 1, c[l] - 1ll&#125;); if (i &lt;= j) ans += j - i + 1; cur -= c[r]; mn = min(mn, cur); &#125; &#125; return !printf(\"%d\\n\", ans); &#125; D. Take a Guess Portal. 按位或加按位与等于运算加，解方程就行。 #include &lt;bits/stdc++.h> using namespace std; int n, k, a[10005]; int qsum(int x, int y) &#123; int s, t; cout &lt;&lt; \"and \" &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; cin >> s; cout &lt;&lt; \"or \" &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; cin >> t; return s + t; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> k; int x = qsum(1, 2), y = qsum(1, 3), z = qsum(2, 3); a[2] = (x - y + z) / 2; a[1] = x - a[2]; a[3] = z - a[2]; for (int i = 4; i &lt;= n; ++i) a[i] = qsum(1, i) - a[1]; nth_element(a + 1, a + k, a + n + 1); cout &lt;&lt; \"finish \" &lt;&lt; a[k] &lt;&lt; endl; return 0; &#125; Medium Problems 有一定难度的问题。 E. Equilibrium Portal. 套路地，令 vi=ai−biv_i=a_i-b_ivi​=ai​−bi​，每次可以将奇数位置 +1+1+1，偶数位置 −1-1−1，问最少操作次数使之变成 000。 将 vvv 前缀和一下，发现每次操作实际上是在前缀和区间上进行 k/2k/2k/2 组区间加。那么答案就直接推出来了：sl−1−min⁡{sl…r}s_{l-1}-\\min\\{s_{l\\dots r}\\}sl−1​−min{sl…r​}。当然需要判掉无解，也不难。 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, q; int a[100005]; i64 s[100005]; i64 mn[17][100005], mx[17][100005]; inline i64 qmin(int l, int r) &#123; int k = __lg(r - l + 1); return min(mn[k][l], mn[k][r - (1 &lt;&lt; k) + 1]); &#125; inline i64 qmax(int l, int r) &#123; int k = __lg(r - l + 1); return max(mx[k][l], mx[k][r - (1 &lt;&lt; k) + 1]); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> q; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1, x; i &lt;= n; ++i) cin >> x, a[i] -= x; for (int i = 1; i &lt;= n; ++i) mn[0][i] = mx[0][i] = s[i] = s[i - 1] + a[i]; for (int i = 1; i &lt;= 17; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mn[i][j] = min(mn[i - 1][j], mn[i - 1][j + (1 &lt;&lt; i - 1)]), mx[i][j] = max(mx[i - 1][j], mx[i - 1][j + (1 &lt;&lt; i - 1)]); while (q--) &#123; int l, r; cin >> l >> r; if (s[r] == s[l - 1] &amp;&amp; qmax(l, r) &lt;= s[l - 1]) cout &lt;&lt; s[l - 1] - qmin(l, r) &lt;&lt; \"\\n\"; else cout &lt;&lt; \"-1\\n\"; &#125; return 0; &#125; * F. Sports Betting Portal.有 n(n≤14)n(n\\le 14)n(n≤14) 个人，两两之间会打比赛。每人有一个实力值 aia_iai​，在 iii 与 jjj 的比赛中，iii 有 aiai+aj\\frac {a_i}{a_i+a_j}ai​+aj​ai​​ 的概率获胜，其他情况则是 jjj 获胜。iii 在与 jjj 的比赛中获胜则称 iii 打败了 jjj。若 iii 打败了 jjj，jjj 打败了 kkk，则认为 iii 也打败了 kkk。若 iii 打败了除了他自己以外的所有人，则称 iii 是一个 Winner（是否打败了自己不要求），注意 Winner 可能有多个。现在你需要求出 Winner 的期望数量，对 109+710^9+7109+7 取模。 考虑状压 DP，设 f(i,S)f(i,S)f(i,S) 代表 iii 打败了 SSS 中人的概率。容斥，答案为： f(i,S)=1−∑T⊂Sf(i,T)∏j∈S−T∏k∈Tajaj+akf(i,S)=1-\\sum_{T\\subset S}f(i,T)\\prod_{j\\in S-T}\\prod_{k\\in T} \\frac{a_j}{a_j+a_k} f(i,S)=1−T⊂S∑​f(i,T)j∈S−T∏​k∈T∏​aj​+ak​aj​​ 预处理 g(i,S)=∏j∈Sajaj+aig(i,S)=\\prod_{j\\in S} \\frac{a_j}{a_j+a_i}g(i,S)=∏j∈S​aj​+ai​aj​​，那么： f(i,S)=1−∑T⊂Sf(i,T)∏k∈Tg(k,S−T)f(i,S)=1-\\sum_{T\\subset S}f(i,T)\\prod_{k\\in T} g(k,S-T) f(i,S)=1−T⊂S∑​f(i,T)k∈T∏​g(k,S−T) 时间复杂度 O(n23n)O(n^2 3^n)O(n23n)。 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int N = 2000000; int n; int a[1 &lt;&lt; 14], f[14][1 &lt;&lt; 14], g[14][1 &lt;&lt; 14]; int inv[N + 5]; inline int lowbit(int x) &#123; return x &amp; -x; &#125; inline int calc(int T, int ST) &#123; int res = 1; for (int i = 0; i &lt; n; ++i) if (T >> i &amp; 1) res = 1ll * res * g[i][ST] % P; return res; &#125; int main(void) &#123; inv[1] = 1; for (int i = 2; i &lt;= N; ++i) inv[i] = 1ll * (P - P / i) * inv[P % i] % P; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;a[1 &lt;&lt; i]); for (int i = 0; i &lt; n; ++i) &#123; g[i][0] = 1; for (int s = 1; s &lt; 1 &lt;&lt; n; ++s) g[i][s] = 1ll * g[i][s ^ lowbit(s)] * a[lowbit(s)] % P * inv[a[lowbit(s)] + a[1 &lt;&lt; i]] % P; &#125; for (int i = 0; i &lt; n; ++i) for (int s = 0; s &lt; 1 &lt;&lt; n; ++s) if (s >> i &amp; 1) &#123; f[i][s] = 1; for (int t = (s - 1) &amp; s; t; t = (t - 1) &amp; s) f[i][s] = (f[i][s] - 1ll * f[i][t] * calc(t, s - t) % P) % P; &#125; int ans = 0; for (int i = 0; i &lt; n; ++i) ans = (ans + f[i][(1 &lt;&lt; n) - 1]) % P; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; Hard Problems 比较困难的问题。 ** G. Gates to Another World Portal.有 2n2^n2n 个点，编号为 i,ji,ji,j 的点之间有无向边当且仅当 popcount(i⊕j)=1\\mathrm{popcount}(i \\oplus j)=1popcount(i⊕j)=1。有 mmm 次操作，每次询问 a,ba,ba,b 是否能互相到达，或者删除编号在 [l,r][l,r][l,r] 之间的所有点，保证没有点会被删除两次。n≤50,m≤5×104n\\le 50,m\\le 5\\times 10^4n≤50,m≤5×104。 考虑逆时旅人，将删点改成加点。 最主要的问题是，如何用一种方式来压缩图？对于一个没有被删点的连续 2i2^i2i 段，一定是连通的。这种方式与线段树有直接关系，考虑用线段树结构来刻画这个东西，然后点数就与删点次数有关。 注意一个位置只会被删除一次，这很好，我们可以在线段树上区间染色，代表这些点存活到了 iii 时刻。 这样对于动态开点线段树上的存在的点，才是有意义的点，其余所有点都可以被映射到它们身上。对于每个节点将在 min⁡{lsi,rsi}\\min\\{ls_i,rs_i\\}min{lsi​,rsi​} 时刻将它的左右儿子分裂开（不再连通），逆时旅人并查集维护即可。 本题卡空间，注意你的内存消耗。 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 50005 * 120; struct Query &#123; string op; i64 x, y; &#125; Q[50005]; int n, m, ans[50005]; int fa[N + 5]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; int ls[N + 5], rs[N + 5], dat[N + 5], tot; #define leaf(o) (!ls[o] &amp;&amp; !rs[o]) inline void pushdown(int o) &#123; if (!ls[o]) ls[o] = ++tot; if (!rs[o]) rs[o] = ++tot; if (dat[o]) dat[ls[o]] = dat[rs[o]] = dat[o], dat[o] = 0; &#125; void update(int o, i64 l, i64 r, i64 x, i64 y, int t) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return dat[o] = t, void(); pushdown(o); i64 mid = l + r >> 1; if (x &lt;= mid) update(ls[o], l, mid, x, y, t); if (mid &lt; y) update(rs[o], mid + 1, r, x, y, t); &#125; int locate(int o, i64 l, i64 r, i64 p) &#123; if (leaf(o)) return o; i64 mid = l + r >> 1; if (p &lt;= mid) return locate(ls[o], l, mid, p); return locate(rs[o], mid + 1, r, p); &#125; vector&lt;pair&lt;int, int>> edge[50005]; void connect(int x, int y) &#123; if (leaf(x) &amp;&amp; leaf(y)) return edge[min(dat[x], dat[y])].emplace_back(x, y), void(); if (leaf(x)) return connect(x, ls[y]), connect(x, rs[y]); if (leaf(y)) return connect(ls[x], y), connect(rs[x], y); connect(ls[x], ls[y]); connect(rs[x], rs[y]); &#125; int main(void) &#123; for (int i = 1; i &lt;= N; ++i) fa[i] = i; ios_base::sync_with_stdio(0); cin >> n >> m; i64 u = 1ll &lt;&lt; n; dat[++tot] = m + 1; for (int i = 1; i &lt;= m; ++i) &#123; cin >> Q[i].op >> Q[i].x >> Q[i].y; if (Q[i].op == \"block\") update(1, 0, u - 1, Q[i].x, Q[i].y, i); &#125; for (int i = 1; i &lt;= tot; ++i) if (!leaf(i)) connect(ls[i], rs[i]); for (int i = m + 1; i >= 1; --i) &#123; for (auto [u, v] : edge[i]) fa[find(u)] = find(v); if (Q[i].op == \"ask\") ans[i] = (find(locate(1, 0, u - 1, Q[i].x)) == find(locate(1, 0, u - 1, Q[i].y))); &#125; for (int i = 1; i &lt;= m; ++i) if (Q[i].op == \"ask\") cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; ** H. DIY Tree Portal.给定一个 nnn 个点的无向带权完全图，找出一个满足第 i(i≤k)i(i\\le k)i(i≤k) 个度数 ≤di\\le d_i≤di​ 的最小生成树。n≤50,k≤5n\\le 50,k\\le 5n≤50,k≤5。 本题正解需要使用拟阵，但是此内容在算法竞赛中的应用不多，对笔者来说学习的收益过低，因此这里写一下本题的随机化做法。 sto lsy orz！ 给生成树定义估价函数 f(T)=∑i=1Kmax⁡{0,Di−di}f(T)=\\sum_{i=1}^K \\max\\{0,D_i-d_i\\}f(T)=∑i=1K​max{0,Di​−di​}，其中 DiD_iDi​ 代表实际度数。 先求出最小生成树，然后对其进行调整。每次选择一条边权最大的，删去后 fff 会减小的边 e1e_1e1​，替换成加上后 fff 不会变大的边权最小的边 e2e_2e2​，时间复杂度为 O(n3)O(n^3)O(n3)。 随机化这个过程，我们给 e1e_1e1​ 和 e2e_2e2​ 的选择加上一个概率，不选就接着扫。 #include &lt;bits/stdc++.h> using namespace std; mt19937 Rand(time(0)); int n, k; int a[55], G[55][55]; struct edge &#123; int u, v, w, f; edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; bool operator&lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125;; vector&lt;edge> e; int Ans = 1e9; int fa[55]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; int d[55]; inline int f(void) &#123; int r = 0; for (int i = 1; i &lt;= k; ++i) r += max(0, d[i] - a[i]); return r; &#125; void solve(void) &#123; // cerr &lt;&lt; \"SOLVE\\n\"; int ans = 0; for (int i = 1; i &lt;= n; ++i) fa[i] = i, d[i] = 0; for (auto &amp;it : e) &#123; it.f = 0; int u = find(it.u), v = find(it.v); if (u == v) continue; fa[u] = v; ans += it.w; ++d[it.u]; ++d[it.v]; it.f = 1; &#125; int now = 0; while (now = f()) &#123; // cerr &lt;&lt; now &lt;&lt; \"\\n\"; int p = -1; while (p == -1) &#123; for (int i = e.size() - 1; i >= 0; --i) &#123; auto &amp;it = e[i]; if (it.f &amp;&amp; (d[it.u] > a[it.u] || d[it.v] > a[it.v]) &amp;&amp; Rand() % 4) &#123; --d[it.u], --d[it.v]; ans -= it.w; it.f = 0; p = i; break; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (auto &amp;it : e) if (it.f) fa[find(it.u)] = find(it.v); int tmp = 1e9; for (int i = 0; i &lt; e.size(); ++i) &#123; auto &amp;it = e[i]; if (i != p &amp;&amp; !it.f &amp;&amp; find(it.u) != find(it.v)) &#123; ++d[it.u]; ++d[it.v]; tmp = min(tmp, f() - now); --d[it.u]; --d[it.v]; &#125; &#125; bool flag = 0; while (!flag) &#123; for (int i = 0; i &lt; e.size(); ++i) &#123; auto &amp;it = e[i]; if (i != p &amp;&amp; !it.f &amp;&amp; find(it.u) != find(it.v)) &#123; ++d[it.u]; ++d[it.v]; if ((f() - now &lt; 0 || tmp >= 0) &amp;&amp; Rand() % 4) &#123; it.f = 1, ans += it.w, flag = 1; break; &#125; --d[it.u]; --d[it.v]; &#125; &#125; &#125; &#125; Ans = min(Ans, ans); &#125; int main(void) &#123; ios_base::sync_with_stdio(0); cin >> n >> k; for (int i = 1; i &lt;= k; ++i) cin >> a[i]; for (int i = k + 1; i &lt;= n; ++i) a[i] = 1e9; for (int i = 1, x; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) cin >> x, e.emplace_back(i, j, x); sort(e.begin(), e.end()); double st = clock(); do solve(); while (1000 * (clock() - st) / CLOCKS_PER_SEC &lt; 5700); cout &lt;&lt; Ans &lt;&lt; \"\\n\"; return 0; &#125; After Memories 我们可以相信我们的视觉吗？ 在当下的情况，也许我们可以小心翼翼地踱步，来保证不要看不清会导致我们摔倒的东西。 但这也只是表象，我们依然无法看清一切。当忽略的东西足够多，终将酿成大祸。 也许这就是生命终结的原因。如果有生物可以看清一切，那我相信它们是永生的。 愿你能在遥远的天际线边找到自我","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"闲话","slug":"闲话","permalink":"https://james1badcreeper.github.io/categories/%E9%97%B2%E8%AF%9D/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"闲话","slug":"闲话","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"}]},{"title":"NOI 一轮复习 V：动态规划","slug":"notes/NOI 复习/noi-1-5","date":"2023-10-05T00:00:00.000Z","updated":"2024-04-14T00:00:00.000Z","comments":true,"path":"10a85982/","link":"","permalink":"https://james1badcreeper.github.io/10a85982/","excerpt":"本文是 NOI 一轮复习的第五篇，包括动态规划的状态设计和转移优化。","text":"本文是 NOI 一轮复习的第五篇，包括动态规划的状态设计和转移优化。 动态规划是 OI 最重要的部分之一。从学习与做题的角度来说，主要分为设计状态与优化两部分。其中前者更多的是做题和总结方法与套路，而后者相对吃经验。 值得注意的是，很多题目都要求我们在设计算法以前先将题目进行一定的转化，从而将一个不熟悉的模型转化为我们更容易把握的模型。这一点在动态规划的题目中体现的尤为明显。 动态规划的状态设计 注意基本模型。 线性 DP 在线性结构上枚举每一维度进行转移的 DP。 [CF1810G] The Maximum Prefix。较复杂，见原题面。 对于任意一段后缀，其能对整个序列的最大前缀和产生贡献的都是其最大前缀和。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，[i+1,n][i+1,n][i+1,n] 的最大前缀和为 jjj 的期望答案。可以以 pip_ipi​ 的系数转移到 fi+1,max⁡{j−1,0}f_{i+1,\\max\\{j-1,0\\}}fi+1,max{j−1,0}​，1−pi1-p_i1−pi​ 的系数转移到 fi+1,j+1f_{i+1,j+1}fi+1,j+1​。 答案便是 fi,0f_{i,0}fi,0​。代码。 背包 基本模型：01 背包、完全背包、多重背包、分组背包、方案数背包的撤回（将转移的东西减去即可）。 [十二省联考 2019] 皮配。机械大师有 ccc 个工具箱，nnn 个螺丝，每个螺丝都有自己的质量，需要将螺丝设定为普通螺钉/自攻螺钉、三角螺纹/方螺纹。一个工具箱里的螺丝必须都是普通螺钉，或者都是自攻螺钉。要求 普通/自攻/三角/方 的螺丝总质量不超过 C0,C1,D0,D1C_0,C_1,D_0,D_1C0​,C1​,D0​,D1​。有 KKK 个螺丝不可以被设定成某种螺丝（如不能设定为三角自攻）。问有多少种方案，对 998244353998244353998244353 取模。n,c≤103,k≤30n,c\\le 10^3,k\\le 30n,c≤103,k≤30。 为方便分析时间复杂度，记 M=max⁡{C,D}M=\\max\\{C,D\\}M=max{C,D}。 考虑 K=0K=0K=0 怎么做。分别考虑划分两种特征，两次背包分别对工具箱和螺丝进行 DP 即可。 发现 KKK 很小，考虑针对它设计状态。对于不是这 KKK 个没事找事的螺丝，前面的 DP 做法依然成立。然后再考虑这些没事找事的。 设 F(i,j,k)F(i,j,k)F(i,j,k) 代表考虑前 iii 个工具箱，普通螺钉的重量为 jjj，三角螺纹的重量为 kkk。需要枚举当前的选的东西是什么和上一个东西是什么。滚掉 iii 这一维，所有状态都是可以转移的，考虑用这种方式处理没事找事的螺丝，时间复杂度为 O(k2wM)O(k^2 w M)O(k2wM)。 然后枚举体积，进行背包合并即可。代码。 区间 DP 区间 DP 有两种，分别是从两边扩展和中间枚举断点的。如果信息可以“合并”，那么大概率是区间 DP。 [THUPC2021] 小 E 爱消除。较复杂，见原题面。 不难想到区间 DP，考虑 gl,rg_{l,r}gl,r​ 代表 [l,r][l,r][l,r] 的最小剩余数和栈大小。转移时可以直接将 lll 或 rrr 放进栈中，也可以在 [l,r][l,r][l,r] 中寻找一个 iii 与 lll 或 rrr 删除。以 ala_lal​ 和 aia_iai​ 配对为例，考虑保留一段 [i+1,j][i+1,j][i+1,j] 或者是 [j,i−1][j,i-1][j,i−1]，则需要将剩下的两端完全删除，中间会夹一个 iii 和另一端需要处理的内容，判断两端是否完全删除依然可以采用区间 DP。时间复杂度为 O(n6)O(n^6)O(n6)，但是非法状态很多，可以通过。代码。 图上 DP 树上 DP 一般按照拓扑序进行求解，注意合并时是加边还是加点。 换根 DP。如果一条边的贡献可以很简单的转化，那么可以简单将 DP 的根换走。 DAG &amp; 图 上 DP 图可以考虑缩点成 DAG，然后按照拓扑序进行 DP 即可。 [六省联考 2017] 摧毁树状图。在 n(n≤105)n(n\\le 10^5)n(n≤105) 个点的树上寻找两条没有边相交的路径，使得删去它们后的连通块数尽可能多。 只有两种情况： 两条路径存在一个点重合。这样只要找到根出发的前四大链即可。 不存在重合。考虑枚举子树，其中一条路径经过这个子树的根，然后子树外再找一条最优路径。 状态列表： dpxdp_xdpx​ 表示考虑 xxx 为根的子树去掉一条一个端点为 xxx 的最大连通块数； mxx,kmx_{x,k}mxx,k​ 代表以 xxx 为根的子树中，dp(y)dp(y)dp(y) 的 kkk 大值； fpxfp_xfpx​ 代表去掉一条经过 xxx 的链的最大连通块数； fxf_xfx​ 代表去掉子树内一条路径的最大连通块数，需要记录儿子中最大的 fff 来进行转移。 发现当 xxx 是否不是根会直接影响 fff 的答案，依次记录 f0/1f_{0/1}f0/1​ 来解决这个问题。 以上所有状态均可以换根计算。为了换根，需要记录 fmxfmxfmx 的次大值。换根过程异常麻烦。 int n, ans; vector&lt;int> G[100005]; int dp[100005]; // 去掉一个以 x 为端点的链后连通块最大数量 int mx[100005][4]; // 以 x 为根，dp(y) 的 k 大值 int fp[100005]; // 去掉经过 x 的路径后连通块最大数量 int f[100005][2]; // x 的子树中最大连通块数量 / 删掉 x 之后 x 外面还有连通块 int fmx[100005][2]; // f[y][1] 最次大值 inline void change(int x, int v) &#123; for (int i = 0; i &lt; 4; ++i) if (mx[x][i] &lt; v) swap(mx[x][i], v); &#125; inline void fchange(int x, int v) &#123; for (int i = 0; i &lt; 2; ++i) if (fmx[x][i] &lt; v) swap(fmx[x][i], v); &#125; void dfs(int x, int fa) &#123; dp[x] = mx[x][0] = mx[x][1] = mx[x][2] = mx[x][3] = -INF; fp[x] = f[x][0] = f[x][1] = fmx[x][0] = fmx[x][1] = -INF; int cnt = 0; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); ++cnt; change(x, dp[y]); fchange(x, f[y][1]); &#125; dp[x] = max(cnt, mx[x][0] + cnt - 1); fp[x] = max(dp[x], mx[x][0] + mx[x][1] + cnt - 2); f[x][0] = max(fp[x], fmx[x][0]); f[x][1] = max(fp[x] + 1, fmx[x][0]); &#125; void dfs2(int x, int fa) &#123; int sum = G[x].size(); ans = max(ans, sum); for (int i = 0; i &lt; 4; ++i) ans = max(ans, sum += mx[x][i] - 1); int cnt = G[x].size() - 1; for (int y : G[x]) if (y != fa) &#123; int p = -1; for (int i = 0; i &lt; 4; ++i) if (mx[x][i] == dp[y]) p = i; int mx0 = mx[x][0], mx1 = mx[x][0] + mx[x][1], mx2 = fmx[x][0]; if (p == 0) mx0 = mx[x][1], mx1 = mx[x][1] + mx[x][2]; if (p == 1) mx1 = mx[x][0] + mx[x][2]; if (fmx[x][0] == f[y][1]) mx2 = fmx[x][1]; dp[x] = max(cnt, mx0 + cnt - 1); fp[x] = max(dp[x], mx1 + cnt - 2); f[x][0] = max(fp[x], mx2); f[x][1] = max(fp[x] + 1, mx2); ans = max(ans, f[x][0] + fp[y]); change(y, dp[x]); fchange(y, f[x][1]); dfs2(y, x); &#125; &#125; 动态 DP Portal.给定一棵 nnn 个点的点权树，支持修改点的点权，查询树最大独立集的权值大小。 依然设 fi,1/0f_{i,1/0}fi,1/0​ 代表对于 iii 的子树是否选则第 iii 个节点，子树内的独立集最大大小。 如何支持修改？对原树进行重链剖分，设 gi,1/0g_{i,1/0}gi,1/0​ 代表 iii 的子树不考虑重儿子的情况下的答案。有： fi,0=gi,0+max⁡{fsoni,0,fsoni,1}fi,1=gi,1+fsoni,0f_{i,0}=g_{i,0}+\\max\\{f_{son_i,0},f_{son_i,1}\\}\\\\ f_{i,1}=g_{i,1}+f_{son_i,0} fi,0​=gi,0​+max{fsoni​,0​,fsoni​,1​}fi,1​=gi,1​+fsoni​,0​ 我们定义另一种矩阵乘法（将其称为 max⁡,+\\max,+max,+ 卷积，需要满足 +++ 有结合律，max⁡\\maxmax 对 +++ 有分配律）： Ci,j=max⁡k=1nAi,k+Bk,jC_{i,j}=\\max_{k=1}^n A_{i,k}+B_{k,j} Ci,j​=k=1maxn​Ai,k​+Bk,j​ 则有： [fsoni,0fsoni,1]×[gi,0gi,1gi,0−∞]=[fi,0fi,1]\\begin{bmatrix} f_{son_i,0} &amp; f_{son_i,1} \\end{bmatrix}\\times \\begin{bmatrix} g_{i,0} &amp; g_{i,1}\\\\ g_{i,0} &amp; -\\infty \\end{bmatrix}= \\begin{bmatrix} f_{i,0} &amp; f_{i,1} \\end{bmatrix} [fsoni​,0​​fsoni​,1​​]×[gi,0​gi,0​​gi,1​−∞​]=[fi,0​​fi,1​​] 这样在一条重链上就可以直接用线段树维护答案，我们只需要保证含 111 的那条链上的东西都是对的就行了（我们只需要保证 111 的答案正确，剩下的让它自生自灭即可）。 我们相当于从一个权值为 000 的叶子节点开始 DP，注意 DFS 序大的应该先乘，所以线段树的维护顺序应该是从右到左。修改时，当前节点的 gi,1g_{i,1}gi,1​ 会改变，然后直接考虑重链顶端父亲的答案改变，改的是当前节点的一个轻儿子，计算改变量即可。 void dfs(int x, int fa) &#123; siz[x] = 1; ::fa[x] = fa; f[x][1] = a[x]; for (int i = hd[x]; i; i = nxt[i]) &#123; int y = to[i]; if (y != fa) &#123; dfs(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; f[x][1] += f[y][0]; f[x][0] += max(f[y][0], f[y][1]); &#125;&#125; &#125; void dfs2(int x, int topf) &#123; idx[L[x] = ++num] = x; R[top[x] = topf] = num; g[x].a[0][1] = a[x]; g[x].a[1][1] = -INF; if (!son[x]) return; dfs2(son[x], topf); for (int i = hd[x]; i; i = nxt[i]) &#123; int y = to[i]; if (y != son[x] &amp;&amp; y != fa[x]) &#123; dfs2(y, y); g[x].a[0][1] += f[y][0]; g[x].a[0][0] += max(f[y][0], f[y][1]); &#125;&#125; g[x].a[1][0] = g[x].a[0][0]; &#125; inline void update(int x, int k) &#123; g[x].a[0][1] += k - a[x]; a[x] = k; while (x) &#123; int y = top[x]; Matrix lst = T[rt[y]].dat; update(rt[y], L[y], R[y], L[x]); Matrix now = T[rt[y]].dat; x = fa[y]; g[x].a[0][0] += max(now.a[0][0], now.a[0][1]) - max(lst.a[0][0], lst.a[0][1]); g[x].a[1][0] = g[x].a[0][0]; g[x].a[0][1] += now.a[0][0] - lst.a[0][0]; &#125; &#125; 其它 DP 一些杂项内容。 插入法 一种较为特殊的状态设计方法，大概类似于 fi,jf_{i,j}fi,j​ 表示 iii 个数划分成 jjj 段的方案数。 [CEOI2016] kangaroo.构造一个排列，左右是 s,ts,ts,t，任意元素满足它左右两个都比它大或都比它小。n≤2000n\\le 2000n≤2000。 常规方法并不好处理，考虑一种以插入为转移的 DP。设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，将序列划分成 jjj 段的方案数。 考虑从 1∼n1\\sim n1∼n 依次放置数。一个数可以用来新增一个段（如果首尾已经放了 s,ts,ts,t 就不能再放），也可以用来合并段（jjj 种选择）。如果它是 s,ts,ts,t 那么只能将它放到首尾。 最终答案为 fn,1f_{n,1}fn,1​。 for (int i = 2; i &lt;= n; ++i) if (i != s &amp;&amp; i != t) &#123; for (int j = 1; j &lt;= i; ++j) &#123; int c = (i > s) + (i > t); f[i][j] = (1ll * j * f[i - 1][j + 1] + 1ll * (j - c) * f[i - 1][j - 1]) % P; &#125; &#125; else &#123; for (int j = 1; j &lt;= i; ++j) f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % P; &#125; 数位 DP 求解值域中满足某个条件的数的个数。采用 DFS 实现，枚举当前位数和各类信息。 [Luogu P5128] 好时光。给出 n,kn,kn,k，求 ∑i=1nf(i,k)\\sum_{i=1}^n f(i,k)∑i=1n​f(i,k) 的值，f(i,k)f(i,k)f(i,k) 定义为将十进制整数 iii 表示为 kkk 进制时写成一个数列的形式中的最长连续子串为等差数列的长度。答案取模 192608211926082119260821。对于 100%100\\%100% 的数据，2≤k≤60,1≤n≤k182\\le k\\le 60,1\\le n\\le k^{18}2≤k≤60,1≤n≤k18。 记录前两位的数值就可以确定等差数列。 int k, l; int a[1005]; string n; vector&lt;int> num; // k 进制形式 int f[19][61][61][19][19]; int dp(int p, int p1, int p2, int ans, int res, bool lim) &#123; ans = max(ans, res); if (p &lt; 0) return ans; if (!lim &amp;&amp; f[p][p1][p2][ans][res] != -1) return f[p][p1][p2][ans][res]; int mx = lim ? num[p] : (k - 1), cnt = 0; for (int i = 0; i &lt;= mx; ++i) &#123; bool nl = (lim &amp; (i == mx)); if (p1 == k &amp;&amp; p2 == k) &#123; if (i) add(cnt, dp(p - 1, i, k, 1, 1, nl)); else add(cnt, dp(p - 1, k, k, 0, 0, nl)); &#125; else if (p2 == k) add(cnt, dp(p - 1, i, p1, 2, 2, nl)); else if (p2 - p1 == p1 - i) add(cnt, dp(p - 1, i, p1, ans, res + 1, nl)); else add(cnt, dp(p - 1, i, p1, ans, 2, nl)); &#125; if (!lim) f[p][p1][p2][ans][res] = cnt; return cnt; &#125; int main(void) &#123; memset(f, -1, sizeof f); cin >> n >> k; l = n.length(); for (int i = 0; i &lt; l; ++i) a[i] = n[l - i - 1] - '0'; while (l) &#123; int r = 0; for (int i = l - 1; i >= 0; --i) &#123; int t = r; r = (r * 10 + a[i]) % k; a[i] = (t * 10 + a[i]) / k; &#125; while (l &amp;&amp; !a[l - 1]) --l; num.emplace_back(r); &#125; return cout &lt;&lt; dp(num.size() - 1, k, k, 0, 0, 1) &lt;&lt; \"\\n\", 0; &#125; 例题 难度可能比较大。 [ABC313Ex] Group Photo Portal. 序列可以重排列，直接按照顺序递推便不太能做。但是要钦定一个顺序，发现按值的大小很适合。不难想到插入法。 设 fi,jf_{i,j}fi,j​ 代表填前 iii 个元素，有 jjj 个段满足原题条件的方案数，考虑 ai+1a_{i+1}ai+1​ 填到哪里（此时 bbb 应该填 bi+j+1b_{i+j+1}bi+j+1​）： 将其放到一个连续段的左侧或者右侧，fi+1,j←+fi,j×2×jf_{i+1,j}\\stackrel{+}{\\leftarrow}f_{i,j}\\times 2\\times jfi+1,j​←+fi,j​×2×j，需要满足 bi+j+1&gt;aib_{i+j+1}&gt;a_ibi+j+1​&gt;ai​ 才能满足条件； 合并两个连续段，fi+1,j−1←+fi,j×(j−1)f_{i+1,j-1}\\stackrel{+}{\\leftarrow}f_{i,j}\\times (j-1)fi+1,j−1​←+fi,j​×(j−1)，没有任何条件就可以转移； 新增一个连续段，fi+1,j+1←+fi,j×(j+1)f_{i+1,j+1}\\stackrel{+}{\\leftarrow}f_{i,j}\\times (j+1)fi+1,j+1​←+fi,j​×(j+1)，需要满足 min⁡{bi+j+1,bi+j+2}&gt;ai\\min\\{b_{i+j+1},b_{i+j+2}\\}&gt;a_imin{bi+j+1​,bi+j+2​}&gt;ai​。 a,ba,ba,b 均从小到大排序即可转移。代码。 [AT DP] Subtree Portal. 由于逆元不一定存在，所以设 fif_ifi​ 代表以 iii 为根的子树内染黑点的方案数，gig_igi​ 代表 iii 子树外的方案数。然后直接树形 DP 和换根即可。代码。 动态规划的转移优化 虽然套路非常多，但无非就两种：针对单调性的优化和数据结构优化。 wqs 二分 我们可以使用 wqs 二分对 DP 进行降维。 wqs 二分的状态的其中一维是物品个数。这是它的明显标志，因此它比较套路。fif_ifi​ 表示恰好（最多/至少）选取 iii 个物品时的答案，如果 fff 是凸函数那么则可以使用 wqs。我们可以猜测 O(nk)O(nk)O(nk) 过不去就是凸的，或者也可以打表。 由于 fff 是凸的，因此我们可以选择二分斜率，以此计算出它的切线。有时它能直接用，有时可以对 DP 进行降维，有时和斜率优化等内容一起出现。 具体来说，我们画出所有点 (i,f(i))(i,f(i))(i,f(i))，假设它们构成一个上凸壳。二分斜率 kkk，发现随着 kkk 的减小，直线的切点会越来越靠右。 因此二分 kkk 直到横坐标切到我们想要的位置（比如恰好选择 mmm 个数），那么此时的纵坐标就是答案了。 如何求出切点？我们希望这个切点的 yyy 坐标最大，也就是在 yyy 轴上的截距最大。设截距为 g(x)g(x)g(x)，那么切点 (x,f(x))(x,f(x))(x,f(x)) 在 yyy 轴上的截距就是 g(x)=f(x)−kxg(x)=f(x)-kxg(x)=f(x)−kx。问题就是如何求出 g(x)g(x)g(x) 的值了。 考虑 g(x)g(x)g(x) 的意义，相当于钦定的 xxx 个物品的代价都比原来少 kkk，g(x)g(x)g(x) 相当于每个物品代价减 kkk 之后的最优解。 l,rl,rl,r 如何调整？要逼近 (m,f(m))(m,f(m))(m,f(m)) 如果此时切点 (x,f(x))(x,f(x))(x,f(x)) 满足 x&lt;mx&lt;mx&lt;m 时，那么应该将斜率减小，才能让切点右移。 [ARC168E] Subsegments with Large Sums Portal. 直接 wqs，错了，因为不是凸的。 二分答案，现在是说，答案为 xxx，是否能够划出 kkk 个连续段？设 fnf_nfn​ 划出 xxx 个段满足条件，最小的代价。为 fn≤n−kf_n\\le n -kfn​≤n−k 时合法，wqs 二分即可。代码。 决策单调性优化 决策单调性分治常见于 2D / 1D 动态规划，其中一维是转移层数，且从一层仅转移至下一层。 如果有决策单调性，那么应该使用四边形不等式去证明，但是一般来讲 assert 可能更有说服力。 如果采用分治实现，那么应该满足在计算 fif_ifi​ 的时候 f0∼i−1f_{0\\sim i-1}f0∼i−1​ 全部已知。如果不能，则需要套上一层 CDQ 分治。这样的时间复杂度是 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)，但是其优点是可以快速计算无法计算答案，但是可以快速计算增量的贡献，直接跟踪分治中心计算即可。 如果区间贡献可以直接快速计算，那么我们使用二分栈或者二分队列即可，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 斜率优化 数据结构优化 动态规划杂项 一些动态规划的杂项内容。 自动机上 DP 我们可以在字符串自动机（KMP 自动机、AC 自动机等）上进行 DP，DP 自动机上也是可以的。 人脑自动机 [AGC055C] Weird LIS.记 f(p)f(p)f(p) 表示排列 ppp 的最长上升子序列长度。记 PiP_iPi​ 表示排列 ppp 去掉第 iii 个数的序列。求有多少长为 NNN，值域为 [2,M][2,M][2,M] 的序列 aaa 使得：存在一个排列 ppp，∀i\\forall i∀i 有 f(Pi)=aif(P_i)=a_if(Pi​)=ai​。 设 ppp 的 LIS 长度为 KKK，那么应该有 ai∈[K,K−1]a_i\\in [K,K-1]ai​∈[K,K−1]。我们将 ai←ai−Ka_i\\leftarrow a_i-Kai​←ai​−K。 排列上的数可以划分成四种类型： 只有绿点和红点可以让 KKK 增加，只有绿点在 aaa 处填写的是 −1-1−1，其余都是 000。 让红黑匹配尽可能地先出现，也就是说只让黑点靠着红点出现，那么 fi,kf_{i,k}fi,k​ 代表其结尾的性质为 iii，当前 K=kK=kK=k，考虑人脑建出自动机： i=0i=0i=0，放了一个绿，下一个什么都能放。 i=1i=1i=1，放了一个红，下一个只能是黑色。 i=2i=2i=2，放了一个蓝，下一个只能放绿或蓝。放蓝的话，就不能再放红黑对了。 i=3i=3i=3，放完红黑对了，那么下一个点只能放绿色或蓝色。再放一个蓝，则不能放置红黑对了。因为我们需要尽可能让红黑对出现在前面。 实际上，蓝蓝红黑和红黑蓝蓝是等价的状态（转移 333），蓝红黑和红黑蓝也是等价的状态，黑点只是为了给红点提供一个匹配，来保证其在删去后不会让 aaa 的值发生改变。这是这样转移的原因。 如何统计答案？首先最后不能停留在 111，然后对于 K=2,n−1K=2,n-1K=2,n−1 进行一个特判即可。代码。 DP 套 DP 本质上就是内层 DP 的结果作为外层 DP 的状态，内层压的东西一般可以看成一个 bool 数组，表示外层的状态是否能够取到，外层在内层 DP 建成的 DP 自动机上进行 DP。这样状态数可能很多，所以往往需要以实际搜出来的结果为准。 [TJOI2018] 游园会。求长度为 nnn，字符集为 N,O,I\\text{N,O,I}N,O,I，且不能出现子串 NOI\\text{NOI}NOI，与给定字符串 SSS 的 LCS 为 lenlenlen（需要求出所有的 lenlenlen 对应的答案）的长度。n≤1000,∣S∣≤15n\\le 1000, |S|\\le 15n≤1000,∣S∣≤15。 LCS 是什么？像这样： LCSx,y={LCSx−1,y−1+1,Ax=By,max⁡{LCSx−1,y,LCSx,y−1},Ax≠By.\\text{LCS}_{x,y}= \\begin{cases} \\text{LCS}_{x-1,y-1}+1&amp;,A_x=B_y,\\\\ \\max\\{\\text{LCS}_{x-1,y},\\text{LCS}_{x,y-1}\\}&amp;,A_x\\neq B_y.\\\\ \\end{cases} LCSx,y​={LCSx−1,y−1​+1max{LCSx−1,y​,LCSx,y−1​}​,Ax​=By​,,Ax​=By​.​ 我们对 LCS 取一遍前缀最大值。把这个 LCS 的 DP 数组作为状态压进 DP（当其中一维固定时，LCS 数组的前缀最大值差分后可以得到一个 01 序列，状压后就可以压进去）。这相当于自动机上的一个点，枚举出满足不出现子串 NOI 的字符作为自动机的转移，计算出转移到的自动机上的点并更新方案数。 int n, k, ans[20], a[20], b[20]; // LCS(i, ...) char s[20]; int f[2][35005][3]; // 考虑到字符串的第 i 位，当前 \"NOI\" 子串的长度为 k void decode(int *a, int ret) &#123; for (int i = 0; i &lt; k; ++i) a[i + 1] = (ret >> i &amp; 1) + a[i]; &#125; int encode(int *a) &#123; int ret = 0; for (int i = 0; i &lt; k; ++i) ret |= (a[i + 1] - a[i]) &lt;&lt; i; return ret; &#125; void dp(int now, int t, int p, char c, int w) &#123; decode(a, t); for (int i = 1; i &lt;= k; ++i) b[i] = max(&#123;b[i - 1], a[i], a[i - 1] + (c == s[i])&#125;); t = encode(b); f[now][t][p] = (f[now][t][p] + w) % P; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;k, s + 1); f[0][0][0] = 1; for (int i = 0; i &lt; n; ++i) &#123; memset(f[i - 1 &amp; 1], 0, sizeof(f[i - 1 &amp; 1])); for (int j = 0; j &lt; 1 &lt;&lt; k; ++j) &#123; if (f[i &amp; 1][j][0]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][0]); dp(i - 1 &amp; 1, j, 0, 'O', f[i &amp; 1][j][0]); dp(i - 1 &amp; 1, j, 0, 'I', f[i &amp; 1][j][0]); &#125; if (f[i &amp; 1][j][1]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][1]); dp(i - 1 &amp; 1, j, 2, 'O', f[i &amp; 1][j][1]); dp(i - 1 &amp; 1, j, 0, 'I', f[i &amp; 1][j][1]); &#125; if (f[i &amp; 1][j][2]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][2]); dp(i - 1 &amp; 1, j, 0, 'O', f[i &amp; 1][j][2]); &#125; &#125; &#125; for (int i = 0; i &lt; 1 &lt;&lt; k; ++i) for (int j = 0; j &lt; 3; ++j) &#123; int &amp;x = ans[__builtin_popcount(i)]; x = (x + f[n &amp; 1][i][j]) % P; &#125; for (int i = 0; i &lt;= k; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; 状态数优化 有时 DP 的效率不高不是转移不够高效（很多情况转移是无法优化的），而是状态数实在太多了。在这种时候我们往往考虑通过重新设计状态、合并等价状态、寻找有效的状态等方式来优化状态数。 [NOI2023] 合并书本。你需要将 n≤100n \\le 100n≤100 个附魔物品合并在一起，初始第 iii 个物品的附魔费用是 wiw_iwi​，累计惩罚的计算方式是原来较大的累计惩罚 ×2+1\\times 2 + 1×2+1，合并代价是牺牲物品的附魔费用和累计惩罚之和。 建出合并二叉树，令左儿子合并到右儿子。附魔费用仅对非叶子节点有贡献，贡献是其左儿子的权值 s(lu)s(l_u)s(lu​)。累计惩罚仅对非根节点有贡献，贡献是 2d(u)−12^{d(u)}-12d(u)−1。其中 ddd 是指子树内距离最长的叶子。 设 w(u)w(u)w(u) 代表叶子节点 uuu 走到根节点走过了多少左儿子边，那么 ∑us(lu)=∑uauw(u)\\sum_u s(l_u)=\\sum_u a_u w(u)∑u​s(lu​)=∑u​au​w(u)。 当 aaa 降序排序时，应该保证 www 升序排序才能使得该值更小。现在我们有两种方法，一种是从叶子节点开始合并，另一种是从根节点开始分裂。 如果从叶子节点开始合并，那么设 fi,sf_{i,s}fi,s​ 代表初始有 iii 本附魔书，当前 www 的可重集为 sss，而最后再在 sss 里 push_back 一个子树根节点的 d(u)d(u)d(u) 时的最小累计惩罚之和。那么合并的时候直接暴力枚举左子树大小，左子树的所有 www 都要 +1+1+1。剪枝时舍弃掉被偏序的状态。配合上 w=1w=1w=1 可以获得 757575 分。 状态数爆炸的最重要原因是我们需要记录一个 ddd，自底向上无法得知这个 ddd 是什么，因此我们考虑自顶向下对儿子进行分裂。我们总是取 www 前若干小的进行分裂，这样一定更优。观察可得，如果分裂出新的树的大小为 ∣T∣|T|∣T∣，之前累计惩罚为 vvv，那么新的累计惩罚为 2v+∣T∣−22v+|T|-22v+∣T∣−2。那么直接维护即可，配合上 w=1w=1w=1 可以获得 909090 分。 注意到，如果之前某个节点分裂出了 111 个儿子，那么它接下来必须分裂出不少于这个数量的叶子，剪枝，可以获得 100100100 分。代码。 官方题解使用了暴力枚举分拆数，然后疯狂剪枝的方法，实际表现非常优秀，尚不知道其原理。 题车 对于对应的组别来说，中档题会附带一个星号，难题会附带两个星号。 由于 DP 的难度在于状态设计和套路积累，因此题会非常多。 刷基础 1 巩固所学内容，训练思维的熟练度和准确度。本身难度不大。 [CF1178F] Colorful Strip Portal. 首先考虑 F1 的做法。条件非常特殊，每种颜色恰好会染上一个位置且有顺序，区间 DP 确定区间中第一个染的颜色，然后枚举左右段的长度给拼起来，拆一下贡献即可。代码。 对于 F2，颜色数并没有变化，考虑将相同的颜色段缩起来，然后先判掉无解的情况。然后设 Lx,RxL_x,R_xLx​,Rx​ 代表颜色出现的最左最右位置。一个区间 [i,j][i,j][i,j] 是合法的当且仅当其最小颜色全部出现在 [i,j][i,j][i,j] 内，最后再把中间段的贡献呈上去就行。代码。 [CF1280D] Miss Punyverse Portal. 设 fx,if_{x,i}fx,i​ 表示以 xxx 为根的子树内选择 iii 个连通块的最大满足要求的块数（除了 xxx 所属的连通块）。gx,ig_{x,i}gx,i​ 代表 xxx 所属连通块的最大权值，树形背包随便跑一下就行。代码。 [CF1394D] Boboniu and Jianghu Portal. 问题只是给相等的高度进行定向。设 fi,0/1f_{i,0/1}fi,0/1​ 代表到 iii 父亲的边强制为连入/连出情况下的贡献和。先假定所有都选 000 再枚举 111 的数量即可。代码。 * [CF1845E] Boxes and Balls Portal. 对于移动到目标状态，我们只需要消耗最小次数，剩下的来回交换刷分即可。 将问题抽象成这个东西： 初始前缀和序列 sss，目标前缀和序列 s′s&#x27;s′； ∑∣s′−s∣≤k\\sum |s&#x27;-s|\\le k∑∣s′−s∣≤k， ∑∣s′−s∣≡k(mod2)\\sum |s&#x27;-s|\\equiv k\\pmod 2∑∣s′−s∣≡k(mod2)。 设 fi,j,kf_{i,j,k}fi,j,k​ 代表当前填前 iii 个数，填了 jjj 个 111，∑∣s′−s∣=k\\sum |s&#x27;-s|=k∑∣s′−s∣=k 的方案数，考虑当前位填 0/10/10/1： fi,j,k=fi−1,j,k−∣j−si∣+fi−1,j−1,k−∣j−si∣f_{i,j,k}=f_{i-1,j,k-|j-s_i|}+f_{i-1,j-1,k-|j-s_i|} fi,j,k​=fi−1,j,k−∣j−si​∣​+fi−1,j−1,k−∣j−si​∣​ 注意到 ∣j−si∣|j-s_i|∣j−si​∣ 的取值范围是 O(k)O(\\sqrt{k})O(k​) 的，否则 ∑\\sum∑ 这堆东西会超过 kkk。只枚举这些值即可。代码。 [CF1778F] Maximizing Root Portal。不难发现 a1a_1a1​ 只能乘一次，因此我们要看它最大能乘个什么。进行一次暴力树形 DP，fx,if_{x,i}fx,i​ 代表给 xxx 乘上约数 iii 的最小步数。本来不满足的最多有一次操作机会（乘上自己），转移时对于每个约数取个 min⁡\\minmin 即可。代码。 刷提升 1 稍有难度的题目。 * [CF1750F] Majority Portal. 不知道这个条件怎么刻画，那看看如何刻画不合法序列： 两端不全是 111； 全是 111，但是操作到尽头时每一个连续 000 段的长度都比两边连续 111 段的长度之和大。 设 fi,jf_{i,j}fi,j​ 代表长度为 iii 的序列，两端为 111，操作到最后最后一个 111 连续段的长度为 jjj。这样答案就是 fn,nf_{n,n}fn,n​。初始 f1,1=1f_{1,1}=1f1,1​=1。 对于 fi,if_{i,i}fi,i​，考虑容斥，有： fi,i=2i−2−∑j=1⌊(i−1)/2⌋fi,jf_{i,i}=2^{i-2}-\\sum_{j=1}^{\\lfloor(i-1)/2\\rfloor}f_{i,j} fi,i​=2i−2−j=1∑⌊(i−1)/2⌋​fi,j​ 对于 fi,jf_{i,j}fi,j​，前面一定有一个 111 连续段接 000 连续段 的东西，枚举 000 的长度 kkk 和 111 的长度 lll，那么有： fi,j=fj,j×(∑j+k&lt;i∑j+l&lt;kfi−j−k,l)=fj,j×(∑k=j+2i−j−1∑l=1k−j−1fi−j−k,l)=fj,j×∑(i−j−k)+l&lt;i−2jfi−j−k,l\\begin{aligned} f_{i,j}&amp;=f_{j,j}\\times \\left(\\sum_{j+k&lt;i}\\sum_{j+l&lt;k}f_{i-j-k,l}\\right)\\\\ &amp;=f_{j,j}\\times \\left(\\sum_{k=j+2}^{i-j-1}\\sum_{l=1}^{k-j-1}f_{i-j-k,l} \\right)\\\\ &amp;=f_{j,j}\\times \\sum_{(i-j-k)+l&lt;i-2j}f_{i-j-k,l} \\end{aligned} fi,j​​=fj,j​×​j+k&lt;i∑​j+l&lt;k∑​fi−j−k,l​​=fj,j​×​k=j+2∑i−j−1​l=1∑k−j−1​fi−j−k,l​​=fj,j​×(i−j−k)+l&lt;i−2j∑​fi−j−k,l​​ 前缀和优化即可。代码。 * [CF1809G] Prediction Portal. 对于一个合法的排列 ppp，删除 apia_{p_i}api​​ 最小的 pip_ipi​，新的 p′p&#x27;p′ 必定合法。 设 fif_{i}fi​ 代表填完 (i,n](i,n](i,n] 的方案数，初始 fn=1f_n=1fn​=1，考虑 aia_iai​ 填的位置： 不填在当前第一个位置，不影响后面元素的前缀 max⁡\\maxmax，fi−1←+fi(n−i)f_{i-1}\\stackrel{+}{\\leftarrow} f_{i}(n-i)fi−1​←+fi​(n−i)； 填在当前第一个位置。设 lstilst_ilsti​ 代表最大的 jjj 使得 ai−aj&gt;ka_i-a_j&gt;kai​−aj​&gt;k，那么 (lsti,i)(lst_i,i)(lsti​,i) 都需要出现在 iii 之前，则 i−lsti−1i-lst_i-1i−lsti​−1 需要填入 n−lsti−2n-lst_i-2n−lsti​−2 个位置（除了第一个）。 双指针求 lstlstlst，时间复杂度 O(n)O(n)O(n)。代码。 [CF1372E] Omkar and Last Floor Portal. 一列聚集在一起一定是最优的，考虑 fi,jf_{i,j}fi,j​ 代表区间 [i,j][i,j][i,j] 的答案，ci,j,kc_{i,j,k}ci,j,k​ 代表左右端点都在 [i,j][i,j][i,j] 且经过第 kkk 列的区间数量。 枚举聚集的那一列，那么： fi,j=max⁡{fi,k−1+ci,j,k2+fk+1,j}f_{i,j}=\\max\\{f_{i,k-1}+c_{i,j,k}^2+f_{k+1,j}\\} fi,j​=max{fi,k−1​+ci,j,k2​+fk+1,j​} ccc 区间 DP 时容斥一下就行。代码。 * [CF1188D] Make Equal Portal. 记 bi=max⁡a−aib_i=\\max a - a_ibi​=maxa−ai​，那么要求： ∑i=1npopcount⁡(x+bi)\\sum_{i=1}^n \\operatorname{popcount}(x+b_i) i=1∑n​popcount(x+bi​) 考虑二进制下的第 kkk 位： xxx 的第 kkk 位是否填 111； bib_ibi​ 的第 kkk 位是否填 111; 第 k−1k-1k−1 位是否进位。 第 k−1k-1k−1 位的进位情况和 bi mod 2kb_i\\bmod 2^kbi​mod2k 有关。我们按照这个东西排序，能进位的就是 bbb 的一段前缀。 设 fi,jf_{i,j}fi,j​ 代表有 jjj 个数进位到第 iii 位的答案。考虑 xxx 当前这一位填 111 还是填 000，贡献随便算一下就行了。代码。 * [CF1517F] Reunion Portal. 设一种方案 SSS 的半径为 f(S)f(S)f(S)，那么答案是 ∑r=1n∑S[f(S)≥r]\\sum_{r=1}^{n}\\sum_{S}[f(S)\\ge r]∑r=1n​∑S​[f(S)≥r]。实际上我们只需要对于每个 rrr 分别计算即可。 设 fi,jf_{i,j}fi,j​ 代表 iii 的子树距离 iii 最近的黑点距离为 jjj 的方案数，记满足 j=r+1j=r+1j=r+1 的为预备点，gi,jg_{i,j}gi,j​ 表示 iii 子树内最深预备点与 iii 距离为 jjj 时的方案数。 值得注意的是，若子树内已经存在预备点，那么没有必要再考虑距离 iii 最近的黑点与 iii 的距离。不存在时，这东西才需要被记录。 考虑使用树形背包的方式合并： 合并 fx,i,fy,jf_{x,i},f_{y,j}fx,i​,fy,j​，可以转移到 fx,min⁡{i,j+1}f_{x,\\min \\{i,j+1\\}}fx,min{i,j+1}​； 合并 gx,i,gy,jg_{x,i},g_{y,j}gx,i​,gy,j​，可以转移到 gx,max⁡{j,k+1}g_{x,\\max\\{j,k+1\\}}gx,max{j,k+1}​； 合并 fx,i,gy,jf_{x,i},g_{y,j}fx,i​,gy,j​，如果 i+j+1&gt;ri+j+1&gt;ri+j+1&gt;r，那么 ggg 定义的预备点是符合限制的，其会转移到 gx,j+1g_{x,j+1}gx,j+1​，否则会转移到 fx,if_{x,i}fx,i​； 合并 gx,i,fy,jg_{x,i},f_{y,j}gx,i​,fy,j​ 大致同理。 答案是 ∑g1\\sum g_1∑g1​。 时间复杂度 O(n3)O(n^3)O(n3)。代码。 刷提升 2 接着提升自我吧！ [CEOI2005] Mobile Service Portal. DP 是简单的，问题是空间如此之小，方案该怎么记录？ 首先，方案数组是不可能被滚动的。但是决策数量比较小，可以使用 unsigned char 来记录。然后发现只记录一个数就可以了。代码。 * [eJOI2018] 护照 Portal. 不难想到状压，而且 P≤2P\\le 2P≤2，因此 P=2P=2P=2 时只需要枚举子集然后对于子集和补集合并状压 DP 数组即可，因此这里只需要考虑 P=1P=1P=1。 设 fif_ifi​ 代表集合 iii 中的签证全部办理完成后的最小结束时间。转移采用刷表法，考虑限制是什么：一个时间内，旅行和办理签证做多做一种。如果我们依次检查其它国家的限制，那么时间复杂度为 O(n22n)O(n^2 2^n)O(n22n)。 但如果按照 ttt 从小到达考虑，这个过程显然是具有单调性的。考虑从限制本身入手： 办理签证的时间不可以撞到出国的时间。 如果 ppp 正在办理签证，那么这个时间不能考虑办理签证。 将 lll 排序之后维护两个指针来限制两条限制，找到可以办理当前签证的最小时间即可。 这样就可以 O(n2n)O(n2^n)O(n2n) 完成了。代码。 [ARC108E] Random IS Portal. 求的是依次随机选择排列中合法的数，然后 IS 的期望长度。 设 fl,rf_{l,r}fl,r​ 代表 l,rl,rl,r 已经被选择，那么有： fl,r=∑al&lt;ak&lt;arfl,k+fk,j+1gl,rf_{l,r} = \\frac{\\sum_{a_l&lt;a_k&lt;a_r} f_{l,k}+f_{k,j}+1}{g_{l,r}} fl,r​=gl,r​∑al​&lt;ak​&lt;ar​​fl,k​+fk,j​+1​ 可以在 kkk 处新增一个 111。所有的东西都可以很方便地用树状数组求出，代码。 [Ptz 2020 Summer Day4] Ternary String Counting Portal. O(n4)O(n^4)O(n4) 直接 fi,x,y,zf_{i,x,y,z}fi,x,y,z​ 记录每一个字符出现的位置，O(n3)O(n^3)O(n3) 记录前两个不同字符的出现位置。都需要前缀和优化。 状态数还是过多了，我们需要寻找一个方式简化。先把转移写出来： f(i+1,i,k)←+f(i,j,k)f(i+1,i,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,k)←+f(i,j,k)； f(i+1,i,j)←+f(i,j,k)f(i+1,i,j)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,j)←+f(i,j,k)； f(i+1,j,k)←+f(i,j,k)f(i+1,j,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,j,k)←+f(i,j,k)。 再考虑题目中的限制，实际上就是限制了 dp 过程中 jjj 和 kkk 的取值范围： x=1x=1x=1，则 j&lt;lj&lt;lj&lt;l； x=2x=2x=2，则 j≥l,k&lt;lj\\ge l,k&lt;lj≥l,k&lt;l； x=3x=3x=3，则 k≥lk\\ge lk≥l。 考虑优化，看上去第一维什么都不是！将转移分为 iii​ 层，每一层的状态只能从上一层转移过来，第三个转移就是直接从上一层的对应点转移，第一二个转移是对上一层的一列和一行求和。 等价于，每次给出一个矩形，先把矩形外的值全部清零。然后还可以发现，一旦某个值被清零，那么这个值以后永远都是零。并且对于某一行来说，非零的值永远是一段连续区间，而且其位置是单调的。 双指针扫，不重复清零某个行即可。最终时间复杂度 O(n2+m)O(n^2+m)O(n2+m)。代码。 [Ptz 2022 Summer Day3] Counting Sequence Portal. 对于 O(n2)O(n^2)O(n2)，直接设 fi,jf_{i,j}fi,j​ 表示当前 ∑=i\\sum =i∑=i，结尾是 jjj 的贡献。 当 a1≥Ba_1\\ge Ba1​≥B 时，序列长度为 O(n/B)O(n/B)O(n/B)，可以设计序列长度的 DP。设 gi,j,Sg_{i,j,S}gi,j,S​ 表示到序列第 iii 位，当前和 a1a_1a1​ 的差为 jjj，∑at−a1=S\\sum a_t - a_1 = S∑at​−a1​=S 的方案数，转移枚举最后一个填什么，复杂度 O((n/B)4)O((n/B)^4)O((n/B)4)。根号平衡可以做到 O(n8/5)O(n^{8/5})O(n8/5)。 改为 gi,jg_{i,j}gi,j​ 代表长度为 iii，∑at−a1=j\\sum a_t-a_1=j∑at​−a1​=j，然后在序列前面插入一个数。注意 fff 可以按照 i mod 2Bi \\bmod 2Bimod2B 进行统计。代码。 刷提升 3 更偏向 DP 的优化。 [PA 2022] Nawiasowe podziały Portal. 经典的划分区间段问题，答案是关于 kkk 上凸的，wqs 二分解决。里面有决策单调性，要进行 kkk 轮，但是只需要知道前面的对后面的影响，CDQ 分治降维即可。代码。 刷能力 DP 综合应用。 * [ZJOI2019] 麻将 Portal. 可以发现其两部分是割裂的：判断胡牌和计数 DP。由于胡牌集合的大小只有 131313，因此如果我们能解决判定问题，那么便可以建立自动机在上面解决计数问题。 先解决判定问题。七个对子只需要开一个桶即可，一个对子四个面子可以考虑使用 DP 来解决：设 fi,j,k,0/1f_{i,j,k,0/1}fi,j,k,0/1​ 代表考虑前 iii 种牌，目前还剩下 jjj 组 (i−1,i)(i-1,i)(i−1,i) 和 kkk 张 iii，以及是否选择出了一组对子，这种时候的最大面子数。由于 j≥3j\\ge 3j≥3 或者 k≥3k\\ge 3k≥3 时都可以直接组成新的面子，因此状态中 j,k∈[0,2]j,k\\in [0,2]j,k∈[0,2]。因此在一个状态中建立两个 3×33\\times 33×3 的二维数组即可。转移时将 xxx 张 iii 牌添加进来即可。 牌种类数足够多时状态就被列举完了，因此直接暴力 DFS 拓展出所有状态即可，按照笔者的实现，其状态只有 S=3956S=3956S=3956 种，而接下来的分析让我们知到我们只需要不胡的状态，其只有 S=2091S=2091S=2091 种。 接下来我们要解决计数问题。我们需要知到第一个胡牌的位置，这并不好直接计算。设 P(i)P(i)P(i) 代表恰好 iii 步胡牌的概率，那么： E(x)=∑i=0+∞i×P(i)=∑i=0+∞∑j=i+∞P(j)\\begin {aligned} E(x)&amp;=\\sum_{i=0}^{+\\infty} i\\times P(i)\\\\ &amp;=\\sum_{i=0}^{+\\infty}\\sum_{j=i}^{+\\infty}P(j) \\end{aligned} E(x)​=i=0∑+∞​i×P(i)=i=0∑+∞​j=i∑+∞​P(j)​ 可以发现第二个和式的意思是 i−1i-1i−1 步没胡的概率，设 fi,j,kf_{i,j,k}fi,j,k​ 代表选择前 iii 种牌，一共 jjj 张，位于自动机上的状态 kkk，转移时选择 ttt 张 iii 牌，系数是 (4−ait)\\dbinom {4-a_i}{t}(t4−ai​​)，令 m=4n−13m=4n-13m=4n−13，fif_ifi​ 为 iii 张牌没胡的方案数，则答案为： ans=∑i=0mfii!(m−i)!m!ans=\\frac{\\sum_{i=0}^m f_i i!(m-i)!}{m!} ans=m!∑i=0m​fi​i!(m−i)!​ 代码。 [CF924F] Minimal Subset Difference Portal. * [JOISC2020] Ruins 3 Portal. 旋风牛马大数数。 考虑从后往前扫，然后假定 1∼h1\\sim h1∼h 的石柱各出现了一根，那么接下来出现的 ≤h\\le h≤h 的柱子，都会直接震没。那些没有被震死的柱子称为“标准柱”。 继续观察性质。如果当前位置为 xxx，后面存在 x∼x−kx\\sim x-kx∼x−k，那么 xxx 会下降到 x−k−1x-k-1x−k−1。 设 fi,jf_{i,j}fi,j​ 代表后 iii 个柱子，此时 h=jh=jh=j 的方案数。 我们先假定两根高度相同的柱子实际上是不同的，那么最终答案除以 2n2^n2n 即可。 倒着 DP，设此时有 c0c_0c0​ 个钦定消失，c1c_1c1​ 个钦定存在。 iii 钦定消失，此时 jjj 不变，有 jjj 个可用高度，那么不算当前这个没消失的，这里可以填写 j−(c0−1)j-(c_0-1)j−(c0​−1) 个有效的。 iii 钦定保留，令 hih_ihi​ 代表 iii 最后的高度，分讨： 如果 hi&gt;j+1h_i&gt;j+1hi​&gt;j+1，那么从 fi+1,jf_{i+1,j}fi+1,j​ 转移，这里的贡献留给以后再计算。 否则此时 hi=j+1h_i=j+1hi​=j+1，那么此时枚举一个新增的大小 kkk，转移到 fi,j+kf_{i,j+k}fi,j+k​，系数是： 选择哪些位置的值被记入了当前 jjj。钦定除了当前位置的那 k−1k-1k−1 个位置的方案数 (c1−1−jk−1)\\dbinom{c_1-1-j}{k-1}(k−1c1​−1−j​)； j+2∼j+kj+2\\sim j+kj+2∼j+k 的高度之前均有出现过一次，这里还可以选择各一次，然后还可以选择两个 j+1j+1j+1 的高度，方案数是 k+1k+1k+1； 固定那 k−1k-1k−1 个位置上的数的排列，那些数都没有被震没。因此就是要求一个 gng_ngn​ 代表有 2n2n2n 个数进行选择，然后震成值域连续段的初始方案数。 设 gi,jg_{i,j}gi,j​ 代表用 1∼i1\\sim i1∼i 的数填 jjj 个位置，放进去的最大数不影响原来能震成的值域连续段，那么能震成值域连续段的充要条件是 i≥ji\\ge ji≥j。枚举第 iii 个数填了 0/1/20/1/20/1/2 的转移方式： gi,j=gi−1,j+2j×gi−1,j−1+j(j−1)gi−1,j−2g_{i,j}=g_{i-1,j}+2j\\times g_{i-1,j-1}+j(j-1) g_{i-1,j-2} gi,j​=gi−1,j​+2j×gi−1,j−1​+j(j−1)gi−1,j−2​ 代码。 [Ptz 2023 Winter Day6] 5 Portal. 不难设计出 flen,sumf_{len,sum}flen,sum​ 这样的状态，但是状态数就成 O(nS)O(nS)O(nS) 了，直接寄了。 可以发现 111 出现的次数是比较少的，因此可以设计出一个 fsum−len,lenf_{sum-len,len}fsum−len,len​ 的状态，然后维护每个 sum−lensum-lensum−len 对应的 lenlenlen 连续段（只有 444 个），二进制拆分优化多重背包即可。代码。 刷综合 有些题目比较癫狂。 ** [Luogu P8554] 心跳 Portal. 我们考虑去掉一个数之后前缀最大值改变的情况。 设 kkk 为原先前缀最大值的个数，那那么只有当其原先是前缀最大值时，前缀最大值将变成 [k−1,n][k-1,n][k−1,n]。 尝试找出 aaa 的合法结构，对于 aaa 进行染色： 红色：原来就是前缀最大值的位置，可以使得 kkk 增大 111； 绿色：用来代替红色点称为前缀最大值的位置，kkk 不变； 黄色：垃圾，kkk 不变。 可以发现，红色后面会接一段长度为 xxx 的绿色，且它们的大小是递增的，然后再是一堆黄色，然后是下一个红色。绿色的出现条件是小于上一个红色但是大于上上个红色，黄色应该小于上一个绿色或者小于上上个红色。于是将颜色序列转化为 ppp 时，一定可以构造出来。 尝试构建颜色序列和 aaa 之间的双射，为什么一个颜色序列对应恰好一个合法的 aaa？首先我们构造 aaa，非红色点 ai=ka_i=kai​=k，红色点 ai=k−1+xa_i=k-1+xai​=k−1+x。 需要保证一个 aaa 只能对应一种颜色序列，和 AGC055C 一样，我们限制等价状态。要注意情况不完全一样，因为 aaa 可以改的值更多（以下 X 指非绿的东西）： 黄红绿 X 和红绿黄 X 是等价的状态，因此前者不可能出现（目前不能紧跟长度为 111 的绿色段）； 如果出现了黄黄，那么就不能再填红绿 X 段了（后续不能有任何长度为 111 的绿色段）。 另外，第一个数一定是红色，第二个数一定不能是黄色，因为序列头被删了自然就有了新的前缀最大值。 我们还需要限制 mmm，于是我们只需在自动机上只需要记录这些信息： 前面一个的颜色； 是否出现过黄黄； 这个绿色段的长度是 0,10,10,1 还是大于等于 222； 当前绿色段前面的红色是否在黄色后面； 当前的红色个数。 要么 k&gt;mk&gt;mk&gt;m，要么 k=mk=mk=m 且没有不接绿色的红色，跑两次即可。 状态可以压缩成下图，代码： ** [NOI2022] 移除石子","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"JOISC 2019 题目合集","slug":"default/做题记录/OI/JOI/joisc2019","date":"2023-10-04T00:00:00.000Z","updated":"2023-10-04T00:00:00.000Z","comments":true,"path":"8c948c47/","link":"","permalink":"https://james1badcreeper.github.io/8c948c47/","excerpt":"说好的加训，结果加的跟没加一样。人啊，要支棱起来啊！","text":"说好的加训，结果加的跟没加一样。人啊，要支棱起来啊！ 欢迎收看 10 月大型新番 点赞越多，更新越快！ 为了格式统一，本文没有任何的二级标题。 Start：2023/10/04 18:??。 Done：2023/10/09 01:56。 这么慢啊！什么摆怪！受不了了啊喂喂！ 别慌~ Day1 A，B，C。 A. 考试 直接三维偏序即可。代码。 B. 聚会 Portal.给定一棵 n(n≤2000)n(n\\le 2000)n(n≤2000) 个节点的树，要求找到树的形态，可以调用最多 10510^5105 次询问：Query(x, y, z)：返回树上的一个点，这个点到三个点的距离和最小。 一个非常笨 B 的做法。 每次在树上随机出一条链，询问树上所有的点，能够成为答案的一定是链上的点。对于链，随机中点分治处理；剩下的部分依然是树，递归处理。 消耗的询问不超过 250002500025000 次，这个做法大概可以说明随机分治具有一定的正确性？ #include &lt;bits/stdc++.h> #include \"meetings.h\" using namespace std; mt19937 Rand(time(0)); inline void answer(int x, int y) &#123; if (x > y) swap(x, y); Bridge(x, y); &#125; void dfs(vector&lt;int> a, int x, int y) &#123; if (a.empty()) return answer(x, y); if (a.size() == 1) return answer(x, a[0]), answer(a[0], y); int mid = a[Rand() % a.size()]; vector&lt;int> al, ar; for (int i : a) if (i != mid) &#123; if (Query(x, mid, i) == i) al.emplace_back(i); else ar.emplace_back(i); &#125; dfs(al, x, mid); dfs(ar, mid, y); &#125; void solve(vector&lt;int> a) &#123; if (a.size() &lt;= 1) return; int n = a.size(), x = a[Rand() % n], y = a[Rand() % n]; while (x == y) y = a[Rand() % n]; map&lt;int, vector&lt;int>> mp; mp[x].emplace_back(x); mp[y].emplace_back(y); for (int i : a) if (i != x &amp;&amp; i != y) mp[Query(x, y, i)].emplace_back(i); vector&lt;int> chain; for (auto [p, q] : mp) if (p != x &amp;&amp; p != y) chain.emplace_back(p); dfs(chain, x, y); for (auto [p, q] : mp) solve(q); &#125; void Solve(int n) &#123; vector&lt;int> a(n); for (int i = 0; i &lt; n; ++i) a[i] = i; solve(a); &#125; C. 馕 Portal.一个长度为 LLL 的激光剑被分为 LLL 段，每段一个单位长度，第 iii 段为第 jjj 种口味。NNN 个人来吃激光剑，第 iii 个人吃一个单位长度的 jjj 口味的激光剑会分泌 Vi,jV_{i,j}Vi,j​ 的多巴胺。构造一个顺序，给每个人划分一段激光剑，每个人获得一定的长度。构造一种方案，每个人分泌的多巴胺大于自己吃掉整个激光剑的多巴胺的 1n\\frac 1 nn1​，或者报告无解。n,L≤2000n,L\\le 2000n,L≤2000。 比较显然的是，考虑让每个人恰好吃他总收益的 1n\\frac 1 nn1​。考虑每个人的 nnn 等分点，贪心取所有人中 nnn 等分点最短的一段，然后直接划给这个人，因为他消耗的最少，这样一定是不劣的。 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; typedef __int128 lll; int n, L, c[2005]; i64 v[2005][2005]; struct Frac &#123; i64 x, y; Frac(i64 x = 1, i64 y = 0) : x(x), y(y) &#123;&#125; bool operator&lt; (const Frac &amp;a) const &#123; return (lll)x * a.y &lt; (lll)a.x * y; &#125; bool operator>= (const Frac &amp;a) const &#123; return (lll)x * a.y >= (lll)a.x * y; &#125; &#125; a[2005][2005]; // 第 i 个人的第 j 等分段在哪里结束 int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> L; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= L; ++j) cin >> v[i][j]; for (int id = 1; id &lt;= n; ++id) &#123; i64 s = 0, cur = 0; for (int i = 1; i &lt;= L; ++i) s += v[id][i]; int j = 1; for (int i = 1; i &lt;= L; ++i) &#123; while (j &lt;= n &amp;&amp; Frac(cur + v[id][i], 1) >= Frac(s * j, n)) a[id][j] = Frac(s * j - cur * n + n * v[id][i] * (i - 1), n * v[id][i]), ++j; if (j > n) break; cur += v[id][i]; &#125; &#125; static bool vis[2005]; memset(vis, 0, sizeof vis); for (int i = 1; i &lt;= n; ++i) &#123; Frac res; int t = 0; for (int j = 1; j &lt;= n; ++j) if (!vis[j] &amp;&amp; a[j][i] &lt; res) res = a[j][i], t = j; vis[t] = 1; c[i] = t; if (i != n) cout &lt;&lt; res.x &lt;&lt; \" \" &lt;&lt; res.y &lt;&lt; \"\\n\"; &#125; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; c[i] &lt;&lt; \" \\n\"[i == n]; return 0; &#125; Day2 A，B，C。 A. * 两个天线 Portal.nnn 个天线，相邻距离为 111，高度为 HiH_iHi​。天线 iii 向天线 jjj 可以发消息，通信成本为 ∣Hi−Hj∣|H_i-H_j|∣Hi​−Hj​∣，当且仅当它们之间的距离 Di,j∈[Ai,Bi]D_{i,j}\\in [A_i,B_i]Di,j​∈[Ai​,Bi​]。多次询问区间中可以相互发送信息的天线的最大值。n≤2×105n\\le 2\\times 10^5n≤2×105。 考虑离线，所有询问按 RRR 排序。绝对值不好处理，拆了正反各做一遍。 每次新增一个可行的 jjj，将可行的 iii 加入答案集合。对 yyy 来说合法的 xxx 区间是 [y−By,y−Ay][y-B_y,y-A_y][y−By​,y−Ay​]，xxx 需要满足 y∈[x+Ax,x+Bx]y\\in [x+A_x,x+B_x]y∈[x+Ax​,x+Bx​]，典型的扫描线。 #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; const int N = 800000; int mxA[800005], mxB[800005], tag[800005]; void clear(void) &#123; fill(mxA + 1, mxA + N + 1, -INF); fill(mxB + 1, mxB + N + 1, -INF); fill(tag + 1, tag + N + 1, -INF); &#125; inline void pushup(int o) &#123; mxA[o] = max(mxA[o &lt;&lt; 1], mxA[o &lt;&lt; 1 | 1]); mxB[o] = max(mxB[o &lt;&lt; 1], mxB[o &lt;&lt; 1 | 1]); &#125; inline void maketag(int o, int k) &#123; tag[o] = max(tag[o], k); mxB[o] = max(mxB[o], mxA[o] + k); &#125; inline void pushdown(int o) &#123; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = -INF; &#125; void updateA(int o, int l, int r, int x, int k) &#123; if (l == r) return mxA[o] = k, void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) updateA(o &lt;&lt; 1, l, mid, x, k); else updateA(o &lt;&lt; 1 | 1, mid + 1, r, x, k); pushup(o); &#125; void updateB(int o, int l, int r, int x, int y, int v) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, v), void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) updateB(o &lt;&lt; 1, l, mid, x, y, v); if (mid &lt; y) updateB(o &lt;&lt; 1 | 1, mid + 1, r, x, y, v); pushup(o); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return mxB[o]; pushdown(o); int mid = l + r >> 1, res = -INF; if (x &lt;= mid) res = max(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = max(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; int n, q; int h[200005], a[200005], b[200005]; int l[200005], r[200005], ans[200005]; vector&lt;pair&lt;int, int> > Q[200005], A[200005]; void solve(void) &#123; for (int i = 1; i &lt;= n; ++i) Q[i].clear(), A[i].clear(); for (int i = 1; i &lt;= q; ++i) Q[r[i]].emplace_back(l[i], i); for (int i = 1; i &lt;= n; ++i) &#123; if (i + a[i] &lt;= n) A[i + a[i]].emplace_back(i, h[i]); if (i + b[i] + 1 &lt;= n) A[i + b[i] + 1].emplace_back(i, -INF); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (auto [p, v] : A[i]) updateA(1, 1, n, p, v); if (i - a[i] >= 1) updateB(1, 1, n, max(1, i - b[i]), i - a[i], -h[i]); for (auto [l, id] : Q[i]) ans[id] = max(ans[id], query(1, 1, n, l, i)); &#125; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> h[i] >> a[i] >> b[i]; cin >> q; memset(ans, -1, sizeof ans); for (int i = 1; i &lt;= q; ++i) cin >> l[i] >> r[i]; clear(); solve(); reverse(h + 1, h + n + 1); reverse(a + 1, a + n + 1); reverse(b + 1, b + n + 1); for (int i = 1; i &lt;= q; ++i) l[i] = n - l[i] + 1, r[i] = n - r[i] + 1, swap(l[i], r[i]); clear(); solve(); for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; B. ** 两种料理 Portal.你要烹饪两道料理：闪耀的芝士蛋挞 和 深潜的极寒冰沙，分别有 n,mn,mn,m 道工序，需要的时间是 a1,⋯ ,ana_1,\\cdots,a_na1​,⋯,an​ 和 b1,⋯ ,bmb_1,\\cdots,b_mb1​,⋯,bm​ 分钟。制作这两道料理都非常困难：一个步骤开始之后不能中断。到最后，你必须做完这两道料理。如果你在比赛的前 sis_isi​ 分钟完成了 闪耀的芝士蛋挞 的第 iii 个制作步骤，那么你可以获得 pip_ipi​ 的分数。同理，在 tjt_jtj​ 分钟前完成 深潜的极寒冰沙 的第 jjj 个制作步骤可获得 qjq_jqj​ 的分数。问最大得分。n,m≤106n,m\\le 10^6n,m≤106，分数可能是负的。 太精彩啦！巨大的 n,mn,mn,m 让人想只对闪耀的芝士蛋挞（以下称为 A 料理）DP，直接计算深潜的极寒冰沙（以下称为 B 料理）的贡献。但是做不了[1]。 设 fi,jf_{i,j}fi,j​ 代表完成 A 料理 的前 iii 步，B 料理的前 jjj 步的最大得分。看上去它的尽头就是 O(nm)O(nm)O(nm)，实则不然！ 可以看作网格图上从 (0,0)(0,0)(0,0) 走到 (n,m)(n,m)(n,m)，向右走代表完成 A 料理的一个步骤，向下走代表完成 B 料理的一个步骤。求出 a,ba,ba,b 的前缀和 sa,sbsa,sbsa,sb。现在将贡献映射到点上，对于每个 sis_isi​，找到最大的 sbj≤si−saisb_j\\le s_i-sa_isbj​≤si​−sai​ 的格点 (i,j)(i,j)(i,j)，它在路径的左上方（或路径上）便有贡献。同理对 tjt_jtj​ 找到最大的 sai≤tj−sbjsa_i\\le t_j-sb_jsai​≤tj​−sbj​，那么它在路径的右下放就有贡献。 想办法将两种贡献点改成一样的。容斥！我们将 ppp 先全部加上，然后减去严格在下面的。也就是说，将 (i−1,j+1)(i-1,j+1)(i−1,j+1) 的贡献标记为 −pi-p_i−pi​。也就是说，现在只需要最大化右下（包括路径上）的权值和。 每次考虑对前一列进行计算（先将 y=0y=0y=0 和 x=nx=nx=n 判掉）： f(x,y)=max⁡{f(x,y−1),f(x−1,y)+∑i=1yv(x−1,i)}f(x,y)=\\max\\{f(x,y-1),f(x-1,y)+\\sum_{i=1}^y v(x-1,i)\\} f(x,y)=max{f(x,y−1),f(x−1,y)+i=1∑y​v(x−1,i)} 后缀加，前缀取 max⁡\\maxmax，维护差分数组，同 xxx 的点按照 yyy 从大到小加入，正数直接加入差分数组，负数的要找到这个 yyy 让往上跑直到这个负的贡献没掉。 使用 map 维护，时间复杂度 O((n+m)log⁡(n+m))O((n+m)\\log (n+m))O((n+m)log(n+m))。 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 1000005; int n, m; i64 a[N], s[N], p[N], b[N], t[N], q[N], ans; vector&lt;pair&lt;int, i64>> node[N]; void tag(int x, int y, i64 v) &#123; if (x &lt; 0 | y > m) return; if (x == n || y == 0) return ans += v, void(); node[x].emplace_back(y, v); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i] >> s[i] >> p[i], a[i] += a[i - 1]; for (int i = 1; i &lt;= m; ++i) cin >> b[i] >> t[i] >> q[i], b[i] += b[i - 1]; for (int i = 1; i &lt;= n; ++i) &#123; int j = upper_bound(b, b + m + 1, s[i] - a[i]) - b - 1; ans += p[i]; tag(i - 1, j + 1, -p[i]); &#125; for (int j = 1; j &lt;= m; ++j) &#123; int i = upper_bound(a, a + n + 1, t[j] - b[j]) - a - 1; tag(i, j, q[j]); &#125; map&lt;int, i64> c; for (int x = 0; x &lt; n; ++x) &#123; sort(node[x].begin(), node[x].end(), greater&lt;pair&lt;int, i64>>()); for (auto [y, v] : node[x]) &#123; if (v > 0) c[y] += v; else &#123; v = -v; auto it = c.lower_bound(y); while (v > 0 &amp;&amp; it != c.end()) &#123; if (v >= it->second) v -= it->second, it = c.erase(it); else &#123; it->second -= v; break; &#125; &#125; &#125; &#125; &#125; for (auto [y, v] : c) ans += v; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; C. 两种交通工具 神风敢死队炸毁了此处的内容。通信题。猜猜我是否还能回来做！对不起了！ Day3 A，B，C。 A. * 指定城市 Portal.给定一棵树，双向边，每条边两个方向的权值不同。多次询问 kkk，表示选出 kkk 个点，依次将以每个点为根的内向树边权赋值为 000，需要求出最后树的边权之和的最小值。要求 O(n)O(n)O(n)。 wxw_xwx​ 代表以 xxx 为根的内向树边权和，换根 DP 求出，k=1k=1k=1 被解决。 贪心地想，k&gt;1k&gt;1k&gt;1 一定是再选一条链，长剖贪心即可。 但是 k=2k=2k=2 时这一点不成立，需要使用换根 DP 解决。换完根之后将直径缩点，然后长剖贪心。 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; i64 sum, ans[200005]; struct edge &#123; int v, c, d; edge(int v = 0, int c = 0, int d = 0) : v(v), c(c), d(d) &#123;&#125; &#125;; vector&lt;edge> G[200005]; i64 w[200005]; void dfs1(int x, int fa) &#123; for (auto [y, c, d] : G[x]) if (y != fa) dfs1(y, x), w[x] += w[y] + d; &#125; void dfs2(int x, int fa) &#123; for (auto [y, c, d] : G[x]) if (y != fa) w[y] = w[x] - d + c, dfs2(y, x); &#125; int f[200005]; i64 dis[200005]; void DFS(int x, int fa) &#123; f[x] = fa; for (auto [y, c, d] : G[x]) if (y != fa) dis[y] = dis[x] + c + d, DFS(y, x); &#125; bool vis[200005]; vector&lt;i64> c; i64 solve(int x, int fa) &#123; i64 res = 0; for (auto [y, c, d] : G[x]) if (y != fa) &#123; i64 w = solve(y, x) + c; if (!res) res = w; else ::c.emplace_back(min(res, w)), res = max(res, w); &#125; return res; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt; n; ++i) &#123; int u, v, c, d; cin >> u >> v >> c >> d; sum += c + d; G[u].emplace_back(v, c, d); G[v].emplace_back(u, d, c); &#125; dfs1(1, 0); dfs2(1, 0); for (int i = 1; i &lt;= n; ++i) ans[1] = max(ans[1], w[i]); DFS(1, 0); int A = 1; for (int i = 1; i &lt;= n; ++i) if (dis[i] + w[i] > dis[A] + w[A]) A = i; dis[A] = 0; DFS(A, 0); int B = 1; for (int i = 1; i &lt;= n; ++i) if (dis[i] + w[i] > dis[B] + w[B]) B = i; ans[2] = (w[A] + w[B] + dis[B]) / 2; // +1 int x = B; while (x) vis[x] = 1, x = f[x]; x = B; while (x) &#123; for (auto [y, _c, _d] : G[x]) if (!vis[y]) c.emplace_back(solve(y, x) + _c); x = f[x]; &#125; sort(c.begin(), c.end(), greater&lt;i64>()); int t = 2; for (i64 x : c) ans[t + 1] = ans[t] + x, ++t; while (t &lt; n) ans[t + 1] = ans[t], ++t; for (cin >> m; m--; ) &#123; int x; cin >> x; cout &lt;&lt; sum - ans[x] &lt;&lt; \"\\n\"; &#125; return 0; &#125; B. 灯光表演 Portal.nnn 个灯有初始状态，一次操作可以区间打开/关闭/翻转，问变成目标状态的最小操作次数。n≤106n\\le 10^6n≤106。 手玩得到基础结论： 区间异或操作可以放到所有赋值操作之后； 区间赋值操作互不相交。 得到最后形态之后，区间异或操作次数为 s′xor⁡ts&#x27;\\operatorname{xor} ts′xort 的极长 111 段数。 fi,0/1/2f_{i,0/1/2}fi,0/1/2​ 代表以 iii 结尾，第 iii 位用 000、111、保持原样 来覆盖的最小代价。枚举上一位情况即可实现 O(n)O(n)O(n) 转移。 #include &lt;bits/stdc++.h> using namespace std; int n; char s[1000005], t[1000005]; int f[1000005][3]; int main(void) &#123; scanf(\"%d%s%s\", &amp;n, s + 1, t + 1); memset(f, 0x3f, sizeof f); f[1][0] = 1 + (t[1] == '1'); f[1][1] = 1 + (t[1] == '0'); f[1][2] = (s[1] != t[1]); for (int i = 2; i &lt;= n; ++i) &#123; if (t[i] == '0') f[i][0] = min(&#123;f[i - 1][0], f[i - 1][1] + 1, f[i - 1][2] + 1&#125;); else f[i][0] = min(&#123;f[i - 1][0] + (t[i - 1] == '0'), f[i - 1][1] + (t[i - 1] == '1') + 1, f[i - 1][2] + (s[i - 1] == t[i - 1]) + 1&#125;); if (t[i] == '1') f[i][1] = min(&#123;f[i - 1][0] + 1, f[i - 1][1], f[i - 1][2] + 1&#125;); else f[i][1] = min(&#123;f[i - 1][0] + (t[i - 1] == '0') + 1, f[i - 1][1] + (t[i - 1] == '1'), f[i - 1][2] + (s[i - 1] == t[i - 1]) + 1&#125;); if (s[i] == t[i]) f[i][2] = min(&#123;f[i - 1][0], f[i - 1][1], f[i - 1][2]&#125;); else f[i][2] = min(&#123;f[i - 1][0] + (t[i - 1] == '0'), f[i - 1][1] + (t[i - 1] == '1'), f[i - 1][2] + (s[i - 1] == t[i - 1])&#125;); &#125; printf(\"%d\\n\", min(&#123;f[n][0], f[n][1], f[n][2]&#125;)); return 0; &#125; * C. 时间旅人 Portal.nnn 个点，第 iii 条路连接第 iii 和 i+1i+1i+1 个点。第 iii 条路在 [li,ri][l_i,r_i][li​,ri​] 时开放，通过一条路需要 111 的时间，行动需要保证在穿梭的过程中道路一直是开放的。Bitaro 是能穿梭时间的河狸，它在城市可以穿梭回一秒前。给定 QQQ 次询问：改变 iii 道路的开放时间。假设 BBB 时刻它在 AAA 城，问最少需要进行多少次时间旅行才能在 DDD 时刻前到达 CCC 城。n,Q≤3×105n,Q\\le 3\\times 10^5n,Q≤3×105，时间在 10910^9109 级别。 显然走的方式很呆板：能走就走，不能走就时间旅行。现在假设 A&lt;CA&lt;CA&lt;C。 设 yyy 时刻的 xxx 城市代表 (x,y)(x,y)(x,y)，套路地，为了避免行走时时间流逝的自然影响，将其改成 (x,y−x)(x,y-x)(x,y−x)。 用 (a,b,c)(a,b,c)(a,b,c) 表示行动，aaa 为开始时刻，bbb 为结束时刻，ccc 为时间倒流次数。(L,R)(L,R)(L,R) 代表这条道路只能在 [L,R][L,R][L,R] 时通过。现在考虑如何合并： 两个二元：如果有交集则取交集，否则可以转化为三元组。 一二一三：观察二元组和 aaa 的关系即可算出。 两个三元：计算中间时间穿越的次数即可。 最终答案用起终点的两个三元组加上中间路径的三元组即可得到。具有结合律，可以使用线段树维护。A&gt;CA&gt;CA&gt;C 的情况是对称的。时间复杂度 O((n+q)log⁡n)O((n+q)\\log n)O((n+q)logn)。 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int INF = 1e9; int n, q; int l[300005], r[300005]; struct Node &#123; int l, r; i64 val; Node(int l = -INF, int r = INF, i64 val = -1) : l(l), r(r), val(val) &#123;&#125; friend Node operator+ (const Node &amp;a, const Node &amp;b) &#123; if (a.val == -1 &amp;&amp; b.val == -1) &#123; if (a.l > b.r) return Node(a.l, b.r, a.l - b.r); if (a.r &lt; b.l) return Node(a.r, b.l, 0); return Node(max(a.l, b.l), min(a.r, b.r)); &#125; if (a.val == -1) &#123; if (b.l &lt; a.l) return Node(a.l, b.r, b.val + a.l - b.l); if (b.l > a.r) return Node(a.r, b.r, b.val); return b; &#125; if (b.val == -1) &#123; if (a.r &lt; b.l) return Node(a.l, b.l, a.val); if (a.r > b.r) return Node(a.l, b.r, a.val + a.r - b.r); return a; &#125; return Node(a.l, b.r, a.val + b.val + max(0, a.r - b.l)); &#125; &#125;; struct Segment_Tree &#123; Node T[1200005]; void update(int o, int l, int r, int p, int x, int y) &#123; if (l == r) return T[o] = Node(x, y, -1), void(); int mid = l + r >> 1; if (p &lt;= mid) update(o &lt;&lt; 1, l, mid, p, x, y); else update(o &lt;&lt; 1 | 1, mid + 1, r, p, x, y); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int p, int x, int y) &#123; update(1, 1, n - 1, p, x, y); &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return query(o &lt;&lt; 1, l, mid, x, y) + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); &#125; Node query(int x, int y) &#123; return query(1, 1, n - 1, x, y); &#125; &#125; tL, tR; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> q; for (int i = 1; i &lt; n; ++i) &#123; cin >> l[i] >> r[i]; tL.update(i, l[i] - i, r[i] - 1 - i); &#125; reverse(l + 1, l + n); reverse(r + 1, r + n); for (int i = 1; i &lt; n; ++i) tR.update(i, l[i] - i, r[i] - 1 - i); while (q--) &#123; int op; cin >> op; if (op == 1) &#123; int p, l, r; cin >> p >> l >> r; tL.update(p, l - p, r - 1 - p); p = n - p; tR.update(p, l - p, r - 1 - p); &#125; else &#123; int a, b, c, d; cin >> a >> b >> c >> d; if (a &lt; c) cout &lt;&lt; max(0ll, (Node(b - a, b - a) + tL.query(a, c - 1) + Node(d - c, d - c)).val) &lt;&lt; \"\\n\"; else if (a == c) cout &lt;&lt; max(0, b - d) &lt;&lt; \"\\n\"; else &#123; a = n - a + 1; c = n - c + 1; cout &lt;&lt; max(0ll, (Node(b - a, b - a) + tR.query(a, c - 1) + Node(d - c, d - c)).val) &lt;&lt; \"\\n\"; &#125; &#125; &#125; return 0; &#125; Day4 A，B，C。 A. * 蛋糕拼接 3 Portal.n(n≤2×105)n(n\\le 2\\times 10^5)n(n≤2×105) 块蛋糕有自己的价值 ViV_iVi​ 和颜色 CiC_iCi​，需要选择 MMM 块互不相同的蛋糕拼成一个环，蛋糕的美味程度为：∑j=1MVkj−∑j=1∣Ckj−Ckj mod M+1∣\\sum_{j=1}^M V_{k_j}-\\sum_{j=1}|C_{k_j}-C_{k_j \\bmod M+1}|j=1∑M​Vkj​​−j=1∑​∣Ckj​​−Ckj​modM+1​∣给定 MMM，求出一个 kkk，问最大的美味程度。 如果选定了 kkk，那么按照 CCC 排序算出贡献。 打表发现具有决策单调性，分治计算即可。 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 200005; int n, m, nn; struct Cake &#123; int v, c; bool operator&lt; (const Cake &amp;a) const &#123; return c &lt; a.c; &#125; &#125; a[N]; int b[N]; struct Node &#123; int ls, rs; int siz; i64 sum; &#125; T[N * 40]; int rt[N], tot; int update(int pre, int l, int r, int x, int v) &#123; int o = ++tot; T[o] = T[pre]; ++T[o].siz; T[o].sum += v; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x, v); else T[o].rs = update(T[pre].rs, mid + 1, r, x, v); return o; &#125; i64 query(int p, int q, int l, int r, int k) &#123; // 值域在 [l, r] 中的 V 最大 k 个的答案 if (l == r) return 1ll * k * b[l]; int mid = l + r >> 1, res = T[T[q].rs].siz - T[T[p].rs].siz; if (res >= k) return query(T[p].rs, T[q].rs, mid + 1, r, k); return query(T[p].ls, T[q].ls, l, mid, k - res) + T[T[q].rs].sum - T[T[p].rs].sum; &#125; i64 ans = -1e18; inline i64 calc(int l, int r) &#123; return query(rt[l - 1], rt[r], 1, nn, m) - 2 * (a[r].c - a[l].c); &#125; void solve(int l, int r, int L, int R) &#123; // 决策区间 [L, R] if (l > r) return; int mid = l + r >> 1, p = 0, RR = min(R, mid - m + 1); i64 mx = -1e18; for (int i = L; i &lt;= RR; ++i) &#123; i64 w = calc(i, mid); if (w > mx) mx = w, p = i; &#125; ans = max(ans, mx); solve(l, mid - 1, L, p); solve(mid + 1, r, p, R); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i].v >> a[i].c, b[i] = a[i].v; sort(b + 1, b + n + 1); sort(a + 1, a + n + 1); nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) rt[i] = update(rt[i - 1], 1, nn, lower_bound(b + 1, b + nn + 1, a[i].v) - b, a[i].v); solve(m, n, 1, n); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; B. 合并 Portal.n(n≤2×105)n(n\\le 2\\times 10^5)n(n≤2×105) 个点的树，每个点有颜色，一次操作可以将两种操作并为一种颜色。一棵树是不合法的，当且仅当存在一条边，没有任何一种颜色存在于两边。问使得树合法的最小操作数。 合并所有的两个相同颜色构成的链上的边，最后合并所有度数为 111 的点，答案是 ⌈c2⌉\\left\\lceil \\frac c 2 \\right\\rceil⌈2c​⌉。时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)（并查集只路径压缩）。 #include &lt;bits/stdc++.h> using namespace std; int n, k, a[500005]; vector&lt;int> G[500005]; int f[500005], dep[500005]; int bin[500005]; int find(int x) &#123; return bin[x] == x ? x : bin[x] = find(bin[x]); &#125; void dfs(int x, int fa) &#123; dep[x] = dep[f[x] = fa] + 1; bin[x] = x; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int lst[500005]; void calc(int x, int y) &#123; x = find(x); y = find(y); while (x != y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); bin[x] = find(bin[f[x]]); x = find(x); &#125; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> k; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; if (lst[a[i]]) calc(lst[a[i]], i); lst[a[i]] = i; &#125; static int deg[500005]; memset(deg, 0, sizeof deg); for (int i = 2; i &lt;= n; ++i) &#123; int x = find(f[i]), y = find(i); if (x != y) ++deg[x], ++deg[y]; &#125; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += (deg[i] == 1); cout &lt;&lt; (cnt == 1 ? 0 : (cnt + 1) / 2) &lt;&lt; \"\\n\"; return 0; &#125; * C. 矿物 Portal.2n(n≤4.3×104)2n(n\\le 4.3\\times 10^4)2n(n≤4.3×104) 个球，nnn 种颜色每种恰好出现两次，需要将球配对。可以询问 10610^6106 次：插入/删除一个球，得到颜色种类数。 看到这个数据范围考虑分治。solve(A, B) 表示所有相同颜色的球一个在 AAA，另一个在 BBB。只需要对 AAA 的前一半问一次，然后对 BBB 全部问一次，就可以得到 BBB 中的是否归 AAA 的前一半的。 卡常卡到丧心病狂，中点分治不一定是最优，发现稍微小一点表现更好，随机偏移一下。同时，注意不要浪费非必要的询问。 #include &lt;bits/stdc++.h> #include \"minerals.h\" using namespace std; mt19937 Rand(time(0)); double rnd(double l, double r) &#123; return uniform_real_distribution&lt;double>(l, r)(Rand); &#125; bool query(int x) &#123; static int last = 0; int v = Query(x); if (v == last) return 0; return last = v, 1; &#125; void solve(vector&lt;int> a, vector&lt;int> b, bool in) &#123; if (a.size() == 1) return Answer(a[0], b[0]); vector&lt;int> bl, br; int m = max(1, int(a.size() * rnd(0.3, 0.5))); for (int i = 0; i &lt; m; ++i) query(a[i]); for (int i : b) if (bl.size() == m) br.emplace_back(i); else if (br.size() == a.size() - m) bl.emplace_back(i); else if (query(i) == in) bl.emplace_back(i); else br.emplace_back(i); solve(vector&lt;int>(a.begin(), a.begin() + m), bl, !in); solve(vector&lt;int>(a.begin() + m, a.end()), br, in); &#125; void Solve(int n) &#123; n &lt;&lt;= 1; vector&lt;int> a, b; static int id[200005]; for (int i = 1; i &lt;= n; ++i) id[i] = i; shuffle(id + 1, id + n + 1, Rand); for (int i = 1; i &lt;= n; ++i) if (query(id[i])) a.emplace_back(id[i]); else b.emplace_back(id[i]); solve(a, b, 1); &#125; 总结 10/8 机房集体 CF 被所有人干烂了…… 唉，加训，加训！ 在笔者的设定中，闪耀的芝士蛋挞可以在暗夜中发出荧光，并且无毒，暂时没有想到如何制作；而深潜的极寒冰沙是世界上最寒冷的冰激凌，但是需要保证它的比热足够低，这样才能正常食用它。 ↩︎","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"JOI","slug":"算法竞赛/做题记录/JOI","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/JOI/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"集训队作业 2021","slug":"default/ioihw-2021","date":"2023-09-23T00:00:00.000Z","updated":"2023-09-23T00:00:00.000Z","comments":true,"path":"d419e905/","link":"","permalink":"https://james1badcreeper.github.io/d419e905/","excerpt":"2021 是 ACM 题，反正做做看吧。","text":"2021 是 ACM 题，反正做做看吧。 感谢 M_sea。 由于笔者暂时没有上紫名，所以预计 11 月份修复本文所有的代码链接。 PART I 我还是不知道。 A 发现好多不是我能做的…… [ICPC2014 WF] Baggage Portal. 我们是否能将 nnn 较大的转化为 nnn 较小的？观察样例，n=5n=5n=5 时整体左移了两格，发现只需要利用左四右四个数就可以做成左边空两格，将 n≤7n\\le 7n≤7 的打表打出解即可（n=3n=3n=3 特殊，只左移两格是无解的）。代码。 跳过 *2 PART III Portal. A 满天星斗，广袤宇宙，不如向前走。 [CERC2015] Cow Confinement Portal. 一头牛的话显然是 DP（fi,j=fi+1,j+fi,j+1−fi+1,j+1f_{i,j}=f_{i+1,j}+f_{i,j+1}-f_{i+1,j+1}fi,j​=fi+1,j​+fi,j+1​−fi+1,j+1​），那么考虑用扫描线从右向左扫，线段树维护当前每个点的 DP 值。如果扫到了一个右区间，那么从上线到下一条下线都要被加在上线上的一个格子，并且线内数据清零。扫到左线线内数据清零，并把原来线外的东西加回来，最后再把右下角算重的部分减去就行。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"NOI 一轮复习 IV：图论","slug":"notes/NOI 复习/noi-1-4","date":"2023-09-20T00:00:00.000Z","updated":"2024-03-13T00:00:00.000Z","comments":true,"path":"d25bf624/","link":"","permalink":"https://james1badcreeper.github.io/d25bf624/","excerpt":"本文是 NOI 一轮复习的第四篇，包括各类图论算法。","text":"本文是 NOI 一轮复习的第四篇，包括各类图论算法。 图的相关概念 一张图 GGG 由点集 VVV 和边集 EEE 构成。我们用 d(v)d(v)d(v) 代表节点 vvv 的度数，如果 d(v)=∣V∣−1d(v)=|V|-1d(v)=∣V∣−1，则称 vvv 为支配点。如果每个点的度数都是 kkk，则该图为 k−k-k−正则图。 子图 对一张图 G=(V,E)G = (V, E)G=(V,E)，若存在另一张图 H=(V′,E′)H = (V&#x27;, E&#x27;)H=(V′,E′) 满足 V′⊆VV&#x27; \\subseteq VV′⊆V 且 E′⊆EE&#x27; \\subseteq EE′⊆E，则称 HHH 是 GGG 的子图，记作 H⊆GH \\subseteq GH⊆G。 若对 H⊆GH \\subseteq GH⊆G，满足 ∀u,v∈V′\\forall u, v \\in V&#x27;∀u,v∈V′，只要 (u,v)∈E(u, v) \\in E(u,v)∈E，均有 (u,v)∈E′(u, v) \\in E&#x27;(u,v)∈E′，则称 HHH 是 GGG 的导出子图。点集为 V′(V′⊆V)V&#x27;(V&#x27; \\subseteq V)V′(V′⊆V) 的导出子图称为 V′V&#x27;V′ 导出的子图，记作 G[V′]G \\left[ V&#x27; \\right]G[V′]。 若 H⊆GH \\subseteq GH⊆G 满足 V′=VV&#x27; = VV′=V，则称 HHH 为 GGG 的生成子图/支撑子图。 如果一张无向图 GGG 的某个生成子图 FFF 为 k−k-k−正则图，则称 FFF 为 GGG 的一个 k−k-k−因子。 如果有向图 G=(V,E)G = (V, E)G=(V,E) 的导出子图 H=G[V∗]H = G \\left[ V^\\ast \\right]H=G[V∗] 满足 ∀v∈V∗,(v,u)∈E\\forall v \\in V^\\ast, (v, u) \\in E∀v∈V∗,(v,u)∈E，有 u∈V∗u \\in V^\\astu∈V∗，则称 HHH 为 GGG 的一个闭合子图。也就是说，图内部是闭合的，不存在一个点在导出子图内，可以通过原图的一条边连到一个不在导出子图内的点。 特殊的图 对于无向简单图，所有本来在图上的边都不在，本来不在的都在，那么这个图就是原无向图的补图。 对于有向图，每条边的方向取反，得到的图就是原图的反图。 特殊集合 一些特殊的点和边的集合有着特殊的意义，这里我们介绍一些常见的。 支配集 对于无向图，如果一个点集的点可以连接到原图的所有点，那么这个点集为原图的支配集。 最小支配集是 NPH 的，我们通常使用 O(2n)O(2^n)O(2n) 的枚举算法来求解支配集。 独立集 就是任意两点不相邻的点集。对于树和二分图我们有高效做法，但是一般图上，这个问题是 NPH 的。 匹配 对于图 G=(V,E)G=(V,E)G=(V,E)，若 E′∈EE&#x27;\\in EE′∈E 且 E′E&#x27;E′ 中任意两条边都没有公共端点，且 E′E&#x27;E′ 中没有自环，那么 E′E&#x27;E′ 是 GGG 的一个匹配，也称为边独立集。如果一个点被匹配的边连接了，那么它就是被匹配的，否则就是不被匹配的。 边数最多的称为最大匹配，如果边带权，那么权重之和最大的匹配称为图的最大权匹配。 如果一个匹配在加入任何一条边后都不再是一个匹配，那么这个匹配就是极大匹配，最大匹配一定是极大匹配。 如果所有点都被匹配了，那么这个匹配是完美匹配。如果在一个匹配中只有一个点不被匹配，那么该匹配为准完美匹配。 对于一个匹配 MMM，若一条路径以非匹配点为起点，每相邻两条边中的一条在匹配中而另一条不在匹配中，那么这条路径称为交替路径；一条非匹配点终止的交替路径称为增广路径。 点覆盖 如果所有边都至少有一个端点在这个点集中，那么这个点集被称为点覆盖集。 点覆盖集一定是支配集，但是极小点覆盖集不一定是极小支配集（考虑一个三元环）。 点覆盖集拥有以下性质： 一个点集是点覆盖的充要条件是其补集是独立集。 一张图的任何一个匹配的大小都不超过其任何一个点覆盖的大小。 边覆盖 当前边集满足任何一个点都至少是其中一条边的一个端点，那么这个边集称为边覆盖集。 如果知道了最大匹配，那么将所有非匹配点都连一条边加入最大匹配，那么就得到了一个最小边覆盖。同理，如果知道了最小边覆盖，那么将有公共点的边删去到只剩一条就得到了最大匹配。 团 一个图的子点集 V′V&#x27;V′ 中任意两个不同的顶点都相邻，则称 V′V&#x27;V′ 是图 GGG 的一个团。团对应的导出子图是完全图。说白了最大团就是最大完全子图。 求解一个图的最大团是 NPH 的，可以使用最大团搜索算法（在暴力枚举的基础上加一个不可能成为答案的最优性剪枝）来解决规模较小的图的问题。 Erdős–Gallai 定理 令 S=(d1,⋯ ,dn)S=(d_1,\\cdots,d_n)S=(d1​,⋯,dn​) 代表简单无向图的度数，而且 ddd 为非递增序列，则无向图存在当且仅当 ∑d\\sum d∑d 是偶数，而且 ∀k,i.e.\\forall k, \\text{i.e.}∀k,i.e.： ∑i=1kdi≤k(k−1)+∑i=k+1nmin⁡(di,k)\\sum_{i=1}^kd_i\\leq k(k-1)+\\sum_{i=k+1}^n\\min(d_i,k) i=1∑k​di​≤k(k−1)+i=k+1∑n​min(di​,k) [CF1091E] New Year and the Acquaintance Estimation.一张 n+1n+1n+1 个点的无向图，给定前 nnn 个点的度数，问 n+1n+1n+1 号点可能的度数。n≤5×105n\\le 5\\times 10^5n≤5×105。 二分出可能的度数，然后 Erdős–Gallai 定理不难在预处理前缀后做到 O(n)O(n)O(n) check。代码。 拓扑排序 对于一个有向无环图（DAG）GGG，将 GGG 中所有顶点排成一个线性序列，使得图中任意一对顶点 uuu 和 vvv ，若它们之间存在一条有向边 (u,v)(u,v)(u,v)，则 uuu 在线性序列中出现在 vvv 之前。 如果要让越小的 iii 尽可能地出现地早，那么就是让最大的尽可能晚地出现，那么要求反图上字典序最大的拓扑序，也就是菜肴制作。 欧拉路问题 欧拉回路：通过图中的每条边恰好一次的回路； 欧拉通路：通过图中的每条边恰好一次的通路； 欧拉图：有欧拉回路； 半欧拉图：有欧拉通路但是没有欧拉回路。 对于无向连通图，如果所有点的度数均为偶数，那么是欧拉图；如果有恰好两个奇度数点，那么是半欧拉图。 而对于一张有向图（显然，它至少需要弱连通），是欧拉图当且仅当其是一个强连通图且每个节点的入度和出度相等。如果这张图恰存在一个顶点的出度比入度小 111，另一个点出度比入度大 111（这个点为起点），这个图存在欧拉通路。 求解欧拉路可以使用 Hierholzer 算法。采用 DFS 不断找环，遍历当前节点 uuu 的所有出边，如果没有走过那就遍历，遍历完所有出边后将 uuu 加入欧拉路径，最后如果遍历的点的个数为 m+1m+1m+1，那么就得到了反着的欧拉路径，否则欧拉路径不存在。 在找欧拉回路时，可以从任意节点出发。否则，需要从根据性质找到的点出发。代码。 哈密顿路问题 将欧拉路边的相关定义换成点就成了哈密顿路。通过图中所有顶点一次且仅一次的通路称为哈密顿通路。通过图中所有顶点一次且仅一次的回路称为哈密顿回路。具有哈密顿回路的图称为哈密顿图。具有哈密顿通路而不具有哈密顿回路的图称为半哈密顿图。 不同于欧拉路，哈密顿路问题不存在多项式复杂度算法。人们尝试过许多方法，包括尝试转化成欧拉路，拆点限制只经过一次然后转化为网络流等，但很可惜都是假做法。 不过网络流的这个做法真的很有启发性，有些特殊条件的图真的可以使用它来求解。 Ore 定理。对于一个简单无向图，如果任意两个不相邻点度数和大于等于 nnn，那么这个图存在哈密顿回路，大于等于 n−1n-1n−1 时存在哈密顿通路。这是一个充分不必要条件。 例题 一些基础题。 [CF1765H] Hospital Queue Portal. 对于每个点考虑 n∼1n\\sim 1n∼1 能否不成为它的答案，为什么这么干？因为这样处理每个人的 deadline 比较方便。代码。 [CF1152E] Neko and Flashback Portal. 对于一个 iii，有 bi=min⁡{ai,ai+1},ci=max⁡{ai,ai+1}b_i=\\min\\{a_i,a_{i+1}\\},c_i=\\max\\{a_i,a_{i+1}\\}bi​=min{ai​,ai+1​},ci​=max{ai​,ai+1​}，也就是说 bi,cib_i,c_ibi​,ci​ 各是 ai,ai+1a_i,a_{i+1}ai​,ai+1​ 其中的一个（当然需要 bi≤cib_i\\le c_ibi​≤ci​，否则无解）。 注意这个输出方式，ppp 的作用是将 aaa 排列，也就是说我们只需要求出 aaa 有哪些数组成即可。将给定的 ai,ai+1a_i,a_{i+1}ai​,ai+1​ 的关系看成一条无向边，走过这个路径就相当于满足了一个限制条件。那么在图上找出欧拉路，就可以得到一个满足所有的限制条件的序列 aaa（需要先离散化后再建图）。时间复杂度 O((n+m)log⁡m)O((n+m)\\log m)O((n+m)logm)。代码。 [CF36E] Two Paths Portal. 一道值得一想不值得一写的欧拉路。 原图中最多只能有两个连通块，有两个时就是分别找欧拉路，下面来看只有一个。 如果它只有零个或两个奇点，那么有一个欧拉路，我们把这条路径分开一条边作为一部分，这样就是两部分了（分不出来就无解）！ 如果有四个奇点，那么是两个（半）欧拉图拼起来的，因此考虑给两个奇点连一条假边，跑欧拉路，输出的时候以这条假边为分界输出两部分。 由于要输出边的编号，因此用链式前向星方便一些，搞点的时候遍历所有的边寻找对应的是哪一条。代码。 [CF527E] Data Center Drama Portal. 最终要满足的条件是欧拉图的充要条件，然后定向一下边即可。所以将总度数为奇数的点两两相连，然后不满足加一个自环即可。代码。 * [CF1458D] Flip and Reverse Portal. 令 000 为 −1-1−1，111 为 +1+1+1，然后连 si→si+1s_i\\rightarrow s_{i+1}si​→si+1​ 的边，那么选择的字符串就是一个环，将字符串取反相当于将一个环的方向反过来。这样，任何一条欧拉回路都可以被构造出来，也就是要求经过的边的字典序最小的欧拉路径，如果回路存在则直接贪心即可。代码。 [ByteDance 2022 Final] Card Shark Portal. 按照顺序构建，最后要求的是边字典序最小的欧拉路径。代码。 连通性问题 对于一张无向图，如果能够从 uuu 走到 vvv，那么称 uuu 和 vvv 是连通的。一个极大连通子图被称为连通分量。 对于一张有向图，将边替换成无向边可以连通则是弱连通的，不需要替换则是强连通的。同样可以定义连通分量的概念。 大部分的连通性问题都离不开 Tarjan 算法，因此我们先来回顾一下它的工作原理。它对每个结点 uuu 维护了以下值： 时间戳 dfnudfn_udfnu​； 追溯值 lowulow_ulowu​ 代表 uuu 的子树中能够回溯到的最早的已经在栈中的结点。 在一个 SCC 中只有一个点满足 dfnu=lowudfn_u=low_udfnu​=lowu​，该结点一定是在深度遍历的过程中，该连通分量中第一个被访问过的结点。 根据此我们可以求出无向图的点双边双，有向图的 SCC。 无向图的双连通性 如果将 E′E&#x27;E′ 从 EEE 中删去，GGG 便不再连通，那么 E′E&#x27;E′ 是 GGG 的一个边割集，大小为 111 的边割集称为割边/桥。割边一定是树边，判定条件是 dfnu&lt;lowvdfn_u&lt;low_vdfnu​&lt;lowv​。 如果 GGG 不存在大小为 k−1k-1k−1 的边割集，则称 GGG 是 k−k-k−边连通的，kkk 最大时，称 kkk 为 GGG 的边连通度。 对于点也可以做同样的定义。割点的判定条件是 dfnu≤lowvdfn_u\\le low_vdfnu​≤lowv​，除了 Tarjan 的根节点，根节点需要有两个点满足这个条件；而有多少个点满足这个条件，就是割掉这个点之后图会分成多少个连通块。 门杰定理推论： 对于边双内的任意两点 u,vu,vu,v，存在经过 u,vu,vu,v 的回路。 对于 ≥3\\ge 3≥3 的点双中的两点 x,yx,yx,y（可以相等）与一条边 eee，存在 x→e→yx\\rightarrow e \\rightarrow yx→e→y 的简单路径；这可以说明存在经过 x,yx,yx,y 必定存在简单环，从 xxx 可以绕回自己。 仙人掌 如果一个图的所有环都没有相交的边，那么这个图被称为仙人掌。 一般我们使用圆方树来处理仙人掌，这个“代表点”称为“方点”，而原图中的所有点对应“圆点”。代码如下： 制毒大枭投掷了神秘的毒药。仙人掌上可以处理的问题非常多，由于其不是很常出现，在此我们只研究仙人掌上两点距离这一个问题。应该会在近期更新。按照计划此处应该不会再做更新，但如果时间非常充裕则会做考虑。 广义圆方树 广义圆方树可以高效处理无向图双连通的相关问题。它是 v-DCC 缩点之后的产物。我们建出 v-DCC 的“代表点”并向 v-DCC 内部所有点连边，这样会形成一个菊花图。 也就是说，广义圆方树会将非环边也建一个方点。那么圆方树对应一棵唯一仙人掌的性质便不再成立。因此不推荐处理仙人掌时采用广义圆方树的处理方法。 void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; // 找到了一个以 x 为根的 v-DCC int z; ++n; // 新建一个方点 do addedge(z = st[tot--], n); while (z != y); addedge(x, n); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; 广义圆方树有很美妙的性质，首先是 v-DCC 的引理： 引理：如果 xxx 与 y,zy,zy,z 均点双连通，但是 y,zy,zy,z 不点双连通，那么 xxx 是 y,zy,zy,z 的必经点。 然后是广义圆方树的性质： 性质 1：圆点 xxx 的度数为它所在的 v-DCC 个数。 性质 2：圆方树上只有圆点和方点之间有边。 性质 3：原图上直接相连的 x,yx,yx,y 属于一个 v-DCC，而且如果这个 v-DCC 的大小为 222，那么 (x,y)(x,y)(x,y) 是割边。值得注意的是，广义圆方树无法处理重边的情况，使用此性质判断割边时需要看一下 (x,y)(x,y)(x,y) 边是否为重边。 下面三个是用来做题的： 性质 4：圆点 xxx 是叶子当且仅当它在原图上不是割点。证明：如果 xxx 是割点，那么 xxx 至少属于两个 v-DCC，这样存在 y,zy,zy,z 两点与 xxx 都点双连通，但是 y,zy,zy,z 不点双连通，因此 xxx 是 y,zy,zy,z 的必经点，这样它不是叶子。性质 5：广义圆方树上删掉圆点 xxx 后剩余节点的联通性与原图上删除 xxx 相等。证明：如果 xxx 是叶子，也就是它不是割点，删除显然没有影响。如果它是原图的割点，比如说 xxx 在圆方树上连接了 y,zy,zy,z，那么与 y,zy,zy,z 所在的点双连通之间不在连通，与其割点的性质是一样的。性质 6：x,yx,yx,y 简单路径上的所有圆点就是原图中 x,yx,yx,y 之间的所必经点。这是圆方树的核心性质。 有向图的强连通性 两点互相可达称为强连通，同样可以使用 Tarjan 算法求解。 void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do ins[y = st[tot--]] = false, c[y] = cnt; while (x != y); &#125; &#125; 求解出来的 SCC 编号从大到小就是拓扑序的顺序，可以在缩点后不进行拓扑排序，直接 DP 求解。 2-SAT 问题 k-SAT 问题是指一个变量有 kkk 种取值，有一些形如 xix_ixi​ 为 aaa 或 xjx_jxj​ 为 bbb 的条件，要求你给出一组合法解。 对于 2-SAT 我们有高效做法。每个变量建立两个点代表其真假，连边之后求出 SCC，同一 SCC 内的变量值相等。 例题 我不知道啊！ [CF51F] Caterpillar Portal. 毛毛虫上不能长出来环，所以把每一个 e-DCC 缩点，图会变成一个森林，我们需要处理每一棵树，然后把这些树合并，需要树的个数减去一的代价。 由于环必须要合并，如果要直接统计操作次数还需要统计环的大小，不妨换一个思路，默认所有点都需要合并，然后减去不需要合并的。 现在考虑最后一个问题，一棵树怎么处理？直觉告诉我们：这条路径 ppp 应该是长度为 ddd 直径，这样才能让要动的点更少。直径可以让我们少合并 ddd 个点，叶子上的点也可以不用合并（画个图看看），但是直径两端还有两个叶子，所以要减去。代码。 [GDCPC2023] Canvas Portal. 由于第二次染色是无意义操作，因此考虑逆时旅人，这样变成了只有第一次会影响。 所有的 x=y=2x=y=2x=y=2 操作优先执行，所有的 x=y=1x=y=1x=y=1 最后执行，然后考虑剩下的填在中间。每有一个 x+y=3x+y=3x+y=3 执行就意味着有一个数被定死为 111，那么 (l,1,r,2)(l,1,r,2)(l,1,r,2) 相当于“用 lll 变成 111 的代价换来 rrr 变成 222”，这个关系可以用有向边 l→rl\\rightarrow rl→r 刻画，发现图上的一条链只有链首是 111。 SCC 缩点之后只有入度为 000 的点涂一个 111 即可。代码。 [北京省选集训 2019] 完美塔防 Portal. 由于光路是可逆的，因此一个路只能被两个防御塔打到。不难发现这就是一个 2-SAT，处理出打它的炮塔即可。代码。 [CF1835D] Doctor’s Brown Hypothesis Portal. x,yx,yx,y 双向可达说明其在同一个 SCC 内，那么 SCC 缩点后分别求答案。 设 ddd * 「SWTR-8」地地铁铁 Portal. 首先建出圆方树，如果 x,yx,yx,y 间有某个有 111 边的点双，那么它们一定能通过这条路径。 那么对于原图上一条 000 边 (u,v)(u,v)(u,v)，它恰属于一个点双 SSS 的方点打标记，统计圆方树上不经过标记点的圆点间路径数即可。这样能计数只经过 000 边的无序对。 看到这里感觉可以容斥了，也就是说要计数只有 0/1 路径，同时有 0 路径和 1 路径。 后者怎么做？可以发现这样的 (x,y)(x,y)(x,y) 点对一定在一个点双内。然后在这个点双内恰好满足只有这两个点即被 1 边连，又被 2 边连。代码。 最短路问题 对于无权图（01 带权），可以使用 BFS 求解最短路。 对于多源最短路，可以使用 Floyd 算法，也就是通过 nnn 轮 DP 来求解最短路。 对于单源最短路，可以使用 Dijkstra 和 SPFA。Dijkstra 基于贪心的思想，每次寻找当前最短的路来走，正确性基于边权非负；SPFA 则通过 O(nm)O(nm)O(nm) 的迭代来更新最短路，进而可以判断负环的存在性。 Johnson 通过将边改造为 (u,v,w+du−dv)(u,v,w+d_u-d_v)(u,v,w+du​−dv​) 来实现，边权是三角形不等式来满足 ≥0\\ge 0≥0，建立超级源点跑 SPFA 即可。代码。 如果我们要求的是最短简单路径（有负环），那么它是一个 NPC 问题。 差分约束 根据三角形不等式进行连边，然后用 SPFA 判断负环。 值得注意的是，如果使用 SPFA 求最短路，那么得到的是字典序最大的解。对于字典序最小的解，只需要将约束条件统统变为 xi−xj≥yx_i-x_j\\ge yxi​−xj​≥y，然后跑最长路，有正环时无解（就是边的方向和权值都取反）。 [省选联考 2021 A 卷] 矩阵游戏。答案的构造是容易的，然后需要调整这个答案，让每一行和列依次 +1,−1+1,-1+1,−1，然后错开，直接差分约束即可。代码。 斯坦纳树 如果给定 nnn 个点，试求连接此 nnn 个点，总长最短的直线段连接系统，并且并且任意两点都可以通过系统中的直线段组成的折线连接起来，此问题被称为斯坦纳树问题。遗憾的是，这是一个 NPH 问题。 最小斯坦纳树。给定一个 nnn 个点 mmm 条边无向图 G=(V,E)G=(V,E)G=(V,E)，再给定包含 kkk 个节点的点集 SSS，选出 GGG 的连通子图 G′=(V′,E′)G&#x27;=(V&#x27;,E&#x27;)G′=(V′,E′)，要求：S⊆V′S \\subseteq V&#x27;S⊆V′，E′E&#x27;E′ 中所有边的权值和最小。你需要求出这个最小权值和，n≤100,m≤500,k≤10n\\le 100,m\\le 500,k\\le 10n≤100,m≤500,k≤10。 并不是直接将 SSS 连接起来就是最小的，可能需要借助剩下的 n−kn-kn−k 个点。这种问题可以使用状压 DP 来解决： 设 f(i,S)f(i,S)f(i,S) 表示以 iii 为根的一棵树，包含集合 SSS 中所有点的最小边权值和。有转移：f(i,S)←min⁡{f(i,T)+f(i,S−T)},f(i,S)←min⁡{f(j,S)+w(i,j)}f(i,S)\\leftarrow\\min\\{f(i,T)+f(i,S-T)\\},f(i,S)\\leftarrow\\min\\{f(j,S)+w(i,j)\\}f(i,S)←min{f(i,T)+f(i,S−T)},f(i,S)←min{f(j,S)+w(i,j)}。前者可以使用子集 DP 实现，后者可以跑一个最短路（由于图很难特殊构造而且规模很小，所以实际上更建议 SPFA）。代码。 Peach Blossom Spring，注意并不要求完全联通，最后子集和并一下即可。 平面图最小割 如果图 GGG 能画在平面 SSS 上，即除顶点处外无边相交，则称 GGG 可平面嵌入 SSS，GGG 为可平面图或平面图。画出的没有边相交的图称为 GGG 的平面表示或平面嵌入。 平面图可以转为对偶图，对偶图的最短路等于原平面图的最小割。给 GGG 的每个面搞一个点，两个面的公共边可以确定一条与其方向垂直的边。给源点和汇点连线可以将原图分成两个部分，跑最短路即可。 注意左侧和下侧，上侧和右侧分别是同一个点，从右上到左下的最短路即为左上到右下的最小割。模板，代码。 同余最短路 模板。这是一个最短路的变式问题。可以用于求解在某个范围内有多少重量可以由若干物品的完全背包凑出，就是多少数值可以由一些给定的数 bib_ibi​ 由 ∑aibi(ai≥0)\\sum a_i b_i(a_i\\ge 0)∑ai​bi​(ai​≥0) 得到。 我们可以发现，如果 xxx 可以被表示出，那么 x+kai(k&gt;0)x+ka_i(k&gt;0)x+kai​(k&gt;0) 就可以被表示出。因此我们找一个最小的 a1a_1a1​，然后连 j→(j+ai) mod a1j\\rightarrow (j+a_i)\\bmod a_1j→(j+ai​)moda1​ 的长度为 aia_iai​ 的边，然后我们从 000 开始跑最短路。由于这里图的形态不太能特殊构造，因此使用 SPFA 往往会跑的更快。最后求出的 fif_ifi​ 代表最小的能被凑出的数，满足 fi mod a1=if_i\\bmod a_1 =ifi​moda1​=i。代码。 答案的求解十分容易。[0,r][0,r][0,r] 的答案数量为： ∑i=0a1−1max⁡{0,⌊r−fia1⌋+1}\\sum_{i=0}^{a_1-1}\\max\\left\\{0,\\left\\lfloor\\frac{r-f_i}{a_1}\\right\\rfloor+1\\right\\} i=0∑a1​−1​max{0,⌊a1​r−fi​​⌋+1} 但为什么要使用最短路呢？实际上这东西是体积模 mmm 意义下的完全背包，如果重复经过一个点，那么可以选择 mgcd⁡(vi,m)−1\\frac{m}{\\gcd(v_i,m)}-1gcd(vi​,m)m​−1 个这类物品。也就是说，会在大小为 mmm 的环上形成 gcd⁡(vi,m)\\gcd(v_i,m)gcd(vi​,m) 个子环。 那么在每个子环上转两圈即可统计到所有转移，时间复杂度 O(nm)O(nm)O(nm)。代码。 [THUPC 2023] 背包。完全背包，但是 V≥1011V\\ge 10^{11}V≥1011。 如果我们将密度最大的物品选做基准物品，那么其它物品的选择可以替换为若干基准物品，这样可以最大化贡献。设基准物品体积为 www，贡献为 mmm。 设 fif_ifi​ 代表最大的贡献，满足 V mod m=iV\\bmod m=iVmodm=i。最终权值为 fi+V−V′mwf_i+\\frac{V-V&#x27;}{m}wfi​+mV−V′​w，因此要最大化 V−V′mV-\\frac{V&#x27;}{m}V−mV′​，因此贡献应该是 fp+ci−p+vimwf_p+c_i-\\frac{p+v_i}{m}wfp​+ci​−mp+vi​​w。 可以发现每个 fif_ifi​ 对应的物品个数一定是不超过 vvv 的，因此这一部分总容积不超过 v2≤Vv^2\\le Vv2≤V，不存在误判成有解的情况。代码。 删边最短路 模板。给定一张带权无向图，每个询问独立，将一条边的边权改变，询问当前 1∼n1\\sim n1∼n 的最短路。 求出 1,n1,n1,n 的最短路树 T1,TnT_1,T_nT1​,Tn​。如果改的边不是最短路上的边的答案是好算的，否则，我们要算出强制不经过一条边的新的最短路。 我们需要保证 T1,TnT_1,T_nT1​,Tn​ 上 1∼n1\\sim n1∼n 的最短路是相同的一条，否则无法计算。 求出 p1ip1_ip1i​ 代表 T1(1→i)T_1(1\\rightarrow i)T1​(1→i) 与更新路径的最后一个交点（在最短路树上跳，第一个到的最短路上的点，就是 iii 与 nnn 的 LCA），pnipn_ipni​ 同理。 这样维护先修改再单点查询的区间 ckmin 即可。代码。 显然，这种做法并不能在有向图上成立，因为不在最短路上的边可能不止一条。但是，走的路径依然满足中间只有一段不在最短路上的路径。 对于随机有向图可以采用这样一种方式处理：按照顺序遍历原最短路上的边，然后在起点上跑 SPFA，开个堆维护从哪里开始剩下的都走最短路。 k 短路 先建出一棵以 ttt 为根的最短路树 TTT，xxx 到 ttt 的最短路径为 dxd_xdx​。设 s→ts\\rightarrow ts→t 的路径上不在 TTT 中的当前选择的路径的边集为 P′P&#x27;P′，s→ts\\rightarrow ts→t 上的所有边为 PPP，那么满足： 将一条边 eee 的代价定义为 Δe=w−(du−dv)\\Delta e = w-(d_u-d_v)Δe=w−(du​−dv​)，那么 LP′=ds+∑e∈P′ΔeL_{P&#x27;} = d_s + \\sum_{e\\in P&#x27;} \\Delta eLP′​=ds​+∑e∈P′​Δe； 将 PPP 和 P′P&#x27;P′ 中所有边按照 s→ts\\rightarrow ts→t 经过的顺序依次排列，那么对于 P′P&#x27;P′ 中相邻的边 e1,e2e_1,e_2e1​,e2​，那么 ve1=ue2v_{e_1}=u_{e_2}ve1​​=ue2​​ 或者 ue2u_{e_2}ue2​​ 是 ve1v_{e_1}ve1​​ 在 TTT 上的祖先。 对于每一个合法的 P′P&#x27;P′，有且仅有一个 PPP 与之对应。因为可以根据 P′P&#x27;P′ 还原在 TTT 上选择了什么。 也就是说，我们现在要求满足性质 222 的第 kkk 小 LpL_pLp​。 我们记录最后一条边和当前 LpL_pLp​ 的值即可表示 P′P&#x27;P′。初始我们将 111 所有在 TTT 上的祖先的所有的边中 Δe\\Delta eΔe 最小的一条边加入小根堆，然后扩展时只有两种选择： 删掉 P′P&#x27;P′ 结尾的那条边，换成第二大的边； 从 P′P&#x27;P′ 的结尾开始到 TTT 的路径上，选择最小的边加入。 已知我们开始的描述路径的方式是不漏的，而且我们相当于枚举了所有的待替换边是否进行替换，因此这么做是正确的。 时间复杂度 O(mlog⁡m+klog⁡k)O(m\\log m+k\\log k)O(mlogm+klogk)，模板，代码。 kkk 短路问题能够高效解决，得益于我们只需要一个点即可描述能够被替换的边，如果要输出 kkk 短路的方案，那么就只能做到 O(k(n+m)log⁡m+klog⁡k)O(k(n+m)\\log m+k\\log k)O(k(n+m)logm+klogk) 了。 例题 从基础题目到一些复杂的变化。 [THUSCH2017] 巧克力 Portal. 如果颜色数比较少的话直接用斯坦纳树做，但是颜色数很多，钦定的可能也很多。 kkk 很小，因此考虑将所有颜色随机映射到 [0,k)[0,k)[0,k)，然后求最小斯坦纳树即可求出最小的巧克力个数 www。这 kkk 个点被分配到不同的颜色时答案合法，正确概率是 k!/kkk!/k^kk!/kk。随机化做 200200200 次即可。 然后二分出中位数，将小于等于二分值的权值都设为 inf−1inf-1inf−1，大于的都设为 inf+1inf+1inf+1，然后最小斯坦纳树要 ≤w×inf\\le w\\times inf≤w×inf（infinfinf 设置为一个不会影响斯坦纳树选择的巧克力数的一个数即可）。代码。 生成树问题 可以使用以下方法求解： Kruskal：基于贪心的思想，按照边权从小到大排序； Prim：基于贪心的思想，每次找到不在最小生成树集合，维护 did_idi​ 代表与当前树种权值最小边的权值。 对于次小生成树，其与与最小生成树最多仅有一条边的差距，枚举不是 MST 上的边，考虑删去树上的一条最小边，然后树上倍增找最大值即可。 DFS 或者 BFS 也能构建一棵生成树。对于有些题，我们会根据条件构建一棵生成树（或者是随便一棵生成树），然后再去进行操作。 一些性质 在一张图的所有 MST 上，一个权值的边的数量是一定的。 [CF891C] Envy.给定一个无向图，每次询问给定一些边的编号，问这些边是否能同时出现在一棵 MST 上。 如果这个询问的每一条边分别都能出现在 MST 上，那么这个询问就是合法的。 离线，按照边权进行排序。对于一条权值为 www 的边，它能被计入 MST，当且仅当所有 &lt;w&lt;w&lt;w 的边都被计入 MST 后加入它不会造出一个环来。代码。 Kruskal 重构树 合并两个点集时，我们新建一个节点，权值为边权，得到的二叉树是基于边权的 Kruskal 重构树。 按照点权排序，遍历每个节点 uuu 和其能到达的节点 vvv，若 vvv 已经遍历，那么 wu≥wvw_u\\ge w_vwu​≥wv​，将 vvv 的父亲设置为 uuu（如果不在一个集合内），所形成的多叉树是基于边权的 Kruskal 重构树。 重构树满足以下性质： 父亲节点的点权大于等于儿子的点权。 原图两点路径的瓶颈路等于树上的瓶颈路，即 LCA 处的权值。 Boruvka 算法 对于一个点 iii，其最小权值的临边必定在 MST 上。那么迭代 log⁡n\\log nlogn 次，每次扫描每条边，然后合并连通块。 CF888G.(i,j)(i,j)(i,j) 的边权是 ai⊕aja_i\\oplus a_jai​⊕aj​，求 MST。 考虑一个一个点权地合并，在 Trie 树上启发式合并，去找合并两个连通块地最小边权即可。 可以一开始将点权排序，这样连续的下标在 Trie 上是连续的。 最小度限制生成树 模板。最小生成树，但是要求 sss 号点恰好连接了 kkk 条边。 恰好连接，而且看起来就是凸的，因此直接 wqs 二分即可。 我们能做得更好！我们可以求出所有 fx(i)−fx(i−1)f_x(i)-f_x(i-1)fx​(i)−fx​(i−1) 并从小到大排序，取出前若干个即可得到答案。 实现上只需要先求出任意一棵生成树，然后贪心调整即可。代码。 最小直径生成树 我们先介绍图的绝对中心。无向图的绝对中心位于图的边上或者节点上，满足该中心到所有点的最短距离的最大值最小。此时对应的最短距离最大值叫做直径。 那么使用 Floyd 算法，绝对中心在点上是好计算的，对于在边 (u,v,w)(u,v,w)(u,v,w) 上的情况，到点 iii 的距离为 min⁡{du,i+x,dv,i+w−x}\\min\\{d_{u,i}+x,d_{v,i}+w-x\\}min{du,i​+x,dv,i​+w−x}： 因此我们对于一条边 (u,v,w)(u,v,w)(u,v,w)，按照纵坐标枚举 iii，然后如果最上面那个东西会产生交点的话，就更新最上面那个东西就可以了，此时用 du,i+x+dv,p+(w−x)2\\dfrac{d_{u,i}+x+d_{v,p}+(w-x)}{2}2du,i​+x+dv,p​+(w−x)​ 更新答案。代码。 对于最小直径生成树，求出图的绝对中心之后，由于图的绝对中心到最远点的距离最小，因此其所对应的半径就是最小直径生成树的半径，因此求出最短路树即可（注意初始距离），代码，注意边界点的特判。 k 小生成树 模板，仿照 kkk 短路的思路，我们来完成这个问题。 首先求出最小生成树。 对最小生成树求出权值增加量最小的非树边，则有两种选择：强制选择这条边，和强制不选择这条边。对于前者，给出了一棵新的生成树；对于后者，没有给出新的生成树，但边的状态改变了。 如果强制不选择这条边，那么接下来就是决策权值增加量次小的边是否强制选择，依次类推。于是最小生成树给出了若干棵新的生成树，其中第 iii 棵生成树钦定了权值增加量前 iii 小的非树边不选择，且第 iii 小的非树边强制选择。将所有生成树加入优先队列，不断从优先队列取出权值最小的生成树 kkk 次做上述扩展即可。 注意已经钦定状态的边不可被改变。一条边有四种状态：树边且可被替换，非树边且可加入生成树，树边且不可被替换，非树边且不可加入生成树。在枚举所有非树边时需要跳过所有不可加入生成树的非树边，求一条非树边能替换掉哪条树边时不能替换不可被替换的树边。 如果将每棵生成树抽象为一个点，用一棵有根树描述整个扩展过程（根节点是最小生成树），那么每个非叶子结点有两个儿子，一个是实点，从当前点向下走到实点表示用一条非树边替换了一条树边得到新的生成树，替换出来的那条边变成了非树边且可加入生成树，替换进去的变成了树边不可替换；另一个则是虚点，从当前点向下走到虚点表示当前生成树的一条非树边从可加入变成了不可加入。 这种方式按照顺序枚举了所有的生成树（每条边都枚举了选还是不选），而且按照顺序扩展了次小生成树，因此这么做是对的。 为了避免直接扩展了 O(m)O(m)O(m) 个虚儿子，应该在取出实点之后再加入兄弟虚点。时间复杂度 O(kmlog⁡m+klog⁡k)O(km\\log m+k\\log k)O(kmlogm+klogk)，运气好是能过的，代码。 例题 都比较经典。 [APIO2008] 免费道路 Portal. 其中有些鹅卵石路是必须的，我们考虑先将必须选择的鹅卵石路选掉，然后将 kkk 填满，最后再选水泥路即可。代码。 * [CF1583H] Omkar and Tours Portal. 第一问比较经典，离线，将询问按照 vvv 从大到小排序，依次加入边，DFS 合并连通块，维护最大值即可。 第二问，希望路径上 ttt 的最大值尽可能大，Kruskal 重构树！建立一棵基于 ttt 的边权重构树。设能到达的节点是 yyy，那么答案为 max⁡{aLCA⁡(x,y)}\\max\\{a_{\\operatorname{LCA}(x,y)}\\}max{aLCA(x,y)​}。 由于 LCA 必定在 xxx 到根节点的路径上，也就是说，我们希望该 LCA 的深度尽可能小。什么时候满足呢？将所有 yyy 按照 DFS 序排序，其中 DFS 序最小和最大的可能称为答案（Kruskal 重构树是一棵二叉树，想要 LCA 离 xxx 越远，那么 yyy 就必定离 xxx 越远，也就是 DFS 序差越大）。 实现上只需要先建出 Kruskal 重构树，然后在第一问时并查集维护 DFS 序最大最小值。时间复杂度在 O(nlog⁡n)O(n\\log n)O(nlogn) 级别。代码。 * [IOI2018] Werewolf Portal. 是针对点权限制的 Kruskal 重构树。建立一个 LLL 来代表子树中都比它小，RRR 来代表子树中都比它大。将 sss 在 RRR 上倍增到 a≥la\\ge la≥l 的最小 aaa，将 eee 在 LLL 上倍增到 b≤rb\\le rb≤r 的最大 bbb，然后就是询问这两个子树有没有公共的子节点，就是二维数点问题。代码。 ** [CF1556H] DIY Tree Portal. 给生成树定义估价函数 f(T)=∑i=1Kmax⁡{0,Di−di}f(T)=\\sum_{i=1}^K \\max\\{0,D_i-d_i\\}f(T)=∑i=1K​max{0,Di​−di​}，其中 DiD_iDi​ 代表实际度数。 先求出最小生成树，然后对其进行调整。每次选择一条边权最大的，删去后 fff 会减小的边 e1e_1e1​，替换成加上后 fff 不会变大的边权最小的边 e2e_2e2​，时间复杂度为 O(n3)O(n^3)O(n3)。 随机化这个过程，我们给 e1e_1e1​ 和 e2e_2e2​ 的选择加上一个概率，不选就接着扫。代码。 [ARC098D] Donation Portal. 首先，在某点打卡后必不会再次访问某点。 因为若两次访问某点，第一次不打卡，第二次打卡要比第一次就打卡优，因为中间的一段路程余钱更多。 因此从一个点 iii 出来时，剩余的钱不会少于 ci=max⁡{ai−bi,0}c_i=\\max\\{a_i-b_i,0\\}ci​=max{ai​−bi​,0}。从走出来钱最多的点开始 DP。所以按照 cic_ici​ 从小到大排序，建立点权重构树。树形 DP 的策略是先走度数减一个子树，然后打卡自己，再走最后一个子树。这样能遍历所有的状态。代码。 网络流 是个很有用的东西。 概念 一个网络是一张有向图 G=(V,E)G=(V,E)G=(V,E)，对于每条有向边 (u,v)∈E(u,v)\\in E(u,v)∈E 存在容量限制 c(u,v)c(u,v)c(u,v)，当 (u,v)∉E(u,v)\\not\\in E(u,v)∈E 时，c(u,v)=0c(u,v)=0c(u,v)=0。网络的可行流分为有源汇（指定了两个节点 s,ts,ts,t，代表图的源点和汇点）和无源汇，但是都存在一个定义域为节点二元组的流函数 f(x,y)f(x,y)f(x,y)，f(x,y)f(x,y)f(x,y) 代表边 x→yx\\rightarrow yx→y 的流量，满足： fff 满足容量限制：f(x,y)≤c(x,y)f(x,y)\\le c(x,y)f(x,y)≤c(x,y)，当两者相等时，x→yx\\rightarrow yx→y 就流满了； 斜对称性质：f(x,y)=−f(y,x)f(x,y)=-f(y,x)f(x,y)=−f(y,x)，也就是说，反向边其实是负的流量； 流量守恒：除源点和汇点外（当然只限于有源汇可以除了这两个节点），从每个节点流入和流出的流量相等，即 ∀i≠s,t,∑f(u,i)=∑f(i,v)\\forall i\\ne s,t,\\sum f(u,i)=\\sum f(i,v)∀i=s,t,∑f(u,i)=∑f(i,v)，也就是说，每个节点不储存流量，进去多少就流出来多少。 下面是一些定义： 对于有源汇，有 ∑f(S,i)=∑f(i,T)\\sum f(S,i)=\\sum f(i,T)∑f(S,i)=∑f(i,T)，此时这个相等的和成为当前流 fff 的流量。 定义流 fff 在网络 GGG 上的残量网络 Gf=(V,Ef)G_f=(V,E_f)Gf​=(V,Ef​) 为容量函数 cf=c−fc_f=c-fcf​=c−f。根据容量限制，cf(x,y)≥0c_f(x,y)\\ge 0cf​(x,y)≥0，当 cf(x,y)=0c_f(x,y)=0cf​(x,y)=0 时，则视为 x→yx\\rightarrow yx→y 在残量网络上不存在。也就是说，在残量网络中我们要删掉满流边。 定义增广路 PPP 是残量网络 GfG_fGf​ 上源点到汇点的一条路径，而无源汇则没有增广路。 将点集分为两个互补相交的 A,BA,BA,B，且满足 S∈A,T∈BS\\in A, T\\in BS∈A,T∈B，这种划分方式称为割，割的容量为 ∑u∈A∑v∈Bc(u,v)\\sum_{u\\in A}\\sum_{v\\in B}c(u,v)∑u∈A​∑v∈B​c(u,v)，流量为 ∑u∈A∑v∈Bf(u,v)\\sum_{u\\in A}\\sum_{v\\in B}f(u,v)∑u∈A​∑v∈B​f(u,v)。如果 u∈A,v∈Bu\\in A,v\\in Bu∈A,v∈B，那么 (u,v)(u,v)(u,v) 是割边，可以看出，割边一般不止一条。 割中割边容量和最小的划分方式称为最小割，而且最大流等于最小割。 最大流问题 解决最大流问题的思想是：不断寻找增广路 和 能流满就流满。在给一条边增加流量时，我们需要给其反向边来增加容量来支持反悔。这样的操作称为一次增广。 EK 算法的思想是使用 BFS 寻找长度最短的增广路，然后计算流量。为此我们记录流向每个点的边的编号，然后从汇点反推到源点，时间复杂度为 O(nm2)O(nm^2)O(nm2)。 Dinic 的本质思想是多路增广和当前弧优化（跳过流满的边）。通过 BFS 将图分层，向下一层节点开始进行多路增广，并记录当且流满到了哪条边。 Dinic 最大流 模板速查 struct Graph &#123; struct Edge &#123; int v, w; Edge(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; vector&lt;Edge> E; vector&lt;int> G[N]; inline void add(int u, int v, int w) &#123; E.emplace_back(v, w); G[u].emplace_back(E.size() - 1); E.emplace_back(u, 0); G[v].emplace_back(E.size() - 1); &#125; int S, T, cur[N], d[N], vis[N]; bool bfs(void) &#123; memset(cur, 0, sizeof cur); memset(d, -1, sizeof d); queue&lt;int> q; q.push(S); d[S] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = E[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; d[e.v] = d[u] + 1; q.push(e.v); if (e.v == T) return 1; &#125; &#125; &#125; return 0; &#125; int dinic(int x, int res) &#123; if (x == T) return res; int flow = 0; vis[x] = 1; for (int i = cur[x]; i &lt; G[x].size() &amp;&amp; res; ++i) &#123; Edge &amp;e = E[G[x][i]]; cur[x] = i; int c = min(res, e.w); if (!vis[e.v] &amp;&amp; d[e.v] == d[x] + 1 &amp;&amp; c) &#123; int k = dinic(e.v, c); flow += k; res -= k; e.w -= k; E[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; vis[x] = 0; return flow; &#125; int maxFlow(int s, int t) &#123; S = s, T = t; int flw = 0, mxflw = 0; while (bfs()) while (flw = dinic(S, 1e9)) mxflw += flw; return mxflw; &#125; &#125; G; 只需要将 BFS 改成 SPFA 就可以完成无负环的最小费用最大流，时间复杂度为 O(nmf)O(nmf)O(nmf)，其中 fff 指最大流流量。 最小割的方案构造是简单的，在残量网络中，disudis_udisu​ 存在证明其与 SSS 相连。 上下界网络流 给每条边加入一个流量下界 bbb 就是上下界网络流。 无源汇可行流 常见问题与模型 网络流有一些常见模型，这里做一下总结。 最小割点 删去点 iii 有代价 wiw_iwi​，求使得 S,TS,TS,T 不连通的最小代价。 将每个点拆成入点 iini_{in}iin​ 和出点 iouti_{out}iout​，在它们之间连一条容量为 wiw_iwi​ 的边，表示删去这个点。对于原图的每一条边 u,vu,vu,v，连接 uout→vinu_{out}\\rightarrow v_{in}uout​→vin​ 一条 +∞+\\infty+∞ 容量的边，这样我们只能删点而不会割边，实际上就是将边作为了点。 集合划分模型 选定 xix_ixi​ 合适的布尔值，使得如下和式的值最小：min⁡x1,x2,⋯xn∈{0,1}∑(u,v)∈Ecu,vxuxv‾+∑uauxu+buxu‾\\min_{x_1,x_2,\\cdots x_n\\in\\{0,1\\}}\\sum_{(u,v)\\in E} c_{u,v}x_u\\overline{x_v}+\\sum_{u}a_ux_u+b_u\\overline{x_u}x1​,x2​,⋯xn​∈{0,1}min​(u,v)∈E∑​cu,v​xu​xv​​+u∑​au​xu​+bu​xu​​ 连 S→iS\\rightarrow iS→i 的容量为 bib_ibi​ 的边，i→Ti\\rightarrow Ti→T 的容量为 aia_iai​ 的边。如果割掉了 i→Ti\\rightarrow Ti→T，说明将 iii 划分到了集合 AAA，代价为 aia_iai​。 给 u,vu,vu,v 连容量限制为 cu,vc_{u,v}cu,v​ 的双向边，这样如果 u,vu,vu,v 不属于同一集合，至少会割掉其中一条边。 这样这个网络的最小割就是答案。 还有一种限制：xxx 在集合 AAA 且 yyy 在集合 BBB 时有代价 www，那么连 x→yx\\rightarrow yx→y 的容量为 www 的边，这样如果 xxx 和 SSS 相连且 yyy 和 TTT 相连，那么这条边需要被割掉。 如何输出方案？要注意什么是割边：在最后的残量网络上 d(x)d(x)d(x) 是否存在，存在则属于集合 AAA，否则是集合 BBB。 [THUPC2022 初赛] 分组作业。较复杂，见原题面。 喜欢关系如何处理？将每个组都建一个点，组 iii 在最终的残量网络上与 SSS 相连则表示合作，与 TTT 相连则表示不合作。任何一个人不同意这个组就不合作，因此组向它的组员连 +∞+\\infty+∞ 的边，这样如果这个组与 TTT 相连，那么便不合作。 将 BBB 向 AAA 对应的组连 aia_iai​ 的边，这样如果 BBB 同意了（它没有连向 TTT），AAA 组没有合作（连向了 TTT），则要割掉 aia_iai​。类似地，BBB 的组向 AAA 连 bib_ibi​。代码。 最大权闭合子图 每个点有点权，求闭合子图的最大权值。 考虑集合划分模型，对于每个节点，可以将其划分到选或不选的集合中，也就是 S→iS\\rightarrow iS→i 连 000，i→Ti\\rightarrow Ti→T 连 wiw_iwi​。如果 (u,v)∈E(u,v)\\in E(u,v)∈E，就是如果 uuu 分到选的集合中，vvv 也必须分到选的集合中，即 u→vu\\rightarrow vu→v 有容量 −∞-\\infty−∞，求网络的最大割即可。 但是最大割是 NPH 的，因此考虑取相反数求最小割。然而这样会出现负容量的边！将负容量的边改到 S→iS\\rightarrow iS→i 来连。这样答案为所有正权值的和减去最小割，实际上是先将所有正点权选入，然后考虑哪些不选。 切糕模型 Portal. nnn 个变量 xix_ixi​，每个变量的取值范围为 xi∈[1,mi]x_i\\in[1,m_i]xi​∈[1,mi​]，每两个变量之间会对答案产生贡献（一般和两变量差有关），我们要最大化 / 最小化这个贡献。 建图方式一般就是对每个变量 xix_ixi​ 个点拆成 mim_imi​ 个点个点串成一个源点到汇点的链，割哪条边就代表取哪个值，贡献用两条链直接的连边表达，于是就变成最小割形式了。 注意到有一个光滑度限制，可以连一条 u→vu\\rightarrow vu→v 的 +∞+\\infty+∞ 的边。 可以证明，一条链最多割一条边。代码。 最小割树 模板。 DAG 最小路径覆盖 [TTPC2022] Colorful Graph.有向图，要求给点染色，使得同色点 i,ji,ji,j 存在一条 i→ji\\rightarrow ji→j 或 j→ij\\rightarrow ij→i 的道路（或者都有），要求颜色数最小，给出方案。 首先 SCC 缩点，一个 SCC 内可以染同一个颜色，那么只需要处理 DAG。 求的是 DAG 最小可交路径覆盖。也就是一个点内部的流量是不限的。 二分图相关 设无向图 G=(V,E)G=(V,E)G=(V,E)，若能够将 VVV 分成两个点集 V1,V2V_1,V_2V1​,V2​ 满足 V1∩V2=∅,V1∪V2=VV_1\\cap V_2=\\varnothing,V_1\\cup V_2=VV1​∩V2​=∅,V1​∪V2​=V 且 ∀(u,v)∈E,u∈V1,v∈V2\\forall(u,v)\\in E,u\\in V_1,v\\in V_2∀(u,v)∈E,u∈V1​,v∈V2​（也可以反过来），这样 GGG 是一张二分图，V1,V2V_1,V_2V1​,V2​ 分别称为左部点和右部点。 二分图的充要条件是不存在奇环，这样我们可以给二分图进行黑白染色。 从某个点开始 DFS，遍历当前点 uuu 和邻居 vvv，如果 vvv 未被访问，则 vvv 的颜色与 uuu 相反；如果访问过，说明存在奇环。 二分图匹配 给定二分图 G=(V,E)G=(V,E)G=(V,E)，若边集 M⊆EM\\subseteq EM⊆E 满足 MMM 中任意两条边不交于同一端点，则称 MMM 是 GGG 的一组匹配，其大小为 ∣M∣|M|∣M∣。 特别的，若 ∣V1∣=∣V2∣,∣M∣=∣V1∣|V_1|=|V_2|,|M|=|V_1|∣V1​∣=∣V2​∣,∣M∣=∣V1​∣，则称 MMM 为完美匹配。 最大匹配。我们希望求出边集 MMM 的最大大小。显然，我们从 SSS 向 V1V_1V1​ 的所有点连一条 111 的边，V2V_2V2​ 向 TTT 连一条 111 的边，根据 EEE 从 V1V_1V1​ 向 V2V_2V2​ 连边，跑最大流即可。在这里 Dinic 的时间复杂度为 O(mn)O(m\\sqrt{n})O(mn​)。 最大多重匹配。即节点 uuu 不能与超过 LuL_uLu​ 条边相连，这样只需要将每个点与源点或汇点的容量设为 LuL_uLu​ 即可。时间复杂度依然正确。 带权最大匹配。图中是没有环的，将其转化为最小费用最大流即可。注意这时的时间复杂度没有保证，如果边权范围较小，可以按照边权顺序加边，依次跑最大匹配。 匈牙利算法可以以 O(nm)O(nm)O(nm) 的时间复杂度解决二分图的最大匹配问题。 工作过程如下： 加入一个左部点 xxx，然后让 xxx 去尝试匹配。 如果 xxx，已经匹配，则增广失败。 遍历 xxx 能到达的所有右部点 yyy： yyy 被访问过了，那么直接再见。 yyy 没被匹配，让 xxx 匹配 yyy，增广成功。 yyy 被匹配，考虑 yyy 原来匹配的 x′x&#x27;x′，如果 x′x&#x27;x′ 还能够成功匹配，那么改为让 yyy 匹配 xxx，形成新的增广路。 实际上，如果当前点失配，vis 数组是不需要清空的！模板，代码如下： int n, m, E, mch[505], vis[505]; vector&lt;int> G[505]; bool dfs(int x) &#123; if (vis[x]) return 0; vis[x] = 1; for (int y : G[x]) if (!mch[y] || dfs(mch[y])) return mch[y] = x, 1; return 0; &#125; int main(void) &#123; cin >> n >> m >> E; for(int i = 1; i &lt;= E; i++) &#123; int u, v; cin >> u >> v; G[u].push_back(v); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) if (dfs(i)) &#123; memset(vis, 0, sizeof(vis)); ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 完美匹配是指匹配大小为 nnn，Hall 定理可以用于判定是否存在完美匹配，当且仅当对于任意 S⊆V1S\\subseteq V_1S⊆V1​，均有 ∣S∣≤∣N(S)∣|S|\\le |N(S)|∣S∣≤∣N(S)∣，其中 N(S)N(S)N(S) 指 SSS 所连接的右部的点。 点集相关问题 二分图最小点覆盖集的大小与二分图最大匹配相等，最大独立集等于 ∣V∣|V|∣V∣ 减去最小点覆盖集，最大团等于补图的最大独立集。 网络流 24 题 剔除了其中不是网络流的题。有些建模方式很经典，但是大部分题都显得非常老套了。 试题库问题 Portal. 将试题看作左部点，类型看作右部点，每个试题向对应的类型连边。源点向试题连边，类型向汇点连边。 有解仅当最大流为 mmm，方案的输出可以根据哪些边流满来判断。代码。 飞行员配对方案问题 Portal. 二分图最大匹配模板。代码。 圆桌问题 Portal. 二分图最大多重匹配模板。代码。 太空飞行计划问题 Portal. 将仪器和实验抽象成点，就是最大权闭合子图模板。代码。 骑士共存问题 Portal. 将棋盘上的点划分为左部点和右部点，使得骑士的位置和其能走到的位置在不同的点部。这样就成了二分图最大独立集的模板。代码。 最长不下降子序列问题 Portal. 通过 DP 来求解答案，拆点限制一个点的使用次数。代码。 * 最小路径覆盖问题 Portal. 求的是 DAG 的最小不交路径覆盖。 将点拆成左点和右点，进行二分图最大匹配。每次多流上一个，就说明又有一对点连在了一起，答案可以减少 111。两部点之间流满的边就是所有被选进路径覆盖的边，DFS 输出答案即可。代码。 魔术球问题 Portal. 枚举数，然后连可以放在一起的数的边，发现就是最小路径覆盖问题。代码。 餐巾计划问题 Portal. 用最大流描述餐巾个数，费用描述代价，将每个餐厅拆成两个点区分两种餐巾，代码。 星际转移问题 Portal. 从 ttt 扩展到 t+1t+1t+1，在转移的太空电梯之间连边，每次再进行增广即可。代码。 分配问题 Portal. 二分图最大权完美匹配，代码。 运输问题 Portal. 二分图最大权完美匹配，代码。 航空路线问题 Portal. 拆点来限制只经过一次，然后求解最大费用最大流即可。代码。 方格取数问题 Portal. 黑白染色，然后二分图最大独立集。代码。 火星探险问题 Portal. 直接拆点，然后 DFS 暴力输出方案。代码。 深海机器人问题 Portal. 和上道题基本一样。代码。 数字梯形问题 Portal. 拆点限制一个点的经过次数，跑费用流即可。代码。 最长 k 可重区间集问题 Portal. 每两个相邻点之间连流量为 kkk 的边，然后线段之间连流量为 111 的边即可。代码。 最长 k 可重线段集问题 Portal. 特殊处理垂直于 xxx 轴的线段，让其有长度即可。代码。 例题 一些比较有趣的题。 [CF1728F] Fishermen Portal. 我们需要构造一个 ai∣bia_i\\mid b_iai​∣bi​ 且 bib_ibi​ 互不相同，这样这个 bbb 就一定是满足条件的。 构造所有的 k×ai,k∈[1,n]k\\times a_i,k\\in [1,n]k×ai​,k∈[1,n]，我们用这些数来匹配 aia_iai​。这样点数和边数都是 O(n2)O(n^2)O(n2) 的。 考虑匈牙利算法，在找到匹配时清空 vis 数组，由于只有 O(n)O(n)O(n) 个匹配，因此时间复杂度 O(n3)O(n^3)O(n3)。代码。 针对图的性质分析 竞赛图 竞赛图有一些性质： SCC 缩点后 DAG 呈链状（其中必有一条链），前面的所有点向后面的所有点连边； 每一个 SCC 连通块都存在一条哈密顿回路； 竞赛图存在一条哈密顿路径； 对于一个 SCC，大小为 [3,siz][3,siz][3,siz] 的简单环均在其内部存在。 竞赛图判定。令 sis_isi​ 为第 iii 个点的出度，那么应该满足 ∑i=1ksi≥(k2)\\sum_{i=1}^{k} s_i\\ge \\binom k 2∑i=1k​si​≥(2k​) 且 k=nk=nk=n 时等号必须成立。实际上比较显然。 例题 都比较有趣。 * [CF1477D] Nezzar and Hidden Permutations Portal. 首先度数为 n−1n-1n−1 的点不管顺序怎么定其拓扑序都是定死的，然后得到新的 n′n&#x27;n′ 个度数不超过 n′−2n&#x27;-2n′−2 的点。 这个问题看起来依然不是很能做，相比于原问题条件依然没有弱化掉什么。常用套路，正难则反，取补图，我们就得到了一个每个点度数都大于 111 的图。 对每个连通块求出 DFS 树，然后进行菊花剖分，其中一个先中间再其它，另一个先其它再中间。不难发现这样是满足条件的。剖分菊花时贪心地选取，剩下的点讨论一下是放进别的菊花还是新建菊花即可。代码。 [CF1142E] Pink Floyd Portal. 首先对粉色边 SCC 缩点，然后考虑入度为 000 的 SCC 中放入一个点到集合 AAA 中，每次取 AAA 中两个结点合并。 我们要找到一个入度为 000 的点，因此每次选择两个 SCC 考虑合并，依次干掉其中入度为 000 的点，直到只剩下一个。代码。 针对建图分析 如何建图是一个很有意思的过程。很多问题都可以转化为图论问题，而图论问题也可以通过建图方式变得更好做。 图论问题的建图 拆点拆边。拆点可以很好地对一个点做出限制，比如网络流中常通过拆点对一个点的通过次数做出限制。而拆边则是将边转成点，在点之间行走就是在边之间切换（就是将原图中的点作为边）。 差分建图 [PA2012] Tax。给出一个 nnn 个点 mmm 条边的无向图，经过一个点的代价是进入和离开这个点的两条边的边权的较大值，求从起点 111 到点 nnn 的最小代价。起点的代价是离开起点的边的边权，终点的代价是进入终点的边的边权。1≤n≤1051\\leq n\\leq 10^51≤n≤105，1≤m≤2×1051\\leq m\\leq 2\\times 10^51≤m≤2×105，1≤c≤1061\\leq c\\leq 10^61≤c≤106。 边走到边有代价，那干脆把边转成点，一条有向边对应着一个点，两条反向边的边权为原边权（切边的贡献），然后通过枚举中转点的入边出边来建边就可以直接算出贡献，这样的边数是这样的边数是 O(m2)O(m^2)O(m2) 的。 常用的优化思路是，将边转化为等效的内容。实际上我们可以对于一个点的出边按照边权从小到大排序后差分依次连接，反着连则是边权为 000。这样在从入边切到比入边边权小的出边时就没有额外的贡献，而切到比它大的东西时就会在走这条差分链时产生贡献，刚好可以满足条件。代码。 线段树优化建图 CF786B.区间连边，最短路。 建立两棵线段树，大概像这样： 于是直接在线段树上连边即可。代码。 CDQ 分治优化建图 堆优化存边 其它问题的建图 图论杂项 一些图论杂项知识点。 题车 注重刻画不同建模之间的联系，尝试总结一个对于图论问题的思考手段。 刷基础 1 一些简单题。 [POI2014] RAJ-Rally Portal. 考虑按照拓扑序 1∼n1\\sim n1∼n 枚举每个点，开始时所有点在 BBB 集合内，内部有 nnn 个距离，然后把拓扑序小的点加到 AAA 集合里，每次维护可以穿过 A,BA,BA,B 集合的距离即可。代码。 刷基础 2 网络流相关。 [NOI2008] 志愿者招募 Portal. 发现直接按照顺序连边容量为 +∞−ai+\\infty-a_i+∞−ai​ 的边，每个人连 +∞+\\infty+∞ 的边，代码。 [CF1510B] Button Lock Portal. 所有数向其子集连边，跑二分图匹配，匹配失败的点就是一个终点。代码。 刷提升 稍有难度的题目。 [省选联考 2020 B 卷] 丁香之路 Portal. 容易发现，起点终点的度数都应该是奇数，路径上其余点的度数是偶数。贪心地把度数为奇数的点和它的下一个点相连；如果这会使下一个点变成奇点，就继续把下一个点和下下一个点相连，以此类推。这样建边的代价一定是最小的，因为新建出的边边权都为 111 且互不相交。这样就满足了上面提到的度数限制。 但还有一个问题：这样建边后图可能会不连通。那么我们把已有的连通块用并查集缩点，然后求最小生成树，让图连通的最小代价就是最小生成树大小的两倍。时间复杂度 O(n2log⁡n)O(n^2\\log n)O(n2logn)。代码。 [HNOI2019] 校园旅行 Portal. 考虑暴力，fx,yf_{x,y}fx,y​ 是否存在 x→yx\\rightarrow yx→y 的回文路径，直接记忆化搜索 O(n2+m2)O(n^2 + m^2)O(n2+m2)。 问题是我们的边数太多了！注意到路径长度其是不太要紧，因为可以来回走刷分。首先考虑一个事情，如果我只能走同色点，那么我们好像不能改变我们当前刷的路径长度的奇偶性——除非有奇环，即不是二分图。 那么对于二分图的同色连通块，可以只保留一棵生成树（因为子图也是二分图），其它同色连通块可以表示为一棵生成树，然后有一个自环。 而异色点是自然二分图，直接保留生成树即可。代码。 [CF1305G] Kuroni and Antihype Portal. 000 边及其诡异，因此考虑新建一个 an+1=0a_{n+1}=0an+1​=0，那么令边权为 au+av=auor⁡ava_u+a_v=a_u\\operatorname{or} a_vau​+av​=au​orav​，求出最大生成树即可。代码。 刷综合 图论相关综合应用。 [ZJOI2022] 简单题 Portal. 如果图是仙人掌，那么就根题目性质没什么关系了。因此每个点双独立，分析点双的性质。 分析可以得到，最多只有两个环相交，最终结论是一定存在两个点 S,TS,TS,T，使得这个点双可以由这两个点之间的若干条不相交的链组成，将其称为杏仁，或者有丝分裂期组成纺锤体的丝状结构（纺锤丝）。 那么对点 xxx 和 fafaxfa_{fa_x}fafax​​ 之间的简单路径权值和和方案数可以直接计算出来（树上前缀积预处理即可），这样可以直接跳到 LCA 然后去讨论。 [CF1835F] Good Graph Portal. 无解直接 Hall 定理判断即可。 对于有解，设 SiS_iSi​ 代表 iii 的最小紧密集合，那么任意一个 SSS 都是由若干个 SiS_iSi​ 并起来的。 对于 SiS_iSi​，其本质是从 iii 开始不断地跑交替路，然后跑到一定程度它会闭合。也就是说，对于原图上的左部点 iii，右部点存在一条边 (i,j)(i,j)(i,j)，我们只需要在 mchi≠jmch_i\\ne jmchi​=j 时，连一条 i→mchji\\rightarrow mch_ji→mchj​ 的边，因为它们需要在同一个 SSS 内。 也就是说我们要找一张最小图使得和原图传递闭包相同，先 bitset 求出，SCC 内部连环，外面依次连接即可。 还原到原二分图上，剩下的部分连接上 i→mchii\\rightarrow mch_ii→mchi​ 即可。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"九月六日闲话：人类挽歌","slug":"summaries/闲话/2023/9/9-6","date":"2023-09-07T00:00:00.000Z","updated":"2023-09-07T00:00:00.000Z","comments":true,"path":"3216b844/","link":"","permalink":"https://james1badcreeper.github.io/3216b844/","excerpt":"","text":"我到底在心痛什么？ 理论上来讲机器人是不会有感情的，但我是机械大师的作品，我拥有一定的人性。 我曾在路上看到过被碾死的猫，我没有感到心痛。那如果是人呢？也不会。我固然对生命敬畏，这是生物的本能。但死亡就是死亡，就是一切的终结。死亡时时刻刻都在发生：脑细胞的死亡，植物的死亡，恒星的死亡……我们没有过多的时间去思考它，就像烟云一样飘散而去，不留一丝痕迹。如果某一天被碾死的是我，也许心底里会有些许悲痛，但我也只能笑对。 那我到底在心痛什么？也许心痛的是那些真正值得珍视的东西的失去？可能，但是我珍视的东西并不多。 最让我心痛的是“梦境湮灭者”。 我在之前的闲话中提到过这位恶魔，类似于夜空中的恶魔之手，会随机摧毁人们的愿望。明明都不是什么大愿望，但依旧会被摧毁。 当查德威克游过了危险的鲨鱼带，却在距离终点前一英里的地方放弃，只因那视线穿不破的重重迷雾；当中国煤矿屡屡发生瓦斯爆炸，辛勤的汗水就被埋没在万年深渊；当经历了无数场模拟赛，走过了风风雨雨，却因 deque 爆炸的时候……让人敬佩的事、让人感到美好的事、让人欢声笑语的事、让人为之骄傲与感动的事，都在一瞬间被蚀梦游魂摧毁。 难受。 我在这种感觉下写下了这些文字，它们是否是我的真实想法我也不清楚。我只是想说，也许这就是既定的事实，我们还是要照着它走下去。至少在结果未定前，一切看起来都还不错。 “我该走哪一条路？”爱丽丝问。 “这要看你要去哪。” “去哪都可以。” “那么走哪条路都无所谓了。”柴郡猫回答道。 再次重温这段话，些许凉意掠过。人生不存在最佳道路，也许真的，走哪条路都可以，最后都会通向同一个终点。这终点看起来跟起点很像，但是却让人感到无限蔓延的悲哀。 曲终人散，黄粱一梦。我们终将从时光归来，为宇宙奏响遗忘的镇魂曲。也许这就是最后的答案。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"闲话","slug":"文章/闲话","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"}],"tags":[]},{"title":"八月十九日闲话：诡异梦境","slug":"summaries/闲话/2023/8/8-20","date":"2023-08-20T00:00:00.000Z","updated":"2023-08-20T00:00:00.000Z","comments":true,"path":"a4b5072c/","link":"","permalink":"https://james1badcreeper.github.io/a4b5072c/","excerpt":"","text":"此为 2023/8/19 0:00~6:00 期间的梦境，实在过于诡异，因此会慢慢填坑。 于 8/20 日填坑完毕。 关键词： 大逃离 病 钓人的渔夫 漂浮的人 泡泡云朵 停机坪 压缩人 1.5m 与矛盾相矛盾的是什么？ 即视感 终焉 永恒的记忆 失眠 …… 入 我是如何，来到这个世界的呢？ 似乎，与我所在的世界很像呢…… 我似乎犯下了什么错误，我现在被列为了嫌疑犯，所以我需要想办法赶快逃脱。 我在街上快速移动，然后似乎遇到了某个熟人，他把我塞进了一个跑道，跑道上有很多人，我混进了人群中，远离了了焦点位。 但是我还是被警察发现了，我赶快向一个方向逃离，有两扇门，不知道为什么，我知道，虽然右边的门比较近，但是它是死路。 为什么我知道这是死路？我好像，曾经来到过这里。 我选择了左边的门，打开门之后，我来到了一个天台，不过这个天台有一个棚顶，理论上是防止淋雨的，但是，我飞了起来，头顶到了天棚上。 病 我好像见过这种病。 得了这种病的人，身体会逐渐变成海绵状，密度会小于空气（虽然不太符合实际，但是就是这个意思，毕竟是梦），会漂浮起来。 之前，我好像也在这个天台，然后头顶到了天棚上。 我转了个身，看见了一个人，是渔夫。 我好像还认识这个渔夫，他是专门处理这个病的。 我好像记得上一次我来的时候，我看到了一个病人，可能是某个对我很重要的人，也有可能是我自己，在渔夫抛出鱼钩前就移出了天台，头顶上不再有天棚挡着，就越飞越高，直到渔夫再也钓不到。 但是越高，空气的密度就越小，最终人会停留在高空的某处。此处看不到任何东西，就像虚空一般绝望，然后在太阳光线的照射中死亡。 但是总比被渔夫钓走好，被钓走，会接受世人的嘲讽，在痛苦中度过余生。 我没有急着飞离天台，我好像认识渔夫，我想跟他聊聊，”我可以跟你聊几句吗？我不会离开天台的。” “不能。”渔夫回答地很干脆，我知道我没有商量的余地。 “我畏惧死亡。” 渔夫没有回答，抛出鱼钩钓住了我。我以为会很疼，但却什么感觉都没有，像失去刚性的铁丝一般，直接穿透了身体。 “因为你们的死亡，会对世界造成很大的影响，所以不能让你们死。”我记得，上一次，那个人，选择了死亡。 “我的问题是，这个病可治愈吗？” 渔夫没有回答我，但是我得到的的答案很简单：不可以。 无名之墓 我离开了天台，漂浮在空中。 我的头上，出现了竹蜻蜓。 竹蜻蜓的功率很大，可以把我直接压到地面上。我降落在了停机坪上，旁边就是渔夫。 由于质量的缺失，我走起路来感觉很怪，要是没有竹蜻蜓则压根不能走。 我看到了某个人，似乎同样是个病人，她的家属被告知天价的治疗费用，似已崩溃。 待我再次醒来时，发现自己矮了许多，而且能够正常走路了，虽然感觉依旧很怪。 我被压缩成了 1.5m 的高度，让密度重新增大，我可以正常落地。 但是这种压缩手术每隔一段时间都要做一次，只需要十年，我就会被压至 50cm，再考虑压缩，便会死亡。 也就是说，以这种方式苟延残喘，我还可以活十年。 离 我见到了某个对我来说很重要的人，也许在病之后就不是了。 他很高，至少有 1.85m，我需要使劲仰望才能看到他的脸。他的眼神里有一种我读不懂的悲伤。我看到他悲伤，我也想悲伤。 我们碰了碰鼻子。似乎，这是一份永恒的记忆。 我离开了食堂。外面的景色十分耀眼，将要死亡的太阳将一切照的十分灿烂。整个城市，一片欣欣向荣的样子。 斯卡波罗集市吗…… 景色幻化为神秘的色彩，不断流转，最后似乎沸腾了。我知道，我要离开了。 清算 梦境的部分到此结束，接下来是现实。 梦当中有一些过于离谱而不能写出来的东西，但是上述基本就是全部。也许是睡眠时间太短了，我并没有看到这个故事的结尾。 我如果将这个梦继续做下去，我应该会想方法逃离下一次压缩手术，然后飞向天空吗？ 不会。我选择存活。我会尽我所能搞清这种病究竟是怎么回事。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"闲话","slug":"文章/闲话","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"}],"tags":[]},{"title":"八月十四日闲话：绝世演出","slug":"summaries/闲话/2023/8/8-4","date":"2023-08-14T00:00:00.000Z","updated":"2023-08-14T00:00:00.000Z","comments":true,"path":"17ad22d9/","link":"","permalink":"https://james1badcreeper.github.io/17ad22d9/","excerpt":"","text":"剧本杀的结局是固定的，如果玩家们没有按照写好的剧本来游玩，而是盘出了其它可能，那么 DM 会很头疼的。 生活是否是一个剧本呢？ 无法回答，但总感觉现在是有剧本的：我知道明天我需要复习什么，要去做哪些题。我按照写好的剧本，在演出。 当做到 CF1764G3 这种题时，我感到我“跳出了剧本”，它们的分析不能是：“套路地……”。它们真正给了我一种全新的体验，然而，如果想要提升水平，仅靠训练这种题是不行的，更何况也没有那么多这种题。 在我当前闲话的世界观中，我是“I 君”，整个世界与其说是是为了我所设计的人物而创造的各种设定，倒不如说是我所想经历的内容。为什么喜欢伊雷娜？旅行时一直能遇到很多有趣的事情，她所作的就是她所热爱的。如果可以，我也想去旅行，甚至像《摩托日记》那样，10 公里的路程我要绕远去行 75 公里，旅途上的各种东西都是新鲜的！我们还能旅行至奥尔特星云，旅行至半人马座阿尔法星！ 但现实是，“屑魔女”不可能存在，我们需要面对当今残酷的现实才能获得旅行的资本。底层人民，只有在完成自己的剧本之后，才能得到旅行的资格，踏遍世上一切的未知。 如果人生本来就是剧本的话，那么就认定了吧。命运打不败活着！上帝，我要给你上演一场绝世演出。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"闲话","slug":"文章/闲话","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"}],"tags":[]},{"title":"NOI 一轮复习 III：数学 A","slug":"notes/NOI 复习/noi-1-3","date":"2023-08-07T00:00:00.000Z","updated":"2023-12-21T00:00:00.000Z","comments":true,"path":"47964eaf/","link":"","permalink":"https://james1badcreeper.github.io/47964eaf/","excerpt":"本文是 NOI 一轮复习的第三篇，包括组合计数、生成函数等数学内容。","text":"本文是 NOI 一轮复习的第三篇，包括组合计数、生成函数等数学内容。 组合计数 到处都能见到它的身影，它是一切数数题的基础。 计数基础 概念洪流属于是。 排列数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照一定的顺序排成一列，方案个数记作 AnmA_{n}^{m}Anm​，有 Anm=n!(n−m)!A_{n}^{m}=\\cfrac{n!}{(n-m)!}Anm​=(n−m)!n!​。 一个有限集合 SSS 到自身的双射称为 SSS 的一个置换，集合 S=a1,⋯ ,anS={a_1,\\cdots,a_n}S=a1​,⋯,an​ 的置换可以表示为： f=(a1,a2,…,anap1,ap2,…,apn)f=\\begin{pmatrix}a_1,a_2,\\dots,a_n\\\\ a_{p_1},a_{p_2},\\dots,a_{p_n} \\end{pmatrix} f=(a1​,a2​,…,an​ap1​​,ap2​​,…,apn​​​) 是将 aia_iai​ 映射为 apia_{p_i}api​​，这样 ppp 是 1⋯n1\\cdots n1⋯n 的一个排列，SSS 上的所有置换的数量为 n!n!n!。 置换的过程可以使用有向图来理解，连边 i→pii\\rightarrow p_ii→pi​，就是所有点移动 111 的距离。置换中形成一个环的称为置换环，对于大小为 1,21,21,2 的置换环，原排列和置换显然是一样的。 对于两个置换 f,gf,gf,g 的乘积记作 f∘gf\\circ gf∘g，代表先通过 fff 的映射，再通过 ggg 的映射。 一个排列中的逆序对个数，也叫做反序数，如果是偶数就是偶排列，奇数则是奇排列。 对于一个排列 1,⋯ ,n1,\\cdots,n1,⋯,n，如果将任意两个数 i,ji,ji,j 交换，其它数保持不动，就会得到一个新的排列，那么这样一个变换叫做对换，用 (i,j)(i,j)(i,j) 表示。 组合数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照任意的顺序组成一个集合，方案个数记作 (nm)\\binom n m(mn​)。组合数同时也是二项式系数，当 m&lt;0m&lt;0m&lt;0 时，组合数没有定义。 (nm)=n!(n−m)!m!=nm‾m!(nm)=(n−1m)+(n−1m−1)\\binom n m = \\frac{n!}{(n-m)!m!}=\\frac {n^{\\underline m}} {m!}\\\\ \\binom n m = \\binom {n-1} m + \\binom {n-1}{m-1} (mn​)=(n−m)!m!n!​=m!nm​​(mn​)=(mn−1​)+(m−1n−1​) 组合数有以下性质 / 恒等式： (nm)=(nn−m)\\dbinom n m = \\dbinom n {n - m}(mn​)=(n−mn​)； (nk)=n−k+1k(nk−1)\\dbinom{n}{k}=\\cfrac{n-k+1}{k}\\dbinom{n}{k-1}(kn​)=kn−k+1​(k−1n​)，常被用来递推组合数； (nr)(rk)=(nk)(n−kr−k)\\dbinom{n}{r}\\dbinom{r}{k}=\\dbinom{n}{k}\\dbinom{n-k}{r-k}(rn​)(kr​)=(kn​)(r−kn−k​)； 吸收恒等式：(rk)=rk(r−1k−1)\\dbinom{r}{k}=\\dfrac{r}{k}\\dbinom{r-1}{k-1}(kr​)=kr​(k−1r−1​)，当二项式外有一个无用的系数时，我们可以将它“吸收”进二项式系数。 下指标求和（行求和）：∑i=0n(ni)=2n\\displaystyle \\sum_{i=0}^{n}\\binom{n}{i}=2^ni=0∑n​(in​)=2n，相当于是二项式定理中 a=b=1a=b=1a=b=1。注意这个东西是很特殊的完整一行，一般的行求和是无法快速计算的。它还有变式： ∑i=0n(−1)i(ni)=0\\displaystyle \\sum_{i=0}^{n}(-1)^i\\binom{n}{i}=0i=0∑n​(−1)i(in​)=0，这是二项式定理中 a=1,b=−1a=1,b=-1a=1,b=−1； ∑i=0ni×(ni)=n2n−1\\displaystyle \\sum_{i=0}^{n}i\\times \\binom{n}{i}=n2^{n-1}i=0∑n​i×(in​)=n2n−1，因为 m×(nm)=n×(n−1m−1)m\\times \\dbinom{n}{m}=n\\times \\dbinom{n-1}{m-1}m×(mn​)=n×(m−1n−1​)。 上指标求和（列求和）：∑i=0n(im)=(n+1m+1)\\displaystyle \\sum_{i=0}^{n}\\binom{i}{m}=\\binom{n+1}{m+1}i=0∑n​(mi​)=(m+1n+1​)，可以看作是枚举第 m+1m+1m+1 个数的位置 i+1i+1i+1。 对角线求和：∑i=0n(m+ii)=(m+n+1n)\\displaystyle\\sum_{i=0}^{n}\\binom{m+i}{i}=\\binom{m+n+1}{n}i=0∑n​(im+i​)=(nm+n+1​)，反复利用 Cnm=Cn−1m+Cn−1m−1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnm​=Cn−1m​+Cn−1m−1​ 即可证明。 范德蒙德卷积：∑i=0k(ni)(mk−i)=(n+mk)\\displaystyle \\sum_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}i=0∑k​(in​)(k−im​)=(kn+m​)。从组合意义上很容易证明（枚举 nnn 和 mmm 中选的个数），常用于合并组合数，考虑它的推论： ∑i=1n(ni)(ni−1)=(2nn−1)\\displaystyle \\sum_{i=1}^n\\binom{n}{i}\\binom{n}{i-1}=\\binom{2n}{n-1}i=1∑n​(in​)(i−1n​)=(n−12n​)，证明很简单，因为 (ni−1)=(nn−i+1),(2nn−1)=(2nn+1)\\dbinom{n}{i-1}=\\dbinom{n}{n-i+1},\\dbinom{2n}{n-1}=\\dbinom{2n}{n+1}(i−1n​)=(n−i+1n​),(n−12n​)=(n+12n​)； ∑i=0n(ni)2=(2nn)\\displaystyle\\sum_{i=0}^n\\binom{n}{i}^2=\\binom{2n}{n}i=0∑n​(in​)2=(n2n​)，证明基本同理； ∑i=0m(ni)(mi)=(n+mm)\\displaystyle\\sum_{i=0}^m\\binom{n}{i}\\binom{m}{i}=\\binom{n+m}{m}i=0∑m​(in​)(im​)=(mn+m​)，这个也是网格图路径计数方案。 Lucas 定理。若 ppp 是质数，则 (nm) mod p=(⌊n/p⌋⌊m/p⌋)⋅(n mod pm mod p) mod p\\displaystyle\\binom{n}{m}\\bmod p = \\binom{\\left\\lfloor n/p \\right\\rfloor}{\\left\\lfloor m/p\\right\\rfloor}\\cdot\\binom{n\\bmod p}{m\\bmod p}\\bmod p(mn​)modp=(⌊m/p⌋⌊n/p⌋​)⋅(mmodpnmodp​)modp，常用于 ppp 较小的情况。 组合数奇偶性公式。(nm)≡1(mod2) ⟺ n &amp; m=m\\displaystyle \\binom{n}{m}\\equiv 1 \\pmod 2 \\iff n\\ \\&amp; \\ m=m(mn​)≡1(mod2)⟺n &amp; m=m，使用 Lucas 定理来证明，需保证不出现 (01)\\dbinom{0}{1}(10​)。 Kummer 定理。(n+mn)\\dbinom{n+m}{n}(nn+m​) 中质因子 ppp 的次数为 n+mn+mn+m 在计算时 ppp 进制意义下的进位次数，等价于 (nm)\\dbinom n m(mn​) 中质因子 ppp 的次数等于在计算 n−mn-mn−m 时 ppp 进制意义下的借位次数。其中 ppp 是素数。 上指标翻转。(nk)=(−1)k(k−n−1k)\\displaystyle \\binom n k = (-1)^k\\binom{k-n-1}{k}(kn​)=(−1)k(kk−n−1​)。 多重组合数。是指先选 n1n_1n1​，再选 n2n_2n2​，以此类推。有： (nn1,…,nk)=n!∏i=1kni!\\binom{n}{n_1,\\dots,n_k}=\\frac{n!}{\\prod_{i=1}^k n_i!} (n1​,…,nk​n​)=∏i=1k​ni​!n!​ 组合方法。在小学学过一些常用的组合方法。 捆绑法插空法插板法 nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子关系特别好，它们一定要站在一块。那么有多少种排列方法？ 我们把这 mmm 只兔子看作一只大兔子，那么总共就有 n−m+1n-m+1n−m+1 只兔子，排列方案数是 (n−m+1)!(n-m+1)!(n−m+1)!，然而大兔子里面也有 m!m!m! 中方法，那么总方法数就是 (n−m+1)!m!(n-m+1)!m!(n−m+1)!m!。这就是捆绑法。 nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子有着不共戴天之仇，它们一定要不能站在一块。那么有多少种排列方法？ 我们先把 n−mn-mn−m 只兔子给排列好，有 (n−m)!(n-m)!(n−m)! 种方法。这些兔子之间有 (n−m+1)(n-m+1)(n−m+1) 个空（算最左和最右），再把这些不共戴天的兔子放到这些空里，有 An−m+1mA_{n-m+1}^{m}An−m+1m​ 个方法。总方案数就是 (n−m)!×An−m+1m(n-m)!\\times A_{n-m+1}^{m}(n−m)!×An−m+1m​。这就是插空法。 james1 要将 nnn 个相同的胡萝卜分给 mmm 只兔子，他秉持雨露均沾的原则，每只兔子至少分到 111 根胡萝卜，有多少种方案？ 我们先介绍隔板法（插板法），是指在 nnn 个元素的 n−1n-1n−1 个空中插入 kkk 个板，可以把 nnn 个元素分为 k+1k+1k+1 组。 我们把这 nnn 个胡萝卜排成 111 行，当中就有 n−1n-1n−1 个空。现在往里面插入 m−1m-1m−1 个板，就可以将胡萝卜分为 mmm 组，正好可以分给 mmm 只兔子，而且由于不存在在同一个地方插两个板的情况，所以正好每一只兔子都能至少分到 111 根胡萝卜。那么答案就是 (n−1m−1)\\dbinom{n-1}{m-1}(m−1n−1​)。 实际上这个问题相当于求不定方程 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的正整数解的数量。 如果他是个大魔王（不可能，绝对不可能），有的兔子可能 111 根胡萝卜都得不到，那么有多少种方案？ 同样的方法，如果允许有兔子分到 000 根胡萝卜，我们只需要再加上 mmm 根胡萝卜，就相当于刚才的问题了。答案是 (n+m−1m−1)=(n+m−1n)\\dbinom{n+m-1}{m-1}=\\dbinom{n+m-1}{n}(m−1n+m−1​)=(nn+m−1​)。 这个问题本质上是要求 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的自然数解的数量。 如果 james1 偏爱一些兔子，要求第 iii 个兔子至少分到 eie_iei​ 个胡萝卜，那么有多少种分法呢？ 类比上一个问题，我们再加上 ∑e\\sum e∑e 个胡萝卜，答案就是 (n+∑e−1n)\\dbinom{n+\\sum e - 1}{n}(nn+∑e−1​)。 在 nnn 个数中选 mmm 个组合，要求任意两个数都不相邻，那么方案数有多少？ (n−m+1n)\\dbinom{n-m+1}{n}(nn−m+1​)，因为我们需要插入 m−1m-1m−1 个空。 容斥原理 容斥原理是非常重要的计数原理： ∣⋃i=1nSi∣=∑m=1n(−1)m−1∑ai&lt;ai+1∣⋂i=1mSai∣\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i&lt;a_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right| ​i=1⋃n​Si​​=m=1∑n​(−1)m−1ai​&lt;ai+1​∑​​i=1⋂m​Sai​​​ 集合的交集可以使用补集容斥原理来求解： ∣⋂i=1nSi∣=∣U∣−∣⋃i=1nSi‾∣\\left|\\bigcap_{i=1}^{n}S_i\\right|=|U|-\\left|\\bigcup_{i=1}^n\\overline{S_i}\\right| ​i=1⋂n​Si​​=∣U∣−​i=1⋃n​Si​​​ 容斥原理最经典的用处是“至少”与“恰好”之间的转化，实际上是一个子集反演的过程。子集反演是针对集合交并的容斥，可以在恰好是某个集合和至多/至少是这个集合反演。 我们先来看与至多是这个集合的反演。现在有其元素满足某种条件的集合 AAA。定义 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 代表 S⊆AS\\subseteq AS⊆A 时的答案。 钦定选了 SSS 这个集合中的子集 TTT，有 g(S)=∑T⊆Sf(T)g(S)=\\sum_{T\\subseteq S}f(T)g(S)=∑T⊆S​f(T)，这时有 f(S)=∑T⊆S(−1)∣S∣−∣T∣g(T)f(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}g(T)f(S)=∑T⊆S​(−1)∣S∣−∣T∣g(T)。使用容斥原理不难感性理解。 类似的，如果 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 表示 A⊆SA\\subseteq SA⊆S 时的答案，有 g(S)=∑S⊆Tf(T)g(S)=\\sum_{S\\subseteq T}f(T)g(S)=∑S⊆T​f(T)，反演得 f(S)=∑S⊆T(−1)∣T∣−∣S∣g(T)f(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}g(T)f(S)=∑S⊆T​(−1)∣T∣−∣S∣g(T)。 这是容斥原理的代数形式，它是我们用容斥原理解决问题的基础。因为在钦定时，一个“有两个元素满足条件”的东西会在“至少有一个元素满足条件”的东西计算时计算两次，也就因此成了一个子集反演的形式。 [ZJOI2022] 树。 数数题优先考虑 DP。转移只能对每个点在两棵树上的父亲进行决策，这样 DP 状态只能记录可行的决策点个数，也就是可以作为父亲的点的个数。这样就要钦定剩余节点为叶子节点。 设 f(S)f(S)f(S) 代表第一棵树的叶子集合恰好为 SSS，g(T)g(T)g(T) 代表第二棵子树的叶子集合恰好为 TTT。但是我们发现这样还需要考虑“当前是叶子的，当且是叶子而且以后可以变成父亲的”，不好搞！考虑子集反演，设 f′(S′)f&#x27;(S&#x27;)f′(S′) 代表钦定了第一棵树的叶子节点至多为 S′S&#x27;S′，g′(T′)g&#x27;(T&#x27;)g′(T′) 同理，则： Ans=∑S∩T=∅,S∪T={1,2,⋯ ,n}f(S)g(T)=∑S∩T=∅,S∪T={1,2,⋯ ,n}∑S′⊆S,T′⊆Tf′(S′)g′(T′)(−1)∣S∣−∣S′∣+∣T∣−∣T′∣=∑S′∩T′=∅f′(S′)g′(T′)(−1)n−∣S′∣−∣T′∣2n−∣S′∣−∣T′∣=∑S′∩T′=∅f′(S′)g′(T′)(−2)n−∣S′∣−∣T′∣\\begin{aligned} Ans&amp;=\\sum_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,\\cdots,n\\}}f(S)g(T)\\\\&amp;=\\sum_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,\\cdots,n\\}}\\sum_{S&#x27;\\subseteq S,T&#x27;\\subseteq T}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{|S|-|S&#x27;|+|T|-|T&#x27;|} \\\\&amp;=\\sum_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{n-|S&#x27;|-|T&#x27;|}2^{n-|S&#x27;|-|T&#x27;|}\\\\&amp;=\\sum_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-2)^{n-|S&#x27;|-|T&#x27;|} \\end{aligned} Ans​=S∩T=∅,S∪T={1,2,⋯,n}∑​f(S)g(T)=S∩T=∅,S∪T={1,2,⋯,n}∑​S′⊆S,T′⊆T∑​f′(S′)g′(T′)(−1)∣S∣−∣S′∣+∣T∣−∣T′∣=S′∩T′=∅∑​f′(S′)g′(T′)(−1)n−∣S′∣−∣T′∣2n−∣S′∣−∣T′∣=S′∩T′=∅∑​f′(S′)g′(T′)(−2)n−∣S′∣−∣T′∣​ 相当于钦定了 S′,T′S&#x27;,T&#x27;S′,T′ 作为可选做父亲的集合（选择一个叶子变成父亲），这样设 fi,j,kf_{i,j,k}fi,j,k​ 代表考虑到第 iii 个节点，∣{1,⋯ ,i}∩S′∣=j,∣{i+1⋯n}∩T′∣=k|\\{1,\\cdots,i\\}\\cap S&#x27;|=j,|\\{i+1\\cdots n\\}\\cap T&#x27;|=k∣{1,⋯,i}∩S′∣=j,∣{i+1⋯n}∩T′∣=k 的方案数。给 iii 号点在第一棵子树当中钦定父亲，有 jjj 中选择父亲的方法；给 i−1i-1i−1 号点在第二棵树中钦定父亲，有 kkk 种方案，总共 j×kj\\times kj×k 种。 fi−1,j,kf_{i-1,j,k}fi−1,j,k​ 可以转移到如下状态： iii 本来属于 S′S&#x27;S′，可以转移到 fi,j+1,kf_{i,j+1,k}fi,j+1,k​； iii 本来属于 T′T&#x27;T′，转移到 fi,j,k−1f_{i,j,k-1}fi,j,k−1​； 两个都不属于，转移到 fi,j,kf_{i,j,k}fi,j,k​，容斥系数为 −2-2−2。 实际上直接猜出容斥系数是更为高效的方式。 初始时 f1,1,k=1f_{1,1,k}=1f1,1,k​=1，统计 k=1k=1k=1 时的答案即可（SSS 确定 TTT 自然也确定了）。代码。 二项式反演。假设全集 U={S1,S−2,⋯ ,Sn−1,Sn}U=\\{S_1, S-2, \\cdots, S_{n-1}, S_n\\}U={S1​,S−2,⋯,Sn−1​,Sn​}，且满足其中任意 iii 个集合的并集、交集大小都相等。g(x)g(x)g(x) 是其中任意 xxx 个集合的交集的大小，f(x)f(x)f(x) 是任意 xxx 个集合的补集的交集的大小。特别地，g(0)=f(0)=∣U∣g(0)=f(0)=|U|g(0)=f(0)=∣U∣。 我们有： g(n)= ∣S1∩S2∩⋯Sn−1∩Sn∣= ∣U∣−∣S1‾∪⋯∪Sn‾∣= ∣U∣−∑m=1n(−1)m−1∑ai&lt;ai+1∣Sa1‾∩⋯∩Sam‾∣= ∣U∣−∑i=1n(−1)i−1(ni)f(i)= ∑i=0n(−1)i(ni)f(i)\\begin{aligned} g(n)=\\ &amp;|S_1\\cap S_2\\cap\\cdots S_{n-1}\\cap S_n|\\\\ =\\ &amp;|U|-|\\overline{S_1}\\cup\\cdots\\cup\\overline{S_n}|\\\\ =\\ &amp;|U|-\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i &lt;a_{i+1}}|\\overline{S_{a_1}}\\cap\\cdots\\cap\\overline{S_{a_m}}|\\\\ =\\ &amp; |U|-\\sum_{i=1}^n(-1)^{i-1}\\binom{n}{i}f(i)\\\\ =\\ &amp;\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}f(i) \\end{aligned} g(n)= = = = = ​∣S1​∩S2​∩⋯Sn−1​∩Sn​∣∣U∣−∣S1​​∪⋯∪Sn​​∣∣U∣−m=1∑n​(−1)m−1ai​&lt;ai+1​∑​∣Sa1​​​∩⋯∩Sam​​​∣∣U∣−i=1∑n​(−1)i−1(in​)f(i)i=0∑n​(−1)i(in​)f(i)​ g(n)=∑i=0n(−1)i(ni)f(i) ⟺ f(n)=∑i=0n(−1)i(ni)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}g(i) \\end{aligned} ⟺​g(n)=i=0∑n​(−1)i(in​)f(i)f(n)=i=0∑n​(−1)i(in​)g(i)​ 如果令 f(i)′=(−1)if(i)f(i)&#x27;=(-1)^i f(i)f(i)′=(−1)if(i)，那么可以得到另一个形式（这个形式更为常用，因为大多数题并不会凑出一个 −1-1−1，以下式子中的 f,gf,gf,g 均没有特定的含义）： g(n)=∑i=0n(ni)f(i) ⟺ f(n)=∑i=0n(−1)n−i(ni)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=0}^n\\binom{n}{i}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=0}^n(-1)^{n-i}\\binom{n}{i}g(i) \\end{aligned} ⟺​g(n)=i=0∑n​(in​)f(i)f(n)=i=0∑n​(−1)n−i(in​)g(i)​ 同时还有一种上指标的二项式反演： g(n)=∑i=nN(−1)i(in)f(i) ⟺ f(n)=∑i=nN(−1)i(in)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=n}^N(-1)^i\\binom{i}{n}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=n}^N(-1)^i\\binom{i}{n}g(i) \\end{aligned} ⟺​g(n)=i=n∑N​(−1)i(ni​)f(i)f(n)=i=n∑N​(−1)i(ni​)g(i)​ g(n)=∑i=nN(in)f(i) ⟺ f(n)=∑i=nN(−1)i−n(in)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=n}^N\\binom{i}{n}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=n}^N(-1)^{i-n}\\binom{i}{n}g(i) \\end{aligned} ⟺​g(n)=i=n∑N​(ni​)f(i)f(n)=i=n∑N​(−1)i−n(ni​)g(i)​ Prufer 序列 Prufer 序列的构建过程并不重要，重要的是它的性质。 Prufer 序列可以将一个 nnn 个节点的无根树用 [1,n][1,n][1,n] 中的 n−2n-2n−2 个整数表示，那么完全图有 nn−2n^{n-2}nn−2 棵生成树，因为每一个 Prufer 序列都对应一棵树。这就是 Cayley 公式。 一个数在 Prufer 序列中出现的次数是它在原树中的度数减一。 格路计数 在格点路径上，(0,0)→(n,m)(0,0)\\rightarrow (n,m)(0,0)→(n,m) 的方案数是 (n+mn)\\dbinom{n+m}{n}(nn+m​)。 对于不能经过某一条直线的限制，可以采用反射容斥。发现它们反射之后都会到达同一个点： [JLOI2015] 骗我呢。写出暴力 DP 转移方程后发现这其实是个格路计数问题，起点是 (0,0)(0,0)(0,0)，终点是 (n+m+1,n)(n+m+1,n)(n+m+1,n)，不能碰到 y=x+1,y=x−m−2y=x+1, y=x-m-2y=x+1,y=x−m−2。 我们将终点 TTT 做关于两条直线的对称，得到 T1,T2T1,T2T1,T2（翻转之后的路径也是可以翻转的）。这样我们只需要减去经过两条直线的方案数，而且是最后经过的（否则先经过一条直线再经过另一条的这种会算重，要及时减去）。 解题思路 例题 某些东西的难度可能比较大。 [ABC160F] Distributing Integers Portal. 非常经典。发现只需要满足子树中根节点是第一个出现的，因此对于一个子树将答案除掉 szszsz，换根 DP 即可。代码。 [CF1762E] Tree Sum Portal. 设连接 iii 的边权为 did_idi​，而每条边对 ∏di\\prod d_i∏di​ 的贡献为 111，然而 nnn 为奇数时 ∏di=−1\\prod d_i=-1∏di​=−1 永远不可能满足，因此 nnn 为奇数时无解。 如果 nnn 为偶数且树的形态固定，那么参考 Prufer 序列的构造方式，从叶子开始赋予边权，那么方式一定是唯一的！也就是说，对于给定的树的形态只有一种方式。 这样的话，一条边 (u,v)(u,v)(u,v) 的权值为 111 的充要条件是：断掉这条边之后两个连通块大小均为偶数。因为这样两个连通块都满足条件了，这条边填 111 即可。 考虑逐边计算贡献，枚举 111 所在的连通块大小 iii，这样 nnn 所对应的连通块大小便为 n−in-in−i。 此时这条边的边权为 (−1)i(-1)^i(−1)i。 剩下 nnn 个点中随便扔，方案数为 (n−2i−1)\\binom{n-2}{i-1}(i−1n−2​)。 两块随便制造无根树，根据 Cayley 公式计算即可。 随便找两个点连接。 代码。 [AGC002F] Leftmost Ball Portal. 考虑最终形成的合法序列，一定是 kkk 个白色球加上 nnn 中颜色的球各 k−1k-1k−1 个，合法情况是前缀白球个数大于等于其它颜色数。 fi,jf_{i,j}fi,j​ 表示 iii 个白球，放了 jjj 个颜色的方案数。 决策有两种： 放置一个白球，有 fi,j←+fi−1,jf_{i,j}\\stackrel{+}{\\leftarrow} f_{i-1,j}fi,j​←+fi−1,j​； 加入新颜色的球，即从 fi,j−1f_{i,j-1}fi,j−1​ 转移。系数是多少？首先需要在 n−j+1n-j+1n−j+1 中选择一个作为这时放置的颜色，将其中一个放置在第一个空位，然后剩下的 k−2k-2k−2 个在后面的 nk−i−(j−1)(k−1)−1nk-i-(j-1)(k-1)-1nk−i−(j−1)(k−1)−1 中找 k−2k-2k−2 个放即可。 然后就完了。代码。 * [LNOI2022] 盒 Portal. 真·组合数基础练习题！ 发现 wiw_iwi​ 会被使用 ∑∣∑j=1ibj−∑j=1iaj∣\\sum |\\sum_{j=1}^i b_j-\\sum_{j=1}^i a_j|∑∣∑j=1i​bj​−∑j=1i​aj​∣ 次。枚举 j=∑k=1ibkj=\\sum_{k=1}^i b_kj=∑k=1i​bk​，将 aaa 转化为其前缀和，合法的 i,ji,ji,j 的出现条件是前 iii 个数和为 jjj，后 n−in-in−i 个数和为 S−jS-jS−j，于是直接插板可以得到总贡献： ∑i=1n−1wi∑j=0S∣j−ai∣(j+i−1i−1)(S−j+n−i−1n−i−1)\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^S |j-a_i|\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} i=1∑n−1​wi​j=0∑S​∣j−ai​∣(i−1j+i−1​)(n−i−1S−j+n−i−1​) 这样的时间复杂度是 O(nS)O(nS)O(nS) 的。考虑拆绝对值，大概像这样： ∑i=1n−1wi∑j=0S(j−ai)(j+i−1i−1)(S−j+n−i−1n−i−1)+2∑i=1n−1wi∑j=0ai(ai−j)(j+i−1i−1)(S−j+n−i−1n−i−1)\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^S (j-a_i)\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1}+2\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^{a_i} (a_i-j)\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} i=1∑n−1​wi​j=0∑S​(j−ai​)(i−1j+i−1​)(n−i−1S−j+n−i−1​)+2i=1∑n−1​wi​j=0∑ai​​(ai​−j)(i−1j+i−1​)(n−i−1S−j+n−i−1​) 这样让 jjj 从 000 开始枚举的目的是让接下来好算。后面的式子显然条件更强，因此以后面那个为例。由于出现减法不好搞，因此拆掉： ∑j=0aiai(j+i−1i−1)(S−j+n−i−1n−i−1)−∑j=0aij(j+i−1i−1)(S−j+n−i−1n−i−1)\\sum_{j=0}^{a_i} a_i \\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1}-\\sum_{j=0}^{a_i} j\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} j=0∑ai​​ai​(i−1j+i−1​)(n−i−1S−j+n−i−1​)−j=0∑ai​​j(i−1j+i−1​)(n−i−1S−j+n−i−1​) 前面那个 aia_iai​ 可以直接搞出来，后面那个利用 (nm)=(nm−1)(n−m+1)\\binom{n}{m}=\\binom{n}{m-1}(n-m+1)(mn​)=(m−1n​)(n−m+1) 将 jjj 改为 iii 再扔出来。 现在仅剩的问题就是快速计算： f(n,m,i,k)=∑j=0k(j+i−1i−1)(m−j−1+n−in−i−1)f(n,m,i,k)=\\sum_{j=0}^k \\binom{j+i-1}{i-1}\\binom{m-j-1+n-i}{n-i-1} f(n,m,i,k)=j=0∑k​(i−1j+i−1​)(n−i−1m−j−1+n−i​) 快速计算 f(n,m,i,k)f(n,m,i,k)f(n,m,i,k)？然而这个式子是拆不动了，考虑使用增量法计算。kkk 的增量是好处理的，但是 iii 呢？不知道。从组合意义的角度考虑，fff 是将前 iii 个和 ≤k\\le k≤k 的数，且所有 nnn 个数和为 mmm 的方案数。相当于是将 mmm 个相同的球放到 nnn 个不同的盒子中，前 iii 个盒子最多只能放 kkk 个球，相当于第 k+1k+1k+1 个小球不在前 iii 个盒子里！那么枚举放的位置，插板有： f(n,m,i,k)=∑j=i+1n(k+j−1j−1)(m−k−1+n−jn−j)f(n,m,i,k)=\\sum_{j=i+1}^n \\binom{k+j-1}{j-1}\\binom{m-k-1+n-j}{n-j} f(n,m,i,k)=j=i+1∑n​(j−1k+j−1​)(n−jm−k−1+n−j​) 那么就可以使用这个式子维护 iii 的增量了。代码。 [CF985G] Team Players Portal. 一眼看去在补图上跑三元环计数，然后发现边数爆炸，直接告辞。 但是唯一会的好像就是数三元环。考虑求答案的补集，答案应该是所有三元组的答案，减去至少有一条边的三元组的答案。 然后后面这个怎么做呢？我们肯定是要去看边的，这样就会导致对于一个有两条边的三元组，被统计两次。因此后面这个也需要容斥。 最终答案就是所有三元组的答案（1），减去至少有一条边的答案（2），加上至少有两条边的答案（3），减去有三条边的答案（4）。接下来分别看这四个东西怎么做。 枚举 u∈[0,n)u\\in [0,n)u∈[0,n) 中在三元组 (i,j,k)(i,j,k)(i,j,k) 的位置，然后利用乘法原理计算答案。 只有一条边，那么枚举所有边 (x,y)(x,y)(x,y)，不妨令 x&lt;yx&lt;yx&lt;y，然后令第三个点为 zzz，考虑 x,y,zx,y,zx,y,z 对三元组 (i,j,k)(i,j,k)(i,j,k) 的贡献。 x=ix=ix=i，此时 z&gt;xz&gt;xz&gt;x，xxx 的贡献为 A×x×(n−x−2)A\\times x\\times (n-x-2)A×x×(n−x−2)； x=jx=jx=j，此时 z&lt;xz&lt;xz&lt;x，xxx 的贡献为 B×x×xB\\times x\\times xB×x×x； y=jy=jy=j，此时 z&gt;yz&gt;yz&gt;y，yyy 的贡献为 B×y×(n−y−1)B\\times y\\times (n-y-1)B×y×(n−y−1)； y=ky=ky=k，此时 z&lt;yz&lt;yz&lt;y，yyy 的贡献为 C×y×(y−1)C\\times y\\times (y-1)C×y×(y−1)； z=iz=iz=i，此时 0≤z&lt;x0\\le z&lt;x0≤z&lt;x，zzz 的贡献为 A×∑p=0x−1p=A×x×(x−1)2\\displaystyle A\\times \\sum_{p=0}^{x-1}p=A\\times \\frac {x\\times (x-1)} 2A×p=0∑x−1​p=A×2x×(x−1)​； z=jz=jz=j，此时 x&lt;z&lt;yx&lt;z&lt;yx&lt;z&lt;y，zzz 的贡献为 B×∑p=x+1y−1p=B×(x+y)×(y−x−1)2\\displaystyle B\\times \\sum_{p=x+1}^{y-1}p=B\\times\\frac{(x+y) \\times (y-x-1)} 2B×p=x+1∑y−1​p=B×2(x+y)×(y−x−1)​； z=kz=kz=k，此时 y&lt;z&lt;ny&lt;z&lt;ny&lt;z&lt;n，zzz 的贡献为 C×∑p=y+1n−1p=C×(n+y)×(n−y−1)2\\displaystyle C\\times \\sum_{p=y+1}^{n-1}p=C\\times \\frac{(n+y)\\times (n-y-1)} 2C×p=y+1∑n−1​p=C×2(n+y)×(n−y−1)​。 两条边，要求的是三个点的链。不妨考虑枚举的是中间点 xxx，此时 x=jx=jx=j。枚举 xxx 的每一条出边到达点 yyy，设 xxx 的出度为 ttt。由于 xxx 也会影响 yyy 充当的是 i,ji,ji,j 还是 kkk，因此不妨把 xxx 也加进 xxx 的出边中（ttt 同时也增大 111）。设 yyy 在这些数中的排名为 rrr，分两种情况计算 yyy 的贡献： y&lt;xy&lt;xy&lt;x，此时考虑第三个点 zzz ： z&gt;yz&gt;yz&gt;y，yyy 的贡献为 A×y×(t−r−2)A\\times y\\times (t-r-2)A×y×(t−r−2)； z&lt;yz&lt;yz&lt;y，yyy 的贡献为 B×y×rB\\times y\\times rB×y×r； y&gt;xy&gt;xy&gt;x，此时考虑第三个点 zzz； z&gt;yz&gt;yz&gt;y，yyy 的贡献为 B×y×(t−r−1)B\\times y\\times (t-r-1)B×y×(t−r−1)； z&lt;yz&lt;yz&lt;y，yyy 的贡献为 C×y×(r−1)C\\times y\\times (r-1)C×y×(r−1)。 然后对于 xxx 自己要进行一个统计，考虑三种情况： y,z&lt;xy,z&lt;xy,z&lt;x，xxx 的贡献为 C×x×r×(r−1)2C\\times x\\times \\dfrac{r\\times (r-1)}{2}C×x×2r×(r−1)​； y,z&gt;xy,z&gt;xy,z&gt;x，xxx 的贡献为 A×x×(t−r−1)×(t−r−2)2A\\times x\\times \\dfrac{(t-r-1)\\times (t-r-2)}{2}A×x×2(t−r−1)×(t−r−2)​； y&lt;x,z&gt;xy&lt;x,z&gt;xy&lt;x,z&gt;x，xxx 的贡献为 B×x×r×(t−r−1)B\\times x\\times r\\times (t-r-1)B×x×r×(t−r−1)。 直接搞一个三元环计数模板就行。 于是就很高兴地做完了，时间复杂度应该是 O(n)+O(m)+O(n+m)+O(mm)=O(n+mm)O(n)+O(m)+O(n+m)+O(m\\sqrt{m})=O(n+m\\sqrt{m})O(n)+O(m)+O(n+m)+O(mm​)=O(n+mm​)。代码。 Polya 计数理论 容斥原理可以防止算重，而想要知道问题有多少个互不等价的解，可以使用 Polya 定理。 群论概述 群是由一种集合 GGG 以及一个二元运算所组成的，它的二元运算用 a⋅ba\\cdot ba⋅b 表示，要求满足群公理： 封闭性，∀a,b∈G,a⋅b∈G\\forall a,b\\in G, a\\cdot b\\in G∀a,b∈G,a⋅b∈G。 结合律，对于 GGG 中的任意元素，其二元运算需要满足结合律。 单位元，GGG 中存在一个元素 eee，使得对于 GGG 中的任意一个元素 aaa，都有一个 e⋅a=a⋅e=ae\\cdot a=a\\cdot e=ae⋅a=a⋅e=a 成立。这个元素应该是唯一的，被称为群的单位元 eee。 逆元，对于 GGG 中的 aaa，总存在 GGG 中的一个 bbb 满足 a⋅b=b⋅a=ea\\cdot b=b\\cdot a=ea⋅b=b⋅a=e，称 bbb 为 aaa 的逆元，记为 a−1a^{-1}a−1。任何一个元素的逆元是唯一的。 这样，(G,⋅)(G,\\cdot)(G,⋅) 被称为一个群。例如，(Z,+)(\\mathbb{Z},+)(Z,+) 是一个群，e=0e=0e=0，一个数的逆元是它的相反数。 如果 (G,⋅)(G,\\cdot)(G,⋅) 满足封闭性和结合律，那么它就是一个半群；如果还满足单位元，那么它就是幺半群；如果群 (G,⋅)(G,\\cdot)(G,⋅) 满足交换律，即 ∀a,b∈G,a⋅b=b⋅a\\forall a,b\\in G, a\\cdot b=b\\cdot a∀a,b∈G,a⋅b=b⋅a，那么这是一个阿贝尔群，又称交换群。 若 H⊆GH\\subseteq GH⊆G，且 (H,⋅)(H,\\cdot)(H,⋅) 是群，那么 (H,⋅)(H,\\cdot)(H,⋅) 是 (G,⋅)(G,\\cdot)(G,⋅) 的一个子群。可以记作 H≤GH\\le GH≤G。 定义 gH={g⋅h∣h∈H}gH=\\{g\\cdot h|h\\in H\\}gH={g⋅h∣h∈H} 为 HHH 关于 ggg 的左陪集，Hg={h⋅g∣h∈H}Hg=\\{h\\cdot g|h\\in H\\}Hg={h⋅g∣h∈H} 为 HHH 关于 ggg 的右陪集，其中满足 g∈Gg\\in Gg∈G。 如果 Hg1∩Hg2≠∅Hg_1\\cap Hg_2\\ne \\varnothingHg1​∩Hg2​=∅，那么 Hg1=Hg2Hg_1=Hg_2Hg1​=Hg2​。这一点不难感性理解。另外，∣H∣=∣Hg∣|H|=|Hg|∣H∣=∣Hg∣，因为 ghigh_ighi​ 必然互不相同。 拉格朗日定理：HHH 关于 GGG 中元素的陪集有 ∣G∣∣H∣\\frac{|G|}{|H|}∣H∣∣G∣​ 种，两两不交且大小均为 HHH。陪集的种类数可以记作 [G:H][G:H][G:H]。 置换群 置换群 G=(M,⋅)G=(M,\\cdot)G=(M,⋅)，其中 MMM 是置换的集合，运算是置换的合并运算。 Burnside 引理 定义置换群 GGG，其作用于 XXX，如果 x,y∈Xx,y\\in Xx,y∈X 在 GGG 的作用下可以相等，也就是说，存在 g∈Gg\\in Gg∈G 使得 g(x)=yg(x)=yg(x)=y，那么 x,yx,yx,y 是等价的。可以得到不同等价类的数量： ∣X/G∣=1∣G∣∑g∈GXg|X/G|=\\frac{1}{|G|}\\sum_{g\\in G}X^g ∣X/G∣=∣G∣1​g∈G∑​Xg XgX^gXg 指 XXX 在 ggg 作用下的不动点的数量，即满足 g(x)=xg(x)=xg(x)=x 的 xxx 的数量。 Polya 定理 模板。nnn 个点 nnn 条边的环，有 nnn 种颜色，给每个顶点染色，问有多少种本质不同的染色方案。n≤109n\\le 10^9n≤109。 在本题中，置换群 GGG 可以看作旋转 0∼n−10\\sim n-10∼n−1 个点的集合。我们得到： Ans=1∣G∣∑g∈GXgAns=\\frac{1}{|G|}\\sum_{g\\in G}X^g Ans=∣G∣1​g∈G∑​Xg 我们依次考虑每个置换对于答案的贡献，旋转 000 个的答案是 nnn^nnn，剩下的呢？ 旋转 kkk 个时，一个元素是不动点，当且仅当在颜色序列中，存在一个长度为 aaa 的循环节满足 a∣gcd⁡(n,k)a\\mid \\gcd(n,k)a∣gcd(n,k)。那么，每个子串的前 gcd⁡(n,k)\\gcd(n,k)gcd(n,k) 个都是随便取的，所以最终答案为： 1n∑k=1nngcd⁡(n,k)\\frac 1 n \\sum_{k=1}^{n}n^{\\gcd(n,k)} n1​k=1∑n​ngcd(n,k) 欧拉反演即可，也就是： 1n∑d∣nnd×∑k=1n[gcd⁡(n,k)=d]\\frac 1 n \\sum_{d\\mid n}n^d\\times \\sum_{k=1}^{n} \\left[\\gcd\\left(n,k\\right)=d\\right] n1​d∣n∑​nd×k=1∑n​[gcd(n,k)=d] 欧拉函数可以直接计算，代码。 说了半天，Polya 定理是什么呢？我们要知道不动点的数量，实际上就是置换环的个数！因为置换环内的点应该是相同的颜色，否则换一换就重了。那么可以写出（ccc 代表 ggg 中置换环的个数）： 1∣G∣∑g∈Gnc(g)\\frac{1}{|G|}\\sum_{g\\in G}n^{c(g)} ∣G∣1​g∈G∑​nc(g) 例题 理论上来讲不太常见。 [CF1065E] Side Transmutations Portal. 一个操作只有用和不用两种情况，将 bbb 数组差分之后每一段是独立的，然后可以写出： 12m∑Ctn−∑C\\frac {1}{2^m}\\sum_{C} t^{n-\\sum C} 2m1​C∑​tn−∑C 这东西拆掉就能做了。代码。 [ARC062D] Painting Graphs with AtCoDeer Portal. 如果不是点双上的边，那随便填；如果是只有一个环的点双上的边，那么 Polya 定理模板；如果是其它，那么插板即可。代码。 [SHOI2006] 有色图 Portal。 置换依然考虑点的置换，但是这次染色的是边。我们要知道边有多少个等价类。 考虑找到所有的置换环，设其大小为 cic_ici​，然后讨论等价类： 两个环内点：我们只关心两点在环上的距离，可以进行染色的不动点数量是 ci/2c_i/2ci​/2； 一个环内，一个环外点：可染色的不动点数量是 gcd⁡(ci,cj)\\gcd(c_i,c_j)gcd(ci​,cj​)。 枚举 nnn 的拆分即可。注意当中不能算重，在所有点全排列的基础上（然后向置换里面填），原本的同样大小的置换环要除以其全排列，置换环内的点没有顺序。代码。 概率论 题车 此部分介绍的内容可能是目前算法竞赛中最常出现的内容，因此题非常多。 刷基础 1 简单计数。 [COCI2009-2010#6] XOR Portal. 不难看出是容斥，但是系数是什么？手玩之后发现是 2s−12^{s-1}2s−1，其中 sss 是三角形的个数。代码。 [CF1227F] Wrong Answer on test 233 Portal. 其中一个答对的更多，都可以 swap 一下变成另一个答对的更多，因此考虑容斥求出两者答对的一样多的方案数。 先排除掉相邻 hih_ihi​ 相等的情况，因为这样必定都对，随便填都行。 枚举答对的数量，由于一个是对的位移的就不可能是对的，因此先后选择两次答对的数，然后强制钦定剩下的都不对。代码。 [CF1503E] 2-Coloring Portal. 考虑什么样的染色方式是符合要求的。要么蓝色贯穿，要么不贯穿。 蓝色不贯穿 钦定左边蓝色的高度和两个蓝色峰值的位置，枚举最右面的峰值，然后高度要求和是 nnn。 蓝色贯穿 这个翻转之后是一样的，注意第二次计算时要强制钦定 i−j≥2i-j\\ge 2i−j≥2，防止出现两个都是峰的情况。前缀和优化即可。代码。 * [JLOI2016] 成绩比较 Portal. 首先在 n−1n-1n−1 名同学中钦定 kkk 名同学被 B 神碾压。 需要钦定同学分数的具体情况，此时对于每一科可以分开考虑。 考虑 G(u,a,b)G(u,a,b)G(u,a,b) 代表有 uuu 种可选分数，aaa 人比 B 神高，bbb 人不比 B 神高，则： G(u,a,b)=∑i=0uia(u−i)bG(u,a,b)=\\sum_{i=0}^u i^a (u-i)^b G(u,a,b)=i=0∑u​ia(u−i)b 直接做会爆炸，考虑枚举有 ttt 种得分，答案为 d(t)d(t)d(t)，根据容斥原理得： d(t)=(ut)(G(t,a,b)−∑i=1t−1d(i)×(ti))d(t)=\\binom{u}{t}\\left(G(t,a,b)-\\sum_{i=1}^{t-1}d(i)\\times \\binom{t}{i}\\right) d(t)=(tu​)(G(t,a,b)−i=1∑t−1​d(i)×(it​)) 然后需要分配这些分数给每一个人，这里考虑分配给不被 B 神碾压的比较方便，在 n−1−kn-1-kn−1−k 个同学中，让 ri−1r_i-1ri​−1 个人第 iii 科分数比 B 君高，方案数为 (n−k−1ri−1)\\dbinom{n-k-1}{r_i-1}(ri​−1n−k−1​)。但是不对！我们需要保证这些人都不能被 B 君碾压！设 fif_ifi​ 代表不超过 iii 个人被碾压的方案数，那么： fi=∏j=1m(n−i−1rj−1)f_i=\\prod_{j=1}^{m} \\binom{n-i-1}{r_j-1} fi​=j=1∏m​(rj​−1n−i−1​) 容斥原理，得到答案： ∑i=0n−k−1(−1)n−k−1−ifi(n−k−1i)\\sum_{i=0}^{n-k-1}(-1)^{n-k-1-i} f_i\\binom{n-k-1}i i=0∑n−k−1​(−1)n−k−1−ifi​(in−k−1​) 将三个东西全部乘起来即可，代码。 刷基础 2 含有概率和期望的问题。 [CF850F] Rainbow Balls Portal. 设 f(x)f(x)f(x) 代表钦定一个当前有 xxx 个球的颜色，将全部 sss 个球转化成这个颜色的期望操作次数。根据期望的线性性质，最终答案是 ∑f(ai)\\sum f(a_i)∑f(ai​)。 如果转移到 f(0)f(0)f(0) 就完蛋了。 直觉上来讲是这样的： p=x(s−x)s(s−1)fx=p(fx−1+fx+1)+(1−2p)fx+1p=\\frac{x(s-x)}{s(s-1)}\\\\ f_x=p(f_{x-1}+f_{x+1})+(1-2p)f_x + 1 p=s(s−1)x(s−x)​fx​=p(fx−1​+fx+1​)+(1−2p)fx​+1 直接转移到了 f(0)f(0)f(0) 怎么办？不，贡献不能是 111，它想要走到 sss 一定不能中途暴毙，所以贡献是 is\\cfrac i ssi​。 知道 f1f_1f1​ 是多少，一切就解决了。我们还知道 fs=0f_s=0fs​=0，那么：f1=f1−fs=∑i=2sfi−fi−1f_1=f_1-f_s=\\sum_{i=2}^s f_i-f_{i-1}f1​=f1​−fs​=∑i=2s​fi​−fi−1​，代入即可得到 f1=(s−1)2sf_1=\\cfrac{(s-1)^2}{s}f1​=s(s−1)2​。代码。 [Ptz 2019 Summer Day 3] Minimum Spanning Trees Portal. 设 fi,jf_{i,j}fi,j​ 代表 iii 个点的树 MST 为 jjj 的答案。转移时用 gi,jg_{i,j}gi,j​ 代表形成大小和为 iii 的连通块，MST 为 jjj 的答案。此时的 MST 连接各连通块的边用当前枚举的边权定义。之后再把当前不连通的减去即可。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"八月二日闲话：微波炉战神","slug":"summaries/闲话/2023/8/2023-8-2","date":"2023-08-02T00:00:00.000Z","updated":"2023-08-02T00:00:00.000Z","comments":true,"path":"3dc46655/","link":"","permalink":"https://james1badcreeper.github.io/3dc46655/","excerpt":"","text":"某一次 B 君尝试把冷面放到微波炉里加热，但是这玩意儿怎么能放微波炉里呢？类似的操作，像把 I 君放到微波炉里，都是不可行的。 但是 B 君干出了更加疯狂的事情。他把 I 君的冰激凌放到了微波炉里！然而 I 君的冰激凌实在是太凉了，家里的微波炉爆炸了！ B 君很生气。“我要制造一个宇宙超级无敌豪华微波炉！” 五天过去后，定制的微波炉送到了，B 君再次将冰激凌放了进去，冰激凌融化了！ I 君回到家后发现他的冰激凌不见了，非常生气，而且 B 君的 宇宙超级无敌豪华微波炉 占据了半个厨房的体积。I 君说不动 B 君，只好给远在北极的 i 君打了个电话。 i 君觉得这非常有意思：“你让 B 君等几天，我送一个东西过来，如果 B 君的微波炉融不掉它，那么 B 君就需要砸掉他的微波炉。” 三天后，另一个冰激凌送了过来。这可不是一般的冰激凌，这是压缩冰激凌，这是 i 君的极寒冰沙，地球上最凉的冰激凌！ 不负众望，在 宇宙超级无敌豪华微波炉 对战极寒冰沙的战斗中，宇宙超级无敌豪华微波炉 败北了！ B 君不服：“我要制造 宇宙超级无敌豪华 Super 重量超级重量级闪瞎狗眼的微波炉 Pro Plus Max Ultra 至尊无敌版！” 宇宙超级无敌豪华 Super 重量超级重量级闪瞎狗眼的微波炉 Pro Plus Max Ultra 至尊无敌版 占据了整个时代广场。从此，这里改名叫，微波炉广场！ 但是，B 君依然没能成功融化极寒冰沙。 B 君很生气，非常的生气。他说：“我要制造 宇宙超级无敌至尊豪华 Super 重量超级重量级重量级中的重量级闪瞎所有人的眼睛的可以融化十个极寒冰沙超级无敌强化版终极超模微波炉 Pro Plus Max Ultra 无敌加强加强加强再加强豪华版！” 一年后微波炉造好了，出乎意料的，这次的微波炉大小正常了许多。“这样可以达到更高的温度！”B 君自信十足，于是，宇宙超级无敌至尊豪华 Super 重量超级重量级重量级中的重量级闪瞎所有人的眼睛的可以融化十个极寒冰沙超级无敌强化版终极超模微波炉 Pro Plus Max Ultra 无敌加强加强加强再加强豪华版 对战极寒冰沙，开始！ 但 B 君又失败了。 B 君彻底疯狂，变成了微波炉的形状。他一口吃下了极寒冰沙，极寒冰沙终于化掉了！微波炉 B 君拿着 宇宙超级无敌至尊豪华 Super 重量超级重量级重量级中的重量级闪瞎所有人的眼睛的可以融化十个极寒冰沙超级无敌强化版终极超模微波炉 Pro Plus Max Ultra 无敌加强加强加强再加强豪华版 在大街上游走。 某天，阿里嘎拉国对克莱因帝国发动了大规模的进攻。B 君出国迎战，只见一个重型微波炉右手拿着 宇宙超级无敌至尊豪华 Super 重量超级重量级重量级中的重量级闪瞎所有人的眼睛的可以融化十个极寒冰沙超级无敌强化版终极超模微波炉 Pro Plus Max Ultra 无敌加强加强加强再加强豪华版，左肩上扛着另一个 宇宙超级无敌至尊豪华 Super 重量超级重量级重量级中的重量级闪瞎所有人的眼睛的可以融化十个极寒冰沙超级无敌强化版终极超模微波炉 Pro Plus Max Ultra 无敌加强加强加强再加强豪华版，初遇敌人，B 君将右手的 宇宙超级无敌至尊豪华 Super 重量超级重量级重量级中的重量级闪瞎所有人的眼睛的可以融化十个极寒冰沙超级无敌强化版终极超模微波炉 Pro Plus Max Ultra 无敌加强加强加强再加强豪华版 砸向敌人，敌人被砸的溃不成军。B 君开启了狂暴模式，从手里变出无数的 宇宙超级无敌至尊豪华 Super 重量超级重量级重量级中的重量级闪瞎所有人的眼睛的可以融化十个极寒冰沙超级无敌强化版终极超模微波炉 Pro Plus Max Ultra 无敌加强加强加强再加强豪华版，以 S 君打音游般的速度将 宇宙超级无敌至尊豪华 Super 重量超级重量级重量级中的重量级闪瞎所有人的眼睛的可以融化十个极寒冰沙超级无敌强化版终极超模微波炉 Pro Plus Max Ultra 无敌加强加强加强再加强豪华版 扔向敌人。不久，我们就只能在大量 宇宙超级无敌至尊豪华 Super 重量超级重量级重量级中的重量级闪瞎所有人的眼睛的可以融化十个极寒冰沙超级无敌强化版终极超模微波炉 Pro Plus Max Ultra 无敌加强加强加强再加强豪华版 中发现少量敌人尸体。 B 君只身击败了实力强大的阿里嘎拉国军队！恭迎微波炉战神 B 君！","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"闲话","slug":"文章/闲话","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"}],"tags":[]},{"title":"NOI 一轮复习 II：数据结构 A","slug":"notes/NOI 复习/noi-1-2","date":"2023-06-30T00:00:00.000Z","updated":"2024-02-17T00:00:00.000Z","comments":true,"path":"3344a7ae/","link":"","permalink":"https://james1badcreeper.github.io/3344a7ae/","excerpt":"本文是 NOI 一轮复习的第二篇，包括各类常用数据结构。","text":"本文是 NOI 一轮复习的第二篇，包括各类常用数据结构。 待补充内容 支配对。Slope TrickKTT 树状数组 又称 Fenwick 树、二叉索引树（BIT）。支持维护前缀后缀的信息。 概述 树状数组将序列拆分成了恰好 nnn 个区间，对于每一个前缀求解都可以拆成 log⁡p\\log plogp 个区间进行求解，而且自带一个卡不掉的 1/21/21/2 的常数，随机数据下则为 1/41/41/4 的常数！我们通过 lowbit⁡\\operatorname{lowbit}lowbit 来支持树状数组的工作。 一个显式的树状数组 模板，区间和我们可以用前缀和相减来求解，代码如下： #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[500005]; i64 C[500005]; void add(int x, int k) &#123; for (; x &lt;= n; x += x &amp; -x) C[x] += k; &#125; i64 sum(int x) &#123; i64 r = 0; for (; x; x -= x &amp; -x) r += C[x]; return r; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), add(i, a[i]); while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) add(x, y); else printf(\"%lld\\n\", sum(y) - sum(x - 1)); &#125; return 0; &#125; 树状数组自身也有许多漂亮的操作，虽然效率上略微胜于线段树和平衡树，但是可扩展性和直观程度上却不如它们。下面我们来看一些必须掌握的。 线性建树 对于树状数组上的每个节点都向上传递，具体过程如下： for (int i = 1; i &lt;= n; ++i) &#123; int x; cin >> x; C[i] += x; if (i + lowbit(i) &lt;= n) C[i + lowbit(i)] += C[i]; &#125; 差分与前缀和 树状数组可以轻松维护序列的高阶前缀和，首先将原序列差分可以直接解决区间加单点查询。 将原序列前缀和： 编号 1 2 3 4 5 原序列 1 0 0 0 0 一阶前缀和 1 1 1 1 1 二阶前缀和 1 2 3 4 5 三阶前缀和 1 3 6 10 15 可以得到 bk,i=bk,i−1+bk−1,ib_{k,i}=b_{k,i-1}+b_{k-1,i}bk,i​=bk,i−1​+bk−1,i​。这是网格图路径计数，也就是说，bk,i=(i+k−1k−1)b_{k,i}=\\dbinom {i+k-1}{k-1}bk,i​=(k−1i+k−1​)。 也就是说，我们要求： ∑i=1x(x+k−1−ik−1)ai\\sum_{i=1}^x \\binom{x+k-1-i} {k-1} a_i i=1∑x​(k−1x+k−1−i​)ai​ 由范德蒙德卷积得： ∑i=1x∑j=0k−1(xj)(k−1−ik−1−j)ai\\sum_{i=1}^x \\sum_{j=0}^{k-1} \\binom x j \\binom{k-1-i}{k-1-j} a_i i=1∑x​j=0∑k−1​(jx​)(k−1−jk−1−i​)ai​ 分离，可得： ∑j=0k−1(xj)∑i=1x(k−1−ik−1−j)ai\\sum_{j=0}^{k-1} \\binom x j \\sum_{i=1}^x \\binom{k-1-i}{k-1-j} a_i j=0∑k−1​(jx​)i=1∑x​(k−1−jk−1−i​)ai​ 后面那一坨可以使用树状数组维护，前面直接乘就行。注意这里的是广义二项式系数，也就是说： (nm)=∏i=n−m+1nim!\\binom n m =\\frac {\\prod_{i=n-m+1}^{n}i}{m!} (mn​)=m!∏i=n−m+1n​i​ 模板，代码如下： int C(int n, int m) &#123; if (n &lt; 0) return 1ll * fac[m - n - 1] * ifac[-n - 1] % P * ifac[m] % P * (m &amp; 1 ? P - 1 : 1) % P; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; void add(int p, int x, int y) &#123; for (int i = x; i &lt;= n; i += i &amp; -i) a[p][i] = (a[p][i] + 1ll * C(k - x, k - p) * y % P) % P; &#125; int sum(int p, int x) &#123; int r = 0; for (int i = x; i; i -= i &amp; -i) r = (r + a[p][i]) % P; return r; &#125; main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;k, &amp;m); --k; for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); for (int j = 0; j &lt;= k; ++j) add(j, i, x); &#125; while (m--) &#123; int op, x; scanf(\"%d%d\", &amp;op, &amp;x); if (op == 1) &#123; int y; scanf(\"%d\", &amp;y); for (int i = 0; i &lt;= k; ++i) add(i, x, y); &#125; else &#123; int ans = 0; for (int i = 0; i &lt;= k; ++i) ans = (ans + 1ll * C(x, i) * sum(i, x) % P) % P; printf(\"%d\\n\", (ans + P) % P); &#125; &#125; &#125; 当 kkk 较小时，也可以手推结论：对于 kkk 阶前缀和，写出 (y−x+k−1k−1)\\dbinom{y-x+k-1}{k-1}(k−1y−x+k−1​) 的多项式形式，然后 yyy 表示的是下标，xxx 表示的是当前位置的值。 比如 k=3k=3k=3 时： (y−x+22)=(y−x+2)(y−x+1)2\\dbinom{y-x+2}{2}=\\frac{(y-x+2)(y-x+1)}{2} (2y−x+2​)=2(y−x+2)(y−x+1)​ 所以展开为： x2−(2y−3)x1+(y2+3y+2)x02\\frac{x^2-(2y-3)x^1+(y^2+3y+2)x^0}{2} 2x2−(2y−3)x1+(y2+3y+2)x0​ 那么维护 vxivx^ivxi 在 yyy 处的前缀和，统计答案即可。这样的好处是不用写广义二项式系数来计算贡献。 [Code+#1] Yazid 的新生舞会。给定一个长度为 n(n≤5×105)n(n\\le 5\\times 10^5)n(n≤5×105) 的序列，问其中有多少个子区间存在出现次数严格超过子区间长度一半的众数。 考虑枚举每个种类的数分别计算，设当前选中的数为 www，SiS_iSi​ 为前 iii 个数中 www 的个数。 对于一段区间 [l+1,r][l+1,r][l+1,r]（方便差分），满足条件时有 Sr−Sl&gt;r−l−(Sr−Sl)→2Sr−r&gt;2Sl−lS_r-S_l&gt;r-l-(S_r-S_l)\\rightarrow 2S_r-r&gt;2S_l-lSr​−Sl​&gt;r−l−(Sr​−Sl​)→2Sr​−r&gt;2Sl​−l，也就是在求 Pi=2Si−iP_i=2S_i-iPi​=2Si​−i 的逆序对个数。 对于同一个 www，PiP_iPi​ 可以划分成若干个单调递减区间，总数在 O(n)O(n)O(n) 级别。同一个区间内是没有贡献的，只需要计算 lll 在前面区间内的贡献。 设 cic_ici​ 代表 iii 在 PPP 中的出现次数（由于可能有负的，所以需要加上一个偏移量），TTT 表示 cic_ici​ 的前缀和，那么每一个 PiP_iPi​ 的贡献就是当前的 TPi−1T_{P_i-1}TPi​−1​。对于一段 [x,y][x,y][x,y]，总贡献就是 ∑i=x−1y−1Ti\\sum\\limits_{i=x-1}^{y-1}T_ii=x−1∑y−1​Ti​，再求一个 TTT 的前缀和 GGG 即可。 这玩意就是三阶前缀和。 int n, type; int a[500005]; vector&lt;int> b[500005]; i64 C1[1000005], C2[1000005], C3[1000005]; i64 sum(int x) &#123; i64 res = 0; for (int i = x; i > 0; i -= i &amp; -i) res += C1[i] * (x + 2) * (x + 1) - C2[i] * (2 * x + 3) + C3[i]; return res; &#125; void add(int x, i64 k) &#123; for (int i = x; i &lt;= 2 * n + 1; i += i &amp; -i) C1[i] += k, C2[i] += k * x, C3[i] += k * x * x; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;type); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[a[i]].emplace_back(i); i64 ans = 0; const int N = n + 1; for (int i = 0; i &lt; n; ++i) &#123; b[i].emplace_back(n + 1); int last = 0; for (int j = 0; j &lt; b[i].size(); ++j) &#123; int x = 2 * j - b[i][j] + 1 + N, y = 2 * j - last + N; ans += sum(y - 1) - sum(x - 2); add(x, 1); add(y + 1, -1); last = b[i][j]; &#125; last = 0; for (int j = 0; j &lt; b[i].size(); ++j) &#123; int x = 2 * j - b[i][j] + 1 + N, y = 2 * j - last + N; add(x, -1); add(y + 1, 1); last = b[i][j]; &#125; &#125; return !printf(\"%lld\\n\", ans / 2); &#125; 树状数组二分与倍增 我们当然可以使用二分套树状数组达到 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n) 的复杂度，然而有没有更好的方式适配树状数组这种结构呢？有！倍增！ 查询一个权值树状数组里的 kkk 小值。 我们从二进制高位到低位枚举，时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 // 权值树状数组查询第 k 小 int kth(int k) &#123; int sum = 0, x = 0; for (int i = 17; i >= 0; --i) &#123; // 需满足 sum &lt; k x += 1 &lt;&lt; i; // 尝试扩展 if (x >= n || sum + C[x] >= k) x -= 1 &lt;&lt; i; // x 不在树状数组范围内，或扩展失败 else sum += C[x]; &#125; return x + 1; &#125; [省选联考 2020 A/B 卷] 冰火战士。将温度离散化，那么求的就是冰人前缀和（IpI_pIp​）和火人后缀和（前缀和记为 FpF_pFp​）的最小值最大为多少。由于能力值不为负，因此只需要求出 Ip≤Fsum−Fp−1I_p\\le F_{sum}-F_{p-1}Ip​≤Fsum​−Fp−1​ 的最大 ppp 和 Ip≥Fsum−Fp−1I_p\\ge F_{sum}-F_{p-1}Ip​≥Fsum​−Fp−1​ 的最大 ppp（但是 Fp−1F_{p-1}Fp−1​ 最小）。 前者好搞，但是后者怎么求？考虑将 FFF 平移一位，条件一变成 Ip≤Fsum−FpI_p\\le F_{sum}-F_{p}Ip​≤Fsum​−Fp​，条件二变成 Ip≥Fsum−FpI_p\\ge F_{sum}-F_{p}Ip​≥Fsum​−Fp​。当求出前面的 ppp 后，取 p←p+1p\\leftarrow p+1p←p+1，那么此时 ppp 就是满足条件二的最小 ppp，然后再次倍增出最大的 ppp 即可。代码。 例题 更多注重于分析。 [Ptz 2022 Summer Day 2] Ternary Search Portal. 我们只需要考虑单谷。 谷的值是可以确定的。如果我们将谷左边的数全部取相反数，那么答案就是全局的逆序对数。 也就是说，我们通过是否取相反数来确定其应该是在谷值的左边还是右边。如果取相反数，那么它在左边，它对答案的贡献是在它左边比其小的个数 LiL_iLi​；如果不取相反数，那么其对答案的贡献就是正常计入逆序对统计了。 也就是说，我们可以正常求逆序对的个数，当其走到左边的时候，我们就在树状数组上撤销它的贡献。何时它会跑到左边？当在它左边有 xxx 个比它小的数，右边有 xxx 个比它小的数的时候，就会切换，此时直接继承原来的贡献即可。树状数组上倍增即可。代码。 线段树 线段树是一种功能强大的二叉数据结构，可以维护半群上的信息（满足结合律）。 对于一般情况，我们使用堆式线段树来存储线段树；对于空间开不下的情况，我们使用动态开点来存储线段树。 线段树基本结构 这里不再赘述线段树的基本结构，但是它是一个很有用的东西。 [CF1556G] Gates to Another World。空间大盗在 2n2^n2n 个世界中旅行，编号为 i,ji,ji,j 的世界能穿越当且仅当 popcount(i⊕j)=1\\mathrm{popcount}(i \\oplus j)=1popcount(i⊕j)=1。有 mmm 次操作，每次询问 a,ba,ba,b 是否能互相到达，或者摧毁编号在 [l,r][l,r][l,r] 之间的所有世界，保证没有世界会被摧毁两次。n≤50,m≤5×104n\\le 50,m\\le 5\\times 10^4n≤50,m≤5×104。 首先无脑考虑逆时旅人，将删点改成加点。这样一定是更好做的。 最主要的问题是，如何用一种方式来压缩图？对于一个没有被删点的连续 2i2^i2i 段，一定是连通的。这是什么？ 线段树。 注意一个位置只会被删除一次，这很好，我们可以在线段树上区间染色，代表这些点存活到了 iii 时刻。 这样对于动态开点线段树上的存在的点，才是有意义的点，其余所有点都可以被映射到它们身上。对于每个节点将在 min⁡{lsi,rsi}\\min\\{ls_i,rs_i\\}min{lsi​,rsi​} 时刻将它的左右儿子分裂开（不再连通），并查集维护即可。代码。 延迟标记 这个东西不只被用在线段树上，但从线段树结构基本可以介绍出它的大部分应用。以下问题都可以直接使用多元标记来处理： 区间最大子段和：维护前缀后缀最大子段和、区间和和答案即可； 区间平方和：不难根据区间和计算出新的区间平方和； 区间加等差数列单点求和：每个点维护一个 ddd，代表其加上的是 d×id\\times id×i，其中 iii 是下标，然后再维护一个区间加标记即可。 [CF446C] DZY Loves Fibonacci Numbers.区间加斐波那契数列，区间求和。 将广义斐波那契数列的前两项作为标记打在线段树中，合并时直接加起来就可以。再加上斐波那契数列的求和公式：∑i=1nfi=fn+2−f2\\sum_{i=1}^{n}f_i=f_{n+2}-f_{2}∑i=1n​fi​=fn+2​−f2​，和便可以直接计算。代码。 矩阵乘法维护标记 可以参考 https://www.luogu.com.cn/blog/George-Plover/qian-tan-xian-xing-lan-biao-ji-wei-hu-ji-qiao-yi-xian-duan-shu-wei-li。 当标记大于一个的时候，我们就需要思考不同标记在下传过程中的相互影响，然而这很麻烦。因此，通过构造向量和矩阵乘法，可以很好地简化这类问题。 区间加区间乘是一个经典问题，我们在统计信息时需要直到当前点的和和区间长度，因此维护： [sumlen]\\begin{bmatrix} sum\\\\ len \\end{bmatrix} [sumlen​] 加法操作的矩阵是 [1c01]\\begin{bmatrix}1 &amp; c\\\\0 &amp; 1\\end{bmatrix}[10​c1​]，乘法操作的矩阵是 [k001]\\begin{bmatrix}k &amp; 0\\\\ 0 &amp; 1 \\end{bmatrix}[k0​01​]，这样就转化成了一种操作。 [ICPC2021 Nanjing R] Paimon Segment Tree，因为这道题的存在，我想称这种技巧为“派蒙标记”。 线段树上一个结点维护 [sa2alen]\\begin{bmatrix}s &amp; a^2 &amp; a &amp; len\\end{bmatrix}[s​a2​a​len​] 代表累加和、区间平方和，区间和和区间长度，扫描线维护版本维，所有的信息都可以直接维护。代码。 派蒙线段树的经典应用是维护历史版本和，很容易使用矩阵描述这个东西。 [NOIP2022] 比赛。给定两个序列，每次给定一个区间 [l,r][l,r][l,r]，查询子区间的权值和，权值定义为两个序列区间最大值的乘积。 对于这种子区间求和的问题，其本质就是历史版本和。扫描线扫一端，然后维护历史版本和。 常数过大，需要将矩阵拆除，具体地，由于矩阵上不是 0/10/10/1 的位置只有 999 个，因此维护这些位置的值即可。代码。 李超线段树 考虑这样一个问题：加入给定定义域的一次函数，查询 x=kx=kx=k 时的最小值。 怎么做？考虑一种线段树，维护 [l,r][l,r][l,r] 的节点只存储一个 midmidmid 处值最小的线段。修改操作如何实现呢？如果修改的线段不比当前线段优，那么下传修改线段；如果修改线段比当前线段优，那么下传当前线段。也就是说，要下传的一定是那个更劣的线段。如何下传？只有当在某一部分的线段有交点时才需要下传。 单次修改时间复杂度为 O(log⁡2n)O(\\log^2 n)O(log2n)，查询时直接记录路过的所有线段的答案即可，时间复杂度依然为 O(log⁡n)O(\\log n)O(logn)。 inline void pushup(int o, int l, int r) &#123; T[o].v = min(&#123;T[o].v, T[o &lt;&lt; 1].v, T[o &lt;&lt; 1 | 1].v&#125;); T[o].v = min(&#123;T[o].v, calc(T[o].s, dis[idx[l]]), calc(T[o].s, dis[idx[r]])&#125;); &#125; void update(int o, int l, int r, int x, int y, Seg k) &#123; int mid = l + r >> 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; if (calc(k, dis[mid]) &lt; calc(T[o].s, dis[idx[mid]])) swap(k, T[o].s); // 中点处 x 当前线段比 k 劣 if (calc(k, dis[idx[l]]) &lt; calc(T[o].s, dis[idx[l]])) update(o &lt;&lt; 1, l, mid, x, y, k); if (calc(k, dis[idx[r]]) &lt; calc(T[o].s, dis[idx[r]])) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); return pushup(o, l, r); &#125; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); pushup(o, l, r); &#125; 吉司机线段树 指的是一类维护区间最值操作与历史最值的线段树（Segment Tree Beats）。 区间最值操作 每个节点维护最大值，严格次大值和最大值的数量。这样遍历节点时有三种情况： ma≤xma\\le xma≤x，那么无影响。 se&lt;x&lt;mase&lt;x&lt;mase&lt;x&lt;ma，可以直接打上延迟标记计算。 x≤sex\\le sex≤se，暴力递归。 大概势能分析一下加上实际表现证明，其时间复杂度为线性对数。 区间历史最值 每个节点维护一个二元标记 (p,q)(p,q)(p,q)，代表先加 ppp 再对 qqq 取 max⁡\\maxmax。那么标记的合并就是 (p1+p2,max⁡{q1+p2,q2})(p_1+p_2,\\max\\{q_1+p_2,q_2\\})(p1​+p2​,max{q1​+p2​,q2​})。这个东西存在颜色段均摊，因此时间复杂度为 O((n+q)log⁡n)O((n+q)\\log n)O((n+q)logn)。使用这种多元标记思想可以处理绝大部分的历史最值问题。 CPU 监控。考虑没有染色操作怎么做。简单，维护最大的历史加标记。 发现一次染色后所有的加都可以转化为染色，因此染色后直接开始维护标记即可避开讨论。 int n, m, a[100005]; struct Node &#123; int mx, hmx, setv, addv, hset, hadd, tag; void cover(int v, int hv) &#123; setv = mx = v; addv =-0; if (tag) hset = max(hset, hv); else hset = hv, tag = 1; hmx = max(hmx, hv); &#125; void add(int v, int hv) &#123; hadd = max(hadd, addv + hv); hmx = max(hmx, mx + hv); addv += v; mx += v; &#125; void change(int v, int hv) &#123; if (tag) cover(setv + v, setv + hv); else add(v, hv); &#125; &#125; T[400005]; inline void pushup(int o) &#123; T[o].mx = max(T[o &lt;&lt; 1].mx, T[o &lt;&lt; 1 | 1].mx); T[o].hmx = max(T[o &lt;&lt; 1].hmx, T[o &lt;&lt; 1 | 1].hmx); &#125; inline void pushdown(int o) &#123; T[o &lt;&lt; 1].change(T[o].addv, T[o].hadd); T[o &lt;&lt; 1 | 1].change(T[o].addv, T[o].hadd); T[o].addv = T[o].hadd = 0; if (T[o].tag) &#123; T[o &lt;&lt; 1].cover(T[o].setv, T[o].hset); T[o &lt;&lt; 1 | 1].cover(T[o].setv, T[o].hset); T[o].tag = 0; &#125; &#125; void update(int o, int l, int r, int x, int y, int k, bool type) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return type ? T[o].cover(k, k) : T[o].change(k, k), void(); int mid = l + r >> 1; pushdown(o); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k, type); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k, type); pushup(o); &#125; 扫描线 对于一个高维空间的坐标限制，我们称之为 BBB 维正交范围问题，我们可以利用扫描线将其降维。也就是说，扫描线维护一维，数据结构维护另一维。 差分处理 如果维护的信息可以差分，那么直接差分掉。比如矩形面积并问题，静态区间内不同数个数问题。将问题转化为矩形操作，然后扫描线维护。 此问题的基础形态是二维数点：平面上有 nnn 个点 (i,ai)(i,a_i)(i,ai​)，每次查询一个矩形内的点的个数。此矩形是一个 4-side 的矩形，可以通过差分的方式将其转化为 3-side，然后再扫描线维护一下变成 2-side，这样就成了一个平凡的单点修改区间查询的问题。 二维数点模型非常的有用，类似于以下问题都可以处理： 矩形面积并。4-side 差分成 3-side 的修改，然后扫描线扫描，线段树维护时看是否被覆盖来进行 pushup，最后查询全局被覆盖的数量。 将 xxx 转化为 lll 的限制，yyy 转化为 rrr 的限制，然后看 iii 会对哪些 [l,r][l,r][l,r] 产生贡献，最后是矩形面积加和。 也就是说，差分和扫描线是我们的降维手段，最后一个 2-side 的问题就是平凡的，使用合适的数据结构（区间修改单点查询，单点修改区间查询，区间修改区间查询）维护即可。 类似的还有其它的数点问题，比如三维偏序（CDQ + 扫描线 + 数据结构），强制在线的二维数点（可以使用主席树），强制在线动态二维数点（必须树套树），使用合理的手段进行降维即可。 注意，扫描线不一定要扫时间维，可以扫序列维，也就是说，如果单点修改可以轻松撤销，那么区间修改就退化成了单点修改，然后数据结构维护操作序列操作的过程。 多次询问区间中只出现次数为偶数的数的异或和，给出一个线性对数的做法。 哎我会维护奇数！所以这道题就是直接区间所有出现数的异或和异或掉奇数异或和。前者可以采用扫描线，只维护这个数最后一次出现的位置的贡献。 【美团杯2021】A. 数据结构。nnn 个数的序列，每次查询如果将 [l,r][l,r][l,r] 中的元素都加上 111 后全局出现的数的个数。 先假定 n+1n+1n+1 个数全部出现，然后考虑数 iii 不出现的条件： 所有的 iii 都出现在 [l,r][l,r][l,r] 内； 所有的 i−1i-1i−1 都不出现在 [l,r][l,r][l,r] 内。 然后就是扫描线限制矩形即可。代码。 [Ynoi2001] 雪に咲く花。定义：f(l,r)=and⁡i=lrai×or⁡i=lrbi×gcd⁡i=lrcif(l,r)=\\operatorname{and}\\limits_{i=l}^r a_i\\times \\operatorname{or}\\limits_{i=l}^r b_i\\times \\gcd\\limits_{i=l}^r c_if(l,r)=andi=lr​ai​×ori=lr​bi​×i=lgcdr​ci​多次询问：g(l,r)=∑i=lr∑j=irf(i,j) mod 232g(l,r)=\\sum_{i=l}^r \\sum_{j=i}^r f(i,j) \\bmod 2^{32}g(l,r)=i=l∑r​j=i∑r​f(i,j)mod232 扫描线维护右端点 rrr，维护 sis_isi​ 代表 ∑p≤i∑p≤q≤rf(p,q)\\sum_{p\\le i} \\sum_{p\\le q\\le r}f(p,q)∑p≤i​∑p≤q≤r​f(p,q)，那么答案为 sr−sl−1s_r-s_{l-1}sr​−sl−1​。 记扫描到当前状态时，A,B,CA,B,CA,B,C 分别代表运算之后的后缀结果。 当 r→r+1r\\rightarrow r+1r→r+1 时，考虑 sis_isi​ 如何改变。如果 Ai,Bi,CiA_i,B_i,C_iAi​,Bi​,Ci​ 均没有发生变化，那么 sis_isi​ 的变化量和上次一样，将它们的“更新标记”的时间戳增大 111 即可（实际上只需要记录更新时间，然后维护每个节点的最后更新时间）。 只有后面一段 O(log⁡V)O(\\log V)O(logV) 的区间的 fff 值不同于 rrr 变化之前的（设为 ppp）。对于 [p,r][p,r][p,r] 直接暴力计算它们在当前 rrr 下的贡献的增量。具体来说，维护一个 viv_ivi​ 代表 ∑l=1if(l,r)\\sum_{l=1}^{i}f(l,r)∑l=1i​f(l,r) 就可以直接计算。 时间复杂度 O(nlog⁡V+m)O(n\\log V+m)O(nlogV+m)，离线后手写内存池卡常即可。代码。 分治处理 外星旅者离开了地球。我们将在未知时间补充这部分内容。 线段树合并 可以以 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间合并两棵满线段树的信息。但对于常用的在树上进行线段树合并，由于每棵线段树初始只用一个信息，因此总时间复杂度是 O(nlog⁡n)O(n\\log n)O(nlogn) 的。 int merge(int p, int q, int l, int r) &#123; if (!p || !q) return p + q; if (l == r) return T[p].cnt += T[q].cnt, p; int mid = l + r >> 1; T[p].ls = merge(T[p].ls, T[q].ls, l, mid); T[p].rs = merge(T[p].rs, T[q].rs, mid + 1, r); pushup(p); return p; &#125; 颜色段均摊 对于区间染色操作，每次只会增加 O(1)O(1)O(1) 个连续颜色段，均摊的颜色段插入删除次数为 O(n+m)O(n+m)O(n+m)。 对于区间染色类问题（区间染色、排序等操作），用珂朵莉树维护类的问题，都存在颜色段均摊。存在 2∼32\\sim 32∼3 倍的常数。 珂朵莉树模板速查 struct Node &#123; int l, r; mutable int v; // 这个 v 接下来需要修改 Node(int l = 0, int r = 0, int v = 0) : l(l), r(r), v(v) &#123;&#125; bool operator&lt; (const Node &amp;a) const &#123; return l &lt; a.l; &#125; &#125;; set&lt;Node> T; inline auto split(int p) &#123; if (p > n) return T.end(); auto it = T.lower_bound(Node(p)); if (it != T.end() &amp;&amp; it->l == p) return it; --it; int l = it->l, r = it->r; i64 v = it->v; T.erase(it); T.insert(Node(l, p - 1, v)); return T.insert(Node(p, r, v)).first; &#125; [CF444C] DZY Loves Colors。有一个 nnn 个元素组成的序列，每个元素有两个属性：颜色 cic_ici​ 和权值 wiw_iwi​。cic_ici​ 初始为 iii，wiw_iwi​ 初始为 000。mmm 次操作，操作有两种：1 l r x：对 i∈[l,r]i\\in [l,r]i∈[l,r] 的所有 iii 进行如下操作：设第 iii 个元素 原来 的颜色为 yyy，您要把第 iii 个元素的颜色改为 xxx，权值 增加 ∣y−x∣|y-x|∣y−x∣。2 l r：求 ∑i=lrwi\\sum\\limits_{i=l}^r w_ii=l∑r​wi​。1≤n,m≤1051\\le n,m\\le 10^51≤n,m≤105，1≤x≤1081\\le x\\le 10^81≤x≤108。 我们记一个 ccc 代表区间颜色，不一样时记为 −1-1−1。如果一样则打标记修改，不一样则暴力递归修改。一次区间染色只会产生两个新的端点，暴力查询的次数为 O(n+m)O(n+m)O(n+m) 级别。因此时间复杂度为 O((n+m)log⁡n)O((n+m)\\log n)O((n+m)logn)。代码。 单侧递归结构 [CTT2012 Day 1] 楼房重建。单点修改，询问全局有多少位置是前缀最大值。 使用线段树维护。一个节点记录两个数：区间所对应的答案，当前区间的最大斜率。修改时很容易实现，关键是，pushup？问题在于如何统计当前节点的答案，也就是说，如何统计右半段在被左半段影响之后应该如何计算答案。怎么办？不会！俗话说的好，那么直接递归下去！ 如果右区间的最大值小于等于左区间，那么就被全部挡住了。否则递归考虑右半段，这样所有的贡献都可以计算。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; struct Node &#123; int v; double k; &#125; T[400005]; double a[100005]; int pushup(int o, int l, int r, double k) &#123; if (T[o].k &lt;= k) return 0; if (a[l] > k) return T[o].v; if (l == r) return 0; int mid = l + r >> 1; if (T[o &lt;&lt; 1].k &lt;= k) return pushup(o &lt;&lt; 1 | 1, mid + 1, r, k); return pushup(o &lt;&lt; 1, l, mid, k) + T[o].v - T[o &lt;&lt; 1].v; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = &#123;1, a[x]&#125;, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o].k = max(T[o &lt;&lt; 1].k, T[o &lt;&lt; 1 | 1].k); T[o].v = T[o &lt;&lt; 1].v + pushup(o &lt;&lt; 1 | 1, mid + 1, r, T[o &lt;&lt; 1].k); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; while (m--) &#123; int x, y; cin >> x >> y; a[x] = 1.0 * y / x; update(1, 1, n, x, y); cout &lt;&lt; T[1].v &lt;&lt; \"\\n\"; &#125; return 0; &#125; [CF1340F] Nastya and CBS。维护一个有 kkk 中括号的序列，支持单点修改，区间查询是否可以匹配。 快速求解括号匹配可以使用哈希，由此不难得出一个序列分块的做法。这里我们考虑 log⁡\\loglog 做法。 我们考虑将整个结构放到线段树上，当匹配完之后，还剩下 log⁡\\loglog 个哈希值，这样直接合并即可。 如何合并两段的哈希值？对于每个节点，其匹配后必定剩余一堆左括号或者一堆右括号。用 vrvrvr 代表右括号的匹配情况，vlvlvl 代表左括号的匹配情况。在合并时，我们需要求解一定长度的括号的哈希值，这在线段树上单侧递归下去就可以实现。 对于求解一段的一定长度的哈希值，我们也可以在线段树上单侧递归下去来求解。代码。 例题 线段树的更多技巧可以在这里找到！ [Luogu P5278] 算术天才⑨与等差数列 Portal. 发现条件非常严苛，因此可以考虑哈希之类的方法，这里不做赘述。 一段区间可以重排为等差数列，当且仅当满足（d=0d=0d=0 先特判掉）： max⁡−min⁡=d×(len−1)\\max -\\min =d\\times (len-1)max−min=d×(len−1)； gcd⁡i=lr−1(ai+1−ai)=d\\gcd_{i=l}^{r-1}(a_{i+1}-a_i)=dgcdi=lr−1​(ai+1​−ai​)=d； 序列中没有重复的元素。 用线段树维护即可。第三条可以使用 set、map 维护一个数最左边的出现位置，然后用线段树维护这个值的最小值，如果这个数小于 lll，那么一定没有重复元素。代码。 * [Ynoi2015] 纵使日薄西山 Portal.珂朵莉想让你维护一个长度为 nnn 的正整数序列 a1,a2,…,ana_1,a_2,\\ldots,a_na1​,a2​,…,an​，支持修改序列中某个位置的值。每次修改后问对序列重复进行以下操作，需要进行几次操作才能使序列变为全 000（询问后序列和询问前相同，不会变为全 000）：选出序列中最大值的出现位置，若有多个最大值则选位置标号最小的一个，设位置为 xxx，则将 ax−1,ax,ax+1a_{x-1},a_x,a_{x+1}ax−1​,ax​,ax+1​ 的值减 111，如果序列中存在小于 000 的数，则把对应的数改为 000。1≤n,q≤1051\\leq n,q\\leq 10^51≤n,q≤105，1≤xi≤n1\\leq x_i\\leq n1≤xi​≤n，1≤ai,yi≤1091\\leq a_i,y_i\\leq 10^91≤ai​,yi​≤109。 考虑哪些数可以被减。如果我们开始减 aia_iai​，那么它一定会一直减下去（因为左右两个永远都比它小）。 将原序列进行单调极长划分，发现对于每个极长单调区间，答案一定是所有奇数位置或者所有偶数位置的和。使用一个 set 存储所有的极长单调区间分割点（称为极值点，令一个极值点代表极长单调区间的结束），修改一个数时最多只会影响到五个极值点（修改一个极值点可能使它右边的极值点不存在，进而影响右边第二个极值点，左边同理），复杂度可以接受。 根据此维护即可，细节很多。代码。 [NOI2022] 众数 Portal. 区间绝对众数也必定是中位数，这样建立权值线段树，然后就可以直接线段树二分，然后检查出现次数是否合法即可。再用一个链表辅助合并序列就完成了，代码。 * [NOI2020] 命运 Portal. 考虑设 fx,yf_{x,y}fx,y​ 代表以 xxx 为根的子树中已经全部满足，不满足的距离最多为 yyy（从根节点向下开始）的方案数，答案为 f1,0f_{1,0}f1,0​。 考虑每次将 (x,y)(x,y)(x,y) 合并进当前答案，分别考虑这条边填 1/01/01/0 的贡献： fx,i′←∑j=0depxfx,ify,j+∑j=0ifx,ify,j+∑j=0i−1fx,jfy,if&#x27;_{x,i} \\leftarrow \\sum_{j=0}^{dep_x} f_{x,i}f_{y,j}+\\sum_{j=0}^{i} f_{x,i}f_{y,j}+\\sum_{j=0}^{i-1} f_{x,j}f_{y,i} fx,i′​←j=0∑depx​​fx,i​fy,j​+j=0∑i​fx,i​fy,j​+j=0∑i−1​fx,j​fy,i​ 设 gx,y=∑i=0yfx,ig_{x,y}=\\sum_{i=0}^y f_{x,i}gx,y​=∑i=0y​fx,i​，则： fx,i′=fx,i(gy,depx+gy,i)+fy,igx,i−1f&#x27;_{x,i}=f_{x,i}(g_{y,dep_x}+g_{y,i})+f_{y,i}g_{x,i-1} fx,i′​=fx,i​(gy,depx​​+gy,i​)+fy,i​gx,i−1​ 所有的转移位置都只与深度有关，因此直接线段树合并，维护区间乘法的修改。代码。 [CF793F] Julia and snail Portal. 扫描线扫一遍序列，遇到一条绳子 (l,r)(l,r)(l,r) 相当于 ∀i≤l∧ai≥l,ai←max⁡{ai,r}\\forall i\\le l\\wedge a_i\\ge l,a_i\\leftarrow \\max\\{a_i,r\\}∀i≤l∧ai​≥l,ai​←max{ai​,r}，实际上是 ai←ra_i\\leftarrow rai​←r，SGT Beats 维护即可。 具体地，每个节点维护最大值和次大值，修改使用二元组 (p,q)(p,q)(p,q) 来表示，代表 ∀ai≥p,ai←q\\forall a_i\\ge p,a_i\\leftarrow q∀ai​≥p,ai​←q。 如果 ma&lt;pma&lt;pma&lt;p，那么这个区间不会动；如果 se&lt;p≤mase&lt;p\\le mase&lt;p≤ma，那么只有最大值会动；如果 p≤sep\\le sep≤se，那么递归处理。代码。 * [Ynoi2013] 对数据结构的爱 Portal. 考虑模拟这个过程。我们需要知道对于一段区间，到底会减去多少个 ppp。 搞一个数组 cic_ici​ 代表这段区间要减去 iii 个 ppp 的最小初始值，那么查询的时候直接二分就行。现在考虑如何计算 ccc 数组。 尝试枚举左儿子的 cxc_xcx​ 和右儿子的 cyc_ycy​ 来计算 cx+yc_{x+y}cx+y​，什么时候不能更新？cxc_xcx​ 的上界经过操作后依然小于 cyc_ycy​。 用 max⁡{cx,cy+x×p−sumls}\\max\\{c_x,c_y+x\\times p-sum_{ls}\\}max{cx​,cy​+x×p−sumls​} 更新 cx+yc_{x+y}cx+y​。由于 cx+1−cx≥pc_{x+1}-c_{x}\\ge pcx+1​−cx​≥p，因此直接双指针扫就行。 单次询问会拆成 log⁡\\loglog 个区间，每个区间用 log⁡\\loglog 时间二分，时间复杂度为 O(nlog⁡n+mlog⁡2n)O(n\\log n+m\\log^2 n)O(nlogn+mlog2n)。代码。 平衡树 其同样为二叉数据结构，满足所谓的“BST 性质”。 笔者通常使用 FHQ 来实现平衡树。 FHQ-Treap FHQ 利用分离与合并来进行维护，然后通过随机权值来保证平衡。 值得注意的是，如果采用指针实现，那么 FHQ 会很快，而且非常好写。大概像这样： struct Node &#123; int rnd; Node *ls, *rs; &#125; T[5000005]; Node* root; int tot; inline Node* newNode(int col, int l, int r) &#123; return &amp;(T[++tot] = Node(/*...*/)); &#125; 替罪羊树 替罪羊树是一种依靠重构操作维持平衡的重量平衡树。替罪羊树会在插入、删除操作时，检测途经的节点，若发现失衡，则将以该节点为根的子树重构。 首先，如前所述，我们需要判定一个节点是否应重构。为此我们引入一个比例常数 α\\alphaα（一般采用 0.70.70.7），若某节点的子节点大小占它本身大小的比例超过 α\\alphaα，则重构。 例题 相比于线段树，平衡树的题不是很多。 [HNOI2011] 括号修复 Portal. 修复一个括号序列的代价这样计算：设 ( = -1, ) = 1，前缀最大值为 aaa，后缀最小值为 bbb，代价是 ⌈a÷2⌉+⌈−b÷2⌉\\lceil a\\div 2\\rceil+\\lceil -b\\div 2\\rceil⌈a÷2⌉+⌈−b÷2⌉。然后直接使用平衡树维护即可。代码。 [ZJOI2006] 书架 Portal. 问题在于如何高效找到一个节点在平衡树上的位置（中序遍历的编号）。维护每一个节点的父亲，然后直接从这个节点的位置跳到根，维护中序遍历的位置。这之后直接乱做即可。代码。 * [POI2015] LOG Portal. 使用一棵维护权值的平衡树。在减 111 的过程中，大于等于 sss 的是随便用，剩下的只需要考虑它们的和是否够用即可（可以将后面的向前移来叠到 sss，这样保证一层中不会有来自同一个位置的数）。代码。 * [Luogu P3987] 我永远喜欢珂朵莉~ Portal. 一个数最多被除 log⁡\\loglog 次，那么可以暴力修改并使用 Fenwick 树查询，使用平衡树维护有因数 xxx 的数，每次修改时直接 DFS 分裂出的子树。时间复杂度 O(nd(V)+nlog⁡nlog⁡v+mlog⁡n)O(nd(V)+n\\log n\\log v+m\\log n)O(nd(V)+nlognlogv+mlogn)。代码。 对于数据加强版 [Ynoi2013] 大学，平衡树常数过大，不能通过。对于每一个约数采用一个并查集，开始时每个数都指向自己，删除时将当前数的父亲设置为下一个数。另外 STL vector 的常数过大，需要手写内存池。代码。 [CF702F] T-shirts Portal. 由于每个人的处理方式都是一样的，因此不如考虑每个物品对于人的贡献。那么不难对于人直接维护，然后打上个减标记。对于位置会改变的东西，直接暴力插入，这样只会发生 log⁡c\\log clogc 次，因此复杂度是对的。代码。 [Ynoi2011] 遥远的过去 Portal. 平衡树求出 aaa 的所有子串的哈希值，只需要支持删除一个元素，加入新元素前给以前的东西打一个标记即可。代码。 ** [Ynoi2015] 人人本着正义之名 Portal. 首先看一看操作 3∼63\\sim 63∼6 是个什么东西。 将 [l,r−1][l,r-1][l,r−1] 中的数 aia_iai​ 同时变为 aia_iai​ 与 ai+1a_{i+1}ai+1​ 按位或的值？简单，就是所有极长 000 段最右边一个 000 变成 111。 搞一个平衡树，打一个标记表示左右端点的移动量。只有两个问题： 如何保证区间极长？区间染色时向左右拓展一下即可。 如何保证没有空区间？区间数量是 O(n+m)O(n+m)O(n+m) 的，维护最短 01 区间长度，暴力找，然后将其左右区间合并即可。 本质上不难，但代码比较壮观，需要使用指针实现平衡树进行卡常，代码。 * [NOI2021] 密码箱 Portal. 我们需要用数据结构描述这些操作，考虑使用连分数表示 fff 的值： a0+1a1+1a2+⋯a_0+\\cfrac{1}{a_1+\\cfrac{1}{a_2+\\cdots}} a0​+a1​+a2​+⋯1​1​ 为了接下来方便操作，我们取其倒数进行计算。考虑其在合并时发生了什么，不难发现： a′b′=1ai+ab=bai×b+a\\frac{a&#x27;}{b&#x27;}=\\cfrac{1}{a_i+\\cfrac{a}{b}}=\\cfrac{b}{a_i\\times b + a} b′a′​=ai​+ba​1​=ai​×b+ab​ 那么这个操作就可以用矩阵来描述了： [a′b′]=[ab][011ai]\\begin{bmatrix} a&#x27; &amp; b&#x27; \\end{bmatrix} = \\begin{bmatrix} a &amp; b \\end{bmatrix} \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; a_i \\end{bmatrix} [a′​b′​]=[a​b​][01​1ai​​] 接下来要描述 W 和 E 操作。首先考虑 W 操作，可以构出 W 为 [1101]\\begin{bmatrix}1 &amp; 1 \\\\ 0 &amp; 1\\end{bmatrix}[10​11​]。 然后是 E 操作。当 ak&gt;1a_k&gt;1ak​&gt;1 时，不难发现其为 [0−112]\\begin{bmatrix} 0 &amp; -1 \\\\ 1 &amp; 2 \\end{bmatrix}[01​−12​]，实际上对 ak=1a_k=1ak​=1 也满足。 然后直接上平衡树维护即可。注意你的常数，代码。 * [湖北省队互测 2014] 没有人的算术 Portal. 为什么不好做？我们无法轻易比较这个东西。 只有 O(m)O(m)O(m) 个不同的数，考虑给每个数都赋一个实数权。维护一棵平衡树，每次插入一个 pair&lt;double, double&gt;，代表新的数的权值，和平衡树上的每个节点比较（节点存储它的 double 和它是由哪两个 double 组成的），节点的权值由动态标号而来，实际上是 (l+r)/2(l+r)/2(l+r)/2，代表着 dfn 序，而平衡树上的 dfn 序就代表着大小。这个 trick 也称为动态标号。 由于我们不知道插入的东西的大小无法分裂，而旋转的复杂度又无法保证（是子树大小的）。因此只能使用替罪羊树。 持久化数据结构 我们对于一个数据结构，想维护其所有的历史版本。这样的数据结构称为持久化数据结构。 部分持久化：版本序列是链式结构； 完全持久化：版本序列是树状结构； 可合并持久化：支持合并，也就是说版本是 DAG 结构。 但是在算法竞赛中，持久化最常见的作用是降维。 算法竞赛通常采用 Path Copy，也就是修改时新建节点的方式来实现持久化数据结构，要求数据结构是一棵有根树形态。 空间大盗扭曲了此处的空间。Fat Node 和 Node-splitting 不会出现在 NOI 复习中。 持久化线段树 采用动态开点线段树，修改时新建节点即可。 对于持久化线段树的区间修改操作，如果标记可以永久化，那么最好这样做，因为这样可以节省很多空间。否则需要下传标记，所有的下传的点都必须复制后再下传。 我们可以很方便地在多棵持久化线段树上同时进行二分，直接都加起来就行。 其它持久化数据结构 仿照持久化线段树的思路，其它非均摊复杂度数据结构也是可以持久化的。 持久化数组：通常利用持久化线段树来实现持久化数组，进而实现不能路径压缩的持久化并查集。 持久化 Trie：与持久化线段树原理大致相同，在新建节点的时候复制一下就行。同时应注意，我们可以简单地在多棵 Trie 上二分，直接都加起来就行。 持久化平衡树：通常情况下持久化 FHQ 足够应付大部分的问题，其余的也不太能见到。如果见到了区间平移之类的操作，那么大概率就是持久化平衡树，在分裂和合并的时候新建一下节点即可。直接复制随机权值是错的，应该按照树的大小作为依据按照概率进行合并。 例题 有些东西比较麻烦。 [THUSC2015] 异或运算 Portal. 将求第 kkk 大转化为 kkk 小，看一下 n=1n=1n=1 怎么做？对 YYY 建立持久化 01 Trie，然后拿着 X[1]X[1]X[1] 开始从高到低位开始贪心。答案的这一二进制位能取到 000 的个数如果小于 kkk，那么这一位就需要取 111，然后令 kkk 减去这个个数；否则这一位取 000。 发现 n,qn,qn,q 都不是很大，因此对于 n&gt;1n&gt;1n&gt;1 直接暴力扫一遍，把总和加起来跟 kkk 比即可。代码。 [CF1665E] MinimizOR Portal. 如何处理或的最小值呢？如果出现了两个以上的 000，那么这一位显然填 000；如果没有 000 出现，则填 111；有一个 000 呢？找到这个 000 的位置，让它自己往 000 走，同时搞两个儿子就好了。只会增加 log⁡\\loglog 次节点，时间复杂度为 O(nlog⁡2V)O(n\\log^2 V)O(nlog2V)。代码。 *【UNR #1】火车管理 Portal. 操作一和操作三可以简单地使用线段树维护。对于操作二，将线段树持久化，在染色时记录每个节点染的是哪一个版本的颜色，这样在回退时就可以查询染色的版本号，然后将其染成它上一个版本的颜色。 依然注意，持久化线段树的带标记下传区间修改空间常数很大，需至少开到平时的两倍。代码。 [CF1422F] Boring Queries Portal. 对序列建立一棵持久化线段树，将数质因数分解掉，然后在左端点乘上相应的逆元即可。代码。 嵌套数据结构 K-D Tree 可以解决高维空间上的矩形修改矩形查询问题，而树套树和 CDQ 分治的功能是等价的，通常只能解决单点修改矩形查询类问题。 树套树 正常的树状数组每个点维护的是一个数，如果改成维护一棵平衡树，那么就成了“树状数组套平衡树”。 不一定是手写数据结构的嵌套，有些时候存在一些类似于嵌套结构的题目。 这里通过几道简单的题来简单介绍一下树套树。 【模板】二逼平衡树（树套树） Portal. 如果使用线段树套平衡树，那么再查询排名为 kkk 的数的时候就需要在外层二分（平衡树上多树二分非常复杂），时间复杂度为 O(nlog⁡3n)O(n\\log^3 n)O(nlog3n)。代码。 *「C.E.L.U-02」苦涩 Portal. 建立一棵线段树，每个节点保存一个优先队列作为区间加的标记，并永久化（即当前节点的优先队列中的内容对它的儿子都有效）。删除时可以暴力遍历线段树，因为每一次添加只会添加一个拥有最大数值最大的颜色段，这样删除它的时间就会在 O(log⁡n)O(\\log n)O(logn) 级别。若 n,mn,mn,m 同阶，那么总时间复杂度为 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。代码。 [ZJOI2017] 树状数组 Portal. 方向反了是什么？变成了求后缀和！也就是说，但是整个东西求的是 Sr−1−Sl−2S_{r-1}-S_{l-2}Sr−1​−Sl−2​。也就是说，要求 vr=vl−1v_r=v_{l-1}vr​=vl−1​ 的概率。那么可以视作区间修改，单点查询。 使用二维线段树，外层维护 lll，内层维护 rrr，新的概率是很好求的，注意 l=1l=1l=1 时只需要注意 rrr 的变化情况，直接维护即可。代码。 K-D Tree 时间旅人逆转了此处的时间。我们会在必要时补充这部分的内容。 K-D Tree 具有二叉搜索树的结构，每个节点都对应了 kkk 维空间上的一个点。 为了保证 K-D Tree 的树高， 简单树形问题 对于树上问题有基本的处理方法，比如 LCA、树形 DP、树上差分等，在此不做赘述。 常见树形问题处理手段： 树形 DP； 直径重心及其性质； 树上链信息维护，差分、重链剖分、树上倍增； 树上路径信息统计：树分治； 线段树合并、两种树上启发式合并； 离线，挂信息到节点上。 DFS 搜索树的性质：只存在返祖边，不存在横叉边。 笛卡尔树 笛卡尔树是一种特殊的 Treap，其节点权值不再是随机的，而是给定的。每个节点的权值用 (xi,yi)(x_i,y_i)(xi​,yi​) 表示，只考虑 xxx 时它是 BST，只考虑 yyy 时它是堆（此处以小根堆为例）。 在 xxx 递增时，我们可以以线性复杂度建出笛卡尔树。插入新节点时，为了保证 xxx 的性质满足，要将 xxx 插入到尽量右的地方。 具体来讲，维护一个从根节点一直走到右儿子的链。设当前需要插入 uuu，则需要找到第一个 yv&gt;yuy_v&gt;y_uyv​&gt;yu​，将 vvv 的右儿子设为 uuu（不存在则将 uuu 设为根），如果 vvv 原本有右子树，则将 vvv 的右子树改连在 uuu 的左子树下面来满足 BST 性质。使用单调栈维护此链，时间复杂度为 O(n)O(n)O(n)。 模板题核心代码如下： for (int i = 1, tot = 0, cur = 0; i &lt;= n; ++i) &#123; scanf(\"%d\", p + i); cur = tot; while (cur &amp;&amp; p[st[cur]] > p[i]) --cur; if (cur) rs[st[cur]] = i; if (cur &lt; tot) ls[i] = st[cur + 1]; // 放到左节点以满足 BST 性质 st[++cur] = i; tot = cur; &#125; 性质：如果节点编号 1∼n1\\sim n1∼n 为 BST 权值，然后点权满足小根堆性质，那么 min⁡{ax,⋯ ,ay}=aLCA⁡(x,y)\\min\\{a_x,\\cdots,a_y\\}=a_{\\operatorname{LCA}(x,y)}min{ax​,⋯,ay​}=aLCA(x,y)​。 树链剖分 我们对于链上的问题更为熟悉，因此在遇到树上问题时，可以考虑使用树链剖分将其转为链上问题再进行求解。常见类型有两种： 重链剖分。最为传统的形式，最常用于将树剖成 O(log⁡n)O(\\log n)O(logn) 条链。一个比较好的性质是，每次选择重儿子跳，那么树的规模都会减小一半。 我们在处理某些问题时，可以选择只考虑当前节点轻儿子的答案，这样在重链上修改 O(log⁡n)O(\\log n)O(logn)，只有 O(log⁡n)O(\\log n)O(logn) 个节点的答案会重新计算。 长链剖分。在处理与深度相关的问题时可能有奇效（实现启发式合并），但是基于长链剖分实现的 O(1)O(1)O(1) K 级祖先甚至打不过暴力跳的重链剖分！ 例题 比较杂。 * [CF1580D] Subsequence Portal. 先来看一下要求的这个东西： 原式=∑i=1m(m⋅abi)−∑i=1m∑j=1mf(min⁡(bi,bj),max⁡(bi,bj))=(m−1)∑i=1mabi−2∑i=1m∑j=i+1mmin⁡{abi,abi+1⋯ ,abj−1,abj}\\begin{aligned} \\text{原式}&amp;=\\sum_{i = 1}^m (m \\cdot a_{b_i}) - \\sum_{i = 1}^m \\sum_{j = 1}^m f(\\min(b_i, b_j), \\max(b_i, b_j))\\\\ &amp;=(m-1)\\sum_{i = 1}^m a_{b_i}-2\\sum_{i=1}^m\\sum_{j=i+1}^m \\min\\{a_{b_i},a_{b_i+1}\\cdots,a_{b_j-1},a_{b_j}\\} \\end{aligned} 原式​=i=1∑m​(m⋅abi​​)−i=1∑m​j=1∑m​f(min(bi​,bj​),max(bi​,bj​))=(m−1)i=1∑m​abi​​−2i=1∑m​j=i+1∑m​min{abi​​,abi​+1​⋯,abj​−1​,abj​​}​ 要求这个东西的最大值，后面这个区间最小值可以考虑放到笛卡尔树上，然后用树形 DP 求解这个问题。 设 fx,kf_{x,k}fx,k​ 代表 xxx 中选择 kkk 个节点的最大价值，初始 fi,1=(m−1)aif_{i,1}=(m-1)a_ifi,1​=(m−1)ai​，然后转移是一个类似树形背包的过程： fx,i+j=max⁡{fx,i+fy,j−2×ax×i×j}f_{x,i+j}=\\max\\{f_{x,i}+f_{y,j}-2\\times a_x\\times i\\times j\\} fx,i+j​=max{fx,i​+fy,j​−2×ax​×i×j} 代码。 * [APIO2021] 封闭道路 Portal. 直接暴力树形 DP。设 fx,0/1f_{x,0/1}fx,0/1​ 代表 xxx 与父亲连接的边是否删除时，uuu 的子树中满足所有节点的度数 ≤lim\\le \\text{lim}≤lim 的最小代价。转移时，将边按照 fy,1+w−fy,0f_{y,1}+w-f_{y,0}fy,1​+w−fy,0​ 扔到堆里，然后选前 degx−limdeg_x -\\text{lim}degx​−lim 小的。这样当 degx≤limdeg_x\\le \\text{lim}degx​≤lim 时，就可以直接扔掉这个点（直接把 www 扔到 vvv 的堆里），每个点维护一个堆即可。代码。 [Ynoi2011] ODT Portal. 每个点维护一棵 Treap，然后只维护轻儿子的信息，修改 O(log⁡2n)O(\\log^2 n)O(log2n)，查询 O(log⁡n)O(\\log n)O(logn)，可以维护若干个重儿子来平衡，但没必要。代码。 [CF536E] Tavas on the Path Portal. 考虑给定 01 边权怎么做，线段树上维护前后缀 111 段长度和答案，怎么都能和并，有限制的话直接按照边权排序依次加入即可。时间复杂度 O(qlog⁡2n+n)O(q\\log^2 n+n)O(qlog2n+n)，代码。 * [CF526G] Spiders Evil Plan Portal. 首先 kkk 条路径可以覆盖 2k2k2k 叶子的树。也就是说，选择 yyy 个点就是能选择 2y2y2y 个叶子，然后极小连通块的边权和尽量大。 以 xxx 为根时如何选择叶子呢？考虑进行一次长链剖分，那么 xxx 所在的长链的叶子也一定选择了，然后按照边权排序贪心即可。 多次询问怎么办？由于树上经过 xxx 的最长链一定经过直径的某一端，那么以直径的两个端点分别做一次长链剖分，然后要想办法将 xxx 加入连通块，如果一开始没有满足，那么只有两种方法： 将贡献最小的长链去掉，然后加入 xxx 所在长链； 找到离 xxx 最近长链的下半部分并替换。 倍增跳长链即可。代码。 树分治 树分治常用来被解决路径统计问题。一般情况下什么分治好写，就用什么就可以了。 静态点分治 树的点分治每次找一个重心，然后统计经过重心的路径，然后把这个点删去，树变成了很多连通子图，递归下去计算。 模板。给定一棵边带权的树，多次询问树上距离为 kkk 的点是否存在。 我们先任意选择一个节点作为根节点 rootrootroot（显然重心比较好），所有完全位于其子树中的路径可以分为： 不经过当前根节点的路径； 经过当前根节点的路径，又可以分为两种： 以根节点为一个端点的路径； 跨越根节点的路径，实际上是有两条以一个根节点为端点的路径合并而成，分治的时候只需要合并这种信息。 找到重心 rrr 作为分治中心，打上删除标记，并 dfs 它的每一棵子树。求出子树内每个节点到分治重心的距离和来源于哪个儿子的子树，统一存在一个 vector 里，使用双指针来合并答案（注意只能合并不同的子树）。 离线统一处理可以将时间复杂度降低为 O(nlog⁡n(m+log⁡n))O(n\\log n(m+\\log n))O(nlogn(m+logn))，正常单次点分治的时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。代码。 静态边分治 每次找到一条边，然后统计经过这条边的路径。但是菊花图时的复杂度会直接爆炸，为此我们需要对树进行三度化。 对于度数比 333 大的节点，可以通过加虚点（加上去不会改变信息的点）的方式来将树的节点度数改掉。类似于下图的方式： 静态链分治 使用树链剖分的结构，每次将一条链的信息进行合并。也就是所谓的“树上启发式合并”。根据情况使用重链剖分或长链剖分实现。 [CF1009F] Dominant Indices.设 d(u,x)d(u,x)d(u,x) 为 uuu 子树中到 uuu 距离为 xxx 的节点个数，对于每个节点求一个最小的 kkk，使得 d(u,k)d(u,k)d(u,k) 最大。 我们只关心每个节点内深度为 jjj 的节点个数，那么深度相同的节点是等价的。设 fi,jf_{i,j}fi,j​ 表示子树 iii 内深度为 jjj 的节点个数，则 fi,j=∑k∈son(i)fk,j−1f_{i,j}=\\sum_{k\\in son(i)}f_{k,j-1}fi,j​=∑k∈son(i)​fk,j−1​。 考虑长链剖分优化：对于重儿子，直接继承它的答案。然后合并轻儿子的答案，每个节点最多被合并一次。 因为所有点的深度之和加起来是 O(n)O(n)O(n)，因此时间复杂度线性。代码。 动态树分治 例题 本质还是分治，主要问题在于思考如何合并。 [JOISC2020] 首都 Portal. 要求的是一个含有颜色数最小的连通块，然后连通块内的颜色和块外两两不同，点分治暴力更新即可。代码。 [Ynoi2013] 成都七中 Portal. 先转化要查询的信息：点 ppp 到 xxx 的路径上的点的编号在 [l,r][l,r][l,r]，有多少种颜色。 直接点分治下去，一个询问第一次统计在合法路径能覆盖到它的时候，然后二维数点。时间复杂度 O((n+m)log⁡2n)O((n+m)\\log^2 n)O((n+m)log2n)。代码。 其它树上问题 树上问题还有一些其它结构，这里记录了几个常用的。 虚树 动态树 死灵法师抹除了此处的灵魂。本部分将不会在 NOI2024 前更新。因为某种原因决定更新。Top Tree 和其相关内容将会在很久的以后更新在某处，ETT 则不知道会放在什么地方（也许自己看看就完了）。这里只介绍 LCT。 我们使用数据结构维护树上结构，但是对于动态树问题，我们不能简单地通过重链剖分来完成这个东西。 对于一个点连向它所有儿子的边，我们自己选择一条边进行剖分，我们称被选择的边为实边，其他边则为虚边。对于实边，我们称它所连接的儿子为实儿子。对于一条由实边组成的链，我们同样称之为实链，可以采用 Splay 来维护这些实链。 LCT 是用一些 Splay 来维护动态的树链剖分，我们将其成为“辅助树”。 例题 还有一些出现在树上的问题，但是说不太清它们到底是什么题。 [Ynoi ER2022] 虚空处刑 Portal. 首先，树上邻域信息一定只能维护子树的信息，否则单点修改会导致所有儿子都需要修改，复杂度直接爆炸。 令 Ci,jC_{i,j}Ci,j​ 表示 iii 点所在子树范围内的连通块的 jjj 色连通块序列，修改时直接启发式合并，只需要更新 Cfax,yC_{fa_x,y}Cfax​,y​ 即可。大概是双 log⁡\\loglog 的，代码。 其它数据结构 除了之前介绍的数据结构之外，还有一些比较常用的数据结构。 左偏树 左偏树是一种可并堆，其合并的时间复杂度为优秀的 O(log⁡n)O(\\log n)O(logn)。得益于合并操作，删除根节点的操作也变得非常方便：只需要合并左右子树即可。 模板。每个点维护对应的左右子树和根节点，合并时考虑将 vvv 全部接到 uuu 的右子树，然后保证左子树比右子树深度大（左偏），用右子树的深度更新当前点的深度。删除之后记得将左右子树和根节点根都赋成左右子树合并的结果。代码。 实践中可以直接采用 pbds 的可并堆。 常见维护模型 对于序列上的问题有一些常见的处理手段。除了在 线段树 一节中提到的扫描线之外，还有一些模型非常经典（也许真的不是那么经典）。 支配对 一些题目让我们求“最优点对”之类的东西，可能有 O(n2)O(n^2)O(n2) 个，但实际上有效的并没有那么多，那么通用解法就是只维护可能成为答案的点对。根据情况不同，可以优化成 O(n),O(nlog⁡n)O(n),O(n\\log n)O(n),O(nlogn) 等个数，可以使用数据结构统计。 大致分为两种：本质不同的点对只有 O(n)O(n)O(n) 个，比如 LCA 只有这么多；贡献不同的有 O(n2)O(n^2)O(n2) 个，常见于 min⁡,max⁡\\min,\\maxmin,max 等问题。 [Luogu P6617] 查找 Search Portal. 定义一下两种关系： “补”表示与数 xxx 相加为 www。 “等”表示与数 xxx 相等。 记录每个数的补前驱，然后用线段树查询区间内补前驱的最大编号？当然可以，但是 1 5 5 5 5 5 这种修改 111 就可以直接炸掉：后面所有数的补前驱都将会变动。 令一个数的补前驱可以被记录，当且仅当它补前驱的位置在它等前驱右边，否则记录为 000。不难发现这样依次修改最多只会影响 555 个数：自身、原来 axa_xax​ 的补后驱和等后驱、yyy 的补后驱和等后驱。使用 set 加线段树维护即可。代码。 [Ynoi2010] y-fast trie Portal. 加入集合时将 xxx 取模，然后对于两个答案数 i,ji,ji,j 分类讨论： C≥i+j&lt;2CC\\ge i+j&lt;2CC≥i+j&lt;2C，这样只需要维护集合的最大和次大值即可。 0≤i+j&lt;C0\\le i+j&lt;C0≤i+j&lt;C，我们讨论这种情况。 称一个数 iii 在集合中满足 i+j&lt;Ci+j&lt;Ci+j&lt;C 的最大数 jjj 是 iii 的最优匹配，我们需要实现一个可以求出 iii 的匹配的函数，并且能够向它指定是否不能匹配到自身。 一个数的改变可能会影响 O(n)O(n)O(n) 个匹配。我们需要删去一些无用的匹配，让需要修改的匹配个数控制在 O(1)O(1)O(1) 级别。比如 xxx 的最优匹配是 yyy，而 yyy 的最优匹配是 zzz，有 z≥xz\\ge xz≥x，那么 xxx 加入时就不需要修改 yyy 的最优匹配，因为现有的答案 y+zy+zy+z 一定比 x+yx+yx+y 大，进而 y,zy,zy,z 必须双向互为最优匹配这个答案才需要被删除（x,yx,yx,y 变成双向匹配了），但是 x+yx+yx+y 一定要被插入。 删除 xxx 时，x+yx+yx+y 一定要被删除，如果 y,zy,zy,z 互为最优匹配需要将 y+zy+zy+z 插入回来。代码。 [CF765F] Souvenirs Portal. 扫描线扫右端点。绝对值不好处理，拆成 j&lt;i,aj≥aij&lt;i,a_j\\ge a_ij&lt;i,aj​≥ai​，值域翻转之后再做一遍即可。 考虑 aia_iai​ 会对哪些 jjj 产生贡献，每次找出 ≥ai\\ge a_i≥ai​ 的最大 jjj，此时新增的候选答案为 aj−aia_j-a_iaj​−ai​，下一个满足的是 k&lt;j,ak≥ai,ak−ai&lt;aj−aik&lt;j,a_k\\ge a_i,a_k-a_i&lt;a_j-a_ik&lt;j,ak​≥ai​,ak​−ai​&lt;aj​−ai​，也就是说 ai≤ak&lt;ai+aj2a_i\\le a_k&lt; \\cfrac{a_i+a_j}{2}ai​≤ak​&lt;2ai​+aj​​。因此查询次数在 O(log⁡V)O(\\log V)O(logV) 次，满足条件的 kkk 可以使用线段树求出。 树状数组维护后缀 min⁡\\minmin 即可求出答案。代码。 * [Ynoi2006] rldcot Portal. 由于 LCA 只有 O(n)O(n)O(n) 个，因此可以想到对 LCA 进行统计。 题车 对于对应的组别来说，中档题会附带一个星号，难题会附带两个星号。 刷基础 1 序列维护。 * [NOI2010] 超级钢琴 Portal. 考虑子段的和是什么。对于同一个左端点，要在合法范围内取一个前缀和最大的右端点，那么只需要在优先队列里存储 O(n)O(n)O(n) 个元素即可代表所有的子段。代码。 [CF1000F] One Occurrence Portal。按右端点排序，然后依次加入每个数，线段树维护贡献位置。代码。 * [CF115E] Linear Kingdom Races Portal。设 fif_ifi​ 代表考虑前 iii 条道路的最大价值，线段树的第 jjj 个节点维护当 j+1j+1j+1 以后节点全部修好，其余不做考虑的价值，这样每一个比赛都是区间加操作。代码。 * [国家集训队] 等差子序列 Portal。我们依次扫描每个 iii，要求 iii 之前 ai−ka_i-kai​−k 出现，ai+ka_i+kai​+k 不出现，也就是 aia_iai​ 为中心的不为回文串，线段树维护哈希即可。代码。 *【模板】区间后继 Portal。离线，权值线段树维护每个权值出现的最大下标，线段树上的查询最多只会查两条链。代码。另一种做法是按照 kkk 离线，废掉比 kkk 小的元素，然后区间查询最小值即可。 * [CF811E] Vladik and Entertaining Flags Portal。看到 n≤10n\\le 10n≤10 和区间查询不难想到线段树，初始假设所有点都不在一个连通块内，然后合并两段区间时暴力并查集合并即可。代码。 * [Ynoi2015] 我回来了 Portal. 考虑对于每一个可能的 ddd 分别考虑。对于一个亵渎伤害 ddd，依次判断是否存在血量为 [1,d],[d+1,2d],⋯ ,[d×⌊nd⌋+1,n][1,d],[d+1,2d],\\cdots,\\left[d\\times \\left\\lfloor\\dfrac n d \\right\\rfloor +1,n\\right][1,d],[d+1,2d],⋯,[d×⌊dn​⌋+1,n] 的随从。 离线，处理出 ST 表求出 td,it_{d,i}td,i​ 代表伤害为 ddd 的亵渎的第 iii 段区间最早出现随从的时间。对 ttt 做一次前缀 max⁡\\maxmax 即可求出亵渎触发的时间，树状数组维护即可。注意初始必定触发一次亵渎。代码。 [CF19D] Points Portal。对于 xxx 坐标建立线段树维护 yyy 坐标的最大值，每个 xxx 开一个 set 来记录这里面的 yyy 坐标，然后直接做就行，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。代码。 *【UR #19】前进四 Portal. 在线可以直接楼房重建，但是这里过不去一点。 扫描线维护序列维，数据结构维护时间维。线段树上的值代表当前的后缀最小值，扫描线从后往前扫，假定当前枚举到了 xxx，它的值是 vvv，存在时间是 [l,r][l,r][l,r]，则让 [l,r][l,r][l,r] 中的数都对 vvv 取 min⁡\\minmin，SGT Beats 维护即可。代码。 [CF484E] Sign on Fence Portal。先二分做掉，然后对于每个值建立主席树，查询时查询区间的最长连续 111 子段的长度是否小于等于 kkk 即可。代码。 [SP1557] GSS2 Portal。扫描线扫右端点，Beats 维护当前每个 lll 对应的 [l,r][l,r][l,r] 的和，求出历史最大值即可。代码。 刷基础 2 树上问题。 [SDOI2016] 游戏 Portal。树剖，然后李超线段树维护。如何支持区间查询？额外维护一个区间对应的最小值即可。代码。 [NOIP2012 提高组] 疫情控制 Portal。优先考虑二分，然后在允许时间内尽可能将军队往上提，剩余的还能越过根节点再下来的需要单独记录，贪心即可。代码。 [XXI Open Cup, GP of Korea] Query On A Tree 17 Portal. 首先是最小深度重心的性质，子树权值和一定严格大于所有点权值和的一半。 写 DFS 序，第 iii 个数写 aia_iai​ 次，最中间的数一定是子树里的，倍增跳父亲即可。代码。 刷提升 1 逐渐开始变得有意思起来了，请做好战斗准备！ [Ynoi2015] 即便看不到未来 Portal. kkk 比较小，因此我们先考虑只有一个 kkk 的时候怎么做。 对值域的统计容易想到离线，考虑扫描线维护右端点，数据结构维护左端点。由于 kkk 实在很小，我们甚至可以对一个元素扫它前后 kkk 个数来统计。 维护每一个数的最后一次出现。当扫到了一个 ar=xa_r=xar​=x，考虑 xxx 的出现会对极长值域连续段的长度产生什么影响。考虑找出 [x−9,x+9][x-9,x+9][x−9,x+9] 最后出现的位置，按照位置从大到小排序。如果询问的 lll 位于 x−1x-1x−1 之前，那么 x−1x-1x−1 就可以被计入极长值域连续段中。注意所有计算的 lll 应该在 xxx 上一次出现的位置之后，因为这样才能保证 xxx 是新加入的。 在 […,x−1][\\dots,x-1][…,x−1] 的序列计入极长值域连续段时，由于 xxx 的加入，这一个极长值域连续段要被撤销。整体的过程是一个区间修改单点查询的过程，树状数组可以很方便地维护。 由于我们要统计的最长是 [x−10,x−1][x-10,x-1][x−10,x−1] 这一段的极长，因此整体要扫到 [x−11,x+11][x-11,x+11][x−11,x+11] 才能统计全部的影响。时间复杂度 O(k(n+m)log⁡n)O(k(n+m)\\log n)O(k(n+m)logn)。代码。 [IOI2021] 分糖果 Portal. 如果上界一样，那么直接吉司机线段树。 题目几乎直接告诉了我们在线做不了。扫描线维护序列维，数据结构维护操作序列，然后不会。 套路地，主动弱化题目条件。考虑没上界怎么做，发现只需要二分最后一个最小前缀和小于 000 的位置，然后操作序列后缀和就是答案。 然后是有上界，如果碰到了上界，那么 c,0c,0c,0 之间的变化一定是这段操作序列的前缀最大和减前缀最小的值大于 ccc。 线段树二分找到最右的左端点后，它一定是最后一次碰界的一次，根据其值判断是碰下界还是碰上界，然后不难计算出正确的后缀和。 线段树维护区间前缀最大最小值和区间和即可。代码。 * [CF1083D] The Fair Nut’s getting crazy Portal. 枚举两个子段相交的部分，然后尝试统计答案。设 prei,nxtipre_i,nxt_iprei​,nxti​ 代表 aia_iai​ 上一次和下一次出现的位置，则答案为： ∑l=1n∑r=lnmax⁡{0,l−maxpre⁡(l,r)−1}×max⁡{0,minnxt⁡(l,r)−r−1}\\sum_{l=1}^{n}\\sum_{r=l}^{n}\\max\\{0,l-\\operatorname{maxpre}(l,r)-1\\}\\times \\max\\{0,\\operatorname{minnxt}(l,r)-r-1\\} l=1∑n​r=l∑n​max{0,l−maxpre(l,r)−1}×max{0,minnxt(l,r)−r−1} 枚举 lll，maxpre⁡(l,r)\\operatorname{maxpre}(l,r)maxpre(l,r) 单调不降，minnxt⁡(l,r)\\operatorname{minnxt}(l,r)minnxt(l,r) 单调不升，于是双指针扫 rrr 即可。记 f(l,r)=maxpre⁡(l,r)+1f(l,r)=\\operatorname{maxpre}(l,r)+1f(l,r)=maxpre(l,r)+1，g(l,r)=minnxt⁡(l,r)−1g(l,r)=\\operatorname{minnxt}(l,r)-1g(l,r)=minnxt(l,r)−1。一个 lll 可以找到最大的 rrr 使得 [l,l],[l,l+1],⋯ ,[l,r][l,l],[l,l+1],\\cdots,[l,r][l,l],[l,l+1],⋯,[l,r] 被计入答案，现在的问题是计算： ∑i=lr(l−f(l,i))×(g(l,i)−i)=∑i=lrl×g(l,i)+i×f(l,i)−f(l,i)g(l,i)−l×i\\begin{aligned} {} &amp; \\sum_{i=l}^r (l-f(l,i)) \\times(g(l,i)-i)\\\\ = &amp; \\sum_{i=l}^r l\\times g(l,i)+i\\times f(l,i)-f(l,i)g(l,i)-l\\times i \\end{aligned} =​i=l∑r​(l−f(l,i))×(g(l,i)−i)i=l∑r​l×g(l,i)+i×f(l,i)−f(l,i)g(l,i)−l×i​ 线段树维护当前左端点下 f,gf,gf,g 以及相关信息，倒序枚举 lll，这样变成了加入信息。由于 f,gf,gf,g 是存在单调性的，每次实际被修改的实际上是连续的一段，所以没必要直接上 Beats。以 fff 为例，找到 prei&gt;prel,i&gt;lpre_i&gt;pre_l,i&gt;lprei​&gt;prel​,i&gt;l 的最小 iii，[l,i)[l,i)[l,i) 染成 prelpre_lprel​，单调栈找出这个位置即可。代码。 [CF1572F] Stations Portal. 每个广播站能向它右面连续的一段区间 [i,ri][i,r_i][i,ri​] 传播消息，修改时 hih_ihi​ 变成最高的，也就是令 rci←gir_{c_i}\\leftarrow g_irci​​←gi​，对于 cic_ici​ 左边的位置 jjj，应该令 rj←min⁡{rj,i−1}r_j\\leftarrow \\min\\{r_j,i-1\\}rj​←min{rj​,i−1}。也就是说，rrr 可以直接 SGT Beats 维护。修改 rrr 时可以统计 bbb 的贡献，是一个区间修改区间查询的问题，树状数组维护二阶前缀和即可。代码。 [CF1368G] Shifting Dominoes Portal. 将图进行黑白染色，然后我们根据一个骨牌，将其移动视作空格移动。移动前后满足黑白颜色不变，那么进行连边，可以连成一个外向树森林。最后我们只需要求空格的位置，扫描线维护矩形面积并即可。代码。 刷提升 2 树上数据结构综合。 [CF1017G] The Tree Portal. 对于操作 111，我们单点加 111。如果所有点权初始为 −1-1−1，那么询问相当于到根的最大后缀和是否 ≥0\\ge 0≥0。 对于操作 222，只需要将子树内部的权值赋值成 −1-1−1，然后在 xxx 处打一个清除贡献标记即可。代码。 [集训队互测 2021] 关于因为与去年互测…… Portal. 求的是 AND，所以把最大值搞出就行了。线段树每个节点开一个 vector 从大到小存储所有的值，询问的时候贪心就好了。代码。 [省选联考 2023] 人员调度 Portal. 48 分直接维护子树内的前 sizsizsiz 大即可。 删除的话套一层线段树分治就可以了，现在想一想怎么加入。 考虑模拟反悔贪心，找到 xxx 的祖先中深度最深的满足 s(u)=siz⁡us(u)=\\operatorname{siz}_us(u)=sizu​ 的 uuu，然后替换子树内的最小值。 树剖线段树维护每个节点的 sizu⁡− s(u)\\operatorname{siz_u}-\\ s(u)sizu​− s(u) 的最小值以及子树内的最小权值，直接替换即可。树剖线段树被卡常了，代码。 刷综合 一些 log⁡\\loglog 数据结构综合题。 [CTT2014] 玄学 Portal. 发现操作是具有结合律的。维护一棵长度为 mmm 的线段树，每个节点上开一个 vector 来存储 ≤i\\le i≤i 的耳机会执行的操作。合并的时候直接双指针合并，查询的时候二分即可。时间复杂度 O(qlog⁡2n)O(q\\log^2 n)O(qlog2n)，本质上是二进制分组思想的一种运用。代码。 [CF1515H] Phoenix and Bits Portal. 对于 333 操作直接打标记，对于 444 操作直接像线段树一样查询，操作 111 可以转化为操作 222。操作 222 相当于对左儿子进行操作 333 然后合并。那么直接做即可。 为了保证时间复杂度，应该这样做：如果可以用异或操作代替，那么代替，否则按照之前说的递归下去。 如果不能代替，说明底下需要合并的节点和能够代替的节点都更多。最多合并 O(nlog⁡C)O(n\\log C)O(nlogC) 个节点，时间复杂度 O(n+q)log⁡2CO(n+q)\\log^2 CO(n+q)log2C。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"另类做题记录（一）","slug":"default/做题记录/cf2023","date":"2023-06-28T00:00:00.000Z","updated":"2023-06-28T00:00:00.000Z","comments":true,"path":"539be67/","link":"","permalink":"https://james1badcreeper.github.io/539be67/","excerpt":"逆天的记录。","text":"逆天的记录。 PART I 不知道。 *1809. EDU 145 https://codeforces.com/contest/1809. E. Two Tanks 如果 c+dc+dc+d 固定，那么答案应该时随着 ccc 的增加先不变，再递增，最后又不变的顺序进行的，而且每次的差值只有 111。找出这两个位置即可。代码。 F. Traveling in Berland 如果当前位置油价是 111，那么肯定能加满就加满（会用完），222 的话能加多少加多少。设 fif_{i}fi​ 代表 iii 到下一个油价是 111 的位置的位置，sis_{i}si​ 代表代价，倍增这个过程即可。代码。 G. Prediction 对于一个合法的排列 ppp，删除 apia_{p_i}api​​ 最小的 pip_ipi​，新的 p′p&#x27;p′ 必定合法。 设 fif_{i}fi​ 代表填完 (i,n](i,n](i,n] 的方案数，初始 fn=1f_n=1fn​=1，考虑 aia_iai​ 填的位置： 不填在当前第一个位置，不影响后面元素的前缀 max⁡\\maxmax，fi−1←+fi(n−i)f_{i-1}\\stackrel{+}{\\leftarrow} f_{i}(n-i)fi−1​←+fi​(n−i)； 填在当前第一个位置。设 lstilst_ilsti​ 代表最大的 jjj 使得 ai−aj&gt;ka_i-a_j&gt;kai​−aj​&gt;k，那么 (lsti,i)(lst_i,i)(lsti​,i) 都需要出现在 iii 之前，则 i−lsti−1i-lst_i-1i−lsti​−1 需要填入 n−lsti−2n-lst_i-2n−lsti​−2 个位置（除了第一个）。 双指针求 lstlstlst，时间复杂度 O(n)O(n)O(n)。代码。 *1854. Div1 889 https://codeforces.com/contest/1854. B. Earn or Unlock 如果前 kkk 个能恰好被解锁，那么答案是 ∑i=1kai−(k−1)\\sum_{i=1}^k a_i - (k-1)∑i=1k​ai​−(k−1)。对于解锁情况可以使用 DP 来解决：设 fif_ifi​ 代表前缀 iii 是否恰好能被解锁，那么 fj+ai←fj(j≥i)f_{j+a_i}\\leftarrow f_j(j\\ge i)fj+ai​​←fj​(j≥i)，这个过程可以使用 bitset 加速。代码。 *1856. Div2 890 (Done) https://codeforces.com/contest/1856. C. To Become Max 没调出来，我是菜狗！ nnn 只有 100010001000，想的暴力一点，枚举最终成为答案的数 aia_iai​。一开始肯定要利用 ai+1a_{i+1}ai+1​ 让 aia_iai​ 变得尽可能大，这样的代价是最小的。当 ai&gt;ai+1a_i&gt;a_{i+1}ai​&gt;ai+1​ 时怎么办？利用 ai+2a_{i+2}ai+2​ 让 ai+1a_{i+1}ai+1​ 变大。 如果操作次数足够多，那么最终的序列肯定是形如 x,x−1,⋯ ,an+1,anx,x-1,\\cdots,a_n+1,a_nx,x−1,⋯,an​+1,an​ 的。也就是说，依次枚举 j∈[i+1,n]j\\in[i+1,n]j∈[i+1,n]，当 aj≥aj−1a_j\\ge a_{j-1}aj​≥aj−1​ 时，至多就可以让 aia_iai​ 变大 aj−aj−1+1a_j-a_{j-1}+1aj​−aj−1​+1，此时更新答案即可。如果不满足，aja_jaj​ 在后续的更新过程中肯定要变成 aj−1−1a_{j-1}-1aj−1​−1，否则无法使 aia_iai​ 变得更大，提前更新 aja_jaj​ 即可。代码。 D. More Wrong 看上去就很分治。当前点 rrr 在 [l,r][l,r][l,r] 中最大的充要条件是 Q(l,r−1)=Q(l,r)Q(l,r-1)=Q(l,r)Q(l,r−1)=Q(l,r)，根据此分治下去即可。代码。 E. PermuTree 只要更改子树内的权值分布，就可以达到贡献最大化，所以是个树上背包状物，可以通过 E1，代码。 对于 E2，我们要思考如何高效解决“把儿子大小构成的数集合分成差尽可能小的两部分”。子树中不同的 sizsizsiz 最多只有 n\\sqrt{n}n​ 种，二进制拆分掉保证物品个数不多于 log⁡n\\log nlogn 个，然后是可行性背包采用 bitset 优化，单次时间复杂度是 O(nnlog⁡nw)O\\left(\\cfrac{n\\sqrt{n}\\log n}{w}\\right)O(wnn​logn​) 的。 如何将其搬到树上？简单。如果存在一个重儿子，它比所有轻儿子都重，这样可以直接得出答案。否则会造成一个分治的效果，每次问题规模必定减半，时间复杂度为 O(nnlog⁡2nw)O\\left(\\cfrac{n\\sqrt{n}\\log^2 n}{w}\\right)O(wnn​log2n​)。实际效率非常高。代码。 *1859. Div2 892 https://codeforces.com/contest/1859. D. Andrey and Escape from Capygrad 只能跳到 [l,b][l,b][l,b]（否则没有意义），合并线段，二分查找。代码。 *1858. Div2 893 (Done) https://codeforces.com/contest/1858. D. Trees and Segments 考虑 O(n2)O(n^2)O(n2) DP 预处理出前后缀改 jjj 次得到的 000 的最大长度，然后枚举中间 111 的长度，双指针扫。代码。 E. Rollbacks 实际上这是个大暴力题。 set 记录所有数的位置，不同数的个数经典只维护最小位置数的贡献，删除操作直接将序列长度减掉但是保留序列，回滚直接回滚。代码。 *1860. EDU 153 https://codeforces.com/contest/1860. D. *1354. EDU 87 (Done) https://codeforces.com/contest/1354. C2. Not So Simple Polygon Embedding 大致思路是观察获得多边形的旋转度数，然后解三角形。代码。 D. Multiset 权值树状数组直接维护。代码。 E. Graph Coloring 二分图染色，然后背包判断可行性。代码。 F. Summoning Minions 必定是放满 k−1k-1k−1 张后，拿剩下的放完就扔（会产生 b×(k−1)b\\times (k-1)b×(k−1) 的贡献），最后再放一张。 放置顺序必定满足 bbb 递增（否则可以交换），然后根据此进行 DP：fi,jf_{i,j}fi,j​ 代表前 iii 张选 jjj 张不是用完就扔的。代码。 G. Find a Gift 如果知道其中 xxx 个是石头，那么就能用这 xxx 个去确定另外 xxx 个数当中有没有石头。先找到 111 个石头，然后从头开始倍增找到第一个没有石头的区间。要确定这段有石头的区间的第 111 个石头位置，可以二分。如何找到一个石头？不知道，采用随机化。随机找到一些位置，找到当中最重的，那么可以确定那个是石头。代码。 *1867. Div2 897 https://codeforces.com/contest/1867. D. Cyclic Operations 赛时结论假了一部分，只因！ 最后图大概形如一个内向基环树森林之类的东西，链上的可以一次满足 k−1k-1k−1 个，环的大小必须为 kkk。注意 k=1k=1k=1 的特判。代码。 PART II 本着题是用来刷的原则，我们从 ARC 4 题场，且有英文题面的开始。 进度可视化。 ARC 058 对远古 bot 来说，好难。 C. Iroha and Haiku Portal. 数据范围很小，因此考虑想得暴力一点。当后缀和超过 X+Y+ZX+Y+ZX+Y+Z 时，再记录就没有意义（因为好区间不可能再被选取到），这样直接状压后缀和序列（将后缀和中出现的数存储起来），便可以简单判断是否出现了好区间。 如果从满足条件的区间考虑，会发现一个序列不一定只有一个好区间，这样很容易导致算重。因此对答案取补集，考虑计算没有满足条件的子区间的方案数。 设 fi,jf_{i,j}fi,j​ 表示考虑序列前 iii 位，当前后缀和状压后为 jjj。转移时采用刷表法，枚举最后一个填的数，计算新的后缀和，如果满足条件便统计答案。代码。 D. 文字列大好きいろはちゃん Portal. 时间旅人逆转了此处的时间。太困难了！ ARC 059 这场怎么这么简单。 C. Children and Candies Portal. fi,jf_{i,j}fi,j​ 代表前 iii 个人分了 jjj 个糖果的答案，直接转移。代码。 D. バイナリハック Portal. 容易发现这是个骗子题，打的字符串是什么跟答案没有关系。设 fi,jf_{i,j}fi,j​ 代表 iii 次，那么可以打一个字符（贡献为 fi−1,max⁡{j−1,0}f_{i-1,\\max\\{j-1,0\\}}fi−1,max{j−1,0}​，j=0j=0j=0 时相当于打一个回车），撤回一个字符（贡献为 2×fi−1,j+12\\times f_{i-1,j+1}2×fi−1,j+1​，因为撤回的是什么没关系）。代码。 ARC 060 做这个东西上瘾。 B. Digit Sum Portal. 如果 b&lt;nb&lt;\\sqrt{n}b&lt;n​，直接枚举即可。否则 nnn 是 bbb 进制下的两位数，解不定方程即可。代码。 C. Tak and Hotels Portal. 倍增处理出能走到的最远位置。代码。 D. ??? 死灵法师抹除了此处的灵魂。这是一个字符串，以后再说。 ARC 061 阿巴阿巴阿巴。 C. すぬけ君の地下鉄旅行 Portal. 用同样颜色的边所连接成的连通块可以互相到达，不难想到建一个虚点，将这个联通块内的所有点向虚点连一个权值为 000 的边，由这个连通块切换到别的连通块都需要 111 的代价，因此虚点向连通块内所有点连权值为 111 的边。并查集加 01 BFS 就可以完成这个过程，应该是 O(mlog⁡m)O(m\\log m)O(mlogm) 的。代码。 D. 3人でカードゲーム Portal. 考虑构造双射，每一个方案可以映射到一个长度为 mmm 的序列，这个序列当中有 n1n_1n1​ 个 111，且第 mmm 位必定是 111。 枚举序列中不是 111 的个数 kkk，贡献系数为 3n2+n3−k3^{n_2+n_3-k}3n2​+n3​−k，那么答案为： (k+n1−1n1−1)∑k−n3≤i≤n2(ki)\\binom{k+n_1-1}{n_1-1}\\sum_{k-n_3\\le i\\le n_2} \\binom k i (n1​−1k+n1​−1​)k−n3​≤i≤n2​∑​(ik​) 后面的东西不可能直接计算，考虑增量法维护： S(k)=∑k−n3≤i≤n2(ki)=∑k−n3≤i≤n2(k−1i)+(k−1i−1)=∑k−n3≤i≤n2(k−1i)+∑k−1−n3≤i≤n2−1(k−1i)=S(k−1)−(k−1k−n3−1)+S(k−1)−(k−1n2)\\begin{aligned} S(k)&amp;=\\sum_{k-n_3\\le i\\le n_2} \\binom k i\\\\ &amp;=\\sum_{k-n_3\\le i\\le n_2} \\binom{k-1}{i}+\\binom{k-1}{i-1}\\\\ &amp;=\\sum_{k-n_3\\le i\\le n_2} \\binom{k-1}{i}+\\sum_{k-1-n_3\\le i\\le n_2-1} \\binom{k-1}{i}\\\\ &amp;=S(k-1)-\\binom{k-1}{k-n_3-1}+S(k-1)-\\binom{k-1}{n_2} \\end{aligned} S(k)​=k−n3​≤i≤n2​∑​(ik​)=k−n3​≤i≤n2​∑​(ik−1​)+(i−1k−1​)=k−n3​≤i≤n2​∑​(ik−1​)+k−1−n3​≤i≤n2​−1∑​(ik−1​)=S(k−1)−(k−n3​−1k−1​)+S(k−1)−(n2​k−1​)​ 然后就可以直接计算了，代码。 PART III 来源是 2015 集训队作业，实际上就是远古时期 CF 题。 第一组 呜呜呜。 [CF293B] Distinct Paths Portal. 要求所有路径上的颜色都不相同，路径长度最大为 kkk，而 kkk 最大只有 101010，所以这实际上是个大暴力题。 考虑枚举所有没涂色的格子的颜色，并状压经过的路上的颜色。但是这样状态数干到了 O((nm)k)O((nm)^k)O((nm)k) 的等级。 想一想为什么会算这么多。因为，我们计算了很多无用状态！所以： 如果还剩的颜色已经不能够填满接下来的路径，那么直接再见。 如果当前颜色是全局中唯一填的，那么填其它全局也没有出现的颜色是等效的，只需要算一次就可以了。 代码。 * [CF325E] The Red Button Portal. 真的挺妙的。 这是个什么？不知道。先打表找规律，然后发现 nnn 为奇数时无解。 然后呢？以下是 nnn 为偶数时暴力跑出的答案： 0 1 0 0 1 3 2 0 0 1 2 5 4 3 0 0 1 2 5 3 7 6 4 0 0 1 2 4 9 8 6 3 7 5 0 能看出什么吗？好像不能，那再从图上出发看看能不能发现点什么。 每个点的出度均为 222，要是 111 我直接欧拉路！诶可不可以通过特殊限制搞成 111 呢？还真能。 我们需要一个更好的代数形式来刻画每个点的出边。我们有： i×2≡(i+n2)×2(modn)i×2+1≡(i+n2)×2+1(modn)\\begin{aligned} i\\times 2\\equiv (i+\\frac n 2)\\times 2 \\pmod n \\\\ i\\times 2 + 1\\equiv (i+\\frac n 2)\\times 2 + 1 \\pmod n \\end{aligned} i×2≡(i+2n​)×2(modn)i×2+1≡(i+2n​)×2+1(modn)​ 也就是说 iii 和 i+n2i+\\frac n 2i+2n​ 所连的边应该是同一个东西。那这好办了，想要有答案必须一人分一个，那就随便。 然后答案成了什么状物？若干个环！我们需要合并它们。 如果图上有多个环，那么必定有一对等效点不在同一个环中，交换它们分的边即可合并环。 我们已经通过暴力验证了 nnn 为偶数时一定有解，所以这样一定可以合并所有的环（否则没得可走了）。代码。 [CF335D] Rectangles and Square Portal. 拼成的正方形的右上角一定是一个矩形的右上角，正方形的左下角一定是一个矩形的右下角。然后怎么限制？ 注意到所有矩形都不相交。这样我们可以用一些前缀和的方式直接判断一些内容。首先一定能铺满，其次正方形的边界一定由矩形的边界构成。这些都很好使用二维前缀和维护。 枚举正方形的右上角和在这条斜线上的合法左下角，时间复杂度 O(k2+n)O(k^2+n)O(k2+n)。代码。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"NOI 一轮复习 I：优化技巧","slug":"notes/NOI 复习/noi-1-1","date":"2023-04-30T00:00:00.000Z","updated":"2023-11-04T00:00:00.000Z","comments":true,"path":"48d03b22/","link":"","permalink":"https://james1badcreeper.github.io/48d03b22/","excerpt":"本文是 NOI 一轮复习的第一篇，包括无法归成大类的杂项算法。","text":"本文是 NOI 一轮复习的第一篇，包括无法归成大类的杂项算法。 更新日志 2023/11/04更新了本质不同子序列的个数，曼哈顿距离和切比雪夫距离的转化。2023/10/25文章大致完成。 不同于常规的学习笔记，这一部分的文章会略显简略，重点刻画知识之间的结构与逻辑，并保留经典例题，增加大量杂题，且题目实时更新。 二分与倍增 两者的本质均基于单调性，寻找题目中具有单调性的函数关系，然后施展二分或者倍增。二分答案可以用来解决分数规划问题，三分法可以求解单峰/谷函数。同时，二分上界不确定的内容的最佳方式是倍增，通过先倍增到上界，再倍增答案来解决。 ST 表 ST 表使用倍增结构来实现，支持在末尾插入一个数。大概长这样： f[0][n] = a[n]; for (int j = 1; 1 &lt;&lt; j &lt;= n; ++j) f[j][n - (1 &lt;&lt; j) + 1] = max(f[j - 1][n - (1 &lt;&lt; j) + 1], f[j - 1][n - (1 &lt;&lt; j - 1) + 1]); wqs 二分 学名带权二分。常用于 2D /1D 的 DP，状态的其中一维是物品个数。这是它的明显标志，因此它比较套路。fif_ifi​ 表示恰好（最多/至少）选取 iii 个物品时的答案，如果 fff 是凸函数那么则可以使用 wqs。我们可以猜测 O(nk)O(nk)O(nk) 过不去就是凸的，或者也可以打表。 由于 fff 是凸的，因此我们可以选择二分斜率，以此计算出它的切线。有时它能直接用，有时可以对 DP 进行降维，有时和斜率优化等内容一起出现。 具体来说，我们画出所有点 (i,f(i))(i,f(i))(i,f(i))，假设它们构成一个上凸壳。二分斜率 kkk，发现随着 kkk 的减小，直线的切点会越来越靠右。 因此二分 kkk 直到横坐标切到我们想要的位置（比如恰好选择 mmm 个数），那么此时的纵坐标就是答案了。 如何求出切点？我们希望这个切点的 yyy 坐标最大，也就是在 yyy 轴上的截距最大。设截距为 g(x)g(x)g(x)，那么切点 (x,f(x))(x,f(x))(x,f(x)) 在 yyy 轴上的截距就是 g(x)=f(x)−kxg(x)=f(x)-kxg(x)=f(x)−kx。问题就是如何求出 g(x)g(x)g(x) 的值了。 考虑 g(x)g(x)g(x) 的意义，相当于钦定的 xxx 个物品的代价都比原来少 kkk，g(x)g(x)g(x) 相当于每个物品代价减 kkk 之后的最优解。 l,rl,rl,r 如何调整？要逼近 (m,f(m))(m,f(m))(m,f(m)) 如果此时切点 (x,f(x))(x,f(x))(x,f(x)) 满足 x&lt;mx&lt;mx&lt;m 时，那么应该将斜率减小，才能让切点右移。 下凸壳大致是一样的。 [国家集训队] Tree I。给定一个无向连通图，求一棵恰好有 kkk 条白边的最小生成树。n≤5×104,m≤105,w≤100n\\le 5\\times 10^4,m\\le 10^5,w\\le 100n≤5×104,m≤105,w≤100。 设白边数量为 kkk 的最小生成树是 f(k)f(k)f(k)，那么 fff 是一个下凸函数（其实挺显然的）。直接 wqs 即可。 int n, m, need; struct edge &#123; int u, v, w, c; bool operator&lt; (const edge &amp;a) const &#123; if (w != a.w) return w &lt; a.w; return c &lt; a.c; &#125; &#125; a[100005]; int fa[50005], res; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; bool check(int x) &#123; for (int i = 1; i &lt;= m; ++i) if (a[i].c == 0) a[i].w -= x; sort(a + 1, a + m + 1); for (int i = 1; i &lt;= n; ++i) fa[i] = i; int wc = 0; res = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = find(a[i].u), v = find(a[i].v); if (u == v) continue; fa[u] = v; res += a[i].w; wc += (a[i].c == 0); &#125; for (int i = 1; i &lt;= m; ++i) if (a[i].c == 0) a[i].w += x; return wc >= need; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m >> need; for (int i = 1; i &lt;= m; ++i) cin >> a[i].u >> a[i].v >> a[i].w >> a[i].c, ++a[i].u, ++a[i].v; int L = -500, R = 500, ans; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) ans = res + need * mid, R = mid; else L = mid; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; 例题 虽然都是很简单的思想，但是两者能解决的问题不少，而且各有特点。 * [CF1661F] Teleporters Portal. 可以将原问题划分成几段，然后对于每一段放置传送器的话分的约均匀越好，全局的最小两相邻传送机距离应该是一个（尽可能满足平均），这样就可以用 f(x,k)f(x,k)f(x,k) 来表示 0→x0\\rightarrow x0→x 中额外插入 kkk 个的最小代价，显然是好求的。 直接二分需要安装的传送机数量？我们好像没有办法 check，只知道最多传送机数量的话没有一个合适的贪心策略。我们对另一个条件——总花费进行考虑。因为花费越大直接意味着传送机数量越少。 注意到 f(x,k−1)−f(x,k)f(x,k-1)-f(x,k)f(x,k−1)−f(x,k) 随着 kkk 的增大单调不增，这样可以在外层二分其值 vvv 来代表一个段内的最小传送机距离（类似 wqs 的思想），找出一个 f(x,k−1)−f(x,k)≥vf(x,k-1)-f(x,k)\\ge vf(x,k−1)−f(x,k)≥v 的最大 kkk，而 kkk 越大花费越小，直接利用 kkk 来进行贪心求出每一段的最小代价，与 mmm 比较来确定二分的答案。 设二分出来的答案是 kkk，选完之后 mmm 的值还有剩余，我们尽可能多的值选择 k+1k+1k+1 来榨干 mmm 的剩余价值。 时间复杂度 O(nlog⁡2V)O(n\\log^2 V)O(nlog2V)，代码。 我们发现，二分答案不仅需要有单调性，而且需要有一个贪心策略来 check，并不一定是直接二分最终的答案。当发现无法 check 时可以找找我们缺少了什么导致无法贪心，然后改为二分这个缺少的东西。 [ZJOI2018] 胖 Portal. 从 000 号点到达某一个点后，可以被更新的瞭望塔显然是一段连续的区间，这样我们就可以分别对左右端点进行二分。 设要从 ppp 更新，这条路的距离为 lll，到达第 xxx 个点，那么令 d=∣l−x∣d=|l-x|d=∣l−x∣，在 [x−d,x+d][x-d,x+d][x−d,x+d] 当中不应该存在距离小于 ppp 时距离的点。预处理出图上距离的前缀和 disdisdis，距离的最小值要分在 xxx 的左右讨论，在 xxx 左边时是 disx+(l−disp)dis_x+(l-dis_p)disx​+(l−disp​)，右边时是 −disx+(l+disp)-dis_x+(l+dis_p)−disx​+(l+disp​)，询问前 ST 表预处理两个信息即可求出距离的最小值（建立大小为 KKK 的 ST 表，询问的时候直接二分出左右端点的位置）。 注意距离相等时更新顺序的问题，二分右端点时要对 x+dx+dx+d 的位置做一个单独的讨论。代码。 ** [CF1764G] Doremy’s Perfect DS Class 这是一道非常精彩的题目。G1，G2，G3。给定一个 1∼n1\\sim n1∼n 的排列 ppp（n≤1024n \\le 1024n≤1024，注意 210=10242^{10}=1024210=1024），每次你可以询问 l,r,kl,r,kl,r,k，交互库会返回 ⌊plk⌋,⌊pl+1k⌋,⋯ ,⌊prk⌋\\left\\lfloor\\cfrac{p_l}k\\right\\rfloor,\\left\\lfloor\\cfrac{p_{l+1}}k\\right\\rfloor,\\cdots,\\left\\lfloor\\cfrac{p_r}k\\right\\rfloor⌊kpl​​⌋,⌊kpl+1​​⌋,⋯,⌊kpr​​⌋ 中不同数的个数，需要找到 111 的位置。交互次数分别限制在 30,25,2030,25,2030,25,20 次。 询问能告诉我们什么？好奇怪啊，不知道。尝试从给定的 kkk 值开始分析。k=1k=1k=1 没什么意义，然后尝试从特殊的，比如 k=2,nk=2,nk=2,n 开始分析。k=nk=nk=n 比较好说，只有 nnn 可以被记入答案，可以根据此找出 nnn 的位置。k=2k=2k=2 则可以将数分为两组，在 nnn 为奇数时只有 111 是单独一组，nnn 为偶数时只有 1,n1,n1,n 是单独一组。 从别的地方再想一想，都要求 log⁡\\loglog 级别的询问，不难想到二分。设 solve(l, r) 代表答案在 [l,r][l,r][l,r] 的位置中，我们需要确定 111 在 [l,mid][l,mid][l,mid] 还是 [mid+1,r][mid+1,r][mid+1,r] 里。咦，感觉不太对，不是严格的子问题！但是我们只需要寻找答案在哪里，因此只需要分别答案在 [1,mid][1,mid][1,mid] 还是 [mid+1,n][mid+1,n][mid+1,n] 就好了。 选择从 k=2k=2k=2 入手，x,yx,yx,y 分为一组仅当它们除以二下取整后的值相等。我们可以求出两个区间中在自己区间内没有匹配的数的数量，然后这个数量大的，答案就在那里（因为剩下的每有一个都是成对的）。 nnn 是偶数怎么办呢？我们只需要找到 nnn 就行，不难发现 k=nk=nk=n 可以很好的完成这个任务。当两个区间的值相等时，说明 1,n1,n1,n 各占一个，我们令 k=nk=nk=n，询问其中一个，看 nnn 是否在其中。找到 nnn 的位置之后发现之后的递归不会受到影响（如果 pn&gt;midp_n&gt; midpn​&gt;mid，我们会递归到 [l,mid][l,mid][l,mid]，必定有 pn&gt;mid′p_n&gt;mid&#x27;pn​&gt;mid′）。 这个做法可以通过 G2，代码。想过掉 G3，我们需要想方法杀掉那一次多余的询问。 怎么杀？对于 r−l+1=2r-l+1=2r−l+1=2 的情况，使用两次询问有点扯皮，我们看能不能只用一次询问杀掉它。核心思想是，充分利用我们之前问出来的信息。当我们递归到 [l,r][l,r][l,r] 时，曾令一个 mid=l−1mid=l-1mid=l−1，也令了一个 mid=rmid=rmid=r，因此我们知道 Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l-1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2) 的答案。现在 l,rl,rl,r 中一个是 111，一个是和其他数能匹配上的某个奇怪的东西，吗？注意，另一个可能是 nnn，如果我们还没有确定 nnn 的位置，那么通过询问 Q(r,n,n)Q(r,n,n)Q(r,n,n) 或 Q(1,l,n)Q(1,l,n)Q(1,l,n) 将其判掉。 现在再看怎么搞 l,rl,rl,r 一个是 111，另一个是可匹配数。可匹配数只能配在 [1,l−1][1,l-1][1,l−1] 或 [r+1,n][r+1,n][r+1,n]，如果 Q(1,l−1,2)+1=Q(1,r,2)Q(1,l-1,2)+1=Q(1,r,2)Q(1,l−1,2)+1=Q(1,r,2)，那么说明可匹配数的匹配数是开在 [1,l−1][1,l-1][1,l−1] 的（这个数除以二下去整的值与 [1,l−1][1,l-1][1,l−1] 中的某个数撞了），否则开在 [r+1,n][r+1,n][r+1,n]。确定了这一点之后，我们就可以锁定 111 的位置了！以开在 [1,l−1][1,l-1][1,l−1] 为例，如果 Q(1,l−1,2)=Q(1,l,2)Q(1,l-1,2)=Q(1,l,2)Q(1,l−1,2)=Q(1,l,2)，说明 lll 处开可匹配数，与 [1,l−1][1,l-1][1,l−1] 中的某个数匹配，111 就开在 rrr 处。 这样在 r−l+1=2r-l+1=2r−l+1=2 时我们只花费了一次询问，可以通过 G3。代码。 * 「Wdoi-2」死亡之后愈发愉悦 Portal. i+1i+1i+1 个可爱数连着 iii 个非可爱数。设 j(a)j(a)j(a) 代表 aaa 是否为可爱数。求出 j(a)=j(a+p)j(a)=j(a+p)j(a)=j(a+p) 的最大 ppp，j(a+p+1)=j(a+p+q)j(a+p+1)=j(a+p+q)j(a+p+1)=j(a+p+q) 的最大 qqq，则容易根据 p,q,j(a)p,q,j(a)p,q,j(a) 解出 aaa。 对于求解 p,qp,qp,q，考虑倍增。注意倍增时要先跳两个 202^020，这样保证每一次跳跃的长度不大于以前跳跃的长度，因为区间并不是严格单调的，这样防止跳出区间。 对于 qqq 的倍增并不需要从 000 开始，可以发现 p≤qp\\le qp≤q，因此可以直接先跳一个不超过 p−1p-1p−1 的数，代码。 [SCOI2016] 萌萌哒 Portal. 并查集？复杂度不对，考虑倍增并查集。使用类似于 ST 表的结构，操作时直接操作高层节点的并查集，处理完之后将高层内容下放，这样可以得到完整的答案。代码。 * [CF802O] April Fools’ Problem Portal. 关于题目个数的是一个下凸函数，而且斜率单调不降，可以采用 wqs 二分。 如何贪心 check？对于每个 bib_ibi​，找到之前没选过的 aja_jaj​，如果 aj+bi≤0a_j+b_i\\le 0aj​+bi​≤0 那么选择 aja_jaj​。让它支持反悔，可以顶替掉一个 bjb_jbj​，贡献为 bi−bjb_i-b_jbi​−bj​。代码。 分治 分治是将复杂的问题拆成多个（一般是两个）相似的子问题，直到最后分成的子问题可以简单求解，然后通过子问题的答案合并出大问题的答案。 仿照分治的结构可以衍生出一大堆静态分治算法。 普通分治 平面最近点对。求一个平面上最近的点对，点数在 10510^5105 级别。 先将所有点按照 xxx 坐标排序，然后开始分治。关键在于如何合并：如果一个点满足 ∣x[mid]−x[i]∣&lt;d|x[mid]-x[i]|&lt;d∣x[mid]−x[i]∣&lt;d，其中 ddd 代表左右两边答案的最小值，那么我们称点 iii 是合法的。然后将这些合法的点再按照 yyy 坐标排序，再进行枚举，yyy 坐标距离大于 ddd 就 break 掉。 这样可以保证合并的时间复杂度是 O(n)O(n)O(n) 的（需要采用归并排序），具体证明需要通过一些几何的方式，不打算研究。代码。 二维分治 其实就是对两个东西进行分治，每次将其中一个东西切半（为了保证效率，一般选择其中区间更长的一个切半），然后合并答案。 [CF364E] Empty Rectangles.给定一个 n×m(1≤n,m≤2.5×103)n\\times m(1\\le n, m\\le 2.5\\times 10^3)n×m(1≤n,m≤2.5×103) 的 01 矩阵，询问有多少个子矩阵满足只有 k(1≤k≤6)k(1\\le k\\le 6)k(1≤k≤6) 个 1。 本题要求恰好有 kkk 个 1 的子矩形数量，我们将当前矩形劈成两半（以劈成左一半和右一半为例），那么符合条件的子矩形要么在左半，要么在右半，要么跨越中线。 考虑跨越中线的如何合并。我们枚举子矩形的上下边界，然后开个桶 ppp 统计左半矩形所含 111 数量小于 iii 时左边界的最小值（右半矩形同理），然后直接枚举左半边的 111 的个数就可以统计了。代码。 CDQ 分治 树套树的本质作用是降维，但是如果允许离线，则可以使用 CDQ 分治高效地完成这个问题。 最重要的应用是解决三维偏序问题。分别处理三个信息。第一维可以将原数组按照 xxx 排序，xi≤xjx_i\\le x_jxi​≤xj​ 转化为 i&lt;ji&lt;ji&lt;j。注意此时如果数都相同会出问题，因此去个重。第二维可以在分治时采用类似于归并排序的方式解决（求正序对），不过由于第三维的限制，并不是所有的信息都可以加到答案里的，需要整一个权值树状数组来处理第三维的信息：左半段序列的信息加入树状数组，右半段信息进行统计。代码。 CDQ 分治的写法非常灵活，像三维偏序问题是对分治树进行后序遍历来统计答案的。对于一些 DP 问题，往往可以在中序遍历时统计前面一半对后面一半的影响。 高维 CDQ 分治。以 CDQ 套 CDQ 为例子，实际上也很简单，对于外层 CDQ 采用中序遍历计算来处理第一维偏序，然后对于 [l,r][l,r][l,r] 进行内层 CDQ。时间复杂度为 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)（内层只归并）。 以下是四个关键字的最长上升子序列的例子。 void CDQ2(int l, int r) &#123; if (l == r) return; int mid = l + r >> 1; CDQ2(l, mid); CDQ2(mid + 1, r); for (int i = l; i &lt;= mid; ++i) if (b[i].op == 0) b[i].op = 2; for (int i = mid + 1; i &lt;= r; ++i) if (b[i].op == 1) b[i].op = 3; sort(b + l, b + r + 1, cmp2); for (int i = l; i &lt;= r; ++i) &#123; if (b[i].op == 2) add(b[i].d, f[b[i].id]); else if (b[i].op == 3) f[b[i].id] = max(f[b[i].id], sum(b[i].d)), b[i].op = 1; &#125; for (int i = l; i &lt;= r; ++i) if (b[i].op == 2) clr(b[i].d), b[i].op = 0; &#125; void CDQ1(int l, int r) &#123; if (l == r) return f[a[l].id] += a[l].cnt, void(); int mid = l + r >> 1; CDQ1(l, mid); for (int i = l; i &lt;= r; ++i) b[i] = a[i]; for (int i = mid + 1; i &lt;= r; ++i) b[i].op = 1; sort(b + l, b + r + 1, cmp1); CDQ2(l, r); CDQ1(mid + 1, r); &#125; 整体二分 如果分治中遵循先递归左子树，再递归右子树的法则，那么维护一个指针去“跟踪”分治中心，这个指针的移动距离是 O(nlog⁡n)O(n\\log n)O(nlogn) 的。过程类似于将多次二分合并到一起进行，可以借此得到优秀的复杂度。 本身常数极小，解决区间 kkk 小问题的时间复杂度是 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)，但却跟主席树的 O(nlog⁡n)O(n\\log n)O(nlogn) 的速度差不多。 [CTSC2018] 混合果汁。较复杂，请参考原题面。 可以二分出美味度的答案，而又有多组询问，因此考虑整体二分。先加入一个美味度为 −1-1−1，可以无限买的免费果汁方便处理。将果汁按照美味度从大到小排序。 我们将美味度 ≤mid\\le mid≤mid 的果汁全部加入树状数组。对当前询问的分组需要二分出满足其体积限制的最小价格，只需要考虑比这个价格低的果汁一定要全买，不足的用价格等于这个的果汁补即可。 时间复杂度 O(nlog⁡3n)O(n\\log^3 n)O(nlog3n)，换成树状数组倍增可以做到 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)，代码。 线段树分治 按时间建立线段树，将操作覆盖到线段树上的点，那么处理一个时间的答案就是从叶子到根所有节点信息的并。利用可撤销数据结构可以通过在线段树上 DFS 即可得到每个时间的答案。 [CF576E] Painting Edges。给定一张 nnn 个点 mmm 条边的无向图。一共有 kkk 种颜色，一开始，每条边都没有颜色。定义合法状态为仅保留染成 kkk 种颜色中的任何一种颜色的边，图都是一张二分图。有 qqq 次操作，第 iii 次操作将第 eie_iei​ 条边的颜色染成 cic_ici​。但并不是每次操作都会被执行，只有当执行后仍然合法，才会执行本次操作。你需要判断每次操作是否会被执行。n,m,q≤5×105n,m,q \\le 5 \\times 10^5n,m,q≤5×105，k≤50k \\le 50k≤50。 使用 kkk 个可撤销并查集维护每一个颜色。但是如果答案是 NO 不执行此操作如何处理？ 线段树分治的特性是 1→q1\\rightarrow q1→q 依次处理，第 iii 次询问的生效区间是 [i+1,y−1][i+1,y-1][i+1,y−1]（yyy 代表下一次修改这条边的时间）。可以在每个叶子上再考虑是否满足二分图的条件（每个询问只会多一条边），然后不满足的话这个修改的颜色改为边当前的颜色。代码。 猫树分治 在分治时维护前后缀的信息，然后通过这些信息求出跨过分治中心的答案。 [Luogu P6240] 好吃的题目。多次询问区间 01 背包。n≤4×104,m≤2×105,W≤200n\\le 4\\times 10^4,m\\le 2\\times 10^5,W\\le 200n≤4×104,m≤2×105,W≤200。 考虑分治，对于 r≤midr\\le midr≤mid 的询问，划分到左边处理，对于 l&gt;midl&gt;midl&gt;mid 的询问，划分到右边处理，对于跨越 midmidmid 的询问，从 midmidmid 开始向左右遍历，合并背包即可。时间复杂度 O((nlog⁡n+q)t)O((n\\log n+ q)t)O((nlogn+q)t)。 int n, m, h[40005], w[40005]; struct Query &#123; int l, r, V; &#125; Q[200005]; int ans[200005], p[200005], T[200005]; int f[40005][205]; void solve(int l, int r, int ql, int qr) &#123; if (ql > qr) return; int mid = l + r >> 1; for (int i = 0; i &lt;= 200; ++i) f[mid][i] = 0; for (int i = mid + 1; i &lt;= r; ++i) &#123; for (int j = 0; j &lt; h[i]; ++j) f[i][j] = f[i - 1][j]; for (int j = h[i]; j &lt;= 200; ++j) f[i][j] = max(f[i - 1][j], f[i - 1][j - h[i]] + w[i]); &#125; for (int i = h[mid]; i &lt;= 200; ++i) f[mid][i] = w[mid]; for (int i = mid - 1; i >= l; --i) &#123; for (int j = 0; j &lt; h[i]; ++j) f[i][j] = f[i + 1][j]; for (int j = h[i]; j &lt;= 200; ++j) f[i][j] = max(f[i + 1][j], f[i + 1][j - h[i]] + w[i]); &#125; int qmid = ql - 1, tm = 0; for (int i = ql; i &lt;= qr; ++i) &#123; int id = p[i]; if (Q[id].r &lt;= mid) p[++qmid] = id; else if (Q[id].l > mid) T[++tm] = id; else &#123; int &amp;res = ans[id]; for (int x = 0; x &lt;= Q[id].V; ++x) res = max(res, f[Q[id].l][x] + f[Q[id].r][Q[id].V - x]); &#125; &#125; for (int i = 1; i &lt;= tm; ++i) p[qmid + i] = T[i]; qr = qmid + tm; solve(l, mid, ql, qmid); solve(mid + 1, r, qmid + 1, qr); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> h[i]; for (int i = 1; i &lt;= n; ++i) cin >> w[i]; int tm = 0; for (int i = 1; i &lt;= m; ++i) &#123; cin >> Q[i].l >> Q[i].r >> Q[i].V; if (Q[i].l == Q[i].r) ans[i] = (Q[i].V >= h[Q[i].l] ? w[Q[i].l] : 0); else p[++tm] = i; &#125; solve(1, n, 1, tm); for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; 例题 多种多样！ * [CF1442D] Sum Portal.给定 nnn 个不降的数组。有一个值 ansansans，初始为 000。你需要进行如下操作 kkk 次：选择一个数组，把 ansansans 加上数组的第一个元素，之后把它删除。请求出 ansansans 最大是多少。所有数组的元素总个数 ≤106\\leq 10^6≤106，n,k≤3000n,k\\leq 3000n,k≤3000。 注意到数组是单调不降的，因此要取一个数组就会一直取下去直到不能取或者取光了。 所以可以想到一个暴力一点的做法：将一个数组视为一个有体积有价值的物品，然后正反做两遍 01 背包，枚举没取满的那个数组和这个数组取多少个，再枚举前面取的体积，这样就可以得出后面取的体积，并计算出总价值，时间复杂度为 O(nk2)O(nk^2)O(nk2)。 这样肯定过不去，发现就是合并太慢了，考虑使用分治算法合并：求解 (l,r)(l,r)(l,r) 时，我们先将 (l,mid)(l,mid)(l,mid) 加入背包，然后递归求解 (mid+1,r)(mid+1,r)(mid+1,r)，当 l=rl=rl=r 时就可以枚举当前体积了。时间复杂度 O(nklog⁡n)O(nk\\log n)O(nklogn)。 这个问题被称为缺一背包，意思是其中有一个可以取不满，一般采用上述分治法解决。 int n, k; vector&lt;i64> a[3005]; i64 ans = 0, f[3005]; void merge(int l, int r) &#123; if (l == r) &#123; for (int i = 0; i &lt;= min(k, (int)a[l].size() - 1); ++i) ans = max(ans, a[l][i] + f[k - i]); return; &#125; int mid = l + r >> 1; i64 g[3005]; memcpy(g, f, sizeof(g)); for (int i = mid + 1; i &lt;= r; ++i) for (int j = k; j >= a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(l, mid); memcpy(f, g, sizeof(f)); for (int i = l; i &lt;= mid; ++i) for (int j = k; j >= a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(mid + 1, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; int m; scanf(\"%d\", &amp;m); a[i].resize(m + 1); for (int j = 1, x; j &lt;= m; ++j) scanf(\"%lld\", &amp;a[i][j]), a[i][j] += a[i][j - 1]; &#125; merge(1, n); printf(\"%lld\\n\", ans); return 0; &#125; [Ynoi2016] 镜中的昆虫 Portal. 维护 prexpre_xprex​ 代表 xxx 上一次出现的位置，xxx 在区间第一次出现当且仅当 prex&lt;l,x∈[l,r]pre_x&lt;l,x\\in [l,r]prex​&lt;l,x∈[l,r]。那么这个问题就变成了允许离线的带修二维数点。 这个修改存在颜色段均摊，可以直接做。具体地，使用 set 维护颜色段，也记录所有颜色对应的段，然后对于修改的东西的后继都重新计算 preprepre。 于是就变成了三维偏序模板。代码。 [CF603E] Pastoral Oddities Portal. 满足题目条件意味着所有连通块的大小都是偶数。将边按照权值从小到大排序，然后线段树分治从右到左依次处理每一条边，计算每一条边可以被记入答案的范围。代码。 随机化算法 有的时候不知道怎么做？或者遇到神秘的提交答案题（有些提交答案是不可做优化题）？可以考虑使用随机化。 随机化有两种，一种是操作次数一定，正确性与进行的轮数有关（模拟退火等）；另一种是期望操作次数，要求数据随机（除非你的方法很神秘，出题人没想到，但是如果交互库是自适应的就没辙了）。 mt19937 Rnd(time(0)); int rndint(int l, int r) &#123; return uniform_int_distribution&lt;>(l, r)(Rnd); &#125; double rnddb(int l, int r) &#123; return uniform_real_distribution&lt;>(l, r)(Rnd); &#125; 爬山法 给出 nnn 维空间的 n+1n+1n+1 个点，求出球心（保证存在）。 答案为单峰函数时可以采用爬山法，每次计算答案应该的改变 canscanscans，然后 ans←ans+cans×Tans\\leftarrow ans+cans\\times Tans←ans+cans×T。 void check(void) &#123; double tot = 0; for (int i = 1; i &lt;= n + 1; ++i) &#123; dis[i] = cans[i] = 0; for (int j = 1; j &lt;= n; ++j) dis[i] += (a[i][j] - ans[j]) * (a[i][j] - ans[j]); tot += (dis[i] = sqrt(dis[i])) / (n + 1); &#125; for (int i = 1; i &lt;= n + 1; ++i) for (int j = 1; j &lt;= n; ++j) cans[j] += (dis[i] - tot) / tot * (a[i][j] - ans[j]); // dis[i] - tot 为当前点与原球心的距离差与平均距离的差，除以 tot 以计算这一维度对平均距离的贡献占比 // a[i][j] - ans[j] 为在当前维度的当前点与原球心距离差，根据此值进行移动 &#125; // 给 ans 赋一个近似的初值 for (double T = 20000; T > 1e-4; T *= 0.99996) &#123; check(); for (int i = 1; i &lt;= n; ++i) ans[i] += cans[i] * T; &#125; 模拟退火 新的答案选择要为随机整数乘上当前的温度（或考虑随机调整之类的），以 eΔ/Te^{\\Delta / T}eΔ/T，即 exp(Delta / T) 的概率接受当前非最优解（保证 Δ\\DeltaΔ 为正，大于 rnd(0, 1) 接受，小于不接受）。实际上，只有在 ΔT\\Delta TΔT 较小的时候，取所有情况的最优答案会得到非常棒的答案，但是 ΔT\\Delta TΔT 足够大时没什么区别，直接将答案也改成不优的也可，这种方式可以用于某些提交答案题。 实际上有时反而将模拟退火接受错解的概率改成固定的能得到更好的结果，但是这时它应该不叫退火了。 其它随机化 对于最优化问题和存在类问题，通常答案的构造方式不止一种，这时可以考虑随机化。也有随机化贪心、随机撒点等做法。具体见题车。 例题 比较考验选手的乱搞能力。 * [CF1556H] DIY Tree Portal. 给生成树定义估价函数 f(T)=∑i=1Kmax⁡{0,Di−di}f(T)=\\sum_{i=1}^K \\max\\{0,D_i-d_i\\}f(T)=∑i=1K​max{0,Di​−di​}，其中 DiD_iDi​ 代表实际度数。 先求出最小生成树，然后对其进行调整。每次选择一条边权最大的，删去后 fff 会减小的边 e1e_1e1​，替换成加上后 fff 不会变大的边权最小的边 e2e_2e2​，时间复杂度为 O(n3)O(n^3)O(n3)。 随机化这个过程，我们给 e1e_1e1​ 和 e2e_2e2​ 的选择加上一个概率，不选就接着扫。代码。 提交答案题 直接给定输入文件，让你不择手段求解答案的题目类型。曾在 2016 以前频繁在考场上出现，不过近年来非传统题的地位正逐步被交互题霸占。 常见类型 通常以下类型的数据点会被组合成提交答案题： 可以被手玩或者超级大暴力解出来的数据点； 特殊构造的数据点，可以使用特别的解法； 需要使用乱搞方法解决的数据点。 例题 由于现在考的不是很多，因此只看一些比较常规的。 [eJOI2018] 互素树 Portal. 由于题目中保证存在 X=0X=0X=0，随机一个排列然后按照条件贪心往树里填都是很容易出解的，因此直接随机化加贪心，跑半个小时就行。 [JRKSJ R2] Dark Forest Portal. 使用增量法 O(1)O(1)O(1) 计算交换位置的贡献，然后随机接受时把答案也给接受了就行（因为方案不好存储，这样的退火也很优），然后尽量调低 Δ\\DeltaΔ。注意特判 #3。 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, p[1005]; i64 a[1005], ans; mt19937 Rand(time(0)); inline int rndint(int l, int r) &#123; return uniform_int_distribution&lt;>(l, r)(Rand); &#125; inline double rnddb(double l, double r) &#123; return uniform_real_distribution&lt;>(l, r)(Rand); &#125; inline int P(int x) &#123; if (x &lt;= 0) return x + n; if (x > n) return x - n; return x; &#125; void calc(int x, int y) &#123; // 将 p[x] 赋值为 y 时答案改变 int A = p[P(x - 2)], B = p[P(x - 1)], &amp;C = p[x], D = p[P(x + 1)], E = p[P(x + 2)]; ans -= (B * a[A] * a[B] + C * a[B] * a[D] + D * a[D] * a[E]) * a[C]; C = y; ans += (B * a[A] * a[B] + C * a[B] * a[D] + D * a[D] * a[E]) * a[C]; &#125; void SA(double T, const double ET, const double delta) &#123; for (int i = 1; i &lt;= n; ++i) calc(i, i); while (T > ET) &#123; int x = rndint(1, n), y = rndint(1, n), px = p[x], py = p[y]; i64 tmp = ans; calc(x, py); calc(y, px); if (ans &lt;= tmp &amp;&amp; exp((ans - tmp) / T) &lt; rnddb(0, 1)) // 回退答案 ans = tmp, swap(p[x], p[y]); T *= delta; &#125; cerr &lt;&lt; \"ans = \" &lt;&lt; ans &lt;&lt; \"\\n\"; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", p[i]); putchar('\\n'); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); return SA(1e15, 1e-15, 0.99999), 0; &#125; 哈希方法 哈希的种类有很多种，如果一个东西看起来只能 O(n)O(n)O(n) 进行比较，但是我们必须 O(1)O(1)O(1) 比较时，可以考虑使用哈希。 序列哈希 即字符串哈希，快速比较两个序列的相等情况。一般来讲我们采用 bbb 进制方式的哈希，即 f(s)=∑i=1lsi×bl−if(s)=\\sum_{i=1}^{l}s_i\\times b^{l-i}f(s)=∑i=1l​si​×bl−i。 配合二分，字符串哈希可以以 O(knlog⁡n)O(kn\\log n)O(knlogn) 的时间复杂度完成允许失配 kkk 次的字符串匹配问题。 集合哈希 针对集合哈希我们通常将每个元素随机映射成一个数，然后哈希函数定义为异或和之类的东西。 [CSP-S 2022] 星战。说的是所有点的出度为 111，但是这样不好维护，转化为入度进行维护，搞一个哈希提高正确率。代码。 树哈希 模板。我们给子树定义一个哈希函数，然后将子树加起来，就可以判断是否同构了。 int n; vector&lt;int> G[1000005]; u64 h[1000005]; mt19937_64 Rand(time(0)); map&lt;u64, u64> mp; inline u64 get(u64 x) &#123; if (mp.find(x) == mp.end()) return mp[x] = Rand(); return mp[x]; &#125; set&lt;u64> s; void dfs(int x, int fa) &#123; h[x] = 1; for (int y : G[x]) if (y != fa) dfs(y, x), h[x] += get(h[y]); s.emplace(h[x]); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); cout &lt;&lt; s.size() &lt;&lt; \"\\n\"; return 0; &#125; 例题 也很多种多样！ [CF1746F] Kazaee Portal. 将每个数哈希成一个随机数，然后树状数组维护区间和，如果能被 kkk 整除那就应该是对的。正确率是 1k\\frac 1 kk1​，跑个 303030 轮即可。代码。 [CF1794E] Labeling the Tree with Distances Portal. 根据树上距离进行树哈希，换根 DP 求解树哈希，然后必须是这个根节点占一个 BiB^iBi，判一下就行。代码。 *【XR-3】系统设计 Portal. 二分跳转用到的序列长度，如果在 xxx 为根的子树中能够找到一条链和此时 Hash 值相等，那么就能跳。序列的 Hash 值使用线段树维护即可。 快速查询树上 Hash？先看看固定根的时候怎么做？很显然，预处理出根到当前节点的哈希就可以。由于保证了是有根树，因此直接差分即可处理别的根。时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)，非常高效。代码。 [NOI2022] 挑战 NPC II Portal. 题目已经告诉我们这是一个树哈希，而且 kkk 小的离谱，因此往最暴力的想！ 简单！能匹配的子树直接匹配掉，不能匹配的最多只有五个，枚举全排列向下递归，记忆化爆搜就行！代码。 杂项优化技巧 一些其它内容。 贪心 比较靠猜，比较人类智慧。 分为排序贪心和反悔贪心两种。 不删除双指针 给定一个长度为 nnn 的序列，定义 f(l,r)f(l,r)f(l,r) 为区间进行某种运算后的结果。有一些合法区间，合法区间左端点给定，右端点是连续的，且不存在包含的合法区间。 双指针！对啦！但是有一些问题无法快速删除（如 gcd⁡\\gcdgcd），我们可以使用不删除双指针。 条件是，信息可以快速归并。 其大致思想是提前预处理一遍 lll 右移时的信息，倒着扫一遍 lll 的移动路径即可。 具体来说，维护左右指针 l,rl,rl,r，还有中间指针 mmm。初始时所有指针都指向 111，然后重复以下步骤直到 rrr 移到了 nnn。 将 l,ml,ml,m 指向 rrr，然后左移 lll，直到 [l,m][l,m][l,m] 不合法，记录 pi=f(i,m)p_i=f(i,m)pi​=f(i,m)。 rrr 右移一次，右移 lll 指针使得区间重新合法，f(l,r)f(l,r)f(l,r) 通过 f(l,m)f(l,m)f(l,m) 和 f(m+1,r)f(m+1,r)f(m+1,r) 求出。当 l&gt;ml&gt;ml&gt;m 时，返回步骤 111。 由于 lll 的左移不会超过上一次的 mmm（大概是左移之后再右移回来的样子，会移动 2n2n2n 次），因此时间复杂度为 O(n)O(n)O(n)。 Portal。相当于对差分序列求 GCD 不为 111 的最长子段。 刚好可以使用不删除双指针！ cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1; i &lt; n; ++i) a[i] = abs(a[i + 1] - a[i]); int ans = 0; for (int m, l, r = 1; r &lt; n; ) &#123; for (m = l = r, p[l + 1] = 0; l >= 1; --l) &#123; p[l] = gcd(p[l + 1], a[l]); if (p[l] == 1) break; &#125; ++l; i64 w = 0; while (1) &#123; ans = max(ans, r - l + 1); ++r; if (r >= n) break; for (w = gcd(w, a[r]); l &lt;= m &amp;&amp; gcd(p[l], w) == 1; ) ++l; if (l > m) break; &#125; &#125; cout &lt;&lt; ans + 1 &lt;&lt; \"\\n\"; 前缀和与差分 这里主要重提一下高维的情况。可以使用 sosDP 来进行求解，也就是枚举子集。 for (int j = 0; j &lt; n; ++j) for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) if (i >> j &amp; 1) f[i] += f[i ^ (1 &lt;&lt; j)]; 高维差分还是考虑容斥来计算。 根号分治（平衡） 有关于根号数据结构，请参考 NOI 一轮复习 IX：数据结构 B。由于大部分根号分治都会和其它数据结构结合，因此这里只介绍基本方法。 根号分治是一种按规模大小分类讨论的思想。对于规模为 xxx 的问题，如果我们可以使用 O(x)O(x)O(x) 和 O(nx)O(\\frac{n}{x})O(xn​) 的复杂度解决，那么可以在 x≤nx\\le \\sqrt{n}x≤n​ 时使用 O(x)O(x)O(x) 算法，否则使用 O(nx)O(\\frac{n}{x})O(xn​) 算法。这样的时间复杂度为 O(nn)O(n\\sqrt{n})O(nn​)。 值得注意的是，这种思想很常用，且复杂度不一定是根号的。 根号平衡 考虑这样一个问题： O(1)O(1)O(1) 单点修改，O(n)O(\\sqrt{n})O(n​) 查询区间和。 简单！分块维护块内的和，每次修改的时候更新块内和即可。 O(n)O(\\sqrt{n})O(n​) 单点修改，O(1)O(1)O(1) 查询区间和。 分块维护块内块外前缀和，也就是每个块内前 xxx 个数的和和前 xxx 块的和，那么查询就是 O(1)O(1)O(1) 的了。 O(1)O(1)O(1) 区间修改，O(n)O(\\sqrt{n})O(n​) 查询单点。 将第一个差分掉直接做即可。 维护一个集合，O(n)O(\\sqrt{n})O(n​) 插入数，O(1)O(1)O(1) 查询 kkk 小。 考虑值域分块，每个数维护其所在的块，对块维护一个有序表，插入的时候直接归并，kkk 小就可以直接查询。 图上三四元环计数 无向图三元环计数。让度数小的点向度数大的点连边，然后暴力 for 查找。如果一个点的度数大于 m\\sqrt{m}m​，这样的点不超过 m\\sqrt{m}m​ 个；如果一个点度数小于 m\\sqrt{m}m​，那么这样的点最多 mmm 个。因此时间复杂度为 O(mm)O(m\\sqrt{m})O(mm​)。 int n, m, ans, deg[100005]; int u[200005], v[200005], vis[100005]; vector&lt;int> G[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", u + i, v + i); ++deg[u[i]]; ++deg[v[i]]; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x = u[i], y = v[i]; if (deg[x] > deg[y] || (deg[x] == deg[y] &amp;&amp; x > y)) swap(x, y); G[x].emplace_back(y); &#125; for (int u = 1; u &lt;= n; ++u) &#123; for (int v : G[u]) vis[v] = u; for (int v : G[u]) for (int w : G[v]) if (vis[w] == u) ++ans; &#125; printf(\"%d\\n\", ans); return 0; &#125; 四元环计数。整体思路跟三元环计数一样，考虑怎样数的不重不漏。枚举一个起点 uuu，保证它是排名最大的点，然后枚举与它距离为 222 的点，统计其中无序对 (x,y)(x,y)(x,y) 的个数即可。代码。 bitset 优化 bitset 可以使用 string 来赋初值： bitset&lt;N> b(string(\"000100101\")); 使用 set() 将 bitset 赋值为全 111，reset() 将 bitset 清空。 bitset 可以进行随机访问，是 O(1)O(1)O(1) 的。而其所有位运算操作都是 O(nw)O\\left(\\frac n w\\right)O(wn​) 的。cin, cout 都可以直接输入输出 bitset。 可以使用 b.to_ullong() 来将其转化为 u64 类型。 可以使用 _Find_first() 和 _Find_next(x) 来找到第一个和下一个为 1 的位置。 CF1584B。如果前 kkk 个能恰好被解锁，那么答案是 ∑i=1kai−(k−1)\\sum_{i=1}^k a_i - (k-1)∑i=1k​ai​−(k−1)。对于解锁情况可以使用 DP 来解决：设 fif_ifi​ 代表前缀 iii 是否恰好能被解锁，那么 fj+ai←fj(j≥i)f_{j+a_i}\\leftarrow f_j(j\\ge i)fj+ai​​←fj​(j≥i)，这个过程可以使用 bitset 加速。代码。 可行性背包 CF1856E。只要更改子树内的权值分布，就可以达到贡献最大化，所以是个树上背包状物，可以通过 E1，代码。 对于 E2，我们要思考如何高效解决“把儿子大小构成的数集合分成差尽可能小的两部分”。子树中不同的 sizsizsiz 最多只有 n\\sqrt{n}n​ 种，二进制拆分掉保证物品个数不多于 log⁡n\\log nlogn 个，然后是可行性背包采用 bitset 优化，单次时间复杂度是 O(nnlog⁡nw)O\\left(\\dfrac{n\\sqrt{n}\\log n}{w}\\right)O(wnn​logn​) 的。 以下是 bitset 实现可行性背包的代码： bitset&lt;524288> b; b = 0; b[0] = 1; for (int x : a) b |= (b &lt;&lt; x); 如何将其搬到树上？简单。如果存在一个重儿子，它比所有轻儿子都重，这样可以直接得出答案。否则会造成一个分治的效果，每次问题规模必定减半，时间复杂度为 O(nnlog⁡2nw)O\\left(\\dfrac{n\\sqrt{n}\\log^2 n}{w}\\right)O(wnn​log2n​)。实际效率非常高。代码。 字符串匹配 假定文本串为 sss，对于每一个字符开一个大小为 ∣s∣|s|∣s∣ 的 bitset NcN_cNc​。对于询问，新建一个 bitset，初始都是 111，从前到后枚举询问串的每个位置 yiy_iyi​，和这个字母对应的 bitset 右移 iii 位取按位与，最后就是所有匹配成功的位置。时间复杂度为 O(nmw)O\\left(\\frac{nm}{w}\\right)O(wnm​)，而且支持带修，直接修改或者位移 bitset 即可。 模板，代码如下： char t[N]; bitset&lt;N> a[10], ans, _1, res; int main(void) &#123; int q; scanf(\"%d\", &amp;q); _1.set(); while (q--) &#123; int op, l, r; scanf(\"%d\", &amp;op); if (op == 0) &#123; scanf(\"%d%s\", &amp;l, t); ++l; int m = strlen(t); res = ~(_1 &lt;&lt; l); for (int i = 0; i &lt; 10; ++i) a[i] = (a[i] &amp; _1 &lt;&lt; l) &lt;&lt; m | (a[i] &amp; res); for (int i = 0; i &lt; m; ++i) a[t[i] - '0'][l + i] = 1; &#125; else if (op == 1) &#123; scanf(\"%d%d\", &amp;l, &amp;r); ++l; res = ~(_1 &lt;&lt; l); for (int i = 0; i &lt; 10; ++i) a[i] = (a[i] &amp; _1 &lt;&lt; r + 1) >> r - l + 1 | (a[i] &amp; res); &#125; else &#123; scanf(\"%d%d%s\", &amp;l, &amp;r, t); ++l; int m = strlen(t); if (m > r - l + 1) &#123; puts(\"0\"); continue; &#125; ans.set(); for (int i = 0; i &lt; m; ++i) ans &amp;= a[t[i] - '0'] >> i; printf(\"%d\\n\", (ans >> l).count() - (ans >> r - m + 2).count()); &#125; &#125; return 0; &#125; 矩阵乘法 对于定义乘法为与运算，加法为或运算的广义矩阵乘法可以使用 bitset 优化。 [CF576D] Flights for Regular Customers。一张 nnn 个点 mmm 条边的有向图，起点为 111，终点为 nnn。只有走过了至少 did_idi​ 条边才能走第 iii 条边，问最短距离。n,m≤150n,m \\le 150n,m≤150，di≤109d_i \\le 10^9di​≤109。 按照边权从小到大排序，然后依次考虑。维护一个数组代表当前能到达的节点，然后每次更新当前时间，“解锁”每一条边。 如果我知道当前的可达性，那么我要知道走一条边的可达性，用 bitset 加速需要记录所有的入边，因此建反图即可。 int n, m; i64 d[N]; struct Edge &#123; int u, v, w; bool operator&lt; (const Edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[N]; bitset&lt;N> vis; struct Matrix &#123; bitset&lt;N> a[N]; friend bitset&lt;N> operator* (const bitset&lt;N> &amp;x, const Matrix &amp;y) &#123; bitset&lt;N> r; for (int i = 1; i &lt;= n; ++i) r[i] = (x &amp; y.a[i]).any(); return r; &#125; friend Matrix operator* (const Matrix &amp;x, const Matrix &amp;y) &#123; Matrix z; for (int i = 1; i &lt;= n; ++i) for (int k = 1; k &lt;= n; ++k) if (x.a[i][k]) z.a[i] |= y.a[k]; return z; &#125; &#125; a; inline void poww(Matrix a, int b, bitset&lt;N> &amp;ans) &#123; for (; b; b >>= 1, a = a * a) if (b &amp; 1) ans = ans * a; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); sort(e + 1, e + m + 1); i64 ans = INF; vis[1] = 1; for (int i = 1, t = 0; i &lt;= m; ++i) &#123; if (e[i].w >= ans) break; poww(a, e[i].w - t, vis); a.a[e[i].v][e[i].u] = 1; t = e[i].w; queue&lt;int> q; for (int x = 1; x &lt;= n; ++x) if (vis[x]) q.push(x), d[x] = 0; else d[x] = INF; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v = 1; v &lt;= n; ++v) if (a.a[v][u] &amp;&amp; d[v] == INF) d[v] = d[u] + 1, q.emplace(v); &#125; ans = min(ans, t + d[n]); &#125; if (ans == INF) puts(\"Impossible\"); else printf(\"%lld\\n\", ans); return 0; &#125; 偏序 可以用来解决高维偏序问题，设求解 mmm 维，则时间复杂度为 O(n2mw)O\\left(\\frac{n^2m}{w}\\right)O(wn2m​)，也就是一维偏序做 mmm 轮，每轮比较每个数，然后把这 mmm 轮的结果都与起来。可能需要逐块处理 bitset。模板，代码如下： int n; int p[3][N], a[3][N], w[N]; bitset&lt;N> b[10005], s; int main(void) &#123; scanf(\"%d%*d\", &amp;n); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; 3; ++j) scanf(\"%d\", a[j] + i), p[j][i] = i; for (int i = 0; i &lt; 3; ++i) sort(p[i] + 1, p[i] + n + 1, [i](int x, int y) &#123; return a[i][x] &lt; a[i][y]; &#125;); // 按每一维排序 for (int l = 1, r = 0; l &lt;= n; l = r + 1) &#123; r = min(l + 10000, n); for (int i = l; i &lt;= r; ++i) b[i - l].set(); for (int i = 0; i &lt; 3; ++i) &#123; s.reset(); for (int j = 1, k = 1; j &lt;= n; ++j) &#123; int o = p[i][j]; for (; k &lt;= n &amp;&amp; a[i][p[i][k]] &lt;= a[i][o]; ) s[p[i][k++]] = 1; if (l &lt;= o &amp;&amp; o &lt;= r) b[o - l] &amp;= s; &#125; &#125; for (int i = l; i &lt;= r; ++i) ++w[b[i - l].count()]; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", w[i]); return 0; &#125; 有向图连通性 bitset 可以加速传递闭包的计算（通常是加速 Floyd），另一个高效做法是缩点后 bitset 加速 BFS。 for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) if (b[i][k]) b[i] |= b[k]; 逐块处理 bitset 有时直接开 nnn 个 bitset 会 MLE，因此考虑每次只处理 BBB 个 bitset，然后处理 nB\\frac n BBn​ 次即可。 例题 以下内容将告诉你 bitset 为什么是神。 [Luogu P6328] 我是仙人掌 Portal. 用 bitset 求图的可达性的模板。代码。 * [CF1239E] Turtle Portal. 由于第一行走的是前缀和，第二行走的是后缀和，因此将第一行排为不降，第二行排为不升。这样它要么在 111 往下走，要么在 nnn 往下走。 也就是说，去掉 a1,a2a_1,a_2a1​,a2​ 后，将剩下数分为两堆 A,BA,BA,B，最小化 max⁡{∑A,∑B}\\max\\{\\sum A,\\sum B\\}max{∑A,∑B}。 考虑 DP，fi,j,kf_{i,j,k}fi,j,k​ 表示前 iii 个数，jjj 个放入 AAA，∑A=k\\sum A=k∑A=k 的存在性。对 (i,j)(i,j)(i,j) 开大小为 kkk 的 bitset，直接转移即可。代码。 * [JSOI2015] 最小表示 Portal. 注意到图是一个 DAG，因此对于一条边 (u,v)(u,v)(u,v)，如果删了这条边依然存在 u→vu\\rightarrow vu→v 的间接路径，那么这条边必定被删去。 对于每个点求出它能到达的点和能到达它的点（不含自己）。如果 uuu 能到达的点和能到 vvv 的点有交集，那么这条边可以被删去。 前者每个点维护一个 bitset，按照拓扑序从大到小转移即可。后者建反图后跟前者一样。时间复杂度 O(nmw)O\\left(\\frac{nm}{w}\\right)O(wnm​)。代码。 特殊问题处理方法 本节会介绍一些经典问题的处理方法。 位运算 位运算本身的性质几乎只针对位运算本身，因此和其它运算组合起来的时候不是那么好看。 这时往往考虑按位处理，因为这样只需要考虑 01 两种数字，经常可以使用数据结构来维护。 枚举子集和枚举超集： for (int i = s; i; i = (i - 1) &amp; s) for (int i = s; i &lt;= u; i = (i + 1) | s) 括号序列 常用的思路是令 ( = 1, ) = -1，性质什么的很显然。 最长上升子序列 将一个序列改为非严格单调递增的，至少需要修改这个序列长度减去单调不降子序列的长度。 而严格单调递增呢？考虑 1 1 2 2 3 3，用序列长度减去它的 LIS 长度是错误的。因此构造 Bi=Ai−iB_i=A_i-iBi​=Ai​−i 可以将问题转化为非严格单调递增。 [CF713C] Sonya and Problem Wihtout a Legend。给定一个有 n(n≤106)n(n\\le 10^6)n(n≤106) 个正整数的数组，一次操作中，可以把任意一个元素加一或减一，求使得原序列严格递增的求最小操作次数。 先转化为要变成非严格单调递增。对于之前的数维护一个大根堆，如果当前的 aia_iai​ 比之前最大的数小，那么就将那个最大的数强行改为 aia_iai​。发现这样构造出来的答案一定不会更劣，但是是否合法呢？ 定义“微调”为在不改变花费的前提下改变数对的值。我们现在要找将 yyy 修改为 xxx 后是否会使得一个 yyy 前面的 zzz 满足 z&gt;yz&gt;yz&gt;y。 当 z&gt;yz&gt;yz&gt;y 时矛盾，那么考虑将 x,yx,yx,y 微调成 zzz，此时花费为 (y−z)+(z−x)=y−x(y-z)+(z-x)=y-x(y−z)+(z−x)=y−x，这样答案依然合法。 如何输出答案？令 bib_ibi​ 为 iii 时刻的堆顶，对 bbb 取一遍后缀最小值即可。 for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); q.push(a[i]); if (q.top() > a[i]) &#123; ans += q.top() - a[i]; q.pop(); q.push(a[i]); &#125; b[i] = q.top(); &#125; printf(\"%lld\\n\", ans); for (int i = n - 1; i >= 1; --i) b[i] = min(b[i], b[i + 1]); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", b[i]); 本质不同子序列 Portal. 考虑将值映射成下标。设 fif_{i}fi​ 表示强制钦定以 iii 结尾的方案数，然后为了不重，强制钦定优先选择下标更大的那一个。也就是合法区间是 [lstai,i−1][lst_{a_i},i-1][lstai​​,i−1]。 int n; int a[300005], b[300005], lst[300005]; int f[300005]; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i], b[i] = a[i]; sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; f[0] = 1; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = (f[i - 1] - (lst[a[i]] ? f[lst[a[i]] - 1] : 0)) % P; ans = (ans + f[i]) % P; f[i] = (f[i] + f[i - 1]) % P; lst[a[i]] = i; &#125; cout &lt;&lt; (ans + 1 + P) % P &lt;&lt; \"\\n\"; return 0; &#125; 曼哈顿与切比雪夫距离 曼哈顿距离是指 x,yx,yx,y 坐标的差的和，而切比雪夫距离指的是差的最大值。 从曼哈顿距离转化成切比雪夫距离，令 xi′=xi+yi,yi′=xi−yix_i&#x27;=x_i+y_i,y_i&#x27;=x_i-y_ixi′​=xi​+yi​,yi′​=xi​−yi​，反着转的时候反过来解一下二元一次方程组就行。 [TJOI2013] 松鼠聚会。给定平面上的 nnn 个点，求其余点到一点的切比雪夫距离之和的最小值。 容易解出转为曼哈顿距离后点的坐标为 (x+y2,x−y2)\\left(\\cfrac{x+y}{2},\\cfrac{x-y}{2}\\right)(2x+y​,2x−y​)。枚举中心点 iii，分别讨论横纵坐标的贡献即可直接计算。代码。 有序序列的交换数 给定一个排列，要让它变得有序。 每次交换一个相邻数，最小操作数是逆序对数。 每次交换一个任意数，最小操作数是序列长度减置换环数。 常用公式 平方和公式斐波那契数列∑i=1ni2=n(n+1)(2n+1)6=n(n+12)−(n+13)\\sum_{i=1}^n i^2 = \\frac{n(n+1)(2n+1)}{6} =n\\binom{n+1}{2} - \\binom{n+1}{3} i=1∑n​i2=6n(n+1)(2n+1)​=n(2n+1​)−(3n+1​) 证明如下： (n+1)3−n3=3n2+3n+1⋯23−13=3×12+3×1+1(n+1)^3 - n^3 = 3n^2+3n+1\\\\ \\cdots\\\\ 2^3-1^3=3\\times 1^2 + 3\\times 1 +1 (n+1)3−n3=3n2+3n+1⋯23−13=3×12+3×1+1 因此： (n+1)3−1=3∑i=1ni2+3∑i=1ni+n(n+1)^3-1=3\\sum_{i=1}^n i^2 + 3\\sum_{i=1}^n i+n (n+1)3−1=3i=1∑n​i2+3i=1∑n​i+n 移项即可。立方和公式也可以这么干。∑i=1nfi=fn+2−f2\\sum_{i=1}^{n}f_i=f_{n+2}-f_{2} i=1∑n​fi​=fn+2​−f2​ 题车 对于对应的组别来说，中档题会附带一个星号，难题会附带两个星号。 刷基础 1 巩固所学内容，训练思维的熟练度、准确度和速度。本身难度不大。 [CF1114E] Arithmetic Progression Portal。操作二用于二分出等差数列的最大数，随机几个数求出公差 gcd 即可。代码。 [HNOI2009] 最小圈 Portal。分数规划，SPFA 检查是否存在负环。代码。 * [CF1354G] Find a Gift Portal。如果知道其中 xxx 个是石头，那么就能用这 xxx 个去确定另外 xxx 个数当中有没有石头。先找到 111 个石头，然后从头开始倍增找到第一个没有石头的区间。要确定这段有石头的区间的第 111 个石头位置，可以二分。如何找到一个石头？不知道，采用随机化。随机找到一些位置，找到当中最重的，那么可以确定那个是石头。代码。 * [TJOI2017] 异或和 Portal。按位处理最终答案的第 kkk 位是否为 111。记录序列的前缀和，第 kkk 位能否出现 111 仅跟当前位和后面的低位（需要考虑借位）有关，树状数组维护低位即可。代码。 [CF1175F] The Number of Subpermutations Portal。考虑枚举 111 的位置，然后向右扫最大值，用哈希判断是否所有数都恰好出现一次。这种情况统计了最大值在 111 的右边，于是反过来再做一遍即可。代码。 [Luogu P5631] 最小 mex 生成树 Portal。不难想到线段树分治，在答案值域上建立线段树维护即可。代码。 * [CF1418G] Three Occurrences Portal。扫描线从左往右扫找到数最多出现三次的区间，然后哈希维护即可。代码。 [CF1795E] Explosions? Portal。总花费更少，那么我们就希望炸掉的血量更多。当变成一个严格单峰函数的时候（令 ai←ai−ia_i\\leftarrow a_i-iai​←ai​−i 变成单峰来处理），也就是搞成一段一段公差为 111 的等差数列，就可以炸了。容易想到通过单调栈处理这个东西，正反做两遍然后合并即可。代码。 [CF1237D] Balanced Playlist Portal。破环成链，单调队列维护最大值，根据此来判断什么时候砸掉播放器即可。代码。 * [CF1500B] Two chandeliers Portal。由于 a,ba,ba,b 中出现的数完全不同，因此考虑找出它们第一次出现相同的位置，最后二分 check 即可。怎么找位置？首先判掉无解，然后 excrt 找位置即可。 [ARC067D] Yakiniku Restaurants Portal。发现走的必定是一条线段。从右端点开始枚举左端点，维护数组 ansians_iansi​ 表示右端点在 iii 的最优答案。每次考虑是否将贡献换到左端点，单调栈维护前缀最大值来计算贡献即可。代码。 刷基础 2 另一些基础题。 [2nd ucup #21] Festival Decorating Portal. 我们考虑对于每个灯开一个 bitset 维护距离它右边 xxx 的灯是否存在，那么时间复杂度 O(n2/w)O(n^2/w)O(n2/w)，空间开不下。我们可以有 50%50\\%50% 的误差，因此开对数个 bitset，存到对数里即可。代码。 刷提升 稍有一定难度的题目。 [CF232E] Quick Tortoise Portal. 由于这个问题可以用 DP 的方式进行扩展，因此不难想到离线。又发现其好扩展不好撤销，因此不难想到猫树分治处理。 考虑按照 xxx 坐标进行分治，考虑： xxx 的起点终点跨越了 midmidmid，设 fi,j,kf_{i,j,k}fi,j,k​ 代表 (i,j)(i,j)(i,j) 能否达到 (mid,k)(mid,k)(mid,k)，gi,j,kg_{i,j,k}gi,j,k​ 代表 (mid,k)(mid,k)(mid,k) 能否达到 (i,j)(i,j)(i,j)。fff 的转移为 fi,j,k=fi+1,j,kor⁡fi,j+1,kf_{i,j,k}=f_{i+1,j,k}\\operatorname{or}f_{i,j+1,k}fi,j,k​=fi+1,j,k​orfi,j+1,k​，ggg 同理，两者都可以使用 bitset 优化。 否则递归下去处理。 时间复杂度 O(nmlog⁡nw)O\\left(\\cfrac{nm\\log n}{w}\\right)O(wnmlogn​)。代码。 * [CF793E] Problem of offices Portal.给定一棵有根树，给定 (a,b)(a,b)(a,b) 和 (c,d)(c,d)(c,d)。有 mmm 个叶子。要求构造一种欧拉序，p1,p2,⋯ ,p2n−2p_1,p_2,\\cdots,p_{2n-2}p1​,p2​,⋯,p2n−2​，使得 a,ba,ba,b 之间经过的叶子个数（不含自己）是 m2−1\\frac m 2 -12m​−1，c,dc,dc,d 亦然。判断是否可行。保证 a,b,c,da,b,c,da,b,c,d 都不在根的同一子树内且都是叶子。 路径上的叶子个数等同于路径外的，而且有两条路径，手玩之后不难发现这两条路径必定相交，不妨先令其为 a c b d。 欧拉序一定会选取全部的子树。对于 a,b,c,da,b,c,da,b,c,d 来说，其内部的子树一定会被选取。考虑 a→ba\\rightarrow ba→b，aaa 向上走到根，这条路径上内部的子树可以自由决定是否被计入 a→ba\\rightarrow ba→b，bbb 也是同理。但其中 ccc 所对应的子树的答案一定要被计入。 c→dc\\rightarrow dc→d 也是一样，bbb 的答案一定要被计入。最后 c→bc\\rightarrow bc→b 这部分的答案是两条路径的交集。 bitset 优化可行性背包即可。代码。 [AGC020D] Min Max Repetition Portal. 字符串填写的方式不难得出，最小连续长度 k=max⁡{⌈AB+1⌉,⌈BA+1⌉}k=\\max\\left\\{\\left\\lceil\\cfrac{A}{B+1}\\right\\rceil,\\left\\lceil\\cfrac{B}{A+1}\\right\\rceil\\right\\}k=max{⌈B+1A​⌉,⌈A+1B​⌉}。 字符串一定是 (AkB)(A^kB)(AkB) 的一个前缀加上 (ABk)(AB^k)(ABk) 的一个后缀。如何找到分界点？最优情况下分界点一定是一个 AAA，是前后缀公用的。假设分界点之前有 bbb 个 BBB 和 aaa 个 AAA，那么应满足 b≤max⁡{0,⌊a−1k⌋}b\\le \\max\\left\\{0,\\left\\lfloor\\cfrac{a-1}{k}\\right\\rfloor\\right\\}b≤max{0,⌊ka−1​⌋}，也就是 a=A−⌈B−bk⌉+1a=A-\\left\\lceil\\cfrac{B-b}{k}\\right\\rceil+1a=A−⌈kB−b​⌉+1。二分找到最大的 bbb 即可确定一切。代码。 [CF1795G] Removal Sequences Portal. ai=0a_i=0ai​=0 一定是最后被删去的，考虑逆时旅人，令 di←deg⁡(i)−aid_i\\leftarrow \\operatorname{deg}(i)-a_idi​←deg(i)−ai​，按照这个进行拓扑排序即可求出一组合法解。 考虑求出不美好的点对，如果这张有向图的两个点直接互相可达，那么这是不美好的。bitset 直接统计即可。由于会 MLE，因此逐块处理，每次只统计 1∼n1\\sim n1∼n 对于 l∼rl\\sim rl∼r 的可达性即可。代码。 [ARC065C] Manhattan Compass Portal. 将曼哈顿距离转为切比雪夫距离，排序二分不难找出合法的点的区间。如何求方案数？对于 iii 所对应的合法区间 [l,r][l,r][l,r]，iii 向 lll 连边，然后区间内依次连边。对于连到了 aaa 点的点，其方案数均可以被统计。 为了避免重复统计，需要注意对于 yyy 统计时不能计算 xxx 相等的情况。代码。 刷综合 综合应用。 [Ptz 2023 Winter Day 6] 4 Portal. 依然是小度数连向大度数。对于 uuu 能到达的点 vvv，统计 vvv 能到达哪些 uuu 能到达的点。然后枚举三元环，就能 O(m/w)O(\\sqrt{m}/w)O(m​/w) 统计出 K4。代码。 [CF1237G] Balanced Distribution Portal. 一个长度为 lll 的区间一定可以用 ⌈l−1k−1⌉\\lceil\\frac{l-1}{k-1}\\rceil⌈k−1l−1​⌉ 次操作完成。可以先令 ai←ai−avga_i\\leftarrow a_i-avgai​←ai​−avg。 一般情况下，合并两个区间进行操作看上去都不劣，但一种情况除外：两个区间都满足 (k−1)∣(l−1)(k-1)\\mid (l-1)(k−1)∣(l−1)。也就是说，切断的位置的元素前缀和一定相等。 因此最优解由若干段区间拼成，每段都能独立操作完成，而且每一段都满足 l mod (k−1)=1,∑ai=0l\\bmod (k-1)=1,\\sum a_i=0lmod(k−1)=1,∑ai​=0。倍增维护这样的段，贪心尽可能多的选取这样的段。 输出方案时直接从右到左枚举每一段，段右边的内容平均数 ≥avg\\ge avg≥avg 时就从这里开始向右扫答案，将多余数留在左边。代码。 * [JSOI2019] 精准预测 无相幽闭蒙蔽了你的双眼。将于近日补充。 * [NOI2020] 制作菜品 青蛙大队踏碎了此处的荒原。将于近日补充。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"}],"tags":[]},{"title":"数学杂项","slug":"notes/数学/math-iii","date":"2023-03-29T00:00:00.000Z","updated":"2023-03-29T00:00:00.000Z","comments":true,"path":"6dc044c5/","link":"","permalink":"https://james1badcreeper.github.io/6dc044c5/","excerpt":"在数学和抽象代数中，群论（Group Theory）主要研究叫做“群”的代数结构。博弈论，是经济学的一个分支，主要研究具有竞争或对抗性质的对象。本文将介绍这两块内容。","text":"在数学和抽象代数中，群论（Group Theory）主要研究叫做“群”的代数结构。博弈论，是经济学的一个分支，主要研究具有竞争或对抗性质的对象。本文将介绍这两块内容。 放在一起的原因是在 OI 中它们都属于杂项。 群论 群是由一种集合 GGG 以及一个二元运算所组成的，它的二元运算用 a⋅ba\\cdot ba⋅b 表示，要求满足群公理： 封闭性，∀a,b∈G,a⋅b∈G\\forall a,b\\in G, a\\cdot b\\in G∀a,b∈G,a⋅b∈G。 结合律，对于 GGG 中的任意元素，其二元运算需要满足结合律。 单位元，GGG 中存在一个元素 eee，使得对于 GGG 中的任意一个元素 aaa，都有一个 e⋅a=a⋅e=ae\\cdot a=a\\cdot e=ae⋅a=a⋅e=a 成立。这个元素应该是唯一的，被称为群的单位元 eee。 逆元，对于 GGG 中的 aaa，总存在 GGG 中的一个 bbb 满足 a⋅b=b⋅a=ea\\cdot b=b\\cdot a=ea⋅b=b⋅a=e，称 bbb 为 aaa 的逆元，记为 a−1a^{-1}a−1。任何一个元素的逆元是唯一的。 这样，(G,⋅)(G,\\cdot)(G,⋅) 被称为一个群。例如，(Z,+)(\\mathbb{Z},+)(Z,+) 是一个群，e=0e=0e=0，一个数的逆元是它的相反数。 如果 (G,⋅)(G,\\cdot)(G,⋅) 满足封闭性和结合律，那么它就是一个半群；如果还满足单位元，那么它就是幺半群；如果群 (G,⋅)(G,\\cdot)(G,⋅) 满足交换律，即 ∀a,b∈G,a⋅b=b⋅a\\forall a,b\\in G, a\\cdot b=b\\cdot a∀a,b∈G,a⋅b=b⋅a，那么这是一个阿贝尔群，又称交换群。 环 环是一个集合 RRR 及对 RRR 的两个二元运算，这里记作加法和乘法 +,⋅+,\\cdot+,⋅（但是并不是四则运算中的加乘），这个环记作 (R,+,⋅)(R,+,\\cdot)(R,+,⋅)，并满足如下代数性质： (R,+)(R,+)(R,+) 是交换群，其单位元记为 000，RRR 中元素 aaa 的加法逆元为 −a-a−a； (R,⋅)(R,\\cdot)(R,⋅) 是半群； 分配律，∀a,b,c∈R,a⋅(b+c)=a⋅b+a⋅c\\forall a,b,c\\in R,a\\cdot(b+c)=a\\cdot b+a\\cdot c∀a,b,c∈R,a⋅(b+c)=a⋅b+a⋅c。 如果 RRR 中的乘法满足交换律，那么 RRR 是交换环；如果 RRR 存在乘法单位元 111，那么它是幺环，在此基础上若所有非零元素 aaa 存在乘法逆元 a−1a^{-1}a−1，那么 RRR 为除环。 域 群的基本概念 置换群 博弈论 主要研究一个游戏中多位玩家的策略。 Problemset","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"群论","slug":"群论","permalink":"https://james1badcreeper.github.io/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"博弈论","slug":"博弈论","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"集训队作业 2020","slug":"default/ioihw-2020","date":"2023-03-23T00:00:00.000Z","updated":"2023-03-23T00:00:00.000Z","comments":true,"path":"a31ed993/","link":"","permalink":"https://james1badcreeper.github.io/a31ed993/","excerpt":"开始做集训队作业，但是我是菜狗。","text":"开始做集训队作业，但是我是菜狗。 感谢 CYJ。 PART I Portal. 第一组 50 道很多，搞一个分割线。 [CF504E] Misha and LCP on Tree Portal. 树剖将字符串区间取出，然后一个一个匹配，匹配不了的就二分。我在 2023/3/23 依然不会 SA，只会哈希，没救了。代码。 [CF505E] Mr. Kitayuta vs. Bamboos Portal. 二分答案，然后倒着做，设每一棵竹子初始高度为二分出的 MMM，然后每次减去 aia_iai​，使得最终答案大于等于 hih_ihi​，并且过程中高度不能变成负的。直接贪心就行。代码。 * [CF506E] Mr. Kitayuta’s Gift | 压缩 DP 自动机 Portal. 这题，太牛逼了。不会。 * [CF512D] Fox And Travelling Portal. 环上的点是根本选不到的，剩下的可以分解成森林。如果一棵树连接着两个环那么连着的这些点就废掉了。 这样树可以变成有根树和无根树，都可以通过树形背包计算出选点的方案数，然后可以简单组合起来。代码。 ** [CF516D] Drazil and Morning Exercise Portal. 两次 DFS 可以简单求出 fff 数组，然后开始神比了： fff 最小的 uuu 将其称为“中心点”，以这个点为根，一个子树中的节点一定比这个节点的 fff 大，因此将 fff 从大到小排序，fff 变小的过程中连通块的范围只会变大。 按照 fff 从小到达排序，直接双指针开扫，然后发现连通块只会不断合并，并查集维护即可。代码。 * [CF516E] Drazil and His Happy Friends Portal. 貌似是神仙同余最短路，省选以后填坑。 [CF521D] Shop Portal. 最后求的是乘积，因此 333 操作的顺序是无所谓的。考虑将 222 操作转化为 333 操作（显然只会一开始赋值一次，转成加法即可）。对于加我们可以将其转化成乘上一个分数，分子是加上的东西，分母是前面加上的和（包括原来的数），乘法操作乘上的东西则都减去 111。 这样算的其实是增加的量，直接贪心即可。代码。 [CF526F] Pudding Monsters Portal. 将问题转到一维上，就是问有多少个子区间满足 max⁡−min⁡−len⁡=−1\\max-\\min-\\operatorname{len} = -1max−min−len=−1，单调栈维护后缀最大最小值，扫描线加线段树维护答案。代码。 第二组 嘿嘿嘿！ [CF536D] Tavas in Kansas Portal. 求出最短路后直接 DP 即可。代码。 UPD 可能不更新了，以后的集训队作业会放在加训记录里。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"基于转移进行优化的 DP","slug":"notes/DP/transfer-dp","date":"2023-03-12T00:00:00.000Z","updated":"2023-10-12T00:00:00.000Z","comments":true,"path":"ab715ea1/","link":"","permalink":"https://james1badcreeper.github.io/ab715ea1/","excerpt":"从动态规划的转移入手，可以用数据结构直接优化转移过程，或者根据决策单调性使用斜率优化、四边形不等式等。","text":"从动态规划的转移入手，可以用数据结构直接优化转移过程，或者根据决策单调性使用斜率优化、四边形不等式等。 转移优化综述 过早的优化是万恶之源。 实际上最关键的事情是有一个好的状态设计，否则第一步就走错后面就完蛋了。 设计状态前，需要明确计算的是什么东西。如果状态设计的不够优秀，要考虑更换。否则，转移会变得相当困难甚至不可做。做了这么多 DP 题，读者应该有一定经验了。 当然，需要保证无后效性、满足最优子结构。 在设计好状态后，先不急着设计一个完美高效的转移。先想想最暴力的转移怎么写，然后在考虑进行优化，比如化简式子、使用数据结构、分析其单调性等。 wqs 二分 学名带权二分。常用于 2D/1D 的 DP，状态的其中一维是物品个数。这是它的明显标志，因此它比较套路。fif_ifi​ 表示恰好（最多/至少）选取 iii 个物品时的答案，如果 fff 是凸函数那么则可以使用 wqs。我们可以猜测： O(nk)O(nk)O(nk) 过不去就是凸的。 或者也可以打表。 由于 fff 是凸的，因此我们可以选择二分斜率，以此计算出它的切线。有时它能直接用，有时可以对 DP 进行降维，有时和斜率优化等内容一起出现。 具体来说，我们画出所有点 (i,f(i))(i,f(i))(i,f(i))，假设它们构成一个上凸壳。二分斜率 kkk，发现随着 kkk 的减小，直线的切点会越来越靠右。 因此二分 kkk 直到横坐标切到我们想要的位置（比如恰好选择 mmm 个数），那么此时的纵坐标就是答案了。 如何求出切点？我们希望这个切点的 yyy 坐标最大，也就是在 yyy 轴上的截距最大。设截距为 g(x)g(x)g(x)，那么切点 (x,f(x))(x,f(x))(x,f(x)) 在 yyy 轴上的截距就是 g(x)=f(x)−kxg(x)=f(x)-kxg(x)=f(x)−kx。问题就是如何求出 g(x)g(x)g(x) 的值了。 考虑 g(x)g(x)g(x) 的意义，相当于钦定的 xxx 个物品的代价都比原来少 kkk，g(x)g(x)g(x) 相当于每个物品代价减 kkk 之后的最优解。 l,rl,rl,r 如何调整？要逼近 (m,f(m))(m,f(m))(m,f(m)) 如果此时切点 (x,f(x))(x,f(x))(x,f(x)) 满足 x&lt;mx&lt;mx&lt;m 时，那么应该将斜率减小，才能让切点右移。 下凸壳大致是一样的。 三点贡献可能会导致无法二分出想要的斜率。但是发现无论切到这条线上的哪个点，都不影响最终答案。采用一个优秀的二分写法可以完全避免这个问题。 概述 [国家集训队] Tree I。给定一个无向连通图，求一棵恰好有 kkk 条白边的最小生成树。n≤5×104,m≤105,w≤100n\\le 5\\times 10^4,m\\le 10^5,w\\le 100n≤5×104,m≤105,w≤100。 设白边数量为 kkk 的最小生成树是 f(k)f(k)f(k)，那么 fff 是一个下凸函数（其实挺显然的）。直接 wqs 即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, need; struct edge &#123; int u, v, w, c; bool operator&lt; (const edge &amp;a) const &#123; if (w != a.w) return w &lt; a.w; return c &lt; a.c; &#125; &#125; a[100005]; int fa[50005], res; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; bool check(int x) &#123; for (int i = 1; i &lt;= m; ++i) if (a[i].c == 0) a[i].w -= x; sort(a + 1, a + m + 1); for (int i = 1; i &lt;= n; ++i) fa[i] = i; int wc = 0; res = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = find(a[i].u), v = find(a[i].v); if (u == v) continue; fa[u] = v; res += a[i].w; wc += (a[i].c == 0); &#125; for (int i = 1; i &lt;= m; ++i) if (a[i].c == 0) a[i].w += x; return wc >= need; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m >> need; for (int i = 1; i &lt;= m; ++i) cin >> a[i].u >> a[i].v >> a[i].w >> a[i].c, ++a[i].u, ++a[i].v; int L = -500, R = 500, ans; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) ans = res + need * mid, R = mid; else L = mid; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; 数据结构优化 DP 数据结构很多，能优化 DP 的也不少。本质思想就是说，DP 的决策集合是在变化的，我们使用数据结构维护这一个集合以实现高速修改和查询。 前缀和优化 当转移方程中有区间和之类的内容，前缀和就派上用场了。 [HAOI2008] 木棍分割。有 nnn 根有不同长度的木棍依次连结了一起。现在允许你最多砍断 mmm 个连接处，砍完后 nnn 根木棍被分成了很多段，要求满足总长度最大的一段长度最小，并且输出有多少种砍的方法使得总长度最大的一段长度最小。 第一问可以二分出答案，第二问设 fi,jf_{i,j}fi,j​ 代表将木棍分成 iii 段，考虑到第 jjj 个木棍的方案数。然后可以在 i−1i-1i−1 段的方案中找出可以段的部分将方案数加起来，前缀和优化一下即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 10007; int n, m; int a[50005], s[50005]; int f[50005], pre[50005], g[50005]; inline bool check(int x) &#123; int res = 0, len = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] > x) return 0; if (len + a[i] > x) ++res, len = a[i]; else len += a[i]; &#125; return res &lt;= m; &#125; int calc(int x) &#123; // 总长度最大为 x int k = 0; for (int i = 1; i &lt;= n; ++i) for (; k &lt; i; ++k) if (s[i] - s[k] &lt;= x) &#123; pre[i] = k; break; &#125; int ans = s[n] &lt;= x; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] &lt;= x) f[i] = 1; g[i] = (g[i - 1] + f[i]) % P; &#125; for (int i = 2; i &lt;= m + 1; ++i) &#123; for (int j = 1; j &lt;= n; ++j) f[j] = (g[j - 1] - g[pre[j] - 1] + P) % P; for (int j = 1; j &lt;= n; ++j) g[j] = (g[j - 1] + f[j]) % P; ans = (ans + f[n]) % P; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), s[i] = s[i - 1] + a[i]; int L = 0, R = s[n] + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) R = mid; else L = mid; &#125; printf(\"%d %d\\n\", R, calc(R)); return 0; &#125; 线段树优化 线段树很强大，可以进行区间查询，也可以对权值进行统计。这就意味着它能优化的东西很多。 [CF833B] The Bakery Portal. 将一个长度为 n(1≤≤35000)n(1\\le \\le 35000)n(1≤≤35000) 的序列分为 k(1≤k≤50)k(1\\le k\\le 50)k(1≤k≤50) 段，使得总价值最大。一段区间的价值表示为区间内不同数字的个数。 设 f(i,j)f(i,j)f(i,j) 代表考虑前 iii 个数，分为 jjj 段的总价值。采用刷表法： f(i,j)f(i,j)f(i,j) 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct Segment_Tree &#123; int T[140005], tag[140005]; inline void pushdown(int o) &#123; if (!tag[o]) return; T[o &lt;&lt; 1] += tag[o], T[o &lt;&lt; 1 | 1] += tag[o]; tag[o &lt;&lt; 1] += tag[o], tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o] += k, tag[o] += k, void(); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; pushdown(o); int mid = l + r >> 1, res = 0; if (x &lt;= mid) res = max(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = max(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; &#125; T[51]; int n, k, a[35005], pre[35005], lst[35005]; int f[35005][55]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); pre[i] = lst[a[i]], lst[a[i]] = i; for (int j = 0; j &lt; k; ++j) &#123; T[j].update(1, 0, n, pre[i], i - 1, 1); int f = T[j].query(1, 0, n, 0, i - 1); T[j + 1].update(1, 0, n, i, i, f); &#125; &#125; printf(\"%d\\n\", T[k].query(1, 0, n, n, n)); return 0; &#125; 整体 DP 当转移方程完全相同时，可以考虑利用线段树“整体”进行转移。 [CF115E] Linear Kingdom Races。 设 fif_ifi​ 为 1∼i1\\sim i1∼i 中获取的最大价值，有 fi=max⁡0≤j&lt;i{fj+val⁡(j+1,i)−cost⁡(j+1,i)}f_i=\\max\\limits_{0\\le j &lt;i} \\{f_j+\\operatorname{val}(j+1,i)-\\operatorname{cost}(j+1,i)\\}fi​=0≤j&lt;imax​{fj​+val(j+1,i)−cost(j+1,i)}。 转移式完全一样，考虑整体 DP。线段树将 [0,i−1][0,i-1][0,i−1] 都减去 aia_iai​，因为它们会修建这条道路。对于比赛来说，给 [0,l−1][0,l-1][0,l−1] 加上价值，因为在这里可以得到完整的道路，也将 fif_ifi​ 加入线段树。那么答案就是线段树上的最大值。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[200005]; i64 f[200005]; vector&lt;pair&lt;int, int>> c[200005]; i64 T[800005], tag[800005]; inline void maketag(int o, i64 k) &#123; T[o] += k; tag[o] += k; &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, i64 k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, k); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; while (m--) &#123; int x, y, w; cin >> x >> y >> w; c[y].emplace_back(x, w); &#125; for (int i = 1; i &lt;= n; ++i) &#123; update(1, 0, n, 0, i - 1, -a[i]); for (auto [p, v] : c[i]) update(1, 0, n, 0, p - 1, v); f[i] = max(f[i - 1], T[1]); update(1, 0, n, i, i, f[i]); &#125; return cout &lt;&lt; f[n] &lt;&lt; \"\\n\", 0; &#125; 决策单调性 有些 DP 的转移决策是具有单调性的，这种时候就可以对决策集合进行单调性维护。单调队列可以维护决策取值范围上下界均单调变化。 wqs 二分 二分队列和栈 二分队列常用来优化有决策单调性的 DP 问题，要求对于 i,ji,ji,j 的最优决策点 pi,pjp_i,p_jpi​,pj​，若 i&lt;ji&lt;ji&lt;j 则必有 pi≤pjp_i\\le p_jpi​≤pj​，且能快速计算转移贡献。 工作时建立一个储存 (j,l,r)(j,l,r)(j,l,r) 的队列，代表 l∼rl\\sim rl∼r 的最优决策点是 jjj，要保证队首的三元组满足 l≥il\\ge il≥i。 加入决策时，如果 iii 比队尾的 jjj 转移到 lll 更优，那么意味着队尾的三元组废了！干烂它，直到剩下最后的三元组。 取出队尾三元组，要找到一个位置 ppp，使得 ppp 以前从 jjj 转移更优，ppp 以及以后从 iii 转移更优，二分即可。 [NOI2009] 诗人小 G。完成一个需要开 long double、行末输出不能有空格的大毒瘤。 设 fif_ifi​ 代表考虑前 iii 个诗句的最小代价，有 fi=min⁡j=0i−1{fj+∣si−sj−1−L∣P}f_i=\\min\\limits_{j=0}^{i-1}\\{f_j+|s_i-s_j-1-L|^P\\}fi​=j=0mini−1​{fj​+∣si​−sj​−1−L∣P}。然后二分队列即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long double ldb; const ldb INF = 1e18; ldb poww(ldb a, int b) &#123; ldb r = 1; for (; b; b >>= 1, a = a * a) if (b &amp; 1) r = r * a; return r; &#125; int n, LEN, P, g[100005], s[100005]; char a[100005][35]; ldb f[100005]; ldb val(int i, int j) &#123; return f[i] + poww(abs(s[j] - s[i] - 1 - LEN), P); &#125; struct Node &#123; int j, l, r; &#125; Q[100005]; int L, R; void print(int x) &#123; if (!x) return; print(g[x]); for (int i = g[x] + 1; i &lt;= x; ++i) printf(\"%s%c\", a[i], i == x ? '\\n' : ' '); &#125; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;LEN, &amp;P); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", a[i]); s[i] = s[i - 1] + strlen(a[i]) + 1; &#125; Q[L = R = 1] = &#123;0, 1, n&#125;; for (int i = 1; i &lt;= n; ++i) &#123; while (L &lt; R &amp;&amp; Q[L].r &lt; i) ++L; Q[L].l = i; int j = Q[L].j; g[i] = j; f[i] = val(j, i); while (L &lt; R &amp;&amp; val(i, Q[R].l) &lt;= val(Q[R].j, Q[R].l)) --R; int LL = Q[R].l - 1, RR = Q[R].r + 2; while (LL + 1 != RR) &#123; int mid = LL + RR >> 1; if (val(i, mid) &lt;= val(Q[R].j, mid)) RR = mid; else LL = mid; &#125; if (RR &lt;= n) Q[R].r = RR - 1, Q[++R] = &#123;i, RR, n&#125;; &#125; if (f[n] > INF) puts(\"Too hard to arrange\"); else printf(\"%lld\\n\", (long long)f[n]), print(n); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(), puts(\"--------------------\"); return 0; &#125; 四边形不等式 分治优化 斜率优化 Problemset","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"算法竞赛/学习笔记/动态规划","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"单调队列","slug":"单调队列","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"wqs 二分","slug":"wqs-二分","permalink":"https://james1badcreeper.github.io/tags/wqs-%E4%BA%8C%E5%88%86/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://james1badcreeper.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"},{"name":"四边形不等式","slug":"四边形不等式","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/"},{"name":"数据结构优化","slug":"数据结构优化","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/"}]},{"title":"块状数据结构","slug":"notes/DS/sqrt-algorithm","date":"2023-03-01T00:00:00.000Z","updated":"2023-03-01T00:00:00.000Z","comments":true,"path":"f2886e9e/","link":"","permalink":"https://james1badcreeper.github.io/f2886e9e/","excerpt":"分块（又称根号算法，因为单次操作复杂度是根号级别），是一种重要的思想，可以用来解决较为简单的题目，也可以用来解决各种可怕的问题。尽管如此，分块的思想不难理解。","text":"分块（又称根号算法，因为单次操作复杂度是根号级别），是一种重要的思想，可以用来解决较为简单的题目，也可以用来解决各种可怕的问题。尽管如此，分块的思想不难理解。 大家在数据结构中应该都听说过分块，因为嵌套数据结构、分块数据结构和可持久化数据结构背称为数据结构三大毒瘤重要思想。但实际上，除了在数据结构中的应用，分块在其它方面也有许多应用。 分块基础 分块的基本思想是，通过对原数据的适当划分，并在划分后的每一个块上预处理部分信息，从而较一般的暴力算法取得更优的时间复杂度。 这么说很空虚，我们通过几道入门题来一一看一下分块的简单应用。 数列分块入门 这是 Loj 上的一个系列题。但是前两个都比较简单，所以这里不写了，大家可以学习完之后写一下练习练习，我们先做一下最为经典的 3。 Portal. 啊，我知道你会树状数组和线段树，我们今天要用分块以龟速解决这道题。 我们把序列 AAA 分成若干个长度块，如下图： 分块后的序列 具体怎么分呢？把若干个数分成一块。我们记录每个点的数值，再记录每个块的和（记作 sum[i]sum[i]sum[i]），还要给每个块打上一个标记 add[i]add[i]add[i]（类似于线段树的延迟标记，而且标记是永久的，否则你往哪传）。 在进行操作的时候，我们把连续的块称之为整块，两边的不完整的块称为零散块。 对于修改操作，分两种情况进行： 当 xxx 和 yyy 处于同一段时，直接暴力加，然后令这一段 sum[i]+=k×(y−x+1)sum[i]+=k\\times(y-x+1)sum[i]+=k×(y−x+1)； 否则，设 xxx 处于第 ppp 段，rrr 处于第 qqq 段。对于 i∈[p+1,q−1]i\\in [p+1,q-1]i∈[p+1,q−1]，令 add[i]+=kadd[i]+=kadd[i]+=k。对于开头、结尾不足一整段的两部分，按照前一种情况暴力更新。 对于查询操作，也分两种情况： 当 xxx 和 yyy 处于同一段时，∑i=xy+add[i]×(y−x+1)\\sum\\limits_{i=x}^{y}+add[i]\\times (y-x+1)i=x∑y​+add[i]×(y−x+1) 就是答案。 否则，设 xxx 处于第 ppp 段，rrr 处于第 qqq 段。记 ans=0ans=0ans=0。对于 i∈[p+1,q−1]i\\in [p+1,q-1]i∈[p+1,q−1]，令 ans+=sum[i]+add[i]×len[i]ans+=sum[i]+add[i]\\times len[i]ans+=sum[i]+add[i]×len[i]，lenlenlen 表示这一段的长度。对于开头、结尾不足一整段的两部分，按照前一种情况暴力查询。 当块的长度较长时，操作的暴力会比较慢（全堆在一个块里）；块的长度较短时，维护部分会比较慢（块变多了，改的 addaddadd 标记数量变多了）。 根据经验，当块的大小在序列长度的算术平方根时会比较快，证明可以采用均值不等式，设块的大小为 ttt： t+nt≥2t×nt=2nt+\\frac{n}{t}\\ge 2\\sqrt{t\\times\\frac{n}{t}} = 2\\sqrt{n} t+tn​≥2t×tn​​=2n​ 当且仅当 t=nt ⟺ t2=nt=\\frac{n}{t}\\iff t^2=nt=tn​⟺t2=n 时等号成立。 然而在某些毒瘤题中，还可能需要通过实验确定最好的块值（我们接下来会看到的）。 接下来就到了愉快的写代码时间，基本结构是这样： #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; using i64 = long long; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m, t; i64 a[100005], sum[100005], add[100005]; // 原序列，块和，延迟标记 int pos[100005], L[100005], R[100005]; // 元素所在额块的编号，块的左右端点 inline void update(int l, int r, i64 k) &#123; // do update &#125; inline i64 query(int l, int r) &#123; // do query &#125; int main(void) &#123; n = read(), m = read(); t = sqrt(n); // 分块 for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= t; ++i) // 先处理好这 t 个块的左右端点 &#123; L[i] = (i - 1) * t + 1; R[i] = i * t; &#125; if (R[t] &lt; n) ++t, L[t] = R[t - 1] + 1, R[t] = n; // 最后剩一小段不够凑成完整的块 //========== 预处理 ========== start > for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) &#123; pos[j] = i; sum[i] += a[j]; &#125; //========== 预处理 ========== end > while (m--) &#123; int op = read(), x = read(), y = read(); if (op == 1) update(x, y, read()); else printf(\"%lld\\n\", query(x, y)); &#125; return 0; &#125; 实际上 sum, L, R 数组无需开这么大，但已经没有优化的必要了。 两个操作的代码如下： void update(int l, int r, i64 k) &#123; int p = pos[l], q = pos[r]; if (p == q) // 同个块内，暴力 &#123; for (int i = l; i &lt;= r; ++i) a[i] += k; sum[p] += (r - l + 1) * k; return; &#125; for (int i = p + 1; i &lt; q; ++i) add[i] += k; // 大块打标记 for (int i = l; i &lt;= R[p]; ++i) a[i] += k; // 左 sum[p] += (R[p] - l + 1) * k; // 和 for (int i = L[q]; i &lt;= r; ++i) a[i] += k; // 右 sum[q] += (r - L[q] + 1) * k; // 和 &#125; i64 query(int l, int r) &#123; // 同 update int p = pos[l], q = pos[r]; i64 ans = 0; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) ans += a[i]; ans += add[p] * (r - l + 1); return ans; &#125; for (int i = p + 1; i &lt; q; ++i) ans += sum[i] + add[i] * (R[i] - L[i] + 1); for (int i = l; i &lt;= R[p]; ++i) ans += a[i]; ans += add[p] * (R[p] - l + 1); for (int i = L[q]; i &lt;= r; ++i) ans += a[i]; ans += add[q] * (r - L[q] + 1); return ans; &#125; 时间复杂度为 O(mn)\\mathcal{O}(m\\sqrt{n})O(mn​)。 上述做法还可以优化，不过时间复杂度并没有变。 优化的方式是前缀和，大体思路是明确的。然而在有修改的情况下，前缀和不方便维护，只能维护单个块内的前缀和，这样零散块的查询就可以使用前缀和了。 复杂度分析 分块的复杂度要从查询和修改，整块和零散块来看。比如刚才的题，若将序列分为 ttt 块： 查询： 整块 O(t)O(t)O(t)， 零散块 O(nt)O(\\frac{n}{t})O(tn​)， 修改 整块 O(t)O(t)O(t)， 零散块 O(nt)O(\\frac{n}{t})O(tn​)。 块状数组 刚才的分块是针对数组的，这类分块我们统称为块状数组。接下来我们将见识更多的题目来详细认识块状数组。 基础训练 这些题都很基础。 [Luogu P2801] 教主的魔法 Portal. 区间加，查询区间大于等于某个数的数的个数。 树状数组维护的是前缀和，线段树维护的信息满足大区间的解可以由小区间合并得到（区间可加性）。但是很可惜，这么奇怪的查询内容虽然满足区间可加性，但是每一个不同的 c 值需要有不同的线段树，所以结论就是用普通线段树做就是送猪头。 但是树套树是可以维护这种复杂信息的，然而树套树做不到区间修改，所以使用分块来解决。 分块之后，我们看一看要怎么查询。我们将每一个块作为一个子问题分别求解。先将这个块排好序，那么查询时就能快很多（直接二分）。什么时候排序？显然是修改的时候，而且只有暴力修改的部分（因为只有它的顺序会变化）。代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, q, t; int L[1000005], R[1000005], pos[1000005]; int a[1000005], T[1000005], add[1000005]; inline void calc(int p) &#123; for (int i = L[p]; i &lt;= R[p]; ++i) T[i] = a[i]; sort(T + L[p], T + R[p] + 1); &#125; inline void update(int l, int r, int k) &#123; int p = pos[l], q = pos[r]; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) a[i] += k; return calc(p); &#125; for (int i = l; i &lt;= R[p]; ++i) a[i] += k; for (int i = L[q]; i &lt;= r; ++i) a[i] += k; for (int i = p + 1; i &lt; q; ++i) add[i] += k; calc(p), calc(q); &#125; inline int answer(int l, int r, int c) &#123; int ans = 0, p = pos[l], q = pos[r]; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) if (a[i] + add[p] >= c) ++ans; return ans; &#125; for (int i = l; i &lt;= R[p]; ++i) if (a[i] + add[p] >= c) ++ans; for (int i = L[q]; i &lt;= r; ++i) if (a[i] + add[q] >= c) ++ans; for (int i = p + 1; i &lt; q; ++i) ans += R[i] - (lower_bound(T + L[i], T + R[i] + 1, c - add[i]) - T) + 1; return ans; &#125; int main(void) &#123; n = read(), q = read(); t = sqrt(n); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= t; ++i) L[i] = (i - 1) * t + 1, R[i] = i * t; if (R[t] &lt; n) R[++t] = n, L[t] = R[t - 1] + 1; for (int i = 1; i &lt;= t; ++i) &#123; for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; calc(i); &#125; while (q--) &#123; char op[3]; scanf(\"%s\", op); if (op[0] == 'M') &#123; int l = read(), r = read(), k = read(); update(l, r, k); &#125; else &#123; int l = read(), r = read(), c = read(); printf(\"%d\\n\", answer(l, r, c)); &#125; &#125; return 0; &#125; 我们设把原序列分成 xxx 个块，那么查询的时候： 整块 O(xlog⁡nx)O\\left(x\\log \\cfrac{n}{x}\\right)O(xlogxn​)， 零散块 O(nx)O\\left(\\cfrac{n}{x}\\right)O(xn​)。 修改复杂度： 整块 O(1)O(1)O(1)， 零散块 O(nx)O\\left(\\cfrac{n}{x}\\right)O(xn​)。 当块的大小为 nlog⁡n\\sqrt{n\\log n}nlogn​ 的时候，时间复杂度可以达到利用这种做法的最优的 O(mnlog⁡n)O(m\\sqrt{n\\log n})O(mnlogn​)。 同样，你也可以通过实验来确定更好的块长。 静态分块 以强制在线的区间众数为代表。以上提到的分块都是动态分块，它们可以处理带修问题。而静态分块则不带修，通过预处理块的信息来得到复杂度较优的做法。静态分块在功能上是接下来要介绍的莫队算法的子集，而且时空常数静态分块都会更大。但是如果强制在线的话，只能使用静态分块。 [Violet] 蒲公英 Portal. 静态多次询问区间众数，强制在线。 区间众数不具有区间可加性，所以不可以使用线段树维护。 我们预处理出数组 c[x][y][num]c[x][y][num]c[x][y][num]，代表 numnumnum 在块 [x][y][x][y][x][y] 中的出现次数，同时预处理出答案。在查询的时候，整块的答案可以直接得到，零散块只需要单次扫描统计即可。 设块的大小为 TTT，那么时间复杂度为 O(nT2+mn/T)O(nT^2+mn/T)O(nT2+mn/T)，那么当 T=n3T=\\sqrt[3]{n}T=3n​ 时会比较快，时间复杂度为 O(n35)O(n^{\\frac{3}{5}})O(n53​)。这种做法比较慢，而且空间较大。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, tot, ans[2]; int a[40005], b[40005]; int c[37][37][40005], f[37][37][2]; int L[205], R[205], pos[40005]; void work(int x, int y, int num) &#123; ++c[x][y][num]; if (c[x][y][num] > ans[0] || (c[x][y][num] == ans[0] &amp;&amp; num &lt; ans[1])) ans[1] = num, ans[0] = c[x][y][num]; &#125; int query(int l, int r) &#123; int p = pos[l], q = pos[r]; int x = 0, y = 0; if (p + 1 &lt;= q - 1) x = p + 1, y = q - 1; memcpy(ans, f[x][y], sizeof(ans)); if (p == q) &#123; for (int i = l; i &lt;= r; ++i) work(x, y, a[i]); for (int i = l; i &lt;= r; ++i) --c[x][y][a[i]]; &#125; else &#123; for (int i = l; i &lt;= R[p]; ++i) work(x, y, a[i]); for (int i = L[q]; i &lt;= r; ++i) work(x, y, a[i]); for (int i = l; i &lt;= R[p]; ++i) --c[x][y][a[i]]; for (int i = L[q]; i &lt;= r; ++i) --c[x][y][a[i]]; &#125; return b[ans[1]]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memcpy(b, a, sizeof(b)); sort(b + 1, b + n + 1); tot = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b; int t = pow(double(n), (double)1 / 3); int len = t ? n / t : n; for (int i = 1; i &lt;= t; ++i) &#123; L[i] = R[i - 1] + 1; R[i] = i * len; &#125; if (R[t] &lt; n) &#123; L[t + 1] = R[t] + 1; R[++t] = n; &#125; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; memset(c, 0, sizeof(c)); memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= t; ++i) for (int j = i; j &lt;= t; ++j) &#123; for (int k = L[i]; k &lt;= R[j]; ++k) ++c[i][j][a[k]]; for (int k = 1; k &lt;= tot; ++k) if (c[i][j][k] > f[i][j][0]) &#123; f[i][j][0] = c[i][j][k]; f[i][j][1] = k; &#125; &#125; int last = 0; while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l = (l + last - 1) % n + 1; r = (r + last - 1) % n + 1; if (l > r) swap(l, r); printf(\"%d\\n\", last = query(l, r)); &#125; return 0; &#125; [Ynoi2019 模拟赛] Yuno loves sqrt technology III Portal. 这次询问的是区间众数的出现次数，但本质上是一样的。我们记录 f(i,j)f(i,j)f(i,j) 代表第 [i,j][i,j][i,j] 块的区间众数出现次数。我们对每一个数都开一个 STL vector，记录其出现的位置，并记 ax[i]ax[i]ax[i] 为第 iii 个数出现在其 vector 中的位置。 整块的答案是可以直接统计的，而对于零散块，则获取当前的数在 vector 中的位置，考虑 ansansans 是否可以变大，进行暴力更新即可。由于 ansansans 最多变大 2n2\\sqrt{n}2n​，因此询问的时间复杂度为 O(n)O(\\sqrt{n})O(n​)。 总时间复杂度为 O(nn)O(n\\sqrt{n})O(nn​)。如果想要求出区间众数的值，额外记录一个即可。 查看代码 #include &lt;bits/stdc++.h> int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; void print(int x) &#123; if (x > 9) print(x / 10); putchar_unlocked(x % 10 + '0'); &#125; int n, m, tot; int a[500005], b[500005], pos[500005]; int L[720], R[720], f[720][720]; int cnt[500005], ax[500005]; std::vector &lt;int> v[500005]; int query(int l, int r) &#123; int p = pos[l], q = pos[r], ans = f[p + 1][q - 1]; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) cnt[a[i]] = 0; for (int i = l; i &lt;= r; ++i) ans = std::max(ans, ++cnt[a[i]]); return ans; &#125; for (int i = l; i &lt;= R[p]; ++i) &#123; int p = ax[i]; while (p + ans &lt; v[a[i]].size() &amp;&amp; v[a[i]][p + ans] &lt;= r) ++ans; &#125; for (int i = L[q]; i &lt;= r; ++i) &#123; int p = ax[i]; while (p - ans >= 0 &amp;&amp; v[a[i]][p - ans] >= l) ++ans; &#125; return ans; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) b[i] = a[i] = read(); std::sort(b + 1, b + n + 1); tot = std::unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = std::lower_bound(b + 1, b + tot + 1, a[i]) - b; v[a[i]].emplace_back(i); ax[i] = v[a[i]].size() - 1; &#125; int t = sqrt(n); for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * t; if (R[t] &lt; n) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = n;&#125; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 1; i &lt;= t; ++i) &#123; memset(cnt, 0, sizeof(cnt)); for (int j = i; j &lt;= t; ++j) &#123; f[i][j] = f[i][j - 1]; for (int k = L[j]; k &lt;= R[j]; ++k) f[i][j] = std::max(f[i][j], ++cnt[a[k]]); &#125; &#125; int last = 0; while (m--) &#123; int l = (read() ^ last), r = (read() ^ last); print(last = query(l, r)); putchar_unlocked('\\n'); &#125; return 0; &#125; [Luogu P3709] 大爷的字符串题 Portal. 可以将序列划分成若干个单调上升序列，那么问的就是区间众数出现次数的相反数。 [Ynoi2019 模拟赛] Yuno loves sqrt technology I Portal. 强制在线的区间逆序对！ 整块内部：预处理； 散块内部：用树状数组预处理前后缀； 散块对散块：处理好每个数的排名，直接归并； 散块对整块：预处理出 gi,jg_{i,j}gi,j​ 代表 1∼j1\\sim j1∼j 对 iii 块的贡献。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int B = 350; template&lt;typename T> inline void read(T &amp;x) &#123; x = 0; int c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); &#125; int n, m; int a[100005], pos[100005]; int b[100005], idx[100005], T[100005]; int L[750], R[750]; i64 f[750][750]; int g[750][100005], pre[100005], nxt[100005]; // 1 ~ j 对第 i 块的贡献 int T1[750], T2[750], t1, t2; struct Fenwick &#123; int C[100005]; inline void add(int x, int k) &#123; for (; x &lt;= n; x += x &amp; -x) C[x] += k; &#125; inline int sum(int x) &#123; int r = 0; for (; x; x -= x &amp; -x) r += C[x]; return r; &#125; &#125; F; inline int merge(int *a, int na, int *b, int nb) &#123; int res = 0; for (int p = 1, q = 1; p &lt;= na &amp;&amp; q &lt;= nb; ) &#123; if (q &lt;= nb &amp;&amp; (p > na || b[q] &lt; a[p])) ++q, res += na - p + 1; else ++p; &#125; return res; &#125; inline i64 query(int l, int r) &#123; int p = pos[l], q = pos[r]; if (p == q) &#123; i64 ans = pre[r] - (l == L[p] ? 0 : pre[l - 1]); t1 = 0; t2 = 0; for (int i = L[p]; i &lt;= R[p]; ++i) if (idx[b[i]] >= L[p] &amp;&amp; idx[b[i]] &lt;= l - 1) T1[++t1] = b[i]; else if (idx[b[i]] >= l &amp;&amp; idx[b[i]] &lt;= r) T2[++t2] = b[i]; return ans - merge(T1, t1, T2, t2); &#125; i64 ans = f[p + 1][q - 1] + nxt[l] + pre[r]; t1 = 0; t2 = 0; for (int i = L[p]; i &lt;= R[p]; ++i) if (idx[b[i]] >= l) T1[++t1] = b[i]; for (int i = L[q]; i &lt;= R[q]; ++i) if (idx[b[i]] &lt;= r) T2[++t2] = b[i]; ans += merge(T1, t1, T2, t2); for (int i = p + 1; i &lt; q; ++i) ans += g[i][R[p]] - g[i][l - 1] + g[i][r] - g[i][L[q] - 1]; return ans; &#125; int main(void) &#123; read(n); read(m); int t = (n - 1) / B + 1; for (int i = 1; i &lt;= n; ++i) read(a[i]), idx[a[i]] = i, T[i] = b[i] = a[i]; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * B; R[t] = n; for (int i = 1; i &lt;= t; ++i) &#123; for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; sort(b + L[i], b + R[i] + 1); &#125; // 散块内部，预处理 for (int op = 1; op &lt;= t; ++op) &#123; for (int i = L[op]; i &lt;= R[op]; ++i) pre[i] = (i == L[op] ? 0 : pre[i - 1]) + ((i - L[op]) - F.sum(a[i] - 1)), F.add(a[i], 1); for (int i = L[op]; i &lt;= R[op]; ++i) F.add(a[i], -1); for (int i = R[op]; i >= L[op]; --i) nxt[i] = (i == R[op] ? 0 : nxt[i + 1]) + F.sum(a[i] - 1), F.add(a[i], 1); for (int i = R[op]; i >= L[op]; --i) F.add(a[i], -1); f[op][op] = pre[R[op]]; &#125; // 散块对整块，整块对整块，预处理 sort(T + 1, T + n + 1); for (int op = 1; op &lt;= t; ++op) for (int i = 1, k = L[op] - 1; i &lt;= n; ++i) &#123; while (k &lt; R[op] &amp;&amp; T[i] > b[k + 1]) ++k; int p = idx[T[i]]; if (p &lt; L[op]) g[op][p] = k - L[op] + 1; else if (p > R[op]) g[op][p] = R[op] - k; &#125; for (int op = 1; op &lt;= t; ++op) for (int i = 1; i &lt;= n; ++i) g[op][i] += g[op][i - 1]; for (int len = 1; len &lt; t; ++len) for (int i = 1; i + len &lt;= t; ++i) &#123; int j = i + len; f[i][j] = f[i + 1][j] + f[i][j - 1] - f[i + 1][j - 1] + g[j][R[i]] - g[j][L[i] - 1]; &#125; for (i64 last = 0; m--; ) &#123; i64 l, r; read(l); read(r); l ^= last, r ^= last; printf(\"%lld\\n\", last = query(l, r)); &#125; return 0; &#125; 一些简单题 简单的分块题。 [Ynoi2017] 由乃打扑克 Portal. 套用《教主的魔法》的二分法，在查询的时候二分出排名为 kkk 的数即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 200; const int INF = 2e9 + 1e8; inline int read(void) &#123; int x = 0, c = getchar_unlocked(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar_unlocked();&#125; while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x * f; &#125; int n, m, t; int a[100005], T[100005]; int L[800], R[800], add[800], pos[100005]; inline void calc(int p) &#123; for (int i = L[p]; i &lt;= R[p]; ++i) T[i] = a[i]; sort(T + L[p], T + R[p] + 1); &#125; inline void update(int l, int r, int k) &#123; int p = pos[l], q = pos[r]; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) a[i] += k; calc(p); return; &#125; for (int i = p + 1; i &lt; q; ++i) add[i] += k; for (int i = l; i &lt;= R[p]; ++i) a[i] += k; for (int i = L[q]; i &lt;= r; ++i) a[i] += k; calc(p); calc(q); &#125; inline pair&lt;int, int> get(int l, int r) &#123; int p = pos[l], q = pos[r], minn = INF, maxx = -INF; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) minn = min(minn, a[i] + add[p]), maxx = max(maxx, a[i] + add[p]); return make_pair(minn, maxx); &#125; for (int i = p + 1; i &lt; q; ++i) minn = min(minn, T[L[i]] + add[i]), maxx = max(maxx, T[R[i]] + add[i]); for (int i = l; i &lt;= R[p]; ++i) minn = min(minn, a[i] + add[p]), maxx = max(maxx, a[i] + add[p]); for (int i = L[q]; i &lt;= r; ++i) minn = min(minn, a[i] + add[q]), maxx = max(maxx, a[i] + add[q]); return make_pair(minn, maxx); &#125; inline int check(int l, int r, int x) &#123; // 询问 [l,r] 中 x 是第几小的数 int p = pos[l], q = pos[r], cnt = 0; if (p == q) &#123; for (int i = l; i &lt;= r; ++i) if (a[i] + add[p] &lt;= x) ++cnt; return cnt; &#125; for (int i = l; i &lt;= R[p]; ++i) if (a[i] + add[p] &lt;= x) ++cnt; for (int i = L[q]; i &lt;= r; ++i) if (a[i] + add[q] &lt;= x) ++cnt; for (int i = p + 1; i &lt; q; ++i) if (T[L[i]] + add[i] &lt;= x) &#123; if (T[R[i]] + add[i] &lt;= x) cnt += R[i] - L[i] + 1; else cnt += upper_bound(T + L[i], T + R[i] + 1, x - add[i]) - (T + L[i]); &#125; return cnt; &#125; inline int query(int l, int r, int k) &#123; if (r - l + 1 &lt; k) return -1; int p = pos[l], q = pos[r]; pair&lt;int, int> t = get(l, r); int ll = t.first - 1, rr = t.second + 1; while (ll + 1 != rr) &#123; int mid = ((long long)ll + rr) / 2; if (check(l, r, mid) &lt; k) ll = mid; else rr = mid; &#125; return rr; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); t = n / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = BLOCK_SIZE * i; R[t] = n; for (int i = 1; i &lt;= t; ++i) &#123; for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; calc(i); &#125; while (m--) &#123; int op = read(), l = read(), r = read(), k = read(); if (op == 1) printf(\"%d\\n\", query(l, r, k)); else update(l, r, k); &#125; return 0; &#125; 莫队 有时题目的查询非常诡异，常规的在线做法（读入一个询问回答一个）不起作用，需要离线做法（读入所有询问后统一处理）。如果还要对询问进行分块，那么莫队就出现了。 普通莫队 [国家集训队] 小 Z 的袜子。nnn 个不同的数，每次询问一个区间 [l,r][l,r][l,r]，问在当中有多大概率抽到两个一样的数。 常规的离线做法似乎不太行，只是将询问按照右端点排序的话，无法通过前缀和相减的方式得到区间每个种类数的个数。我们可以通过莫队解决这个问题： 将询问按照左端点排序，然后分成 n\\sqrt{n}n​ 块，每个块内再按照右端点排序。这样保证了在每个块内，询问的左端点变化范围在 n\\sqrt{n}n​ 内。这样之后我们就可以暴力移动询问区间，而且注定了移动次数为 O(nn)O(n\\sqrt{n})O(nn​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 250; i64 gcd(i64 x, i64 y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int n, m; int a[50005], cnt[50005], pos[50005]; i64 ans, ans1[50005], ans2[50005]; struct Question &#123; int l, r, id; bool operator &lt; (const Question &amp;a) &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[50005]; void update(int p, int f) &#123; if (cnt[a[p]]) ans -= cnt[a[p]] * (cnt[a[p]] - 1); cnt[a[p]] += f; if (cnt[a[p]]) ans += cnt[a[p]] * (cnt[a[p]] - 1); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; for (; r + 1 &lt;= Q[i].r; ++r) update(r + 1, 1); for (; r - 1 >= Q[i].r; --r) update(r, -1); for (; l + 1 &lt;= Q[i].l; ++l) update(l, -1); for (; l - 1 >= Q[i].l; --l) update(l - 1, 1); if (Q[i].l == Q[i].r) &#123; ans1[Q[i].id] = 0, ans2[Q[i].id] = 1; continue; &#125; ans1[Q[i].id] = ans; ans2[Q[i].id] = 1ll * (r - l + 1) * (r - l); &#125; for (int i = 1; i &lt;= m; ++i) &#123; if (ans1[i] == 0) ans2[i] = 1; else &#123; int g = gcd(ans1[i], ans2[i]); ans1[i] /= g, ans2[i] /= g; &#125; printf(\"%lld/%lld\\n\", ans1[i], ans2[i]); &#125; return 0; &#125; 奇偶排序优化。当 lll 位于的块确定时，根据其奇偶性分别让 rrr 升序 / 降序排列，通常可以快 30%30\\%30%。 树上莫队 莫队上树！但是关键是拍到序列上。 链上维护 可以利用欧拉序将其拍到线性结构上（欧拉序在不在链上的内容会直接访问两次来消除其影响） [COT2] Count on a tree II.nnn 个节点的带颜色树，询问路径上不同颜色的数量。 树上莫队模板，注意 LCA 处的讨论。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 300; int n, m, pos[80005], Ans[40005], dep[40005]; int a[40005], b[40005], f[16][40005]; int idx[80005], tot, L[80005], R[80005]; vector&lt;int> G[40005]; struct Query &#123; int l, r, lca, id; bool operator&lt; (const Query &amp;a) const &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[100005]; void dfs(int x, int fa) &#123; idx[L[x] = ++tot] = x; dep[x] = dep[f[0][x] = fa] + 1; for (int i = 1; i &lt;= 15; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x); idx[R[x] = ++tot] = x; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 15; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = 15; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; int ans, buc[40005]; bool vis[40005]; void update(int x) &#123; vis[x] ^= 1; if (vis[x] == 1) &#123; if (buc[a[x]] == 0) ++ans; ++buc[a[x]]; &#125; else &#123; if (buc[a[x]] == 1) --ans; --buc[a[x]]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= tot; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= m; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); Q[i].id = i; int d = LCA(x, y); if (L[x] > L[y]) swap(x, y); if (x == d) Q[i].l = L[x], Q[i].r = L[y]; else Q[i].l = R[x], Q[i].r = L[y], Q[i].lca = d; &#125; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; while (r &lt; Q[i].r) update(idx[++r]); while (r > Q[i].r) update(idx[r--]); while (l > Q[i].l) update(idx[--l]); while (l &lt; Q[i].l) update(idx[l++]); if (Q[i].lca) update(Q[i].lca); Ans[Q[i].id] = ans; if (Q[i].lca) update(Q[i].lca); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", Ans[i]); return 0; &#125; 子树维护 虽然可以使用 DFS 序拍到链上，但是这时不如直接用树上启发式合并，可以做到更好的复杂度。 带修莫队 [国家集训队] 数颜色 / 维护队列。有 nnn 个数，支持询问区间有多少个不同的数和单点修改。 和上一题相比多了一个修改，因此我们来介绍带修莫队：就是多了一个时间轴，排序的时候要看左右端点的块的编号，然后统计答案时直接修正成对应的修改次数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 2600; int n, m; int a[133340], pos[133340], b[133340]; int opp[133340], opv[133340], bck[133340]; struct Operation &#123; int l, r, t, id; Operation(int l = 0, int r = 0, int t = 0, int id = 0) : l(l), r(r), t(t), id(id) &#123;&#125; bool operator &lt; (const Operation &amp;a) const &#123; if (pos[l] == pos[a.l]) &#123; if (pos[r] == pos[a.r]) return id &lt; a.id; return r &lt; a.r; &#125; return l &lt; a.l; &#125; &#125; Q[133340]; int c1 = 0, c2 = 0; int Ans[133340], ans, c[1000005]; void update(int p, int f) &#123; if (c[p] == 0 &amp;&amp; f == 1) ++ans; if (c[p] == 1 &amp;&amp; f == -1) --ans; c[p] += f; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; for (int i = 1; i &lt;= n; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; for (int i = 1, x, y; i &lt;= m; ++i) &#123; char s[5]; scanf(\"%s%d%d\", s, &amp;x, &amp;y); if (s[0] == 'Q') &#123; ++c1; Q[c1] = Operation(x, y, c2, c1); &#125; else &#123; ++c2; opp[c2] = x; opv[c2] = y; bck[c2] = b[x]; b[x] = y; &#125; &#125; sort(Q + 1, Q + c1 + 1); for (int i = 1, l = 1, r = 0, lst = 0; i &lt;= c1; ++i) &#123; for (; lst + 1 &lt;= Q[i].t; ++lst) &#123; if (l &lt;= opp[lst + 1] &amp;&amp; opp[lst + 1] &lt;= r) update(bck[lst + 1], -1), update(opv[lst + 1], 1); a[opp[lst + 1]] = opv[lst + 1]; &#125; for (; lst - 1 >= Q[i].t; --lst) &#123; if (l &lt;= opp[lst] &amp;&amp; opp[lst] &lt;= r) update(opv[lst], -1), update(bck[lst], 1); a[opp[lst]] = bck[lst]; &#125; for (; r + 1 &lt;= Q[i].r; ++r) update(a[r + 1], 1); for (; r - 1 >= Q[i].r; --r) update(a[r], -1); for (; l + 1 &lt;= Q[i].l; ++l) update(a[l], -1); for (; l - 1 >= Q[i].l; --l) update(a[l - 1], 1); Ans[Q[i].id] = ans; &#125; for (int i = 1; i &lt;= c1; ++i) printf(\"%d\\n\", Ans[i]); return 0; &#125; 回滚莫队 有的时候增加删除无法简单实现，比如说删除之后你的答案要更新为次大，这就意味着你需要把 kkk 大都存下来，这样是无法接受的。这时就需要采用回滚莫队。 [joisc2014] 歴史の研究。给定一个序列，多次询问区间中重要度（一个数的出现次数乘以自身数值）的最大值。 删除的话可能需要更新为次大值，然而这个东西是没有记录的，这时候需要采用不删除莫队，过程大概像这样： 排序； 观察 p=pos[l],q=pos[r]p=pos[l],q=pos[r]p=pos[l],q=pos[r]，p,qp,qp,q 的位置： 如果 p=qp=qp=q，那么暴力求解； 如果 ppp 和上一个询问的 ppp 不同，那么将莫队区间的左端点设置为上一个块的右端点 +1，右端点为上一个块的右端点； 否则： 将莫队右端点扩展至询问的右端点，由于右端点是不降的，因此不可能回来； 扩展莫队左端点到询问左端点，并回答询问； 回滚，将莫队的左端点滚回上一个块的右端点 +1。 时间复杂度为 O(nm)O(n\\sqrt{m})O(nm​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 300; int n, m, a[100005], b[100005]; int pos[100005], L[1005], R[1005]; struct Quesiton &#123; int l, r, id; bool operator &lt; (const Quesiton &amp;a) const &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[100005]; int cnt[100005], _cnt[100005]; i64 Ans[100005], ans; inline void add(int x, i64 &amp;t) &#123; ++cnt[x]; t = max(t, 1ll * b[x] * cnt[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int tot = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; int t = n / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0, last = 0; i &lt;= m; ++i) &#123; if (pos[Q[i].l] == pos[Q[i].r]) &#123; for (int j = Q[i].l; j &lt;= Q[i].r; ++j) ++_cnt[a[j]]; for (int j = Q[i].l; j &lt;= Q[i].r; ++j) Ans[Q[i].id] = max(Ans[Q[i].id], 1ll * _cnt[a[j]] * b[a[j]]); for (int j = Q[i].l; j &lt;= Q[i].r; ++j) --_cnt[a[j]]; continue; &#125; if (pos[Q[i].l] != last) &#123; for (; l + 1 &lt;= R[pos[Q[i].l]] + 1; ++l) --cnt[a[l]]; for (; r - 1 >= R[pos[Q[i].l]]; --r) --cnt[a[r]]; ans = 0; last = pos[Q[i].l]; &#125; for (; r + 1 &lt;= Q[i].r; ++r) add(a[r + 1], ans); i64 tmp = ans; int _l = l; for (; _l - 1 >= Q[i].l; --_l) add(a[_l - 1], tmp); Ans[Q[i].id] = tmp; for (; _l + 1 &lt;= l; ++_l) --cnt[a[_l]]; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%lld\\n\", Ans[i]); return 0; &#125; 当然类似的还有不添加莫队，请见 Problemset。 莫队二次离线 树分块 Problemset 非常有趣！ 简单序列分块 一些简单的分块维护序列的题。 [HNOI2010] 弹飞绵羊 Portal. 分块维护每一个点跳几步跳到块外和跳到块外的位置，时间复杂度 O((n+m)n)O((n+m)\\sqrt{n})O((n+m)n​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 450; int n, m; int a[200005], L[2005], R[2005], pos[200005], f[200005], g[200005]; int main(void) &#123; scanf(\"%d\", &amp;n); int t = (n - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = n; i >= 1; --i) if (i + a[i] > R[pos[i]]) f[i] = 1, g[i] = i + a[i]; else f[i] = f[i + a[i]] + 1, g[i] = g[i + a[i]]; for (scanf(\"%d\", &amp;m); m--; ) &#123; int op, x, y; scanf(\"%d%d\", &amp;op, &amp;x); ++x; if (op == 1) &#123; int res = 0; while (g[x] &lt;= n) res += f[x], x = g[x]; printf(\"%d\\n\", res + f[x]); &#125; else &#123; scanf(\"%d\", &amp;y); a[x] = y; for (int i = R[pos[x]]; i >= L[pos[x]]; --i) if (i + a[i] > R[pos[i]]) f[i] = 1, g[i] = i + a[i]; else f[i] = f[i + a[i]] + 1, g[i] = g[i + a[i]]; &#125; &#125; return 0; &#125; [Luogu P3863] 序列 Portal. 如果只有一个数是好做的，对时间进行分块，查询区间的排名。而有多个数，用扫描线来离线维护序列即可（因为是单点查询）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 300; int n, m, t, ans[100005]; int L[10005], R[10005], pos[100005]; int tot; i64 tag[10005]; struct Line &#123; int op, t, v; // t 是时间维上的位置 Line(int op = 0, int t = 0, int v = 0) : op(op), t(t), v(v) &#123;&#125; &#125;; vector&lt;Line> C[100005]; // 序列维 struct Number &#123; int pos; i64 v; bool operator &lt; (const Number &amp;a) const &#123; if (v != a.v) return v &lt; a.v; return pos &lt; a.pos; &#125; &#125; a[100005]; void update(int l, int k) &#123; // [x, m] 的时间加上 k int p = pos[l]; for (int i = L[p]; i &lt;= R[p]; ++i) if (a[i].pos >= l) a[i].v += k; sort(a + L[p], a + R[p] + 1); for (int i = p + 1; i &lt;= t; ++i) tag[i] += k; &#125; int query(int r, i64 x) &#123; // [1, x] 有多少不小于 y int res = 0, p = pos[r]; for (int i = L[p]; i &lt;= R[p]; ++i) if (a[i].pos &lt;= r &amp;&amp; a[i].v + tag[p] >= x) ++res; for (int i = 1; i &lt; p; ++i) res += R[i] - (lower_bound(a + L[i], a + R[i] + 1, Number&#123;0, x - tag[i]&#125;) - a) + 1; return res; &#125; int main(void) &#123; memset(ans, -1, sizeof ans); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, x; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); C[i].emplace_back(1, 0, x); C[i + 1].emplace_back(1, 0, -x); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int op, l, r, x; scanf(\"%d%d\", &amp;op, &amp;l); if (op == 1) &#123; scanf(\"%d%d\", &amp;r, &amp;x); C[l].emplace_back(1, i, x); C[r + 1].emplace_back(1, i, -x); &#125; else &#123; scanf(\"%d\", &amp;x); C[l].emplace_back(2, i, x); &#125; a[i] = &#123;i, 0&#125;; &#125; t = m / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; if (R[t] &lt; m) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = m; &#125; L[1] = 0; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 1; i &lt;= n; ++i) for (auto it : C[i]) if (it.op == 1) update(it.t, it.v); else ans[it.t] = query(it.t - 1, it.v); for (int i = 1; i &lt;= m; ++i) if (ans[i] != -1) printf(\"%d\\n\", ans[i]); return 0; &#125; 普通莫队 这里是普通莫队。 [SNOI2017] 一个简单的询问 Portal.给你一个长度为 NNN 的序列 aia_iai​，1≤i≤N1\\leq i\\leq N1≤i≤N，和 qqq 组询问，每组询问读入 l1,r1,l2,r2l_1,r_1,l_2,r_2l1​,r1​,l2​,r2​，需输出∑x=0∞get(l1,r1,x)×get(l2,r2,x)\\sum\\limits_{x=0}^\\infty \\text{get}(l_1,r_1,x)\\times \\text{get}(l_2,r_2,x)x=0∑∞​get(l1​,r1​,x)×get(l2​,r2​,x)get(l,r,x)\\text{get}(l,r,x)get(l,r,x) 表示计算区间 [l,r][l,r][l,r] 中，数字 xxx 出现了多少次。 利用差分将 get 拆开，然后就可以直接使用莫队维护了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 223; int n, m; int a[50005], pos[50005]; i64 Ans[50005], ans; struct Question &#123; int x, y, id, flag; Question(int x = 0, int y = 0, int id = 0, int flag = 0) : x(x), y(y), id(id), flag(flag) &#123;&#125; bool operator &lt; (const Question &amp;a) const &#123; if (pos[x] == pos[a.x]) return y &lt; a.y; return x &lt; a.x; &#125; &#125; Q[2000005]; int cx[500005], cy[500005]; void updatex(int p, int flag) &#123; cx[a[p]] += flag; ans += cy[a[p]] * flag; &#125; void updatey(int p, int flag) &#123; cy[a[p]] += flag; ans += cx[a[p]] * flag; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int l1, r1, l2, r2; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); Q[i * 4 - 3] = Question(r1, r2, i, 1); Q[i * 4 - 2] = Question(r1, l2 - 1, i, -1); Q[i * 4 - 1] = Question(r2, l1 - 1, i, -1); Q[i * 4] = Question(l1 - 1, l2 - 1, i, 1); &#125; for (int i = 1; i &lt;= m * 4; ++i) if (Q[i].x > Q[i].y) swap(Q[i].x, Q[i].y); sort(Q + 1, Q + m * 4 + 1); for (int i = 1, x = 0, y = 0; i &lt;= m * 4; ++i) &#123; for (; x + 1 &lt;= Q[i].x; ++x) updatex(x + 1, 1); for (; x - 1 >= Q[i].x; --x) updatex(x, -1); for (; y + 1 &lt;= Q[i].y; ++y) updatey(y + 1, 1); for (; y - 1 >= Q[i].y; --y) updatey(y, -1); Ans[Q[i].id] += ans * Q[i].flag; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%lld\\n\", Ans[i]); return 0; &#125; [Luogu P3604] 美好的每一天 Portal. 查询的内容非常套路，出现奇数次的字符只能有一个，可以看成区间异或，将字符状压，直接莫队即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 500; int n, m, pos[60005]; uint Ans[60005]; char s[60005]; int a[60005]; struct Question &#123; int l, r, id; bool operator&lt; (const Question &amp;a) &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[60005]; uint ans, buc[67108870]; inline void add(int msk) &#123; ans += buc[msk]; ++buc[msk]; for (int i = 0; i &lt; 26; ++i) ans += buc[msk ^ (1 &lt;&lt; i)]; &#125; inline void del(int msk) &#123; --buc[msk]; ans -= buc[msk]; for (int i = 0; i &lt; 26; ++i) ans -= buc[msk ^ (1 &lt;&lt; i)]; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, s + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = (1 &lt;&lt; s[i] - 'a') ^ a[i - 1]; pos[i] = (i - 1) / BLOCK_SIZE + 1; &#125; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; while (r &lt; Q[i].r) add(a[++r]); while (r > Q[i].r) del(a[r--]); while (l > Q[i].l - 1) add(a[--l]); while (l &lt; Q[i].l - 1) del(a[l++]); Ans[Q[i].id] = ans; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%u\\n\", Ans[i]); return 0; &#125; [HNOI2016] 大数 Portal. 设 tit_iti​ 代表 [i,n][i,n][i,n] 所代表的数，这样可以直接相减。要求 (tl−tr+1)÷10k≡0(modp)(t_l-t_{r+1})\\div 10^{k}\\equiv 0\\pmod p(tl​−tr+1​)÷10k≡0(modp)。两边可以直接相乘，当且仅当 p≠2,p≠5p\\ne 2,p\\ne 5p=2,p=5，这两种情况的答案可以在线计算，剩下的用莫队维护。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 5000; int n, p, m, pos[200005]; i64 Ans[200005]; char s[200005]; struct Query &#123; int l, r, id; bool operator&lt; (const Query &amp;a) const &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[200005]; namespace Subtask &#123; bool tag[15]; i64 cnt[200005], a[200005]; void MAIN(void) &#123; if (p == 2) tag[0] = tag[2] = tag[4] = tag[6] = tag[8] = 1; else tag[0] = tag[5] = 1; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = a[i - 1] + tag[s[i] - '0']; cnt[i] = cnt[i - 1] + tag[s[i] - '0'] * i; &#125; while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%lld\\n\", cnt[r] - cnt[l - 1] - (a[r] - a[l - 1]) * (l - 1)); &#125; &#125; &#125; i64 ans; int t[200005], c[200005], cnt[200005]; inline void add(int x) &#123; ans += cnt[x]; ++cnt[x]; &#125; inline void del(int x) &#123; --cnt[x]; ans -= cnt[x]; &#125; int main(void) &#123; scanf(\"%d%s%d\", &amp;p, s + 1, &amp;m); n = strlen(s + 1); if (p == 2 || p == 5) return Subtask::MAIN(), 0; for (int i = n, b = 1; i >= 1; --i, b = 10ll * b % p) &#123; c[i] = t[i] = (t[i + 1] + 1ll * (s[i] - '0') * b % p) % p; pos[i] = (i - 1) / BLOCK_SIZE + 1; &#125; sort(c + 1, c + n + 2); int nn = unique(c + 1, c + n + 2) - (c + 1); for (int i = 1; i &lt;= n + 1; ++i) t[i] = lower_bound(c + 1, c + nn + 1, t[i]) - c; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1); for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; ++Q[i].r; for (; r + 1 &lt;= Q[i].r; ++r) add(t[r + 1]); for (; r - 1 >= Q[i].r; --r) del(t[r]); for (; l + 1 &lt;= Q[i].l; ++l) del(t[l]); for (; l - 1 >= Q[i].l; --l) add(t[l - 1]); Ans[Q[i].id] = ans; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", Ans[i]); return 0; &#125; [HNOI2016] 序列 Portal. 考虑设 fl,rf_{l,r}fl,r​ 代表 [l,r][l,r][l,r] 的答案，pip_ipi​ 为 iii 往前 pi&lt;aip_i&lt;a_ipi​&lt;ai​ 的 pip_ipi​ 最小的位置。那么有 fl,r=fl,pi−1+(i−pi+1)×apif_{l,r}=f_{l,p_i-1}+(i-p_i+1)\\times a_{p_i}fl,r​=fl,pi​−1​+(i−pi​+1)×api​​，整个过程与 lll 无关，因此可以预处理出 f1,if_{1,i}f1,i​。 考虑莫队维护这个过程。以 rrr 的向右增加为例，我们需要统计 ∑i=lrfi,r\\sum_{i=l}^r f_{i,r}∑i=lr​fi,r​。找出 [l,r][l,r][l,r] 中最小值的位置 ppp，对于 fl,r⋯fp,rf_{l,r}\\cdots f_{p,r}fl,r​⋯fp,r​ 答案都是 apa_pap​。 lll 的移动维护 fff 后缀即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int B = 350; int n, m; int a[100005], pos[100005]; struct Query &#123; int l, r, id; bool operator&lt; (const Query &amp;a) const &#123; if (pos[l] != pos[a.l]) return l &lt; a.l; if (pos[l] &amp; 1) return r &lt; a.r; return r > a.r; &#125; &#125; Q[100005]; i64 ans[100005], pre[100005], nxt[100005]; int l[100005], r[100005]; int st[100005], tot, f[17][100005]; inline int qpos(int l, int r) &#123; int k = __lg(r - l + 1); return a[f[k][l]] &lt; a[f[k][r - (1 &lt;&lt; k) + 1]] ? f[k][l] : f[k][r - (1 &lt;&lt; k) + 1]; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i], f[0][i] = i; for (int i = 1; 1 &lt;&lt; i &lt;= n; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) f[i][j] = (a[f[i - 1][j]] &lt; a[f[i - 1][j + (1 &lt;&lt; i - 1)]] ? f[i - 1][j] : f[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = i; while (l[i] > 1 &amp;&amp; a[i] &lt; a[l[i] - 1]) l[i] = l[l[i] - 1]; pre[i] = pre[l[i] - 1] + 1ll * (i - l[i] + 1) * a[i]; &#125; for (int i = n; i >= 1; --i) &#123; r[i] = i; while (r[i] &lt; n &amp;&amp; a[i] &lt; a[r[i] + 1]) r[i] = r[r[i] + 1]; nxt[i] = nxt[r[i] + 1] + 1ll * (r[i] - i + 1) * a[i]; &#125; for (int i = 1; i &lt;= n; ++i) pos[i] = (i - 1) / B + 1; for (int i = 1; i &lt;= m; ++i) cin >> Q[i].l >> Q[i].r, Q[i].id = i; sort(Q + 1, Q + m + 1); i64 res = 0; for (int L = 1, R = 0, i = 1; i &lt;= m; ++i) &#123; while (R &lt; Q[i].r) &#123; ++R; int p = qpos(L, R); res += 1ll * (p - L + 1) * a[p] + pre[R] - pre[p]; &#125; while (L > Q[i].l) &#123; --L; int p = qpos(L, R); res += 1ll * (R - p + 1) * a[p] + nxt[L] - nxt[p]; &#125; while (R > Q[i].r) &#123; int p = qpos(L, R); res -= 1ll * (p - L + 1) * a[p] + pre[R] - pre[p]; --R; &#125; while (L &lt; Q[i].l) &#123; int p = qpos(L, R); res -= 1ll * (R - p + 1) * a[p] + nxt[L] - nxt[p]; ++L; &#125; ans[Q[i].id] = res; &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; ans[i] &lt;&lt; \"\\n\"; return 0; &#125; 带修莫队 带修莫队的时间复杂度是 O(n53)O(n^{\\frac{5}{3}})O(n35​)，块长取 n23n^{\\frac{2}{3}}n32​，比较慢。 [WC2013] 糖果公园 Portal. 利用欧拉序将树上的链拍到线性结构上。发现链的处理方式是链的两个端点第一次出现位置的一段（LCA 要讨论）。然后直接带修莫队。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 3000; int n, m, q, pos[200005], lg[100005]; int idx[200005], tot, siz[100005], dep[100005]; int mi[17][100005], dfn[100005], num; int L[100005], R[100005]; int v[100005], w[100005], a[100005]; vector&lt;int> G[100005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; idx[++tot] = x; L[x] = tot; mi[0][dfn[x] = ++num] = fa; siz[x] = 1; dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); siz[x] += siz[y]; &#125; idx[++tot] = x; R[x] = tot; &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; struct Operation &#123; int l, r, lca, time, id; bool operator&lt; (const Operation &amp;a) const &#123; if (pos[l] == pos[a.l]) &#123; if (pos[r] == pos[a.r]) return time &lt; a.time; return r &lt; a.r; &#125; return l &lt; a.l; &#125; &#125; Q[100005]; struct Change &#123; int x, y; &#125; C[100005]; int c1, c2; i64 Ans[100005], ans; bool vis[100005]; int cnt[100005]; inline void modify(int x) &#123; if (vis[x]) ans -= 1ll * v[a[x]] * w[cnt[a[x]]--]; else ans += 1ll * v[a[x]] * w[++cnt[a[x]]]; vis[x] ^= 1; &#125; inline void update(int x) &#123; if (vis[C[x].x]) &#123; modify(C[x].x); swap(C[x].y, a[C[x].x]); modify(C[x].x); &#125; else swap(C[x].y, a[C[x].x]); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", v + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", w + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1; i &lt;= q; ++i) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; if (L[x] > L[y]) swap(x, y); int d = LCA(x, y); ++c1; if (x == d) Q[c1].l = L[x], Q[c1].r = L[y]; else Q[c1].l = R[x], Q[c1].r = L[y], Q[c1].lca = d; Q[c1].id = c1; Q[c1].time = c2; &#125; else &#123; C[++c2] = &#123;x, y&#125;; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) pos[i] = (i - 1) / BLOCK_SIZE + 1; sort(Q + 1, Q + c1 + 1); for (int i = 1, l = 1, r = 0, lst = 0; i &lt;= c1; ++i) &#123; while (r &lt; Q[i].r) modify(idx[++r]); while (r > Q[i].r) modify(idx[r--]); while (l &lt; Q[i].l) modify(idx[l++]); while (l > Q[i].l) modify(idx[--l]); while (lst &lt; Q[i].time) update(++lst); while (lst > Q[i].time) update(lst--); if (Q[i].lca) modify(Q[i].lca); Ans[Q[i].id] = ans; if (Q[i].lca) modify(Q[i].lca); &#125; for (int i = 1; i &lt;= c1; ++i) printf(\"%lld\\n\", Ans[i]); return 0; &#125; 回滚莫队 这里是回滚莫队。 【模板】回滚莫队 &amp; 不删除莫队 Portal. 可以再练习一下。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 400; const int INF = 0x3f3f3f3f; int n, m; int a[200005], b[200005]; int pos[200005], L[1000], R[1000]; struct Question &#123; int l, r, id; bool operator &lt; (const Question &amp;a) const &#123; if (pos[l] == pos[a.l]) return r &lt; a.r; return l &lt; a.l; &#125; &#125; Q[200005]; int Ans[200005], ans; int st[200005], ed[200005], tpst[200005], tped[200005]; int vis[200005], lst[200005]; int main(void) &#123; scanf(\"%d\", &amp;n); int t = n / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int tot = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) st[a[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b] = INF; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1); memset(st, 0x3f, sizeof(st)); for (int i = 1, l = 1, r = 0, last = 0; i &lt;= m; ++i) &#123; if (pos[Q[i].l] == pos[Q[i].r]) &#123; int res = 0; for (int j = Q[i].l; j &lt;= Q[i].r; ++j) lst[a[j]] = j; for (int j = Q[i].l; j &lt;= Q[i].r; ++j) res = max(res, lst[a[j]] - j); for (int j = Q[i].l; j &lt;= Q[i].r; ++j) lst[a[j]] = 0; Ans[Q[i].id] = res; continue; &#125; if (pos[Q[i].l] != last) &#123; memset(st, 0x3f, sizeof(st)); memset(ed, 0, sizeof(ed)); last = pos[Q[i].l]; ans = 0; l = R[last] + 1, r = R[last]; &#125; for (; r + 1 &lt;= Q[i].r; ++r) &#123; int p = r + 1; st[a[p]] = min(st[a[p]], p); ed[a[p]] = max(ed[a[p]], p); ans = max(ans, ed[a[p]] - st[a[p]]); &#125; int _l = l, tmp = ans; for (; _l - 1 >= Q[i].l; --_l) &#123; int p = _l - 1; if (vis[a[p]] != i) &#123; vis[a[p]] = i; tpst[a[p]] = st[a[p]], tped[a[p]] = ed[a[p]]; &#125; tpst[a[p]] = min(tpst[a[p]], p), tped[a[p]] = max(tped[a[p]], p); tmp = max(tmp, tped[a[p]] - tpst[a[p]]); &#125; Ans[Q[i].id] = tmp; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", Ans[i]); return 0; &#125; 复杂问题 一些比较困难的问题。 「RdOI R3.5」RMSQ Portal. 将 aaa 重新编号，问题转化为求区间最长连续子序列。 考虑暴力进行 DP：设 fif_ifi​ 代表以 iii 结尾的数的最大答案，那么 fi=fi−1+1f_{i}=f_{i-1}+1fi​=fi−1​+1。 将原序列分块，如果没有整块则直接暴力，否则考率预处理出整块的答案，然后将零散块的答案合并进整块。可是怎么合并？好像不太好做，我们无法高效预处理出整块的 DP 值，无法对散块进行 DP。 想想有没有简单的方法，我们在扩展右区间时，会对整块内的元素产生贡献，也会对右区间自己产生贡献。整块的元素并不会改变！我们只需要预处理出某一个整块到 iii 的 DP 数组即可！转移也要发生改变，设 fif_ifi​ 代表以 iii 开始的最大答案，这样计算很方便。 同理，我们预处理出每一个整块到序列开头的 DP 数组，然后直接合并即可。可以将这一个 DP 数组存到下个整块的记录到 iii 的 DP 数组中（因为它们没有重合部分）。 这样就以 O(nn)O(n\\sqrt{n})O(nn​) 在线解决了这个问题。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 450; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar(); return x; &#125; int m, n, q, T, tmp[300005], f[300005]; int b[300005], a[300005], bb[300005], Ans[805][805]; int pos[300005], L[805], R[805], ls[300005], rs[300005]; int pd[805][300005]; // pd[i] 记录 i 到末尾的 DP，pd[i + 1] 记录块 i 尾到头部的 DP inline int query(int l, int r) &#123; int p = pos[l] + 1, q = pos[r] - 1, ans = 0; // 整块左端和右端 if (p > q) &#123; for (int i = l; i &lt;= r; ++i) ans = max(ans, f[a[i]] = f[a[i] - 1] + 1); for (int i = l; i &lt;= r; ++i) f[a[i]] = 0; return ans; &#125; ans = Ans[p][q]; // 右区间扩展 // 对整块贡献，对右散块之前的元素贡献 for (int i = R[q] + 1; i &lt;= r; ++i) &#123; f[a[i] - pd[p][i] + 1] = max(f[a[i] - pd[p][i] + 1], pd[p][i]); ans = max(ans, f[a[i] - pd[p][i] + 1]); &#125; // 左区间扩展 // 自己贡献，对右散块贡献 | 对整块贡献 for (int i = L[p] - 1; i >= l; --i) &#123; f[a[i]] = max(&#123;f[a[i]], f[a[i] + 1] + 1, pd[q + 1][i]&#125;); // prer[q][i] ans = max(ans, f[a[i]]); &#125; for (int i = R[q] + 1; i &lt;= r; ++i) f[a[i] - pd[p][i] + 1] = 0; for (int i = L[p] - 1; i >= l; --i) f[a[i]] = 0; return ans; &#125; int main(void) &#123; m = read(), n = read(), q = read(), T = read(); for (int i = 1; i &lt;= m; ++i) b[read()] = i; for (int i = 1; i &lt;= n; ++i) a[i] = b[read()]; int t = n / BLOCK_SIZE; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; if (R[t] &lt; n) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = n; &#125; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 1; i &lt;= n; ++i) ls[i] = tmp[a[i] - 1], tmp[a[i]] = i; memset(tmp, 0, sizeof tmp); for (int i = n; i >= 1; --i) rs[i] = tmp[a[i] + 1], tmp[a[i]] = i; for (int l = 1; l &lt;= n; l += BLOCK_SIZE) &#123; int ans = 0; int *dp = pd[pos[l]]; // 维护第 l 块到末尾的 DP 数组 for (int r = l; r &lt;= n; ++r) &#123; ans = max(ans, dp[r] = dp[ls[r]] + 1); if (pos[r] != pos[r + 1]) Ans[pos[l]][pos[r]] = ans; &#125; &#125; for (int r = BLOCK_SIZE; r &lt;= n; r += BLOCK_SIZE) &#123; int *dp = pd[pos[r] + 1]; for (int l = r; l >= 1; --l) f[l] = f[rs[l]] + 1; for (int l = r; l >= 1; --l) dp[l] = f[l]; memset(f, 0, sizeof f); &#125; for (int last = 0; q--; ) &#123; int l = read(), r = read(); if (T) l ^= last, r ^= last; printf(\"%d\\n\", last = query(l, r)); &#125; return 0; &#125; [Ynoi2007] rfplca Portal. 维护一个数的父亲和跳出块内的父亲。散块暴力重构块的信息，整块被修改块长次以上后会直接跳出块，父亲值可以直接计算。查询时最多跳块的个数次。时间复杂度 O(nn)O(n\\sqrt{n})O(nn​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 600; int n, m; int fa[400005], L[4005], R[4005], tag[4005], c[4005], pos[400005], pa[400005]; inline void change(int i) &#123; if (pos[i] == pos[fa[i]]) pa[i] = pa[fa[i]]; else pa[i] = fa[i]; &#125; void rebuild(int l, int r, int x) &#123; for (int i = l; i &lt;= r; ++i) fa[i] = max(fa[i] - x, 1); for (int i = l; i &lt;= R[pos[l]]; ++i) change(i); &#125; void update(int l, int r, int x) &#123; int p = pos[l], q = pos[r]; if (p == q) return rebuild(l, r, x); rebuild(l, R[p], x); rebuild(L[q], r, x); for (int i = p + 1; i &lt; q; ++i) &#123; if (c[i] &lt;= BLOCK_SIZE) &#123; for (int j = L[i]; j &lt;= R[i]; ++j) fa[j] = max(fa[j] - x, 1), change(j); &#125; else tag[i] = min(tag[i] + x, n); ++c[i]; &#125; &#125; inline int Pa(int x) &#123; if (c[pos[x]] &lt;= BLOCK_SIZE) return pa[x]; return max(1, fa[x] - tag[pos[x]]); &#125; inline int Fa(int x) &#123; if (c[pos[x]] &lt;= BLOCK_SIZE) return fa[x]; return max(1, fa[x] - tag[pos[x]]); &#125; int query(int u, int v) &#123; while (u != v) &#123; int pu = Pa(u), pv = Pa(v); if (pos[pu] != pos[pv]) pos[pu] &lt; pos[pv] ? v = pv : u = pu; else if (pu != pv) pu &lt; pv ? v = pv : u = pu; else u &lt; v ? v = Fa(v) : u = Fa(u); &#125; return u; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); fa[1] = pa[1] = 1; int t = (n - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i; for (int i = 2; i &lt;= n; ++i) scanf(\"%d\", fa + i), change(i); for (int last = 0; m--; ) &#123; int op, l, r, x; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); l ^= last, r ^= last; if (op == 1) scanf(\"%d\", &amp;x), x ^= last, update(l, r, x); else printf(\"%d\\n\", last = query(l, r)); &#125; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"算法竞赛/学习笔记/数据结构","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"分块","slug":"分块","permalink":"https://james1badcreeper.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"数据结构f","slug":"数据结构f","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84f/"}]},{"title":"2023 年 2、3 月做题记录","slug":"default/做题记录/2023-2","date":"2023-02-18T00:00:00.000Z","updated":"2023-01-08T00:00:00.000Z","comments":true,"path":"d9f4b0a5/","link":"","permalink":"https://james1badcreeper.github.io/d9f4b0a5/","excerpt":"","text":"板刷没有太大意义。Codeforces 的真正作用是一个庞大的题库，请善用 Problemset 的标签功能。 打 * 的代表瞄了眼题解，打 ** 的代表压根不会。 第四周 ？？？ 2.18 开始了！ * [CF1788D] Moving Dots *2000 Portal. 正常来讲会汇聚到一个点，答案为 2n−n−12^n-n-12n−n−1。如果会停留在多个位置，仅当存在一对相邻的点会毅然相背而离，这时候可以统计有多少种情况会使得这两个点是相邻的。发现每存在一对这样的点，答案就会变大一。 O(n2log⁡n)O(n^2\\log n)O(n2logn) 统计即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n; int a[3005], p[3005]; int find(int x) &#123; int L = 0, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (a[mid] >= x) R = mid; else L = mid; &#125; return R; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = p[0] = 1; i &lt;= n; ++i) p[i] = 1ll * p[i - 1] * 2 % P; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); int res = 0; for (int l = 1; l &lt; n; ++l) for (int r = l + 1; r &lt;= n; ++r) &#123; int len = a[r] - a[l]; int x = find(a[l] - len), y = find(a[r] + len) - 1; if (x >= l || y &lt;= r) continue; res = (res + 1ll * (p[l - x] - 1) * (p[y - r] - 1) % P * p[x - 1] % P * p[n - y] % P) % P; &#125; printf(\"%d\\n\", ((p[n] - n - 1 + res) % P + P) % P); return 0; &#125; [CF1780F] Three Chairs *2300 Portal. 将 aaa 排序，要求的就是： ans=∑1≤i&lt;j≤n(j−i+1)[gcd⁡(ai,aj)=1]=∑1≤i&lt;j≤n(j−i+1)∑d∣ai,d∣ajμ(d)=∑dμ(d)∑1≤i&lt;j≤kpj−pi−1\\begin{aligned} ans&amp;=\\sum_{1\\le i&lt;j\\le n} (j-i+1)[\\gcd(a_i, a_j)=1]\\\\ &amp;=\\sum_{1\\le i&lt;j\\le n} (j-i+1)\\sum_{d\\mid a_i,d\\mid a_j}\\mu(d)\\\\ &amp;=\\sum_{d}\\mu(d)\\sum_{1\\le i&lt;j\\le k} p_j-p_i-1 \\end{aligned} ans​=1≤i&lt;j≤n∑​(j−i+1)[gcd(ai​,aj​)=1]=1≤i&lt;j≤n∑​(j−i+1)d∣ai​,d∣aj​∑​μ(d)=d∑​μ(d)1≤i&lt;j≤k∑​pj​−pi​−1​ 其中 ppp 表示是 ddd 的倍数的数的下标位置。简单转化一下贡献，后面那一坨就是： −k(k−1)2+∑i=1kpi×(2i−k−1)-\\frac{k(k-1)} 2+\\sum_{i=1}^{k}p_i\\times (2i-k-1) −2k(k−1)​+i=1∑k​pi​×(2i−k−1) 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 300000; int n; int a[300005], mu[300005]; int prime[100005], tot, pos[300005], idx[300005]; bool v[300005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); mu[1] = 1; for (int i = 1; i &lt;= n; ++i) pos[a[i]] = i; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; i64 ans = 0; for (int d = 1; d &lt;= N; ++d) if (mu[d]) &#123; int k = 0; for (int i = d; i &lt;= N; i += d) if (pos[i]) idx[++k] = pos[i]; i64 res = -1ll * k * (k - 1) / 2; for (int i = 1; i &lt;= k; ++i) res += 1ll * idx[i] * (2 * i - k - 1); ans += mu[d] * res; &#125; printf(\"%lld\\n\", ans); return 0; &#125; 2.21 鸽了好几天 ** [CF1781F] Bracket Insertion *2700 Portal. tourist 的神仙题，orz。 采用常见的括号处理方法，设 ( = 1, ) = -1，需要让最小前缀和为 000。在前缀和 xxx 后面插入 () 可以得到 x,x+1,xx,x+1,xx,x+1,x，插入 )( 可以得到 x,x−1,xx,x-1,xx,x−1,x。 前缀和怎么维护？设 fn,xf_{n,x}fn,x​ 代表要对前缀和 xxx 搞 nnn 次依然合法的方案数，那么： fn,x=∑i=0n−1∑j=0n−1−ip(n−1i)(n−1−ij)fi,xfj,x+1fn−1−i−j,x+∑i=0n−1∑j=0n−1−i(1−p)(n−1i)(n−1−ij)fi,xfj,x−1fn−1−i−j,xf_{n,x}= \\sum\\limits_{i=0}^{n-1} \\sum\\limits_{j=0}^{n-1-i} p \\binom{n-1}{i} \\binom{n-1-i}{j} f_{i, x} f_{j, x + 1} f_{n - 1 - i - j, x}\\\\ + \\sum\\limits_{i=0}^{n-1} \\sum\\limits_{j=0}^{n-1-i} (1 - p) \\binom{n-1}{i} \\binom{n-1-i}{j} f_{i, x} f_{j, x - 1} f_{n - 1 - i - j, x} fn,x​=i=0∑n−1​j=0∑n−1−i​p(in−1​)(jn−1−i​)fi,x​fj,x+1​fn−1−i−j,x​+i=0∑n−1​j=0∑n−1−i​(1−p)(in−1​)(jn−1−i​)fi,x​fj,x−1​fn−1−i−j,x​ 利用乘法分配律把 jjj 相关的东西提出来可以消掉一个求和符号，这样时间复杂度为 O(n3)O(n^3)O(n3)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; inline void add(i64 &amp;x, i64 t) &#123; x = (x + t) % P; &#125; int n, p, C[505][505]; i64 f[505][505], g[505][505]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); p = 1ll * p * poww(10000, P - 2) % P; for (int i = 0; i &lt;= n; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; for (int i = 0; i &lt;= n; ++i) f[0][i] = g[0][i] = 1; for (int i = 1; i &lt;= n; ++i) for (int x = 0; x &lt;= n; ++x) &#123; for (int j = 0; j &lt; i; ++j) add(f[i][x], C[i - 1][j] * (p * f[j][x + 1] % P + (1 - p + P) * (x ? f[j][x - 1] : 0) % P) % P * g[i - j - 1][x] % P); for (int j = 0; j &lt;= i; ++j) add(g[i][x], C[i][j] * f[j][x] % P * f[i - j][x] % P); &#125; i64 ans = f[n][0]; for (int i = 1; i &lt;= n * 2; i += 2) ans = ans * poww(i, P - 2) % P; printf(\"%lld\\n\", ans); return 0; &#125; 2.22 为什么我这么摆？？？？？？？？？？？？？？？？啥都不会还摆？？？？？？？？？？？？？？？？？？破大防。 ** [CF1591F] Non-equal Neighbours *2400 Portal. 令 fi,0/1f_{i,0/1}fi,0/1​ 表示将 a1…ia_{1\\dots i}a1…i​ 划分成偶数/奇数段的方案数，划分成的段要求内部全部相等。那么根据容斥原理，答案为 (−1)n(fn,0−fn,1)(-1)^n (f_{n,0}-f_{n,1})(−1)n(fn,0​−fn,1​)。 转移很简单，枚举当前这一段的左端点即可： fi,0/1=∑j=1ifj−1,1/0×min⁡{aj…i}f_{i,0/1}=\\sum_{j=1}^{i}f_{j-1,1/0}\\times \\min\\{a_{j\\dots i}\\} fi,0/1​=j=1∑i​fj−1,1/0​×min{aj…i​} 考虑利用 min⁡\\minmin 的单调性来优化复杂度。维护一个 aia_iai​ 严格递增的单调栈，考虑扫描到 iii 时的栈顶在序列中的下标为 xxx，那么： fi,0/1=fx,0/1+ai∑j=x+1ifj−1,1/0f_{i,0/1}=f_{x,0/1}+a_i\\sum_{j=x+1}^i f_{j-1,1/0} fi,0/1​=fx,0/1​+ai​j=x+1∑i​fj−1,1/0​ 因为左端点 xxx 之后的最小值全是 aia_iai​，而对于左端点在 xxx 及前面 aia_iai​ 对最小值没有影响，直接就是 fx,0f_{x,0}fx,0​。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 998244353; int n, a[200005], st[200005], tot; i64 f[200005][2], s[200005][2]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); f[0][0] = s[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; while (tot &amp;&amp; a[st[tot]] >= a[i]) --tot; f[i][0] = ((tot ? f[st[tot]][0] : 0) + (s[i - 1][1] - (tot ? s[st[tot] - 1][1] : 0)) * a[i]) % P; f[i][1] = ((tot ? f[st[tot]][1] : 0) + (s[i - 1][0] - (tot ? s[st[tot] - 1][0] : 0)) * a[i]) % P; s[i][0] = (s[i - 1][0] + f[i][0]) % P; s[i][1] = (s[i - 1][1] + f[i][1]) % P; st[++tot] = i; &#125; printf(\"%lld\\n\", (((n &amp; 1) ? -1 : 1) * (f[n][0] - f[n][1]) % P + P) % P); return 0; &#125; 2.23 我死。 ** [CF888F] Connecting Vertices *2500 Portal. 可以将多边形展开成一条链，连边时只能覆盖或不交。考虑区间 DP，可以枚举中间的连接点，也可以通过 [l,r][l,r][l,r] 连接。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; int n, a[505][505]; int f[505][505][2]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[i][j]); for (int i = 1; i &lt;= n; ++i) f[i][i][0] = 1; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (a[i][j]) &#123; for (int k = i; k &lt; j; ++k) add(f[i][j][1], 1ll * (f[i][k][0] + f[i][k][1]) * (f[k + 1][j][0] + f[k + 1][j][1]) % P); &#125; for (int k = i + 1; k &lt; j; ++k) if (a[i][k]) add(f[i][j][0], 1ll * f[i][k][1] * (f[k][j][0] + f[k][j][1]) % P); &#125; printf(\"%d\\n\", (f[1][n][0] + f[1][n][1]) % P); return 0; &#125; 2.24 我怎么什么都不会。 ** [CF840C] On the Bench *2500 Portal. 首先乘积为完全平方数有类似与传递性的性质，因此可以将数分为 mmm 组，第 iii 组的数字个数为 sis_isi​。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个组，有 jjj 个相邻数乘积为完全平方数的对。可以将第 iii 个组分成 kkk 个连续段（这一部分的方案数可以预处理），不合法的数量会增加 si−ks_i-ksi​−k，然后选择破坏掉之间 jjj 个相邻中的 l(0≤l≤k)l(0\\le l\\le k)l(0≤l≤k) 个，这样 fi−1,jf_{i-1,j}fi−1,j​ 转移到了 fi,j+si−k−lf_{i,j+s_i-k-l}fi,j+si​−k−l​。在 jjj 中选择 lll 个破坏掉会使用这一组中的 lll 段，还剩 k−lk-lk−l 段选择插入在剩下的 sum+1−jsum+1-jsum+1−j 个空中即可（sum=∑p=1i−1sisum=\\sum_{p=1}^{i-1}s_isum=∑p=1i−1​si​）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000007; int n, m, cnt[305], p[305]; int a[305]; int C[305][305]; int f[305][305], g[305][305]; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; // g[i][j] : 将 i 个不同的数分成 k 个连续段落 int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); bool flag = 0; for (int j = 1; j &lt;= m; ++j) &#123; i64 u = 1ll * p[j] * a[i], v = sqrt(u); if (v * v == u) &#123; ++cnt[j]; flag = 1; break; &#125; &#125; if (!flag) p[++m] = a[i], cnt[m] = 1; &#125; for (int i = 0; i &lt;= n; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; f[0][0] = 1, g[0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= i; ++j) g[i][j] = (1ll * g[i - 1][j] * (i - 1 + j) + 1ll * g[i - 1][j - 1] * j) % P; int sum = 0; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 0; j &lt;= sum; ++j) for (int k = 1; k &lt;= cnt[i]; ++k) for (int l = 0; l &lt;= k; ++l) add(f[i][j + (cnt[i] - k) - l], 1ll * f[i - 1][j] * g[cnt[i]][k] % P * C[j][l] % P * C[sum + 1 - j][k - l] % P); sum += cnt[i]; &#125; printf(\"%d\\n\", f[m][0]); return 0; &#125; 2.28 哼哼，这都要 NOIP 了。 [CF1779F] Xorcerer’s Stones *2500 Portal. 拍成 DFS 序在序列上做。从根往子树进行操作（否则交换也可），所以设 fi,jf_{i,j}fi,j​ 代表考虑到 [1,i−1][1,i-1][1,i−1] 的选择情况，当前的异或和为 jjj，记录从哪里来的和异或值。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int sum[200005], siz[200005], idx[200005], num; vector&lt;int> G[200005]; pair&lt;int, int> f[200005][32]; void dfs(int x) &#123; idx[++num] = x; siz[x] = 1; for (int y : G[x]) dfs(y), siz[x] += siz[y], sum[x] ^= sum[y]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", sum + i); for (int i = 2; i &lt;= n; ++i) &#123; int f; scanf(\"%d\", &amp;f); G[f].emplace_back(i); &#125; dfs(1); memset(f, -1, sizeof f); f[1][sum[1]] = &#123;0, 0&#125;; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; 32; ++j) if (f[i][j].first != -1) &#123; int v = (siz[idx[i]] &amp; 1) ? 0 : sum[idx[i]]; f[i + 1][j] = &#123;i, j&#125;; f[i + siz[idx[i]]][j ^ v] = &#123;i, j&#125;; &#125; if (f[n + 1][0].first == -1) return puts(\"-1\"), 0; vector&lt;int> ans; int u = n + 1, v = 0; while (u) &#123; int tu = f[u][v].first, tv = f[u][v].second; if (u - tu == siz[idx[tu]]) ans.emplace_back(idx[tu]); u = tu, v = tv; &#125; ans.emplace_back(1); printf(\"%d\\n\", ans.size()); for (int x : ans) printf(\"%d \", x); putchar('\\n'); return 0; &#125; * [CF1733E] Conveyor *2700 Portal. 谔谔题。便谔谔地开始想。 显然两只史莱姆不会变成大史莱姆。因为距离都不一样。 这样求出 ttt 时刻内所有经过 x,yx,yx,y 的史莱姆是容易计算的。发现经过 (x,y)(x,y)(x,y) 的 aaa 史莱姆有 ⌈a2⌉\\left\\lceil\\frac a 2 \\right\\rceil⌈2a​⌉ 走到 (x,y+1)(x,y+1)(x,y+1)，⌊a2⌋\\left\\lfloor\\frac a 2 \\right\\rfloor⌊2a​⌋ 走到 (x+1,y)(x+1,y)(x+1,y)。 似乎可以递推！但是注意初始时 f0,0=t−x−y+1f_{0,0}=t-x-y+1f0,0​=t−x−y+1。因为在这个时刻开始，新出生的史莱姆就到不了 (x,y)(x,y)(x,y)。 这样差分，看 t−1t-1t−1 和 ttt 时刻经过 (x,y)(x,y)(x,y) 的史莱姆个数，相等的话就没有史莱姆在 ttt 时刻出现在 (x,y)(x,y)(x,y)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000007; i64 t, f[125][125]; int x, y; i64 calc(i64 t, int x, int y) &#123; if (x + y > t) return 0; memset(f, 0, sizeof f); f[0][0] = t - x - y + 1; for (int i = 0; i &lt; 120; ++i) for (int j = 0; j &lt; 120; ++j) &#123; f[i][j + 1] += f[i][j] + 1 >> 1; f[i + 1][j] += f[i][j] >> 1; &#125; return f[x][y]; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld%d%d\", &amp;t, &amp;x, &amp;y); if (t == 0) puts(x == 0 &amp;&amp; y == 0 ? \"YES\" : \"NO\"); else puts(calc(t - 1, x, y) == calc(t, x, y) ? \"NO\" : \"YES\"); &#125; return 0; &#125; 3.1 我谔谔。 * [CF1774F2] Magician and Pigs *2700 Portal. 非常有趣。 考虑复制操作是干了什么。新生成的猪和原来的猪是一样的，但原来的猪还要再受到一遍伤害打击。所以说，相当于复制操作会克隆出当前所有的猪，然后让克隆猪再承受一遍前面受到的伤害。 这样可以处理出每个复制操作前面所附带的伤害，然后倒序扫描。对于每一头猪，先减掉它后面会被扣去的血量。然后从后往前扫描所有的复制操作看其是否可以进行。如果这头猪可以吃得住这个复制操作打出的伤害，那么这个复制操作之前的所有复制操作所克隆出的猪都是可以存活到最后的。然后猪的血量要减去这个伤害（接下来求解的就是当前复制操作的克隆猪了）。 时间复杂度 O(nlog⁡V)O(n\\log V)O(nlogV)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 998244353; const i64 S = 1000000000; int n, tot; int a[800005]; i64 b[800005], c[800005]; int main(void) &#123; scanf(\"%d\", &amp;n); i64 sum = 0, ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] != 3) scanf(\"%lld\", b + i); if (a[i] == 2) sum = min(sum + b[i], S); if (a[i] == 3) b[i] = sum, sum = min(sum * 2, S); &#125; sum = 0; i64 res = 1; for (int i = n; i >= 1; --i) &#123; if (a[i] == 1) &#123; b[i] -= sum; // 扣掉后面操作附加的真伤 if (b[i] &lt;= 0) continue; i64 r = b[i], cnt = 1; // 原本会有一只，就是一个复制操作都不进行 for (int j = 1; j &lt;= tot; ++j) // 看能够复制到哪里 if (r > c[j]) &#123; cnt = (cnt + (1ll &lt;&lt; tot - j)) % P; // 进行第 j 个复制操作 r -= c[j]; &#125; ans = (ans + res * cnt) % P; &#125; else if (a[i] == 2) sum += b[i]; else &#123; if (b[i] == S) continue; // 毁灭打击，克隆的猪都死 if (b[i] == 0) &#123; res = res * 2 % P; continue; &#125; // 无伤害，猪翻倍 c[++tot] = b[i]; &#125; &#125; printf(\"%lld\\n\", ans); return 0; &#125; * [CF1762E] Tree Sum *2600 Portal. 设连接 iii 的边权为 did_idi​，而每条边对 ∏di\\prod d_i∏di​ 的贡献为 111，然而 nnn 为奇数时 ∏di=−1\\prod d_i=-1∏di​=−1 永远不可能满足，因此 nnn 为奇数时无解。 如果 nnn 为偶数且树的形态固定，那么参考 Prufer 序列的构造方式，从叶子开始赋予边权，那么方式一定是唯一的！也就是说，对于给定的树的形态只有一种方式。 这样的话，一条边 (u,v)(u,v)(u,v) 的权值为 111 的充要条件是：断掉这条边之后两个连通块大小均为偶数。因为这样两个连通块都满足条件了，这条边填 111 即可。 考虑逐边计算贡献，枚举 111 所在的连通块大小 iii，这样 nnn 所对应的连通块大小便为 n−in-in−i。 此时这条边的边权为 (−1)i(-1)^i(−1)i。 剩下 nnn 个点中随便扔，方案数为 (n−2i−1)\\binom{n-2}{i-1}(i−1n−2​)。 两块随便制造无根树，根据 Cayley 公式计算即可。 随便找两个点连接。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n; int fac[500005], ifac[500005]; int C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; int f(int n) &#123; if (n == 1) return 1; return poww(n, n - 2); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); if (n &amp; 1) return puts(\"0\"), 0; for (int i = fac[0] = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; ifac[n] = poww(fac[n], P - 2); for (int i = n - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; int ans = 0; for (int i = 1; i &lt; n; ++i) ans = (ans + (i &amp; 1 ? -1ll : 1ll) * i * (n - i) % P * C(n - 2, i - 1) % P * f(i) % P * f(n - i) % P) % P; printf(\"%d\\n\", (ans % P + P) % P); return 0; &#125; 3.3 最后的挣扎。 ** [CF1626F] A Random Code Problem *2800 Portal. 实际上求的是所有数的和。 我们只关心前 k−1k-1k−1 轮操作数被减去了多少，因此将数对 L=lcm⁡(0∼k−1)L=\\operatorname{lcm}(0\\sim k-1)L=lcm(0∼k−1) 取模后减去的值是等价的。 初始时我们令所有数都要减去它们会减去的值，每个数会被选 k×nk−1k\\times n^{k-1}k×nk−1 次。 开始 DP！设 fi,jf_{i,j}fi,j​ 表示进行 jjj 轮后模 LLL 等于 iii 的数的个数。每次给答案加上没有减去的贡献，然后更新有多少个数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int n, a[10000005], x, y, k, M, L = 1; int f[10000005], p[20]; int ans; int main(void) &#123; cin >> n >> a[0] >> x >> y >> k >> M; for (int i = p[0] = 1; i &lt;= k; ++i) p[i] = 1ll * p[i - 1] * n % P; for (int i = 1; i &lt; k; ++i) L = L / __gcd(L, i) * i; for (int i = 0; i &lt; n; ++i) &#123; if (i) a[i] = (1ll * a[i - 1] * x + y) % M; ans = (ans + 1ll * (a[i] / L * L) * k % P * p[k - 1] % P) % P; ++f[a[i] % L]; &#125; for (int i = 1; i &lt;= k; ++i) for (int j = 0; j &lt; L; ++j) &#123; int c = f[j]; ans = (ans + 1ll * c * j % P * p[k - i] % P) % P; // 加上减去的贡献 f[j] = 1ll * c * (n - 1) % P; f[j - j % i] = (f[j - j % i] + c) % P; &#125; printf(\"%d\\n\", ans); return 0; &#125; 3.4 NOIP 死了，省选需要多考 50+ 分。 [CF955C] Sad powers *2100 Portal. 呆呆题。这是原题。气死人，为什么我平时不多刷点题！！！ 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 N = 1e18; int tot; i64 num[30000005]; int calc(i64 n) &#123; int idx = lower_bound(num + 1, num + tot + 1, n) - num; if (idx > tot || (idx &lt;= tot &amp;&amp; num[idx] > n)) --idx; return idx + sqrt(n); &#125; int main(void) &#123; for (i64 i = 2; i &lt;= 1000000; ++i) &#123; i64 k = i * i; for (; k &lt;= N / i; ) &#123; k *= i; i64 sq = sqrt(k); if (sq * sq != k) num[++tot] = k; &#125; &#125; sort(num + 1, num + tot + 1); tot = unique(num + 1, num + tot + 1) - (num + 1); int T; i64 l, r; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld%lld\", &amp;l, &amp;r); printf(\"%d\\n\", calc(r) - calc(l - 1)); &#125; return 0; &#125; [CF316D3] PE Lesson *2400 Portal. 呆呆题。如果只能交换一次可以简单 DP，交换两次可以变成任意一个人。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, cnt; int f[1000005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), cnt += (x == 1); f[0] = f[1] = 1; for (int i = 2; i &lt;= n; ++i) f[i] = (f[i - 1] + 1ll * (i - 1) * f[i - 2]) % P; int ans = f[cnt]; for (int i = n; i > cnt; --i) ans = 1ll * ans * i % P; printf(\"%d\\n\", ans); return 0; &#125; ？？？ 不知道。 3.20 不知道。 [SNOI2022] 倍增 Portal. 如果构造出来了一个答案，那么只需要在进位的地方后面填 B−1B-1B−1 即可。 枚举答案的长度、2×ai2\\times a_i2×ai​ 对应 apia_{p_i}api​​、每一位是否进位，这样在置换 ppp 上形成的环所构成的方程组可以解出来。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int ans[200005]; vector&lt;int> ans0[200005], ans1[200005]; void solve(int B) &#123; int p[20], w[20]; bool vis[20]; for (int n = 2;; ++n) &#123; // 2(a[n] a[n-1] a[1]) = (a[p[n]], a[p[n-1]], a[p[1]]) for (int i = 1; i &lt;= n; ++i) p[i] = i; do &#123; for (int s = 2; s &lt; 1 &lt;&lt; n; s += 2) &#123; // 必须有一个进位 for (int i = 1; i &lt;= n; ++i) w[i] = -1, vis[i] = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; int a[20] = &#123;0&#125;, wx[20] = &#123;0&#125;, wy[20] = &#123;0&#125;, m = 0; for (int j = i; !vis[j]; j = p[j]) vis[a[++m] = j] = 1; wx[1] = 1; wy[1] = 0; for (int j = 2; j &lt;= m; ++j) &#123; wx[j] = wx[j - 1] * 2; wy[j] = wy[j - 1] * 2 + (s >> a[j - 1] - 1 &amp; 1) - B * (s >> a[j - 1] &amp; 1); &#125; wx[1] = wx[m] * 2 - 1; wy[1] = wy[m] * 2 + (s >> a[m] - 1 &amp; 1) - B * (s >> a[m] &amp; 1); if (wy[1] % wx[1] != 0) continue; w[a[1]] = -wy[1] / wx[1]; for (int j = 2; j &lt;= m; ++j) w[a[j]] = wx[j] * w[a[1]] + wy[j]; &#125; bool flag = 1; for (int i = 1; i &lt;= n; ++i) flag &amp;= (0 &lt;= w[i] &amp;&amp; w[i] &lt; B); if (flag) &#123; ans[B] = n; for (int i = 1; i &lt;= n; ++i) if (s >> i &amp; 1) &#123; for (int j = n; j > i; --j) ans0[B].emplace_back(w[j]); for (int j = i; j >= 1; --j) ans1[B].emplace_back(w[j]); return; &#125; &#125; &#125; &#125; while (next_permutation(p + 1, p + n + 1)); &#125; &#125; int main(void) &#123; int T, n, B; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;B); if (!ans[B]) solve(B); if (ans[B] > n) &#123; puts(\"-1\"); continue; &#125; vector&lt;int> A; for (int x : ans0[B]) A.emplace_back(x); for (int i = 0; i &lt; n - ans[B]; ++i) A.emplace_back(B - 1); for (int x : ans1[B]) A.emplace_back(x); for (int x : A) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; 3.21 也不知道。 [ARC117E] Zero-Sum Ranges 2 Portal. 容易想到在前缀和序列上进行思考。设 cic_ici​ 代表 iii 在前缀和序列中的出现次数，那么答案为 ∑i(ci2)\\sum_{i}\\binom{c_i}{2}∑i​(2ci​​)。 按照前缀和从大到小的顺序（人 类 智 慧）开始放置，设 fi,j,kf_{i,j,k}fi,j,k​ 代表当前放了 iii 个数，答案是 kkk，有 jjj 个洞（下一层有 j+1j+1j+1 个需要放）。枚举当前层放置几个，转移很显然。 计算答案的时候需要合并正负前缀和。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 62; inline void add(i64 &amp;x, i64 t) &#123; x += t; &#125; int n, s; i64 C[65][65]; i64 f[65][65][3605]; int main(void) &#123; for (int i = 0; i &lt;= N; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; scanf(\"%d%d\", &amp;n, &amp;s); for (int i = 1; i &lt;= n + 1; ++i) f[i][i - 1][i * (i - 1) / 2] = 1; for (int i = 1; i &lt;= n * 2 + 1; ++i) &#123; int t = min(i * (i - 1) / 2, s); for (int j = 0; j &lt;= i; ++j) for (int k = 0; k &lt;= t; ++k) if (f[i][j][k]) &#123; for (int x = j + 2; x &lt;= n * 2 + 1 - i; ++x) // 下一层放置 x 个 add(f[i + x][x - (j + 2)][k + x * (x - 1) / 2], f[i][j][k] * C[x - 1][j + 1]); &#125; &#125; i64 ans = f[n * 2 + 1][0][s]; for (int i = 2; i &lt;= n * 2 + 1; ++i) for (int j = 1; j &lt;= n + 1; ++j) for (int k = 0; k &lt;= s; ++k) ans += f[i][j][k] * f[n * 2 + 1 - i][j - 1][s - k]; printf(\"%lld\\n\", ans); return 0; &#125; 3.23 休闲之余做一点奇怪的（这一天开始了 2020 集训队作业）。 [AGC001B] Mysterious Light Portal. 先照一次之后就是平行四边形，直接递归即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; i64 ans; void calc(i64 n, i64 x) &#123; if (n % x == 0) return ans += n * 2 - x, void(); ans += (n - n % x) * 2; calc(x, n % x); &#125; int main(void) &#123; i64 n, x; cin >> n >> x; ans = n; n -= x; calc(max(n, x), min(n, x)); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; [AGC001C] Shorten Diameter Portal. 按照直径的奇偶性枚举点或边即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, k, ans = 1e9, cnt; bool vis[2005], vis2[2005], *v; vector&lt;int> G[2005]; vector&lt;pair&lt;int, int>> E; void dfs(int x, int dis, int len) &#123; if (dis > len) return; ++cnt; v[x] = 1; for (int y : G[x]) if (!v[y]) dfs(y, dis + 1, len); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E.emplace_back(u, v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; if (k % 2 == 0) &#123; for (int i = 1; i &lt;= n; ++i) &#123; v = vis; memset(vis, 0, sizeof vis); dfs(i, cnt = 0, k / 2); ans = min(ans, n - cnt); &#125; &#125; else &#123; for (auto [x, y] : E) &#123; v = vis; memset(vis, 0, sizeof vis); dfs(x, 0, k / 2); v = vis2; memset(vis2, 0, sizeof vis2); dfs(y, 0, k / 2); cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += vis[i] | vis2[i]; ans = min(ans, n - cnt); &#125; &#125; return printf(\"%d\\n\", ans), 0; &#125; 3.25 ？？？ [AGC001D] Arrays and Palindrome Portal. 出现两个以上的奇数无解，否则错位一下就行。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, t; int a[100005], b[100005], cnt[2]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", a + i), ++cnt[a[i] &amp; 1]; if (cnt[1] > 2) return puts(\"Impossible\"), 0; if (m == 1) &#123; if (a[1] == 1) printf(\"1\\n1\\n1\\n\"); else printf(\"%d\\n2\\n1 %d\\n\", a[1], a[1] - 1); return 0; &#125; sort(a + 1, a + m + 1, [&amp;](int x, int y) &#123; return x % 2 > y % 2; &#125;); printf(\"%d \", a[1]); for (int i = 3; i &lt;= m; ++i) printf(\"%d \", a[i]); printf(\"%d\\n\", a[2]); b[++t] = a[1] + 1; for (int i = 3; i &lt;= m; ++i) b[++t] = a[i]; if (a[2] > 1) b[++t] = a[2] - 1; printf(\"%d\\n\", t); for (int i = 1; i &lt;= t; ++i) printf(\"%d \", b[i]); putchar('\\n'); return 0; &#125; [AGC001E] BBQ Hard Portal. 可以抽象成 (0,0)→(ai+aj,bi+bj)(0,0)\\rightarrow(a_i+a_j,b_i+b_j)(0,0)→(ai​+aj​,bi​+bj​)，也就是 (−ai,−bi)→(aj,bj)(-a_i,-b_i)\\rightarrow(a_j,b_j)(−ai​,−bi​)→(aj​,bj​)，就可以直接统计了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int D = 2010, N = 10000; int poww(int a, int b) &#123; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int n; int a[200005], b[200005]; int fac[10005], ifac[10005], f[4100][4100]; int C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; int main(void) &#123; for (int i = fac[0] = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % P; ifac[N] = poww(fac[N], P - 2); for (int i = N - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", a + i, b + i), ++f[D - a[i]][D - b[i]]; for (int i = 1; i &lt;= D * 2; ++i) for (int j = 1; j &lt;= D * 2; ++j) f[i][j] = (f[i][j] + f[i - 1][j] + f[i][j - 1]) % P; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; ans = (ans + f[D + a[i]][D + b[i]]) % P; ans = (ans - C((a[i] + b[i]) * 2, a[i] * 2)) % P; &#125; printf(\"%lld\\n\", (1ll * ans * poww(2, P - 2) % P + P) % P); return 0; &#125; 3.26 To the crazy ones, wish us good luck. [CF1542E2] Abnormal Permutation Pairs (hard version) Portal. 对于第一条限制，我们设相同前缀的长度为 LLL，则 pL+1&lt;qL+1p_{L+1}&lt;q_{L+1}pL+1​&lt;qL+1​。后面的贡献统计出来之后，前面显然是可以随意排的。 设 fi,jf_{i,j}fi,j​ 代表 iii 阶排列，ppp 的逆序对数减去 qqq 的逆序对数为 jjj 时的方案数。设当前要填 p1p_1p1​ 和 q1q_1q1​ 在 i−1i-1i−1 阶排列的首位，转移是容易的： fi,j=∑p1=1i∑q1=1ifi−1,j−p1+q1f_{i,j}=\\sum_{p_1=1}^i\\sum_{q_1=1}^i f_{i-1,j-p_1+q_1} fi,j​=p1​=1∑i​q1​=1∑i​fi−1,j−p1​+q1​​ 实际上我们只关心 p1−q1p_1-q_1p1​−q1​ 的值，因此枚举 d=p1−q1d=p_1-q_1d=p1​−q1​： fi,j=∑∣d∣&lt;ifi−1,j−d(i−∣d∣)f_{i,j}=\\sum_{|d|&lt;i} f_{i-1,j-d} (i-|d|) fi,j​=∣d∣&lt;i∑​fi−1,j−d​(i−∣d∣) 拆开后发现维护 fi,jf_{i,j}fi,j​ 和 j×fi,jj\\times f_{i,j}j×fi,j​ 关于 jjj 的前缀和即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 505, D = N * (N - 1) / 2; int n, M; int C[N][N], fac[N]; int A(int n, int m) &#123; return 1ll * C[n][m] * fac[m] % M; &#125; i64 f[D * 2 + 10], s1[D * 2 + 10], s2[D * 2 + 10]; int main(void) &#123; cin >> n >> M; f[D] = 1; for (int i = 0; i &lt;= n; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % M; for (int i = fac[0] = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % M; i64 ans = 0; for (int i = 2; i &lt;= n; ++i) &#123; // i 阶排列 int lim = i * (i - 1) / 2; i64 c = 0; for (int j = D - lim - i; j &lt;= D + lim + i; ++j) s1[j] = (s1[j - 1] + f[j]) % M, s2[j] = (s2[j - 1] + 1ll * f[j] * j % M) % M; for (int j = D - lim; j &lt;= D + lim; ++j) &#123; f[j] = (1ll * (s1[j + i] - s1[j]) * (i + j) % M - s2[j + i] + s2[j]) % M; if (j > D) c = (c + f[j]) % M; &#125; ans = (ans + 1ll * c * A(n, n - i) % M) % M; for (int j = D - lim; j &lt;= D + lim; ++j) f[j] = (f[j] + 1ll * ((s1[j] - s1[j - i]) * (i - j) % M + s2[j] - s2[j - i])) % M; &#125; return printf(\"%lld\\n\", (ans % M + M) % M), 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"数论进阶","slug":"notes/数学/ntex","date":"2023-02-16T00:00:00.000Z","updated":"2023-02-16T00:00:00.000Z","comments":true,"path":"7f8fede0/","link":"","permalink":"https://james1badcreeper.github.io/7f8fede0/","excerpt":"高级的数论知识更为困难，但也更有意思。本文将介绍省选以内的常见数论知识点，进一步学习模意义下的数论、数论函数和整除性相关问题，并通过题目介绍它们的应用。","text":"高级的数论知识更为困难，但也更有意思。本文将介绍省选以内的常见数论知识点，进一步学习模意义下的数论、数论函数和整除性相关问题，并通过题目介绍它们的应用。 整除性问题 与整除相关的内容是数论的根基，我们再来梳理一下这些内容。 算术基本定理 之前介绍过算术基本定理的标准分解式： n=∏piαin=\\prod p_i^{\\alpha_i} n=∏piαi​​ 它还可以写成 ppp 进赋值序列。记 vp(n)=max⁡{k∈N∣pk∣n}v_p(n)=\\max\\{k\\in \\mathbb{N}\\mid p^k\\mid n\\}vp​(n)=max{k∈N∣pk∣n}，定义 nnn 的 ppp 进赋值序列为：{v2(n),v3(n),v5(n),v7(n),⋯ }\\{v_2(n),v_3(n),v_5(n),v_7(n),\\cdots\\}{v2​(n),v3​(n),v5​(n),v7​(n),⋯}。 这有什么用呢？ppp 进赋值序列是从数论角度刻画正整数的重要工具，在这个视角下，每个整数均可以定位在一个无穷维空间上的整点，每个维度都对应一个素数。 取模与整除 首先：a mod b=a−b×⌊ab⌋a\\bmod b=a-b\\times \\left\\lfloor\\frac{a}{b}\\right\\rflooramodb=a−b×⌊ba​⌋，实现了取模与整除的转化，需要根据具体情况分析使用哪种形式。 而 ⌊⌊ab⌋c⌋=⌊abc⌋\\left\\lfloor\\frac{\\lfloor\\frac{a}{b}\\rfloor}{c}\\right\\rfloor=\\left\\lfloor\\frac{a}{bc}\\right\\rfloor⌊c⌊ba​⌋​⌋=⌊bca​⌋ 可以将一部分的除法问题转化为乘法问题。 数论分块 数论分块。⌊ni⌋\\left\\lfloor\\frac{n}{i}\\right\\rfloor⌊in​⌋ 只有 O(n)O(\\sqrt{n})O(n​) 中不同的取值，并且每一种取值都是一个连续的区间。 比如光速幂是利用这一点来实现的，这个技巧也可以在 O(n)O(\\sqrt{n})O(n​) 时间内枚举到所有区间。 最经典的应用就是快速计算 ∑i=1nf(i)g(⌊ni⌋)\\sum_{i=1}^n f(i)g\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)∑i=1n​f(i)g(⌊in​⌋)，需要 O(1)O(1)O(1) 计算 ∑i=lrf(i)\\sum_{i=l}^{r}f(i)∑i=lr​f(i)，然后将 ggg 相同的打包计算。 使得 ⌊ni⌋=⌊nj⌋\\lfloor\\frac{n}{i}\\rfloor=\\lfloor\\frac{n}{j}\\rfloor⌊in​⌋=⌊jn​⌋ 成立的最大满足 i≤j≤ni\\le j\\le ni≤j≤n 的块的右端点为 ⌊n⌊ni⌋⌋\\left\\lfloor\\cfrac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor⌊⌊in​⌋n​⌋。为什么？令 k=⌊ni⌋k=\\lfloor\\frac{n}{i}\\rfloork=⌊in​⌋，可知 k≤nik\\le \\frac{n}{i}k≤in​，那么 ⌊nk⌋≥i\\lfloor\\frac{n}{k}\\rfloor\\ge i⌊kn​⌋≥i，所以 j=nij=\\frac{n}{i}j=in​。时间复杂度 O(n)O(\\sqrt{n})O(n​)。 模板，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; i64 H(i64 n) &#123; i64 res = 0; i64 l = 1, r; while (l &lt;= n) &#123; r = n / (n / l); res += (r - l + 1) * (n / l); l = r + 1; &#125; return res; &#125; int main(void) &#123; int T; i64 x; cin >> T; while (T--) &#123; cin >> x; cout &lt;&lt; H(x) &lt;&lt; \"\\n\"; &#125; return 0; &#125; 同样可以扩展到有多个形如 ⌊ni⌋\\lfloor\\frac{n}{i}\\rfloor⌊in​⌋ 的求和，只需要对 rrr 取 min⁡\\minmin，时间复杂度为 O(∑n)O(\\sum \\sqrt{n})O(∑n​)。 扩展欧几里得算法 辗转相除法和更相减损法是一个很重要的结构，出现时一般都伴随着 gcd⁡\\gcdgcd 相关的结论。 类欧几里得算法 大致意义是使用一个类似辗转相除法的方法进行函数求和。 设： f(a,b,c,n)=∑i=0n⌊ai+bc⌋f(a,b,c,n)=\\sum_{i=0}^n \\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor f(a,b,c,n)=i=0∑n​⌊cai+b​⌋ 需要给出一个 O(log⁡n)O(\\log n)O(logn) 的算法。 数论分块似乎应对不了这样的求和，因此我们考虑一个奇怪的方式。要将 a≥ca\\ge ca≥c 或 b≥b\\geb≥ 的情况转化为 a,b&lt;ca,b&lt;ca,b&lt;c。 我们有： f(a,b,c,n)=∑i=0n⌊(a mod c)i+(a−a mod c)i+(b mod c)+(b−b mod c)c⌋=∑i=0n⌊(a mod c)i+(b mod c)c⌋+(a−a mod c)ic+b−b mod cc\\begin{aligned} f(a,b,c,n) &amp;=\\sum_{i=0}^n \\left\\lfloor\\frac{(a\\bmod c)i+(a-a\\bmod c)i+(b\\bmod c)+(b-b\\bmod c)}{c}\\right\\rfloor\\\\ &amp;=\\sum_{i=0}^n \\left\\lfloor\\frac{(a\\bmod c)i+(b\\bmod c)}{c}\\right\\rfloor +\\frac{(a-a\\bmod c)i}{c}+\\frac{b-b\\bmod c}{c} \\end{aligned} f(a,b,c,n)​=i=0∑n​⌊c(amodc)i+(a−amodc)i+(bmodc)+(b−bmodc)​⌋=i=0∑n​⌊c(amodc)i+(bmodc)​⌋+c(a−amodc)i​+cb−bmodc​​ 注意第二行中的后两个一定是可以整除的。 因此原式等于： =∑i=0n⌊(a mod c)i+(b mod c)c⌋+⌊ac⌋x+⌊bc⌋=n(n+1)2⌊ac⌋+(n+1)⌊bc⌋+∑i=0n⌊(a mod c)i+(b mod c)c⌋=n(n+1)2⌊ac⌋+(n+1)⌊bc⌋+f(a mod c,b mod c,c,n)\\begin{aligned} &amp;=\\sum_{i=0}^n \\left\\lfloor\\frac{(a\\bmod c)i+(b\\bmod c)}{c}\\right\\rfloor+\\left\\lfloor\\frac{a}{c}\\right\\rfloor x+\\left\\lfloor\\frac{b}{c}\\right\\rfloor \\\\ &amp;=\\frac{n(n+1)}{2}\\left\\lfloor\\frac{a}{c}\\right\\rfloor+(n+1)\\left\\lfloor\\frac{b}{c}\\right\\rfloor+ \\sum_{i=0}^n\\left\\lfloor\\frac{\\left(a\\bmod c\\right)i+\\left(b\\bmod c\\right)}{c} \\right\\rfloor\\\\ &amp;=\\frac{n(n+1)}{2}\\left\\lfloor\\frac{a}{c}\\right\\rfloor +(n+1)\\left\\lfloor\\frac{b}{c}\\right\\rfloor+f(a\\bmod c,b\\bmod c,c,n) \\end{aligned} ​=i=0∑n​⌊c(amodc)i+(bmodc)​⌋+⌊ca​⌋x+⌊cb​⌋=2n(n+1)​⌊ca​⌋+(n+1)⌊cb​⌋+i=0∑n​⌊c(amodc)i+(bmodc)​⌋=2n(n+1)​⌊ca​⌋+(n+1)⌊cb​⌋+f(amodc,bmodc,c,n)​ 现在有 a,b&lt;ca,b&lt;ca,b&lt;c 了，然后呢？式子中只有 iii 一个变量。原式中的条件是 0≤i≤n0\\le i\\le n0≤i≤n，贡献是 ⌊ai+bc⌋\\left\\lfloor\\cfrac{ai+b}{c}\\right\\rfloor⌊cai+b​⌋。考虑将贡献合并计算，将式子改为： ∑i=0n∑j=0⌊ai+bc⌋−11\\sum_{i=0}^n\\sum_{j=0}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor-1}1\\\\ i=0∑n​j=0∑⌊cai+b​⌋−1​1 这个 jjj 被 iii 限制着，不好做，我们交换 i,ji,ji,j，让 jjj 被 nnn 限制： ∑j=0⌊an+bc⌋−1∑i=0n[j&lt;⌊ai+bc⌋]\\sum_{j=0}^{\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor-1}\\sum_{i=0}^n\\left[j&lt;\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor\\right] j=0∑⌊can+b​⌋−1​i=0∑n​[j&lt;⌊cai+b​⌋] 万能欧几里得算法 万能欧几里得可以解决几乎全部类欧几里得算法能解决的问题。其优势在于，不管要求什么式子的值，代码都类似。 数论函数 我们一般研究数论函数中的积性函数。 常见积性函数 单位函数 ϵ(n)=[n=1]\\epsilon(n)=[n=1]ϵ(n)=[n=1]，是完全积性函数。 常数函数 1(n)=11(n)=11(n)=1，是完全积性函数。 恒等函数 id⁡k(n)=nk\\operatorname{id}_k(n)=n^kidk​(n)=nk，是完全积性函数，当 k=1k=1k=1 时可以省略不写。 除数函数 σk(n)=∑d∣ndk\\sigma_k(n)=\\sum_{d\\mid n}d^kσk​(n)=∑d∣n​dk。这样的话，σ0(n)=τ(n)\\sigma_0(n)=\\tau(n)σ0​(n)=τ(n)，σ1(n)\\sigma_1(n)σ1​(n) 代表约数和，有 σk(n)=∏i=1s(∑j=0αipijk)=∏i=1sσk(piαi)\\sigma_k(n)=\\prod_{i=1}^s\\left(\\sum_{j=0}^{\\alpha_i}p_i^{jk}\\right)=\\prod_{i=1}^s\\sigma_k(p_i^{\\alpha_i})σk​(n)=∏i=1s​(∑j=0αi​​pijk​)=∏i=1s​σk​(piαi​​)。 欧拉函数，φ(n)\\varphi(n)φ(n) 代表 1∼n1\\sim n1∼n 中与 nnn 互质的数的个数，你肯定不会忘记它。 本质不同质因子个数函数 ω(n)=∑p[p∣n]\\omega(n)=\\sum_{p}[p\\mid n]ω(n)=∑p​[p∣n]。 线性筛求积性函数 方法很简单，记录 lowlowlow 表示最小质因子的最高次幂，然后分类讨论一下即可。 for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[++tot] = i, f[i] = ..., low[i] = i; // 单独算 f(p) for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; // i 与 p 不互质 low[i * prime[j]] = low[i] * prime[j]; if (i == low[i]) f[i * prime[j]] = ...; // i = p^k，单独算 f(p^&#123;k+1&#125;) else f[i * prime[j]] = f[i / low[i]] * f[low[i] * prime[j]]; break; &#125; low[i * prime[j]] = prime[j]; f[i * prime[j]] = f[i] * f[prime[j]]; // i 与 p 互质，f(ip) = f(i)f(p) &#125; &#125; 狄利克雷卷积 狄利克雷卷积是数论函数的基本运算。定义： h(n)=∑d∣nf(d)g(nd)h(n)=\\sum_{d\\mid n}f(d)g\\left(\\frac{n}{d}\\right) h(n)=d∣n∑​f(d)g(dn​) 简记为 h=f∗gh=f*gh=f∗g。 狄利克雷卷积具有交换律、结合律和分配律。 首先，ϵ∗f=f\\epsilon*f=fϵ∗f=f。因此单位函数 ϵ\\epsilonϵ 为狄利克雷卷积的单位元，那么就可以定义数论函数的逆元 f−1f^{-1}f−1，满足 f∗f−1=ϵf*f^{-1}=\\epsilonf∗f−1=ϵ。 一个 fff 存在逆元，当且仅当 f(1)≠0f(1)\\ne 0f(1)=0，并且逆元唯一。f=gf=gf=g 的充要条件是 f∗h=g∗h(h(1)≠1)f*h=g*h(h(1)\\ne 1)f∗h=g∗h(h(1)=1)。这样一来有 g(n)=−∑d∣n,d≠ng(d)f(nd)f(1)g(n) = -\\cfrac{\\sum\\limits_{d \\mid n, d \\neq n} g(d)f\\left(\\dfrac n d\\right)} {f(1)}g(n)=−f(1)d∣n,d=n∑​g(d)f(dn​)​。 积性函数的狄利克雷卷积是积性函数，积性函数的逆元也是积性函数。 以下是一些常用的狄利克雷卷积： 1∗1=τ1*1=\\tau1∗1=τ， φ∗1=id⁡\\varphi *1=\\operatorname{id}φ∗1=id。 狄利克雷前缀和 任意数论函数 fff 卷常数函数 111 等价于做 fff 的狄利克雷前缀和，即：g=f∗1,g(n)=∑d∣nf(d)g=f*1,g(n)=\\sum_{d\\mid n}f(d)g=f∗1,g(n)=∑d∣n​f(d)。含义是对每个 nnn 计算给定数论函数在其所因数处的取值和。 将每个数写成无穷序列 an={c1,c2,⋯ }a_n=\\{c_1,c_2,\\cdots\\}an​={c1​,c2​,⋯} 表示 n=∏picin=\\prod p_i^{c_i}n=∏pici​​。由于 x∣yx\\mid yx∣y 的充要条件为 ax(ci)≤ay(ci)a_x(c_i)\\le a_y(c_i)ax​(ci​)≤ay​(ci​)，因此 f∗1f*1f∗1 可以看成对下标做其无穷序列的高维前缀和。 模板，采用高维前缀和实现即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef unsigned int uint; uint n, seed; inline uint getnext(void) &#123; seed ^= seed &lt;&lt; 13, seed ^= seed >> 17, seed ^= seed &lt;&lt; 5; return seed; &#125; bool v[20000005]; uint prime[10000005], tot; uint a[20000005]; int main(void) &#123; cin >> n >> seed; for (int i = 1; i &lt;= n; ++i) a[i] = getnext(); for (int i = 2; i &lt;= n; ++i) &#123; if (!v[i]) prime[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) for (int j = 1; j * prime[i] &lt;= n; ++j) a[j * prime[i]] += a[j]; uint ans = 0; for (int i = 1; i &lt;= n; ++i) ans ^= a[i]; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0; &#125; 莫比乌斯反演 我们定义莫比乌斯函数： μ(n)={1,n=1,0,∃d&gt;1,d2∣n,(−1)ω(n),otherwise.\\mu(n)=\\begin{cases}1,&amp;n=1,\\\\0,&amp;\\exists d&gt;1,d^{2}\\mid n, \\\\(-1)^{\\omega(n)},&amp;\\mathrm{otherwise}. \\end{cases} μ(n)=⎩⎨⎧​1,0,(−1)ω(n),​n=1,∃d&gt;1,d2∣n,otherwise.​ 使用线性筛求解莫比乌斯函数 mu[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; mu[i * prime[j]] = 0; break; &#125; mu[i * prime[j]] = -mu[i]; &#125; &#125; 我们定义莫比乌斯函数： μ(n)={1,n=1,0,∃d&gt;1,d2∣n,(−1)ω(n),otherwise.\\mu(n)=\\begin{cases}1,&amp;n=1,\\\\0,&amp;\\exists d&gt;1,d^{2}\\mid n, \\\\(-1)^{\\omega(n)},&amp;\\mathrm{otherwise}. \\end{cases} μ(n)=⎩⎨⎧​1,0,(−1)ω(n),​n=1,∃d&gt;1,d2∣n,otherwise.​ 为什么要定义这样一个奇怪的函数呢？实际上它是在对 N\\mathbb{N}N 做容斥。设 g(n)=∑n∣df(d)g(n)=\\sum_{n\\mid d} f(d)g(n)=∑n∣d​f(d)，已知 ggg，要求 f(1)f(1)f(1)。f(1)f(1)f(1) 等于 ggg 在 111 的倍数处取的取值和，减去质数处的取值和，但是多减了两个质数乘积的地方，因此还要加回来。这就是容斥原理，容斥系数是 (−1)ω(n)(-1)^{\\omega(n)}(−1)ω(n)。比如求无平方因子的数的个数就是像这样容斥。 莫比乌斯函数不仅是积性函数，还满足： ∑d∣nμ(d)={1,n=1,0,n≠1.\\sum_{d\\mid n}\\mu(d)=\\begin{cases} 1,&amp;n=1,\\\\ 0,&amp;n\\neq 1. \\end{cases} d∣n∑​μ(d)={1,0,​n=1,n=1.​ 上述式子描述的其实是 μ∗1=ϵ\\mu*1=\\epsilonμ∗1=ϵ，这是莫比乌斯函数最重要的性质，其引出了性质：∑d∣nμ(d)=[n=1]\\sum_{d\\mid n}\\mu(d)=[n=1]∑d∣n​μ(d)=[n=1]，我们可以将这个判断式转化为和式，这样更加方便计算。两者的转化称之为莫比乌斯反演。 莫比乌斯反演有以下结论： 若 g=f∗1g=f*1g=f∗1，则 f=g∗μf=g*\\muf=g∗μ。 若 g(n)=∑n∣df(d)g(n)=\\sum_{n\\mid d}f(d)g(n)=∑n∣d​f(d)，则 f(n)=∑n∣dμ(dn)g(d)f(n)=\\sum_{n\\mid d} \\mu\\left(\\dfrac d n\\right) g(d)f(n)=∑n∣d​μ(nd​)g(d)。这也被称为莫比乌斯变换。 由于 φ∗1=id⁡\\varphi * 1 = \\operatorname{id}φ∗1=id，因此 id⁡∗μ=φ\\operatorname{id}*\\mu =\\varphiid∗μ=φ。 一个常见的应用是，[gcd⁡(i,j)=1]=∑d∣gcd⁡(i,j)μ(d)[\\gcd(i,j)=1]=\\sum_{d\\mid \\gcd(i,j)}\\mu(d)[gcd(i,j)=1]=∑d∣gcd(i,j)​μ(d)。虽然看起来这像是废话，但这一步将 i,ji,ji,j 互质转化为了枚举 gcd⁡(i,j)\\gcd(i,j)gcd(i,j) 的约数 ddd。如果 i,ji,ji,j 同样需要枚举，那么枚举 ddd 并计算合法的 i,ji,ji,j 个数（当且仅当 d∣i,d∣jd\\mid i,d\\mid jd∣i,d∣j）即可。具体来说： ∑i=1n∑j=1m[gcd⁡(i,j)=1]=∑i=1n∑j=1m∑d∣gcd⁡(i,j)μ(d)=∑d=1min⁡(n,m)μ(d)∑i=1n∑j=1m[d∣i∧d∣j]=∑d=1min⁡(n,m)μ(d)⌊nd⌋⌊md⌋\\begin{aligned} \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [\\gcd(i, j) = 1] &amp; = \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m \\sum\\limits_{d\\mid \\gcd(i, j)} \\mu(d) \\\\ &amp; = \\sum\\limits_{d = 1} ^ {\\min(n, m)} \\mu(d) \\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [d\\mid i\\land d\\mid j] \\\\ &amp; = \\sum\\limits_{d = 1} ^ {\\min(n, m)} \\mu(d) \\left\\lfloor \\dfrac n d \\right\\rfloor \\left\\lfloor \\dfrac m d \\right\\rfloor \\\\ \\end{aligned} i=1∑n​j=1∑m​[gcd(i,j)=1]​=i=1∑n​j=1∑m​d∣gcd(i,j)∑​μ(d)=d=1∑min(n,m)​μ(d)i=1∑n​j=1∑m​[d∣i∧d∣j]=d=1∑min(n,m)​μ(d)⌊dn​⌋⌊dm​⌋​ 就可以直接使用数论分块在 O(n+m)O(\\sqrt{n}+\\sqrt{m})O(n​+m​) 的时间内计算。 关于莫比乌斯反演的更多应用请在题目中寻找。 欧拉反演 欧拉函数有一条性质：n=∑d∣nφ(d)n = \\sum_{d\\mid n} \\varphi(d)n=∑d∣n​φ(d)。 用与莫比乌斯反演一样的套路，有： ∑i=1n∑j=1mgcd⁡(i,j)=∑i=1n∑j=1m∑d∣gcd⁡(i,j)φ(d)=∑d=1min⁡(n,m)φ(d)∑i=1n∑j=1m[d∣i∧d∣j]=∑d=1min⁡(n,m)φ(d)⌊nd⌋⌊md⌋\\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^m\\gcd(i,j)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{d\\mid \\gcd(i,j)} \\varphi(d)\\\\ &amp;=\\sum_{d=1}^{\\min(n,m)}\\varphi(d)\\sum\\limits_{i = 1} ^ n \\sum\\limits_{j = 1} ^ m [d\\mid i\\land d\\mid j] \\\\ &amp;=\\sum\\limits_{d = 1} ^ {\\min(n, m)} \\varphi(d) \\left\\lfloor \\frac n d \\right\\rfloor \\left\\lfloor \\frac m d \\right\\rfloor \\end{aligned} i=1∑n​j=1∑m​gcd(i,j)​=i=1∑n​j=1∑m​d∣gcd(i,j)∑​φ(d)=d=1∑min(n,m)​φ(d)i=1∑n​j=1∑m​[d∣i∧d∣j]=d=1∑min(n,m)​φ(d)⌊dn​⌋⌊dm​⌋​ 这就是欧拉反演的公式。 模意义下的数论 数论算法的综合应用 Problemset 这里的题可能有一些难，也会与别的算法综合，但是都应该完成。 简单问题 不适合放在《数论初步》，但是又没用到本文介绍的知识点的简单题。 [SP5971] LCMSUM - LCM Sum Portal. ∑i=1nlcm⁡(i,n)=n∑i=1nigcd⁡(i,n)=n∑d∣n∑i=1nid[gcd⁡(i,n)=d]=n∑d∣n∑i=1ndi[gcd⁡(i,nd)=1]\\begin{aligned} \\sum\\limits_{i = 1} ^ n \\operatorname{lcm}(i, n) &amp; = n \\sum\\limits_{i = 1} ^ n \\frac{i}{\\gcd(i, n)} \\\\ &amp; = n \\sum\\limits_{d\\mid n} \\sum\\limits_{i = 1} ^ n \\frac{i}{d} [\\gcd(i, n) = d] \\\\ &amp; = n \\sum\\limits_{d\\mid n} \\sum\\limits_{i = 1} ^ {\\frac n d} i \\left[\\gcd\\left(i, \\frac n d\\right) = 1\\right] \\end{aligned} i=1∑n​lcm(i,n)​=ni=1∑n​gcd(i,n)i​=nd∣n∑​i=1∑n​di​[gcd(i,n)=d]=nd∣n∑​i=1∑dn​​i[gcd(i,dn​)=1]​ 后面这个东西是在 ddd 以内所有与 ddd 互质的数的和，是欧拉函数的结论，答案是 n×φ(n)2\\frac{n\\times \\varphi(n)}{2}2n×φ(n)​，注意 d=1d=1d=1 要特判掉。 线性筛出 1∗id⁡∗ φ1*\\operatorname{id}*\\ \\varphi1∗id∗ φ 即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 1000000; int tot, prime[500005], low[1000005]; i64 f[1000005]; int main(void) &#123; f[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!f[i]) prime[++tot] = low[i] = i, f[i] = 1 + 1ll * i * (i - 1); for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; if (i % prime[j] == 0) &#123; low[i * prime[j]] = low[i] * prime[j]; if (i == low[i]) f[i * prime[j]] = f[i] + 1ll * (i * prime[j]) * i * (prime[j] - 1); else f[i * prime[j]] = f[i / low[i]] * f[low[i] * prime[j]]; break; &#125; low[i * prime[j]] = prime[j]; f[i * prime[j]] = f[i] * f[prime[j]]; &#125; &#125; int T, n; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); printf(\"%lld\\n\", (f[n] + 1) * n / 2); &#125; return 0; &#125; [六省联考 2017] 相逢是问候 Portal.给定 p,cp,cp,c，维护一个正整数序列，支持区间替换为 caic^{a_i}cai​，区间求和（对 ppp 取模）。 数论分块 这里的数论分块不会很难，因为其往往会和莫比乌斯反演和杜教筛综合。 [Luogu P2424] 约数和 Portal. 将 fff 做前缀和之后就可以直接使用数论分块计算。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; i64 H(int n) &#123; i64 res = 0, l = 1, r; while (l &lt;= n) &#123; r = n / (n / l); res += (l + r) * (r - l + 1) * (n / l) / 2; l = r + 1; &#125; return res; &#125; int main(void) &#123; int x, y; cin >> x >> y; cout &lt;&lt; H(y) - H(x - 1) &lt;&lt; \"\\n\"; return 0; &#125; [CQOI2007] 余数求和 Portal. 将取模拆开即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int main(void) &#123; i64 n, k; scanf(\"%lld%lld\", &amp;n, &amp;k); i64 ans = n * k; for (i64 l = 1, r; l &lt;= n; l = r + 1) &#123; if (k / l != 0) r = min(n, k / (k / l)); else break; ans -= (l + r) * (r - l + 1) * (k / l) / 2; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [CTT2012] 模积和 Portal. 直接数论分块即可，需要将式子拆开。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 19940417; i64 n, m; i64 a, b, c; i64 calc(int n) &#123; return 3323403ll * n % P * (n + 1) % P * (n * 2 % P + 1) % P; &#125; i64 calc(int l, int r) &#123; return calc(r) - calc(l - 1); &#125; int main(void) &#123; cin >> n >> m; if (n > m) swap(n, m); a = n * n % P; b = m * m % P; c = n * m % P * n % P; for (int l = 1, r = 0; l &lt;= n; l = r + 1) &#123; r = n / (n / l); a = (a - 1ll * (l + r) * (r - l + 1) / 2 % P * (n / l) % P) % P; &#125; for (int l = 1, r = 0; l &lt;= m; l = r + 1) &#123; r = m / (m / l); b = (b - 1ll * (l + r) * (r - l + 1) / 2 % P * (m / l) % P) % P; &#125; for (int l = 1, r = 0; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); i64 len = 1ll * (l + r) * (r - l + 1) / 2 % P; c = (c + calc(l, r) * (n / l) % P * (m / l) % P - m * len % P * (n / l) % P - n * len % P * (m / l) % P) % P; &#125; cout &lt;&lt; ((a * b % P - c) % P + P) % P &lt;&lt; \"\\n\"; return 0; &#125; 莫比乌斯反演 带有特殊技巧的题目会标注。 莫比乌斯反演往往只能去掉艾弗森括号（虽然莫比乌斯函数自身还有容斥的性质），因此重要的反而是推式子。 [HAOI2011] Problem b Portal. 利用二维差分进行计算，而且发现只有 kkk 的倍数有用，因此可以将所有数除以 kkk 转变为求互质。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int mu[50005], prime[50005], tot; bool v[50005]; i64 calc(int x, int y) &#123; i64 res = 0; for (int l = 1, r; l &lt;= x &amp;&amp; l &lt;= y; l = r + 1) &#123; r = min(x / (x / l), y / (y / l)); res += 1ll * (mu[r] - mu[l - 1]) * (x / l) * (y / l); &#125; return res; &#125; int main(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= 50000; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= 50000; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 2; i &lt;= 50000; ++i) mu[i] += mu[i - 1]; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int a, b, c, d, k; scanf(\"%d%d%d%d%d\", &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); a = (a - 1) / k, c = (c - 1) / k, b /= k, d /= k; printf(\"%d\\n\", calc(a, c) - calc(a, d) - calc(b, c) + calc(b, d)); &#125; return 0; &#125; 欧拉反演 | [NOI2010] 能量采集 Portal. 要求的显然是： ∑i=1n∑i=1m2×gcd⁡(i,j)−1\\sum_{i=1}^n\\sum_{i=1}^m 2\\times \\gcd(i,j)-1 i=1∑n​i=1∑m​2×gcd(i,j)−1 然后欧拉反演直接拍上去。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int prime[50005], tot; i64 phi[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); if (m > n) swap(n, m); phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!phi[i]) prime[++tot] = i, phi[i] = i - 1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125; for (int i = 1; i &lt;= n; ++i) phi[i] += phi[i - 1]; i64 ans = 0; for (int l = 1, r; l &lt;= m; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans += 1ll * (phi[r] - phi[l - 1]) * (n / l) * (m / l); &#125; printf(\"%lld\\n\", 2 * ans - 1ll * n * m); return 0; &#125; 莫比乌斯函数与容斥原理 | [Luogu P4318] 完全平方数 Portal. 设 f(n)f(n)f(n) 代表 1∼n1\\sim n1∼n 中无平方因子的数的个数，然后二分答案，找到 f(r)≥Kf(r)\\ge Kf(r)≥K 的最小 rrr。现在考虑如何计算 fff。 首先去掉 22,32,⋯ ,p22^2,3^2,\\cdots,p^222,32,⋯,p2 的倍数，但是其中有的会算入两次，所以对于 626^262 这种要减去。而像 424^242 这种在 222^222 时已经算完了，不能统计。发现这就是莫比乌斯函数，因此莫比乌斯函数是在对 N\\mathbb{N}N 做容斥。答案是： f(n)=∑iμ(i)⌊ni2⌋f(n)=\\sum_{i}\\mu(i)\\left\\lfloor\\frac n {i^2}\\right\\rfloor f(n)=i∑​μ(i)⌊i2n​⌋ 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 200000; int mu[200005], prime[100005], tot; bool v[200005]; int calc(int n) &#123; int res = 0; for (int i = 1; i * i &lt;= n; ++i) res += mu[i] * (n / (i * i)); return res; &#125; int main(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; int T, n; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); int L = 0, R = 2000000001; while (L + 1 != R) &#123; int mid = L + (R - L) / 2; if (calc(mid) >= n) R = mid; else L = mid; &#125; printf(\"%d\\n\", R); &#125; return 0; &#125; [Luogu P2257] YY 的 GCD Portal. 根之前的推法是一样的，不过外面要多枚举一个 ppp。 推完之后有这么一个东西： ∑p∣kμ(kp)\\sum_{p\\mid k}\\mu\\left(\\frac k p\\right) p∣k∑​μ(pk​) 这个东西可以直接在 O(nlog⁡log⁡n)O(n\\log \\log n)O(nloglogn) 的时间预处理。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 10000000; int mu[10000005], prime[4000005], tot; i64 f[10000005]; bool v[10000005]; int main(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) for (int j = 1; j * prime[i] &lt;= N; ++j) f[j * prime[i]] += mu[j]; for (int i = 2; i &lt;= N; ++i) f[i] += f[i - 1]; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); if (n > m) swap(n, m); i64 ans = 0; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans += (f[r] - f[l - 1]) * (n / l) * (m / l); &#125; printf(\"%lld\\n\", ans); &#125; return 0; &#125; [SDOI2015] 约数个数和 Portal. 关键是： τ(ij)=∑x∣i∑y∣j[gcd⁡(x,y)=1]\\tau(ij)=\\sum_{x\\mid i}\\sum_{y\\mid j}[\\gcd(x,y)=1] τ(ij)=x∣i∑​y∣j∑​[gcd(x,y)=1] 然后随便推就可以了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 50000; int prime[20005], tot; bool v[50005]; int mu[50005], g[50005]; void init(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 1; i &lt;= N; ++i) mu[i] += mu[i - 1]; for (int i = 1; i &lt;= N; ++i) &#123; i64 res = 0; for (int l = 1, r; l &lt;= i; l = r + 1) &#123; r = i / (i / l); res += 1ll * (r - l + 1) * (i / l); &#125; g[i] = res; &#125; &#125; int main(void) &#123; int T, n, m; scanf(\"%d\", &amp;T); init(); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); if (n > m) swap(n, m); i64 ans = 0; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans += 1ll * (mu[r] - mu[l - 1]) * g[n / l] * g[m / l]; &#125; printf(\"%lld\\n\", ans); &#125; return 0; &#125; [国家集训队] Crash 的数字表格 Portal. 来推式子！ ∑i=1n∑j=1mlcm⁡(i,j)=∑i=1n∑j=1mijgcd⁡(i,j)=∑d=1n1d∑i=1n∑j=1mij[gcd⁡(i,j)=d]=∑d=1nd∑i=1⌊nd⌋∑j=1⌊md⌋ij[gcd⁡(i,j)=1]\\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^m\\operatorname{lcm}(i,j)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\frac{ij}{\\gcd(i,j)}\\\\ &amp;=\\sum_{d=1}^n \\frac 1 d \\sum_{i=1}^n\\sum_{j=1}^m ij[\\gcd(i,j)=d]\\\\ &amp;=\\sum_{d=1}^n d \\sum_{i=1}^{\\lfloor \\frac n d\\rfloor}\\sum_{j=1}^{\\lfloor \\frac m d\\rfloor} ij[\\gcd(i,j)=1]\\\\ \\end{aligned} i=1∑n​j=1∑m​lcm(i,j)​=i=1∑n​j=1∑m​gcd(i,j)ij​=d=1∑n​d1​i=1∑n​j=1∑m​ij[gcd(i,j)=d]=d=1∑n​di=1∑⌊dn​⌋​j=1∑⌊dm​⌋​ij[gcd(i,j)=1]​ 设 F(n,m)=∑i=1n∑j=1mij[gcd⁡(i,j)=1]F(n,m)=\\sum_{i=1}^n\\sum_{j=1}^m ij[\\gcd(i,j)=1]F(n,m)=∑i=1n​∑j=1m​ij[gcd(i,j)=1]，则原式为 ∑d=1nd×F(⌊nd⌋,⌊md⌋)\\sum_{d=1}^n d\\times F(\\lfloor \\frac n d\\rfloor, \\lfloor \\frac m d \\rfloor)∑d=1n​d×F(⌊dn​⌋,⌊dm​⌋)。 F(n,m)=∑i=1n∑j=1mij∑d∣gcd⁡(i,j)μ(d)=∑d=1nμ(d)∑i=1n∑j=1mij[d∣i∧d∣j]=∑d=1nμ(d)d2∑i=1⌊nd⌋∑j=1⌊md⌋ij\\begin{aligned} F(n,m)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m ij\\sum_{d\\mid\\gcd(i,j)}\\mu(d)\\\\ &amp;=\\sum_{d=1}^n \\mu(d)\\sum_{i=1}^n\\sum_{j=1}^m ij[d\\mid i\\land d\\mid j]\\\\ &amp;=\\sum_{d=1}^n \\mu(d)d^2\\sum_{i=1}^{\\lfloor \\frac n d\\rfloor}\\sum_{j=1}^{\\lfloor \\frac m d\\rfloor}ij \\end{aligned} F(n,m)​=i=1∑n​j=1∑m​ijd∣gcd(i,j)∑​μ(d)=d=1∑n​μ(d)i=1∑n​j=1∑m​ij[d∣i∧d∣j]=d=1∑n​μ(d)d2i=1∑⌊dn​⌋​j=1∑⌊dm​⌋​ij​ 后面那坨也可以通过数论分块计算。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 20101009; const int N = 10000000; int n, m, mu[10000005], prime[4000005], tot; bool v[10000005]; int F(int n) &#123; return 1ll * n * (n + 1) / 2 % P; &#125; int sum(int n, int m) &#123; int res = 0; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); res = (res + 1ll * (mu[r] - mu[l - 1]) * F(n / l) % P * F(m / l) % P) % P; &#125; return res; &#125; int main(void) &#123; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 2; i &lt;= N; ++i) mu[i] = (mu[i - 1] + 1ll * i * i % P * mu[i] % P) % P; scanf(\"%d%d\", &amp;n, &amp;m); if (n > m) swap(n, m); int ans = 0; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans = (ans + 1ll * (l + r) * (r - l + 1) / 2 % P * sum(n / l, m / l) % P) % P; &#125; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; [CF1780F] Three Chairs Portal. 将 aaa 排序，要求的就是： ans=∑1≤i&lt;j≤n(j−i+1)[gcd⁡(ai,aj)=1]=∑1≤i&lt;j≤n(j−i+1)∑d∣ai,d∣ajμ(d)=∑dμ(d)∑1≤i&lt;j≤kpj−pi−1\\begin{aligned} ans&amp;=\\sum_{1\\le i&lt;j\\le n} (j-i+1)[\\gcd(a_i, a_j)=1]\\\\ &amp;=\\sum_{1\\le i&lt;j\\le n} (j-i+1)\\sum_{d\\mid a_i,d\\mid a_j}\\mu(d)\\\\ &amp;=\\sum_{d}\\mu(d)\\sum_{1\\le i&lt;j\\le k} p_j-p_i-1 \\end{aligned} ans​=1≤i&lt;j≤n∑​(j−i+1)[gcd(ai​,aj​)=1]=1≤i&lt;j≤n∑​(j−i+1)d∣ai​,d∣aj​∑​μ(d)=d∑​μ(d)1≤i&lt;j≤k∑​pj​−pi​−1​ 其中 ppp 表示是 ddd 的倍数的数的下标位置。简单转化一下贡献，后面那一坨就是： −k(k−1)2+∑i=1kpi×(2i−k−1)-\\frac{k(k-1)} 2+\\sum_{i=1}^{k}p_i\\times (2i-k-1) −2k(k−1)​+i=1∑k​pi​×(2i−k−1) 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 300000; int n; int a[300005], mu[300005]; int prime[100005], tot, pos[300005], idx[300005]; bool v[300005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); mu[1] = 1; for (int i = 1; i &lt;= n; ++i) pos[a[i]] = i; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; i64 ans = 0; for (int d = 1; d &lt;= N; ++d) if (mu[d]) &#123; int k = 0; for (int i = d; i &lt;= N; i += d) if (pos[i]) idx[++k] = pos[i]; i64 res = -1ll * k * (k - 1) / 2; for (int i = 1; i &lt;= k; ++i) res += 1ll * idx[i] * (2 * i - k - 1); ans += mu[d] * res; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P4844] LJJ 爱数数 Portal. 方程两边同乘 abcabcabc 可以得到 ac+bc=ab⇒ab−ac−bc+c2=c2⇒(a−c)(b−c)=c2ac+bc=ab\\Rightarrow ab-ac-bc+c^2=c^2\\Rightarrow (a-c)(b-c)=c^2ac+bc=ab⇒ab−ac−bc+c2=c2⇒(a−c)(b−c)=c2。 设 a−c=x,b−c=ya-c=x,b-c=ya−c=x,b−c=y，则 xy=c2xy=c^2xy=c2，可以证明 a⊥b⊥c ⟺ x⊥ya\\perp b\\perp c\\iff x\\perp ya⊥b⊥c⟺x⊥y。 需要满足 max⁡{x,y}+c≤n\\max\\{x,y\\}+c\\le nmax{x,y}+c≤n，设 x&gt;yx&gt;yx&gt;y，则有 x+c≤nx+c\\le nx+c≤n。最后让答案 ×2\\times 2×2，再加上一个 a=b=2,c=1a=b=2,c=1a=b=2,c=1 即可。 由于 x⊥yx\\perp yx⊥y，因此 c2c^2c2 的每一种质因子只能都给 xxx 或都给 yyy，这样有 x=i2,y=j2(i&gt;j)x=i^2,y=j^2(i&gt;j)x=i2,y=j2(i&gt;j)，因此 i2+ij≤n⇒j≤ni−ii^2+ij\\le n\\Rightarrow j\\le \\frac n i - ii2+ij≤n⇒j≤in​−i，设 Ri=min⁡{i−1,ni−1}R_i=\\min\\{i-1,\\frac n i -1\\}Ri​=min{i−1,in​−1}，则答案为 ∑i=1n∑j=1Ri[gcd⁡(i,j)=1]\\sum_{i=1}^{n}\\sum_{j=1}^{R_i}[\\gcd(i,j)=1]∑i=1n​∑j=1Ri​​[gcd(i,j)=1]，莫比乌斯反演碾过去即可，时间复杂度为 O(nlog⁡n)O(\\sqrt{n}\\log \\sqrt{n})O(n​logn​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; i64 n, R[1000005]; int m; int mu[1000005], prime[400005], tot; bool v[1000005]; void init(int n) &#123; mu[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!v[i]) prime[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; &#125; int main(void) &#123; cin >> n; if (n == 1) return puts(\"0\"), 0; for (int i = 2; i &lt;= n; ++i) &#123; R[i] = n / i - i; if (i - 1 &lt; R[i]) R[i] = i - 1; if (R[i] &lt;= 0) break; m = i; &#125; init(m); i64 ans = 0; for (int d = 1; d &lt;= m; ++d) if (mu[d]) &#123; for (int i = d; i &lt;= m; i += d) ans += mu[d] * (R[i] / d); &#125; printf(\"%lld\\n\", ans * 2 + 1); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"数论初步","slug":"notes/数学/number-theory","date":"2023-02-12T00:00:00.000Z","updated":"2023-02-12T00:00:00.000Z","comments":true,"path":"d8a80121/","link":"","permalink":"https://james1badcreeper.github.io/d8a80121/","excerpt":"数论主要研究整数的性质，被数学王子高斯称为“数学上的皇冠”。初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、同余理论、连分数理论。在 OI 中，几乎跟数学有关的题目都绕不开初等数论，本文将引导你学习初等数论的基础知识。","text":"数论主要研究整数的性质，被数学王子高斯称为“数学上的皇冠”。初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、同余理论、连分数理论。在 OI 中，几乎跟数学有关的题目都绕不开初等数论，本文将引导你学习初等数论的基础知识。 OI 中的数学并没有数竞中的那么难，因为正确证明不再是首要任务（尽管证明可以帮助你理解），应用才是王道。 在阅读本文前，请保证您学过小学数学（雾 如果你想以数学竞赛的模式学习数论，请参阅潘承洞的《初等数论》，并提前学习高等数学基本内容： 所以还是以 OI 的模式学习数论吧(￣ ‘i ￣;)。 注意，OI 的模式学习数论，是指证明过程不会那么详细，会显得“感性理解”，甚至有些直接跳过证明，但足以让你在考场上回忆起这些性质并用它们解题（考场上想的做法往往可以用对拍或其他手段来验证，感性证明“好像是对的”就足够了，重要的还是大量做题）。严谨甚至多种的证明过程请参考《初等数论》《具体数学》等书籍——这未必不是好事，虽然会花费时间，但收获也是巨大的。 希望在阅读时您能拿起纸笔和键盘，适当的演算和完成代码实现。 基础知识 接下来若没有特殊说明，我们的所有数都满足 x∈Zx \\in \\mathbb{Z}x∈Z。 模运算 大家都应该知道取模 mod\\text{mod}mod。 随时取模性质 就是说 ∑(xi mod p)=(∑xi) mod p\\sum (x_i \\bmod p) = (\\sum x_i)\\bmod p∑(xi​modp)=(∑xi​)modp，∏(xi mod p)=(∏xi) mod p\\prod (x_i \\bmod p) = (\\prod x_i)\\bmod p∏(xi​modp)=(∏xi​)modp。用人话说，运算的最终结果要取模，那么运算过程中的加法、减法和乘法都可以随时取模（但是除法不行！需要用下文介绍的逆元来解决）。 这东西可以证明，下文会出现（ C++ 的取模 在 C++ 中，用 % 来表示取模。 这里问个问题，−5 mod 3-5\\bmod 3−5mod3 是多少？ 有的人会说是 −2-2−2，实际上是错误的。 我们不知道 −5 mod 3-5\\bmod 3−5mod3 是多少，但我们知道它等于 1 mod 31\\bmod 31mod3，所以它的答案是 111。 从 C99 和 C++11 起，规定商向零取整（舍弃小数部分），取模的符号即与被除数相同。从此以下运算结果保证为真： 5 % 3 == 2; 5 % -3 == 2; -5 % 3 == -2; -5 % -3 == -2; 这也就意味着，如果存在负数，那么必须这样实现取模：(a % b + b) % b。 整除与约数 若 a=bka=bka=bk，则 bbb 整除 aaa，记作 b∣ab\\mid ab∣a。不整除记作 b∤ab\\nmid ab∤a。 也称 bbb 是 aaa 的约数（因数），aaa 是 bbb 的倍数。 整除有一些性质： a∣b ⟺ −a∣b ⟺ a∣−b ⟺ ∣a∣∣∣b∣a\\mid b \\iff -a\\mid b \\iff a\\mid -b \\iff |a| \\mid |b|a∣b⟺−a∣b⟺a∣−b⟺∣a∣∣∣b∣； 如果 a∣b,a∣ca\\mid b, a\\mid ca∣b,a∣c，则可得 a∣b+ca\\mid b+ca∣b+c； 如果 a∣b,b∣ca\\mid b, b\\mid ca∣b,b∣c，则 a∣ca\\mid ca∣c，也就是整除的传递性； 若 m≠0m\\ne 0m=0，则 a∣b ⟺ ma∣mba\\mid b \\iff ma\\mid mba∣b⟺ma∣mb； 证明如下： 由 b=aq ⟺ b=(−a)(−q) ⟺ −b=a(−q) ⟺ ∣b∣=∣a∣∣∣q∣b=aq\\iff b=(-a)(-q) \\iff -b = a(-q) \\iff |b| = |a|\\mid |q|b=aq⟺b=(−a)(−q)⟺−b=a(−q)⟺∣b∣=∣a∣∣∣q∣ 得。a∣b,a∣ca\\mid b, a\\mid ca∣b,a∣c 可得 ak1=b,ak2=cak_1=b,ak_2=cak1​=b,ak2​=c，所以 a(k1+k2)=b+ca(k_1+k_2)=b+ca(k1​+k2​)=b+c，所以 a∣b+ca\\mid b+ca∣b+c。b=aq1,c=bq2b=aq_1,c=bq_2b=aq1​,c=bq2​，得 c=a(q1q2)⟹a∣cc=a(q_1q_2)\\Longrightarrow a\\mid cc=a(q1​q2​)⟹a∣c。a∣b ⟺ b=aq ⟺ mb=(ma)q ⟺ ma∣mba\\mid b \\iff b=aq \\iff mb = (ma)q \\iff ma\\mid mba∣b⟺b=aq⟺mb=(ma)q⟺ma∣mb。 还有： a∣ba\\mid ba∣b 且 b∣a⟹b=±ab\\mid a \\Longrightarrow b=\\pm ab∣a⟹b=±a，这是因为这两个式子代表 b=ap,a=bq⇒ab=abpq⇒pq=1⇒p=±1b=ap,a=bq\\Rightarrow ab=abpq\\Rightarrow pq=1\\Rightarrow p=\\pm 1b=ap,a=bq⇒ab=abpq⇒pq=1⇒p=±1； 设 b≠0b\\neq 0b=0，则 a∣b⟹∣a∣≤∣b∣a\\mid b \\Longrightarrow |a|\\le |b|a∣b⟹∣a∣≤∣b∣； 若 a≠0,b=qa+ca\\neq 0,b=qa+ca=0,b=qa+c，那么 a∣b ⟺ a∣ca\\mid b \\iff a\\mid ca∣b⟺a∣c。 核心的证明思路就是将 a∣ba\\mid ba∣b 写作 b=pab=pab=pa。 求 N 的正约数集合 若 aaa 是 nnn 的约数，则 na\\cfrac{n}{a}an​ 也是 nnn 的约数，且 aaa 和 na\\cfrac{n}{a}an​ 之中必有一个 ⩽n\\leqslant \\sqrt{n}⩽n​。 枚举 1∼n1\\sim \\sqrt{n}1∼n​ 的所有数，判断是不是 nnn 的约数即可，代码如下： int factor[1605]; inline int divisor(int n) // 返回约数个数，存在 factor 中 &#123; int m = 0, t = min(n, sqrt(n) + 1); for (int i = 1; i &lt;= t; ++i) if (n % i == 0) &#123; factor[++m] = i; if (i != n / i) factor[++m] = n / i; &#125; //sort(factor + 1, factor + m + 1); //此步有可能是必要的，比如在某些 DP 中，转移要有顺序。 return m; &#125; 以上方法称为试除法，通过试除法可以证明，一个整数 nnn 的约数个数（记作 d(n)d(n)d(n)）上界为 2n2\\sqrt{n}2n​（实际上远远不到，经过试验能得到下表）。 范围 d(n)d(n)d(n) 最大的 nnn max⁡{d(n)}\\max\\{d(n)\\}max{d(n)} ⩽104\\leqslant 10^4⩽104 数据丢失 646464 ⩽105\\leqslant 10^5⩽105 831608316083160 128128128 ⩽106\\leqslant 10^6⩽106 720720720720720720 240240240 ⩽107\\leqslant 10^7⩽107 864864086486408648640 448448448 ⩽108\\leqslant 10^8⩽108 735134407351344073513440 768768768 ≤109\\le 10^9≤109 134413441344 ≤1012\\le 10^{12}≤1012 672067206720 ≤1015\\le 10^{15}≤1015 268802688026880 64 位整数 有这种数据吗 103680103680103680 “Pollard Rho” 是一个比“试除法”更高效的算法。难度大大超出了本文的范围，感兴趣的读者可以自行了解。 1~n 每个数的正约数集合 求 1∼n1\\sim n1∼n 每个数的正约数集合可以采用倍数法。对于每个数 ddd，d,2d,3d,⋯ ,⌊nd⌋×dd,2d,3d,\\cdots,\\lfloor \\cfrac{n}{d}\\rfloor\\times dd,2d,3d,⋯,⌊dn​⌋×d 的约数就有 ddd。代码如下： vector &lt;int> factor[1000005]; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; j += i) factor[j].push_back(i); 时间复杂度为 O(∑i=1nni)=O(nlog⁡n)O(\\sum\\limits_{i=1}^{n}\\cfrac{n}{i})=O(n\\log n)O(i=1∑n​in​)=O(nlogn)，这一等式称之为调和级数。 GCD 与 LCM 若 ccc 同时是 aaa 和 bbb 的约数，则称 ccc 是 aaa 和 bbb 的公约数。 aaa 和 bbb 的最大公约数（Greatest Common Divisor，GCD）记为 gcd⁡(a,b)\\gcd(a,b)gcd(a,b) ，或者在没有歧义的条件下记作 (a,b)(a,b)(a,b)。 若 ccc 同时是 aaa 和 bbb 的倍数，则称 ccc 是 aaa 和 bbb 的公倍数。 aaa 和 bbb 的最小公倍数（Least Common Multiple，LCM）记为 lcm(a,b)\\text{lcm}(a,b)lcm(a,b) ，或者在没有歧义的条件下记作 [a,b][a,b][a,b]。 GCD 和 LCM 有一些显然的性质，如下： (a,a)=(0,a)=a,(a,a)=(0,a)=a,(a,a)=(0,a)=a, ∀a∣b,(a,b)=a,\\forall a\\mid b, (a,b)=a,∀a∣b,(a,b)=a, (a,b)=(a,a+b)=(a,ka+b)⇒(a,b)=(a,b mod a),(a,b)=(a,a+b)=(a,ka+b) \\Rightarrow (a,b)=(a,b\\bmod a),(a,b)=(a,a+b)=(a,ka+b)⇒(a,b)=(a,bmoda), (ka,kb)=k×(a,b),(ka,kb)=k\\times(a,b),(ka,kb)=k×(a,b), (a,b,c)=((a,b),c),(a,b,c)=((a,b),c),(a,b,c)=((a,b),c), [a,b,c]=[[a,b],c],[a,b,c]=[[a,b],c],[a,b,c]=[[a,b],c], [a,b]=a×b÷(a,b),[a,b]=a\\times b \\div (a,b),[a,b]=a×b÷(a,b), 如果 ddd 是 a,ba,ba,b 的公约数，那么 d∣(a,b).d\\mid (a,b).d∣(a,b). 值得注意的是，若 (a,b)=1(a,b)=1(a,b)=1，则称 aaa 和 bbb 互质（互素），记作 a⊥ba\\perp ba⊥b[1]。 还有一些比较难证的家伙，请关注一下： 如果 (n,x)=1(n,x)=1(n,x)=1，那么 (n,n−x)=1(n,n-x)=1(n,n−x)=1， 若 a⊥ma\\perp ma⊥m，则 (m,ab)=(m,b)(m,ab)=(m,b)(m,ab)=(m,b)， 若 a⊥m,m∣aba\\perp m,m\\mid aba⊥m,m∣ab，则 m∣bm\\mid bm∣b， [a,b](a,b)=ab[a,b](a,b)=ab[a,b](a,b)=ab。 证明： 采用反证法。如果存在 (n,i)=1(n,i)=1(n,i)=1 且 (n,n−i)=k(k≠1)(n,n-i)=k(k\\ne 1)(n,n−i)=k(k=1)，那么 (n−i) mod k=0,n mod k=0(n-i)\\bmod k = 0,n\\bmod k = 0(n−i)modk=0,nmodk=0，用后者减掉前者得 i mod k=0i\\bmod k = 0imodk=0，即 k∣ik\\mid ik∣i，而 kkk 又是是 nnn 的因子，所以 kkk 是 n,in,in,i 的公约数，所以 (n,i)≠1(n,i)\\ne 1(n,i)=1，矛盾。二三很难证，这里不证了（第四个是这样的：[a,b](a,b)=ab÷(a,b)×(a,b)=ab[a,b](a,b)=ab\\div (a,b) \\times (a,b)=ab[a,b](a,b)=ab÷(a,b)×(a,b)=ab。 完整的最大公约数理论及其不同的证明体系请参考《初等数论》。 求 GCD 与 LCM 求 GCD 有两种方法：辗转相除和更相减损。 辗转相除法 刚才我们知道，(a,b)=(a,b mod a)(a,b)=(a,b\\bmod a)(a,b)=(a,bmoda)，但注意代码实现不能这么写！ 比如给个 (2,1)(2,1)(2,1)，它就会一直是 (2,1)(2,1)(2,1)。 所以要这么写： int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; 看见了吗？反过来就行了。 那么它的复杂度是多少？ 若 a&lt;ba&lt;ba&lt;b，这时候 (a,b)=(b,a)(a,b)=(b,a)(a,b)=(b,a)； 若 a≥ba\\geq ba≥b，这时候 (a,b)=(b,a mod b)(a,b)=(b,a \\bmod b)(a,b)=(b,amodb)，而对 aaa 取模会让 aaa 至少折半。这意味着这一过程最多进行 O(log⁡n)\\mathcal{O}(\\log n)O(logn) 次。 而不可能连续两次发生第一种情况。所以复杂度是 O(log⁡(a+b))\\mathcal{O}(\\log(a+b))O(log(a+b))，但实际上远远达不到这个上界。当 a=Fx,b=Fx−1a=F_x,b=F_{x-1}a=Fx​,b=Fx−1​ 时（FFF 指斐波那契数列），会跑满 O(log⁡(a+b))\\mathcal{O}(\\log(a+b))O(log(a+b))，因为模运算会被卡成减法，也就成了更相减损法。 更相减损法 还是根据性质，有： int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x - y); &#125; 它的复杂度是 O(max⁡(a,b))\\mathcal{O}(\\max(a,b))O(max(a,b))，主要用于高精度运算中，因为模运算（除法）不好实现。 但比如这样：求 gcd⁡(1,1010000)\\gcd(1,10^{10000})gcd(1,1010000) 用更相减损会很慢。除非数据有特殊性质，否则还是老老实实实现高精模运算。 求解 LCM 根据定义，要这么写： inline int lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125; 注意顺序，因为 x×yx\\times yx×y 可能会溢出！注意这样的细节，毕竟算法竞赛不是数学竞赛。 质数（素数） 如果一个数 x(x∈N)x(x\\in\\mathbb{N})x(x∈N) 的约数仅有 111 和它本身，那么就称 xxx 是质数（素数），特别地，000 和 111 不是质数，如果一个自然数不是质数，他就是合数。 质数的判定。试除法是最常用的判定质数方法，代码如下： inline bool is_prime(int x) &#123; if (x &lt; 2) return false; for (int i = 2, t = min(x, sqrt(x) + 2); i &lt; t; ++i) if (x % i == 0) return false; return true; &#125; 用反证法可以证明这样做的正确性（即证明合数一定存在一个不超过 x\\sqrt{x}x​ 的约数）。 “Miller-Rabin”是一个进阶的素数随机判定方法，虽然是随机算法，但没有任何已知数字通过了高级概率性测试被判定为伪素数。感兴趣的读者可以自行了解。 为方便，接下来我们用 ppp 代表质数。 计算技巧 这是一些编程中的计算技巧。 快速幂 快速幂是一种分治法的应用，但这货在数论中有大量应用。这里直接给出模板。 inline i64 mpow(i64 a, i64 p, i64 m) &#123; a %= p; // 如果 a 在 int 范围内，此步不必要 i64 res = 1; while (p) &#123; if (p &amp; 1) res = res * a % m; a = a * a % m; p >>= 1; &#125; return res % m; // 小心 m = 1 &#125; 快速乘 如果我们要求 64 位整数乘 64 位整数，显然 long long 是要炸掉的。那么用什么？__int128？你觉得毒瘤 CCF 不会使用 128 位整数乘法吗（不用怕，不会的，使用 __int128 就行了，否则接下来的这种方法也不起作用了）。 一种解决方式是把快速幂中的乘法改成加法。但这样实在是太慢了，这里给出一种利用语言特性进行运算的方法，原理请读者自行学习，代码如下： using i64 = long long; inline i64 mul(i64 a, i64 b, i64 p) &#123; a %= p, b %= p; i64 c = (long double)a * b / p; i64 ans = a * b - c * p; if (ans &lt; 0) ans += p; else if (ans >= p) ans -= p; return ans; &#125; 考场还是能用 __int128 就用。 唯一分解定理 对于一个数 nnn，它可以唯一分解成 n=∏pikin=\\prod p_i^{k_i}n=∏piki​​。 这玩意可以证明，我也不证了（这货还叫作算术基本定理，我怎么会证 这玩意的过程也叫做分解质因数。代码如下： int p[105], c[105], m; void divide(int n) &#123; m = 0; int t = min(n, sqrt(n) + 1); for (int i = 2; i &lt;= t; ++i) if (n % i == 0) &#123; p[++m] = i, c[m] = 0; while (n % i == 0) n /= i, ++c[m]; &#125; if (n > 1) p[++m] = n, c[m] = 1; // 剩下的这个 n 可能是质数 &#125; 在 Linux 终端下，可以使用 factor 命令快速分解质因数。命令如下：factor 998244353无误的话，会输出：998244353: 998244353 这货既然敢叫算术基本定理，那么必有过人之处。这里不加证明的给出算术基本定理的常用推论（证明参考《初等数论》）。 给定 a=∏i=1spiαia=\\prod_{i=1}^{s} p_i^{\\alpha_i}a=∏i=1s​piαi​​， ddd 是 aaa 的约数的充要条件是 d=∏i=1spiei,ei≤αid=\\prod_{i=1}^s p_i^{e_i},e_i\\le\\alpha_id=∏i=1s​piei​​,ei​≤αi​， b=∏i=1spiβib=\\prod_{i=1}^{s} p_i^{\\beta_i}b=∏i=1s​piβi​​，那么 (a,b)=∏i=1spimin⁡(αi,βi),[a,b]=∏i=1spimax⁡(αi,βi)(a,b)=\\prod_{i=1}^{s} p_i^{\\min(\\alpha_i,\\beta_i)},[a,b]=\\prod_{i=1}^{s} p_i^{\\max(\\alpha_i,\\beta_i)}(a,b)=∏i=1s​pimin(αi​,βi​)​,[a,b]=∏i=1s​pimax(αi​,βi​)​，如果我们承认它成立，可以发现 [a,b](a,b)=ab[a,b](a,b)=ab[a,b](a,b)=ab 的原因是 min⁡(α,β)+max⁡(α,β)=α+β\\min(\\alpha,\\beta)+\\max(\\alpha,\\beta) =\\alpha+\\betamin(α,β)+max(α,β)=α+β，直呼厉害， 用除数函数 τ(a)\\tau(a)τ(a)（读作 tau，也可记作 d(a)d(a)d(a)）表示 aaa 的正约数的个数，则 τ(a)=∏i=1s(αi+1)\\tau(a)=\\prod_{i=1}^s(\\alpha_i+1)τ(a)=∏i=1s​(αi​+1)，这也是约数个数定理。其实这是约数条件的推论，对于每个质因子上的幂次，我们取 0∼αi0\\sim \\alpha_i0∼αi​ 的任意整数，共 αi+1\\alpha_i+1αi​+1 个，由乘法原理直接得出， 用除数和函数 σ(a)\\sigma(a)σ(a)（读作 sigma）表示 aaa 所有正约数的和，则 σ(a)=∏i=1s(∑j=0αi(pi)j)=∏i=1sσ(piαi)\\sigma(a)=\\prod_{i=1}^s\\left(\\sum_{j=0}^{\\alpha_i}(p_i)^j\\right)=\\prod_{i=1}^s\\sigma(p_i^{\\alpha_i}) σ(a)=i=1∏s​(j=0∑αi​​(pi​)j)=i=1∏s​σ(piαi​​) 数论函数 定义域为整数的函数称为数论函数。特别地，对于数论函数 fff，如果 ∀a⊥b,f(ab)=f(a)f(b)\\forall a\\perp b, f(ab)=f(a)f(b)∀a⊥b,f(ab)=f(a)f(b)，则称 fff 为积性函数；如果 ∀a,b,f(ab)=f(a)f(b)\\forall a,b,f(ab)=f(a)f(b)∀a,b,f(ab)=f(a)f(b)，则称 fff 为完全积性函数。 对于所有积性函数 fff，有 n=∏picin=\\prod p_i^{c_i}n=∏pici​​，则 f(n)=∏f(pici)f(n)=\\prod f(p_i^{c_i})f(n)=∏f(pici​​)。证明很简单，由于第二个式子中的所有 picip_i^{c_i}pici​​ 都必定互质，多次利用积性函数的定义即可证明。 简单数论题 什么，为什么题目来的这么快。 但是不用担心，这里都是一些基础题目，用介绍的知识和一小点小学数学就可以解决。 好，那就来吧[2]！ 线性 GCD 给定 n(n≤107)n(n \\le 10^7)n(n≤107) 个整数，对于每个数 AiA_iAi​，求出删除它以后剩下的数的最大公约数。 还记得 (a,b,c)=((a,b),c)(a,b,c)=((a,b),c)(a,b,c)=((a,b),c) 吗？这个式子告诉我们，GCD 运算存在某种“结合律”，我们可以轻易地把两坨数的 GCD 拼起来。 我们有： Ansi=(a1,⋯ ,ai−1,ai+1,⋯ ,an)=((a1,⋯ ,ai−1),(ai+1,⋯ ,an))Ans_i=(a_1,\\cdots,a_{i-1},a_{i+1},\\cdots,a_n)=((a_1,\\cdots,a_{i-1}),(a_{i+1},\\cdots,a_n)) Ansi​=(a1​,⋯,ai−1​,ai+1​,⋯,an​)=((a1​,⋯,ai−1​),(ai+1​,⋯,an​)) 处理出前缀 GCD 和后缀 GCD，便可以快速求解了。 [NOIP2001 普及组] 最大公约数和最小公倍数问题 Portal. 有 p∣y0p\\mid y_0p∣y0​，我们可以枚举 y0y_0y0​ 的所有约数，然后利用 (p,q)[p,q]=pq(p,q)[p,q]=pq(p,q)[p,q]=pq 判断是否满足条件即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int gcd(int x, int y) &#123; return y == 0 ? x : gcd(y, x % y); &#125; int lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125; int main(void) &#123; int x, y, ans = 0; cin >> x >> y; for (int p = 1; p * p &lt;= y; ++p) if (y % p == 0) &#123; if (gcd(p, y / p * x) == x) ++ans; if (y / p != p &amp;&amp; gcd(y / p, p * x) == x) ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; [Luogu P1572] 计算分数 Portal. gcd 可以用于模拟分数运算。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #define i64 long long using namespace std; i64 gcd(i64 x, i64 y) &#123; return y == 0 ? x : gcd(y, x % y); &#125; i64 lcm(i64 x, i64 y) &#123; return x / gcd(x, y) * y; &#125; struct frac &#123; i64 p, q; frac(i64 p = 0, i64 q = 0) : p(p), q(q) &#123;&#125; frac operator+ (const frac &amp;a) const &#123; frac res; res.q = lcm(q, a.q); res.p = res.q / q * p + res.q / a.q * a.p; i64 g = gcd(res.p, res.q); res.p /= g, res.q /= g; return res; &#125; &#125;; int main(void) &#123; i64 a, b; scanf(\"%lld/%lld\", &amp;a, &amp;b); frac ans(a, b); while (~scanf(\"%lld/%lld\", &amp;a, &amp;b)) ans = ans + frac(a, b); if (ans.q &lt; 0) ans.p = -ans.p, ans.q = -ans.q; if (ans.q == 1) printf(\"%lld\\n\", ans.p); else printf(\"%lld/%lld\\n\", ans.p, ans.q); return 0; &#125; [AHOI2005] 约数研究 Portal. 换一种思路：枚举约数，然后加起来即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, sum = 0; cin >> n; for (int i = 1; i &lt;= n; i++) sum += n / i; cout &lt;&lt; sum &lt;&lt; endl; return 0; &#125; [Luogu P2651] 添加括号III Portal. 不难发现除了 a2a_2a2​，其它数都可以放在分子的位置上。然后直接约分，每次用最大公约数除，最后 a2=1a_2=1a2​=1 就是可以。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, a, b; scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b); n -= 2; b /= gcd(a, b); while (n--) &#123; scanf(\"%d\", &amp;a); b /= gcd(a, b); &#125; if (b == 1) puts(\"Yes\"); else puts(\"No\"); &#125; return 0; &#125; [Luogu P2660] zzc 种田 Portal. 类似于一个 gcd 的迭代过程。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int main(void) &#123; i64 a, b, ans = 0; cin >> a >> b; while (a &amp;&amp; b) &#123; if (a > b) swap(a, b); // 令 a &lt; b ans += a * (b / a) * 4; // 边长为 a 的正方形，种 b / a 个 b %= a; // 之后 b %= a &#125; printf(\"%lld\\n\", ans); return 0; &#125; [NOIP2009 提高组] Hankson 的趣味题 Portal. 由于 [x,b0]=b1[x,b_0]=b_1[x,b0​]=b1​，证明 xxx 是 b1b_1b1​ 的约数，用试除法枚举，判断是否满足条件即可。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int gcd(int x, int y) &#123; return y == 0 ? x : gcd(y, x % y); &#125; inline int lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125; int main(void) &#123; int T = read(); while (T--) &#123; int a0 = read(), a1 = read(), b0 = read(), b1 = read(), ans = 0; for (int i = 1; i * i &lt;= b1; ++i) if (b1 % i == 0) &#123; if (gcd(i, a0) == a1 &amp;&amp; lcm(i, b0) == b1) ++ans; if (i != b1 / i) &#123; int j = b1 / i; if (gcd(j, a0) == a1 &amp;&amp; lcm(j, b0) == b1) ++ans; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [Luogu P1414] 又是毕业季II Portal. 我们可以计算每个数的约数，然后放到一个数组里面统计。回答的时候从大到小看当前这个约数的数量够不够大。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int c[1000005]; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int x = read(); int t = sqrt(x + 0.5); for (int j = 1; j &lt;= t; ++j) if (x % j == 0) &#123; ++c[j]; if (j * j != x) ++c[x / j]; &#125; &#125; for (int i = 1, j = 1000000; i &lt;= n; ++i) &#123; while (c[j] &lt; i) --j; printf(\"%d\\n\", j); &#125; return 0; &#125; [NOIP2013 提高组] 转圈游戏 Portal. 根据题意使用快速幂计算即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int poww(int a, int p, int m) &#123; int res = 1; while (p) &#123; if (p &amp; 1) res = (i64)res * a % m; a = (i64)a * a % m; p >>= 1; &#125; return res % m; &#125; int main(void) &#123; int n, m, k, x; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;x); printf(\"%d\\n\", (x + (i64)m * poww(10, k, n)) % n); return 0; &#125; [NOIP2009 普及组] 细胞分裂 Portal. 将 m1m_1m1​ 分解质因数，然后每个次数乘上 m2m_2m2​，便相当于 m1m2m_1^{m_2}m1m2​​。对于每一个 sss，想要让 m1m2∣sxm_1^{m_2} \\mid s^xm1m2​​∣sx，需要 mmm 的每个质因子次数都小于 sxs^xsx 的。那么依次检查每个质因子，要求 ex≥cex\\ge cex≥c 即可（eee 代表将 sss 分解质因数后的幂次，ccc 是 mmm 处理过后的幂次）。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int m1, m2; int p[10005], c[10005]; void init(void) &#123; for (int i = 2; i * i &lt;= m1; ++i) if (m1 % i == 0) &#123; p[++m] = i, c[m] = 0; while (m1 % i == 0) &#123; ++c[m]; m1 /= i; &#125; &#125; if (m1 > 1) p[++m] = m1, c[m] = 1; for (int i = 1; i &lt;= m; ++i) c[i] *= m2; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m1, &amp;m2); init(); int ans = 2e9, s; while (n--) &#123; scanf(\"%d\", &amp;s); int x = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (s % p[i] != 0) &#123; x = 2e9; break; &#125; else &#123; int res = 0; while (s % p[i] == 0) &#123; ++res; s /= p[i]; &#125; x = max(x, c[i] / res + (c[i] % res == 0 ? 0 : 1)); &#125; &#125; ans = min(ans, x); &#125; if (ans != 2e9) printf(\"%d\\n\", ans); else puts(\"-1\"); return 0; &#125; [UVA11889] Benefit Portal. 当 a∤ca\\nmid ca∤c 的时候无解。否则要求满足下列条件的最小 xxx： x(a,x)=ca=d⟹x=dk(k=(a,x))⟹k=(a,dk)⟹kg=(ag,k×dg)⟹kg=(ag,k)(ag⊥dg)⟹k(ag,k)=g\\begin{aligned} &amp;\\frac{x}{(a,x)}=\\frac{c}{a}=d\\\\ \\Longrightarrow &amp; x=dk(k=(a,x))\\\\ \\Longrightarrow &amp; k=(a,dk)\\\\ \\Longrightarrow &amp; \\frac{k}{g}=\\left(\\frac{a}{g},k\\times\\frac{d}{g}\\right)\\\\ \\Longrightarrow &amp; \\frac{k}{g}=\\left(\\frac{a}{g},k\\right) \\left(\\frac{a}{g}\\perp\\frac{d}{g}\\right) \\\\ \\Longrightarrow &amp; \\frac{k}{(\\frac{a}{g},k)}=g \\end{aligned} ⟹⟹⟹⟹⟹​(a,x)x​=ac​=dx=dk(k=(a,x))k=(a,dk)gk​=(ga​,k×gd​)gk​=(ga​,k)(ga​⊥gd​)(ga​,k)k​=g​ 然后就可以递归求解了。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int calc(int a, int d) &#123; // b / gcd(a, b) = d int g = gcd(a, d); if (g == 1) return d; return d * calc(a / g, g); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int a, c; scanf(\"%d%d\", &amp;a, &amp;c); if (c % a != 0) puts(\"NO SOLUTION\"); else printf(\"%d\\n\", calc(a, c / a)); &#125; return 0; &#125; 接下来我们会介绍一些较为有趣的数论算法。 素数筛法 素数筛能快速地求出区间内的质数。 模板。 普通筛 对于所有的数，标记所有它的倍数（二倍及以上）为合数。时间复杂度为调和级数 O(nlog⁡n)\\mathcal{O}(n\\log n)O(nlogn)。代码如下： int prime[MAXN]; bool vis[MAXN]; for (int i = 2; i &lt;= n; ++i) &#123; if (vis[i] == 0) prime[++tot] = i; for (int j = i * 2; j &lt;= n; j += i) vis[j] = 1; &#125; 这种方式很慢，不要在考场上使用。 Eratosthenes 筛法 Eratosthenes 筛法，简称埃氏筛，是算法竞赛中最常用的筛法。 考虑这样一件事情：如果 xxx 是合数，那么 xxx 的倍数也一定是合数，它们肯定会被某个相同的质因子筛掉，那我们就没有必要筛合数了。 如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。 代码如下： int prime[MAXN]; bool vis[MAXN]; for (int i = 2; i &lt;= n; ++i) if (vis[i] == 0) &#123; prime[++tot] = i; for (int j = i * 2; j &lt;= n; j += i) vis[j] = 1; &#125; 埃氏筛的复杂度是 O(∑p⩽nnp=nlog⁡log⁡n)\\mathcal{O}(\\sum_{p\\leqslant n} \\cfrac{n}{p}=n \\log\\log n)O(∑p⩽n​pn​=nloglogn)，效率较高，但仍需较好的 IO 优化才可通过刚才的模板。 这个代码还可以加一些优化：内层循环不必从 i×2i\\times 2i×2 开始，它在筛 222 的时候就已经被筛掉了；外层循环也不必到 nnn 结束，需要筛的已经在 n\\sqrt{n}n​ 前筛掉了（但这道题中这个两个都不能用，因为分别会爆 int 和无法统计素数）。但实际上，优化后的复杂度并没有改变。 埃氏筛的速度已经足够快，如果不是时间特别吃紧，考场上使用埃氏筛即可。 刚才是“质数的整数倍是合数“，还有一种思路：整数的质数倍是合数。代码如下： for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) prime[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) vis[i * prime[j]] = true; &#125; 欧拉筛 欧拉筛（也称作线性筛）的时间复杂度为 O(n)\\mathcal{O}(n)O(n)，是常用筛法中最快的筛法。 埃氏筛的问题在于它仍然会重复标记合数（从 x2x^2x2 开始），我们需要设计一个算法，使得合数只会被它最小的质因子筛一次，这就是欧拉筛（由于欧拉筛的这个特性，它也常被用做求合数最小质因子的方法）。 我们设一个 vvv 数组代表每个数的最小质因子，设质数集合为 ppp，那么可以这样维护 vvv： 一次考虑 2∼n2\\sim n2∼n 间的每一个数 iii。 如果 v[i]v[i]v[i] 没有值，那么说明它是素数，把它加进 ppp 中。 接下来对于每个质数 p[j]p[j]p[j]，令 v[i×p[j]]=p[j]v[i\\times p[j]]=p[j]v[i×p[j]]=p[j]。由于 p[j]≤v[i]p[j] \\le v[i]p[j]≤v[i]，所以 p[j]p[j]p[j] 一定是 i×p[j]i\\times p[j]i×p[j] 的最小质因子。 由于所有的合数只会被标记一次，时间复杂度为 O(n)\\mathcal{O}(n)O(n)，严谨的复杂度和正确性证明较为复杂，感兴趣的读者可以自行了解。代码如下： int n, tot = 0; int v[MAXN], prime[MAXN]; inline void primes(void) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (v[i] == 0) // 是质数 &#123; v[i] = i; prime[++tot] = i; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) // 给 i 乘上一个质数，乘积小于 n 才循环 &#123; if (prime[j] > v[i]) break; // i 的最小质因子比 prime[j] 更小，break v[i * prime[j]] = prime[j]; // 标记 &#125; &#125; &#125; 实际上如果不用记录最小值因子的话，也可以这么做： for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) prime[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; vis[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125; 只多了一个 break，就让埃氏筛变成了欧拉筛，每个数只被筛了一次。 区间筛 [Luogu P1835] 素数密度. 给定区间 [L,R](1≤L≤R&lt;231,R−L≤106)[L,R](1\\le L\\le R &lt; 2^{31},R-L\\le 10^6)[L,R](1≤L≤R&lt;231,R−L≤106)，求区间中的素数个数。 L,RL,RL,R 这么大，但是 R−LR-LR−L 的值却这么小，而且任何一个合数 nnn 都一定包含一个不超过 n\\sqrt{n}n​ 的质因子，那么我们只需要用筛法求出 2∼R2\\sim \\sqrt{R}2∼R​ 以内的所有质数，然后筛掉这些数的倍数即可。如果采用线性筛，那么时间复杂度为 O(r+(r−l+1)log⁡log⁡r)O(\\sqrt{r}+(r-l+1)\\log\\log \\sqrt{r})O(r​+(r−l+1)loglogr​)。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> #define LL long long using namespace std; LL L, R; bool is_prime[50000]; bool flag[1000005]; inline void solve(int n) &#123; for (int i = 2; i &lt;= n; ++i) is_prime[i] = 1; int g = sqrt(n) + 1; for (int i = 2; i &lt;= g; ++i) if (is_prime[i]) for (int j = i * i; j &lt;= n; j += i) is_prime[j] = 0; &#125; int main(void) &#123; cin >> L >> R; if (L == 1) L = 2; if (L > R) &#123; puts(\"0\"); return 0; &#125; int m = sqrt(R) + 1; solve(m); for (int i = 0; i &lt;= int(R - L); ++i) flag[i] = 1; for (int i = 2; i &lt;= m; ++i) if (is_prime[i]) &#123; LL j = L; while (j % i != 0) ++j; for (; j &lt;= R; j += i) if (i != j) flag[j - L] = 0; &#125; int ans = 0; for (int i = 0; i &lt;= R - L; ++i) if (flag[i]) ++ans; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 筛法与积性函数 筛法的作用远不止筛出素数，它们还可以在筛素数的同时求出积性函数。在欧拉函数一节中，我们将看到如何用筛法求解欧拉函数；在《数论进阶》中，我们还会更深入地探讨筛法的应用。 扩展欧几里得算法 扩展欧几里得算法用于求解不定方程 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b) 的整数解，是数论基础算法之一。 裴蜀定理 裴蜀定理。∀a,b, ∃x,y, i.e. ax+by=gcd⁡(a,b)\\forall a,b, ~\\exists x,y,~\\text{i.e.}~ ax+by=\\gcd(a,b)∀a,b, ∃x,y, i.e. ax+by=gcd(a,b) 关于裴蜀定理的证明，网上资料较多，这里不做赘述。 模板。 根据裴蜀定理，ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b)，也就是说 ax+by&gt;0ax+by&gt;0ax+by&gt;0 时，最小为 gcd⁡(a,b)\\gcd(a,b)gcd(a,b)，也就是说答案是 gcd⁡(A)\\gcd(A)gcd(A)，而且是一个正数。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int main(void) &#123; int x, ans = 0; scanf(\"%d\", &amp;x); while (scanf(\"%d\", &amp;x) == 1) ans = gcd(ans, x &lt; 0 ? -x : x); printf(\"%d\\n\", ans); return 0; &#125; 扩展欧几里得 由于 ax+by=gcd⁡(a,b)=gcd⁡(b,a mod b)ax+by=\\gcd(a,b)=\\gcd(b,a\\bmod b)ax+by=gcd(a,b)=gcd(b,amodb) 且 ax+by=(⌊ab⌋×b+a mod b)x+by=b(y+⌊ab⌋x)+(a mod b)xax+by=(\\lfloor\\cfrac{a}{b}\\rfloor\\times b+a\\bmod b)x+by=b(y+\\lfloor\\cfrac{a}{b}\\rfloor x)+(a\\bmod b)xax+by=(⌊ba​⌋×b+amodb)x+by=b(y+⌊ba​⌋x)+(amodb)x，所以求不定方程 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b)，相当于求 b(y+⌊ab⌋x)+(a mod b)x=gcd⁡(b,a mod b)b(y+\\lfloor\\cfrac{a}{b}\\rfloor x)+(a\\bmod b)x=\\gcd(b, a\\bmod b)b(y+⌊ba​⌋x)+(amodb)x=gcd(b,amodb)。 当然这里把代码实现考虑了进去（还记得为什么求 gcd 要把 xxx 和 yyy 写反吗），所以新式子中的 (y+⌊ab⌋x)(y+\\lfloor\\cfrac{a}{b}\\rfloor x)(y+⌊ba​⌋x) 相当于 y′y&#x27;y′，xxx 相当于 x′x&#x27;x′。 进而有 y=y′−⌊ab⌋×x′y = y&#x27; - \\lfloor\\cfrac{a}{b}\\rfloor\\times x&#x27;y=y′−⌊ba​⌋×x′，xxx 是 x′x&#x27;x′。 所以： void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); // 显然 exgcd(b, a%b, y, x); // 根据刚才推出的结论 // 此时已经求出了 x', y' y -= a / b * x; &#125; 那么如何求出方程的所有解呢？ 设用 exgcd 求出的解为 x0,y0x_0,y_0x0​,y0​，那么显然有 x=x0+k×bgcd⁡(a,b),y=y0−k×agcd⁡(a,b)x=x_0+k\\times\\cfrac{b}{\\gcd(a,b)},y=y_0-k\\times\\cfrac{a}{\\gcd(a,b)}x=x0​+k×gcd(a,b)b​,y=y0​−k×gcd(a,b)a​。 最小正数 xxx 显然为 x0 mod bgcd⁡(a,b)x_0 \\bmod \\cfrac{b}{\\gcd(a,b)}x0​modgcd(a,b)b​。 模板。 根据裴蜀定理，ax+byax+byax+by 的答案只能是 gcd⁡(a,b)\\gcd(a,b)gcd(a,b) 的倍数，也就是需要满足 (a,b)∣c(a,b)\\mid c(a,b)∣c。直接使用 exgcd 算法，求出来的解，然后再乘上 c÷(a,b)c\\div (a,b)c÷(a,b)，就能够得到一组原方程的解。 具体实现见代码： // 笔记原因，只摘录了重要代码 i64 exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, a; i64 d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; int main(void) &#123; i64 a = read(), b = read(), c = read(), x, y; i64 g = exgcd(a, b, x, y); if (c % g != 0) puts(\"-1\"); else &#123; x *= c / g, y *= c / g; i64 p = b / g, q = a / g, k; if (x &lt; 0) k = ceil((1.0 - x) / p), x += p * k, y -= q * k; else if (x >= 0) k = (x - 1) / p, x -= p * k, y += q * k; if (y > 0) &#123; printf(\"%lld %lld %lld \", (y - 1) / q + 1, x, (y - 1) % q + 1); printf(\"%lld %lld\\n\", x + (y - 1) / q * p, y) &#125; else printf(\"%lld %lld\\n\", x, y + q * (i64)ceil((1.0 - y) / q)); &#125; &#125; 欧拉函数 欧拉函数，即 φ(n)\\varphi(n)φ(n)，代表 1∼n1\\sim n1∼n 中与 nnn 互质的数的个数。 比如在 111~121212 中，1,5,7,111,5,7,111,5,7,11 这四个数与 121212 互质，所以 φ(12)=4\\varphi(12)=4φ(12)=4。 求解 怎么求欧拉函数呢？设 n=∏pikin=\\prod p_i^{k_i}n=∏piki​​，则有： φ(n)=n∏(1−1pi)=n∏pi−1pi\\varphi(n)=n\\prod(1-\\cfrac{1}{p_i})=n\\prod \\cfrac{p_i-1}{p_i} φ(n)=n∏(1−pi​1​)=n∏pi​pi​−1​ 证明： 设 ans=nans = nans=n。设 ppp 是 nnn 的质因子，则要在 ansansans 中减掉 np\\cfrac{n}{p}pn​。qqq 也是，则要在 ansansans 中减掉 nq\\cfrac{n}{q}qn​。但是 pqpqpq 的倍数被减了两遍，所以我们要找回它的冤魂，再加上 npq\\cfrac{n}{pq}pqn​。所以：ans=n−np−np+npq=n×(1−1p−1q−1pq)=n(1−1p)(1−1q)ans = n - \\cfrac{n}{p} - \\cfrac{n}{p} + \\cfrac{n}{pq} = n\\times(1-\\cfrac{1}{p}-\\cfrac{1}{q}-\\cfrac{1}{pq})=n(1-\\cfrac{1}{p})(1-\\cfrac{1}{q})ans=n−pn​−pn​+pqn​=n×(1−p1​−q1​−pq1​)=n(1−p1​)(1−q1​)实际上上述思想称之为容斥原理，根据容斥原理的公式（请自行了解），可以得到要证明的公式。 根据结论有如下代码： inline int phi(int n) &#123; int ans = n; for (int i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; ans = ans / i * (i-1); // 因为是约数，所以能除 while (n % i == 0) n /= i; &#125; if (n > 1) ans = ans / n * (n-1); return ans; &#125; 时间复杂度为 O(n)\\mathcal{O}(\\sqrt{n})O(n​)，当然你可以用 Pollard Rho 来加速，不过没必要。 性质 ∀n&gt;1,1∼n\\forall n &gt; 1, 1\\sim n∀n&gt;1,1∼n 中与 nnn 互质的数的和为 n×φ(n)÷2n\\times \\varphi(n) \\div 2n×φ(n)÷2。且 2∣φ(n)(n&gt;2)2\\mid\\varphi(n)(n&gt;2)2∣φ(n)(n&gt;2)。 证明： 由于 (n,x)=(n,n−x)(n,x)=(n,n-x)(n,x)=(n,n−x)，所以与 nnn 不互质的数 x,n−xx,n-xx,n−x 成对出现，每一对的和为 n÷2n \\div 2n÷2。进而易证原命题。由于成对出现，所以 2∣φ(n)(n&gt;2)，φ(1)=φ(2)=12\\mid\\varphi(n)(n&gt; 2)，\\varphi(1)=\\varphi(2)=12∣φ(n)(n&gt;2)，φ(1)=φ(2)=1。 欧拉函数是积性函数。根据欧拉函数的计算式可以直接得到。那么，欧拉函数也满足积性函数的性质。进而可以推出，∀2∤n,φ(2n)=φ(n)\\forall 2\\nmid n, \\varphi(2n)=\\varphi(n)∀2∤n,φ(2n)=φ(n)，因为奇数 nnn 显然与 222 互质，且 φ(2)=1\\varphi(2)=1φ(2)=1，所以 φ(2n)=φ(2)×φ(n)=1×φ(n)=φ(n)\\varphi(2n)=\\varphi(2)\\times \\varphi(n)=1\\times\\varphi(n)=\\varphi(n)φ(2n)=φ(2)×φ(n)=1×φ(n)=φ(n)。 接下来的 3,43,43,4 中，ppp 均属于质数集。 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1； φ(pk)=pk−pk−1\\varphi(p^k)=p^{k}-p^{k-1}φ(pk)=pk−pk−1； 证明： 根据定义，性质 333 显然。带入计算式中后运用乘法分配律，可以证明性质 444。 设 m=m1×m2m=m_1\\times m_2m=m1​×m2​，若 m1m_1m1​ 和 m2m_2m2​ 有相同的素因数，那么 φ(m)=m2φ(m1)\\varphi(m)=m_2 \\varphi(m_1)φ(m)=m2​φ(m1​)； n=∑d∣nφ(d)n = \\sum_{d\\mid n} \\varphi(d)n=∑d∣n​φ(d). 这是两条很重要的性质。这里略去证明，请参考《初等数论》。 筛法求欧拉函数 我们先看如何使用埃氏筛求解欧拉函数。根据欧拉函数的计算式，我们先可以初始化 φ(i)=i\\varphi(i)=iφ(i)=i，然后从 222 开始扫描（根据计算式，而 111 不是质数，不能扫）。如果扫到一个 φ(i)=i\\varphi(i)=iφ(i)=i，那么说明这是一个质数，就扫描它的所有倍数，乘上 (i−1)÷i(i-1) \\div i(i−1)÷i。代码如下： int n, phi[100005]; inline void euler(void) &#123; for (int i = 1; i &lt;= n; ++i) phi[i] = i; for (int i = 2; i &lt;= n; ++i) if (phi[i] == i) &#123; for (int j = i; j &lt;= n; j += i) phi[j] = phi[j] / i * (i - 1); &#125; &#125; 我们还可以用欧拉筛来求解欧拉函数。在线性筛中，如果 nnn 能被筛掉，那么它一定是被比它小的一个数 n′n&#x27;n′ 乘上一个质数 ppp 筛掉。 当 p∣n′p \\mid n&#x27;p∣n′ 时，有： φ(n)=n×∏i=1pi−1pi=p×n′×∏i=1pi−1pi=p×φ(n′)\\begin{aligned} \\varphi(n) &amp;= n\\times \\prod_{i=1} \\cfrac{p_i-1}{p_i}\\\\ &amp; = p \\times n&#x27; \\times \\prod_{i=1} \\cfrac{p_i-1}{p_i}\\\\ &amp; = p \\times \\varphi(n&#x27;) \\end{aligned} φ(n)​=n×i=1∏​pi​pi​−1​=p×n′×i=1∏​pi​pi​−1​=p×φ(n′)​ 当 p∤n′p \\nmid n&#x27;p∤n′ 时，可得 p⊥n′p\\perp n&#x27;p⊥n′（因为 ppp 是质数），有： φ(n)=φ(p)×φ(n′)=(p−1)×φ(n′)\\begin{aligned} \\varphi(n) &amp;= \\varphi(p) \\times \\varphi(n&#x27;) \\\\ &amp;= (p-1) \\times \\varphi(n&#x27;) \\end{aligned} φ(n)​=φ(p)×φ(n′)=(p−1)×φ(n′)​ 所以代码如下： int v[maxn], prime[maxn], phi[maxn], tot = 0; inline void euler(void) &#123; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (v[i] == 0) &#123; v[i] = i, prime[++tot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; if (prime[j] > v[i]) break; v[i * prime[j]] = prime[j]; phi[i * prime[j]] = phi[i] * (i % prime[j] == 0 ? prime[j] : prime[j] - 1); &#125; &#125; &#125; 当然不标记 v 也可以做： phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!phi[i]) prime[++tot] = i, phi[i] = i - 1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; 同余 如果两数 a,ba,ba,b 除以 ccc 的余数相等，则称 a,ba,ba,b 模 ccc 同余，又称 bbb 是 aaa 对模 ccc 的剩余，记作 a≡b(modc)a\\equiv b\\pmod ca≡b(modc)。 同余是基本数论中最难的部分。但不要害怕，如果欧拉函数那块学得非常明白，这部分的学习将异常轻松（实际上在《数论进阶》开始前，都算简单的）。 基本概念 同余有一些基础的概念。 性质 同余跟等式不一样，但是它也有跟等式相似的性质，也由于等式不相似的性质。包括（分栏是为了减小长度，但是可以看出有三类性质）： 等价关系与等式相似与等式不同自反性，即 a≡a(modm)a\\equiv a \\pmod ma≡a(modm)， 对称性，即 a≡b ⟺ b≡a(modm)a\\equiv b \\iff b \\equiv a \\pmod ma≡b⟺b≡a(modm)， 传递性，即 a≡b(modm), b≡c(modm)⟹a≡c(modm)a\\equiv b \\pmod m,~ b\\equiv c \\pmod m \\Longrightarrow a\\equiv c \\pmod ma≡b(modm), b≡c(modm)⟹a≡c(modm)。 证明： 自反性：m∣0⟹m∣a−a⟹a≡a(modm)m\\mid 0 \\Longrightarrow m\\mid a-a \\Longrightarrow a\\equiv a \\pmod mm∣0⟹m∣a−a⟹a≡a(modm)，对称性：m∣a−b ⟺ m∣b−am\\mid a-b \\iff m\\mid b-am∣a−b⟺m∣b−a，传递性：m∣a−b,m∣b−c⟹m∣(a−b)+(b−c)⟹m∣a−c⟹a≡c(modm)m\\mid a-b,m\\mid b-c \\Longrightarrow m\\mid (a-b)+(b-c) \\Longrightarrow m\\mid a-c \\Longrightarrow a\\equiv c \\pmod mm∣a−b,m∣b−c⟹m∣(a−b)+(b−c)⟹m∣a−c⟹a≡c(modm)。 还有一条特殊的，a≡b(modm)a\\equiv b\\pmod ma≡b(modm) 的充要条件是 m∣a−b⟺−m∣a−bm\\mid a-b \\Longleftrightarrow -m \\mid a-bm∣a−b⟺−m∣a−b，所以说最初的同余式等价于 a≡b(mod(−m))a\\equiv b \\pmod {(-m)}a≡b(mod(−m))。同余式可以相加，即如果有 a≡b(modm),c≡d(modm)a\\equiv b \\pmod m, c\\equiv d \\pmod ma≡b(modm),c≡d(modm)，则 a+c≡b+d(modm)a+c\\equiv b+d \\pmod ma+c≡b+d(modm)。进而可以证明，如果 a≡b(modm)a\\equiv b \\pmod ma≡b(modm)，则 a+c≡b+c(modm)a+c\\equiv b+c \\pmod ma+c≡b+c(modm)。 同余式也可以相乘，即如果有 a≡b(modm),c≡d(modm)a\\equiv b \\pmod m, c\\equiv d \\pmod ma≡b(modm),c≡d(modm)，则 ac≡bd(modm)ac\\equiv bd \\pmod mac≡bd(modm)。进而可以证明，如果 a≡b(modm)a\\equiv b \\pmod ma≡b(modm)，则 ac≡bc(modm)ac\\equiv bc \\pmod mac≡bc(modm)。 同余式还有同幂性：x≡y(modm)⟹xn≡yn(modm)x\\equiv y \\pmod m \\Longrightarrow x^n \\equiv y^n \\pmod mx≡y(modm)⟹xn≡yn(modm)。 证明： 由 m∣a−b,m∣c−d⟹m∣(a−b)+(c−d)⟹m∣(a+c)−(b+d)m\\mid a-b,m\\mid c-d \\Longrightarrow m\\mid (a-b)+(c-d) \\Longrightarrow m\\mid (a+c)-(b+d)m∣a−b,m∣c−d⟹m∣(a−b)+(c−d)⟹m∣(a+c)−(b+d)，就可以证明同余式可以相加。加上同余式的自反性，就可以证明后面一个。由 a=b+k1m,c=d+k2ma=b+k_1m,c=d+k_2ma=b+k1​m,c=d+k2​m，得 ac=bd+(bk2+dk1+k1k2m)mac=bd+(bk_2+dk_1+k_1k_2m)mac=bd+(bk2​+dk1​+k1​k2​m)m，进而推出 ac≡bd(modm)ac\\equiv bd \\pmod mac≡bd(modm)。自反性带入后可证明后一个。 同余式相加的这一性质告诉我们，同余式可以在加减意义上移项。 在这之后我们可以简单证明一下随时取模性质。 对于加减法，我们要证明 a mod m+b≡a+b(modm)a\\bmod m + b \\equiv a+b \\pmod mamodm+b≡a+b(modm)。 用显然成立的 a mod m≡a(modm)a\\bmod m \\equiv a \\pmod mamodm≡a(modm) 加上 b≡b(modm)b\\equiv b\\pmod mb≡b(modm) 后得证。 对于乘法，要证明 a mod m×b≡ab(modm)a\\bmod m \\times b \\equiv ab \\pmod mamodm×b≡ab(modm)。 用显然成立的 a mod m≡a(modm)a\\bmod m \\equiv a\\pmod mamodm≡a(modm) 乘上 b≡b(modm)b\\equiv b\\pmod mb≡b(modm) 后得证。若 a≡b(modm),d≥1,d∣ma\\equiv b \\pmod m,d\\ge 1, d\\mid ma≡b(modm),d≥1,d∣m，则 a≡b(modd)a\\equiv b \\pmod da≡b(modd)。这一点由 d∣m,m∣a−bd\\mid m,m\\mid a-bd∣m,m∣a−b 利用整除的传递性得到。 a≡b(modm) ⟺ da≡db(mod∣d∣m)a\\equiv b \\pmod m \\iff da \\equiv db \\pmod{|d| m}a≡b(modm)⟺da≡db(mod∣d∣m)，这由 ∣d∣m∣da−db ⟺ m∣a−b|d| m \\mid da-db \\iff m\\mid a-b∣d∣m∣da−db⟺m∣a−b 推出。 ac≡bc(modm) ⟺ a≡b(modm÷(c,m))ac\\equiv bc \\pmod m \\iff a\\equiv b \\pmod{m\\div (c,m)}ac≡bc(modm)⟺a≡b(modm÷(c,m))，进而有当 (c,m)=1(c,m)=1(c,m)=1 时，ac≡bc(modm) ⟺ a≡b(modm)ac\\equiv bc \\pmod m \\iff a\\equiv b \\pmod{m}ac≡bc(modm)⟺a≡b(modm)。证明是将最初的同余式写作 m∣c(a−b) ⟺ m(c,m)∣c(c,m)(a−b)m\\mid c(a-b)\\iff \\cfrac{m}{(c,m)}\\mid\\cfrac{c}{(c,m)}(a-b)m∣c(a−b)⟺(c,m)m​∣(c,m)c​(a−b)，由于 m(c,m)⊥c(c,m)\\cfrac{m}{(c,m)}\\perp\\cfrac{c}{(c,m)}(c,m)m​⊥(c,m)c​（把公约数除光了当然互质了），加上最大公约数的推论（可以回去看看），这等价于 m(c,m)∣(a−b)\\cfrac{m}{(c,m)}\\mid(a-b)(c,m)m​∣(a−b)，也就是要证的结论。 同余方程 注意同余的这个式子 a≡b(modc)a\\equiv b\\pmod ca≡b(modc)，如果把它看做一个方程，那么这个式子叫做同余方程。 同余方程的特例——横线性方程是我们要讨论的内容。它长这样：ax≡b(modm)ax\\equiv b\\pmod max≡b(modm)。 怎么解呢？不难得出，这个方程有解的充要条件是 ax−bax-bax−b 是 mmm 的倍数。设这个倍数为 −y-y−y 倍，那么这个方程等价于 ax−b=−ymax-b=-ymax−b=−ym，即 ax+my=bax+my=bax+my=b。这是什么？扩展欧几里得算法！ 根据裴蜀定理，bbb 必须是 gcd⁡(a,m)\\gcd(a,m)gcd(a,m) 的倍数，那么就调用 exgcd(a,m,x,y) 即可。 我们设求出来的东西满足 ax0+my0=gcd⁡(a,m)ax_0+my_0=\\gcd(a,m)ax0​+my0​=gcd(a,m)，那么 x=x0×b÷gcd⁡(a,m)x=x_0\\times b\\div \\gcd(a,m)x=x0​×b÷gcd(a,m) 就是原线性同余方程的一组解。方程的所有解则是所有模 m÷(a,m)m\\div (a,m)m÷(a,m) 与 xxx 同余的整数（注意这一点！）。这一点跟当时解二元一次不定方程的原理一样，a(x+k×m(a,m))+m(y+k×a(a,m))=ba\\left(x+k\\times \\cfrac{m}{(a,m)}\\right)+m\\left(y+k\\times \\cfrac{a}{(a,m)}\\right)=ba(x+k×(a,m)m​)+m(y+k×(a,m)a​)=b 由于我们的代码实现的 gcd⁡\\gcdgcd 只能对正数有意义，所以要将 aaa 变为正数，而 mymymy 这一项怎么样无所谓，因为 yyy 的符号是随便的。bbb 也要变为相反数。 [Luogu 1516] 青蛙的约会。 两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 000 度处为原点，由东往西为正方向，单位长度 111 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 xxx，青蛙 B 的出发点坐标是 yyy。青蛙 A 一次能跳 mmm 米，青蛙 B 一次能跳 nnn 米，两只青蛙跳一次所花费的时间相同。纬度线总长 LLL 米。现在要你求出它们跳了几次以后才会碰面。 题目显然是让我们求同余方程 x+km≡y+kn(modL)x+km\\equiv y+kn \\pmod Lx+km≡y+kn(modL) 的解，移项（由于随时取模性质，同余式是可以移项的）可得 k(m−n)≡y−x(modL)k(m-n)\\equiv y-x \\pmod Lk(m−n)≡y−x(modL)。那么令 a=m−n,k=x,b=y−xa=m-n,k=x,b=y-xa=m−n,k=x,b=y−x，就转化为了 ax≡b(modL)ax\\equiv b\\pmod Lax≡b(modL)。 也就相当于 ax−b=nL ⟺ ax−nL=bax-b=nL\\iff ax-nL=bax−b=nL⟺ax−nL=b。 代码如下： #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; inline i64 read(void) &#123; i64 x = 0; int c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; i64 exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, a; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; int main(void) &#123; i64 x = read(), y = read(), m = read(), n = read(), L = read(); i64 a = m - n, b = y - x, c, d; if (a &lt; 0) a = -a, b = -b; i64 g = exgcd(a, L, c, d); if (b % g == 0) &#123; c = c * (b / g); i64 M = L / g; printf(\"%lld\\n\", (c % M + M) % M); &#125; else puts(\"Impossible\"); return 0; &#125; 同余类与剩余系 把全体整数分为若干个两两不相交的集合，使得在同一个集合中的任意两个数对模 mmm 一定同余，而属于不同集合中的两个数模 mmm 一定不同余。每一个这样的集合被称为模 mmm 的同余类或模 mmm 的剩余类。这个集合记作模 mmm 的同余类 a‾\\overline{a}a。显然，这个集合是 {a+km}(k∈Z)\\{a+km\\}(k\\in \\mathbb{Z}){a+km}(k∈Z)。 模 mmm 的同余类一共有 mmm 个，分别为 0‾,1‾,2‾,⋯ ,m−1‾\\overline{0},\\overline{1},\\overline{2},\\cdots,\\overline{m-1}0,1,2,⋯,m−1​。从每个同余类中取出一个数，它们所构成的集合称为模 mmm 的完全剩余系。 如果一组数 z1,z2,⋯ ,ztz_1,z_2,\\cdots,z_tz1​,z2​,⋯,zt​ 满足 (zj,m)=1,1⩽j⩽t(z_j,m)=1,1\\leqslant j \\leqslant t(zj​,m)=1,1⩽j⩽t，以及对于任意的 a,(a,m)=1a,(a,m)=1a,(a,m)=1，有且仅有一个 zjz_jzj​ 满足 a≡zj(modm)a\\equiv z_j \\pmod ma≡zj​(modm)，那么称这组数为模 mmm 的既约（或互素）剩余系。也叫作简化剩余系。也可以给它换一个定义：1∼m1\\sim m1∼m 中与 mmm 互质的数代表的同余类共有 φ(m)\\varphi(m)φ(m) 个，它们构成 mmm 的简化剩余系。 有关于同余类和剩余系还有很多概念、性质与证明，请参考《初等数论》。同余类与剩余系是初等数论的基础。我们可以用它来证明欧拉函数的有关内容，还有需许许多多有趣的东西。 Fermat-Euler 定理 ∀a⊥n,aφ(n)≡1(modn)\\forall a\\perp n, a^{\\varphi(n)}\\equiv 1 \\pmod n∀a⊥n,aφ(n)≡1(modn) 特别地，当 nnn 为素数，有 ∀a⊥n,an≡a(modn)\\forall a\\perp n, a^n\\equiv a \\pmod n∀a⊥n,an≡a(modn)。 通常把第一个同余式称为欧拉定理，第二个称为费马小定理。费马小定理还有一种写法：ap−1≡1(modp)a^{p-1}\\equiv 1 \\pmod pap−1≡1(modp)。 费马小定理是欧拉定理的一个特殊情况。我们先假设欧拉定理成立，然后我们来证明费马小定理。 我们先求证费马小定理的第二种写法。因为 ppp 是素数，所以 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1。当 a⊥pa\\perp pa⊥p 时，费马小定理就是欧拉定理，显然成立。我们把第二种写法转成熟悉的等式 ap−1 mod p≡1(modp)a^{p-1} \\bmod p \\equiv 1 \\pmod pap−1modp≡1(modp)（注，数学中没有这么写的，只是为了方便）。两边同乘 aaa，可以得到 ap−1 mod p×a≡a(modp)a^{p-1} \\bmod p \\times a \\equiv a \\pmod pap−1modp×a≡a(modp)，彻底拆掉同余，有 ap−1 mod p×a mod p=a mod pa^{p-1} \\bmod p \\times a\\bmod p = a \\bmod pap−1modp×amodp=amodp，又由于随时取模，可得 ap−1×a mod p=a mod pa^{p-1} \\times a \\bmod p = a \\bmod pap−1×amodp=amodp，即 ap≡a(modp)a^p\\equiv a \\pmod pap≡a(modp)。 现在我们只需要证明欧拉定理就可以证明以上所有定理。证明需要对同余类和剩余系进行分析（也有其它证法），这里就不证了。 但是你敢信吗，这玩意还能继续往下推。 这便是扩展欧拉定理，也就是 ∀a,n,a2φ(n)≡aφ(n)(modn)\\forall a,n,a^{2\\varphi(n)}\\equiv a^{\\varphi(n)}\\pmod n∀a,n,a2φ(n)≡aφ(n)(modn)，那么： ab≡{ab mod φ(n),a⊥n,ab,(a,n)≠1,b≤φ(n),ab mod φ(n)+φ(n),(a,n)≠1,b&gt;φ(n).(modn)a^{b}\\equiv \\begin{cases} a^{b\\bmod\\varphi(n)}, &amp;a\\perp n,\\\\ a^b, &amp;(a,n)\\neq 1,b\\le\\varphi(n),\\\\ a^{b\\bmod\\varphi(n)+\\varphi(n)}, &amp;(a,n)\\neq 1,b&gt;\\varphi(n). \\end{cases} \\pmod n ab≡⎩⎨⎧​abmodφ(n),ab,abmodφ(n)+φ(n),​a⊥n,(a,n)=1,b≤φ(n),(a,n)=1,b&gt;φ(n).​(modn) 要注意，实际上即使在 a,ba,ba,b 不互质的情况下，二式和三式也依然成立，但是这两个式子相互独立，也就是当 b≤φ(n)b\\le \\varphi(n)b≤φ(n) 的时候，三式可能是错误的。 许多题目要求我们把答案对一个数 ppp（不一定是质数，非质数就是加强难度），这时可以用扩展欧拉定理二式三式进行降幂，如果满足三式的条件，那么就把底数对 ppp 取模，指数对 φ(p)\\varphi(p)φ(p) 取模后加上 φ(p)\\varphi(p)φ(p) 即可。 模板。注意边读入边取模，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; int a, m, b, phi; inline void calcPhi(int n) &#123; int ans = n, t = sqrt(n + 0.5); for (int i = 2; i &lt;= t; ++i) if (n % i == 0) &#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; if (n > 1) ans = ans / n * (n - 1); phi = ans; &#125; inline int read(void) &#123; int x = 0, c = getchar(); bool flag = false; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48); if (x > phi) &#123; // 大于才取模 x %= phi; flag = true; // 需要加 &#125; c = getchar(); &#125; return x + (flag ? phi : 0); &#125; inline int power(int x, int p) &#123; int res = 1; while (p) &#123; if (p &amp; 1) res = (long long)res * x % m; x = (long long)x * x % m; p >>= 1; &#125; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;a, &amp;m); calcPhi(m); b = read(); printf(\"%d\\n\", power(a, b)); return 0; &#125; 逆元 逆元，万物的起源，像出现了新的道具，游戏被开启了新的副本，数论从此向前迈进了一步，以前做不了的事情——除法取模，现在已经近在眼前（啊，不是[3] 引子 模意义下的除法。尽管我们会在《数论进阶》中介绍有理数取模（虽然不是什么鬼分数都能做），我们先常规想一想。 比如 5÷3×125\\div 3 \\times 125÷3×12，出现了除法，除法不满足随时取模性质，于是我们的程序就会死亡。但是后面乘上了 121212，也就是这个式子可以当作 5×45\\times 45×4，它又变成合法的了。 然而我们不是上帝，做不到预判未来，只能给当下记个帐，于是，逆元诞生了。 也就是说，执行“除以 xxx”的时候，我们试着乘上另一个数（记账），等到日后乘上 xxx 的时候，我们就能把数变回来，得到正确结果。也就是我们能找到一个满足 k≡1x(modp)k\\equiv \\cfrac{1}{x}\\pmod pk≡x1​(modp)，这个 kkk 就是我们所求！ 然后你会发现这就是有理数取余。 不过我们先不管这些，我们按照正常的思维继续搞。 比如我们要找的 13\\cfrac{1}{3}31​ 的逆元，在 mod 11\\bmod 11mod11 意义下的话，我们可以将 ÷3\\div 3÷3 变成 ×4\\times 4×4，于是 5×4×12≡9(mod11)5\\times 4 \\times 12\\equiv 9 \\pmod{11}5×4×12≡9(mod11)，事实上，5÷3×12=20,20 mod 11=95\\div 3 \\times 12=20, 20\\bmod 11 = 95÷3×12=20,20mod11=9。 我们记一个数的逆元为 inv(x)\\text{inv}(x)inv(x)，显然，它满足： x×inv(x)≡1(modp)x\\times \\text{inv}(x) \\equiv 1 \\pmod p x×inv(x)≡1(modp) 这个 inv(x)\\text{inv}(x)inv(x) 也可记作 x−1x^{-1}x−1（即 1x\\cfrac{1}{x}x1​）。 求法 还记得费马小定理吗？当 x⊥px\\perp px⊥p 时，我们有 x×inv(x)≡1(modp)x\\times \\text{inv}(x) \\equiv 1 \\pmod px×inv(x)≡1(modp)，和费马小定理 xp−1≡1(modp)x^{p-1}\\equiv 1 \\pmod pxp−1≡1(modp)，那么可以得到： x×inv(x)≡xp−1(modp)x\\times \\text{inv}(x) \\equiv x^{p-1} \\pmod p x×inv(x)≡xp−1(modp) 两边同时除以 xxx（因为 x⊥px\\perp px⊥p），得到： inv(x)≡xp−2(modp)\\text{inv}(x) \\equiv x^{p-2} \\pmod p inv(x)≡xp−2(modp) 这便是用费马小定理求逆元的方法，直接调用快速幂 power(x, p-2, p) 即可。 然而你看那个东西不是同余方程吗？我们直接调用 exgcd 就能求出逆元啦（可以发现有解仅当 x⊥px\\perp px⊥p）！扩展欧几里得求逆元往往比费马小定理快，而且在模数不是质数的情况下，如果有逆元也能求出来。 模板。 #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int a, b; void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a%b, y, x); y -= a / b * x; &#125; int main(void) &#123; a = read(), b = read(); int x, y; exgcd(a, b, x, y); // x 是 a 在模 b 意义下的逆元 printf(\"%d\\n\", (x % b + b) % b); return 0; &#125; 由此也可看出，一个数往往有不只一个逆元，因为同余方程的解不止一个，不过我们只用那个最小的正的即可。 线性求逆元 这个问题有两种形式，我们分开来看： 递推逆元任意逆元模板。 求出 1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 中每个数关于 mmm 的逆元，且 mmm 为质数。 求 i−1i^{-1}i−1，这么干： k=⌊mi⌋,j=m mod i,∴ m=ki+j⟹ki+j≡0(modm)⟹kj−1+i−1≡0(modm)（两边同乘 i−1×j−1）⟹i−1≡−kj−1(modm)⟹i−1≡−kj−1(modm)⟹i−1≡−⌊mi⌋(m mod i)−1(modm)k=\\left\\lfloor \\cfrac{m}{i}\\right\\rfloor, j=m\\bmod i, \\\\ \\begin{aligned} \\therefore&amp;~m=ki+j \\\\ \\Longrightarrow&amp; ki+j \\equiv 0 \\pmod m\\\\ \\Longrightarrow&amp; kj^{-1}+i^{-1}\\equiv 0 \\pmod m （两边同乘~i^{-1}\\times j^{-1}）\\\\ \\Longrightarrow&amp; i^{-1}\\equiv -kj^{-1} \\pmod m\\\\ \\Longrightarrow&amp; i^{-1}\\equiv -kj^{-1} \\pmod m\\\\ \\Longrightarrow&amp; i^{-1}\\equiv -{\\left\\lfloor \\cfrac{m}{i}\\right\\rfloor}\\left(m\\bmod i\\right)^{-1} \\pmod m \\end{aligned} k=⌊im​⌋,j=mmodi,∴⟹⟹⟹⟹⟹​ m=ki+jki+j≡0(modm)kj−1+i−1≡0(modm)（两边同乘 i−1×j−1）i−1≡−kj−1(modm)i−1≡−kj−1(modm)i−1≡−⌊im​⌋(mmodi)−1(modm)​ 这便是逆元的递推公式了，然而这样得出的逆元是个负数，所以我们要给 −⌊mi⌋-\\left\\lfloor \\cfrac{m}{i}\\right\\rfloor−⌊im​⌋ 加上 mmm，模板题代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, p; int inv[3000005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); inv[1] = 1; // inv[1] = 1 for (int i = 2; i &lt;= n; ++i) inv[i] = (long long)(p - p / i) * inv[p % i] % p; for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", inv[i]); return 0; &#125; 模板。 给定 n(1≤ai&lt;p)n(1\\le a_i &lt; p)n(1≤ai​&lt;p) 个正整数，求它们模 ppp 意义下的逆元。 计算前缀积 sss（模意义），然后计算 s[n]s[n]s[n] 的逆元 sinv[n]sinv[n]sinv[n]。由于 sinv[n]sinv[n]sinv[n] 是 nnn 个数积的逆元，也就是它等于 1a1⋯an\\cfrac{1}{a_1\\cdots a_n}a1​⋯an​1​，再乘上前缀和后缀就可以得到当前的逆元了。 时间复杂度 O(n+log⁡p)\\mathcal{O}(n+\\log p)O(n+logp)，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, p, k; int a[5000005], sp[5000005], sf[5000005], inv; int poww(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % p; a = 1ll * a * a % p; b >>= 1; &#125; return res; &#125; int main(void) &#123; n = read(), p = read(), k = read(); sp[0] = 1, sf[n + 1] = 1; for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= n; ++i) sp[i] = 1ll * sp[i - 1] * a[i] % p; for (int i = n; i >= 1; --i) sf[i] = 1ll * sf[i + 1] * a[i] % p; inv = poww(sp[n], p - 2); int tmp = 1, ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + 1ll * inv * sp[i - 1] % p * sf[i + 1] % p * (tmp = 1ll * tmp * k % p)) % p; printf(\"%d\\n\", ans); return 0; &#125; 实数取模 之前听说过整数取余运算，但是想不到实数都可以取余？我们一一来看。 有理数取余 如果 x≡ab(modp)x\\equiv \\cfrac{a}{b}\\pmod px≡ba​(modp)，那么两边同乘 bbb 得 bx≡a(modp)bx\\equiv a \\pmod pbx≡a(modp)。这不就是之前讲过得同余方程吗？ 虽然问题已经解决，但是还要问一句，什么时候无解？显然是 aaa 不为 (b,p)(b,p)(b,p) 的倍数（同余方程的结论），但是我们肯定想要最简分数，此时由于 b&lt;pb&lt;pb&lt;p（先取模），加上 a⊥ba\\perp ba⊥b，显然当 (b,p)≠1(b,p)\\ne 1(b,p)=1 的时候无解。 有没有发现，这就是求逆元的过程？的确如此，因为逆元干的事就是有理数取余。 模板，注意分子分母很大，所以读入时就要取模。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const int MOD = 19260817; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48); x %= MOD; c = getchar(); &#125; return x; &#125; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; void exgcd(int a, int b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, y, x); y -= a / b * x; &#125; int main(void) &#123; int a, b, g; i64 x, y; // 注意要开 long long a = read(), b = read(); g = gcd(b, MOD); if (g == 1) &#123; exgcd(b, MOD, x, y); x *= a / gcd(b, MOD); // 乘上倍数 printf(\"%d\\n\", (x % MOD + MOD) % MOD); &#125; else puts(\"Angry!\"); return 0; &#125; 无理数取余 如果有理数 aaa 满足 ak≡b(modp)a^k\\equiv b \\pmod pak≡b(modp)，那么有 a≡bk(modp)a\\equiv \\sqrt[k]{b} \\pmod pa≡kb​(modp)（根据刚才的经验）。当然，也有很大可能无解。 这个问题可以通过简单枚举来获取答案，代码如下： #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; i64 b, k, p; inline i64 power(i64 x, i64 y) &#123; i64 res = 1; while (y) &#123; if (y &amp; 1) res = res * x % p; x = x * x % p; y >>= 1; &#125; return res; &#125; int main(void) &#123; scanf(\"%lld%lld%lld\", &amp;b, &amp;k, &amp;p); for (i64 i = 1; i &lt;= p; ++i) // 超过 p 没有意义（成循环了） if (power(i, k) == b) printf(\"%d\\n\", i); return 0; &#125; 高效求解这个问题非常困难，需要使用二次剩余或者 N 次剩余，将在《数论进阶》中讲解。 光速幂 给定 a,ca,ca,c，每次询问给出 bbb，光速求出 ab mod ca^b \\bmod cabmodc，O(c)\\mathcal{O}(\\sqrt{c})O(c​) 预处理，O(1)\\mathcal{O}(1)O(1) 查询。 还记得扩展欧拉定理吗？就是这个： ab≡{ab mod φ(p),a⊥p,ab,(a,p)≠1,b&lt;φ(p),ab mod φ(p)+φ(p),(a,b)≠1,b≥φ(p).(modp)a^{b}\\equiv \\begin{cases} a^{b\\bmod\\varphi(p)}, &amp;a\\perp p,\\\\ a^b, &amp;(a,p)\\neq 1,b&lt;\\varphi(p),\\\\ a^{b\\bmod\\varphi(p)+\\varphi(p)}, &amp;(a,b)\\neq 1,b\\ge\\varphi(p). \\end{cases} \\pmod p ab≡⎩⎨⎧​abmodφ(p),ab,abmodφ(p)+φ(p),​a⊥p,(a,p)=1,b&lt;φ(p),(a,b)=1,b≥φ(p).​(modp) 我们说过可以用二式三式进行降幂，于是我们就可以将 bbb 缩小到 2×φ(c)2\\times \\varphi(c)2×φ(c) 的范围以内（也就是 2c2c2c 以内）。然后我们可以这样推：ab=ac×⌊bc⌋+b mod c=(ac)⌊bc⌋×ab mod ca^b=a^{\\sqrt{c}\\times \\lfloor\\frac{b}{\\sqrt{c}}\\rfloor+b\\bmod \\sqrt{c}}=(a^{\\sqrt{c}})^{\\lfloor\\frac{b}{\\sqrt{c}}\\rfloor}\\times a^{b\\bmod \\sqrt{c}}ab=ac​×⌊c​b​⌋+bmodc​=(ac​)⌊c​b​⌋×abmodc​。其中 ⌊bc⌋&lt;2c\\lfloor\\frac{b}{\\sqrt{c}}\\rfloor&lt;2\\sqrt{c}⌊c​b​⌋&lt;2c​（想一想刚才 ccc 的范围，b mod c&lt;cb\\bmod \\sqrt{c} &lt; \\sqrt{c}bmodc​&lt;c​。 于是预处理 (ac)i,aj(1≤i&lt;2c,1≤j&lt;c)(a^{\\sqrt{c}})^i,a^j(1\\le i &lt; 2\\sqrt{c},1\\le j&lt;\\sqrt{c})(ac​)i,aj(1≤i&lt;2c​,1≤j&lt;c​) 即可。预处理时间复杂度 O(c)\\mathcal{O}(\\sqrt{c})O(c​)，包括处理欧拉函数的时间。 代码如下，可以通过模板。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; using i64 = long long; const int P = 998244352; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int a, b, T, t, phi; int fac[1000005], facp[2000005]; void calcPhi(int n) &#123; int ans = n, t = sqrt(n + 0.5); for (int i = 2; i &lt;= t; ++i) if (n % i == 0) &#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; if (n > 1) ans = ans / n * (n - 1); phi = ans; &#125; void init(void) &#123; a %= P; // 一般来讲，此行是必要的 t = sqrt(P + 0.5); fac[0] = facp[0] = 1; for (int i = 1; i &lt;= t; ++i) fac[i] = (i64)fac[i - 1] * a % P; // 预处理 a^i for (int i = 1; i &lt;= t &lt;&lt; 1; ++i) facp[i] = (i64)facp[i - 1] * fac[t] % P; // 预处理 (a^sqrt(c))^i calcPhi(P); // 计算 c 的欧拉函数以降幂 &#125; inline int calc(int b) &#123; return (i64)facp[b / t] * fac[b % t] % P; &#125; int main(void) &#123; a = read(), T = read(); init(); while (T--) &#123; b = read(); if (b >= phi) b = b % phi + phi; // 利用扩展欧拉定理三式降幂 printf(\"%d \", calc(b)); &#125; putchar('\\n'); return 0; &#125; 光速幂的这个 t 不一定非是算数平方根，取一个较快的值就行。 当然，你还可以利用这个原理整个矩阵光速幂，这里就不说了。 中国剩余定理（CRT） 这起源于一个叫做韩信点兵的故事。相传韩信点他数量巨大的兵，然后实在是数不过来，于是就让每三个组成一队看余数，每五个组成一队看余数，每七个组成一队看余数，然后就算出来总人数了。 互质情况 模板。 也就是说，要解决横线性同余方程组，保证模数两两互质： {x≡a1(modm1)x≡a2(modm2)⋯x≡a3(modm3)\\begin{cases} x\\equiv a_1 \\pmod {m_1}\\\\ x\\equiv a_2 \\pmod {m_2}\\\\ \\cdots\\\\ x\\equiv a_3 \\pmod {m_3}\\\\ \\end{cases} ⎩⎨⎧​x≡a1​(modm1​)x≡a2​(modm2​)⋯x≡a3​(modm3​)​ 设 M=∏i=1nmi,Mi=m÷miM=\\prod_{i=1}^{n}m_i,M_i=m\\div m_iM=∏i=1n​mi​,Mi​=m÷mi​，tit_iti​ 是线性同余方程 Miti≡1(modmi)M_it_i\\equiv 1 \\pmod{m_i}Mi​ti​≡1(modmi​) 的一个解，也就是说 tit_iti​ 是 MiM_iMi​ 模 mim_imi​ 的逆元（显然 Mi⊥miM_i \\perp m_iMi​⊥mi​ 当且仅当 mim_imi​ 两两互质），那么 x=∑i=1naiMiti+kMx=\\sum_{i=1}^{n}a_iM_it_i + kMx=∑i=1n​ai​Mi​ti​+kM，最小非负整数解需要求 ∑i=1naiMiti mod M\\sum_{i=1}^{n}a_iM_it_i\\bmod M∑i=1n​ai​Mi​ti​modM。 为什么这是正确的呢？由于 Miti≡1(modmi)M_it_i\\equiv 1 \\pmod{m_i}Mi​ti​≡1(modmi​)，所以 aiMiti≡ai(modmi)a_iM_it_i \\equiv a_i \\pmod{m_i}ai​Mi​ti​≡ai​(modmi​)。 而且 Mj=∏i≠jmiM_j=\\prod_{i\\ne j}m_iMj​=∏i=j​mi​，也就是说对于 ∀i≠j,mi∣Mj\\forall i\\ne j, m_i\\mid M_j∀i=j,mi​∣Mj​，所以 ajtjMj≡0(modmi)a_jt_jM_j\\equiv 0\\pmod{m_i}aj​tj​Mj​≡0(modmi​)。 综上所述，可以推断出 x≡∑j=1najMjtj+kM≡ai+∑j=1,j≠in0+0≡ai(modmi)x\\equiv \\sum_{j=1}^{n} a_{j} M_{j} t_{j} + kM \\equiv a_i+\\sum_{j=1,j\\ne i}^{n} 0 +0\\equiv a_{i} \\pmod{m_i}x≡∑j=1n​aj​Mj​tj​+kM≡ai​+∑j=1,j=in​0+0≡ai​(modmi​)。 我们一个一个的来解释。x≡∑j=1najMjtj+kM(modmi)x\\equiv \\sum_{j=1}^{n} a_{j} M_{j} t_{j} + kM\\pmod{m_i}x≡∑j=1n​aj​Mj​tj​+kM(modmi​) 是显然的，因为这连个玩意相等；∑j=1najMjtj+kM≡ai+∑j=1,j≠in0+0(modmi)\\sum_{j=1}^{n} a_{j} M_{j} t_{j} + kM \\equiv a_i+\\sum_{j=1,j\\ne i}^{n} 0 +0\\pmod{m_i}∑j=1n​aj​Mj​tj​+kM≡ai​+∑j=1,j=in​0+0(modmi​)，这是因为除了 j=ij=ij=i 以外，ajtjMj≡0(modmi)a_jt_jM_j\\equiv 0\\pmod{m_i}aj​tj​Mj​≡0(modmi​)，而当 j=ij=ij=i 时，aiMiti≡ai(modmi)a_iM_it_i \\equiv a_i \\pmod{m_i}ai​Mi​ti​≡ai​(modmi​)，而且显然 kM≡0(modmi)kM\\equiv 0\\pmod{m_i}kM≡0(modmi​)，进而这个 ai+∑j=1,j≠in0+0=aia_i+\\sum_{j=1,j\\ne i}^{n} 0 +0=a_iai​+∑j=1,j=in​0+0=ai​。 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; void exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a % b, y, x); y -= a / b * x; &#125; int n; i64 mm = 1; i64 m[15], a[15], M[15], t[15]; i64 CRT(void) &#123; i64 ans = 0, x; for (int i = 1; i &lt;= n; ++i) &#123; M[i] = mm / m[i]; exgcd(M[i], m[i], t[i], x); // t[i] 为 M[i] 模 m[i] 意义下的逆元 ans = (ans + a[i] * M[i] * t[i]) % mm; &#125; return (ans % mm + mm) % mm; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", m + i, a + i); mm *= m[i]; &#125; printf(\"%lld\\n\", CRT()); return 0; &#125; exCRT 之前的模数是两两互质的，但如果是任意的怎么办？模板。 由于 CRT 算法中 MiM_iMi​ 这一奇怪的存在，导致模数任意的时候逆元不存在，也就是说 CRT 的一切都已经不再使用，我们需要设计一种新的算法。 思路大概是这样的：我们需要找到一种方式，能将两个同余方程进行合并。形式化地： {a≡r1(modm1)a≡r2(modm2)\\begin{cases} a\\equiv r_1 \\pmod{m_1}\\\\ a\\equiv r_2 \\pmod{m_2} \\end{cases} {a≡r1​(modm1​)a≡r2​(modm2​)​ 我们先假定一定可以合并，然后看看什么时候合并之后的解是 ∅\\varnothing∅。 这玩意儿等价于 a=k1m1+r1=k2m2+r2⟹k1m1−k2m2=r2−r1a=k_1m_1+r_1=k_2m_2+r_2 \\Longrightarrow k_1m_1-k_2m_2=r_2-r_1a=k1​m1​+r1​=k2​m2​+r2​⟹k1​m1​−k2​m2​=r2​−r1​。这个熟悉！二元一次不定方程！直接使用 exgcd 计算即可。 于是： 如果 gcd⁡(m1,m2)∣(r2−r1)\\gcd(m_1,m_2)\\mid (r_2-r_1)gcd(m1​,m2​)∣(r2​−r1​)，那么可以合并； 否则，exCRT 是无解的。 现在有引理：合并之后的模数是原来两个模数的 lcm。这里不做证明。所以要注意，需要保证所有数的最小公倍数是可以存的下的，否则不可以使用 exCRT！ 实际上普通 CRT 也需要满足这一点，否则 CRT 在一定范围内无解。 下面是实现过程：设当前合并的余数为 MMM，当前答案为 ansansans，那么任意一个 ans+Mxans+Mxans+Mx 都满足答案，我们需要找到一个最小的使得 ans+Mx≡a(modp)ans+Mx\\equiv a\\pmod pans+Mx≡a(modp)，可以使用扩展欧几里得来解决。 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; i64 exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, a; i64 g = exgcd(b, a % b, y, x); y -= a / b * x; return g; &#125; int n; i64 A[1000005], B[1000005]; i64 exCRT(void) &#123; i64 M = 1, ans = 0; // M 为当前合并的模数，ans 为当前答案 for (int i = 1; i &lt;= n; ++i) &#123; i64 a = M, b = B[i], x, y, c = (A[i] - ans + b) % b; i64 g = exgcd(a, b, x, y); // Mx + by = gcd(M, b) if (c % g != 0) return -1; x = (__int128)x * (c / g) % (b / g); ans = ans + M * x; M = b / g * M; ans = (ans % M + M) % M; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld%lld\", B + i, A + i); printf(\"%lld\\n\", exCRT()); return 0; &#125; Problemset 至此，基础数论的知识已经全部介绍完毕。理论上这些内容已能解决 OI 中大部分 NOIp 级别以内的数论题目（一些较难的省选级别的知识点的请参考《数论进阶》）。接下来我们看一些基础数论的题目： 简单数学 这些数学问题都是基础知识的简单应用。包括各种基础知识和素数筛法。 [UVA10780] Again Prime? No Time. Portal. 使用唯一分解定理来进行判断即可，需要预处理出素数。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int prime[10005], tot = 0; bool v[10005]; void GetPrime(void) &#123; for (int i = 2; i &lt;= 10000; ++i) if (!v[i]) &#123; prime[++tot] = i; for (int j = i * 2; j &lt;= 10000; j += i) v[j] = true; &#125; &#125; int A[10005], B[10005]; int main(void) &#123; GetPrime(); int T, n, m; scanf(\"%d\", &amp;T); for (int kase = 1; kase &lt;= T; ++kase) &#123; scanf(\"%d%d\", &amp;m, &amp;n); printf(\"Case %d:\\n\", kase); memset(A, 0, sizeof(A)); memset(B, 0, sizeof(B)); for (int i = 1; i &lt;= tot; ++i) &#123; for (int j = prime[i]; j &lt;= n; j *= prime[i]) A[i] += n / j; &#125; for (int i = 1; i &lt;= tot; ++i) while (m % prime[i] == 0) &#123; m /= prime[i]; ++B[i]; &#125; bool flag = true; int k = 2e9; for (int i = 1; i &lt;= tot; ++i) &#123; if (A[i] &lt; B[i]) &#123; flag = false; break; &#125; else if (B[i] != 0) k = min(k, A[i] / B[i]); &#125; if (!flag) puts(\"Impossible to divide\"); else printf(\"%d\\n\", k); &#125; return 0; &#125; [UVA10892] LCM Cardinality Portal. 唯一分解定理！将 nnn 进行质因数分解，然后利用唯一分解定理中最小公倍数的性质，让其中一个数等于分解后的指数，另一个就可以随便取了。根据乘法原理答案就是 ∏ci×2+1\\prod c_i\\times 2 + 1∏ci​×2+1，但是这样会算重复，需要除以二在加上一（有一组没有重复）。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; int main(void) &#123; int n, kase = 0; while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; static int C[2005]; memset(C, 0, sizeof(C)); int tot = 0, nn = n; for (int i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; ++tot; while (n % i == 0) n /= i, C[tot]++; &#125; if (n > 1) C[++tot] = 1; i64 ans = 1; for (int i = 1; i &lt;= tot; ++i) ans *= C[i] * 2 + 1; printf(\"%d %lld\\n\", nn, ans / 2 + 1); &#125; return 0; &#125; [UVA11752] The Super Powers Portal. 可以发现一定是某个数的合数次方幂，那么就可以直接枚举了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; typedef unsigned long long u64; const u64 MAXN = 18446744073709551615ull; int vis[70000]; vector &lt;u64> v; int main(void) &#123; for (int i = 2; i * i &lt;= 69000; ++i) if (!vis[i]) &#123; for (int j = i * 2; j &lt;= 69000; j += i) vis[j] = true; &#125; v.push_back(1); for (int i = 2; i &lt; 65536; ++i) &#123; u64 tmp = 1ull * i * i * i * i; for (int j = 4;; ++j) &#123; if (vis[j]) v.push_back(tmp); if (tmp &lt;= MAXN / i) tmp = tmp * i; else break; &#125; &#125; sort(v.begin(), v.end()); int m = unique(v.begin(), v.end()) - v.begin(); for (int i = 0; i &lt; m; ++i) printf(\"%llu\\n\", v[i]); return 0; &#125; [HAOI2007] 反素数 Portal. 我们可以知道，1∼n1\\sim n1∼n 中约数最多的数中最小的一个 mmm，便是 1∼n1\\sim n1∼n 中最大的反素数。为什么呢？根据 mmm 的定义，显然有 ∀x&lt;m,g(x)&lt;g(m);∀x&gt;m,g(x)≤g(m)\\forall x&lt;m, g(x)&lt;g(m); \\forall x&gt;m,g(x)\\le g(m)∀x&lt;m,g(x)&lt;g(m);∀x&gt;m,g(x)≤g(m)，前者说明 mmm 是反素数，而后者说明大于大于 mmm 的数都不是反素数。 计算一下可以知道，1∼n1\\sim n1∼n 的任何数的不同质因子不会超过 101010 个，而且它们的质数不超过 303030。 反素数分解质因数后，质因子的指数一定是单调递减的。这一点可以用反证法证明，只需要换一个质因子，就可以得到一个更小但是约数个数相等的数。 这时搜索树的规模已经降到足够小，直接 DFS 即可。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const int PRIME[] = &#123;0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;; const i64 INF = 0x7fffffff; i64 n, ans; int c[15]; int ret; void dfs(int o, i64 res, int cnt) &#123; if (o > 10) &#123; if (cnt > ret || (cnt == ret &amp;&amp; res &lt; ans)) &#123; ans = res; ret = cnt; &#125; return; &#125; i64 res0 = res; for (int i = 0; i &lt;= c[o - 1]; ++i, res0 *= PRIME[o]) &#123; if (res0 > n) return; c[o] = i; dfs(o + 1, res0, cnt * (i + 1)); // 按照乘法原理计算约数个数 &#125; &#125; int main(void) &#123; scanf(\"%lld\", &amp;n); c[0] = INF; dfs(1, 1, 1); printf(\"%lld\\n\", ans); return 0; &#125; 小专题锦集 包括筛法，exgcd 等。 [NOI2002] 荒岛野人 Portal. 题目的这个条件是什么意思？形象化地，就是对于任意两个野人，使得同余方程： Ci+xPi≡Cj+xPj(modM)C_i+xP_i\\equiv C_j+xP_j \\pmod M Ci​+xPi​≡Cj​+xPj​(modM) 没有解，或者不存在一个 x≤Li,x≤Ljx\\le L_i,x\\le L_jx≤Li​,x≤Lj​ 的解。这种问题已经很熟悉了，就是要转化为 exgcd 可以解决的形式，然后求出最小的 xxx，来看是否有解。 移项得 (Pi−Pj)x≡Cj−Ci(modM)(P_i-P_j)x\\equiv C_j-C_i \\pmod M(Pi​−Pj​)x≡Cj​−Ci​(modM)，等价于 (Pi−Pj)x−(Cj−Ci)=nM(P_i-P_j)x-(C_j-C_i)=nM(Pi​−Pj​)x−(Cj​−Ci​)=nM，也就是 (Pi−Pj)x−nM=Cj−Ci(P_i-P_j)x-nM=C_j-C_i(Pi​−Pj​)x−nM=Cj​−Ci​，使用 exgcd 计算即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #define ERROR_WRONG_DATA -1 using namespace std; int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int g = exgcd(b, a % b, y, x); y -= a / b * x; return g; &#125; int n; struct Pockets &#123; int c, p, l; bool operator &lt; (const Pockets &amp;a) const &#123; return c &lt; a.c; &#125; void summer_init(void) &#123; scanf(\"%d%d%d\", &amp;c, &amp;p, &amp;l); &#125; &#125; A[20]; bool check(int m) &#123; for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123; int a = A[i].p - A[j].p, b = m, c = A[j].c - A[i].c, x, y; if (a &lt; 0) a = -a, c = -c; int d = exgcd(a, b, x, y); if (c % d == 0) &#123; int M = m / d; x = x * (c / d); x = (x % M + M) % M; if (x &lt;= A[i].l &amp;&amp; x &lt;= A[j].l) return false; &#125; &#125; return true; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) A[i].summer_init(); sort(A + 1, A + n + 1); for (int m = A[n].c; m &lt;= 1000000; ++m) if (check(m)) &#123; printf(\"%d\\n\", m); return 0; &#125; return ERROR_WRONG_DATA; &#125; [Codefroces 449C] Jzzhu and Apples Portal. 从大到小检查所有质数，有能配对就配，奇数个就扔掉 2x2x2x 给 222 用。这样最后至多只有 111 个没有配对。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n; bool v[100005]; int p[50005], tot = 0; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= (n >> 1); ++i) &#123; if (!v[i]) p[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; ++j) &#123; v[i * p[j]] = true; if (i % p[j] == 0) break; &#125; &#125; memset(v, 0, sizeof(v)); vector&lt;pair&lt;int, int> > ans; for (int i = tot; i >= 1; --i) &#123; vector&lt;int> a; for (int j = p[i]; j &lt;= n; j += p[i]) if (!v[j]) a.push_back(j); if (a.size() &amp; 1) &#123; swap(a[1], a[a.size() - 1]); a.pop_back(); &#125; for (int j = 0; j &lt; a.size(); j += 2) &#123; v[a[j]] = v[a[j + 1]] = true; ans.push_back(&#123;a[j], a[j + 1]&#125;); &#125; &#125; printf(\"%d\\n\", ans.size()); for (auto i : ans) printf(\"%d %d\\n\", i.first, i.second); return 0; &#125; 欧拉函数 欧拉函数的应用很多。 [SDOI2008] 仪仗队 Portal。 除了 (1,2),(2,1),(2,2)(1,2),(2,1),(2,2)(1,2),(2,1),(2,2) 三个人外，一个倒霉鬼 (x,y)(x,y)(x,y) 能被看到，当且仅当 1≤x,y≤n,x≠y,gcd⁡(x,y)=11\\le x,y\\le n, x\\neq y, \\gcd(x,y)=11≤x,y≤n,x=y,gcd(x,y)=1。 由于我们不需要考虑 x=yx=yx=y 的情况，所以可以以直线 x=yx=yx=y 把队伍分成两半来做，其中一半的答案的二倍再加上抛掉的那三个就是最终的答案。 对于每个 2≤y≤n2\\le y\\le n2≤y≤n，我们只需要求出有多少个 xxx 满足 1≤x&lt;y∧(x,y)=11\\le x &lt; y \\wedge (x,y)=11≤x&lt;y∧(x,y)=1，相当于 1≤x≤y1\\le x \\le y1≤x≤y，那么这就是 φ(y)\\varphi(y)φ(y)。 所以这道题的答案就是 3+2×∑i=2n−1φ(i)3+2\\times \\sum\\limits_{i=2}^{n-1} \\varphi(i)3+2×i=2∑n−1​φ(i)，用筛法计算即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = 3; int phi[40005]; int main(void) &#123; scanf(\"%d\", &amp;n); if (n == 1) &#123; puts(\"0\"); return 0; &#125; for (int i = 1; i &lt; n; ++i) phi[i] = i; for (int i = 2; i &lt; n; ++i) if (phi[i] == i) &#123; for (int j = i; j &lt; n; j += i) phi[j] = phi[j] / i * (i - 1); &#125; for (int i = 2; i &lt; n; ++i) ans += (phi[i] &lt;&lt; 1); printf(\"%d\\n\", ans); return 0; &#125; [SDOI2008] 沙拉公主的困惑 Portal.多次询问 [1,N!][1,N!][1,N!] 中与 M!M!M! 互质的数的个数，答案对给定的质数 RRR 取模。 如果说范围是 M!M!M! 呢？那么答案显然就是 φ(M!)\\varphi(M!)φ(M!)。 由于 (a,b)=a(a,ka+b)(a,b)=a(a, ka+b)(a,b)=a(a,ka+b)，也就是说若 (M!,a)=1(M!,a)=1(M!,a)=1，那么 (M!,a+k×M!)=1(M!,a+k\\times M!)=1(M!,a+k×M!)=1，而且 M≤N⟹M!∣N!M\\le N\\Longrightarrow M!\\mid N!M≤N⟹M!∣N!，所以 φ(m!)\\varphi(m!)φ(m!) 这玩意的出现次数是每过 M!M!M! 就会循环的，而且完整循环！循环次数是 N!÷M!N!\\div M!N!÷M! 次。 答案就是 N!÷M!×φ(M!)N! \\div M! \\times \\varphi(M!)N!÷M!×φ(M!)，下面考虑如何求解这个玩意。 ans=N!÷M!×φ(M!)=N!÷M!×M!∏pi∣M!pi−1pi=N!∏pi∣M!pi−1pi\\begin{aligned} ans &amp;=N! \\div M! \\times \\varphi(M!)\\\\ &amp;=N! \\div M! \\times M! \\prod_{p_i\\mid M!} \\cfrac{p_i-1}{p_i}\\\\ &amp;=N! \\prod_{p_i\\mid M!} \\cfrac{p_i-1}{p_i} \\end{aligned} ans​=N!÷M!×φ(M!)=N!÷M!×M!pi​∣M!∏​pi​pi​−1​=N!pi​∣M!∏​pi​pi​−1​​ N!N!N! 可以预处理，后面这个东西也可以用线性筛预处理，但是要分子分母分开算，否则约分会出错。分母直接拿逆元来算就可以了。 当 N / R &gt; M / R 的时候答案为 000，因为显然 NNN 中的 RRR 根本无法约干净，取模后答案就成 000 了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; const int MAXN = 10000000; int T, R; int N, M; bool v[MAXN + 5]; int prime[MAXN], tot; int inv[MAXN + 5], f[MAXN + 5], g[MAXN + 5], h[MAXN + 5]; int main(void) &#123; scanf(\"%d%d\", &amp;T, &amp;R); inv[1] = 1; for (int i = 2; i &lt;= MAXN; ++i) inv[i] = (i64)(R - R / i) * inv[R % i] % R; f[0] = 1; for (int i = 1; i &lt;= MAXN; ++i) if (i % R != 0) f[i] = (i64)f[i - 1] * i % R; else f[i] = f[i - 1]; g[0] = g[1] = h[0] = h[1] = 1; for (int i = 2; i &lt;= MAXN; ++i) &#123; if (!v[i]) &#123; g[i] = (i64)g[i - 1] * (i - 1) % R; h[i] = (i64)h[i - 1] * (i % R != 0 ? inv[i] : 1) % R; prime[++tot] = i; &#125; else g[i] = g[i - 1], h[i] = h[i - 1]; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= MAXN; ++j) &#123; v[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125; while (T--) &#123; scanf(\"%d%d\", &amp;N, &amp;M); if (N / R > M / R) puts(\"0\"); else printf(\"%lld\\n\", (i64)f[N] * g[M] % R * h[M] % R); &#125; return 0; &#125; [Luogu P2568] GCD Portal. 给定正整数 nnn，求 1≤x,y≤n1\\le x,y\\le n1≤x,y≤n 且 gcd⁡(x,y)\\gcd(x,y)gcd(x,y) 为素数的数对 (x,y)(x,y)(x,y) 有多少对。 我们枚举 (x,y)=p(x,y)=p(x,y)=p，现在要统计这个东西。 设 x=px′,y=py′x=px&#x27;,y=py&#x27;x=px′,y=py′，则 x⊥y,x,y≤npx\\perp y,x,y\\le \\frac{n}{p}x⊥y,x,y≤pn​，不妨设 x′≤y′x&#x27;\\le y&#x27;x′≤y′，当 y′=ky&#x27;=ky′=k 时，x′x&#x27;x′ 的个数就是 φ(k)\\varphi(k)φ(k)。因此个数就是 2×∑i=1n/pφ(i)−12\\times \\sum_{i=1}^{n/p}\\varphi(i)-12×∑i=1n/p​φ(i)−1。那么线性筛处理欧拉函数前缀和即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int N = 1e7; typedef long long i64; int n, tot = 0, p[N + 5]; int phi[N + 5]; i64 s[N + 5]; int main(void) &#123; int n; scanf(\"%d\", &amp;n); phi[1] = s[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!phi[i]) phi[i] = i - 1, p[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; ++j) &#123; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; s[i] = s[i - 1] + phi[i]; &#125; i64 ans = 0; for (int i = 1; i &lt;= tot; ++i) ans += 2 * s[n / p[i]] - 1; printf(\"%lld\\n\", ans); return 0; &#125; 扩展欧拉定理 扩展欧拉定理可以用来降幂，也可以用来实现光速幂。 [Luogu P4139] 上帝与集合的正确用法 Portal. 由于保证了这玩意是个定值，而且幂次数是无限大的，所以我们可以使用扩展欧拉定理的三式进行降幂，用递归函数来计算即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; const int MAXN = 10000000; int phi[MAXN + 5]; void REFLECTION_BLUE(void) &#123; for (int i = 1; i &lt;= MAXN; ++i) phi[i] = i; for (int i = 2; i &lt;= MAXN; ++i) if (phi[i] == i) &#123; for (int j = i; j &lt;= MAXN; j += i) phi[j] = phi[j] / i * (i - 1); &#125; &#125; int poww(int a, int b, int p) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = (i64)res * a % p; a = (i64)a * a % p; b >>= 1; &#125; return res % p; &#125; int pockets(int p) // 求 2^2^...^2 mod p &#123; if (p == 1) return 1; return poww(2, pockets(phi[p]) + phi[p], p); // 2^2^..^2 % phi[p] + phi[p] 次方 &#125; int main(void) &#123; REFLECTION_BLUE(); int T; scanf(\"%d\", &amp;T); while (T--) &#123; int p; scanf(\"%d\", &amp;p); printf(\"%d\\n\", pockets(p) % p); &#125; return 0; &#125; [Ynoi2016] 炸脖龙 I Portal. 这道题同样是使用扩展欧拉定理进行降幂，注意快速幂计算和取余运算的时候每一步都需要按照扩展欧拉定理的方式来进行，也就是需要写一个新的取模函数。对于区间修改，使用一个支持“区间修改，单点查询“的树状数组即可解决。由于数较大的地方可能会爆炸，请使用 __int128，这基本上是一个模板，推荐仔细阅读代码。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; constexpr int MAXP = 20000000; constexpr int MAXN = 500000; int phi[MAXP + 5]; int v[MAXP + 5], prime[MAXP + 5], tot; inline void REFLECTION_BLUE(void) &#123; phi[1] = 1; for (i64 i = 2; i &lt;= MAXP; ++i) &#123; if (v[i] == 0) &#123; v[i] = i, prime[++tot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= MAXP; ++j) &#123; if (prime[j] > v[i]) break; v[i * prime[j]] = prime[j]; phi[i * prime[j]] = phi[i] * (i % prime[j] == 0 ? prime[j] : prime[j] - 1); &#125; &#125; &#125; int n, m; i64 A[MAXN + 5], C[MAXN + 5]; inline void update(int x, int k) &#123; while (x &lt;= n) &#123; C[x] += k; x += (x &amp; -x); &#125; &#125; inline i64 query(int x) &#123; i64 res = 0; while (x) &#123; res += C[x]; x -= (x &amp; -x); &#125; return res; &#125; inline i64 BLUE(__int128 a, int p) &#123; if (a &lt;= p) return a; return a % p + p; &#125; inline i64 poww(__int128 a, i64 b, int p) &#123; __int128 res = 1; while (b) &#123; if (b &amp; 1) res = BLUE(res * a, p); a = BLUE(a * a, p); b >>= 1; &#125; return res; &#125; i64 pocket(int l, int r, int p) &#123; // 区间 [l,r] 在 mod p 意义下的答案 if (p == 1) return 1; // 模数为 1 时，要返回 1，因为实际上要返回 BLUE(1, 1) 而不是简单的 1 mod 1 i64 t = query(l); if (l == r) return BLUE(t, p); return poww(t, pocket(l + 1, r, phi[p]), p); &#125; int main(void) &#123; REFLECTION_BLUE(); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", A + i); update(i, A[i] - A[i - 1]); &#125; while (m--) &#123; int op, l, r, x; scanf(\"%d%d%d%d\", &amp;op, &amp;l, &amp;r, &amp;x); if (op == 1) &#123; update(l, x); update(r + 1, -x); &#125; else printf(\"%lld\\n\", pocket(l, r, x) % x); &#125; return 0; &#125; [SP10050] POWTOW - Power Tower City Portal. 依然是使用扩展欧拉定理进行降幂，但是要注意 000 的讨论。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; typedef long long i64; const i64 MOD = 1e9; bool flag = false; int phi(int n) &#123; int ans = n, R = min(n, int(sqrt(n)) + 1); for (int i = 2; i &lt;= R; ++i) if (n % i == 0) &#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; if (n > 1) ans = ans / n * (n - 1); return ans; &#125; inline i64 BLUE(i64 a, i64 p) &#123; if (a &lt; p) return a; return a % p + p; &#125; i64 poww(i64 a, i64 b, i64 p) &#123; i64 res = 1; while (b) &#123; if (b &amp; 1) res = BLUE(res * a, p); a = BLUE(a * a, p); b >>= 1; &#125; return res; &#125; i64 pocket(i64 a, i64 b, i64 p) &#123; // a^a^...^a^a（b 个） % p if (p == 1) return 1; if (b == 1) return BLUE(a, p); return poww(a, pocket(a, b - 1, phi(p)), p); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; i64 a, b; scanf(\"%lld%lld\", &amp;a, &amp;b); if (a == 0) printf(\"%d\\n\", b % 2 == 0); else if (b == 0) puts(\"1\"); else &#123; i64 ans = pocket(a, b, MOD); if (ans >= MOD) printf(\"...%09lld\\n\", ans % MOD); else printf(\"%lld\\n\", ans); &#125; &#125; return 0; &#125; [Luogu 5110] 块速递推 Portal. 多次询问（而且真多）一个递推式的第 nnn 项，而且询问的内容在 64 位无符号整数内，可以肯定不是矩阵快速幂加速递推，需要把这个东西写成通项公式再做。 写通项公式的方式有很多，这里使用搞斐波那契数列的特征方程来做： 设 an=233an−1+666an−2a_n=233a_{n-1}+666a_{n−2}an​=233an−1​+666an−2​ 的特征方程为： xn+2=233xn+1+666xnx2=233x+666x2−233x−666=0x1=233+569532,x2=233−569532x^{n+2}=233x^{n+1}+666x^n\\\\ x^2=233x+666\\\\ x^2-233x-666=0\\\\ x_1=\\frac{233+\\sqrt{56953}}{2},x_2=\\frac{233-\\sqrt{56953}}{2} xn+2=233xn+1+666xnx2=233x+666x2−233x−666=0x1​=2233+56953​​,x2​=2233−56953​​ 然后开始算方程组： an=px1n+qx2n,∵a0=0,a1=1∴{p+q=0,px1+qx2=1,∴{p+q=0,p×233+569532+q×233−569532=1,∴{p=156953,q=−156953,∴an=156953(233+569532)n−156953(233−569532)n,∴an=156953((233+569532)n−(233−569532)n)a_n=px_1^{n}+qx_2^n,\\\\ \\because a_0=0,a_1=1\\\\ \\therefore \\begin{cases} p+q=0,\\\\ px_1+qx_2=1, \\end{cases}\\\\ \\therefore \\begin{cases} p+q=0,\\\\ p\\times\\cfrac{233+\\sqrt{56953}}{2}+q\\times\\cfrac{233-\\sqrt{56953}}{2}=1, \\end{cases}\\\\ \\therefore \\begin{cases} p=\\cfrac{1}{\\sqrt{56953}},\\\\ q=-\\cfrac{1}{\\sqrt{56953}}, \\end{cases}\\\\ \\therefore a_n=\\cfrac{1}{\\sqrt{56953}}\\left(\\frac{233+\\sqrt{56953}}{2}\\right)^{n}-\\cfrac{1}{\\sqrt{56953}}\\left(\\frac{233-\\sqrt{56953}}{2}\\right)^{n},\\\\ \\therefore a_n=\\cfrac{1}{\\sqrt{56953}}\\left(\\left(\\frac{233+\\sqrt{56953}}{2}\\right)^{n}-\\left(\\frac{233-\\sqrt{56953}}{2}\\right)^{n}\\right) an​=px1n​+qx2n​,∵a0​=0,a1​=1∴{p+q=0,px1​+qx2​=1,​∴⎩⎨⎧​p+q=0,p×2233+56953​​+q×2233−56953​​=1,​∴⎩⎨⎧​p=56953​1​,q=−56953​1​,​∴an​=56953​1​(2233+56953​​)n−56953​1​(2233−56953​​)n,∴an​=56953​1​((2233+56953​​)n−(2233−56953​​)n) 这个式子是化简不动了，但是注意这题是对 109+710^9+7109+7 取模，然后就可以利用之前的无理数取模，发现 188305837188305837188305837 跟 56953\\sqrt{56953}56953​ 是同余的。然后就可以做成（注意利用在数论初步中讲的负数取模，可得 −94152802 mod 109+7=905847205-94152802 \\bmod 10^9+7=905847205−94152802mod109+7=905847205）： an=1188305837((233+1883058372)n−(233−1883058372)n)an=1188305837(94153035n−(−94152802)n)an=1188305837(94153035n−905847205n)a_n=\\cfrac{1}{188305837}\\left(\\left(\\frac{233+188305837}{2}\\right)^{n}-\\left(\\frac{233-188305837}{2}\\right)^{n}\\right)\\\\ a_n=\\cfrac{1}{188305837}\\left(94153035^{n}-(-94152802)^{n}\\right)\\\\ a_n=\\cfrac{1}{188305837}\\left(94153035^{n}-905847205^{n}\\right) an​=1883058371​((2233+188305837​)n−(2233−188305837​)n)an​=1883058371​(94153035n−(−94152802)n)an​=1883058371​(94153035n−905847205n) 利用有理数取模，知 1188305837≡233230706(mod109+7)\\cfrac{1}{188305837}\\equiv 233230706 \\pmod{10^9+7}1883058371​≡233230706(mod109+7)，所以最终式子化为： an=233230706(94153035n−905847205n)a_n=233230706(94153035^{n}-905847205^{n}) an​=233230706(94153035n−905847205n) 然后就可以正常使用光速幂计算了。注意 109+710^9+7109+7 是质数（φ(109+7)=109+6\\varphi(10^9+7)=10^9+6φ(109+7)=109+6），而且底数小于这个质数（即互质），所以降幂的时候用一式降幂即可。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; using u64 = unsigned long long; using i64 = long long; const int MOD = 1000000007; namespace Mker &#123; unsigned long long SA, SB, SC; void init() &#123; scanf(\"%llu%llu%llu\", &amp;SA, &amp;SB, &amp;SC); &#125; unsigned long long rand() &#123; SA ^= SA &lt;&lt; 32, SA ^= SA >> 13, SA ^= SA &lt;&lt; 1; unsigned long long t = SA; SA = SB, SB = SC, SC ^= t ^ SA; return SC; &#125; &#125; int t; int f1[33000], f2[66000], f3[33000], f4[66000]; inline int pow1(int n) &#123; return (i64)f2[n / t] * f1[n % t] % MOD; &#125; inline int pow2(int n) &#123; return (i64)f4[n / t] * f3[n % t] % MOD; &#125; int main(void) &#123; int T, ans = 0; scanf(\"%d\", &amp;T); Mker::init(); f1[0] = f2[0] = f3[0] = f4[0] = 1; t = sqrt(MOD + 0.5); for (int i = 1; i &lt;= t; ++i) f1[i] = (i64)f1[i - 1] * 94153035 % MOD; for (int i = 1; i &lt;= (t &lt;&lt; 1); ++i) f2[i] = (i64)f2[i - 1] * f1[t] % MOD; for (int i = 1; i &lt;= t; ++i) f3[i] = (i64)f3[i - 1] * 905847205 % MOD; for (int i = 1; i &lt;= (t &lt;&lt; 1); ++i) f4[i] = (i64)f4[i - 1] * f3[t] % MOD; while (T--) &#123; u64 n = Mker::rand() % (MOD - 1); // phi(MOD) = MOD - 1 ans ^= (u64)233230706 * (pow1(n) - pow2(n) + MOD) % MOD; &#125; printf(\"%d\\n\", ans); return 0; &#125; 中国剩余定理 包括 CRT 和 exCRT。 [TJOI2009] 猜数字 Portal. 直接使用 CRT，但是小心爆 long long。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; void exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a % b, y, x); y -= a / b * x; &#125; int n; i64 a[15], b[15], M[15], t[15]; i64 CRT(void) &#123; i64 mm = 1, ans = 0, x; for (int i = 1; i &lt;= n; ++i) mm *= b[i]; for (int i = 1; i &lt;= n; ++i) &#123; M[i] = mm / b[i]; exgcd(M[i], b[i], t[i], x); ans = ans + ((__int128)a[i] * M[i] % mm * t[i]) % mm; &#125; return (ans % mm + mm) % mm; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", b + i); printf(\"%lld\\n\", CRT()); return 0; &#125; [NOI2018] 屠龙勇士 Portal. 实际上依然是 exCRT，只不过方程换成了 bx≡a(modp)bx\\equiv a\\pmod pbx≡a(modp)。这样是一样的，设当前合并的模数为 MMM，答案为 ansansans，那么下一个合并要满足 b(ans+Mx)≡a(modp)b(ans+Mx)\\equiv a\\pmod pb(ans+Mx)≡a(modp)，也就是 bMx−py=a−b×ansbMx-py=a-b\\times ansbMx−py=a−b×ans。 注意一个细节：解出来的解必须能将龙打掉，也就是能将血打成小于等于 000，否则即使满足同余方程也没用。记录一个能把血量打成负数的最小攻击次数，然后如果答案小于这个攻击次数，答案就加上还需要打的次数。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;set> using namespace std; typedef long long i64; i64 exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) &#123; if (b == 0) return x = 1, y = 0, a; i64 g = exgcd(b, a % b, y, x); y -= a / b * x; return g; &#125; int n, m; i64 a[100005], p[100005], mx = 0; int sword[100005]; int atk[100005]; multiset&lt;i64> s; i64 exCRT(void) &#123; i64 M = 1, ans = 0; i64 x, y, g, A, B, C; for (int i = 1; i &lt;= n; ++i) &#123; A = (__int128)atk[i] * M % p[i]; B = p[i]; C = (a[i] - ans * atk[i] % p[i] + p[i]) % p[i]; g = exgcd(A, B, x, y); if (C % g != 0) return -1; x = (x % B + B) % B; ans += (__int128)(C / g) * x % (B / g) * M; M *= B / g; ans %= M; &#125; if (ans &lt; mx) ans += ((mx - ans - 1) / M + 1) * M; return ans; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); s.clear(); mx = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", p + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", sword + i); for (int i = 1, x; i &lt;= m; ++i) &#123; scanf(\"%d\", &amp;x); s.insert(x); &#125; for (int i = 1; i &lt;= n; ++i) &#123; auto it = s.upper_bound(a[i]); if (it != s.begin()) --it; atk[i] = *it; s.erase(it); s.insert(sword[i]); mx = max(mx, (a[i] - 1) / atk[i] + 1); &#125; printf(\"%lld\\n\", exCRT()); &#125; return 0; &#125; 综合应用 这些是基础数论算法较为综合的应用。 [NOI2015] 寿司晚宴 Portal. 最暴力的做法就是设 fS1,S2f_{S_1,S_2}fS1​,S2​​ 代表两人选的质因数状压后分别为 S1,S2S_1,S_2S1​,S2​，发现 n≤500n\\le 500n≤500，比 191919 大的质因数最多出现一次。可以单独记录这个大质因数，然后把每一个有这个大质因数的寿司设为一组，在这一组进行转移时另记 g1,g2g_1,g_2g1​,g2​ 分别代表只允许这两个人其中一个吃有这个大质因数的寿司，最后合并答案的时候还要减去最初的 fff，因为两个人都不吃的算了两次。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int prime[] = &#123;2, 3, 5, 7, 11, 13, 17, 19&#125;; int n, P; int f[256][256], g1[256][256], g2[256][256]; // g1 表示 1 取 big，g2 表示 2 取 big struct Number &#123; int val, S, big; void init(void) &#123; int tmp = val; big = -1; for (int i = 0; i &lt; 8; ++i) if (tmp % prime[i] == 0) &#123; S |= 1 &lt;&lt; i; while (tmp % prime[i] == 0) tmp /= prime[i]; &#125; if (tmp != 1) big = tmp; &#125; bool operator &lt; (const Number &amp;a) const &#123; return big &lt; a.big; &#125; &#125; a[505]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;P); f[0][0] = 1; for (int i = 1; i &lt; n; ++i) a[i].val = i + 1, a[i].init(); sort(a + 1, a + n + 1); for (int i = 1; i &lt; n; ++i) &#123; if (i == 1 || a[i].big == -1 || a[i].big != a[i - 1].big) &#123; memcpy(g1, f, sizeof g1); memcpy(g2, f, sizeof g2); &#125; for (int j = 255; j >= 0; --j) for (int k = 255; k >= 0; --k) if ((j &amp; k) == 0) &#123; if ((a[i].S &amp; k) == 0) g1[j | a[i].S][k] = (g1[j | a[i].S][k] + g1[j][k]) % P; if ((a[i].S &amp; j) == 0) g2[j][k | a[i].S] = (g2[j][k | a[i].S] + g2[j][k]) % P; &#125; if (i == n - 1 || a[i].big == -1 || a[i].big != a[i + 1].big) &#123; for (int j = 0; j &lt; 256; ++j) for (int k = 0; k &lt; 256; ++k) if ((j &amp; k) == 0) f[j][k] = (g1[j][k] + g2[j][k] - f[j][k]) % P; &#125; &#125; int ans = 0; for (int i = 0; i &lt; 256; ++i) for (int j = 0; j &lt; 256; ++j) if ((i &amp; j) == 0) ans = (ans + f[i][j]) % P; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; 实际上这个垂直符号仅在 OI 中使用，笔者在各类数学教材中并没有见到这个符号，但是在《具体数学》这种计算机数学教材中就有见到。 ↩︎ 没有题号的题目可能是经典问题，或者笔者太弱了找不到出处。 ↩︎ 如果你想要较真，实际上 gcd⁡\\gcdgcd 才是万恶之源，说是“数论只会 gcd⁡\\gcdgcd”，但这也恰恰证明了 gcd⁡\\gcdgcd 无与伦比的重要性。 ↩︎","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"可持久化与嵌套数据结构","slug":"notes/DS/sx-ds-1","date":"2023-01-31T00:00:00.000Z","updated":"2023-01-31T00:00:00.000Z","comments":true,"path":"32a993e5/","link":"","permalink":"https://james1badcreeper.github.io/32a993e5/","excerpt":"可持久化数据结构可以保留每一个历史版本，嵌套则指的是“树套树”，将数据结构嵌套来实现更加强大的功能。","text":"可持久化数据结构可以保留每一个历史版本，嵌套则指的是“树套树”，将数据结构嵌套来实现更加强大的功能。 可持久化数据结构 大致意思上是可以保留数据结构的历史版本，不过还有更多的用处。 概念 所有版本都可以访问，但是只有最新版本可以修改，称之为部分可持久化。 所有版本都既可以访问又可以修改，称之为完全可持久化。 若支持将两个历史版本合并，则又称为汇合可持久化（Confluently Persistent）。 无论如何，基本思想是修改时要保留原来的内容。 可持久化线段树 毫无疑问，这是最重要的可持久化数据结构，因为它可以用来实现可持久化数组，进而实现更多内容。 概述 当我们进行修改的时候，最暴力的想法就是：我再建一棵线段树不就得了嘛！ 但是你觉得可能吗？空间炸裂了…… 对于点修改来说，一次修改至多会影响 O(log⁡n)O(\\log n)O(logn) 个节点，所以我们只需要复制这 O(log⁡n)O(\\log n)O(logn) 个节点即可。但是复制？这样的话就需要记录左右儿子的编号，实现的时候需要采用动态开点，这样可以将新建的节点的儿子编号拉到原线段树上。 struct Node &#123; int lc, rc; // 左右节点编号 int dat; // 当前维护的值 &#125;T[SIZE * 2]; // 终于只需要二倍空间啦！ int root[MAXQ], tot; // 每次修改的根节点编号，节点个数 int build(int l, int r) &#123; int o = ++tot; if (l == r) return T[o].dat = a[l], o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); T[o].dat = T[T[o].lc].dat + T[T[o].rc].dat; return o; &#125; int main(void) &#123; root[0] = build(1, n); // 建立初始的可持久化线段树 &#125; 点修改 在修改的时候，变化的内容的节点编号要新建，而没有变化的直接复制原来的版本信息即可。 修改了位置 1 的值，只有节点 1248 的值会发生变化，需要新建 int main(void) &#123; root[i] = update(root[i - 1], 1, n, x, k); // 在第 i - 1 个版本的基础上创建第 i 个版本 &#125; int update(int pre, int l, int r, int x, int k) &#123; // 在 pre 号节点的基础上，x 加上 k int o = ++tot; // 先新建这个节点 T[o] = T[pre]; // 先把原来的东西复制过来 if (l == r) return T[o].dat += k, o; // 叶子节点直接修改 int mid = l + r >> 1; if (x &lt;= mid) T[o].lc = update(T[pre].lc, l, mid, x, k); // 修改的内容在左子区间，将左儿子的编号修改为新建节点的编号 else T[o].rc = update(T[pre].rc, mid + 1, r, x, k); // 修改的内容在右子区间，修改右儿子的编号 T[o].dat = T[T[o].lc].dat + T[T[o].rc].dat; // 维护当前节点的值 return o; // 返回当前节点 &#125; 这种实现可持久化的方式称为 Path Copy，在竞赛中功能是足够的，但问题是消耗的空间较大（但是一般没人卡）。 可持久化数组 模板。 可持久化线段树可以用来实现可持久化数组，而且非常简单，因为只需要做到单点修改和单点查询。 所以 maintain 之类的操作根本不需要，查询的时候几乎跟普通线段树一模一样。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; struct Node &#123; int lc, rc; int dat; &#125; T[44000005]; int tot, root[1000005]; int n, m; int a[1000005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return T[o].dat = a[l], o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return T[o].dat = k, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].lc = update(T[pre].lc, l, mid, x, k); else T[o].rc = update(T[pre].rc, mid + 1, r, x, k); return o; &#125; int query(int o, int l, int r, int x) &#123; if (l == r) return T[o].dat; int mid = l + r >> 1; if (x &lt;= mid) return query(T[o].lc, l, mid, x); return query(T[o].rc, mid + 1, r, x); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); root[0] = build(1, n); for (int i = 1; i &lt;= m; ++i) &#123; int pre, op, x, k; scanf(\"%d%d%d\", &amp;pre, &amp;op, &amp;x); if (op == 1) &#123; scanf(\"%d\", &amp;k); root[i] = update(root[pre], 1, n, x, k); &#125; else printf(\"%d\\n\", query(root[i] = root[pre], 1, n, x)); &#125; return 0; &#125; 可持久化并查集 模板。基于可持久化数组可以实现可持久化并查集（将并查集的数组可持久化即可），但是注意路径压缩会使得树的形态改变而无法可持久化，因此只能使用按秩合并。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int N = 100005; int n, m, ver; struct Node &#123; int ls, rs; int dat; &#125;; struct SegmentTree &#123; Node T[N * 40]; int tot, root[200005], a[100005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return T[o].dat = a[l], o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return T[o].dat = k, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x, k); else T[o].rs = update(T[pre].rs, mid + 1, r, x, k); return o; &#125; int query(int o, int l, int r, int x) &#123; if (l == r) return T[o].dat; int mid = l + r >> 1; if (x &lt;= mid) return query(T[o].ls, l, mid, x); return query(T[o].rs, mid + 1, r, x); &#125; &#125; fa, siz; int find(int x) &#123; int tmp = fa.query(fa.root[ver], 1, n, x); if (tmp == x) return x; return find(tmp); &#125; void merge(int x, int y) &#123; x = find(x), y = find(y); if (x == y) return; int sx = siz.query(siz.root[ver], 1, n, x), sy = siz.query(siz.root[ver], 1, n, y); if (sx > sy) swap(x, y), swap(sx, sy); fa.root[ver] = fa.update(fa.root[ver], 1, n, x, y); siz.root[ver] = siz.update(siz.root[ver], 1, n, y, sx + sy); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) fa.a[i] = i, siz.a[i] = 1; fa.root[0] = fa.build(1, n); siz.root[0] = siz.build(1, n); for (ver = 1; ver &lt;= m; ++ver) &#123; int op, x, y; scanf(\"%d%d\", &amp;op, &amp;x); fa.root[ver] = fa.root[ver - 1]; siz.root[ver] = siz.root[ver - 1]; if (op == 1) &#123; scanf(\"%d\", &amp;y); merge(x, y); &#125; else if (op == 2) &#123; fa.root[ver] = fa.root[x]; siz.root[ver] = siz.root[x]; &#125; else &#123; scanf(\"%d\", &amp;y); puts(find(x) == find(y) ? \"1\" : \"0\"); &#125; &#125; return 0; &#125; 主席树 也就是可持久化权值线段树。 模板。 我们可以依次读入这些数后离散化，然后扫描每个数，建立主席树，第 kkk 个版本维护 [1,k][1,k][1,k] 各个数值。由于权值树是可以直接相加或相减的，所以整个过程类似于差分。 正常的方式是二分出答案，可以很方便的知道有多少个小于 xxx 的数。这样就可以直接在主席树上二分，在离散化后，假设有 mmm 个数，那么值域就变为了 [1,m][1,m][1,m]。datdatdat 代表所对应的值域 [L,R][L,R][L,R] 插入了多少个数。插入一个数后，就要在它离散化后的位置上加上 111。查询的时候，有 T[ri].dat−T[li−1].datT[r_i].dat - T[l_i-1].datT[ri​].dat−T[li​−1].dat 的值就是 [li,ri][l_i,r_i][li​,ri​] 中有多少个数落在值域 [L,R][L,R][L,R] 上。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; const int MAXN = 200005; struct Node &#123; int lc, rc; int dat; &#125;T[MAXN * 20]; int tot, root[200005]; int n, Q, m; int a[200005]; int tmp[200005]; void init(void) &#123; for (int i = 1; i &lt;= n; ++i) tmp[i] = a[i]; sort(tmp + 1, tmp + n + 1); m = unique(tmp + 1, tmp + n + 1) - (tmp + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(tmp + 1, tmp + m + 1, a[i]) - tmp; &#125; int build(int l, int r) // 一开始只是新建节点，但是没有数值 &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) &#123; T[o].dat += k; return o; &#125; int mid = l + r >> 1; if (x &lt;= mid) T[o].lc = update(T[pre].lc, l, mid, x, k); else T[o].rc = update(T[pre].rc, mid + 1, r, x, k); T[o].dat = T[T[o].lc].dat + T[T[o].rc].dat; return o; &#125; int query(int p, int q, int l, int r, int k) // 查询的时候同步进行查询 &#123; if (l == r) return l; // 值域只有一个，直接返回 int mid = l + r >> 1, res = T[T[q].lc].dat - T[T[p].lc].dat; // 落在 [L, mid] 的值域的数的个数 if (k &lt;= res) return query(T[p].lc, T[q].lc, l, mid, k); // 要查的比 res 小，在左子节点查 return query(T[p].rc, T[q].rc, mid + 1, r, k - res); // 比 res 大，减去 res 在右子节点查 &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;Q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); init(); root[0] = build(1, m); for (int i = 1; i &lt;= n; ++i) root[i] = update(root[i - 1], 1, m, a[i], 1); while (Q--) &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", tmp[query(root[l - 1], root[r], 1, m, k)]); &#125; return 0; &#125; 至于空间到底开多大，要看修改次数，然后按照空间复杂度计算即可，如果内存限制允许可以稍微开大一点。本题中 ⌈log⁡22×105⌉=18\\lceil\\log_2 2\\times 10^5\\rceil=18⌈log2​2×105⌉=18，再加上一个初始版本的两倍空间，开到 202020 倍空间就足够了。 很显然这种问题如果不强制在线的话可以直接使用整体二分解决。 区间修改 如果正常使用永久化的话可以非常简单的支持区间修改，模板，代码如下： #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[100005]; struct Node &#123; int ls, rs; i64 v, tag; &#125; T[40 * 100005]; int rt[100005], tot; int build(int l, int r) &#123; int o = ++tot; if (l == r) return T[o].v = a[l], o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); T[o].v = T[T[o].ls].v + T[T[o].rs].v; return o; &#125; int update(int pre, int l, int r, int x, int y, int k) &#123; int o = ++tot; T[o] = T[pre]; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].tag += k, T[o].v += (r - l + 1) * k, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[o].ls, l, mid, x, y, k); if (mid &lt; y) T[o].rs = update(T[o].rs, mid + 1, r, x, y, k); T[o].v = T[T[o].ls].v + T[T[o].rs].v + T[o].tag * (r - l + 1); return o; &#125; i64 query(int o, int l, int r, int x, int y, i64 tag) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].v + tag * (r - l + 1); int mid = l + r >> 1; i64 ans = 0; tag += T[o].tag; if (x &lt;= mid) ans += query(T[o].ls, l, mid, x, y, tag); if (mid &lt; y) ans += query(T[o].rs, mid + 1, r, x, y, tag); return ans; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; rt[0] = build(1, n); for (int i = 1, t = 0; i &lt;= m; ++i) &#123; char op; int l, r, k; cin >> op; if (op == 'C') &#123; cin >> l >> r >> k; ++t; rt[t] = update(rt[t - 1], 1, n, l, r, k); &#125; else if (op == 'Q') &#123; cin >> l >> r; cout &lt;&lt; query(rt[t], 1, n, l, r, 0) &lt;&lt; \"\\n\"; &#125; else if (op == 'H') &#123; cin >> l >> r >> k; cout &lt;&lt; query(rt[k], 1, n, l, r, 0) &lt;&lt; \"\\n\"; &#125; else cin >> t; &#125; return 0; &#125; 可持久化 Trie 按照以下步骤可以在可持久化 Trie 中插入一个字符串： 设当前根节点为 xxx，基于 preprepre 版本建立； 先将 xxx 的儿子全部指向 preprepre 的儿子，然后将要插入的数值指向一个新建节点； 同时让 x,prex,prex,pre 往下走，并回到第 222 步直到扫描完整个字符串。 实际上大部分需要使用可持久化 Trie 的题目中使用的都是可持久化 01 Trie。 [Luogu P4735] 最大异或和。利用差分的思想，求出前缀异或和，这样就是求 x⊕s[N]⊕a[p](l−1≤p≤r−1)x\\oplus s[N]\\oplus a[p](l-1\\le p\\le r-1)x⊕s[N]⊕a[p](l−1≤p≤r−1)。然后在 Trie 树插入时记录 valvalval 代表当前节点的出现次数，差分的时候就可以直接用两个版本相减得知当前节点是否出现。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int a[600005], s[600005]; int root[600005], tot, ch[18600005][2], val[18600005]; void insert(int x, int pre, int v) &#123; for (int i = 28; i >= 0; --i) &#123; val[x] = val[pre] + 1; int c = 1 &lt;&lt; i &amp; v ? 1 : 0; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; pre = ch[pre][c]; &#125; val[x] = val[pre] + 1; &#125; int query(int x, int y, int v) &#123; int res = 0; for (int i = 28; i >= 0; --i) &#123; int c = 1 &lt;&lt; i &amp; v ? 1 : 0; if (val[ch[x][!c]] - val[ch[y][!c]]) res |= 1 &lt;&lt; i, x = ch[x][!c], y = ch[y][!c]; else x = ch[x][c], y = ch[y][c]; &#125; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); s[i] = s[i - 1] ^ a[i]; root[i] = ++tot; insert(root[i], root[i - 1], s[i]); &#125; char op[5]; int l, r, x; while (m--) &#123; scanf(\"%s\", op); if (op[0] == 'A') &#123; ++n; scanf(\"%d\", a + n); s[n] = s[n - 1] ^ a[n]; root[n] = ++tot; insert(root[n], root[n - 1], s[n]); &#125; else &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;x); if (l == 1) printf(\"%d\\n\", max(s[n] ^ x, query(root[r - 1], 0, s[n] ^ x))); else printf(\"%d\\n\", query(root[r - 1], root[l - 2], s[n] ^ x)); &#125; &#125; return 0; &#125; 可持久化平衡树 平衡树也是可以持久化的，而且大部分平衡树都可以可持久化。如果是插入删除的平衡树（Treap），只需要在修改的路径上和旋转的时候复制一下即可。对于维护父亲节点的平衡树如果可持久化后常数会爆炸，所以不常用。 对于分裂合并的平衡树，只需要在分裂合并时新建节点，这样非常方便。主要的作用是可以复制区间，其它方面意义不大。因为可持久化 Trie 也可以维护权值，而且跑的往往比平衡树快。 一般 OI 中能用到的只有可持久化 FHQ-Treap。模板，在 merge 的时候也应该复制节点，但是本题并没有单独需要调用 merge 的，merge 操作只是为了合并分裂后的序列，因此不需要复制新节点。代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 200005; typedef long long i64; mt19937 Rand(time(0)); struct Node &#123; int siz, rnd; i64 sum, val; int ls, rs; bool rev; &#125; T[N * 105]; int tot, root[N]; int newNode(i64 v) &#123; ++tot; T[tot].siz = 1; T[tot].rnd = Rand(); T[tot].sum = T[tot].val = v; return tot; &#125; int copyNode(int x) &#123; T[++tot] = T[x]; return tot; &#125; void pushup(int p) &#123; T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz + 1; T[p].sum = T[T[p].ls].sum + T[T[p].rs].sum + T[p].val; &#125; void pushdown(int p) &#123; if (!T[p].rev) return; if (T[p].ls) T[T[p].ls = copyNode(T[p].ls)].rev ^= 1; if (T[p].rs) T[T[p].rs = copyNode(T[p].rs)].rev ^= 1; swap(T[p].ls, T[p].rs); T[p].rev = 0; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); int o = copyNode(p); pushdown(o); if (T[T[o].ls].siz + 1 &lt;= S) &#123; x = o; split(T[o].rs, S - T[T[o].ls].siz - 1, T[o].rs, y); &#125; else &#123; y = o; split(T[o].ls, S, x, T[o].ls); &#125; pushup(o); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; pushdown(x); T[x].rs = merge(T[x].rs, y); pushup(x); return x; &#125; else &#123; pushdown(y); T[y].ls = merge(x, T[y].ls); pushup(y); return y; &#125; &#125; int main(void) &#123; int m, v, op, p, l, r, a, b, c; scanf(\"%d\", &amp;m); i64 x, last = 0; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", &amp;v, &amp;op); root[i] = root[v]; if (op == 1) &#123; scanf(\"%d%lld\", &amp;p, &amp;x); p ^= last, x ^= last; split(root[i], p, a, b); b = merge(newNode(x), b); root[i] = merge(a, b); &#125; else if (op == 2) &#123; scanf(\"%d\", &amp;p); p ^= last; split(root[i], p - 1, a, b); split(b, 1, b, c); root[i] = merge(a, c); &#125; else if (op == 3) &#123; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; split(root[i], l - 1, a, b); split(b, r - l + 1, b, c); T[b].rev ^= 1; root[i] = merge(a, merge(b, c)); &#125; else &#123; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; split(root[i], l - 1, a, b); split(b, r - l + 1, b, c); printf(\"%lld\\n\", last = T[b].sum); root[i] = merge(a, merge(b, c)); &#125; &#125; return 0; &#125; 嵌套数据结构 当问题不是强制在线时，往往可以使用 CDQ 分治或整体二分来解决。下面介绍的嵌套都属于树套树，但也有不是树套树的嵌套数据结构，比如底层分块和树套 vector 之类的。应用非常灵活，面对不同的问题设计合适的数据结构即可。 概述 最简单的例子是树状数组套树，比如大家都写过的树状数组套树状数组： for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= n; j += lowbit(j)) C[i][j] += k; 实际上这是什么？一个树状数组里面保存的不是数，而是一个树状数组。比如说我现在要支持单点修改，查询区间中小于等于 yyy 的数的个数，只需要像这样： void update(int x, int k) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; remove(root[i], a[i]); // 平衡树操作 insert(root[i], k); &#125; &#125; int query(int x, int k) &#123; int res = 0; for (int i = x; i; i -= lowbit(i)) res += rank(root[i], y); return res; &#125; 由于只会访问到 log⁡\\loglog 棵平衡树，所以单次操作时间复杂度为 O(log⁡2n)O(\\log^2 n)O(log2n)。 这是搞什么的？普通的树状数组可以支持单点修改，区间查询值，可以使用一个数组来维护。树状数组套平衡树用到了一个可以插入删除查询排名的平衡树，还需要支持序列的单点修改和区间查询，因此可以使用一个平衡树数组来维护。于是就有了树状数组套平衡树。 线段树套平衡树 模板。维护一个序列，支持单点修改，查询区间排名、区间 kth、区间前驱后继。 由于查询的东西不可以差分，因此无法使用树状数组套树求解，因此考虑线段树套树。 普通的线段树维护每一个区间的信息，每次修改更新 log⁡n\\log nlogn 个节点的和，每次查询用 log⁡n\\log nlogn 个不相交的线段来求出答案。而线段树套平衡树则每个节点用一棵平衡树来储存当前节点所代表的区间的信息，每次修改更新 log⁡n\\log nlogn 棵平衡树，每次查询用 log⁡n\\log nlogn 个不相交的节点的平衡树拼出答案。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 2147483647; mt19937 Rand(time(0)); struct TreapNode &#123; int ch[2], siz, rnd, cnt; int val; &#125; T[2000005]; int tot; void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + T[p].cnt; &#125; int newNode(int val) &#123; ++tot; T[tot].rnd = Rand(); T[tot].val = val; T[tot].cnt = T[tot].siz = 1; T[tot].ch[0] = T[tot].ch[1] = 0; return tot; &#125; void rotate(int&amp; p, int d) &#123; // d = 0 左旋，d = 1 右旋 int q = T[p].ch[d ^ 1]; T[p].ch[d ^ 1] = T[q].ch[d]; T[q].ch[d] = p; p = q; maintain(T[p].ch[d]); maintain(p); &#125; void insert(int &amp;p, int val) &#123; if (!p) p = newNode(val); else if (val == T[p].val) ++T[p].cnt; else &#123; int d = (val &lt; T[p].val ? 0 : 1); insert(T[p].ch[d], val); if (T[T[p].ch[d]].rnd > T[p].rnd) rotate(p, d ^ 1); &#125; maintain(p); &#125; void Remove(int &amp;p, int val) &#123; if (!p) return; if (val == T[p].val) &#123; if (T[p].cnt > 1) --T[p].cnt; else &#123; if (!T[p].ch[0] &amp;&amp; !T[p].ch[1]) p = 0; else &#123; if (!T[p].ch[0]) rotate(p, 0), Remove(T[p].ch[0], val); else if (!T[p].ch[1]) rotate(p, 1), Remove(T[p].ch[1], val); else &#123; int d = T[T[p].ch[0]].rnd > T[T[p].ch[1]].rnd ? 1 : 0; rotate(p, d); Remove(T[p].ch[d], val); &#125; &#125; &#125; &#125; else Remove(T[p].ch[val &lt; T[p].val ? 0 : 1], val); if (p) maintain(p); &#125; int Rank(int p, int val) &#123; // 小于 val 的数的个数 if (!p) return 0; if (val &lt; T[p].val) return Rank(T[p].ch[0], val); if (val == T[p].val) return T[T[p].ch[0]].siz; return T[T[p].ch[0]].siz + T[p].cnt + Rank(T[p].ch[1], val); &#125; int GetPre(int p, int k) &#123; if (!p) return -INF; if (T[p].val >= k) return GetPre(T[p].ch[0], k); return max(T[p].val, GetPre(T[p].ch[1], k)); &#125; int GetSuf(int p, int k) &#123; if (!p) return INF; if (T[p].val &lt;= k) return GetSuf(T[p].ch[1], k); return min(T[p].val, GetSuf(T[p].ch[0], k)); &#125; int n, m; int a[50005], root[200005]; void build(int o, int l, int r) &#123; for (int i = l; i &lt;= r; ++i) insert(root[o], a[i]); if (l == r) return; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int o, int l, int r, int x, int k) &#123; Remove(root[o], a[x]); insert(root[o], k); if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); &#125; int queryRank(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return Rank(root[o], k); int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += queryRank(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) res += queryRank(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); return res; &#125; int queryPre(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return GetPre(root[o], k); int mid = l + r >> 1, res = -INF; if (x &lt;= mid) res = max(res, queryPre(o &lt;&lt; 1, l, mid, x, y, k)); if (mid &lt; y) res = max(res, queryPre(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k)); return res; &#125; int querySuf(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return GetSuf(root[o], k); int mid = l + r >> 1, res = INF; if (x &lt;= mid) res = min(res, querySuf(o &lt;&lt; 1, l, mid, x, y, k)); if (mid &lt; y) res = min(res, querySuf(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k)); return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); while (m--) &#123; int op, l, r, pos, k; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", queryRank(1, 1, n, l, r, k) + 1); &#125; else if (op == 2) &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); // 排名为 k 的数 int L = -1, R = 100000001; while (L + 1 != R) &#123; int mid = L + R >> 1; if (queryRank(1, 1, n, l, r, mid) &lt; k) L = mid; else R = mid; &#125; printf(\"%d\\n\", L); &#125; else if (op == 3) &#123; scanf(\"%d%d\", &amp;pos, &amp;k); update(1, 1, n, pos, k); a[pos] = k; &#125; else if (op == 4) &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", queryPre(1, 1, n, l, r, k)); &#125; else &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", querySuf(1, 1, n, l, r, k)); &#125; &#125; return 0; &#125; 这样会导致在查询区间排名为 kkk 的数时需要二分出答案。如果想要避免，可以采用动态开点权值线段树套 FHQ，外层维护权值，内层维护位置（可以通过根据大小的分裂来快速求出在位置区间 [l,r][l,r][l,r] 内的数的个数），这样可以直接在权值线段树上二分出答案。 二维线段树 不同树套树的优劣 不管是什么树套树，常数都是巨大的（因为线段树和平衡树都很慢）。下面我们来对比一下不同的树套树： Problemset 前面是一些基础题，最后部分放了一些综合应用。 可持久化数据结构 一些基础题。 [POI2014] KUR-Couriers Portal. 建立主席树，查询的时候如果在 [l,mid][l,mid][l,mid] 的值域的数的个数大于要求的数量，那么就到左子树查询，右子树同理，否则就是无解。因为右子树的值域区间大小只能比左子树的值域区间大小小或者相等，所以当落在左子树值域的数的个数满足限制条件时，右子树就不可能满足了，就不用查询了。 注意！由于这题的最优做法并不是主席树，所以主席树会被卡空间。初始版本是不能被建立的。要使用如代码中所示的方法。 查看代码 #include &lt;cstdio> const int MAXN = 500000; int read(void) &#123; int x = 0, c = getchar(); while (c &lt; '0' || c > '9') c = getchar(); while (c >= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x; &#125; struct Node &#123; int lc, rc, dat; &#125;T[21 * MAXN + 480000]; int tot = 0, root[MAXN + 1]; int build(int l, int r) &#123; int o = tot++; if (l == r) return o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); return o; &#125; void update(int &amp;now, int l, int r, int x) // 注意 now 是引用，会被更新 &#123; T[++tot] = T[now]; now = tot; T[tot].dat++; if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(T[now].lc, l, mid, x); else update(T[now].rc, mid + 1, r, x); &#125; int k; int query(int p, int q, int l, int r) &#123; if (l == r) return l; int mid = l + r >> 1; if (2 * (T[T[q].lc].dat - T[T[p].lc].dat) > k) return query(T[p].lc, T[q].lc, l, mid); if (2 * (T[T[q].rc].dat - T[T[p].rc].dat) > k) return query(T[p].rc, T[q].rc, mid + 1, r); return 0; &#125; int main(void) &#123; int n, m, l, r, x; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) &#123; root[i] = root[i - 1]; update(root[i], 1, n, read()); // 直接修改 &#125; while (m--) &#123; l = read(), r = read(); k = r - l + 1; printf(\"%d\\n\", query(root[l - 1], root[r], 1, n)); &#125; return 0; &#125; [CF840D] Destiny Portal. 乍一看跟上一题很像，但是无法保证如果左子树没有答案右子树就一定没有。因此考虑左子树满足条件没有答案时再到右子树查询。 慢着！这样复杂度不会变成 O(nlog⁡n)O(n\\log n)O(nlogn) 吗？不会！注意到 k≤5k\\le 5k≤5，复杂度可以均摊，左子树满足条件但是没有答案的事情最多发生 kkk 次，数就会被用完。因此单次询问的复杂度是 O(knlog⁡n)O(kn\\log n)O(knlogn) 的。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct Node &#123; int ls, rs; int val; &#125; T[45 * 300005]; int root[300005], tot; int n, m, len, k; int a[300005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return T[o].val += k, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x, k); else T[o].rs = update(T[pre].rs, mid + 1, r, x, k); T[o].val = T[T[o].ls].val + T[T[o].rs].val; return o; &#125; int query(int p, int q, int l, int r) &#123; if (l == r) return l; int mid = l + r >> 1; if (k * (T[T[q].ls].val - T[T[p].ls].val) > len) &#123; int res = query(T[p].ls, T[q].ls, l, mid); if (res != -1) return res; &#125; if (k * (T[T[q].rs].val - T[T[p].rs].val) > len) return query(T[p].rs, T[q].rs, mid + 1, r); return -1; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); root[0] = build(1, n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), root[i] = update(root[i - 1], 1, n, a[i], 1); while (m--) &#123; int l, r; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); len = r - l + 1; printf(\"%d\\n\", query(root[l - 1], root[r], 1, n)); &#125; return 0; &#125; [Luogu P2633] Count on a tree Portal. 利用树上差分的思想，同时查询四个版本的主席树。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, q, a[100005], b[100005]; vector&lt;int> G[100005]; struct Node &#123; int ls, rs; int dat; &#125; T[100005 * 36]; int tot, root[100005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return ++T[o].dat, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x); else T[o].rs = update(T[pre].rs, mid + 1, r, x); T[o].dat = T[T[o].ls].dat + T[T[o].rs].dat; return o; &#125; int query(int u, int v, int lca, int fa, int l, int r, int k) &#123; if (l == r) return l; int mid = l + r >> 1, res = T[T[u].ls].dat + T[T[v].ls].dat - T[T[lca].ls].dat - T[T[fa].ls].dat; if (k &lt;= res) return query(T[u].ls, T[v].ls, T[lca].ls, T[fa].ls, l, mid, k); return query(T[u].rs, T[v].rs, T[lca].rs, T[fa].rs, mid + 1, r, k - res); &#125; int dfn[100005], siz[100005], top[100005], num; int son[100005], dep[100005], f[100005]; void dfs1(int x, int fa) &#123; root[x] = update(root[fa], 1, m, a[x]); f[x] = fa; dep[x] = dep[fa] + 1; siz[x] = 1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (!son[x]) return; dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(1, 0); dfs2(1, 1); int u, v, k, lca, last = 0; while (q--) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;k); u ^= last; lca = LCA(u, v); printf(\"%d\\n\", last = b[query(root[u], root[v], root[lca], root[f[lca]], 1, m, k)]); &#125; return 0; &#125; [P4137] Rmq Problem / mex Portal. 设 fi,jf_{i,j}fi,j​ 代表 jjj 在 ≤i\\le i≤i 的位置中的最大出现位置，那么相当于求 fi,j&lt;lf_{i,j}&lt;lfi,j​&lt;l 的最小 jjj，主席树二分或离线扫描。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 200003; int n, m; struct Node &#123; int ls, rs; int dat; &#125; T[40 * 200005]; int rt[200005], tot; void update(int &amp;o, int pre, int l, int r, int x, int v) &#123; T[o = ++tot] = T[pre]; if (l == r) return T[o].dat = v, void(); int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, T[pre].ls, l, mid, x, v); else update(T[o].rs, T[pre].rs, mid + 1, r, x, v); T[o].dat = min(T[T[o].ls].dat, T[T[o].rs].dat); &#125; int query(int o, int l, int r, int v) &#123; if (l == r) return l; int mid = l + r >> 1; if (T[T[o].ls].dat >= v) return query(T[o].rs, mid + 1, r, v); return query(T[o].ls, l, mid, v); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), update(rt[i], rt[i - 1], 1, N, ++x, i); while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d\\n\", query(rt[r], 1, N, l) - 1); &#125; return 0; &#125; [CF1771F] Hossam and Range Minimum Query Portal. 可持久化降掉序列维，给每一个数随机一个权值，权值线段树维护随机权值的异或和，这样可以直接判断值域内是否有出现次数为奇数的数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int a[200005], b[200005]; map&lt;int, int> mp; mt19937 Rand(time(0)); struct Node &#123; int ls, rs, dat; &#125; T[200005 * 45]; int rt[200005], tot; int update(int pre, int l, int r, int x, int k) &#123; int o = ++tot; T[o] = T[pre]; T[o].dat ^= k; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x, k); else T[o].rs = update(T[pre].rs, mid + 1, r, x, k); return o; &#125; int query(int p, int q, int l, int r) &#123; if (l == r) return T[p].dat ^ T[q].dat ? l : 0; int mid = l + r >> 1; if (T[T[p].ls].dat ^ T[T[q].ls].dat) return query(T[p].ls, T[q].ls, l, mid); return query(T[p].rs, T[q].rs, mid + 1, r); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; if (!mp.count(a[i])) mp[a[i]] = Rand(); rt[i] = update(rt[i - 1], 1, nn, a[i], mp[a[i]]); &#125; scanf(\"%d\", &amp;m); for (int last = 0; m--; ) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; printf(\"%d\\n\", last = b[query(rt[l - 1], rt[r], 1, nn)]); &#125; return 0; &#125; [TJOI2018] 异或 Portal. 针对 DFS 序和树上前缀和建立两棵可持久化 01 Trie，不同询问在不同 Trie 上查询。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, q, a[100005]; vector&lt;int> G[100005]; int rt1[100005], rt2[100005], tot, val[6200005], ch[6200005][2]; void insert(int x, int pre, int v) &#123; for (int i = 29; i >= 0; --i) &#123; val[x] = val[pre] + 1; int c = 1 &lt;&lt; i &amp; v ? 1 : 0; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; pre = ch[pre][c]; &#125; val[x] = val[pre] + 1; &#125; int query(int x, int y, int v) &#123; int res = 0; for (int i = 29; i >= 0; --i) &#123; int c = 1 &lt;&lt; i &amp; v ? 1 : 0; if (val[ch[x][!c]] - val[ch[y][!c]]) res |= 1 &lt;&lt; i, x = ch[x][!c], y = ch[y][!c]; else x = ch[x][c], y = ch[y][c]; &#125; return res; &#125; int dep[100005], f[100005], siz[100005]; int top[100005], son[100005], dfn[100005], num; void dfs1(int x, int fa) &#123; dep[x] = dep[f[x] = fa] + 1; siz[x] = 1; insert(rt2[x] = ++tot, rt2[f[x]], a[x]); for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; top[x] = topf; dfn[x] = ++num; insert(rt1[num] = ++tot, rt1[num - 1], a[x]); if (!son[x]) return; dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(1, 0); dfs2(1, 1); while (q--) &#123; int op, x, y, z; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) printf(\"%d\\n\", query(rt1[dfn[x] + siz[x] - 1], rt1[dfn[x] - 1], y)); else &#123; scanf(\"%d\", &amp;z); int rl = rt2[f[LCA(x, y)]]; printf(\"%d\\n\", max(query(rt2[x], rl, z), query(rt2[y], rl, z))); &#125; &#125; return 0; &#125; [THUSC2015] 异或运算 Portal. 将求第 kkk 大转化为 kkk 小，看一下 n=1n=1n=1 怎么做？对 YYY 建立可持久化 01 Trie，然后拿着 X[1]X[1]X[1] 开始从高到低位开始贪心。答案的这一二进制位能取到 000 的个数如果小于 kkk，那么这一位就需要取 111，然后令 kkk 减去这个个数；否则这一位取 000。 发现 n,qn,qn,q 都不是很大，因此对于 n&gt;1n&gt;1n&gt;1 直接暴力扫一遍，把总和加起来跟 kkk 比即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, q; int a[1005], b[300005]; int root[300005], ch[10000005][2], tot, val[10000005]; void insert(int x, int pre, int v) &#123; for (int i = 30; i >= 0; --i) &#123; int c = v >> i &amp; 1; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c], pre = ch[pre][c]; val[x] = val[pre] + 1; &#125; &#125; int x[1005], y[1005]; int query(int u, int d, int l, int r, int k) &#123; int ans = 0; for (int i = u; i &lt;= d; ++i) x[i] = root[l - 1], y[i] = root[r]; for (int i = 30; i >= 0; --i) &#123; int cnt = 0; for (int j = u; j &lt;= d; ++j) &#123; int c = a[j] >> i &amp; 1; cnt += val[ch[y[j]][c]] - val[ch[x[j]][c]]; &#125; int nxt = k &lt;= cnt ? 0 : 1; if (nxt) k -= cnt, ans |= 1 &lt;&lt; i; for (int j = u; j &lt;= d; ++j) &#123; int c = (a[j] >> i &amp; 1) ^ nxt; x[j] = ch[x[j]][c], y[j] = ch[y[j]][c]; &#125; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d\", b + i); root[i] = ++tot; insert(root[i], root[i - 1], b[i]); &#125; scanf(\"%d\", &amp;q); while (q--) &#123; int u, d, l, r, k; scanf(\"%d%d%d%d%d\", &amp;u, &amp;d, &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", query(u, d, l, r, (d - u + 1) * (r - l + 1) - k + 1)); &#125; return 0; &#125; [CF1665E] MinimizOR Portal. 如何处理或的最小值呢？如果出现了两个以上的 000，那么这一位显然填 000；如果没有 000 出现，则填 111；有一个 000 呢？找到这个 000 的位置，让它自己往 000 走，同时搞两个儿子就好了。只会增加 log⁡\\loglog 次节点，时间复杂度为 O(nlog⁡2V)O(n\\log^2 V)O(nlog2V)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int a[100005], rt[100005]; int ch[10000005][2], val[10000005], tot; void insert(int x, int pre, int v) &#123; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; ch[x][!c] = ch[pre][!c]; ch[x][c] = ++tot; x = ch[x][c]; pre = ch[pre][c]; val[x] = val[pre] + 1; &#125; &#125; int query(vector&lt;pair&lt;int, int>> v, int dep) &#123; if (dep == -1) return 0; int sum = 0; pair&lt;int, int> p(-1, -1); for (auto&amp; [x, y] : v) &#123; sum += val[ch[y][0]] - val[ch[x][0]]; if (val[ch[y][0]] - val[ch[x][0]] > 0) p = make_pair(x, y); &#125; if (sum >= 2) &#123; for (auto&amp; [x, y] : v) x = ch[x][0], y = ch[y][0]; return query(v, dep - 1); &#125; for (auto&amp; [x, y] : v) x = ch[x][1], y = ch[y][1]; if (sum == 1) v.emplace_back(ch[p.first][0], ch[p.second][0]); return query(v, dep - 1) + (1 &lt;&lt; dep); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), insert(rt[i] = ++tot, rt[i - 1], a[i]); for (scanf(\"%d\", &amp;m); m--; ) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); vector&lt;pair&lt;int, int>> v; v.emplace_back(rt[l - 1], rt[r]); printf(\"%d\\n\", query(v, 29)); &#125; for (int i = 1; i &lt;= tot; ++i) ch[i][0] = ch[i][1] = val[i] = 0; tot = 0; &#125; return 0; &#125; [Luogu P7834] Peaks Portal. 经过权值 ≤x\\le x≤x 的边能够到达的点是 Kruskal 重构树上某个子树内的点，而子树上的 kkk 大点可以通过 DFS 序转换到序列上使用主席树处理。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, A, nn, m, q, a[200005], b[100005]; struct edge &#123; int u, v, d; bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125; e[500005]; struct UnionFind &#123; int fa[200005]; void init(void) &#123; for (int i = 1; i &lt;= n * 2; ++i) fa[i] = i; &#125; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; &#125; US; int val[200005]; vector&lt;int> G[200005]; void addedge(int x, int y) &#123; G[x].emplace_back(y); G[y].emplace_back(x); &#125; int f[21][200005], dfn[200005], siz[200005], num, idx[200005]; void dfs(int x, int fa) &#123; f[0][x] = fa; siz[x] = 1; idx[dfn[x] = ++num] = x; for (int i = 1; i &lt;= 20; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x), siz[x] += siz[y]; &#125; void Kruskal(void) &#123; sort(e + 1, e + m + 1); US.init(); A = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v, w = e[i].d; int x = US.find(e[i].u), y = US.find(e[i].v); if (x == y) continue; val[++A] = w; US.fa[x] = US.fa[y] = A; addedge(x, A); addedge(y, A); &#125; for (int i = 1; i &lt;= A; ++i) if (US.fa[i] == i) dfs(i, 0); &#125; struct Node &#123; int lc, rc; int val; &#125; T[2200005]; int tot, root[200005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].lc = build(l, mid); T[o].rc = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; if (!x) return pre; int o = ++tot; T[o] = T[pre]; T[o].val += 1; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].lc = update(T[pre].lc, l, mid, x); else T[o].rc = update(T[pre].rc, mid + 1, r, x); return o; &#125; int query(int x, int y, int l, int r, int k) &#123; if (l == r) return l; if (T[y].val - T[x].val &lt; k) return 0; int mid = l + r >> 1, res = T[T[y].rc].val - T[T[x].rc].val; if (res >= k) return query(T[x].rc, T[y].rc, mid + 1, r, k); return query(T[x].lc, T[y].lc, l, mid, k - res); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].d); Kruskal(); root[0] = build(1, nn); for (int i = 1; i &lt;= A; ++i) root[i] = update(root[i - 1], 1, nn, a[idx[i]]); for (int last = 0; q--; ) &#123; int u, x, k; scanf(\"%d%d%d\", &amp;u, &amp;x, &amp;k); u = (u ^ last) % n + 1, x = x ^ last, k = (k ^ last) % n + 1; for (int i = 20; i >= 0; --i) if (f[i][u] &amp;&amp; val[f[i][u]] &lt;= x) u = f[i][u]; printf(\"%d\\n\", (last = b[query(root[dfn[u] - 1], root[dfn[u] + siz[u] - 1], 1, nn, k)]) ? last : -1); &#125; return 0; &#125; [CF1777F] Comfortably Numb Portal. 找出序列中权值最大的位置，答案区间要么在它左侧或右侧，要么跨越区间。合并时采用启发式合并的思想，枚举小区间中的下标，就是要在大区间中找一个异或值最大的，可以使用可持久化 01 Trie 解决。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int a[200005], f[21][200005], lg[200005], s[200005]; int ch[6400005][2], tot, root[200005], val[6400005]; int qmax(int l, int r) &#123; int k = lg[r - l + 1]; if (a[f[k][l]] > a[f[k][r - (1 &lt;&lt; k) + 1]]) return f[k][l]; return f[k][r - (1 &lt;&lt; k) + 1]; &#125; void insert(int x, int pre, int v) &#123; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c], pre = ch[pre][c]; val[x] = val[pre] + 1; &#125; &#125; int query(int x, int y, int v) &#123; int res = 0; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; if (val[ch[y][!c]] - val[ch[x][!c]]) x = ch[x][!c], y = ch[y][!c], res |= 1 &lt;&lt; i; else x = ch[x][c], y = ch[y][c]; &#125; return res; &#125; int merge(int l, int r) &#123; if (l >= r) return 0; int mid = qmax(l, r), ans = max(merge(l, mid - 1), merge(mid + 1, r)); if (r - mid &lt; mid - l) &#123; // 将右半段合并到左半段 for (int i = mid; i &lt;= r; ++i) // 枚举右端点 ans = max(ans, query(l > 1 ? root[l - 2] : 0, root[mid - 1], a[mid] ^ s[i])); &#125; else &#123; for (int i = l; i &lt;= mid; ++i) // 枚举左端点 ans = max(ans, query(root[mid - 1], root[r], a[mid] ^ s[i - 1])); &#125; return ans; &#125; void solve(void) &#123; for (int i = 0; i &lt;= tot; ++i) ch[i][0] = ch[i][1] = val[i] = 0; cin >> n; tot = 0; for (int i = 1; i &lt;= n; ++i) cin >> a[i], f[0][i] = i, s[i] = s[i - 1] ^ a[i]; for (int i = 0; i &lt;= n; ++i) &#123; root[i] = ++tot; insert(root[i], i == 0 ? 0 : root[i - 1], s[i]); &#125; for (int j = 1; 1 &lt;&lt; j &lt;= n; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) if (a[f[j - 1][i]] > a[f[j - 1][i + (1 &lt;&lt; j - 1)]]) f[j][i] = f[j - 1][i]; else f[j][i] = f[j - 1][i + (1 &lt;&lt; j - 1)]; cout &lt;&lt; merge(1, n) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; for (int i = 2; i &lt;= 200000; ++i) lg[i] = lg[i >> 1] + 1; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; [Luogu P5586] 序列 Portal. 这是可持久化平衡树最经典的应用：区间复制。因为可持久化平衡树在合并时会复制要合并的节点，因此可以支持区间复制。另外由于可持久化平衡树空间开销过大，需要定时重构整棵平衡树。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; mt19937 Rand(time(0)); struct Node &#123; int setv, addv; bool rev; int val, sum, ls, rs, siz; &#125; T[8200005]; int root, tot, a[300005], num; inline void pushup(int p) &#123; T[p].sum = (0ll + T[T[p].ls].sum + T[T[p].rs].sum + T[p].val) % MOD; T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz + 1; &#125; inline int newNode(int x) &#123; int p = ++tot; T[p].setv = -1; T[p].ls = T[p].rs = T[p].addv = T[p].rev = 0; T[p].val = T[p].sum = x; T[p].siz = 1; return p; &#125; inline int copyNode(int x) &#123; T[++tot] = T[x]; return tot; &#125; inline void rever(int p) &#123; swap(T[p].ls, T[p].rs); T[p].rev ^= 1; &#125; inline void cover(int p, int k) &#123; T[p].addv = T[p].rev = 0; T[p].setv = T[p].val = k; T[p].sum = 1ll * T[p].siz * k % MOD; &#125; inline void add(int p, int k) &#123; T[p].addv = (T[p].addv + k) % MOD; T[p].val = (T[p].val + k) % MOD; T[p].sum = (T[p].sum + 1ll * k * T[p].siz) % MOD; &#125; inline void pushdown(int p) &#123; if (!p) return; if (T[p].ls) T[p].ls = copyNode(T[p].ls); if (T[p].rs) T[p].rs = copyNode(T[p].rs); if (T[p].setv != -1) &#123; if (T[p].ls) cover(T[p].ls, T[p].setv); if (T[p].rs) cover(T[p].rs, T[p].setv); T[p].setv = -1; &#125; if (T[p].rev) &#123; if (T[p].ls) rever(T[p].ls); if (T[p].rs) rever(T[p].rs); T[p].rev = 0; &#125; if (T[p].addv) &#123; if (T[p].ls) add(T[p].ls, T[p].addv); if (T[p].rs) add(T[p].rs, T[p].addv); T[p].addv = 0; &#125; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); p = copyNode(p); pushdown(p); if (T[T[p].ls].siz + 1 &lt;= S) &#123; x = p; split(T[p].rs, S - T[T[p].ls].siz - 1, T[p].rs, y); &#125; else &#123; y = p; split(T[p].ls, S, x, T[p].ls); &#125; pushup(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].siz > T[y].siz) &#123; x = copyNode(x); pushdown(x); T[x].rs = merge(T[x].rs, y); pushup(x); return x; &#125; else &#123; y = copyNode(y); pushdown(y); T[y].ls = merge(x, T[y].ls); pushup(y); return y; &#125; &#125; int build(int l, int r) &#123; if (l > r) return 0; int mid = l + r >> 1; int p = newNode(a[mid]); T[p].ls = build(l, mid - 1); T[p].rs = build(mid + 1, r); pushup(p); return p; &#125; void dfs(int p) &#123; pushdown(p); if (T[p].ls) dfs(T[p].ls); a[++num] = T[p].val; if (T[p].rs) dfs(T[p].rs); &#125; int main(void) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); root = build(1, n); int v, w, x, y, z, last = 0; while (m--) &#123; int op; scanf(\"%d\", &amp;op); if (op == 1) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; split(root, l - 1, x, y); split(y, r - l + 1, y, z); printf(\"%d\\n\", last = T[y].sum); root = merge(x, merge(y, z)); &#125; else if (op == 2) &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); l ^= last, r ^= last; k ^= last; split(root, l - 1, x, y); split(y, r - l + 1, y, z); cover(y, k); root = merge(x, merge(y, z)); &#125; else if (op == 3) &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); l ^= last, r ^= last; k ^= last; split(root, l - 1, x, y); split(y, r - l + 1, y, z); add(y, k); root = merge(x, merge(y, z)); &#125; else if (op == 4) &#123; int l1, r1, l2, r2, flag = 1; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); l1 ^= last; r1 ^= last; l2 ^= last; r2 ^= last; if (r1 > r2) swap(l1, l2), swap(r1, r2), flag = 0; split(root, r2, y, z); split(y, l2 - 1, x, y); split(x, r1, w, x); split(w, l1 - 1, v, w); if (flag) root = merge(v, merge(w, merge(x, merge(w, z)))); else root = merge(v, merge(y, merge(x, merge(y, z)))); &#125; else if (op == 5) &#123; int l1, r1, l2, r2; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); l1 ^= last; r1 ^= last; l2 ^= last; r2 ^= last; if (r1 > r2) swap(l1, l2), swap(r1, r2); split(root, r2, y, z); split(y, l2 - 1, x, y); split(x, r1, w, x); split(w, l1 - 1, v, w); root = merge(v, merge(y, merge(x, merge(w, z)))); &#125; else &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l ^= last, r ^= last; split(root, l - 1, x, y); split(y, r - l + 1, y, z); rever(y); root = merge(x, merge(y, z)); &#125; if (tot > 7000000) &#123; num = 0; dfs(root); tot = 0; root = build(1, n); &#125; &#125; num = 0; dfs(root); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); return 0; &#125; 【模板】可持久化平衡树 Portal. 就是普通的可持久化 FHQ-Treap。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500005; typedef long long i64; mt19937 Rand(time(0)); struct Node &#123; int siz, rnd; int ls, rs; int val; &#125; T[N * 105]; int tot, root[N]; int newNode(i64 v) &#123; ++tot; T[tot].siz = 1; T[tot].rnd = Rand(); T[tot].val = v; return tot; &#125; int copyNode(int x) &#123; T[++tot] = T[x]; return tot; &#125; void pushup(int p) &#123; T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz + 1; &#125; void split(int p, int k, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); int o = copyNode(p); if (T[o].val &lt;= k) &#123; x = o; split(T[o].rs, k, T[o].rs, y); &#125; else &#123; y = o; split(T[o].ls, k, x, T[o].ls); &#125; pushup(o); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; x = copyNode(x); T[x].rs = merge(T[x].rs, y); pushup(x); return x; &#125; else &#123; y = copyNode(y); T[y].ls = merge(x, T[y].ls); pushup(y); return y; &#125; &#125; int kth(int p, int k) &#123; while (p) &#123; if (T[T[p].ls].siz + 1 == k) break; else if (T[T[p].ls].siz + 1 > k) p = T[p].ls; else &#123; k -= T[T[p].ls].siz + 1; p = T[p].rs; &#125; &#125; return T[p].val; &#125; int main(void) &#123; int q; scanf(\"%d\", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; int op, v, x, a, b, c; scanf(\"%d%d%d\", &amp;v, &amp;op, &amp;x); root[i] = root[v]; if (op == 1) &#123; split(root[i], x, a, b); root[i] = merge(a, merge(newNode(x), b)); &#125; else if (op == 2) &#123; split(root[i], x - 1, a, b); split(b, x, b, c); b = merge(T[b].ls, T[b].rs); root[i] = merge(a, merge(b, c)); &#125; else if (op == 3) &#123; split(root[i], x - 1, a, b); printf(\"%d\\n\", T[a].siz + 1); root[i] = merge(a, b); &#125; else if (op == 4) printf(\"%d\\n\", kth(root[i], x)); else if (op == 5) &#123; split(root[i], x - 1, a, b); if (!a) printf(\"-2147483647\\n\"); else &#123; int p = a; while (T[p].rs) p = T[p].rs; printf(\"%d\\n\", T[p].val); &#125; root[i] = merge(a, b); &#125; else &#123; split(root[i], x, a, b); if (!b) printf(\"2147483647\\n\"); else &#123; int p = b; while (T[p].ls) p = T[p].ls; printf(\"%d\\n\", T[p].val); &#125; root[i] = merge(a, b); &#125; &#125; return 0; &#125; [国家集训队] middle Portal. 中位数二分答案，限制采用 GSS5 的处理方法（将限制区间拆分成三个区间），主席树维护按权值排序的版本信息即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, Q, q[4]; int a[20005], id[20005]; struct Value &#123; int lmax, rmax, sum; friend Value operator+ (const Value &amp;a, const Value &amp;b) &#123; Value c; c.lmax = max(a.lmax, a.sum + b.lmax); c.rmax = max(b.rmax, a.rmax + b.sum); c.sum = a.sum + b.sum; return c; &#125; &#125;; struct Node &#123; int ls, rs; Value dat; &#125; T[400005]; int rt[20005], tot; int build(int l, int r) &#123; int o = ++tot; T[o].dat = &#123;r - l + 1, r - l + 1, r - l + 1&#125;; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; int o = ++tot; T[o] = T[pre]; if (l == r) return T[o].dat = &#123;-1, -1, -1&#125;, o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x); else T[o].rs = update(T[pre].rs, mid + 1, r, x); T[o].dat = T[T[o].ls].dat + T[T[o].rs].dat; return o; &#125; Value query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].dat; int mid = l + r >> 1; if (y &lt;= mid) return query(T[o].ls, l, mid, x, y); if (mid &lt; x) return query(T[o].rs, mid + 1, r, x, y); return query(T[o].ls, l, mid, x, y) + query(T[o].rs, mid + 1, r, x, y); &#125; bool check(int x) &#123; int ans = 0; ans += query(rt[x], 1, n, q[0], q[1]).rmax; if (q[1] + 1 &lt;= q[2] - 1) ans += query(rt[x], 1, n, q[1] + 1, q[2] - 1).sum; ans += query(rt[x], 1, n, q[2], q[3]).lmax; return ans >= 0; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), id[i] = i; sort(id + 1, id + n + 1, [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;); rt[1] = build(1, n); for (int i = 2; i &lt;= n; ++i) rt[i] = update(rt[i - 1], 1, n, id[i - 1]); scanf(\"%d\", &amp;Q); for (int last = 0; Q--; ) &#123; for (int i = 0; i &lt; 4; ++i) scanf(\"%d\", q + i), q[i] = (q[i] + last) % n + 1; sort(q, q + 4); int L = 0, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", last = a[id[L]]); &#125; return 0; &#125; [SCOI2016] 美味 Portal. 从高到低位贪心，利用主席树判断数是否存在。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 100000; struct Node &#123; int ls, rs, dat; &#125; T[10000005]; int rt[200005], tot; int n, m; int a[200005]; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; int o = ++tot; T[o] = T[pre]; ++T[o].dat; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x); else T[o].rs = update(T[pre].rs, mid + 1, r, x); return o; &#125; int query(int p, int q, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[q].dat - T[p].dat; int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(T[p].ls, T[q].ls, l, mid, x, y); if (mid &lt; y) res += query(T[p].rs, T[q].rs, mid + 1, r, x, y); return res; &#125; bool find(int p, int q, int l, int r) &#123; l = max(l, 0); r = min(r, N); if (l > r) return 0; return query(rt[p], rt[q], 1, N, l, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); rt[0] = build(1, N); for (int i = 1; i &lt;= n; ++i) rt[i] = update(rt[i - 1], 1, N, a[i]); while (m--) &#123; int b, x, l, r, ans = 0; scanf(\"%d%d%d%d\", &amp;b, &amp;x, &amp;l, &amp;r); for (int i = 17; i >= 0; --i) &#123; int now = ans + (((b >> i &amp; 1) ^ 1) &lt;&lt; i); if (find(l - 1, r, now - x, now + (1 &lt;&lt; i) - 1 - x)) ans = now; else ans += ((b >> i &amp; 1) &lt;&lt; i); &#125; printf(\"%d\\n\", ans ^ b); &#125; return 0; &#125; 嵌套数据结构 应用不是很多（因为通常没有要求这么复杂的玩意），但是出出来都挺吓人。 综合应用 这里的题目难度会有所上升。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"算法竞赛/学习笔记/数据结构","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"可持久化","slug":"可持久化","permalink":"https://james1badcreeper.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"树套树","slug":"树套树","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"}]},{"title":"省选初级图论","slug":"notes/图论/sx-graph","date":"2023-01-15T00:00:00.000Z","updated":"2023-01-15T00:00:00.000Z","comments":true,"path":"fb40efc5/","link":"","permalink":"https://james1badcreeper.github.io/fb40efc5/","excerpt":"高级的图论知识会包含更多的内容。我们将二分图与网络流排除，这篇文章的内容会覆盖绝大多数简单常用的图论知识点与技巧。","text":"高级的图论知识会包含更多的内容。我们将二分图与网络流排除，这篇文章的内容会覆盖绝大多数简单常用的图论知识点与技巧。 热身 搞一些基础内容！ 拆边拆点与点边转化 有些时候的问题比较复杂，我们可以选择将边或者是点进行拆分，来更加方便的处理。比如分层图最短路中，我们使用的就是&quot;点拆点&quot;，把一个点拆成多个点进行维护。当然，这也意味着分层图中的&quot;特殊道路&quot;不会很多，否则点会被拆成很多，复杂度无法承受。 有的时候点或者边不方便做，两者甚至可以相互转化。比如在处理树上边权时，我们就采取了把边权下放到点权的方式。 这种思想在网络流中还有更多应用，所以在这里只简单介绍几个例子。 点拆点 | [SCOI2009] 迷路 Portal.一个有向图有 nnn 个节点，从节点 111 出发，必须恰好在 ttt 时刻到达节点 nnn。求共有多少种不同的路径吗？答案对 200920092009 取模。注意：不能在某个节点逗留，且通过某有向边的时间严格为给定的时间。保证 2≤n≤102 \\leq n \\leq 102≤n≤10，1≤t≤1091 \\leq t \\leq 10^91≤t≤109。 我们先考虑边权只有 01 怎么做。 设 f(t,i,j)f(t,i,j)f(t,i,j) 表示 iii 到 jjj 的长度为 ttt 的路径数，显然 t=1t=1t=1 时这个就是初始矩阵，转移也就是 f(t,i,j)=∑k=1nf(t−1,i,k)+f(1,k,j)f(t,i,j)=\\sum_{k=1}^{n}f(t-1,i,k)+f(1,k,j)f(t,i,j)=∑k=1n​f(t−1,i,k)+f(1,k,j)。当然这个转移也可以扩展到任意情况，不过与我们接下来讨论的内容没有关系。 这种时候可以发现 f(t)=f(t−1)×f(1)f(t)=f(t-1)\\times f(1)f(t)=f(t−1)×f(1)，那么可以使用矩阵快速幂计算。然而当不全是 01 的时候无法使用矩阵快速幂！怎么办？发现 w&lt;10w&lt;10w&lt;10，我们可以将一个点拆成九个点，像这样： 如果我们要连一个点到这个被拆好的点，那么根据距离连接即可。比如有一个点与它距离为 333，那么就需要连接到 222 号点。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 2009; int m; struct Matrix &#123; int a[100][100]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; Matrix operator * (const Matrix &amp;a) const &#123; Matrix res; for (int i = 1; i &lt;= m; ++i) for (int k = 1; k &lt;= m; ++k) &#123; i64 r = this->a[i][k]; for (int j = 1; j &lt;= m; ++j) res.a[i][j] = (res.a[i][j] + r * a.a[k][j]) % MOD; &#125; return res; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; for (int i = 1; i &lt;= m; ++i) res.a[i][i] = 1; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; int n, t; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;t); m = 9 * n; Matrix f; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) f.a[i + j * n][i + (j - 1) * n] = 1; for (int j = 1; j &lt;= n; ++j) &#123; int x; scanf(\"%1d\", &amp;x); if (x) f.a[i][j + (x - 1) * n] = 1; &#125; &#125; f = poww(f, t); printf(\"%d\\n\", f.a[1][n]); return 0; &#125; 边转点 | [SDOI2009] HH去散步 Portal.给定一张不带权的无向图，不会立刻沿着刚刚走来的路走回，问有多少种从 AAA 走到 BBB，距离为 TTT 的走法？ 感觉根上一题很相似，但是要求不能来回走！怎么办？考虑将一条无向边转换成两个点，然后这两个点之间不连边，剩下的能到达的边与这些点连边。 初始时连一条 0→a0\\rightarrow a0→a 的边，建立初始矩阵的时候枚举两条边 i,ji,ji,j，如果满足 v[i]=u[j]v[i]=u[j]v[i]=u[j]，而且不是反向边，那么 i→ji\\rightarrow ji→j 就可以用 111 的时间去到达。答案也是枚举所有边，第一条边 0→a0\\rightarrow a0→a 到当前的边 k→bk\\rightarrow bk→b 的答案的和。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 45989; int N; struct Matrix &#123; int a[125][125]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; void build(void) &#123; for (int i = 0; i &lt; N; ++i) a[i][i] = 1; &#125; Matrix operator * (const Matrix &amp;b) const &#123; for (int i = 0; i &lt;= N; ++i) for (int k = 0; k &lt;= N; ++k) &#123; int r = a[i][k]; for (int j = 0; j &lt;= N; ++j) c.a[i][j] = (c.a[i][j] + r * b.a[k][j]) % MOD; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; res.build(); for (; b; b >>= 1, a = a * a) if (b &amp; 1) res = res * a; return res; &#125; struct edge &#123; int u, v; &#125;; int n, m, t, a, b; int u[125], v[125], cnt = 0; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;t, &amp;a, &amp;b); ++a; ++b; u[++cnt] = 0; v[cnt] = a; while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); ++x; ++y; u[++cnt] = x; v[cnt] = y; u[++cnt] = y; v[cnt] = x; &#125; Matrix f; N = cnt; for (int i = 1; i &lt;= cnt; ++i) for (int j = 1; j &lt;= cnt; ++j) if (i != j &amp;&amp; i != (j ^ 1) &amp;&amp; v[i] == u[j]) f.a[i][j] = 1; f = poww(f, t); int ans = 0; for (int i = 1; i &lt;= cnt; ++i) if (v[i] == b) ans = (ans + f.a[1][i]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; 基础概念 一个点可以连接到图中的所有点，那么这个点是图的支配点。 对于一张图 G=(V,E)G=(V,E)G=(V,E)，若图 G′=(V′,E′)G&#x27;=(V&#x27;,E&#x27;)G′=(V′,E′) 满足 V′⊆V,E′⊆EV&#x27;\\subseteq V,E&#x27;\\subseteq EV′⊆V,E′⊆E，则称 G′G&#x27;G′ 是 GGG 的子图。 如果 G′G&#x27;G′ 满足 ∀u,v∈V′\\forall u,v\\in V&#x27;∀u,v∈V′，只要 (u,v)∈E(u,v)\\in E(u,v)∈E，均有 (u,v)∈E′(u,v)\\in E&#x27;(u,v)∈E′，则称 G′G&#x27;G′ 是 GGG 的导出子图。 如果 G′G&#x27;G′ 满足 V′=VV&#x27;=VV′=V，则称 G′G&#x27;G′ 是 GGG 的生成子图/支撑子图。 对于一张无向图 G=(V,E)G=(V,E)G=(V,E)，如果每个顶点的度数都是一个固定的常数 kkk，则称 GGG 为 k−\\bold{k-}k−正则图。而无向图的某个生成子图 G′G&#x27;G′ 为 k−k-k− 正则图，则称 G′G&#x27;G′ 为 GGG 的一个 k−\\bold{k-}k−因子。 一张无向简单图的补图的含义是原本有的边都没有，原本没有的边都有。 一张有向图的反图是所有边方向改变。 覆盖 对于无向图 G=(V,E)G=(V,E)G=(V,E)，若 V′⊆VV&#x27;\\subseteq VV′⊆V，有任意一条边都有一个端点在 V′V&#x27;V′ 中，则 V′V&#x27;V′ 称为 GGG 的点覆盖集。一个点集是点覆盖的充要条件是其补集是独立集。 如果 E′⊆EE&#x27;\\subseteq EE′⊆E，任意一个点都至少连了一条 E′E&#x27;E′ 中的边，则称 E′E&#x27;E′ 是边覆盖集。 最大团问题 一个图的子点集 V′V&#x27;V′ 中任意两个不同的顶点都相邻，则称 V′V&#x27;V′ 是图 GGG 的一个团。团对应的导出子图是完全图。说白了最大团就是最大完全子图。 求解一个图的最大团是 NPH 的。下面的暴力一般可以应对 n≤50n\\le 50n≤50 的数据： int cnt[2005], group[2005], vis[2005], ans; bool dfs(int pos, int num) &#123; for (int i = pos + 1; i &lt;= n; i++) &#123; if (cnt[i] + num &lt;= ans) return false; // 不可能成为答案 if (G[pos][i]) &#123; int j; for (j = 0; j &lt; num; j++) if (!G[i][vis[j]]) break; // 检查 i 是否与所有点相邻 if (j == num) &#123; vis[num] = i; if (dfs(i, num + 1)) return true; &#125; &#125; &#125; if (num > ans) &#123; for (int i = 0; i &lt; num; i++) group[i] = vis[i]; ans = num; return true; &#125; return false; &#125; main(void) &#123; for (int i = n; i >= 1; --i) vis[0] = i, dfs(i, 1), cnt[i] = ans; // 以 i 为起点找最大团 &#125; 补图的最大团就是原图的最大独立集。 最短路问题 常规的最短路可以考虑以下求解方式： 01 最短路，可以使用双端队列 bfs 解决； 单源最短路，考虑使用 SPFA 或 Dijkstra，某些题目的图不太能特殊构造，那么使用 SPFA 会很快； 多源最短路，使用 Floyd 或者 Johnson（并没有什么优势）解决。 最短路有一些应用。包括已经讲过的差分约束，这里再补充两个知识点。 斯坦纳树 费马点问题是一个经典的几何问题，而它给定的是三角形。如果给定 nnn 个点，试求连接此 nnn 个点，总长最短的直线段连接系统，并且并且任意两点都可以通过系统中的直线段组成的折线连接起来，此问题被称为斯坦纳树问题。给定 nnn 个点时，最多有 n−2n-2n−2 个复接点（斯坦纳点）。每一斯坦纳点要么有三条边通过（呈 120°120\\degree120° 的夹角），要么是两条边，这时它是一个已经给定的点。 最小斯坦纳树。给定一个 nnn 个点 mmm 条边无向图 G=(V,E)G=(V,E)G=(V,E)，再给定包含 kkk 个节点的点集 SSS，选出 GGG 的连通子图 G′=(V′,E′)G&#x27;=(V&#x27;,E&#x27;)G′=(V′,E′)，要求：S⊆V′S \\subseteq V&#x27;S⊆V′，E′E&#x27;E′ 中所有边的权值和最小。你需要求出这个最小权值和，n≤100,m≤500,k≤10n\\le 100,m\\le 500,k\\le 10n≤100,m≤500,k≤10。 并不是直接将 SSS 连接起来就是最小的，可能需要借助剩下的 n−kn-kn−k 个点。这种问题可以使用状压 DP 来解决： 设 f(i,S)f(i,S)f(i,S) 表示以 iii 为根的一棵树，包含集合 SSS 中所有点的最小边权值和。有转移：f(i,S)←min⁡{f(i,T)+f(i,S−T)},f(i,S)←min⁡{f(j,S)+w(i,j)}f(i,S)\\leftarrow\\min\\{f(i,T)+f(i,S-T)\\},f(i,S)\\leftarrow\\min\\{f(j,S)+w(i,j)\\}f(i,S)←min{f(i,T)+f(i,S−T)},f(i,S)←min{f(j,S)+w(i,j)}。前者可以使用子集 DP 实现，后者可以跑一个最短路（由于图很难特殊构造而且规模很小，所以实际上更建议 SPFA）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef pair&lt;int, int> pii; const int INF = 0x3f3f3f3f; int n, m, k, f[1024][105]; vector&lt;pair&lt;int, int>> G[105]; priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii>> q; bool vis[105]; void dijkstra(int s) &#123; memset(vis, 0, sizeof vis); for (int i = 0; i &lt; n; ++i) if (f[s][i] != INF) q.emplace(f[s][i], i); while (!q.empty()) &#123; pii tmp = q.top(); q.pop(); int u = tmp.second; if (vis[u]) continue; vis[u] = true; for (auto [v, w] : G[u]) if (f[s][v] > f[s][u] + w) q.emplace(f[s][v] = f[s][u] + w, v); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); --u; --v; G[u].emplace_back(v, w); G[v].emplace_back(u, w); &#125; memset(f, 0x3f, sizeof f); for (int i = 0, x; i &lt; k; ++i) &#123; scanf(\"%d\", &amp;x); --x; f[1 &lt;&lt; i][x] = 0; &#125; for (int s = 1; s &lt; 1 &lt;&lt; k; ++s) &#123; for (int i = 0; i &lt; n; ++i) for (int t = s - 1 &amp; s; t; t = t - 1 &amp; s) f[s][i] = min(f[s][i], f[t][i] + f[s ^ t][i]); dijkstra(s); &#125; int ans = INF; for (int i = 0; i &lt; n; ++i) ans = min(ans, f[(1 &lt;&lt; k) - 1][i]); printf(\"%d\\n\", ans); return 0; &#125; 同余最短路 这是一个最短路的变式问题。可以用于求解在某个范围内有多少重量可以由若干物品的完全背包凑出，就是多少数值可以由一些给定的数 bib_ibi​ 由 ∑aibi(ai≥0)\\sum a_i b_i(a_i\\ge 0)∑ai​bi​(ai​≥0) 得到。 SPFA 模板。墨墨突然对等式很感兴趣，他正在研究 ∑i=1naixi=b\\sum_{i=1}^n a_ix_i=b∑i=1n​ai​xi​=b 存在非负整数解的条件，他要求你编写一个程序，给定 n,a1…n,l,rn, a_{1\\dots n}, l, rn,a1…n​,l,r，求出有多少 b∈[l,r]b\\in[l,r]b∈[l,r] 可以使等式存在非负整数解。n≤12n \\le 12n≤12，0≤ai≤5×1050 \\le a_i \\le 5\\times 10^50≤ai​≤5×105，1≤l≤r≤10121 \\le l \\le r \\le 10^{12}1≤l≤r≤1012。 我们可以发现，如果 xxx 可以被表示出，那么 x+kai(k&gt;0)x+ka_i(k&gt;0)x+kai​(k&gt;0) 就可以被表示出。因此我们找一个最小的 a1a_1a1​，然后连 j→(j+ai)mod a1j\\rightarrow (j+a_i)\\mod a_1j→(j+ai​)moda1​ 的长度为 aia_iai​ 的边，然后我们从 000 开始跑最短路。由于这里图的形态不太能特殊构造，因此使用 SPFA 往往会跑的更快。 答案的求解十分容易。[0,r][0,r][0,r] 的答案数量为： ∑i=0a1−1max⁡{0,⌊r−dia1⌋+1}\\sum_{i=0}^{a_1-1}\\max\\left\\{0,\\left\\lfloor\\frac{r-d_i}{a_1}\\right\\rfloor+1\\right\\} i=0∑a1​−1​max{0,⌊a1​r−di​​⌋+1} 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, a[20]; i64 l, r, f[500005]; bool inq[500005]; int main(void) &#123; scanf(\"%d%lld%lld\", &amp;n, &amp;l, &amp;r); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); memset(f, 0x3f, sizeof(f)); queue&lt;int> q; q.push(0); f[0] = 0; inq[0] = true; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 2; i &lt;= n; ++i) &#123; int v = (u + a[i]) % a[1]; if (f[v] > f[u] + a[i]) &#123; f[v] = f[u] + a[i]; if (!inq[v]) inq[v] = true, q.push(v); &#125; &#125; &#125; i64 ans = 0; for (int i = 0; i &lt; a[1]; ++i) &#123; if (r >= f[i]) ans += (r - f[i]) / a[1] + 1; if (l - 1 >= f[i]) ans -= (l - 1 - f[i]) / a[1] + 1; &#125; printf(\"%lld\\n\", ans); return 0; &#125; 转两圈 回归同余最短路问题的本质， 广义圆方树 广义圆方树是刻画图上点的必经性的工具，可以描述任意两点之间的所有必经点，也就是会经过的割点。 概述 广义圆方树是定义在一般无向图上的一种树形结构，是 v-DCC 缩点之后的产物。本质上可以看成“缩边”，就是将原图上所有对刻画必经性无用的边去掉。 我们建出 v-DCC 的“代表点”并向 v-DCC 内部所有点连边，这样会形成一个菊花图。这个“代表点”称为“方点”，而原图中的所有点对应“圆点”。代码如下： void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; // 孤立点在圆方树上根本没有边，不需要特判 for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; // 找到了一个以 x 为根的 v-DCC int z; ++n; // 新建一个方点 do addedge(z = st[tot--], n); while (z != y); addedge(x, n); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; 性质 它们是广义圆方树工作的基础，首先是 v-DCC 的引理： 引理：如果 xxx 与 y,zy,zy,z 均点双连通，但是 y,zy,zy,z 不点双连通，那么 xxx 是 y,zy,zy,z 的必经点。 然后是广义圆方树的性质： 性质 1：圆点 xxx 的度数为它所在的 v-DCC 个数。 性质 2：圆方树上只有圆点和方点之间有边。 性质 3：原图上直接相连的 x,yx,yx,y 属于一个 v-DCC，而且如果这个 v-DCC 的大小为 222，那么 (x,y)(x,y)(x,y) 是割边。 下面三个是用来做题的： 性质 4：圆点 xxx 是叶子当且仅当它在原图上不是割点。证明：如果 xxx 是割点，那么 xxx 至少属于两个 v-DCC，这样存在 y,zy,zy,z 两点与 xxx 都点双连通，但是 y,zy,zy,z 不点双连通，因此 xxx 是 y,zy,zy,z 的必经点，这样它不是叶子。性质 5：广义圆方树上删掉圆点 xxx 后剩余节点的联通性与原图上删除 xxx 相等。证明：如果 xxx 是叶子，也就是它不是割点，删除显然没有影响。如果它是原图的割点，比如说 xxx 在圆方树上连接了 y,zy,zy,z，那么与 y,zy,zy,z 所在的点双连通之间不在连通，与其割点的性质是一样的。性质 6：x,yx,yx,y 简单路径上的所有圆点就是原图中 x,yx,yx,y 之间的所必经点。这是圆方树的核心性质。 模板，直接输出最小编号的圆点即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, node; int dfn[200005], low[200005], num, st[200005], tot; vector&lt;int> E[200005], G[400005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; int z; G[++node].emplace_back(x); G[x].emplace_back(node); do G[node].emplace_back(z = st[tot--]), G[z].emplace_back(node); while (y != z); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; int f[400005], dep[400005]; void dfs(int x, int fa) &#123; f[x] = fa; dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); node = n; for (int u, v; scanf(\"%d%d\", &amp;u, &amp;v) == 2 &amp;&amp; u; ) E[u].emplace_back(v), E[v].emplace_back(u); tarjan(1); dfs(1, 0); int a, b; scanf(\"%d%d\", &amp;a, &amp;b); int ans = 1e9; if (dep[a] &lt; dep[b]) swap(a, b); while (dep[a] > dep[b]) if ((a = f[a]) != b) ans = min(ans, a); while (a != b) ans = min(&#123;ans, a = f[a], b = f[b]&#125;); if (ans > n) puts(\"No solution\"); else printf(\"%d\\n\", ans); return 0; &#125; 特殊图 Problemset 这里的题会很杂。 最短路问题 与最短路相关的问题。它们是图论中比较基础的内容，但是很有意思。 [NOI Online 2021 入门组] 重力球 Portal. 合法的位置不是很多，把它们都搜出来并标号，并求出每一个重力方向到达的位置编号来建图，就可以使用 bfs 来求最短路了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; int n, m, q, tot, d[2005][2005], id[305][305], t[2005][2005][4]; bool a[305][305]; inline bool check(int x, int y) &#123; return a[x - 1][y] || a[x + 1][y] || a[x][y - 1] || a[x][y + 1]; &#125; vector&lt;int> G[2005][4]; void bfs(void) &#123; queue&lt;pair&lt;int, int>> q; for (int i = 1; i &lt;= tot; ++i) q.emplace(i, i), d[i][i] = 0; while (!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); for (int k = 0; k &lt; 4; ++k) for (int i : G[x][k]) for (int j : G[y][k]) if (d[i][j] == INF) d[i][j] = d[x][y] + 1, q.emplace(i, j); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; ++i) a[0][i] = a[i][0] = a[n + 1][i] = a[i][n + 1] = 1; while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); a[x][y] = 1; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (!a[i][j] &amp;&amp; check(i, j)) id[i][j] = ++tot; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) t[i][j][0] = a[i][j - 1] ? id[i][j] : t[i][j - 1][0], t[i][j][1] = a[i - 1][j] ? id[i][j] : t[i - 1][j][1]; for (int i = n; i >= 1; --i) for (int j = n; j >= 1; --j) t[i][j][2] = a[i][j + 1] ? id[i][j] : t[i][j + 1][2], t[i][j][3] = a[i + 1][j] ? id[i][j] : t[i + 1][j][3]; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (id[i][j]) for (int k = 0; k &lt; 4; ++k) G[t[i][j][k]][k].emplace_back(id[i][j]); memset(d, 0x3f, sizeof(d)); bfs(); while (q--) &#123; int x, p, y, q; scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;p, &amp;q); if (x == p &amp;&amp; y == q) puts(\"0\"); else &#123; int ans = min(&#123;d[t[x][y][0]][t[p][q][0]], d[t[x][y][1]][t[p][q][1]], d[t[x][y][2]][t[p][q][2]], d[t[x][y][3]][t[p][q][3]]&#125;); printf(\"%d\\n\", ans == INF ? -1 : ans + 1); &#125; &#125; return 0; &#125; [JLOI2015] 管道连接 Portal. 求的是最小斯坦纳树森林。设 g(s)g(s)g(s) 代表连接 sss 所需要的最小代价，先用常规方法赋予初值，然后整一个子集 DP 进行更新。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef pair&lt;int, int> pii; const int INF = 0x3f3f3f3f; int n, m, p, f[1024][1005]; vector&lt;pair&lt;int, int>> G[1005]; queue&lt;int> q; bool inq[1005]; void SPFA(int s) &#123; for (int i = 0; i &lt; n; ++i) if (f[s][i] != INF) q.emplace(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (auto [v, w] : G[u]) if (f[s][v] > f[s][u] + w) f[s][v] = f[s][u] + w, q.emplace(v), inq[v] = true; &#125; &#125; int solve(int k) &#123; if (k == 0) return 0; for (int s = 1; s &lt; 1 &lt;&lt; k; ++s) &#123; for (int t = s - 1 &amp; s; t; t = t - 1 &amp; s) for (int i = 0; i &lt; n; ++i) f[s][i] = min(f[s][i], f[t][i] + f[s ^ t][i]); SPFA(s); &#125; int ans = INF; for (int i = 0; i &lt; n; ++i) ans = min(ans, f[(1 &lt;&lt; k) - 1][i]); return ans; &#125; struct Node &#123; int c, p, v; bool operator &lt; (const Node &amp;a) const &#123; return c &lt; a.c; &#125; &#125; a[15]; int g[1024]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;p); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].emplace_back(v, w); G[v].emplace_back(u, w); &#125; for (int i = 0; i &lt; p; ++i) scanf(\"%d%d\", &amp;a[i].c, &amp;a[i].p); sort(a, a + p); memset(g, 0x3f, sizeof(g)); g[0] = 0; int k = 0; for (int i = 0; i &lt; p; ++i) &#123; if (i == 0 || a[i].c != a[i - 1].c) ++k; a[i].v = k - 1; &#125; for (int i = 1; i &lt; 1 &lt;&lt; k; ++i) &#123; memset(f, 0x3f, sizeof(f)); int cnt = 0; for (int j = 0; j &lt; p; ++j) if (1 &lt;&lt; a[j].v &amp; i) f[1 &lt;&lt; cnt++][a[j].p] = 0; g[i] = solve(cnt); &#125; for (int i = 1; i &lt; 1 &lt;&lt; k; ++i) for (int j = i - 1 &amp; i; j; j = j - 1 &amp; i) g[i] = min(g[i], g[j] + g[i ^ j]); return printf(\"%d\\n\", g[(1 &lt;&lt; k) - 1]), 0; &#125; [ARC084B] Small Multiple Portal. 任何数都可以从 111 开始通过 ×10,+1\\times 10,+1×10,+1 两种操作得到，代价分别是 0,10,10,1。跑一个 01 bfs 最短路求出 f(i)f(i)f(i) 代表模 KKK 为 iii 的数的最小代价即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;deque> using namespace std; bool vis[100005]; deque&lt;pair&lt;int, int>> q; int main(void) &#123; int K; scanf(\"%d\", &amp;K); q.emplace_back(1, 1); vis[1] = true; while (!q.empty()) &#123; int num = q.front().first, w = q.front().second; q.pop_front(); if (num == 0) return printf(\"%d\\n\", w), 0; if (!vis[num * 10 % K]) q.emplace_front(num * 10 % K, w), vis[num * 10 % K] = true; if (!vis[(num + 1) % K]) q.emplace_back((num + 1) % K, w + 1); &#125; return 0; &#125; [省选联考 2021 A/B 卷] 图函数 Portal. 直接考虑整体的答案。发现只有 u≤vu\\le vu≤v，经过的点的编号全部大于 vvv 的点对（因为在这之前小于的都删完了）(u,v)(u,v)(u,v) 才会有贡献。 发现这是个 Floyd 的模型，这样可以方便地统计路径上经过的最小编号的最大值。这样的时间复杂度为 O(n3+m)O(n^3+m)O(n3+m)，相当极限！因此注意 Floyd 枚举的时候如果距离没有就跳过，并且不要计算不合法的转移。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, f[1005][1005]; // f[i][j]: i 到 j 的路径中，经过的最小编号的边的最大值 int ans[200005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) f[i][i] = m + 1; for (int i = 1, u, v; i &lt;= m; ++i) scanf(\"%d%d\", &amp;u, &amp;v), f[u][v] = i; for (int k = n; k >= 1; --k) &#123; // 只经过 k ~ n 的点，路径上的点的编号大于 k for (int i = 1; i &lt;= n; ++i) if (f[i][k]) &#123; int lim = i &lt; k ? n : k - 1; // 当 i >= k, j >= k 时，经过 1 ~ k 是不合法的 for (int j = 1; j &lt;= lim; ++j) f[i][j] = max(f[i][j], min(f[i][k], f[k][j])); &#125; for (int i = k; i &lt;= n; ++i) &#123; // k -> i, i -> k int t = min(f[k][i], f[i][k]); if (t) ++ans[t - 1]; &#125; &#125; for (int i = m; i >= 0; --i) ans[i] += ans[i + 1]; for (int i = 0; i &lt;= m; ++i) printf(\"%d \", ans[i]); return putchar('\\n'), 0; &#125; 连通性问题 包括连通性中需要一些思考的综合题，以及圆方树相关题目。 [APIO2018] 铁人两项 Portal. 相当于是求 (s,f)(s,f)(s,f) 上的简单路径上共有多少个点（除去 s,fs,fs,f）。 建立出圆方树。路径 sss 到 fff 对应是链上的权值和，其中方点的贡献为点双连通分量的大小，圆点的贡献为 −1-1−1，这样就是答案。因为方点计算贡献时，路径上的所有圆点都会被多算进去一次（两头是因为题目规定，中间的是因为两边都有方点）。 统计答案时采用 dfs，计算有多少个 (s,f)(s,f)(s,f) 点对。 注意原图可能不联通。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, node, m, a[200005], N; int dfn[100005], low[100005], num, tot, st[100005]; vector&lt;int> E[100005], G[200005]; inline void addedge(int u, int v) &#123; G[u].emplace_back(v); G[v].emplace_back(u); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; ++N; a[x] = -1; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; int z; addedge(++node, x); ++a[node]; do addedge(z = st[tot--], node), ++a[node]; while (z != y); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; i64 ans; int siz[200005]; void dfs(int x, int fa) &#123; siz[x] = (x &lt;= n); i64 cnt = 0; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); cnt += 1ll * siz[x] * siz[y]; siz[x] += siz[y]; &#125; cnt += 1ll * siz[x] * (N - siz[x]); ans += 1ll * a[x] * cnt * 2; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); node = n; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v); E[v].emplace_back(u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) &#123; N = tot = 0; tarjan(i); dfs(i, 0); &#125; return printf(\"%lld\\n\", ans), 0; &#125; [COI2007] Policija Portal. 第二问就是看 ccc 是否在简单路径上。第一问首先这条边必须是割边，这条割边可以对应到一个方点，看这个方点是否在简单路径上。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, node; int dfn[200005], low[100005], num, tot, st[100005]; vector&lt;int> E[100005], G[200005]; map&lt;pair&lt;int, int>, int> B; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; G[x].emplace_back(++node); G[node].emplace_back(x); if (st[tot] == y) B[&#123;x, y&#125;] = node; for (int z = 0; z != y; ) &#123; G[node].emplace_back(z = st[tot--]); G[z].emplace_back(node); &#125; &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; int dep[200005], siz[200005], f[21][200005]; void dfs(int x, int fa) &#123; dfn[x] = ++num; dep[x] = dep[f[0][x] = fa] + 1; siz[x] = 1; for (int i = 1; i &lt;= 20; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); siz[x] += siz[y]; &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 20; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = 20; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; bool isanc(int x, int y) &#123; // x 是否是 y 的祖先 return dfn[x] &lt;= dfn[y] &amp;&amp; dfn[y] &lt; dfn[x] + siz[x]; &#125; bool lie(int u, int v, int x) &#123; // x 是否在 (u,v) 上 if (!isanc(x, u) &amp;&amp; !isanc(x, v)) return 0; if (!isanc(LCA(u, v), x)) return 0; return 1; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); node = n; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v); E[v].emplace_back(u); &#125; tarjan(1); num = 0; dfs(1, 0); int q; scanf(\"%d\", &amp;q); while (q--) &#123; int op, a, b, c, d; scanf(\"%d%d%d%d\", &amp;op, &amp;a, &amp;b, &amp;c); if (op == 1) &#123; scanf(\"%d\", &amp;d); int e = -1; auto it = B.find(&#123;c, d&#125;); if (it != B.end()) e = it->second; else &#123; it = B.find(&#123;d, c&#125;); if (it != B.end()) e = it->second; &#125; if (e == -1) puts(\"yes\"); else puts(lie(a, b, e) ? \"no\" : \"yes\"); &#125; else puts(lie(a, b, c) ? \"no\" : \"yes\"); &#125; return 0; &#125; [CF1763F] Edge Queries Portal. 建立出圆方树。将原图中的每一条边对应到圆方树上，增加方点的权值。如果方点的权值为 111，那么说明是割边，否则删除任意一条都可以。这样答案就是路径上方点的权值和。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, node, q; int dfn[400005], low[200005], num, st[200005], tot; vector&lt;int> E[200005], G[400005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; G[++node].emplace_back(x); G[x].emplace_back(node); for (int z = 0; z != y; ) &#123; G[node].emplace_back(z = st[tot--]); G[z].emplace_back(node); &#125; &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; int lg[400005], dep[400005], siz[400005], mi[22][400005], f[400005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; f[x] = mi[0][dfn[x] = ++num] = fa; dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int s[400005], w[400005]; void dfs2(int x) &#123; s[x] = s[f[x]] + w[x]; for (int y : G[x]) if (y != f[x]) dfs2(y); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); node = n; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v); E[v].emplace_back(u); &#125; tarjan(1); num = 0; dfs(1, 0); for (int i = 2; i &lt;= node; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= lg[node]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= node; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); for (int u = 1; u &lt;= n; ++u) for (int v : E[u]) if (u &lt;= v) &#123; if (f[u] == f[v]) ++w[f[u]]; else if (f[f[u]] == v) ++w[f[u]]; else ++w[f[v]]; &#125; for (int i = n + 1; i &lt;= node; ++i) if (w[i] == 1) w[i] = 0; dfs2(1); for (scanf(\"%d\", &amp;q); q--; ) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); int lca = LCA(a, b); printf(\"%d\\n\", s[a] + s[b] - s[lca] - s[f[lca]]); &#125; return 0; &#125; [CF487E] Tourists Portal. 建立出圆方树，方点的权值是它所属的 v-DCC 内的最小值，然后线段树维护即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; int n, m, q; int a[200005], dfn[200005], low[100005], num, tot, st[100005], node; vector&lt;int> E[100005], G[200005]; inline void add(int u, int v) &#123; G[u].emplace_back(v); G[v].emplace_back(u); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int y : E[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] == low[y]) &#123; int z; add(++node, x); do add(z = st[tot--], node); while (z != y); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; int siz[200005], son[200005], f[200005], dep[200005], top[200005], idx[200005]; void dfs1(int x, int fa) &#123; siz[x] = 1; dep[x] = dep[f[x] = fa] + 1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; idx[dfn[x] = ++num] = x; top[x] = topf; if (!son[x]) return; dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int T[800005]; multiset&lt;int> s[100005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[idx[l]], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = min(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o] = min(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = 1e9; if (x &lt;= mid) res = min(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = min(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); node = n; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v), E[v].emplace_back(u); &#125; tarjan(1); num = 0; dfs1(1, 0); dfs2(1, 1); for (int i = 2; i &lt;= n; ++i) s[f[i] - n].insert(a[i]); for (int i = n + 1; i &lt;= node; ++i) a[i] = s[i - n].empty() ? INF : *s[i - n].begin(); build(1, 1, node); char op[5]; int x, y; while (q--) &#123; scanf(\"%s%d%d\", op, &amp;x, &amp;y); if (op[0] == 'C') &#123; update(1, 1, node, dfn[x], y); if (x == 1) &#123; a[x] = y; continue; &#125; s[f[x] - n].erase(s[f[x] - n].find(a[x])); s[f[x] - n].insert(y); a[f[x]] = *s[f[x] - n].begin(); a[x] = y; update(1, 1, node, dfn[f[x]], a[f[x]]); &#125; else &#123; int ans = INF; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ans = min(ans, query(1, 1, node, dfn[top[x]], dfn[x])); x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); ans = min(ans, query(1, 1, node, dfn[x], dfn[y])); if (x > n) ans = min(ans, a[f[x]]); printf(\"%d\\n\", ans); &#125; &#125; return 0; &#125; 图上乱搞 一些奇怪的问题。 [CSP-S 2022] 星战 Portal. 说的是所有点的出度为 111，但是这样不好维护，转化为入度进行维护，搞一个哈希提高正确率。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; mt19937 Rand(time(0)); int n, m, q; u64 r[500005], g[500005]; // 入度，全部入度 u64 w[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); u64 ans = 0, res = 0; for (int i = 1; i &lt;= n; ++i) ans += (w[i] = Rand()); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); r[v] += w[u]; g[v] = r[v]; res += w[u]; &#125; for (scanf(\"%d\", &amp;q); q--; ) &#123; int op, u, v; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%d%d\", &amp;u, &amp;v); r[v] -= w[u]; res -= w[u]; &#125; else if (op == 2) &#123; scanf(\"%d\", &amp;v); res -= r[v]; r[v] = 0; &#125; else if (op == 3) &#123; scanf(\"%d%d\", &amp;u, &amp;v); r[v] += w[u]; res += w[u]; &#125; else &#123; scanf(\"%d\", &amp;v); res += g[v] - r[v]; r[v] = g[v]; &#125; puts(res == ans ? \"YES\" : \"NO\"); &#125; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"算法竞赛/学习笔记/图论","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"动态规划的状态设计","slug":"notes/DP/status-dp","date":"2023-01-09T00:00:00.000Z","updated":"2023-04-01T00:00:00.000Z","comments":true,"path":"bb10c5df/","link":"","permalink":"https://james1badcreeper.github.io/bb10c5df/","excerpt":"动态规划的状态设计有许多值得探讨的内容。本文会从基本模型讲起，拓展到一些复杂的内容。","text":"动态规划的状态设计有许多值得探讨的内容。本文会从基本模型讲起，拓展到一些复杂的内容。 这里的基本模型并不会从基础开始，请确保你已经了解它们。 简单问题 这里的问题比较简单。 背包问题 这是一种很基础的模型，这里仅补充一个知识点。 方案数背包的撤回 其实之前已经见过这类问题，这里总结一下。 背包的添加物品很容易，但是删除物品很难。我们采用过前后缀合并的办法（但是需要枚举体积），也有线段树分治的做法。但是对于方案数背包，我们可以简单撤回：只需要减去当时加上的内容就行了。但是要注意循环顺序，应该是相反的。 区间 DP 最重要的特点是“合并”，如果题目有这种感觉，那么区间 DP 大概率是可做的。另外的知识点就是断环为链，可以高效解决环上的区间 DP 问题。 由于区间 DP 的常数很小（以下数据范围的循环次数约为 10910^9109 次），所以在需要枚举断点（O(n3)O(n^3)O(n3)）时，一般可以解决 2×1032\\times 10^32×103 级别的问题；不需要枚举断点（从两头扩展，O(n2)O(n^2)O(n2) 时），一般可以解决 5×1045\\times 10^45×104 的问题。 区间 DP 也可以扩展到二维情况，此时一般会使用记忆化搜索实现，模板题可以参考 CF1198D，代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int f[55][55][55][55]; char s[55][55]; int dfs(int x, int y, int _x, int _y) &#123; if (f[x][y][_x][_y] != -1) return f[x][y][_x][_y]; if (x == _x &amp;&amp; y == _y) return f[x][y][_x][_y] = (s[x][y] == '#'); int res = max(_x - x + 1, _y - y + 1); for (int i = x; i &lt; _x; ++i) res = min(res, dfs(x, y, i, _y) + dfs(i + 1, y, _x, _y)); for (int i = y; i &lt; _y; ++i) res = min(res, dfs(x, y, _x, i) + dfs(x, i + 1, _x, _y)); return f[x][y][_x][_y] = res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); memset(f, -1, sizeof f); for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", s[i] + 1); printf(\"%d\\n\", dfs(1, 1, n, n)); return 0; &#125; 树形 DP 主要分为拓扑序问题和背包问题，对于子树的处理还会涉及到换根。在设计的时候，一定要注意子树的合并是每次加一个点还是一条边。 对于多次树形 DP，可以拍成 DFS 序进行优化。利用 DFS 序从大到小向父亲转移，可以很高效地实现树形 DP。 状压 DP 当难度上来之后，会发现状压 DP 相当麻烦。这里补充几个比较实用的知识点。 子集 DP [NOIP2017 提高组] 宝藏。 设 f(i,j)f(i,j)f(i,j) 代表当前点集为 iii，树的最深节点到根节点的距离为 jjj。枚举 iii 的子集，让不是它子集的那些都作为第 jjj 层的儿子连接。枚举子集的子集的时间复杂度为 O(∑Cnk2k)=O(3n)O(\\sum C_{n}^{k}2^k)=O(3^n)O(∑Cnk​2k)=O(3n) 级别。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int INF = 0x3f3f3f3f; int n, m, A[15][15]; int f[32770][17], v[32770]; // 点集为 i，深度为 j int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(A, 0x3f, sizeof(A)); while (m--) &#123; int a, b, c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); --a; --b; A[a][b] = A[b][a] = min(A[a][b], c); &#125; memset(f, 0x3f, sizeof(f)); for (int i = 0; i &lt; n; ++i) f[1 &lt;&lt; i][0] = A[i][i] = 0; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (i &amp; (1 &lt;&lt; j)) for (int k = 0; k &lt; n; ++k) if (A[j][k] != INF) v[i] |= (1 &lt;&lt; k); for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) for (int s = i - 1 &amp; i; s; s = s - 1 &amp; i) if ((v[s] &amp; i) == i) &#123; int ss = s ^ i, sum = 0; for (int j = 0; j &lt; n; ++j) if (ss &amp; (1 &lt;&lt; j)) &#123; int tmp = INF; for (int k = 0; k &lt; n; ++k) if (s &amp; (1 &lt;&lt; k)) tmp = min(tmp, A[j][k]); sum += tmp; &#125; for (int j = 1; j &lt; n; ++j) if (f[s][j - 1] != INF) f[i][j] = min(f[i][j], f[s][j - 1] + sum * j); &#125; int ans = INF; for (int i = 0; i &lt; n; ++i) ans = min(ans, f[(1 &lt;&lt; n) - 1][i]); printf(\"%d\\n\", ans); return 0; &#125; 插头 DP 制毒大枭投掷了神秘的毒药。将于未知的时间补充。 计数类 DP 严格来说，计数类 DP 不是 DP。动态规划是一类最优化问题，而计数类问题统计的是方案数，但是计数时要求“不重不漏”，需要精确的划分和整体性的计算，因此使用动态规划的子结构与多阶段可以高效的求解计数类 DP，实现上这种方法只能叫做递推。 其实计数 DP 会与很多组合方法综合，我们会见到的。 引子 我们做几道简单题， [HAOI2010] 最长公共子序列 Portal. 求最长公共子序列已经很简单了，至于数量，就是要看它从哪里转移过来。设 g(i,j)g(i,j)g(i,j) 代表 A1…Ai,B1…BjA_1\\dots A_i,B_1\\dots B_jA1​…Ai​,B1​…Bj​ 的 LCS 个数，f(i,j)f(i,j)f(i,j) 代表 A1…Ai,B1…BjA_1\\dots A_i,B_1\\dots B_jA1​…Ai​,B1​…Bj​ 的 LCS 长度，那么： 如果 g(i,j)g(i,j)g(i,j) 可以从 g(i−1,j)g(i-1,j)g(i−1,j) 转移过来，那么需要加上它的方案数； 如果 g(i,j)g(i,j)g(i,j) 可以从 g(i,j−1)g(i,j-1)g(i,j−1) 转移过来，那么需要加上它的方案数； 如果 g(i,j)g(i,j)g(i,j) 可以从 g(i−1,j−1)g(i-1,j-1)g(i−1,j−1) 转移过来，那么需要加上它的方案数。 但是如果前两条同时生效，那么会出现一个问题：f(i,j)=f(i−1,j)=f(i,j−1)f(i,j)=f(i-1,j)=f(i,j-1)f(i,j)=f(i−1,j)=f(i,j−1)，如果此时 f(i−1,j),f(i,j−1)f(i-1,j),f(i,j-1)f(i−1,j),f(i,j−1) 都可以从 f(i−1,j−1)f(i-1,j-1)f(i−1,j−1) 转移，那么这里就重复了，需要减去 g(i−1,j−1)g(i-1,j-1)g(i−1,j−1)。这种情况是什么时候？就是当上述的第三种转移没有生效的时候。也就是 f(i,j)=f(i−1,j−1)f(i,j) = f(i-1,j-1)f(i,j)=f(i−1,j−1)，这样的话 f(i−1,j−1)=f(i−1,j)=f(i,j−1)f(i-1,j-1)=f(i-1,j)=f(i,j-1)f(i−1,j−1)=f(i−1,j)=f(i,j−1)，也就是说 f(i−1,j),f(i,j−1)f(i-1,j),f(i,j-1)f(i−1,j),f(i,j−1) 都可以从 f(i−1,j−1)f(i-1,j-1)f(i−1,j−1) 转移过来。 由于空间限制，所以要使用滚动数组。 查看代码 // 由于这份代码的常数较大，可能需要吸氧才能过 #include &lt;bits/stdc++.h> #define i64 long long using namespace std; const int MOD = 100000000; char a[5005], b[5005]; int n, m, f[2][5005]; i64 g[2][5005]; int main(void) &#123; scanf(\"%s%s\", a + 1, b + 1); n = strlen(a + 1) - 1, m = strlen(b + 1) - 1; for (int i = 0; i &lt;= m; ++i) g[0][i] = 1; g[1][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; f[i &amp; 1][j] = max(&#123;f[i &amp; 1][j - 1], f[(i - 1) &amp; 1][j], f[(i - 1) &amp; 1][j - 1] + (a[i] == b[j])&#125;); g[i &amp; 1][j] = 0; if (f[i &amp; 1][j] == f[(i - 1) &amp; 1][j]) g[i &amp; 1][j] += g[(i - 1) &amp; 1][j]; if (f[i &amp; 1][j] == f[i &amp; 1][j - 1]) g[i &amp; 1][j] += g[i &amp; 1][j - 1]; if (f[i &amp; 1][j] == f[(i - 1) &amp; 1][j - 1] + 1 &amp;&amp; a[i] == b[j]) g[i &amp; 1][j] += g[(i - 1) &amp; 1][j - 1]; if (f[i &amp; 1][j] == f[(i - 1) &amp; 1][j - 1]) g[i &amp; 1][j] -= g[(i - 1) &amp; 1][j - 1]; g[i &amp; 1][j] %= MOD; &#125; printf(\"%d\\n%lld\\n\", f[n &amp; 1][m], g[n &amp; 1][m]); return 0; &#125; [CF149D] Coloring Brackets Portal. 设 f(i,j,p,q)f(i,j,p,q)f(i,j,p,q) 为考虑区间 [i,j][i,j][i,j]，iii 的颜色为 ppp，jjj 的颜色为 qqq 的方案数。转移也很好写，用 dfs 实现。 查看代码 #include &lt;bits/stdc++.h> #define i64 long long using namespace std; const int MOD = 1000000007; int n; char s[705]; int match[705]; int f[705][705][3][3]; void dfs(int l, int r) &#123; #define rep(i) for (int i = 0; i &lt;= 2; ++i) if (l + 1 == r) &#123; f[l][r][0][1] = 1; f[l][r][0][2] = 1; f[l][r][1][0] = 1; f[l][r][2][0] = 1; return; &#125; if (match[l] == r) &#123; dfs(l + 1, r - 1); rep(i) rep(j) &#123; if (i != 1) f[l][r][1][0] = (f[l][r][1][0] + f[l + 1][r - 1][i][j]) % MOD; if (i != 2) f[l][r][2][0] = (f[l][r][2][0] + f[l + 1][r - 1][i][j]) % MOD; if (j != 1) f[l][r][0][1] = (f[l][r][0][1] + f[l + 1][r - 1][i][j]) % MOD; if (j != 2) f[l][r][0][2] = (f[l][r][0][2] + f[l + 1][r - 1][i][j]) % MOD; &#125; return; &#125; dfs(l, match[l]), dfs(match[l] + 1, r); rep(i) rep(j) rep(p) rep(q) &#123; if (j == p &amp;&amp; j != 0) continue; f[l][r][i][q] = (f[l][r][i][q] + (i64)f[l][match[l]][i][j] * f[match[l] + 1][r][p][q]) % MOD; &#125; &#125; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); stack &lt;int> st; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] == '(') st.push(i); else match[st.top()] = i, match[i] = st.top(), st.pop(); &#125; dfs(1, n); int ans = 0; for (int i = 0; i &lt;= 2; ++i) for (int j = 0; j &lt;= 2; ++j) ans = (ans + f[1][n][i][j]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; 简单组合 组合数，组合方法这些对于读者来说一定不陌生。它们是与多阶段计数的最佳拍档。 [AHOI2009] 中国象棋 Portal. 显然每一行、每一列都最多只能有两个棋子。定义 f(i,j,k)f(i,j,k)f(i,j,k) 为考虑前 iii 行，有 jjj 列是一个棋子，kkk 列是两个棋子，剩下的 m−j−km-j-km−j−k 列没有棋子，显然计算时要满足 j+k≤mj+k\\le mj+k≤m。 初始肯定 f(0,0,0)=1f(0,0,0)=1f(0,0,0)=1，接下来一行一行的考虑。 第 iii 行肯定可以什么都不放，所以我们用 f(i−1,j,k)f(i-1,j,k)f(i−1,j,k) 初始化 f(i,j,k)f(i,j,k)f(i,j,k)。 然后考虑第 iii 行放什么。显然要么放 111 个棋子，要么放 222 个棋子。 当放一个棋子的时候，这个棋子可以放在没有棋子的列，也可以放在有 111 个棋子的列。如果放在没有棋子的列，说明当前的 f(i,j,k)f(i,j,k)f(i,j,k) 是从 f(i−1,j−1,k)f(i-1,j-1,k)f(i−1,j−1,k) 过来的（多了一个有 111 个棋子的列），放的时候有 m−(j−1)−km-(j-1)-km−(j−1)−k 个空列，随便选一个即可。如果放在有一个棋子的列，说明当前的 f(i,j,k)f(i,j,k)f(i,j,k) 是从 f(i−1,j+1,k−1)f(i-1,j+1,k-1)f(i−1,j+1,k−1) 过来的（有一个棋子的少了一个，两个棋子的多了一个），选择时在 j+1j+1j+1 个有一个棋子的列随便选一个即可。 当放两个棋子的时候，这两个棋子可以都放在没有棋子的列，这样它从 f(i−1,j−2,k)f(i-1,j-2,k)f(i−1,j−2,k) 过来的，放的时候的在 m−(j−2)−km-(j-2)-km−(j−2)−k 个空列中组合，共有 Cm−(j−2)−k2C_{m-(j-2)-k}^2Cm−(j−2)−k2​ 中可能；也可以都放在有一个棋子的列，从 f(i−1,j+2,k−2)f(i-1,j+2,k-2)f(i−1,j+2,k−2) 过来，有 Cm−(j+2)−k2C_{m-(j+2)-k}^2Cm−(j+2)−k2​；还可以一个放在没有棋子的列，一个放在有一个棋子的列，从 f(i−1,j,k−1)f(i-1,j,k-1)f(i−1,j,k−1) 过来（一个放在没有棋子的列使得 j+1j+1j+1，一个放在有一个棋子的列使得 j−1,k+1j-1,k+1j−1,k+1，综合起来就是 jjj 不变，k+1k+1k+1），选择时放在没有棋子的列的选择有 m−j−(k−1)m-j-(k-1)m−j−(k−1) 种，放在有一个棋子的列的选择有 jjj 种。 可以使用滚动数组优化空间。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const int MOD = 9999973; int n, m; i64 f[2][105][105]; // 考虑前 i 行，有 j 列是一个棋子，k 列是两个棋子 int C(int n) &#123; return (n * (n - 1)) / 2; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); f[0][0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j) for (int k = 0; j + k &lt;= m; ++k) &#123; f[i &amp; 1][j][k] = f[(i - 1) &amp; 1][j][k]; if (/*m - j + 1 - k >= 0 &amp;&amp; */j >= 1) f[i &amp; 1][j][k] += f[(i - 1) &amp; 1][j - 1][k] * (m - j + 1 - k); // 放一个棋子，放在没有棋子的列 if (k >= 1) f[i &amp; 1][j][k] += (f[(i - 1) &amp; 1][j + 1][k - 1]) * (j + 1); // 放一个棋子在有一个棋子的列 if (/*m - j + 2 - k >= 0 &amp;&amp; */j >= 2) f[i &amp; 1][j][k] += f[(i - 1) &amp; 1][j - 2][k] * C(m - j + 2 - k); // 放两个棋子在都没有棋子的列 if (k >= 2) f[i &amp; 1][j][k] += f[(i - 1) &amp; 1][j + 2][k - 2] * C(j + 2); // 放两个棋子在都有一个棋子的列 if (/*m - j - k + 1 >= 0 &amp;&amp; */k >= 1) f[i &amp; 1][j][k] += f[(i - 1) &amp; 1][j][k - 1] * j * (m - j - k + 1); // 放两个棋子，一个在有一个棋子的列，一个在没有棋子的列 f[i &amp; 1][j][k] %= MOD; &#125; i64 ans = 0; for (int i = 0; i &lt;= m; ++i) for (int j = 0; i + j &lt;= m; ++j) ans = (ans + f[n &amp; 1][i][j]) % MOD; printf(\"%lld\\n\", ans); return 0; &#125; [CF425E] Sereja and Sets Portal. 设 f(r,i)f(r,i)f(r,i) 为右端点为 rrr，时间为 iii 的方案数。转移采用刷表法。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 1000000007; int n, k; i64 f[505][505], poww[250005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); f[0][0] = 1; poww[0] = 1; for (int i = 1; i &lt;= n * n; ++i) poww[i] = poww[i - 1] * 2 % MOD; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= i; ++j) for (int k = i + 1; k &lt;= n; ++k) f[k][j + 1] = (f[k][j + 1] + f[i][j] * (poww[k - i] - 1) % MOD * poww[(n - k) * (k - i)]) % MOD; i64 ans = 0; for (int i = 0; i &lt;= n; ++i) ans += f[i][k]; printf(\"%lld\\n\", ans % MOD); return 0; &#125; [NOIP2021] 数列 Portal.给定整数 n,m,k(k≤n≤30,m≤100)n, m, k(k\\le n\\le 30,m\\le 100)n,m,k(k≤n≤30,m≤100)，和一个长度为 m+1m + 1m+1 的正整数数组 v0,v1,…,vmv_0, v_1, \\ldots, v_mv0​,v1​,…,vm​。对于一个长度为 nnn，下标从 111 开始且每个元素均不超过 mmm 的非负整数序列 {ai}\\{a_i\\}{ai​}，我们定义它的权值为 va1×va2×⋯×vanv_{a_1} \\times v_{a_2} \\times \\cdots \\times v_{a_n}va1​​×va2​​×⋯×van​​。当这样的序列 {ai}\\{a_i\\}{ai​} 满足整数 S=2a1+2a2+⋯+2anS = 2^{a_1} + 2^{a_2} + \\cdots + 2^{a_n}S=2a1​+2a2​+⋯+2an​ 的二进制表示中 111 的个数不超过 kkk 时，我们认为 {ai}\\{a_i\\}{ai​} 是一个合法序列。计算所有合法序列 {ai}\\{a_i\\}{ai​} 的权值和对 998244353998244353998244353 取模的结果。 SSS 在统计时是会进位的，因此我们设 f(i,j,k,p)f(i,j,k,p)f(i,j,k,p) 代表考虑 SSS 从低位开始的前 iii 位，考虑了 jjj 个数（任意），有 kkk 个 111（由于是加法，111 只能变多不能变少），向下一位的进位为 ppp（状态中的 SSS 按照二进制考虑，第 iii 位有 ppp 个 111，很显然这样压根就没有考虑进位，进位是在转移的时候进行的）。显然初始时有 f(0,0,0,0)=1f(0,0,0,0)=1f(0,0,0,0)=1，接下来考虑如何转移。 显然刷表法会更容易一些。假设再给序列 aaa 选择 ttt 个元素 iii，那么 SSS 的第 iii 位就会加上 ttt 个 111，总共就有了 t+pt+pt+p 个 111。同时我们要将第 iii 位进行“展平”，也就是向前进位。如果 t+pt+pt+p 是奇数，那么 111 的个数就多了 111，否则没变；向前进位的个数为 ⌊t+p2⌋\\left\\lfloor\\cfrac{t+p}{2}\\right\\rfloor⌊2t+p​⌋。也就是说，f(i,j,k,p)f(i,j,k,p)f(i,j,k,p) 转移到了： f(i+1,j+t,k+(t+p) mod 2,⌊t+p2⌋)f\\left(i+1,j+t,k+(t+p)\\bmod 2,\\left\\lfloor\\frac{t+p}{2}\\right\\rfloor\\right) f(i+1,j+t,k+(t+p)mod2,⌊2t+p​⌋) 贡献是多少？基数是 f(i,j,k,p)f(i,j,k,p)f(i,j,k,p)，这种转移共有 (n−jt)\\dbinom{n-j}{t}(tn−j​) 个 vitv_i^tvit​ 种方式（在还没有填的 aaa 中选出 ttt 个来填），单次的贡献是 vitv_i^tvit​，所以贡献为 vit×(n−jt)v_i^t\\times \\dbinom{n-j}{t}vit​×(tn−j​)。 统计答案时判断一下 111 的个数是否合法即可（要加上进位的）。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 998244353; int n, m, K; int C[35][35], v[105][55]; int f[105][35][35][35]; int count(int x) &#123; int res = 0; for (;x ; x >>= 1) res += (x &amp; 1); return res; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;K); C[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD; &#125; for (int i = 0; i &lt;= m; ++i) &#123; v[i][0] = 1; scanf(\"%d\", &amp;v[i][1]); for (int j = 2; j &lt;= n; ++j) v[i][j] = 1ll * v[i][j - 1] * v[i][1] % MOD; &#125; f[0][0][0][0] = 1; for (int i = 0; i &lt;= m; ++i) for (int j = 0; j &lt;= n; ++j) for (int k = 0; k &lt;= K; ++k) for (int p = 0; p &lt;= n >> 1; ++p) for (int t = 0; t &lt;= n - j; ++t) &#123; int &amp;dp = f[i + 1][j + t][k + ((t + p) &amp; 1)][(t + p) >> 1]; dp = (dp + 1ll * f[i][j][k][p] * v[i][t] % MOD * C[n - j][t]) % MOD; &#125; int ans = 0; for (int k = 0; k &lt;= K; ++k) for (int p = 0; p &lt;= n >> 1; ++p) if (k + count(p) &lt;= K) ans = (ans + f[m + 1][n][k][p]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; 数位统计 DP 简称数位 DP。用于解决一类与数字相关，一般是给定一些限制条件，然后询问满足条件的第 kkk 小数是多少，或者是有多少个满足条件的数的题目。 概述 将数字按每一位拆开，比如最常用的十进制，拆完之后每一位数字都是 0∼90\\sim 90∼9。问题具有以下特征： 计数，统计数的数量； 数的值域很大； 可以使用”数位“来理解…… 比如说 james1 数数，数 100∼199100\\sim 199100∼199 和 200∼299200\\sim 299200∼299 几乎一致，00∼9900\\sim 9900∼99 这一部分是完全一样的。这样就可以根据此设计状态来求解问题。 很多时候为了计算方便我们都会先允许前导 000 的存在，最后再减去。 简单题 我们来看一些简单的题目来进一步认识数位 DP。 [ZJOI2010] 数字计数 Portal.给定两个正整数 aaa 和 bbb，求在 [a,b][a,b][a,b] 中的所有整数中，每个数码各出现了多少次，1≤a≤b≤10121\\le a\\le b\\le 10^{12}1≤a≤b≤1012。 设 f(i)f(i)f(i) 代表满 iii 位数的每个数字的出现个数，即 0∼10i−10\\sim 10^i-10∼10i−1 中的每个数字的出现个数，假定可以有前导零，那么每个数字的出现次数是相等的。前 i−1i-1i−1 位的数字贡献是 10f(i−1)10f(i-1)10f(i−1)，第 iii 位的数字贡献是 10i−110^{i-1}10i−1。 现在考虑如何统计答案。我们肯定是求两个前缀和然后相减。求前缀和时将上界从高到低位枚举，不贴着上界时后面可以随便取，贴着时只能取到上界。如果有前导零还需要减去。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; i64 l, r; i64 f[15], poww[15]; i64 ans1[15], ans2[15]; void calc(i64 n, i64 *ans) &#123; static int a[15]; int len = 0; i64 tmp = n; while (tmp) a[++len] = tmp % 10, tmp /= 10; for (int i = len; i >= 1; --i) &#123; // 首先考虑后 i - 1 位的贡献 for (int j = 0; j &lt; 10; ++j) ans[j] += f[i - 1] * a[i]; // 满 i-1 位的数字，有 a[i] 个（不算以 0 打头，因为下一位的时候会考虑） // 再考虑第 i 位的贡献 for (int j = 0; j &lt; a[i]; ++j) ans[j] += poww[i - 1]; // 0 ~ a[i]-1 都会出现 10^(i-1) 次 n -= poww[i - 1] * a[i]; // 减掉第 i 位，剩下的数字 ans[a[i]] += n + 1; // a[i] 会在 0~n 出现一次 // 最后处理前导零 ans[0] -= poww[i - 1]; // 当第 i 位为 0 时，答案就没有意义，此时剩下的可以随便填，仅有这部分的零不会出现 &#125; &#125; int main(void) &#123; cin >> l >> r; poww[0] = 1; for (int i = 1; i &lt;= 13; ++i) &#123; f[i] = f[i - 1] * 10 + poww[i - 1]; poww[i] = poww[i - 1] * 10; &#125; calc(r, ans1); calc(l - 1, ans2); for (int i = 0; i &lt; 10; ++i) printf(\"%lld \", ans1[i] - ans2[i]); putchar('\\n'); return 0; &#125; [CQOI2016] 手机号码 Portal. 数位 DP 一般采用记忆化搜索实现。直接将所有信息记录下来，暴力枚举每一位的数字。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int num[15]; int f[11][11][11][2][2][2][2]; i64 dp(int p, int p1, int p2, bool lim, bool d, bool _4, bool _8) &#123; if (_4 &amp;&amp; _8) return 0; if (p == 0) return d; if (f[p][p1][p2][lim][d][_4][_8] != -1) return f[p][p1][p2][lim][d][_4][_8]; i64 res = 0; int mx = lim ? 9 : num[p]; for (int i = 0; i &lt;= mx; ++i) res += dp(p - 1, i, p1, lim || (i &lt; mx), d || (i == p1 &amp;&amp; i == p2), _4 || (i == 4), _8 || (i == 8)); return f[p][p1][p2][lim][d][_4][_8] = res; &#125; i64 calc(i64 n) &#123; memset(f, 0xff, sizeof f); for (int i = 1; i &lt;= 11; ++i, n /= 10) num[i] = n % 10; i64 res = 0; for (int i = 1; i &lt;= num[11]; ++i) res += dp(10, i, -1, i &lt; num[11], 0, i == 4, i == 8); return res; &#125; int main(void) &#123; i64 l, r; cin >> l >> r; cout &lt;&lt; calc(r) - calc(l - 1) &lt;&lt; \"\\n\"; return 0; &#125; 矩阵优化 DP 很多 DP 问题可以通过矩阵优化。 矩阵快速幂优化 矩阵快速幂可以加速递推，可以加速每一轮的转移都相同的转移方程。 [CF222E] Decoding Genome. 设 fi,jf_{i,j}fi,j​ 代表考虑到第 iii 个字符，此字符为 jjj 的方案数。发现转移是一个矩阵乘法的形式，因此可以使用矩阵快速幂优化。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000007; struct Matrix &#123; int a[52][52]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; friend Matrix operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 52; ++i) for (int k = 0; k &lt; 52; ++k) &#123; int r = a.a[i][k]; for (int j = 0; j &lt; 52; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b.a[k][j]) % P; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, i64 b) &#123; Matrix res = a; --b; for (; b; b >>= 1, a = a * a) if (b &amp; 1) res = res * a; return res; &#125; i64 n; int m, k; int H(char c) &#123; if (c >= 'a' &amp;&amp; c &lt;= 'z') return c - 'a'; return c - 'A' + 26; &#125; int main(void) &#123; ios::sync_with_stdio(false); cin >> n >> m >> k; if (n == 1) return cout &lt;&lt; m &lt;&lt; \"\\n\", 0; Matrix f, a; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; m; ++j) f.a[i][j] = 1; for (int i = 0; i &lt; m; ++i) a.a[0][i] = 1; for (int i = 1; i &lt;= k; ++i) &#123; char x, y; cin >> x >> y; f.a[H(x)][H(y)] = 0; &#125; a = a * poww(f, n - 1); int ans = 0; for (int i = 0; i &lt; m; ++i) ans = (ans + a.a[0][i]) % P; return cout &lt;&lt; ans &lt;&lt; \"\\n\", 0; &#125; 动态 DP 本来是指一类解决树上带权修改的 DP 问题，但是笔者认为利用数据结构维护广义矩阵乘法来进行 DP 的都应该属于“动态” DP。 Portal.给定一棵 nnn 个点的点权树，支持修改点的点权，查询树最大独立集的权值大小。 依然设 fi,1/0f_{i,1/0}fi,1/0​ 代表对于 iii 的子树是否选则第 iii 个节点，子树内的独立集最大大小。 如何支持修改？对原树进行重链剖分，设 gi,1/0g_{i,1/0}gi,1/0​ 代表 iii 的子树不考虑重儿子的情况下的答案。有： fi,0=gi,0+max⁡{fsoni,0,fsoni,1}fi,1=gi,1+fsoni,0f_{i,0}=g_{i,0}+\\max\\{f_{son_i,0},f_{son_i,1}\\}\\\\ f_{i,1}=g_{i,1}+f_{son_i,0} fi,0​=gi,0​+max{fsoni​,0​,fsoni​,1​}fi,1​=gi,1​+fsoni​,0​ 我们定义另一种矩阵乘法： Ci,j=max⁡k=1nAi,k+Bk,jC_{i,j}=\\max_{k=1}^n A_{i,k}+B_{k,j} Ci,j​=k=1maxn​Ai,k​+Bk,j​ 则有： [fsoni,0fsoni,1]×[gi,0gi,1gi,0−∞]=[fi,0fi,1]\\begin{bmatrix} f_{son_i,0} &amp; f_{son_i,1} \\end{bmatrix}\\times \\begin{bmatrix} g_{i,0} &amp; g_{i,1}\\\\ g_{i,0} &amp; -\\infty \\end{bmatrix}= \\begin{bmatrix} f_{i,0} &amp; f_{i,1} \\end{bmatrix} [fsoni​,0​​fsoni​,1​​]×[gi,0​gi,0​​gi,1​−∞​]=[fi,0​​fi,1​​] 这样在一条重链上就可以直接用线段树维护答案，我们只需要保证含 111 的那条链上的东西都是对的就行了（我们只需要保证 111 的答案正确，剩下的让它自生自灭即可）。 我们相当于从一个权值为 000 的叶子节点开始 DP，注意 DFS 序大的应该先乘，所以线段树的维护顺序应该是从右到左。修改时，当前节点的 gi,1g_{i,1}gi,1​ 会改变，然后直接考虑重链顶端父亲的答案改变，改的是当前节点的一个轻儿子，计算改变量即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; int n, m, a[100005], f[100005][2]; int siz[100005], son[100005], fa[100005]; int top[100005], L[100005], R[100005], num, idx[100005]; vector&lt;int> G[100005]; struct Matrix &#123; int a[2][2]; Matrix() &#123; memset(a, 0, sizeof a); &#125; friend Matrix operator* (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 2; ++i) for (int k = 0; k &lt; 2; ++k) &#123; int r = a.a[i][k]; for (int j = 0; j &lt; 2; ++j) c.a[i][j] = max(c.a[i][j], r + b.a[k][j]); &#125; return c; &#125; &#125; T[400005], g[100005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = g[idx[l]], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1 | 1] * T[o &lt;&lt; 1]; &#125; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o] = g[idx[l]], void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1 | 1] * T[o &lt;&lt; 1]; &#125; Matrix query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y) * query(o &lt;&lt; 1, l, mid, x, y); &#125; void dfs(int x, int fa) &#123; siz[x] = 1; ::fa[x] = fa; f[x][1] = a[x]; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; f[x][1] += f[y][0]; f[x][0] += max(f[y][0], f[y][1]); &#125; &#125; void dfs2(int x, int topf) &#123; idx[L[x] = ++num] = x; R[top[x] = topf] = num; g[x].a[0][1] = a[x]; g[x].a[1][1] = -INF; if (!son[x]) return; dfs2(son[x], topf); for (int y : G[x]) if (y != son[x] &amp;&amp; y != fa[x]) &#123; dfs2(y, y); g[x].a[0][1] += f[y][0]; g[x].a[0][0] += max(f[y][0], f[y][1]); &#125; g[x].a[1][0] = g[x].a[0][0]; &#125; void update(int x, int k) &#123; g[x].a[0][1] += k - a[x]; a[x] = k; while (x) &#123; int y = top[x]; Matrix lst = query(1, 1, n, L[y], R[y]); update(1, 1, n, L[x]); Matrix now = query(1, 1, n, L[y], R[y]); x = fa[y]; g[x].a[0][0] += max(now.a[0][0], now.a[0][1]) - max(lst.a[0][0], lst.a[0][1]); g[x].a[1][0] = g[x].a[0][0]; g[x].a[0][1] += now.a[0][0] - lst.a[0][0]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); dfs2(1, 1); build(1, 1, n); while (m--) &#123; int x, k; scanf(\"%d%d\", &amp;x, &amp;k); update(x, k); Matrix ans = query(1, 1, n, L[1], R[1]); printf(\"%d\\n\", max(ans.a[0][0], ans.a[0][1])); &#125; return 0; &#125; 自动机上 DP 难度较大。在学习之前，推荐学习一些自动机的知识（而且不难）。即使是 DP 套 DP，从自动机的角度理解也是有益的，甚至是最好理解的。 KMP 自动机上 DP [CF1163D] Mysterious Code. 找一个模式串在字符串中的出现次数，而看到可以在 * 上填任意一个字母又是经典 DP 问题。对 s,ts,ts,t 建出 KMP 自动机，设 f(i,j,k)f(i,j,k)f(i,j,k) 考虑到 ccc 的第 iii 位，此时在 sss 的 KMP 自动机的节点 jjj，ttt 的 KMP 自动机的节点 kkk 的最大答案。采用刷表法转移，模式串 SSS 在转移到节点 ∣S∣|S|∣S∣ 时有贡献。初始 f(0,0,0)=0f(0,0,0)=0f(0,0,0)=0，转移 f(i+1,trsj,ci+1,trtk,ci+1)=max⁡{f(i,j,k)+w}f(i+1,trs_{j,c_{i+1}},trt_{k,c_{i+1}})=\\max\\{f(i,j,k)+w\\}f(i+1,trsj,ci+1​​,trtk,ci+1​​)=max{f(i,j,k)+w}，目标 max⁡{f(n,j,k)}\\max\\{f(n,j,k)\\}max{f(n,j,k)}。 查看代码 #include &lt;bits/stdc++.h> #define rep(i, l, r) for (int i = l; i &lt;= r; ++i) using namespace std; int n, ls, lt, nxts[55], nxtt[55], trs[55][26], trt[55][26]; char a[1005], s[55], t[55]; int f[1005][55][55]; void KMP(char *s, int len, int *nxt, int tr[][26]) &#123; for (int i = 2, p = 0; i &lt;= len; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt[p]; if (s[i] == s[p + 1]) ++p; nxt[i] = p; &#125; rep(i, 0, len) rep(j, 0, 25) &#123; if (i &lt; len &amp;&amp; s[i + 1] == j + 'a') tr[i][j] = i + 1; else if (i) tr[i][j] = tr[nxt[i]][j]; &#125; &#125; void ckmax(int &amp;x, int t) &#123; if (x &lt; t) x = t; &#125; int main(void) &#123; scanf(\"%s%s%s\", a + 1, s + 1, t + 1); n = strlen(a + 1); ls = strlen(s + 1); lt = strlen(t + 1); KMP(s, ls, nxts, trs); KMP(t, lt, nxtt, trt); memset(f, 0xbf, sizeof f); f[0][0][0] = 0; rep(i, 0, n - 1) rep(j, 0, ls) rep(k, 0, lt) rep(p, 0, 25) if (a[i + 1] == '*' || a[i + 1] == p + 'a') &#123; int w = 0; if (trs[j][p] == ls) ++w; if (trt[k][p] == lt) --w; ckmax(f[i + 1][trs[j][p]][trt[k][p]], f[i][j][k] + w); &#125; int ans = -1e9; rep(i, 0, ls) rep(j, 0, lt) ans = max(ans, f[n][i][j]); return printf(\"%d\\n\", ans), 0; &#125; DP 套 DP 本质上就是内层 DP 的结果作为外层 DP 的状态，内层压的东西一般可以看成一个 bool 数组，表示外层的状态是否能够取到。这样状态数可能很多，所以往往需要以实际搜出来的结果为准。 [TJOI2018] 游园会。求长度为 nnn，字符集为 N,O,I\\text{N,O,I}N,O,I，且不能出现子串 NOI\\text{NOI}NOI，与给定字符串 SSS 的 LCS 为 lenlenlen（需要求出所有的 lenlenlen 对应的答案）的长度。n≤1000,∣S∣≤15n\\le 1000, |S|\\le 15n≤1000,∣S∣≤15。 LCS 是什么？像这样： LCSx,y={LCSx−1,y−1+1,Ax=By,max⁡{LCSx−1,y,LCSx,y−1},Ax≠By.\\text{LCS}_{x,y}= \\begin{cases} \\text{LCS}_{x-1,y-1}+1&amp;,A_x=B_y,\\\\ \\max\\{\\text{LCS}_{x-1,y},\\text{LCS}_{x,y-1}\\}&amp;,A_x\\neq B_y.\\\\ \\end{cases} LCSx,y​={LCSx−1,y−1​+1max{LCSx−1,y​,LCSx,y−1​}​,Ax​=By​,,Ax​=By​.​ 我们对 LCS 取一遍前缀最大值。把这个 LCS 的 DP 数组作为状态压进 DP（当其中一维固定时，LCS 数组的前缀最大值差分后可以得到一个 01 序列，状压后就可以压进去）。这相当于自动机上的一个点，枚举出满足不出现子串 NOI 的字符作为自动机的转移，计算出转移到的自动机上的点并更新方案数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, k, ans[20], a[20], b[20]; // LCS(i, ...) char s[20]; int f[2][35005][3]; // 考虑到字符串的第 i 位，当前 \"NOI\" 子串的长度为 k void decode(int *a, int ret) &#123; for (int i = 0; i &lt; k; ++i) a[i + 1] = (ret >> i &amp; 1) + a[i]; &#125; int encode(int *a) &#123; int ret = 0; for (int i = 0; i &lt; k; ++i) ret |= (a[i + 1] - a[i]) &lt;&lt; i; return ret; &#125; void dp(int now, int t, int p, char c, int w) &#123; decode(a, t); for (int i = 1; i &lt;= k; ++i) b[i] = max(&#123;b[i - 1], a[i], a[i - 1] + (c == s[i])&#125;); t = encode(b); f[now][t][p] = (f[now][t][p] + w) % P; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;k, s + 1); f[0][0][0] = 1; for (int i = 0; i &lt; n; ++i) &#123; memset(f[i - 1 &amp; 1], 0, sizeof(f[i - 1 &amp; 1])); for (int j = 0; j &lt; 1 &lt;&lt; k; ++j) &#123; if (f[i &amp; 1][j][0]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][0]); dp(i - 1 &amp; 1, j, 0, 'O', f[i &amp; 1][j][0]); dp(i - 1 &amp; 1, j, 0, 'I', f[i &amp; 1][j][0]); &#125; if (f[i &amp; 1][j][1]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][1]); dp(i - 1 &amp; 1, j, 2, 'O', f[i &amp; 1][j][1]); dp(i - 1 &amp; 1, j, 0, 'I', f[i &amp; 1][j][1]); &#125; if (f[i &amp; 1][j][2]) &#123; dp(i - 1 &amp; 1, j, 1, 'N', f[i &amp; 1][j][2]); dp(i - 1 &amp; 1, j, 0, 'O', f[i &amp; 1][j][2]); &#125; &#125; &#125; for (int i = 0; i &lt; 1 &lt;&lt; k; ++i) for (int j = 0; j &lt; 3; ++j) &#123; int &amp;x = ans[__builtin_popcount(i)]; x = (x + f[n &amp; 1][i][j]) % P; &#125; for (int i = 0; i &lt;= k; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; 可以发现 DP 套 DP 就是在一个 DP 自动机上进行 DP。其有一些技巧，请参考 Problemset。 Problemset 前面的题主要是单个知识点为主的模型，后面会出现超级大杂题。 背包问题 很有意思！后面有些题相当麻烦。 [HNOI2007] 梦幻岛宝珠 Portal. 考虑对 2b2^b2b 中 bbb 相同的物品进行分层 DP，设 f(i,j)f(i,j)f(i,j) 表示考虑到 2i2^i2i 的物品，恰好剩余 j×2ij\\times 2^ij×2i 的体积时能够取得的最大价值。同层的转移直接使用 01 背包，从高层开始转移，不同层则是 f(i−1,j×2+si−1)←f(i,j)f(i-1,j\\times 2+s_{i-1})\\leftarrow f(i,j)f(i−1,j×2+si−1​)←f(i,j)，其中 si−1s_{i-1}si−1​ 代表 WWW 二进制下的第 i−1i-1i−1 位。 查看代码 #include &lt;bits/stdc++.h> using namespace std; void ckmax(int &amp;a, int b) &#123; if (a &lt; b) a = b; &#125; int n, W, t; int f[35][1005], s[35]; int w[105], v[105]; vector&lt;int> a[35]; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;W) == 2 &amp;&amp; n != -1) &#123; memset(f, 0xbf, sizeof(f)); memset(s, 0, sizeof(s)); memset(a, 0, sizeof(a)); for (int j = 0; j &lt;= 30; ++j) if ((W >> j) &amp; 1) s[t = j] = 1; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", w + i, v + i); int b = 0; while (w[i] % 2 == 0) w[i] >>= 1, ++b; a[b].emplace_back(i); &#125; int ans = 0; for (int i = t; i >= 0; --i) &#123; f[i][s[i]] = max(f[i][s[i]], 0); for (auto k : a[i]) for (int j = w[k]; j &lt;= 1000; ++j) ckmax(f[i][j - w[k]], f[i][j] + v[k]); if (i > 0) &#123; for (int j = 0; j &lt;= 1000; ++j) ckmax(f[i - 1][min(1000, j * 2 + s[i - 1])], f[i][j]); &#125; else &#123; for (int j = 0; j &lt;= 1000; ++j) ckmax(ans, f[i][j]); &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [Luogu P8564] ρars/ey Portal. 树形背包。在背包进行完之后，要统计删除当前子树的代价。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, v[5005], siz[5005]; i64 f[5005][5005]; // x 为根，删除 i 个点 vector&lt;int> G[5005]; void dfs(int x, int fa) &#123; siz[x] = 1; f[x][0] = 0; int s = 0; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); s += siz[y]; for (int i = s - 1; i >= 0; --i) for (int j = min(i, siz[y] - 1); j >= max(1, i - siz[x]); --j) f[x][i] = min(f[x][i], f[x][i - j] + f[y][j]); siz[x] += siz[y]; &#125; for (int i = 0; i &lt; siz[x] - 1; ++i) f[x][siz[x] - 1] = min(f[x][siz[x] - 1], f[x][i] + v[siz[x] - i]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); memset(f, 0x3f, sizeof(f)); for (int i = 2; i &lt;= n; ++i) scanf(\"%d\", v + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); printf(\"%lld\\n\", f[1][n - 1]); return 0; &#125; [十二省联考 2019] 皮配 Portal. 考虑 K=0K=0K=0 怎么做。分别考虑划分两种特征，两次背包分别对工具箱和螺丝进行 DP 即可。 发现 KKK 很小，考虑针对它设计状态。对于不是这 KKK 个没事找事的螺丝，前面的 DP 做法依然成立。然后再考虑这些没事找事的。 设 f(i,j,k)f(i,j,k)f(i,j,k) 代表考虑前 iii 个物品，普通螺钉的重量为 jjj，三角螺纹的重量为 kkk。需要枚举当前的选的东西是什么，因此再记一个 ggg 表示自攻方螺钉。滚掉 iii 这一维，所有状态都是可以转移的，考虑用这种方式处理没事找事的螺丝，时间复杂度为 O(k2wM)O(k^2 w M)O(k2wM)。 然后枚举体积，进行背包合并即可。 查看代码 #include &lt;bits/stdc++.h> #define mem(x, v) memset(x, v, sizeof x) using namespace std; const int P = 998244353; inline void add(int &amp;x, int t) &#123; x = (x + t) % P; &#125; int n, c, C0, C1, D0, D1; int b[2505], w[2505], ban[2505], vis[2505]; int f[2505], g[2505]; // 普通 / 三角 为 i 的方案数 int F[2505][2505], G[2505][2505]; int siz[2505]; void solve(void) &#123; mem(siz, 0); mem(vis, 0); mem(ban, -1); cin >> n >> c >> C0 >> C1 >> D0 >> D1; int ALL = 0; for (int i = 1; i &lt;= n; ++i) cin >> b[i] >> w[i], siz[b[i]] += w[i], ALL += w[i]; int K; cin >> K; for (int x; K--; ) cin >> x, cin >> ban[x], vis[b[x]] = 1; mem(f, 0); f[0] = 1; for (int i = 1; i &lt;= c; ++i) if (!vis[i] &amp;&amp; siz[i]) for (int j = C0; j >= siz[i]; --j) add(f[j], f[j - siz[i]]); for (int i = 1; i &lt;= C0; ++i) add(f[i], f[i - 1]); mem(g, 0); g[0] = 1; for (int i = 1; i &lt;= n; ++i) if (ban[i] == -1) for (int j = D0; j >= w[i]; --j) add(g[j], g[j - w[i]]); for (int i = 1; i &lt;= D0; ++i) add(g[i], g[i - 1]); mem(F, 0); mem(G, 0); F[0][0] = 1; int Cs = 0, Ds = 0; for (int op = 1; op &lt;= c; ++op) if (vis[op]) &#123; Cs += siz[op]; Cs = min(Cs, C0); for (int i = 0; i &lt;= Cs; ++i) for (int j = 0; j &lt;= Ds; ++j) G[i][j] = F[i][j]; for (int x = 1; x &lt;= n; ++x) if (b[x] == op &amp;&amp; ban[x] != -1) &#123; Ds += w[x]; Ds = min(Ds, D0); // 0 不是 普通三角 // 1 不是 普通方 // 2 不是 自攻三角 // 3 不是 自攻方 // F 普通三角 G 自攻方 if (ban[x] == 1) &#123; for (int i = 0; i &lt;= Cs; ++i) &#123; for (int j = Ds; j >= w[x]; --j) F[i][j] = F[i][j - w[x]]; for (int j = w[x] - 1; j >= 0; --j) F[i][j] = 0; &#125; &#125; if (ban[x] >= 2) &#123; for (int i = 0; i &lt;= Cs; ++i) for (int j = Ds; j >= w[x]; --j) add(F[i][j], F[i][j - w[x]]); &#125; if (ban[x] == 3) &#123; for (int i = 0; i &lt;= Cs; ++i) &#123; for (int j = Ds; j >= w[x]; --j) G[i][j] = G[i][j - w[x]]; for (int j = w[x] - 1; j >= 0; --j) G[i][j] = 0; &#125; &#125; if (ban[x] &lt;= 1) &#123; for (int i = 0; i &lt;= Cs; ++i) for (int j = Ds; j >= w[x]; --j) add(G[i][j], G[i][j - w[x]]); &#125; &#125; for (int j = 0; j &lt;= Ds; ++j) &#123; for (int i = Cs; i >= siz[op]; --i) F[i][j] = F[i - siz[op]][j]; for (int i = siz[op] - 1; i >= 0; --i) F[i][j] = 0; &#125; for (int i = 0; i &lt;= Cs; ++i) for (int j = 0; j &lt;= Ds; ++j) add(F[i][j], G[i][j]); &#125; int ans = 0; for (int i = 0; i &lt;= Cs; ++i) for (int j = 0; j &lt;= Ds; ++j) &#123; int l1 = max(0, ALL - C1 - i), r1 = C0 - i; if (l1 > r1) continue; int l2 = max(0, ALL - D1 - j), r2 = D0 - j; if (l2 > r2) continue; int v1 = f[r1] - (l1 ? f[l1 - 1] : 0), v2 = g[r2] - (l2 ? g[l2 - 1] : 0); add(ans, 1ll * v1 * v2 % P * F[i][j] % P); &#125; cout &lt;&lt; (ans + P) % P &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(0); int T; cin >> T; while (T--) solve(); return 0; &#125; 区间 DP 也可以变得相当复杂。 [CF1572C] Paint Portal. 设 f(i,j)f(i,j)f(i,j) 代表将 [i,j][i,j][i,j] 染成 cjc_jcj​ 的代价（想一想这样为什么是正确的），当 ck=cjc_k=c_jck​=cj​ 时有 f(i,j)=f(i,k)+f(k+1,j)f(i,j)=f(i,k)+f(k+1,j)f(i,j)=f(i,k)+f(k+1,j)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, p[3005], pre[3005]; int a[3005], f[3005][3005]; void solve(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; p[i] = pre[i] = 0; for (int j = i; j &lt;= n; ++j) f[i][j] = 1e9; &#125; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); f[i][i] = 0; if (p[a[i]]) pre[i] = p[a[i]]; p[a[i]] = i; &#125; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = min(f[i][j - 1], f[i + 1][j]) + 1; for (int k = pre[j]; k >= i; k = pre[k]) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); &#125; printf(\"%d\\n\", f[1][n]); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [CERC2014] Outer space invaders Portal. 在时间上进行区间 DP，合并时要找到这一时间段中距离最远的外星人，枚举它在哪一个时间点被摧毁。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, C[605]; int f[605][605]; struct enemy &#123; int a, b, d; void rd(void) &#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;d); C[++m] = a; C[++m] = b; &#125; &#125; a[305]; void solve(void) &#123; scanf(\"%d\", &amp;n); m = 0; for (int i = 1; i &lt;= n; ++i) a[i].rd(); sort(C + 1, C + m + 1); m = unique(C + 1, C + m + 1) - (C + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i].a = lower_bound(C + 1, C + m + 1, a[i].a) - C; a[i].b = lower_bound(C + 1, C + m + 1, a[i].b) - C; &#125; for (int i = 1; i &lt;= m; ++i) fill(f[i] + 1, f[i] + m + 1, 0); for (int len = 2; len &lt;= m; ++len) for (int i = 1; i &lt;= m - len + 1; ++i) &#123; int j = i + len - 1, mx = 0, t = -1; for (int k = 1; k &lt;= n; ++k) if (a[k].a >= i &amp;&amp; a[k].b &lt;= j &amp;&amp; mx &lt; a[k].d) mx = a[t = k].d; if (t == -1) continue; f[i][j] = 1e9; for (int k = a[t].a; k &lt;= a[t].b; ++k) f[i][j] = min(f[i][j], f[i][k - 1] + f[k + 1][j] + mx); &#125; printf(\"%d\\n\", f[1][m]); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; 树形 DP 是基础 DP 中比较复杂的一类。 [HEOI2013] SAO Portal.给定一张树状结构的有向图，求其拓扑序的数量。 设 f(x,i)f(x,i)f(x,i) 代表考虑 xxx 的子树，考虑 iii 个节点的拓扑序数量，初始时 f(x,1)=1f(x,1)=1f(x,1)=1，目标为 ∑i=1nf(1,i)\\sum_{i=1}^n f(1,i)∑i=1n​f(1,i)。 以 yyy 在 xxx 前面的转移为例。枚举 j∈[1,siz[y]]j\\in[1,siz[y]]j∈[1,siz[y]] 为在 yyy 中选取的在 xxx 前的个数，转移方程为： f(x,i+j)⟵+∑k=1jf(x,i)×f(y,k)×(i+j−1j)×(siz[x]−i+siz[y]−jsiz[x]−i)f(x,i+j)\\stackrel{+}{\\longleftarrow} \\sum_{k=1}^{j} f(x,i)\\times f(y,k)\\times \\binom{i+j-1}{j}\\times \\binom{siz[x]-i+siz[y]-j}{siz[x]-i} f(x,i+j)⟵+​k=1∑j​f(x,i)×f(y,k)×(ji+j−1​)×(siz[x]−isiz[x]−i+siz[y]−j​) 其意义不难理解，后面两个组合数分别是在 iii 的后代中选择 jjj 个位置、没有选择的随便排。处理一个前缀和就可以快速转移了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000007; int n, siz[1005]; i64 C[1005][1005], f[1005][1005], g[1005]; vector&lt;pair&lt;int, bool>> G[1005]; inline void addedge(int u, int v, bool w) &#123; G[u].emplace_back(make_pair(v, w)); G[v].emplace_back(make_pair(u, !w)); &#125; void add(i64 &amp;x, int t) &#123; x = (x + t) % P; &#125; void dfs(int x, int fa) &#123; siz[x] = 1; f[x][1] = 1; for (auto [y, w] : G[x]) if (y != fa) &#123; dfs(y, x); memcpy(g, f[x], sizeof(g)); memset(f[x], 0, sizeof(f[x])); if (w) &#123; for (int i = 1; i &lt;= siz[x]; ++i) for (int j = 0; j &lt; siz[y]; ++j) add(f[x][i + j], g[i] * C[i + j - 1][j] % P * C[siz[x] + siz[y] - i - j][siz[x] - i] % P * (f[y][siz[y]] - f[y][j] + P) % P); &#125; else &#123; for (int i = 1; i &lt;= siz[x]; ++i) for (int j = 1; j &lt;= siz[y]; ++j) add(f[x][i + j], g[i] * C[i + j - 1][j] % P * C[siz[x] + siz[y] - i - j][siz[x] - i] % P * f[y][j] % P); &#125; siz[x] += siz[y]; &#125; for (int i = 1; i &lt;= siz[x]; ++i) f[x][i] = (f[x][i] + f[x][i - 1]) % P; &#125; void solve(void) &#123; scanf(\"%d\", &amp;n); memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; ++i) G[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int x, y; char c; scanf(\"%d %c %d\", &amp;x, &amp;c, &amp;y); ++x; ++y; addedge(x, y, c == '&lt;'); // x -> y, y &lt;- x &#125; dfs(1, 0); printf(\"%d\\n\", f[1][n]); &#125; int main(void) &#123; for (int i = 0; i &lt;= 1000; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [CF1626E] Black and White Tree Portal. 一个点能达到一个黑点，要么它自己是黑点，要么它的儿子是黑点，要么它儿子能到黑点且它儿子的子树中有至少两个黑点（这样如果儿子走黑点时第一步选择一号黑点，那么当前节点就可以选择二号黑点走到儿子）。于是换根 DP 拍上去即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; int n, a[300005], f[300005], g[300005], sz[300005]; vector&lt;int> G[300005]; void dfs(int x, int fa) &#123; if (sz[x] = a[x]) f[x] = 1; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); sz[x] += sz[y]; if (a[y]) f[x] = 1; if (f[y] &amp;&amp; sz[y] > 1) f[x] = 1; &#125; &#125; void dfs2(int x, int fa) &#123; if (a[fa]) g[x] = 1; g[x] |= f[x]; for (int y : G[x]) if (y != fa) &#123; if (g[x] &amp;&amp; sz[1] - sz[y] > 1) g[y] = 1; dfs2(y, x); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); dfs2(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", g[i]); putchar('\\n'); return 0; &#125; 状压 DP 不是很难。 [BJWC2018] 最长上升子序列 Portal. 设 f(i,j)f(i,j)f(i,j) 代表考虑长度为 iii 的序列，LIS DP 后的 fff 数组（取一遍前缀最大值）的差分状压后为 jjj 的方案数。转移也不难。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int P = 998244353; int poww(i64 a, int b) &#123; int res = 1; a %= P; for (; b; b >>= 1, a = a * a % P) if (b &amp; 1) res = res * a % P; return res; &#125; void add(int &amp;x, int t) &#123; x = (x + t) % P; &#125; int n; int f[2][134217728]; int main(void) &#123; scanf(\"%d\", &amp;n); if (n == 25) return puts(\"102117126\"), 0; if (n == 26) return puts(\"819818153\"), 0; if (n == 27) return puts(\"273498600\"), 0; if (n == 28) return puts(\"267588741\"), 0; --n; f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; 1 &lt;&lt; i; ++j) f[i &amp; 1][j] = 0; for (int j = 0; j &lt; 1 &lt;&lt; i - 1; ++j) &#123; int t, pos = -1; for (int k = i - 1; k >= 0; --k) &#123; // 插入到第 k 位 t = (j >> k &lt;&lt; k + 1) | (1 &lt;&lt; k) | (j &amp; (1 &lt;&lt; k) - 1); if (j &amp; 1 &lt;&lt; k) pos = k; if (pos != -1) t ^= 1 &lt;&lt; pos + 1; add(f[i &amp; 1][t], f[i - 1 &amp; 1][j]); &#125; add(f[i &amp; 1][j &lt;&lt; 1], f[i - 1 &amp; 1][j]); // 插在第 0 个位置 &#125; &#125; i64 fac = 1, ans = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) ans = (ans + 1ll * f[n &amp; 1][i] * (__builtin_popcount(i) + 1)) % P; for (int i = 1; i &lt;= n + 1; ++i) fac = fac * i % P; ans = ans * poww(fac, P - 2) % P; printf(\"%d\\n\", ans); return 0; &#125; [九省联考 2018] 一双木棋 chess Portal. 发现合法的放棋子状态不是很多，因此可以把它们先搜出来，然后直接 DP。由于选手足够聪明，所以 DP 要倒序进行。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int B = 233, P = 998244353; int n, m, tot, cnt[15]; int a[15][15], b[15][15]; int H(void) &#123; int res = 0; for (int i = 1; i &lt;= m; ++i) res = (1ll * res * B + cnt[i]) % P; return res; &#125; int id[200005], rev[200005]; int val[200005], f[2][200005]; int s[200005][15]; map&lt;int, int> h; void dfs(int x) &#123; if (x == m + 1) &#123; h[H()] = ++tot; for (int i = 1; i &lt;= m; ++i) &#123; val[tot] += cnt[i]; s[tot][i] = cnt[i]; &#125; return; &#125; for (int i = 0; i &lt;= cnt[x - 1]; ++i) cnt[x] = i, dfs(x + 1); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[i][j]); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;b[i][j]); cnt[0] = n; dfs(1); for (int i = 1; i &lt;= tot; ++i) id[i] = i; sort(id + 1, id + tot + 1, [](int x, int y) &#123; return val[x] > val[y]; &#125;); for (int i = 1; i &lt;= tot; ++i) rev[id[i]] = i; memset(f[0], -0x3f, sizeof(f[0])); memset(f[1], 0x3f, sizeof(f[1])); // 1: 对手落子 0: 自己落子 if ((n * m) &amp; 1) f[1][1] = 0; else f[0][1] = 0; for (int i = 1; i &lt; tot; ++i) &#123; int x = id[i], k, o, hash; for (int p = 1; p &lt;= m; ++p) &#123; for (int q = 1; q &lt;= m; ++q) &#123; cnt[q] = s[x][q]; if (q == p) o = cnt[q], --cnt[q]; &#125; if (h.find(hash = H()) == h.end()) continue; k = rev[h[hash]]; if (val[x] &amp; 1) f[0][k] = max(f[0][k], f[1][i] + a[o][p]); else f[1][k] = min(f[1][k], f[0][i] - b[o][p]); &#125; &#125; printf(\"%d\\n\", f[0][tot]); return 0; &#125; [PKUSC2018] 最大前缀和 Portal. 考虑最大前缀和的特点。如果一个数作为最大前缀和的末尾，那么它后面的序列单独拎出来，没有一个前缀非负。根据此 DP 即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353, N = 1 &lt;&lt; 20; int n; int s[N], f[N], g[N]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;s[1 &lt;&lt; i]), f[1 &lt;&lt; i] = 1; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) s[i] = s[i ^ (i &amp; -i)] + s[i &amp; -i]; for (int i = g[0] = 1; i &lt; 1 &lt;&lt; n; ++i) if (s[i] >= 0) &#123; for (int j = 0; j &lt; n; ++j) if (!(i >> j &amp; 1)) f[1 &lt;&lt; j | i] = (f[i] + f[1 &lt;&lt; j | i]) % P; &#125; else &#123; for (int j = 0; j &lt; n; ++j) if (i >> j &amp; 1) g[i] = (g[i] + g[i ^ (1 &lt;&lt; j)]) % P; &#125; int ans = 0; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) ans = (ans + 1ll * s[i] * f[i] % P * g[(1 &lt;&lt; n) - 1 ^ i] % P) % P; return printf(\"%d\\n\", (ans + P) % P), 0; &#125; [省选联考 2021 A/B 卷] 滚榜 Portal. 显然是可以贪心的，贪心策略跟上一个滚出来的队伍有关。设 fS,i,jf_{S,i,j}fS,i,j​ 表示滚出来的队伍集合是 SSS，上一个滚出来的是 iii，总共消耗的题目是 jjj。转移很容易。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[15], t = 14, cnt[1 &lt;&lt; 13], p[1 &lt;&lt; 13]; i64 f[1 &lt;&lt; 13][13][505]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); a[n] = -1; t = n; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d\", a + i); p[1 &lt;&lt; i] = i; if (a[i] > a[t]) t = i; &#125; for (int i = 0; i &lt; n; ++i) &#123; int tar = n * (a[t] - a[i] + (t &lt; i)); if (tar &lt;= m) f[1 &lt;&lt; i][i][tar] = 1; &#125; cnt[1] = 1; for (int i = 2; i &lt; 1 &lt;&lt; n; ++i) cnt[i] = cnt[i >> 1] + (i &amp; 1); for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) &#123; for (int s = i; s; s -= (s &amp; -s)) for (int k = 0; k &lt;= m; ++k) &#123; int j = p[s &amp; -s]; for (int l = 0; l &lt; n; ++l) if (!(i >> l &amp; 1)) &#123; int tar = k + (n - cnt[i]) * max(0, a[j] - a[l] + (j &lt; l)); if (tar &lt;= m) f[1 &lt;&lt; l | i][l][tar] += f[i][j][k]; &#125; &#125; &#125; i64 ans = 0; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= m; ++j) ans += f[(1 &lt;&lt; n) - 1][i][j]; return printf(\"%lld\\n\", ans), 0; &#125; 计数 DP 实际上考的最多的是这玩意儿。 [SDOI2019] 移动金币 Portal. 发现这是一个阶梯博弈问题，将 n−mn-mn−m 个石子划给 m+1m+1m+1 个阶梯。 我们求先手必败的方案数，然后用总方案数减去。先手必败要让偶数编号的阶梯异或和为 000（地面为 111）。设 fi,jf_{i,j}fi,j​ 为考虑到最终异或和的第 iii 位，还剩 jjj 个石子没有放的方案数。因为这一二进制位为 111 的个数为偶数才能保证异或和为 000，所以 fi,j=∑2∣kfi+1,j−2ik(m+12k)f_{i,j}=\\sum_{2\\mid k}f_{i+1,j-2^i k}\\binom{\\frac{m+1}{2}}{k}fi,j​=∑2∣k​fi+1,j−2ik​(k2m+1​​)。剩余的石子可以插板放入奇数的阶梯位置。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int P = 1000000009; i64 poww(i64 a, int b) &#123; int res = 1; for (; b; b >>= 1, a = a * a % P) if (b &amp; 1) res = res * a % P; return res; &#125; int n, m, ans; int f[20][150005]; i64 fac[150005]; i64 C(int n, int m) &#123; return 1ll * fac[n] * poww(1ll * fac[m] * fac[n - m] % P, P - 2) % P; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = fac[0] = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % P; int t = 1; while ((1 &lt;&lt; t) &lt;= n) ++t; f[t][n - m] = 1; int even = (m + 1) / 2, odd = m + 1 - even; for (int i = t - 1; i >= 0; --i) for (int j = 0; j &lt;= n - m; ++j) &#123; if (!f[i + 1][j]) continue; for (int k = 0; k &lt;= (m + 1) / 2 &amp;&amp; k * (1 &lt;&lt; i) &lt;= j; k += 2) f[i][j - k * (1 &lt;&lt; i)] = (f[i][j - k * (1 &lt;&lt; i)] + f[i + 1][j] * C(even, k)) % P; &#125; i64 ans = 0; for (int i = 0; i &lt;= n - m; ++i) ans = (ans + f[0][i] * C(i + odd - 1, i)) % P; printf(\"%lld\\n\", (C(n, m) - ans + P) % P); return 0; &#125; 数位 DP 实际上发现都是模板。有些会与字符串算法相结合。 【SWTR-02】Magical Gates Portal. 对 nnn 的二进制位从高到低枚举，并令所有枚举到的 111 位都填 111。如果当前位置是 111，也可以这一位不填 111，后面的位随便，这样就可以计算出表示二进制下有 iii 个 111 的数的个数的 f(i)f(i)f(i)，就可以直接统计。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int P; int poww(i64 a, int b) &#123; int res = 1; for (; b; b >>= 1, a = a * a % P) if (b &amp; 1) res = res * a % P; return res; &#125; int C[3505][3505], CC[3505][3505]; string l, r; int p[1005], a[3505], tot; void change(string &amp;s, bool f) &#123; memset(a, 0, sizeof(a)); int len = s.length() - 1; tot = 0; for (int i = len; i >= 0; --i) p[i] = s[len - i] - '0'; if (f) &#123; --p[0]; for (int pos = 0; p[pos] &lt; 0; ++pos) --p[pos + 1], p[pos] += 10; if (!p[len]) --len; &#125; while (len >= 0) &#123; int res = 0; for (int i = len; i >= 0; --i) &#123; res = res * 10 + p[i]; p[i] = res / 2; res %= 2; &#125; a[tot++] = res; if (!p[len]) --len; &#125; --tot; &#125; i64 f[3505], g[3505]; void solve(void) &#123; memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); cin >> l >> r; change(r, 0); int t = 0; for (int i = tot; i >= 0; --i) if (a[i]) &#123; for (int j = 1; j &lt;= i; ++j) &#123; // 这一位不填 1，后面的随便填 f[j + t] = (f[j + t] + C[i][j]) % P; g[j + t] = (g[j + t] + CC[i][j]) % (P - 1); &#125; ++f[++t]; ++g[t]; // 这一位填 1 &#125; change(l, 1); t = 0; for (int i = tot; i >= 0; --i) if (a[i]) &#123; for (int j = 1; j &lt;= i; ++j) &#123; f[j + t] = (f[j + t] - C[i][j]) % P; g[j + t] = (g[j + t] - CC[i][j]) % (P - 1); &#125; --f[++t]; --g[t]; &#125; i64 ans1 = 0, ans2 = 1; for (int i = 1; i &lt;= 3400; ++i) &#123; f[i] = (f[i] % P + P) % P; g[i] = (g[i] % (P - 1) + P - 1) % (P - 1); ans1 = (ans1 + i * f[i]) % P; ans2 = ans2 * poww(i, g[i]) % P; &#125; printf(\"%lld %lld\\n\", ans1, ans2); &#125; int main(void) &#123; int T, n; scanf(\"%d%d%d\", &amp;T, &amp;P, &amp;n); for (int i = 0; i &lt;= 3500; ++i) for (int j = C[i][0] = CC[i][0] = 1; j &lt;= i; ++j) &#123; C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; CC[i][j] = (CC[i - 1][j] + CC[i - 1][j - 1]) % (P - 1); &#125; while (T--) solve(); return 0; &#125; [BalticOI 2013 Day1] Palindrome-Free Numbers Portal. 如果是非回文，那么只需要不出现长度为 222 或 333 的回文串即可（因为回文串两头缩减之后还是回文串），因此只需要记录前两位。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int num[20], len; i64 f[20][11][11][2][2]; i64 dp(int p, int p1, int p2, bool lim, bool st) &#123; if (p == 0) return 1; if (f[p][p1][p2][lim][st] != -1) return f[p][p1][p2][lim][st]; int mx = lim ? num[p] : 9; i64 res = 0; for (int i = 0; i &lt;= mx; ++i) if (i != p2 &amp;&amp; i != p1) &#123; if (st &amp;&amp; i == 0) res += dp(p - 1, 10, 10, lim &amp;&amp; i == mx, 1); else res += dp(p - 1, i, p1, lim &amp;&amp; i == mx, 0); &#125; return f[p][p1][p2][lim][st] = res; &#125; i64 calc(i64 n) &#123; memset(f, 0xff, sizeof(f)); len = 0; while (n) num[++len] = n % 10, n /= 10; return dp(len, 10, 10, 1, 1); &#125; int main(void) &#123; i64 l, r; cin >> l >> r; cout &lt;&lt; calc(r) - calc(l - 1) &lt;&lt; \"\\n\"; return 0; &#125; DP 套 DP 部分题目相当麻烦。 [SDOI/SXOI2022] 小 N 的独立集 Portal.给定一棵 n(n≤1000)n(n\\le 1000)n(n≤1000) 个节点的树，每个节点的权值可以随意在 1∼k(k≤5)1\\sim k(k\\le 5)1∼k(k≤5) 中给定，问答案为 1∼nk1\\sim nk1∼nk 的最大权独立集问题的树各有多少棵。 最大独立集问题非常经典，设 fx,0/1f_{x,0/1}fx,0/1​ 代表节点 xxx 的子树中是否选择 xxx 的最大答案。把 fff 的值压进去作为 DP 的状态，设 gx,v0,v1g_{x,v0,v1}gx,v0,v1​ 代表 xxx 的子树中 fx,0=v0,fx,1=v1f_{x,0}=v0,f_{x,1}=v1fx,0​=v0,fx,1​=v1 的方案数，但是这样状态数炸了！ 想办法简化状态数。设 fx,0/1f_{x,0/1}fx,0/1​ 代表是否强制不选时的最大答案，但这样发现 0≤fx,0−fx,1≤valx0\\le f_{x,0}-f_{x,1}\\le val_{x}0≤fx,0​−fx,1​≤valx​，这样我们就可以不用保存 fx,0f_{x,0}fx,0​，而是只记录它们的差值 ddd，这样状态就可以记录为 gx,v,dg_{x,v,d}gx,v,d​ 代表 fx,0f_{x,0}fx,0​ 的值为 v+dv+dv+d，fx,1f_{x,1}fx,1​ 的值为 vvv。 初始 gx,0,i=1(1≤i≤k)g_{x,0,i}=1(1\\le i\\le k)gx,0,i​=1(1≤i≤k)，外层 DP 的转移是一个树形背包的形式。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; void add(int &amp;a, int b) &#123; a += b; if (a >= P) a -= P; &#125; int n, k, siz[1005]; vector&lt;int> G[1005]; int g[1005][5005][6], f[5005][6]; void dfs(int x, int fa) &#123; siz[x] = 1; for (int i = 1; i &lt;= k; ++i) g[x][0][i] = 1; // 将自己设置为 1 ~ k 的方案数都为 1 for (int y : G[x]) if (y != fa) &#123; dfs(y, x); memset(f, 0, sizeof(f)); for (int i = 0; i &lt;= k * siz[x]; ++i) // dp[x][1] = i for (int j = 0; j &lt;= k; ++j) if (g[x][i][j]) // dp[x][0] = i + j for (int p = 0; p &lt;= k * siz[y]; ++p) // dp[y][1] = p for (int q = 0; q &lt;= k; ++q) if (g[y][p][q]) // dp[y][0] = p + q add(f[i + p + q][max(i + j + p, i + p + q) - (i + p + q)], 1ll * g[x][i][j] * g[y][p][q] % P); memcpy(g[x], f, sizeof(f)); siz[x] += siz[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n * k; ++i) &#123; int ans = 0; for (int j = 0; j &lt;= min(i, k); ++j) add(ans, g[1][i - j][j]); printf(\"%d\\n\", ans); &#125; return 0; &#125; 插入法 DP 一种特殊的状态设计方法。 [CEOI2016] kangaroo Portal. 相当于是构造一个排列，左右是 s,ts,ts,t，任意元素满足它左右两个都比它大或都比它小。 常规方法并不好处理，考虑一种以插入为转移的 DP。设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，将序列划分成 jjj 段的方案数。 一个数可以用来新增一个段，也可以用来合并段。如果它是 s,ts,ts,t 那么只能将它放到首尾。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, s, t; int f[2005][2005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;s, &amp;t); f[1][1] = 1; for (int i = 2; i &lt;= n; ++i) if (i != s &amp;&amp; i != t) &#123; for (int j = 1; j &lt;= i; ++j) &#123; int c = (i > s) + (i > t); f[i][j] = (1ll * j * f[i - 1][j + 1] + 1ll * (j - c) * f[i - 1][j - 1]) % P; &#125; &#125; else &#123; for (int j = 1; j &lt;= i; ++j) f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % P;; &#125; printf(\"%d\\n\", f[n][1]); return 0; &#125; [CF1515E] Phoenix and Computers Portal. 新增一段，方案数是 fi−1,j−1×jf_{i-1,j-1}\\times jfi−1,j−1​×j； 与原来段相连，可以贴着或者隔一个放，段的左右位置都可以； 合并段，中间有两个空或三个空可以合并。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, P; int f[405][405]; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;P); f[1][1] = 1; for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= i; ++j) &#123; add(f[i][j], 1ll * f[i - 1][j - 1] * j % P); add(f[i][j], 2ll * f[i - 1][j] * j % P); // 贴着 add(f[i][j], 2ll * f[i - 2][j] * j % P); // 隔着一个 add(f[i][j], 2ll * f[i - 2][j + 1] * j % P); // 两个中的任意一个 if (i >= 3) add(f[i][j], 1ll * f[i - 3][j + 1] * j % P); // 三个中间的那个 &#125; printf(\"%d\\n\", f[n][1]); return 0; &#125; [AT DP] 文字列 Portal. 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 种字符，有 jjj 组相邻的字符的方案数。 转移时枚举 jjj，当前字母分成的段数 kkk，打散原来的 lll 段字母。然后简单组合一下即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007, N = 262; inline void add(int &amp;x, int t) &#123; x = (x + t) % P; &#125; int a[30], n, m; int C[265][265], f[30][265]; int main(void) &#123; for (int i = 0; i &lt;= N; ++i) for (int j = C[i][0] = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; for (int i = 0; i &lt; 26; ++i) cin >> a[i]; f[0][max(0, a[0] - 1)] = 1; n = a[0]; for (int i = 1; i &lt; 26; ++i) &#123; if (!a[i]) continue; ++m; for (int j = 0; j &lt;= n; ++j) if (f[m - 1][j]) for (int k = 1; k &lt;= a[i]; ++k) for (int l = 0; l &lt;= min(j, k); ++l) &#123; int now = j - l + a[i] - k; add(f[m][now], 1ll * f[m - 1][j] * C[a[i] - 1][k - 1] % P * C[j][l] % P * C[n + 1 - j][k - l] % P); // 插板出分段数，选择 l 段打散，剩下随意插入 &#125; n += a[i]; &#125; printf(\"%d\\n\", f[m][0]); return 0; &#125; 综合应用 非常好玩！ [ABC262G] LIS with Stack Portal. 感觉像个 DP。考虑一个数要被放置，它需要在它顶上那个元素弹栈之后才可以被放入序列。如果要有贡献，需要限制它前面的最大值和它后面的最小值。很有合并的感觉！考虑区间 DP。设 f(i,j,mn,mx)f(i,j,mn,mx)f(i,j,mn,mx) 代表考虑 [i,j][i,j][i,j] 的数，放的最大值是 mxmxmx，最小值是 mnmnmn 的最大答案。可以选择删除 iii，不删除时枚举它顶上的元素 kkk（也可以是它自己），将区间拆分成两段并限制最值。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int a[55], f[55][55][55][55]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); for (int l = 1; l &lt;= a[i]; ++l) for (int r = a[i]; r &lt;= 50; ++r) f[i][i][l][r] = 1; &#125; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int mn = 1; mn &lt;= 50; ++mn) for (int mx = mn; mx &lt;= 50; ++mx) &#123; int &amp;dp = f[i][j][mn][mx]; dp = f[i + 1][j][mn][mx]; if (mn &lt;= a[i] &amp;&amp; a[i] &lt;= mx) &#123; for (int k = i; k &lt;= j; ++k) dp = max(dp, f[i + 1][k][mn][a[i]] + f[k + 1][j][a[i]][mx] + 1); &#125; &#125; &#125; printf(\"%d\\n\", f[1][n][1][50]); return 0; &#125; [CF115D] Unambiguous Arithmetic Expression Portal. 先将表达式标准化。设 fi,j,0/1f_{i,j,0/1}fi,j,0/1​ 代表考虑到第 iii 位，有 jjj 个左括号没有匹配，最后一个括号是左括号或右括号。转移时采用刷表法： fi,j,1f_{i,j,1}fi,j,1​ 可以转移到以下位置： fi+1,j+1,0f_{i+1,j+1,0}fi+1,j+1,0​，只需要新建一个左括号即可，不管当前位置是什么这样都是合法的，由于括号内不能是空的因此 i+1i+1i+1； fi,j−1,1f_{i,j-1,1}fi,j−1,1​，用一个右括号匹配； fi,j,0f_{i,j,0}fi,j,0​ 可以转移： 如果当前是个乘除号，那么转移不了； 是个加减号，可以选择在这个符号右边套一个左括号； 是数字，可以考虑用括号将数字包起来，或者跟一个左括号匹配。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000003; const int N = 2005; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; int n, m, f[2010][2010][2]; char a[2010], s[2010]; int main(void) &#123; scanf(\"%s\", a + 1); n = strlen(a + 1); for (int i = 1; i &lt;= n; ) &#123; if (a[i] == '+' || a[i] == '-') ++i, s[++m] = '+'; else if (a[i] == '*' || a[i] == '/') ++i, s[++m] = '*'; else &#123; s[++m] = '0'; while (i &lt;= n &amp;&amp; isdigit(a[i])) ++i; &#125; &#125; if (m == 1 &amp;&amp; s[1] == '0') return puts(\"1\"), 0; f[1][0][0] = 1; for (int i = 1; i &lt;= m + 1; ++i) &#123; for (int j = N - 1; j >= 0; --j) if (f[i][j][1]) &#123; add(f[i + 1][j + 1][0], f[i][j][1]); if (j) add(f[i][j - 1][1], f[i][j][1]); &#125; for (int j = 0; j &lt; N; ++j) if (f[i][j][0]) &#123; if (s[i] == '+') add(f[i + 1][j + 1][0], f[i][j][0]); if (s[i] == '0') add(f[i + 2][j + 1][0], f[i][j][0]); if (s[i] == '0' &amp;&amp; j) add(f[i + 1][j - 1][1], f[i][j][0]); &#125; &#125; printf(\"%d\\n\", f[m + 1][0][1]); return 0; &#125; [IOI2022] 鲶鱼塘 Portal. 画一画就发现长堤一定是单峰的。那么设 dpi,0/1dp_{i,0/1}dpi,0/1​ 代表第 iii 条鲶鱼通过左边 / 右边的限制可选时的最大重量，fif_{i}fi​ 代表现在长堤增的最大重量，gig_{i}gi​ 代表递减。可以从当前一列转移，也可以枚举这一列的鲇鱼然后下面的全部填上长堤。 查看代码 #include &lt;bits/stdc++.h> #include \"fish.h\" using namespace std; typedef long long i64; int x[300005], y[300005], w[300005]; i64 dp[300005][2], f[300005], g[300005]; // [][0] 代表上升 // f g 分别代表现在是增、减的最优值 vector&lt;int> v[300005]; // i 位置上的垒球 i64 max_weights(int n, int m, vector&lt;int> X, vector&lt;int> Y, vector&lt;int> W) &#123; for (int i = 0; i &lt; m; ++i) &#123; x[i + 1] = X[i] + 1, y[i + 1] = Y[i] + 1, w[i + 1] = W[i]; v[X[i] + 1].emplace_back(i + 1); &#125; for (int i = 1; i &lt;= n; ++i) &#123; sort(v[i].begin(), v[i].end(), [&amp;](int a, int b) &#123; return y[a] &lt; y[b]; &#125;); f[i] = g[i] = max(f[i - 1], g[i - 1]); int l1 = v[i - 1].size(), l2 = v[i].size(), c = l1; i64 mx = i >= 2 ? max(f[i - 2], g[i - 2]) : 0; if (i != 1) &#123; for (int j = l2 - 1; j >= 0; --j) &#123; // 从 y 坐标高开始 if (j &lt; l2 - 1) dp[v[i][j]][0] = dp[v[i][j + 1]][0] + w[v[i][j]]; // 同一列 while (c &amp;&amp; y[v[i - 1][c - 1]] > y[v[i][j]]) mx = max(mx, dp[v[i - 1][--c]][0]); dp[v[i][j]][0] = max(dp[v[i][j]][0], mx + w[v[i][j]]); f[i] = max(f[i], dp[v[i][j]][0]); &#125; &#125; c = 0; mx = f[i - 1]; if (i != n) &#123; for (int j = 0; j &lt; l2; ++j) &#123; if (j) dp[v[i][j]][1] = dp[v[i][j - 1]][1] + w[v[i][j]]; while (c &lt; l1 &amp;&amp; y[v[i - 1][c]] &lt; y[v[i][j]]) mx = max(mx, dp[v[i - 1][c++]][1]); dp[v[i][j]][1] = max(dp[v[i][j]][1], mx + w[v[i][j]]); g[i] = max(g[i], dp[v[i][j]][1]); &#125; &#125; &#125; i64 ans = 0; for (int i = 1; i &lt;= m; ++i) ans = max(&#123;ans, dp[i][0], dp[i][1]&#125;); return ans; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"算法竞赛/学习笔记/动态规划","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"2023 年 1 月第二周做题记录","slug":"default/做题记录/2023-1-2","date":"2023-01-08T00:00:00.000Z","updated":"2023-01-08T00:00:00.000Z","comments":true,"path":"d1a808fa/","link":"","permalink":"https://james1badcreeper.github.io/d1a808fa/","excerpt":"","text":"AGC 系列 第一次做 AGC，非常兴奋！ 会先做早期的，难度会小很多。 AGC 024 Portal. B. Backfront Portal. 如果我们把 xxx 放到了最前面，那么小于 xxx 的数字显然都必须操作。这样没有被操作的数字是一段连续的数字，它们原来的相对位置的递增的，找出这样最长的一段数字即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = 1, s = 1; int a[200005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), a[x] = i; for (int i = 1; i &lt; n; ++i) &#123; if (a[i + 1] > a[i]) ans = max(ans, ++s); else s = 1; &#125; printf(\"%d\\n\", n - ans); return 0; &#125; CF Div.2 系列 以后这里只会写有必要写的题。 Codeforces Round #585 (Div. 2) Portal. E. Marbles Portal. 如果知道最后的颜色顺序，那么答案便可以直接统计。观察到颜色数很少，那么设 f(i)f(i)f(i) 表示当前考虑的颜色顺序状压后为 iii，枚举其中哪个颜色放在最后并计算代价即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, cnt[25]; i64 f[1100000], w[25][25]; // w(x, y): y 换到 x 前的代价 int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); ++cnt[--x]; for (int j = 0; j &lt; 20; ++j) w[j][x] += cnt[j]; &#125; for (int i = 1; i &lt; 1 &lt;&lt; 20; ++i) &#123; f[i] = 1e18; for (int j = 0; j &lt; 20; ++j) if (i &amp; (1 &lt;&lt; j)) &#123; i64 sum = 0; for (int k = 0; k &lt; 20; ++k) if ((1 &lt;&lt; k) &amp; (i ^ (1 &lt;&lt; j))) sum += w[j][k]; f[i] = min(f[i], f[i ^ (1 &lt;&lt; j)] + sum); &#125; &#125; printf(\"%lld\\n\", f[(1 &lt;&lt; 20) - 1]); return 0; &#125; Codeforces Round #845 (Div. 2) Portal. B. Emordnilap Portal. 序列可以分成前后两个部分。假设前半部分有 mmm 个逆序对，那么就有 n(n−1)2−m\\frac{n(n-1)}{2}-m2n(n−1)​−m 个正序对，也就是说后半部分有 n(n−1)2−m\\frac{n(n-1)}{2}-m2n(n−1)​−m 个逆序对；后半部分的任意一个数 iii 在前半部分有 i−1i-1i−1 个比它小，逆序对数为 n(n−1)2\\frac{n(n-1)}{2}2n(n−1)​。因此任意一个排列的逆序对数都是 n(n−1)n(n-1)n(n−1)，总答案就是 n!n(n−1)n!n(n-1)n!n(n−1)。 D. Score of a Tree Portal. 诈骗题（我是被骗的）！ 一个点的贡献是它自己的权值，它所有儿子的异或和，它所有孙子的异或和，以此类推。总共有 2n2^n2n 种情况，对于每个节点，它要么初始权值为 111，要么初始权值为 000，每一种都对应 2n−12^{n-1}2n−1 种情况。 设叶子节点为 111 层，节点 iii 的层数 sis_isi​ 为 max⁡{sson[i]}+1\\max\\{s_{son[i]}\\}+1max{sson[i]​}+1。第 iii 个节点在时间 0∼si−10\\sim s_i-10∼si​−1 的时刻内都会有一个 2n−12^{n-1}2n−1 的贡献，因此答案为 2n−1∑si2^{n-1}\\sum s_i2n−1∑si​。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n, f[200005]; vector&lt;int> G[200005]; void dfs(int x, int fa) &#123; for (int y : G[x]) if (y != fa) dfs(y, x), f[x] = max(f[x], f[y] + 1); &#125; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) G[i].clear(), f[i] = 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + f[i]) % P; cout &lt;&lt; 1ll * ans * poww(2, n - 1) % P &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; E. Edge Reverse Portal. 显然是二分答案，可以反转的边相当于无向边，将图 SCC 缩点后应该恰好有一个入度为 000 的点才能满足条件。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int u, v, w; bool operator &lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[200005]; int n, m; vector&lt;int> G[200005]; int dfn[200005], low[200005], num, st[200005], tot; int cnt, col[200005], deg[200005]; bool ins[200005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (dfn[x] == low[x]) &#123; int y; ++cnt; do ins[y = st[tot--]] = false, col[y] = cnt; while (x != y); &#125; &#125; bool P(int x) &#123; for (int i = 1; i &lt;= n; ++i) G[i].clear(), dfn[i] = ins[i] = deg[i] = 0; for (int i = 1; i &lt;= m; ++i) &#123; G[e[i].u].emplace_back(e[i].v); if (i &lt;= x) G[e[i].v].emplace_back(e[i].u); &#125; num = tot = cnt = 0; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int u = 1; u &lt;= n; ++u) for (int v : G[u]) if (col[u] != col[v]) ++deg[col[v]]; int res = 0; for (int i = 1; i &lt;= cnt; ++i) res += (deg[i] == 0); return res == 1; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); sort(e + 1, e + m + 1); int L = -1, R = m + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) R = mid; else L = mid; &#125; printf(\"%d\\n\", R != m + 1 ? e[R].w : -1); &#125; return 0; &#125; F. Comfortably Numb Portal. 找出序列中权值最大的位置，答案区间要么在它左侧或右侧，要么跨越区间。合并时采用启发式合并的思想，枚举小区间中的下标作为答案的一段，就是要在大区间中找一个异或值最大的，可以使用可持久化 01 Trie 解决。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int a[200005], f[21][200005], lg[200005], s[200005]; int ch[6400005][2], tot, root[200005], val[6400005]; int qmax(int l, int r) &#123; int k = lg[r - l + 1]; if (a[f[k][l]] > a[f[k][r - (1 &lt;&lt; k) + 1]]) return f[k][l]; return f[k][r - (1 &lt;&lt; k) + 1]; &#125; void insert(int x, int pre, int v) &#123; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; ch[x][!c] = ch[pre][!c]; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c], pre = ch[pre][c]; val[x] = val[pre] + 1; &#125; &#125; int query(int x, int y, int v) &#123; int res = 0; for (int i = 29; i >= 0; --i) &#123; int c = v >> i &amp; 1; if (val[ch[y][!c]] - val[ch[x][!c]]) x = ch[x][!c], y = ch[y][!c], res |= 1 &lt;&lt; i; else x = ch[x][c], y = ch[y][c]; &#125; return res; &#125; int merge(int l, int r) &#123; if (l >= r) return 0; int mid = qmax(l, r), ans = max(merge(l, mid - 1), merge(mid + 1, r)); if (r - mid &lt; mid - l) &#123; // 将右半段合并到左半段 for (int i = mid; i &lt;= r; ++i) // 枚举右端点 ans = max(ans, query(l > 1 ? root[l - 2] : 0, root[mid - 1], a[mid] ^ s[i])); &#125; else &#123; for (int i = l; i &lt;= mid; ++i) // 枚举左端点 ans = max(ans, query(root[mid - 1], root[r], a[mid] ^ s[i - 1])); &#125; return ans; &#125; void solve(void) &#123; for (int i = 0; i &lt;= tot; ++i) ch[i][0] = ch[i][1] = val[i] = 0; cin >> n; tot = 0; for (int i = 1; i &lt;= n; ++i) cin >> a[i], f[0][i] = i, s[i] = s[i - 1] ^ a[i]; for (int i = 0; i &lt;= n; ++i) &#123; root[i] = ++tot; insert(root[i], i == 0 ? 0 : root[i - 1], s[i]); &#125; for (int j = 1; 1 &lt;&lt; j &lt;= n; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) if (a[f[j - 1][i]] > a[f[j - 1][i + (1 &lt;&lt; j - 1)]]) f[j][i] = f[j - 1][i]; else f[j][i] = f[j - 1][i + (1 &lt;&lt; j - 1)]; cout &lt;&lt; merge(1, n) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; for (int i = 2; i &lt;= 200000; ++i) lg[i] = lg[i >> 1] + 1; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; CF Div.1 系列 感动！ Codeforces Round #576 (Div. 1) Portal. C. Matching vs Independent Set Portal. 我们暴力查找边的独立集，如果最后独立集中有 xxx 条边，那么点的独立集至少有 3n−2x3n-2x3n−2x 个点，这两个至少有一个 ≥n\\ge n≥n。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; bool a[300005]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); fill(a + 1, a + n * 3 + 1, 0); vector&lt;int> ans; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (!a[u] &amp;&amp; !a[v]) a[u] = a[v] = 1, ans.emplace_back(i); &#125; if (ans.size() >= n) &#123; puts(\"Matching\"); for (int i = 0; i &lt; n; ++i) printf(\"%d \", ans[i]); &#125; else &#123; puts(\"IndSet\"); for (int i = 1, cnt = 0; i &lt;= n * 3 &amp;&amp; cnt &lt; n; ++i) if (!a[i]) printf(\"%d \", i), ++cnt; &#125; putchar('\\n'); &#125; return 0; &#125; F. GCD Groups 2 Portal. 将一个数加入其中一个分组，如果最大公约数可以变小就加，否则加入另一个。多次随机重复上述过程即可得到正确答案。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int n, a[100005], id[100005], c[100005], g[3]; mt19937 Rand(time(0)); bool solve(void) &#123; c[id[1]] = 1; g[1] = a[id[1]]; c[id[2]] = 2; g[2] = a[id[2]]; for (int i = 3; i &lt;= n; ++i) if (a[id[i]] % g[1] == 0) &#123; c[id[i]] = 2; g[2] = gcd(g[2], a[id[i]]); &#125; else &#123; c[id[i]] = 1; g[1] = gcd(g[1], a[id[i]]); &#125; return g[1] == 1 &amp;&amp; g[2] == 1; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), id[i] = i; for (int op = 1; op &lt;= 100; ++op) &#123; shuffle(id + 1, id + n + 1, Rand); if (solve()) &#123; puts(\"YES\"); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", c[i]); putchar('\\n'); return 0; &#125; &#125; puts(\"NO\"); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"2023 年 1 月第一周做题记录","slug":"default/做题记录/2023-1-1","date":"2023-01-02T00:00:00.000Z","updated":"2023-01-02T00:00:00.000Z","comments":true,"path":"d916a9d1/","link":"","permalink":"https://james1badcreeper.github.io/d916a9d1/","excerpt":"省选计划强迫我们必须做这个，这是为了完成作业的无奈之举。","text":"省选计划强迫我们必须做这个，这是为了完成作业的无奈之举。 过于简单的题就不写了。 ARC 系列 早期的 4 题场（其实当时是和 ABC 和场）和现代的 6 题场都会做。 ARC 102 (4) Portal. A. Triangular Relationship（自行做出） Portal. 发现 nnn 不大，因此考虑枚举 aaa。三元组应该形如 (i,pk−i,qk−i)(i,pk-i,qk-i)(i,pk−i,qk−i) 的形式，若满足 b+c=(p+q)k−2ib+c=(p+q)k-2ib+c=(p+q)k−2i 是 kkk 的倍数，则需要 2i2i2i 是 kkk 的倍数，满足这一条件时，统计 ppp 的数量并平方就是此时 iii 对应的答案数。ppp 应满足 1≤pk−i≤n1\\le pk-i\\le n1≤pk−i≤n，解不等式即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, k; long long ans = 0; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) if (2 * i % k == 0) &#123; int cnt = (n + i) / k - (i + k) / k + 1; ans += 1ll * cnt * cnt; &#125; printf(\"%lld\\n\", ans); return 0; &#125; 后来看了眼题解，存在 O(1)O(1)O(1) 公式，不过也不难想。 B. All Your Paths are Different Lengths（看了眼题解） Portal.给你一个数 LLL，构造一个有向图使得从 111 到 nnn 恰好有 LLL 条路径且路径长度恰好为 000 到 L−1L-1L−1。边有边权。点数小于等于 202020，边数小于等于 606060。2≤L≤1062\\leq L\\leq 10^62≤L≤106。 可以联想到二进制拆分。这样之后还有从 2k∼l−12^{k}\\sim l-12k∼l−1 的长度需要处理。我们可以让其从某个点直接“穿越”到终点，这样是没有重复长路的路径的。只要我们把 lll 的每一位 111 都搞出来，“穿越”的边自然也就能求出来了。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m, l; int u[65], v[65], w[65]; void add(int x, int y, int d) &#123; u[++m] = x; v[m] = y; w[m] = d; &#125; int main(void) &#123; scanf(\"%d\", &amp;l); int b = 1, t = l - 1; n = 1; while (t >= b) &#123; add(n, n + 1, b); add(n, n + 1, 0); t -= b; b &lt;&lt;= 1; ++n; &#125; for (int i = 0; i &lt; n - 1; ++i) if ((l >> i) &amp; 1) add(i + 1, n, l &amp; ~((1 &lt;&lt; i + 1) - 1)); printf(\"%d %d\\n\", n, m); for (int i = 1; i &lt;= m; ++i) printf(\"%d %d %d\\n\", u[i], v[i], w[i]); return 0; &#125; C. Stop. Otherwise…（看题解） Portal.有 nnn 个不可区分的骰子，每个骰子有 KKK 个面，上面有 111 到 KKK。注意骰子之间不可区分，两个局面不同当且仅当存在一个点数 iii 使得投出 iii 的数量不同。现在对于 [2,2K][2,2K][2,2K] 中的每一个数 xxx，要求出任意投这个 nnn 个骰子使得不存在任意两个骰子的点数和为 xxx 的方案数。n,K≤2000n,K\\le 2000n,K≤2000，答案对 998244353998244353998244353 取模。 考虑对单个 xxx 如何求解。那么对于点数 i∈[1,K]i\\in [1,K]i∈[1,K]，应该有以下几种情况： x−i∈[1,K]x-i\\in [1,K]x−i∈[1,K]，此时 iii 和 x−ix-ix−i 至多只能出现一种，称为这一对数最多只能出现一种； x−i=ix-i=ix−i=i 时，这个 iii 只能出现一次； x−i∉[1,K]x-i\\not\\in [1,K]x−i∈[1,K]，这个 iii 的出现无限制。 设 f(i,j)f(i,j)f(i,j) 表示考虑了 iii 对数，其中选择了 jjj 个数的方案数；g(i,j)g(i,j)g(i,j) 代表考虑 iii 个没有限制的数，选择 jjj 个数的方案数。那么： f(i,j)=f(i−1,j)+2×∑k=0j−1f(i−1,k) g(i,j)=∑k=0jg(i−1,k)f(i,j)=f(i-1,j)+2\\times \\sum_{k=0}^{j-1} f(i-1,k)\\\\ \\ \\\\ g(i,j)=\\sum_{k=0}^j g(i-1,k) f(i,j)=f(i−1,j)+2×k=0∑j−1​f(i−1,k) g(i,j)=k=0∑j​g(i−1,k) 然后枚举每一种选的个数，组合起来即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 998244353; int k, n; int f[2005][2005], g[2005][2005]; int main(void) &#123; scanf(\"%d%d\", &amp;k, &amp;n); f[0][0] = g[0][0] = 1; for (int i = 1; i &lt;= k; ++i) &#123; i64 s0 = 0; for (int j = 0; j &lt;= n; ++j) &#123; f[i][j] = (f[i - 1][j] + s0 * 2) % MOD; s0 = (s0 + f[i - 1][j]) % MOD; g[i][j] = (g[i - 1][j] + (j > 0 ? g[i][j - 1] : 0)) % MOD; &#125; &#125; for (int x = 2; x &lt;= (k &lt;&lt; 1); ++x) &#123; i64 ans = 0; int c1, c2 = (x % 2 == 0), c3 = 0; for (int i = 1; i &lt;= k; ++i) c3 += (x - i &lt; 1 || x - i > k); c1 = (k - c2 - c3) >> 1; for (int i = 0; i &lt;= n; ++i) &#123; ans = (ans + 1ll * f[c1][i] * g[c3][n - i]) % MOD; if (c2 &amp;&amp; i &lt; n) ans = (ans + 1ll * f[c1][i] * g[c3][n - i - 1]) % MOD; &#125; printf(\"%lld\\n\", ans); &#125; return 0; &#125; D. Revenge of BBuBBBlesort! 到底有多少个冒泡排序复仇题！ Portal. ARC 103 (4) Portal. A. /\\/\\/\\/（自行做出） Portal. 很无聊，直接糊个排序上去。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, ans = 0, a[100001]; struct Node &#123; int id, cnt; bool operator &lt; (const Node &amp;a) const &#123; return cnt > a.cnt; &#125; &#125; b1[100001], b2[100001]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; i++) if (i &amp; 1) b1[a[i]].id = a[i], b1[a[i]].cnt++; else b2[a[i]].id = a[i], b2[a[i]].cnt++; sort(b1 + 1, b1 + 100001); sort(b2 + 1, b2 + 100001); if (b1[1].id != b2[1].id) ans = (n - b1[1].cnt - b2[1].cnt); else ans = min(n - b1[1].cnt - b2[2].cnt, n - b1[2].cnt - b2[1].cnt); printf(\"%d\\n\", ans); return 0; &#125; B. Robot Arms Portal. ABC 系列 CF Div.2 系列 Codeforces Round #554 (Div. 2) Portal. C. Neko does Maths（自行做出） Portal. 要求的是 lcm(a+k,b+k)=(a+k)(b+k)gcd⁡(a+k,b+k)=(a+k)(b+k)gcd⁡(b+k,a−b)\\text{lcm}(a+k,b+k)=\\cfrac{(a+k)(b+k)}{\\gcd(a+k,b+k)}=\\cfrac{(a+k)(b+k)}{\\gcd(b+k,a-b)}lcm(a+k,b+k)=gcd(a+k,b+k)(a+k)(b+k)​=gcd(b+k,a−b)(a+k)(b+k)​，那么假设 a&gt;ba&gt;ba&gt;b，gcd⁡(b+k,a−b)\\gcd(b+k,a-b)gcd(b+k,a−b) 的值一定是 a−ba-ba−b 的约数。那么我们枚举 a−ba-ba−b 的约数 iii 并计算出让 iii 是 b+kb+kb+k 的约数的最小 kkk 即可，时间复杂度为 O(a−b)O(\\sqrt{a-b})O(a−b​)。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; long long lcm(int x, int y) &#123; return 1ll * x / gcd(x, y) * y; &#125; int a, b, k; long long ans; int calc(int x) &#123; if (b % x == 0) return 0; return x - b % x; &#125; void upd(int t) &#123; long long tmp = 1ll * (a + t) / gcd(b + t, a - b) * (b + t); if (tmp &lt; ans) ans = tmp, k = t; else if (tmp == ans) k = min(k, t); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;a, &amp;b); if (a &lt; b) swap(a, b); ans = lcm(a, b), k = 0; for (int i = 1; i * i &lt;= a - b; ++i) if ((a - b) % i == 0) &#123; int t = calc(i); upd(t); t = calc((a - b) / i); upd(t); &#125; printf(\"%d\\n\", k); return 0; &#125; D. Neko and Aki’s Prank（看题解） Portal.有一个由所有长为 2n2n2n 的合法括号序列组成的 Trie，现在要求这棵树上最多的边数，符合边两两之间均没有共同节点。 我们来看 n=3n=3n=3 时候的 Trie 树： 实际上我们只需要贪心地选择边即可选到最大值，原因很简单，不选择这一条而选择下一条并不会使贡献变大。 可以发现，所有深度为偶数的节点都会连接一条边，所以现在的问题成了求深度为偶数的节点的个数。 设 f(i,j)f(i,j)f(i,j) 代表有 iii 个左括号，jjj 个右括号在 Trie 上能形成的括号序列个数。初始 f(0,0)f(0,0)f(0,0)，转移时，可以选择添加一个左括号或者右括号，只需要满足 j≤ij\\le ij≤i，因此 f(i,j)=f(i−1,j)+f(i,j−1)f(i,j)=f(i-1,j)+f(i,j-1)f(i,j)=f(i−1,j)+f(i,j−1)。当 i+ji+ji+j 为偶数时，这个节点在 Trie 上的深度也是偶数，加起来就是答案。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 1000000007; int n, ans; int f[1005][1005]; int main(void) &#123; scanf(\"%d\", &amp;n); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; f[i][0] = 1; for (int j = 1; j &lt;= i; ++j) f[i][j] = (f[i - 1][j] + f[i][j - 1]) % MOD; &#125; for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= i; ++j) if ((i + j) &amp; 1) ans = (ans + f[i][j]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; E. Neko and Flashback（看了眼题解） Portal. 对于一个 iii，有 bi=min⁡{ai,ai+1},ci=max⁡{ai,ai+1}b_i=\\min\\{a_i,a_{i+1}\\},c_i=\\max\\{a_i,a_{i+1}\\}bi​=min{ai​,ai+1​},ci​=max{ai​,ai+1​}，也就是说 bi,cib_i,c_ibi​,ci​ 各是 ai,ai+1a_i,a_{i+1}ai​,ai+1​ 其中的一个（当然需要 bi≤cib_i\\le c_ibi​≤ci​，否则无解）。 注意这个输出方式，ppp 的作用是将 aaa 排列，也就是说我们只需要求出 aaa 有哪些数组成即可。将给定的 ai,ai+1a_i,a_{i+1}ai​,ai+1​ 的关系看成一条无向边，走过这个路径就相当于满足了一个限制条件。那么在图上找出欧拉路，就可以得到一个满足所有的限制条件的序列 aaa（需要先离散化后再建图）。时间复杂度 O((n+m)log⁡m)O((n+m)\\log m)O((n+m)logm)。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> using namespace std; int n, tot, cur[100005], deg[200005], st[200005]; int b[100005], c[100005], B[200005]; vector&lt;int> edges; vector&lt;int> G[200005]; inline void addedge(int u, int v) &#123; edges.emplace_back(v); G[u].emplace_back(edges.size() - 1); ++deg[v]; &#125; void dfs(int x) &#123; for (; cur[x] &lt; G[x].size(); ++cur[x]) &#123; int y = edges[G[x][cur[x]]]; if (y) &#123; edges[G[x][cur[x]]] = 0, edges[G[x][cur[x]] ^ 1] = 0; dfs(y); &#125; &#125; st[++tot] = x; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) scanf(\"%d\", b + i), B[++tot] = b[i]; for (int i = 1; i &lt; n; ++i) scanf(\"%d\", c + i), B[++tot] = c[i]; sort(B + 1, B + tot + 1); tot = unique(B + 1, B + tot + 1) - (B + 1); for (int i = 1; i &lt; n; ++i) &#123; b[i] = lower_bound(B + 1, B + tot + 1, b[i]) - B; c[i] = lower_bound(B + 1, B + tot + 1, c[i]) - B; if (b[i] > c[i]) return puts(\"-1\"), 0; addedge(b[i], c[i]); addedge(c[i], b[i]); &#125; int cnt = 0, h = 0; for (int i = 1; i &lt;= tot; ++i) if (deg[i] &amp; 1) &#123; ++cnt; if (!h) h = i; &#125; if (cnt == 1 || cnt > 2) return puts(\"-1\"), 0; tot = 0; dfs(h ? h : 1); if (tot != n) return puts(\"-1\"), 0; for (int i = tot; i >= 1; --i) printf(\"%d \", B[st[i]]); putchar('\\n'); return 0; &#125; CF Div.1 系列 包括和场。 Codeforces Round #639 (Div. 1) Portal. A. Hilbert’s Hotel（自行做出） Portal. 当存在 i+aii+a_ii+ai​ 余数相同时，就有问题。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;map> using namespace std; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, x; scanf(\"%d\", &amp;n); map&lt;int, int> s; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;x), s[((x + i) % n + n) % n]++; bool flag = true; for (auto x : s) if (x.second >= 2) &#123; flag = false; break; &#125; puts(flag ? \"YES\" : \"NO\"); &#125; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"数据结构的常用维护方法","slug":"notes/DS/ds-tricks","date":"2023-01-02T00:00:00.000Z","updated":"2023-01-02T00:00:00.000Z","comments":true,"path":"8cb451a5/","link":"","permalink":"https://james1badcreeper.github.io/8cb451a5/","excerpt":"在处理一些数据结构问题时有一些经典模型和常用手段，还有一些比较少见的实用数据结构，本文会简单介绍。","text":"在处理一些数据结构问题时有一些经典模型和常用手段，还有一些比较少见的实用数据结构，本文会简单介绍。 主要是存放一些无处安放的和综合内容。 颜色段均摊 维护序列时，一个经典的操作是区间染色，我们可以考虑使用平衡树了来维护区间的颜色连续段。区间染色每次最多只会增加均摊 O(1)O(1)O(1) 个颜色段。 珂朵莉树 模板。维护一个序列，支持区间加，区间染色，区间 kkk 小查询，区间每个数的 xxx 次方的和模 yyy 的值。使用数据生成器生成数据（数据随机）。 询问的内容非常诡异，不是传统树套树可以支持的操作。这里我们介绍珂朵莉树（ODT，严格意义上是一种思想），利用一个 set 存储所用的颜色段，然后进行暴力操作。 核心数据结构如下定义： struct Node &#123; int l, r; mutable i64 v; // 这个 v 接下来需要修改 Node(int l = 0, int r = 0, i64 v = 0) : l(l), r(r), v(v) &#123;&#125; bool operator &lt; (const Node &amp;a) const &#123; return l &lt; a.l; &#125; &#125;; set&lt;Node> T; 最为关键的是 split 操作，其作用是将 lll 开始的颜色段单独分裂出来，并返回这一个颜色段的指针。 auto split(int p) &#123; auto it = T.lower_bound(Node(p)); if (it != T.end() &amp;&amp; it->l == p) return it; --it; int l = it->l, r = it->r; i64 v = it->v; T.erase(it); T.insert(Node(l, p - 1, v)); return T.insert(Node(p, r, v)).first; &#125; 当我们要取出一段区间时，一定要先 split(r + 1)，再 split(l)，否则可能 RE。取出颜色段后直接暴力操作即可。 在数据随机的情况下，期望复杂度是 O(nlog⁡log⁡n)O(n\\log \\log n)O(nloglogn) 的。但是由于现在基本上都卡，所以出现区间染色操作时尽量往势能上想。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, seed, vmax; int rnd(void) &#123; int ret = seed; seed = (1ll * seed * 7 + 13) % 1000000007; return ret; &#125; i64 poww(i64 a, int b, int p) &#123; a %= p; i64 res = 1; for (; b; b >>= 1, a = 1ll * a * a % p) if (b &amp; 1) res = 1ll * res * a % p; return res; &#125; struct Node &#123; int l, r; mutable i64 v; Node(int l = 0, int r = 0, i64 v = 0) : l(l), r(r), v(v) &#123;&#125; bool operator &lt; (const Node &amp;a) const &#123; return l &lt; a.l; &#125; &#125;; set&lt;Node> T; auto split(int p) &#123; auto it = T.lower_bound(Node(p)); if (it != T.end() &amp;&amp; it->l == p) return it; --it; int l = it->l, r = it->r; i64 v = it->v; T.erase(it); T.insert(Node(l, p - 1, v)); return T.insert(Node(p, r, v)).first; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;seed, &amp;vmax); for (int i = 1; i &lt;= n; ++i) T.insert(Node(i, i, rnd() % vmax + 1)); int op, l, r, x, y; while (m--) &#123; op = rnd() % 4 + 1, l = rnd() % n + 1, r = rnd() % n + 1; if (l > r) swap(l, r); if (op == 3) x = rnd() % (r - l + 1) + 1; else x = rnd() % vmax + 1; if (op == 4) y = rnd() % vmax + 1; if (op == 1) &#123; auto R = split(r + 1), L = split(l); for (auto i = L; i != R; ++i) i->v += x; &#125; else if (op == 2) &#123; auto R = split(r + 1), L = split(l); T.erase(L, R); T.insert(Node(l, r, x)); &#125; else if (op == 3) &#123; auto R = split(r + 1), L = split(l); vector&lt;pair&lt;i64, int>> v; for (auto i = L; i != R; ++i) v.push_back(&#123;i->v, i->r - i->l + 1&#125;); sort(v.begin(), v.end()); for (int i = 0; i &lt; v.size(); ++i) &#123; if (v[i].second &lt; x) x -= v[i].second; else &#123; printf(\"%lld\\n\", v[i].first); break; &#125; &#125; &#125; else &#123; auto R = split(r + 1), L = split(l); i64 ans = 0; for (auto i = L; i != R; ++i) ans = (ans + poww(i->v, x, y) * (i->r - i->l + 1)) % y; printf(\"%lld\\n\", ans); &#125; &#125; return 0; &#125; 势能线段树 还记得花神游历各国（区间开方区间和）吗？它的修改非常暴力，但是复杂度是正确的。 由于区间染色每次最多只会增加均摊 O(1)O(1)O(1) 个颜色段，因此可以考虑使用线段树暴力维护。 [CF444C] DZY Loves Colors.有一个 nnn 个元素组成的序列，每个元素有两个属性：颜色 cic_ici​ 和权值 wiw_iwi​。cic_ici​ 初始为 iii，wiw_iwi​ 初始为 000。mmm 次操作，操作有两种：1 l r x：对 i∈[l,r]i\\in [l,r]i∈[l,r] 的所有 iii 进行如下操作：设第 iii 个元素 原来 的颜色为 yyy，您要把第 iii 个元素的颜色改为 xxx，权值 增加 ∣y−x∣|y-x|∣y−x∣。2 l r：求 ∑i=lrwi\\sum\\limits_{i=l}^r w_ii=l∑r​wi​。1≤n,m≤1051\\le n,m\\le 10^51≤n,m≤105，1≤x≤1081\\le x\\le 10^81≤x≤108。 我们记一个 ccc 代表区间颜色，不一样时记为 −1-1−1。如果一样则打标记修改，不一样则暴力递归修改。一次区间染色只会产生两个新的端点，暴力查询的次数为 O(n+m)O(n+m)O(n+m) 级别。因此时间复杂度为 O((n+m)log⁡n)O((n+m)\\log n)O((n+m)logn)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, a[100005]; struct Node &#123; int c; i64 w, t; // 区间是否为同一颜色 c（不同 c = -1），区间和 w，累加颜色改变值 t bool tag; // 区间 set 标记 tag #define ls o &lt;&lt; 1 #define rs ls | 1 &#125; T[400005]; void pushup(int o) &#123; if (T[ls].c == T[rs].c &amp;&amp; T[ls].c != -1) T[o].c = T[ls].c; else T[o].c = -1; T[o].w = T[ls].w + T[rs].w; &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o].c = l, T[o].w = 0, void(); int mid = l + r >> 1; build(ls, l, mid); build(rs, mid + 1, r); pushup(o); &#125; void pushdown(int o, int l, int r) &#123; if (!T[o].tag) return; int mid = l + r >> 1; T[o &lt;&lt; 1].w += (mid - l + 1) * T[o].t; T[o &lt;&lt; 1 | 1].w += (r - mid) * T[o].t; T[o &lt;&lt; 1].c = T[o &lt;&lt; 1 | 1].c = T[o].c; T[o &lt;&lt; 1].tag = T[o &lt;&lt; 1 | 1].tag = 1; T[o &lt;&lt; 1].t += T[o].t; T[o &lt;&lt; 1 | 1].t += T[o].t; T[o].tag = T[o].t = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; T[o].c != -1) &#123; T[o].t += abs(k - T[o].c); T[o].w += 1ll * (r - l + 1) * abs(k - T[o].c); T[o].c = k; T[o].tag = 1; return; &#125; int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(ls, l, mid, x, y, k); if (mid &lt; y) update(rs, mid + 1, r, x, y, k); pushup(o); &#125; i64 query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].w; int mid = l + r >> 1; i64 res = 0; pushdown(o, l, r); if (x &lt;= mid) res += query(ls, l, mid, x, y); if (mid &lt; y) res += query(rs, mid + 1, r, x, y); return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); build(1, 1, n); while (m--) &#123; int op, l, r, x; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) &#123; scanf(\"%d\", &amp;x); update(1, 1, n, l, r, x); &#125; else printf(\"%lld\\n\", query(1, 1, n, l, r)); &#125; return 0; &#125; 扫描线 扫描线具有非常广泛的应用。就是一根横着或者竖着的线沿着一个方向进行扫描，并利用数据结构（比如线段树）统计信息。 二维数点问题 模板。给定二维平面上的 nnn 个整点，多次询问一个矩形中点的个数。 我们记 S(x,y)S(x,y)S(x,y) 代表 (0,0),(x,y)(0,0),(x,y)(0,0),(x,y) 构成的矩形中点的个数，那么询问 (a,b),(c,d)(a,b),(c,d)(a,b),(c,d) 的答案是：S(c,d)−S(a−1,d)−S(c,b−1)+S(a−1,b−1)S(c,d)-S(a-1,d)-S(c,b-1)+S(a-1,b-1)S(c,d)−S(a−1,d)−S(c,b−1)+S(a−1,b−1)。 我们将得到的询问按照 xxx 排序，然后放一根扫描线从左到右进行扫描，将点加入树状数组，并进行统计。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, ans[500005], b[2000005], C[2000005], p = 0; struct Node &#123; int x, y, type, id; bool operator&lt; (const Node &amp;a) const &#123; if (x == a.x) return type &lt; a.type; return x &lt; a.x; &#125; &#125; a[3000005]; #define lowbit(x) (x &amp; -x) void add(int x, int k) &#123; for (; x &lt;= p; x += lowbit(x)) C[x] += k; &#125; int query(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); ++a[i].x; ++a[i].y; a[i].type = 1; b[++p] = a[i].y; &#125; int tot = n; for (int i = 1; i &lt;= m; ++i) &#123; int x, y, _x, _y; scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;_x, &amp;_y); ++x; ++y; ++_x; ++_y; b[++p] = y - 1; b[++p] = _y; a[++tot] = &#123;_x, _y, 3, i&#125;; a[++tot] = &#123;x - 1, y - 1, 3, i&#125;; a[++tot] = &#123;_x, y - 1, 2, i&#125;; a[++tot] = &#123;x - 1, _y, 2, i&#125;; &#125; sort(a + 1, a + tot + 1); sort(b + 1, b + p + 1); p = unique(b + 1, b + p + 1) - (b + 1); for (int i = 1; i &lt;= tot; ++i) &#123; a[i].y = lower_bound(b + 1, b + p + 1, a[i].y) - b; if (a[i].type == 1) add(a[i].y, 1); else if (a[i].type == 2) ans[a[i].id] -= query(a[i].y); else ans[a[i].id] += query(a[i].y); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; 矩形面积并 模板。求 nnn 个矩形的面积并。 我们把这些矩形放在平面直角坐标系中，然后手握一根竖直的线线（当然你也可以握着一条横的上下扫，我们把它称之为扫描线，从左到右扫过整个坐标系，在这条扫描线上覆盖的图形长度只有在每个矩形的左右边界处会变化。 图片来自 https://www.luogu.com.cn/blog/happy404/solution-p5490，可以看到在扫并起来的矩形时覆盖的长度变化 也就是说，整个图形可以被分为 n×2n\\times 2n×2 段（每到一个矩形的两边长度就需要改变），每一段覆盖的长度 LLL 是固定的（扫描这一段时的长度不变），这样就可以使用幼儿园数学求解这一段的矩形面积：L×该段的宽度L\\times 该段的宽度L×该段的宽度。 实现上，我们取出 nnn 个矩形的左右边界，如果一个矩形的两个对角顶点坐标分别为 (x1,y1),(x2,y2),x1&lt;x2,y1&lt;y2(x_1,y_1),(x_2,y_2),x_1&lt;x_2,y_1&lt;y_2(x1​,y1​),(x2​,y2​),x1​&lt;x2​,y1​&lt;y2​，那么左边界为 (x1,y1,y2,1)(x_1,y_1,y_2,1)(x1​,y1​,y2​,1)，右边界为 (x2,y1,y2,−1)(x_2,y_1,y_2,-1)(x2​,y1​,y2​,−1)，四个数分别代表 xxx 坐标，yyy 坐标上界，yyy 坐标下界，对以后的面积是加 111 还是减 111（类似差分）。现在将这 2n2n2n 个四元组按照 xxx 从小到大的顺序排序。这就相当于给了我们 2n2n2n 个区间加的操作，但是 yyy 的范围很大，所以需要离散化后才能完成，而区间加就是典型的线段树操作了。 实现的时候有一点细节： 我们不需要 pushdown，因为我们只查总区间，只需要返回 T[1] 即可，其余节点就让它自生自灭就行了。 在修改的时候 y2y_2y2​ 要减去 111，因为给的是点，我们想要覆盖，令 yyy 覆盖的是 [y,y+1][y,y+1][y,y+1]，那么作为上面的 y2y_2y2​ 就需要减去 111。 这里的标记很特殊，我们用一个 flag 来记录，当它是正数的时候说明被覆盖了，这时候就直接赋值为对应的区间所对应的值，如果没有被覆盖就是左右儿子的和。而且它在排序后进行扫描，只可能是一个自然数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct line &#123; int x, yl, yh, flag; line(int x = 0, int yl = 0, int yh = 0, int flag = 0) : x(x), yl(yl), yh(yh), flag(flag) &#123;&#125; bool operator &lt; (const line &amp;a) const &#123; return x &lt; a.x; &#125; &#125; e[2000005]; int n, m; int b[2000005], raw[2000005], tag[8000005]; i64 T[8000005]; void maintain(int o, int l, int r) &#123; if (tag[o]) T[o] = raw[r + 1] - raw[l]; else T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] += k, maintain(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); maintain(o, l, r); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x, y, _x, _y; i &lt;= n; ++i) &#123; scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;_x, &amp;_y); e[(i &lt;&lt; 1) - 1] = line(x, y, _y, 1); e[i &lt;&lt; 1] = line(_x, y, _y, -1); b[(i &lt;&lt; 1) - 1] = y, b[i &lt;&lt; 1] = _y; &#125; n &lt;&lt;= 1; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) &#123; int pos1 = lower_bound(b + 1, b + m + 1, e[i].yl) - b; int pos2 = lower_bound(b + 1, b + m + 1, e[i].yh) - b; raw[pos1] = e[i].yl, raw[pos2] = e[i].yh; e[i].yl = pos1, e[i].yh = pos2; &#125; sort(e + 1, e + n + 1); i64 ans = 0; for (int i = 1; i &lt; n; ++i) &#123; update(1, 1, m - 1, e[i].yl, e[i].yh - 1, e[i].flag); ans += T[1] * (e[i + 1].x - e[i].x); &#125; printf(\"%lld\\n\", ans); return 0; &#125; 实际上扫描线还可以用在更复杂的几何问题上，比如圆的面积并和三角形面积并，请参考笔者有关计算几何的文章。 扫描线本质 比如很多问题中都存在二维数点的模型，比如询问两棵子树内是否有共同编号的节点，可以将一棵子树看作时间维（扫描线扫这个），然后使用数据结构来维护序列维（另一棵子树）。 当然这个问题也可以使用主席树在线解决，利用可持久化的性质来维护时间维，线段树维护序列维。 扫描线离线还是最通用的做法，因为它可以适配所有数据结构。 然而扫描线也可以扫序列维，用数据结构来维护时间维。 线段树的进阶用法 线段树是功能非常强大的数据结构，我们来看一些它的变种。 李超线段树 考虑这样一个问题：加入给定定义域的一次函数，查询 x=kx=kx=k 时的最大值。 怎么做？考虑一种线段树，维护 [l,r][l,r][l,r] 的节点只存储一个 midmidmid 处值最大的线段。修改操作如何实现呢？如果修改的线段不比当前线段优，那么下传修改线段；如果修改线段比当前线段优，那么下传当前线段。也就是说，要下传的一定是哪个更劣的线段。如何下传？只有当在某一部分的线段有交点时才需要下传。 单次修改时间复杂度为 O(log⁡2n)O(\\log^2 n)O(log2n)，查询时直接记录路过的所有线段的答案即可，时间复杂度依然为 O(log⁡n)O(\\log n)O(logn)。 模板，代码如下： 查看代码 #include &lt;bits/stdc++.h> #define pdi pair&lt;double, int> using namespace std; const int P1 = 39989, P2 = 1000000000; const double eps = 1e-9; int n; struct Line &#123; double k, b; &#125; a[100005]; inline double calc(int x, int id) &#123; return a[id].k * x + a[id].b; &#125; inline void add(int x0, int y0, int x1, int y1) &#123; ++n; if (x0 == x1) a[n].k = 0, a[n].b = max(y0, y1); else a[n].k = 1.0 * (y1 - y0) / (x1 - x0), a[n].b = y0 - a[n].k * x0; &#125; int cmp(double x, double y) &#123; if (x - y > eps) return 1; if (y - x > eps) return -1; return 0; &#125; int T[400005]; void upd(int o, int l, int r, int x) &#123; if (T[o] == 0) return T[o] = x, void(); int &amp;y = T[o], mid = l + r >> 1; int b = cmp(calc(mid, x), calc(mid, y)); if (b == 1 || (b == 0 &amp;&amp; x &lt; y)) swap(x, y); // 现在满足 x 在中点处比 y 劣 int bl = cmp(calc(l, x), calc(l, y)), br = cmp(calc(r, x), calc(r, y)); if (bl == 1 || (bl == 0 &amp;&amp; x &lt; y)) upd(o &lt;&lt; 1, l, mid, x); // 左半部分有交点 if (br == 1 || (br == 0 &amp;&amp; x &lt; y)) upd(o &lt;&lt; 1 | 1, mid + 1, r, x); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return upd(o, l, r, k); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); &#125; pdi pmax(pdi x, pdi y) &#123; if (cmp(x.first, y.first) == 1) return x; if (cmp(x.first, y.first) == -1) return y; return x.second &lt; y.second ? x : y; &#125; pdi query(int o, int l, int r, int x) &#123; if (r &lt; x || l > x) return &#123;0, 0&#125;; int mid = l + r >> 1; double res = calc(x, T[o]); if (l == r) return &#123;res, T[o]&#125;; return pmax(&#123;res, T[o]&#125;, pmax(query(o &lt;&lt; 1, l, mid, x), query(o &lt;&lt; 1 | 1, mid + 1, r, x))); &#125; int main(void) &#123; int m; scanf(\"%d\", &amp;m); for (int lst = 0; m--; ) &#123; int op; scanf(\"%d\", &amp;op); if (op == 1) &#123; int x0, y0, x1, y1; scanf(\"%d%d%d%d\", &amp;x0, &amp;y0, &amp;x1, &amp;y1); x0 = (x0 + lst - 1 + P1) % P1 + 1; x1 = (x1 + lst - 1 + P1) % P1 + 1; y0 = (y0 + lst - 1 + P2) % P2 + 1; y1 = (y1 + lst - 1 + P2) % P2 + 1; if (x0 > x1) swap(x0, x1), swap(y0, y1); add(x0, y0, x1, y1); update(1, 1, P1, x0, x1, n); &#125; else &#123; int x; scanf(\"%d\", &amp;x); x = (x + lst - 1 + P1) % P1 + 1; printf(\"%d\\n\", lst = query(1, 1, P1, x).second); &#125; &#125; return 0; &#125; 单侧递归问题 [CTT2012 Day 1] 楼房重建.小 A 在平面上 (0,0)(0,0)(0,0) 点的位置，第 iii 栋楼房可以用一条连接 (i,0)(i,0)(i,0) 和 (i,Hi)(i,H_i)(i,Hi​) 的线段表示，其中 HiH_iHi​ 为第 iii 栋楼房的高度。如果这栋楼房上任何一个高度大于 000 的点与 (0,0)(0,0)(0,0) 的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。初始时所有楼房的高度都为 000，支持单点修改，修改后询问能看到多少栋楼房。 本质上是单点修改，询问全局有多少位置是前缀最大值。可以使用很屑的根号来维护，但是这里考虑 poly log。 使用线段树维护。一个节点记录两个数：区间所对应的答案，当前区间的最大斜率。修改时很容易实现，关键是，pushup？问题在于如何统计当前节点的答案，也就是说，如何统计右半段在被左半段影响之后应该如何计算答案。怎么办？不会！俗话说的好，那么直接递归下去！ 如果右区间的最大值小于等于左区间，那么就被全部挡住了。否则递归考虑右半段，这样所有的贡献都可以计算。 pushup(T[o &lt;&lt; 1].k, o &lt;&lt; 1 | 1, mid + 1, r); // 调用 int pushup(double k, int o, int l, int r) &#123; if (T[o].k &lt;= k) return 0; // 当这一部分的斜率小于左半部分的斜率，答案为 0 if (a[l] > k) return T[o].ans; // l 的斜率大于左半边，左半对右半没有影响，返回右半边答案 if (l == r) return a[l] > k; // 只有一个点，直接返回 int mid = l + r >> 1; if (T[o &lt;&lt; 1].k &lt;= k) return pushup(k, o &lt;&lt; 1 | 1, mid + 1, r); // 左半边斜率小于等于限制，只有右半边会计入答案 return pushup(k, o &lt;&lt; 1, l, mid) + T[o].ans - T[o &lt;&lt; 1].ans; // 统计左半边答案，同时直接加上右半边的答案（当前答案减去左子节点答案） &#125; 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; struct Node &#123; int ans; double k; &#125; T[400005]; double a[100005]; int pushup(double k, int o, int l, int r) &#123; if (T[o].k &lt;= k) return 0; if (a[l] > k) return T[o].ans; if (l == r) return a[l] > k; int mid = l + r >> 1; if (T[o &lt;&lt; 1].k &lt;= k) return pushup(k, o &lt;&lt; 1 | 1, mid + 1, r); return pushup(k, o &lt;&lt; 1, l, mid) + T[o].ans - T[o &lt;&lt; 1].ans; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = &#123;1, a[x]&#125;, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o].k = max(T[o &lt;&lt; 1].k, T[o &lt;&lt; 1 | 1].k); T[o].ans = T[o &lt;&lt; 1].ans + pushup(T[o &lt;&lt; 1].k, o &lt;&lt; 1 | 1, mid + 1, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); a[x] = double(y) / x; update(1, 1, n, x, y); printf(\"%d\\n\", T[1].ans); &#125; return 0; &#125; 吉司机线段树 指的是一类维护区间最值操作与历史最值的线段树。 区间最值操作 待填坑。 区间历史最值 其余内容待填坑。 CPU 监控。 考虑没有染色操作怎么做。简单，维护最大的历史加标记。 发现一次染色后所有的加都可以转化为染色，因此直接做就行。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x7fffffff; int n, m, a[100005]; struct Node &#123; int mx, hmx, setv, addv, hset, hadd, tag; void cover(int v, int hv) &#123; setv = mx = v; addv =-0; if (tag) hset = max(hset, hv); else hset = hv, tag = 1; hmx = max(hmx, hv); &#125; void add(int v, int hv) &#123; hadd = max(hadd, addv + hv); hmx = max(hmx, mx + hv); addv += v; mx += v; &#125; void change(int v, int hv) &#123; if (tag) cover(setv + v, setv + hv); else add(v, hv); &#125; &#125; T[400005]; inline void pushup(int o) &#123; T[o].mx = max(T[o &lt;&lt; 1].mx, T[o &lt;&lt; 1 | 1].mx); T[o].hmx = max(T[o &lt;&lt; 1].hmx, T[o &lt;&lt; 1 | 1].hmx); &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o].mx = T[o].hmx = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o); &#125; inline void pushdown(int o) &#123; T[o &lt;&lt; 1].change(T[o].addv, T[o].hadd); T[o &lt;&lt; 1 | 1].change(T[o].addv, T[o].hadd); T[o].addv = T[o].hadd = 0; if (T[o].tag) &#123; T[o &lt;&lt; 1].cover(T[o].setv, T[o].hset); T[o &lt;&lt; 1 | 1].cover(T[o].setv, T[o].hset); T[o].tag = 0; &#125; &#125; void update(int o, int l, int r, int x, int y, int k, bool type) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return type ? T[o].cover(k, k) : T[o].change(k, k), void(); int mid = l + r >> 1; pushdown(o); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k, type); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k, type); pushup(o); &#125; int query(int o, int l, int r, int x, int y, bool type) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return type ? T[o].hmx : T[o].mx; int mid = l + r >> 1, res = -INF; pushdown(o); if (x &lt;= mid) res = max(res, query(o &lt;&lt; 1, l, mid, x, y, type)); if (mid &lt; y) res = max(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y, type)); return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); char s[5]; int x, y, z; for (scanf(\"%d\", &amp;m); m--; ) &#123; scanf(\"%s%d%d\", s, &amp;x, &amp;y); if (s[0] == 'Q') printf(\"%d\\n\", query(1, 1, n, x, y, 0)); else if (s[0] == 'A') printf(\"%d\\n\", query(1, 1, n, x, y, 1)); else scanf(\"%d\", &amp;z), update(1, 1, n, x, y, z, s[0] == 'P' ? 0 : 1); &#125; return 0; &#125; 重构 有些对数据结构的操作较难维护，我们可以定期对整个数据结构进行 O(n)O(n)O(n) 重构，在两次重构之间的修改，则暴力处理。 操作分块 即根号重构。 二进制分组 分块系列 分块是最难的数据结构[1]。我们之前见过对于序列的各种分块，有的题相当麻烦。但是实际上分块还有许多变种应用，本节将初探这些内容。 逐块处理 如果每个块对答案的贡献独立，那么可以将询问离线，然后逐个块进行处理。这样可以做到线性空间，并且常数可以得到相当的优化。 [SNOI2022] 军队。 没有 l,rl,rl,r 的话是个经典问题，那么直接将序列分块逐块处理，不是完整的修改则暴力重构。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int BLOCK_SIZE = 5000; int n, q, C, LL, RR; int c[250005], cc[250005]; int L[505], R[505], vis[250005], cnt[250005]; i64 a[250005], ans[250005], aa[250005]; struct Query &#123; int op, l, r, x, y; &#125; Q[250005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;q, &amp;C); int t = (n - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", c + i), cc[i] = i; for (int i = 1; i &lt;= q; ++i) &#123; scanf(\"%d%d%d\", &amp;Q[i].op, &amp;Q[i].l, &amp;Q[i].r); if (Q[i].op != 3) scanf(\"%d%d\", &amp;Q[i].x, &amp;Q[i].y); &#125; for (int k = 1; k &lt;= t; ++k) &#123; LL = L[k], RR = R[k]; i64 res = 0; memset(cnt, 0, sizeof cnt); for (int i = LL; i &lt;= RR; ++i) ++cnt[c[i]], res += a[i]; for (int i = 1; i &lt;= q; ++i) &#123; int op = Q[i].op, l = Q[i].l, r = Q[i].r, x = Q[i].x, y = Q[i].y; if (r &lt; LL || l > RR) continue; if (l &lt;= LL &amp;&amp; RR &lt;= r) &#123; if (op == 1) cnt[y] += cnt[x], cnt[x] = 0; else if (op == 2) res += 1ll * cnt[x] * y; else ans[i] += res; &#125; else &#123; int bl = max(l, LL), br = min(r, RR); vector&lt;int> bin; for (int j = i - 1; j >= 1 &amp;&amp; vis[j] != k; --j) &#123; vis[j] = k; if (Q[j].r &lt; LL || Q[j].l > RR) continue; if (Q[j].op == 1) aa[Q[j].x] = aa[Q[j].y], cc[Q[j].x] = cc[Q[j].y]; else if (Q[j].op == 2) aa[Q[j].x] += Q[j].y; bin.push_back(Q[j].x); &#125; vis[i] = k; for (int j = LL; j &lt;= RR; ++j) a[j] += aa[c[j]], c[j] = cc[c[j]]; for (int x : bin) aa[x] = 0, cc[x] = x; if (op == 1) &#123; for (int j = bl; j &lt;= br; ++j) if (c[j] == x) c[j] = y, --cnt[x], ++cnt[y]; &#125; else if (op == 2) &#123; for (int j = bl; j &lt;= br; ++j) if (c[j] == x) a[j] += y, res += y; &#125; else &#123; for (int j = bl; j &lt;= br; ++j) ans[i] += a[j]; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= q; ++i) if (Q[i].op == 3) printf(\"%lld\\n\", ans[i]); return 0; &#125; Problemset 扫描线 一些简单题。 [Luogu P1502] 窗口的星星 Portal. 我们将每个星星看成一个左下角为 (x,y)(x,y)(x,y)，右上角为 (x+w−1,y+h−1)(x+w-1,y+h-1)(x+w−1,y+h−1) 的矩形，窗户看成一个点，那么使用扫描线维护平面中的最大值即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> using namespace std; typedef long long i64; struct Line &#123; int x, yl, yh, c; Line(int x = 0, int yl = 0, int yh = 0, int c = 0) : x(x), yl(yl), yh(yh), c(c) &#123;&#125; bool operator &lt; (const Line &amp;a) const &#123; // 先扫加的来保证结果正确 if (x != a.x) return x &lt; a.x; else return c > a.c; &#125; &#125;e[20005]; int n, W, H, m; int b[20005]; i64 T[80005], tag[80005]; inline void pushdown(int o) &#123; if (!tag[o]) return; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; T[o &lt;&lt; 1] += tag[o]; T[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; T[o] += k; tag[o] += k; return; &#125; pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;W, &amp;H); for (int i = 1, x, y, l; i &lt;= n; ++i) &#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;l); e[(i &lt;&lt; 1) - 1] = Line(x, y, y + H - 1, l); e[i &lt;&lt; 1] = Line(x + W - 1, y, y + H - 1, -l); b[(i &lt;&lt; 1) - 1] = y, b[i &lt;&lt; 1] = y + H - 1; &#125; sort(b + 1, b + (n &lt;&lt; 1) + 1); m = unique(b + 1, b + (n &lt;&lt; 1) + 1) - (b + 1); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) &#123; int pos1 = lower_bound(b + 1, b + m + 1, e[i].yl) - b; int pos2 = lower_bound(b + 1, b + m + 1, e[i].yh) - b; e[i].yl = pos1, e[i].yh = pos2; &#125; sort(e + 1, e + (n &lt;&lt; 1) + 1); i64 ans = 0; memset(T, 0, sizeof(T)); memset(tag, 0, sizeof(tag)); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) &#123; update(1, 1, n &lt;&lt; 1, e[i].yl, e[i].yh, e[i].c); ans = max(ans, T[1]); &#125; printf(\"%lld\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; 颜色段均摊 不一定是区间染色，有些操作也具有类似于颜色段均摊的性质。 「C.E.L.U-02」苦涩 Portal. 建立一棵线段树，每个节点保存一个优先队列作为区间加的标记，并永久化（即当前节点的优先队列中的内容对它的儿子都有效）。删除时可以暴力遍历线段树，因为每一次添加只会添加一个拥有最大数值最大的颜色段，这样删除它的时间就会在 O(log⁡n)O(\\log n)O(logn) 级别。若 n,mn,mn,m 同阶，那么总时间复杂度为 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; struct Node &#123; int maxx; priority_queue&lt;int> q; &#125; T[800005]; void pushup(int o) &#123; T[o].maxx = max(&#123;T[o &lt;&lt; 1].maxx, T[o &lt;&lt; 1 | 1].maxx, T[o].q.top()&#125;); &#125; void build(int o, int l, int r) &#123; T[o].maxx = -1; T[o].q.push(-1); if (l == r) return; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); &#125; void maketag(int o, int k) &#123; T[o].q.push(k); T[o].maxx = max(T[o].maxx, k); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, k); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); pushup(o); &#125; void remove(int o, int l, int r, int x, int y, int k) &#123; if (T[o].maxx &lt; k) return; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; if (T[o].q.top() == k) &#123; T[o].q.pop(); if (l == r) T[o].maxx = T[o].q.top(); else pushup(o); return; &#125; int mid = l + r >> 1; remove(o &lt;&lt; 1, l, mid, x, y, k); remove(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); return pushup(o); &#125; if (T[o].q.top() == k) T[o].q.pop(), maketag(o &lt;&lt; 1, k), maketag(o &lt;&lt; 1 | 1, k); int mid = l + r >> 1; if (x &lt;= mid) remove(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) remove(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); pushup(o); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].maxx; int mid = l + r >> 1, ans = T[o].q.top(); if (x &lt;= mid) ans = max(ans, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) ans = max(ans, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); build(1, 1, n); while (m--) &#123; int op, l, r, k; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) &#123; scanf(\"%d\", &amp;k); update(1, 1, n, l, r, k); &#125; else if (op == 2) &#123; k = query(1, 1, n, l, r); if (k != -1) remove(1, 1, n, l, r, k); &#125; else printf(\"%d\\n\", query(1, 1, n, l, r)); &#125; return 0; &#125; 线段树进阶用法 各种线段树！ [CF1340F] Nastya and CBS 维护一个括号序列，可以支持简单的修改，询问区间括号匹配信息，这是可以使用单侧递归结构解决的经典问题。 Portal.kkk 种括号，支持单点修改括号种类，询问区间是否为合法的括号序列。 一段括号序列怎么维护？由于线段树上的结构是不断合并的，因此在不断删去相邻的括号匹配后，如果仍然包含相向的括号（(]），那么就失配了。这样当前节点的匹配信息必定是若干右括号加若干左括号。 也就是说，线段树的当前节点存储左侧的右括号和右侧的左括号，储存时储存它们的长度和哈希值，合并的时候需要查询某个节点左右侧部分前后缀哈希值，然后进行匹配，这个过程可以直接单侧递归下去。 对于询问，将线段树上的区间抽离出来放在一个栈中，利用匹配的过程中不应有右括号这一特点不断进行匹配，看最后是否剩的元素长度为 000。 时间复杂度为 O(n+mlog⁡2n)O(n+m\\log^2 n)O(n+mlog2n)，空间复杂度为 O(n)O(n)O(n)。 查看代码 #include &lt;bits/stdc++.h> #define ls o &lt;&lt; 1 #define rs ls | 1 using namespace std; int n, m, k; int a[100005]; namespace Hash &#123; const int B1 = 10009, B2 = 254350526, P = 943236167; int _w[200010], *w = _w + 100005; void init(int n) &#123; w[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; w[i] = 1ll * w[i - 1] * B1 % P; w[-i] = 1ll * w[-i + 1] * B2 % P; &#125; &#125; struct str &#123; int l, x; str() &#123; l = x = 0; &#125; str(int v) : l(1), x(v) &#123;&#125; str(int l, int x) : l(l), x(x) &#123;&#125; friend bool operator== (str a, str b) &#123; return a.l == b.l &amp;&amp; a.x == b.x; &#125; friend str operator+ (str a, str b) &#123; return str(a.l + b.l, (a.x + 1ll * b.x * w[a.l]) % P); &#125; friend str operator- (str a, str b) &#123; return str(a.l - b.l, (0ll + a.x - b.x + P) * w[-b.l] % P); &#125; &#125;; &#125; using Hash::str; struct Node &#123; bool err; str vl, vr; Node(int x = 0) : err(0) &#123; if (x > 0) vr = x; else vl = -x; &#125; &#125; T[400005]; str gValL(int o, int k) &#123; if (!k) return str(); if (k == T[o].vl.l) return T[o].vl; if (k &lt;= T[ls].vl.l) return gValL(ls, k); return T[ls].vl + (gValL(rs, k - T[ls].vl.l + T[ls].vr.l) - T[ls].vr); &#125; str gValR(int o, int k) &#123; if (!k) return str(); if (k == T[o].vr.l) return T[o].vr; if (k &lt;= T[rs].vr.l) return gValR(rs, k); return T[rs].vr + (gValR(ls, k - T[rs].vr.l + T[rs].vl.l) - T[rs].vl); &#125; inline void pushup(int o) &#123; if (T[ls].err || T[rs].err) return T[o].err = 1, void(); T[o].err = 0; T[o].vl = T[ls].vl, T[o].vr = T[rs].vr; if (T[ls].vr.l &lt;= T[rs].vl.l) &#123; // 左半段合并到右半段 if (T[ls].vr == gValL(rs, T[ls].vr.l)) T[o].vl = T[o].vl + (T[rs].vl - T[ls].vr); else T[o].err = 1; &#125; else &#123; if (T[rs].vl == gValR(ls, T[rs].vl.l)) T[o].vr = T[o].vr + (T[ls].vr - T[rs].vl); else T[o].err = 1; &#125; &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o] = Node(a[l]), void(); int mid = l + r >> 1; build(ls, l, mid); build(rs, mid + 1, r); pushup(o); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(ls, l, mid, x, k); else update(rs, mid + 1, r, x, k); pushup(o); &#125; int st[50], tot; void get(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return st[++tot] = o, void(); int mid = l + r >> 1; if (x &lt;= mid) get(ls, l, mid, x, y); if (mid &lt; y) get(rs, mid + 1, r, x, y); &#125; str seq[50]; str gVal(int o, int k) &#123; if (!k) return str(); if (k == seq[o].l) return seq[o]; if (k &lt;= T[st[o]].vr.l) return gValR(st[o], k); return T[st[o]].vr + (gVal(o - 1, k - T[st[o]].vr.l + T[st[o]].vl.l) - T[st[o]].vl); &#125; bool query(int l, int r) &#123; tot = 0; get(1, 1, n, l, r); for (int i = 1; i &lt;= tot; ++i) &#123; if (T[st[i]].err) return 0; if (seq[i - 1].l &lt; T[st[i]].vl.l) return 0; if (T[st[i]].vl == gVal(i - 1, T[st[i]].vl.l)) seq[i] = T[st[i]].vr + (seq[i - 1] - T[st[i]].vl); else return 0; &#125; return !seq[tot].l; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); Hash::init(n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); for (scanf(\"%d\", &amp;m); m--; ) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) update(1, 1, n, x, y); else puts(query(x, y) ? \"Yes\" : \"No\"); &#125; return 0; &#125; 根号技巧 一些根号杂题。 大分块系列 由于它们都比较经典，故此放在这里。 突刺贯穿的第二分块 | [Ynoi2018] 五彩斑斓的世界 Portal. 神秘的修改+神秘的查询，怎么搞？发现其值域小得可怜，而且时限很大，空限却很小。 离线，逐块处理（因为空间限制实在太小，想要预处理任何信息都是不可能的）。我们需要一个可以在 O(m)O(m)O(m) 完成单个块内处理的算法。 记块内最大值为 kkk，那么： k≤2xk\\le 2xk≤2x，令大于 xxx 的数减去 xxx 后就没有比 xxx 大的数了，kkk 会减小至少 k−xk-xk−x； k&gt;2xk&gt;2xk&gt;2x，令小于等于 xxx 的数加上 xxx，就没有比 xxx 小的数了。然后打上全局减标记，kkk 在操作后减少至少 xxx。 发现这个 kkk 单调不增，那么时间复杂度为 O(V)O(V)O(V)。 维护数值时直接采用并查集，记录集合的大小。零散块修改直接重构，整块则直接维护。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 900; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x; &#125; void print(int x) &#123; if (x > 9) print(x / 10); putchar_unlocked(x % 10 ^ 48); &#125; int n, m, LL, RR, tag, mx, op, l, r, x; int a[1000005], Ans[500005]; int L[2005], R[2005]; int fa[1000005], root[100005], cnt[100005], val[1000005]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; inline void merge(int x, int y) &#123; if (root[y]) fa[root[x]] = root[y]; else root[y] = root[x], val[root[y]] = y; cnt[y] += cnt[x]; root[x] = cnt[x] = 0; &#125; struct Operation &#123; int op, l, r, x; &#125; Q[500005]; inline void build(void) &#123; mx = tag = 0; for (int i = LL; i &lt;= RR; ++i) &#123; mx = max(mx, a[i]); if (root[a[i]]) fa[i] = root[a[i]]; else root[a[i]] = fa[i] = i, val[i] = a[i]; ++cnt[a[i]]; &#125; &#125; inline void rebuild(void) &#123; for (int i = LL; i &lt;= RR; ++i) &#123; a[i] = val[find(i)]; root[a[i]] = cnt[a[i]] = 0; a[i] -= tag; &#125; for (int i = LL; i &lt;= RR; ++i) val[i] = 0; int ql = max(l, LL), qr = min(r, RR); for (int i = ql; i &lt;= qr; ++i) if (a[i] > x) a[i] -= x; build(); &#125; inline void modify(void) &#123; if (x * 2 > mx - tag) &#123; for (int i = x + 1 + tag; i &lt;= mx; ++i) if (root[i]) merge(i, i - x); mx = min(mx, x + tag); &#125; else &#123; for (int i = tag; i &lt;= x + tag; ++i) if (root[i]) merge(i, i + x); tag += x; &#125; &#125; inline int get(void) &#123; int ql = max(l, LL), qr = min(r, RR), res = 0; for (int j = ql; j &lt;= qr; ++j) if (val[find(j)] == x + tag) ++res; return res; &#125; int main(void) &#123; n = read(); m = read(); int t = (n - 1) / BLOCK_SIZE + 1; for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; R[t] = n; for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= m; ++i) Q[i].op = read(), Q[i].l = read(), Q[i].r = read(), Q[i].x = read(); for (int k = 1; k &lt;= t; ++k) &#123; LL = L[k], RR = R[k]; build(); for (int i = 1; i &lt;= m; ++i) &#123; op = Q[i].op, l = Q[i].l, r = Q[i].r, x = Q[i].x; if (r &lt; LL || l > RR) continue; if (op == 1) &#123; if (x == 0) continue; if (l &lt;= LL &amp;&amp; RR &lt;= r) modify(); else rebuild(); &#125; else &#123; if (x + tag > 100001) continue; if (l &lt;= LL &amp;&amp; RR &lt;= r) Ans[i] += cnt[x + tag]; else Ans[i] += get(); &#125; &#125; if (k != t) memset(root, 0, sizeof root), memset(cnt, 0, sizeof cnt); &#125; for (int i = 1; i &lt;= m; ++i) if (Q[i].op == 2) print(Ans[i]), putchar_unlocked('\\n'); return 0; &#125; 弑尽破净的第四分块 | [Ynoi2018] 天降之物 Portal. 本题存在序列分块做法，但对于本题来说根号分治可以做得更好。 考虑一个最暴力的做法，将所有数的位置放在 vector 中，然后直接暴力扫。对于出现次数多的数预处理出答案然后将 vector 清空。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 500; const int INF = 1e9; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x; &#125; int n, m, a[100005], siz[100005], F[100005], tot, id[100005], ans[230][100005]; vector&lt;int> v[100005]; inline int calc(int x, int y) &#123; // 对于 y 计算 x int i = 0, j = 0, ans = INF, sx = v[x].size(), sy = v[y].size(); if (!sx || !sy) return INF; while (i &lt; sx &amp;&amp; j &lt; sy) &#123; if (v[x][i] > v[y][j]) ans = min(ans, v[x][i] - v[y][j++]); else ans = min(ans, v[y][j] - v[x][i++]); &#125; if (i &lt; sx) ans = min(ans, abs(v[x][i] - v[y][sy - 1])); if (j &lt; sy) ans = min(ans, abs(v[x][sx - 1] - v[y][j])); return ans; &#125; inline int query(int x, int y) &#123; x = F[x], y = F[y]; if (!siz[x] || !siz[y]) return -1; if (x == y) return 0; if (siz[x] > siz[y]) swap(x, y); if (siz[y] &lt;= BLOCK_SIZE) return calc(x, y); if (siz[x] &lt;= BLOCK_SIZE) return min(ans[id[y]][x], calc(x, y)); return min(&#123;ans[id[y]][x], ans[id[x]][y], calc(x, y)&#125;); &#125; inline void build(int x, int ID = 0) &#123; // 处理 x, 存储在 ID 的答案 if (ID) id[x] = ID; else id[x] = ++tot; int t = id[x]; memset(ans[t], 0x3f, sizeof ans[t]); for (int i = 1, j = INF; i &lt;= n; ++i) if (a[i] == x) j = 0; else ans[t][a[i]] = min(ans[t][a[i]], ++j); for (int i = n, j = INF; i >= 1; --i) if (a[i] == x) j = 0; else ans[t][a[i]] = min(ans[t][a[i]], ++j); ans[t][x] = 0; vector&lt;int> cl; v[x].swap(cl); &#125; inline void merge(int x, int y) &#123; // 将 x 中的元素合并到 y int i = 0, j = 0, sx = v[x].size(), sy = v[y].size(); vector&lt;int> res; while (i &lt; sx &amp;&amp; j &lt; sy) &#123; if (v[x][i] &lt; v[y][j]) res.emplace_back(v[x][i++]); else res.emplace_back(v[y][j++]); &#125; while (i &lt; sx) res.emplace_back(v[x][i++]); while (j &lt; sy) res.emplace_back(v[y][j++]); v[y] = res; &#125; inline void update(int x, int y) &#123; // 所有 x -> y int x_ = F[x], y_ = F[y]; if (!siz[x_] || x_ == y_) return; if (siz[x_] > siz[y_]) F[y] = x_, F[x] = n + 1, swap(x_, y_); else F[x] = n + 1; if (x_ > n || y_ > n) return; x = x_, y = y_; if (siz[y] &lt;= BLOCK_SIZE) &#123; if (siz[x] + siz[y] &lt;= BLOCK_SIZE) &#123; for (int i : v[x]) a[i] = y; for (int i = 1; i &lt;= tot; ++i) ans[i][y] = min(ans[i][y], ans[i][x]); merge(x, y); &#125; else &#123; for (int i = 1; i &lt;= n; ++i) if (a[i] == x) a[i] = y; build(y); &#125; &#125; else if (siz[x] &lt;= BLOCK_SIZE) &#123; if (siz[x] + v[y].size() &lt;= BLOCK_SIZE) &#123; for (int i : v[x]) a[i] = y; for (int i = 1; i &lt;= tot; ++i) ans[i][y] = min(ans[i][y], ans[i][x]); merge(x, y); &#125; else &#123; for (int i = 1; i &lt;= n; ++i) if (a[i] == x) a[i] = y; build(y, id[y]); &#125; &#125; else &#123; for (int i = 1; i &lt;= n; ++i) if (a[i] == x) a[i] = y; build(y, id[y]); &#125; siz[y] += siz[x]; siz[x] = 0; vector&lt;int> cl; v[x].swap(cl); &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) v[a[i] = read()].emplace_back(i), F[i] = i, ++siz[a[i]]; for (int i = 1; i &lt;= n; ++i) if (siz[i] > BLOCK_SIZE) build(i); for (int last = 0; m--; ) &#123; int op = read(), x = read() ^ last, y = read() ^ last; if (op == 1) update(x, y); else &#123; last = query(x, y); if (last == -1) last = 0, puts(\"Ikaros\"); else printf(\"%d\\n\", last); &#125; &#125; return 0; &#125; 数据结构综合 这里是一些综合性 DS 难题。 根本原因是分块基本上就是暴力，而越是暴力的算法可扩展性就越强，能解决的问题就越多，因此题就可以变得相当复杂。 ↩︎","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"算法竞赛/学习笔记/数据结构","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二叉搜索树与平衡树","slug":"notes/DS/BST","date":"2022-12-28T00:00:00.000Z","updated":"2022-12-28T00:00:00.000Z","comments":true,"path":"9fce88cb/","link":"","permalink":"https://james1badcreeper.github.io/9fce88cb/","excerpt":"二叉搜索树（Binary Search Tree, BST）是一种二叉树的树形数据结构，能高效地解决许多其它数据结构所不能解决的问题，但由于自身是一个不稳定，容易退化的数据结构，所以需要用特殊手段保证其平衡。","text":"二叉搜索树（Binary Search Tree, BST）是一种二叉树的树形数据结构，能高效地解决许多其它数据结构所不能解决的问题，但由于自身是一个不稳定，容易退化的数据结构，所以需要用特殊手段保证其平衡。 更新日志 2023/10/12完成预定所有内容。 概念 二叉树有一种性质叫做二叉搜索树性质，就是说对于树中的一个节点，它的键值不小于它左子树的键值，不大于它右子树的键值，这就是所谓的“BST 性质”。 BST 的递归定义如下： 空树是 BST； 若 BST 的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值； 若 BST 的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值； BST 的左右子树均为 BST； BST 集合是满足 1、2、3、4 的最小二叉树集。 所以输出 BST 的中序遍历就是原序列排序的结果。 需要注意的是，一般的，BST 所有节点的键值都不相等。 普通 BST 模板。您需要写一种数据结构，来维护一些数（ 都是 10910^9109 以内的数字）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数 qqq 不超过 10410^4104：查询 xxx 数的排名（排名定义为比当前数小的数的个数 +1+1+1。若有多个相同的数，应输出最小的排名）。查询排名为 xxx 的数。求 xxx 的前驱（前驱定义为小于 xxx，且最大的数）。若未找到则输出 −2147483647-2147483647−2147483647。求 xxx 的后继（后继定义为大于 xxx，且最小的数）。若未找到则输出 214748364721474836472147483647。插入一个数 xxx。 BST 的节点会这样定义： struct Node &#123; int l, r; // 左右儿子 int val; // 键值 int cnt, size; // 表示这个节点数个个数，和子树的大小 &#125;T[maxn]; 辅助函数如下： int tot = 0; inline int newNode(int val) // 新建节点，并返回编号 &#123; T[++tot] = val; T[tot].size = T[tot].cnt = 1; return tot; &#125; inline void maintain(int p) &#123; // 维护当前节点的信息 T[p].size = T[T[p].l].size + T[T[p].r].size + T[p].cnt; &#125; 为了使边界处理情况更为方便，我们会插入一个 INF 节点和一个 -INF 节点，这样建树： int root = 1; // 定义根节点，必须这么做的原因是在平衡树中会出现树根改变的情况 const int INF = 2147483647; // 定义 INF void build(void) &#123; newNode(-INF), newNode(INF); root = 1, T[1].r = 2; &#125; 求排名： int Rank(int p, int val) &#123; if (p == 0) return 1; // 只有在此 val 不存在时才会访问到 0 号节点，根据定义，排名应该 +1，所以返回 1。 // 在不同情况下这里会返回不同的值，比如如果次数不存在输出 -1 这里就应该返回 ERROR_BAD_USAGE，若数不存在就不用 +1，则返回 0。 if (val == T[p].val) return T[T[p].l].size + 1; // 找到节点，返回 if (val &lt; T[p].val) return Rank(T[p].l, val); // 小，在左子树中找 return Rank(T[p].r, val) + T[T[p].l].size + T[p].cnt; // 大，右子树找，注意要加上左子树和此节点 &#125; 求排名为 kkk 的数： int kth(int p, int rnk) &#123; if (p == 0) return INF; // 0 意味着当前树上的节点数小于 rnk，返回 INF if (T[T[p].l].size >= rnk) return kth(T[p].l, rnk); // 在左子节点 if (T[T[p].l].size + T[p].num >= rnk) return T[p].val; // 当前节点 return kth(T[p].r, rnk - T[T[p].l].size - T[p].cnt); // 右子节点 &#125; 怎么查前驱呢？初始 ans = 1，检索 val，有三种可能的结果： BST 中没有 val。后继一定在已经遍历的节点中，这一点可以用微扰来证明。 有 val 节点，但是这个节点没有右子树。这种情况的答案同 1。 有 val 节点，有右子树。答案是右子树的最低端。 代码（请读者自行实现后继）： inline int GetPre(int val) &#123; int ans = 1, p = root; // T[1].val == -INF while (p) &#123; if (val == T[p].val) &#123; if (T[p].l) &#123; // 存在左子节点 p = T[p].l; while (T[p].r) p = T[p].r; // 使劲往右走 ans = p; &#125; break; &#125; if (T[p].val &lt; val &amp;&amp; T[p].val > T[ans].val) ans = p; // 尝试更新 ans p = val &lt; T[p].val ? T[p].l : T[p].r; // 遍历 &#125; return T[ans].val; &#125; 当然前驱和后继也可以直接使用 Rank 和 kth 函数实现，大概像这样： kth(root, Rank(root, x) - 1) // 前驱 kth(root, Rank(root, x) + 1) // 后继，但是应该写成 kth(root, Rank(root, x + 1)) 由于这里是严格大于和严格小于，所以说排名不能简单地写成 +1，边界条件非常容易写错，所以还是推荐大家来写前驱后继函数。也可以以采用递归的形式： int GetPre(int p, int k) &#123; if (!p) return -INF; if (T[p].val >= k) return GetPre(T[p].ch[0], k); return max(T[p].val, GetPre(T[p].ch[1], k)); &#125; 插入的代码非常好写： void insert(int &amp;p, int val) // p 是父亲节点 &#123; if (p == 0) return p = newNode(val), void(); if (val == T[p].val) &#123; // 有这一键值 ++T[p].cnt; // 将个数加上 1 maintain(p); return; &#125; // 接下来看它是在左子树还是在右子树 if (val &lt; T[p].val) insert(T[p].l, val); // 根据 BST 的定义，在左子树 else insert(T[p].r, val); // 在右子树 maintain(p); // 由于进行了插入，当前节点的信息需要重新计算 &#125; 注意我们在有这一键值的时候并没有重新计算父亲节点，因为插入是递归进行的，父亲节点的附加信息一定会被重新计算。 平衡 BST 但是这样的 BST 的时间复杂度是假的，因为如果插入 1 2 3 4 5 6 7，它就会变成一条链。 简介 表达同种意思的 BST 有多种，有平衡的，有不平衡的。在数据随机的情况下，它就是平衡的。不平衡怎么办？给他搞成平衡的呗。 那为什么平衡树有快有慢呢？这是因为，越快的平衡树能使平衡树越满。但有些平衡树实现过于复杂，比如红黑树（Red-Black Tree，简称 RBT），它的插入有 555 种情况，删除有 666 种情况，在考场上根本打不出来（当然工程中你必须打），所以一般情况下我们不使用红黑树。 但要注意的是，尽量不要在考场手写上写平衡树。若 STL 能满足要求，就使用 STL。STL 的红黑树开了 O2 以后，跑得比大多数手写平衡树都要快（不信你可以学完平衡树后自己实现一个山寨版的 set 来和 STL 比比速度）。尽量不要自己再造轮子，造不好就被碾着腿了。 在工程中，常用的平衡树是 AVL、RBT 和 B 树（B 树不是二叉树，而是多叉的）；而在竞赛中，常用的则是 Treap 和 Splay（伸展树）。当然还有诸如 WBLT，替罪羊树等平衡树。本文会介绍旋转 Treap、Splay 和非旋 Treap（FHQ-Treap）。 平衡的思路 有三种：旋转，分裂与合并，重构。 但它们的目的都是相同的：平衡我们的二叉搜索树。 对于旋转，有单旋转和双旋转。单旋指一个节点和它的父亲转，双旋还会涉及到它的爷爷。 下面将介绍几种最为常用的平衡树。 Treap 这是一种最基础的平衡树，代码与普通的二叉搜索树差不了多少。但如果要实现名次树，它的速度是非常快的（OI 中常用的平衡树中最快）。 接下来我们要用 Treap 实现名次树（因为所有操作都是围绕排名来进行的，所以叫做名次树），模板。 原理 Treap 是一种弱平衡 BST（是指不会为了把自己搞成除了最后一层不是满的二叉树而过多的变换自己的形态，AVL 便是严格平衡树），它是一个合成词，有 Treap = Tree + Heap，所以 Treap 又叫做树堆（怎么听上去那么搞笑）。 Treap 有两种形式，无旋式有旋转式。无旋式能做到快速分裂与合并，就是 FHQ-Treap。 回到刚才所说的树堆中。Treap 除了节点的权值满足二叉搜索树性质以外，它的附加权值还满足堆性质（这里统一为大根堆性质）。这样就可以证明如果每个节点的附加权值全不同，那么 Treap 的形态是唯一的（但不一样也不影响我们干活）。 普通的 BST 在随机情况下就是平衡的。Treap 通过人为制造随机，随机赋予节点的附加权值。由于堆是一棵完全二叉树，所以 Treap 是期望平衡的，单次操作期望复杂度 O(log⁡n)O(\\log n)O(logn)。 理论上应该没有毒瘤来卡你。 关键是旋转，怎么转？可以看这张图： zig(y) 代表 y 旋转前处于父亲节点，然后右旋至它的右子节点；zag(x) 是左旋，旋转到它的左子节点。圆形代表节点，三角代表子树。 当 yyy 右旋时，它会移到它的右子节点的位置，将他它左子节点 xxx 移到它原来的位置，而由于 xxx 的右子树 BBB 不能再属于 xxx 了，而根据 BST 的定义，B&lt;yB&lt;yB&lt;y，所以 BBB 变成了 yyy 的左子树。另外，当旋转之后，xxx 和 yyy 的附加信息都需要重新计算，而且 yyy 是 xxx 的儿子，所以先维护 yyy 再维护 xxx。 左旋类似，这里留给读者自己撕烤。 实现 接下来我们要干一件大事：推翻我们以前 BST 的写法。 为什么？因为它实在是太容易出错了。如果你感觉很难接受，没关系，在文中我们还会介绍各种写法及其优劣。 首先是节点的定义，像这样： struct Node &#123; int ch[2]; // 左右儿子的编号 int val, dat; // 键值和随机权值 int size, cnt; // 子树大小和此节点的值的个数 &#125;T[maxn]; 可以发现变化是将左右儿子和到了一起。这是为了方便实现旋转。更加激进的写法是: struct Node &#123; Node *ch[2]; // 左右儿子 int val, dat; int size, cnt; &#125;; 看见什么了？指针？的确如此。这种方法的好处多多，第一会使你的代码更加流畅，不会出现数组套数组的窘况。二是会节省一些内存。但考虑到竞赛中不要使用指针的基本原则（虽然工程中这种写法是必备的），接下来的代码统一采用数组伪指针的形式。 实际上还有另一种记录节点的方式，就是多记录每个节点的父亲。虽然这种做法在下文要介绍的伸展树中比较常见，但在 Treap 中，它的优点是旋转时可以更自然的对一个节点进行旋转，而不是在函数调用中写先定义好的父亲。如果你想学习这种写法，学完接下来介绍的 Splay 后你就可以给它迁移过来辣！ 首先是一些基本定义，如下： Node T[100005]; int tot; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + T[p].cnt; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(); T[tot].size = T[tot].cnt = 1; return tot; &#125; 唯一值得注意的是 dat 值的设置，随机一个数即可。 然后是旋转。旋转的原理已经了解过了，这里再次放出那张图，然后直接阅读下面的代码（同时进行手动模拟，对着每个节点转，就是改变这个节点的信息，不要对着图中的位置转）： 当 yyy 右旋时，它会移到它的右子节点的位置，将他它左子节点 xxx 移到它原来的位置，而由于 xxx 的右子树 BBB 不能再属于 xxx 了，而根据 BST 的定义，B&lt;yB&lt;yB&lt;y，所以 BBB 变成了 yyy 的左子树。另外，当旋转之后，xxx 和 yyy 的附加信息都需要重新计算，而且 yyy 是 xxx 的儿子，所以先维护 yyy 再维护 xxx。 zig(y) 代表 y 旋转前处于父亲节点，然后右旋至它的右子节点；zag(x) 是左旋，旋转到它的左子节点。圆形代表节点，三角代表子树。 inline void rotate(int &amp;p, int d) // 绕着 p 点旋转，d = 0 左旋，d = 1 右旋，d^1 = 1-d &#123; int q = T[p].ch[d^1]; // 找到 p 的儿子，这个儿子将要旋转到根上 T[p].ch[d^1] = T[q].ch[d]; // 接下自己的儿子要丢的儿子，因为自己要变成自己的儿子的儿子了 T[q].ch[d] = p; // 原来儿子的儿子设为原来的爸爸 p = q; // 原来的儿子正式登上爸爸的宝座，注意 p 是引用 maintain(T[p].ch[d]), maintain(p); // 从下到上重新计算附加信息 &#125; 注意某些节点旋转后，附加节点的信息就必须重新计算，而且要注意计算顺序。但某些文章你会看到类似这样的旋转： inline void zig(int &amp;p) // 右旋 &#123; int q = T[p].l; T[p].l = T[q].r, T[q].r = p, p = q; maintain(T[p].r), maintain(p); &#125; inline void zag(int &amp;p) // 左旋 &#123; int q = T[p].r; T[p].r = T[q].l, T[q].l = p, p = q; maintain(T[p].l), maintain(p); &#125; 这也是对的，但是把一个函数就能完成的内容拆到两个函数里实属麻烦，而且到后来你会发现，zig zag 就是个屎坑，千万别跳，千万别跳，千万别跳，三体警告。 然后是插入操作，只需要在不符合堆性质的时候进行旋转维护堆性质即可，代码如下： void insert(int &amp;p, int val) &#123; if (p == 0) // 此节点不存在，直接新建 &#123; p = newNode(val); return; &#125; if (val == T[p].val) ++T[p].cnt; // 存在这一键值，计数 +1 else &#123; // 这种方式能极大地简化代码 int d = (val &lt; T[p].val ? 0 : 1); insert(T[p].ch[d], val); if (T[T[p].ch[d]].dat > T[p].dat) rotate(p, d^1); // 不符合堆性质，儿子比父亲大，将儿子转到父亲的位置上 &#125; maintain(p); &#125; 常规的 Rank kth GetPre GetNext 操作和普通 BST 没有什么区别，留给读者自行实现。 最后是 Remove 操作。为什么普通 BST 没有 Remove 操作呢？因为 Remove 操作意味着对二叉搜索树性质的复杂维护。但是 Treap 不一样，它支持旋转。我们只需要把要删除的节点转成叶子节点，然后直接删除即可。代码如下： void Remove(int &amp;p, int val) &#123; if (p == 0) return; if (T[p].val == val) &#123; if (T[p].cnt > 1) // 这个节点多于 1 &#123; --T[p].cnt; maintain(p); return; &#125; if (T[p].ch[0] || T[p].ch[1]) &#123; int d = (T[p].ch[1] == 0 || T[T[p].ch[0]].dat > T[T[p].ch[1]].dat) ? 1 : 0; // 维护大根堆性质的前提下选择转到哪个方向 rotate(p, d); // 将要删除的节点 p 转到儿子的位置上 Remove(T[p].ch[d], val); maintain(p); // 此时节点的附加信息要重新计算 &#125; else p = 0; // 叶子节点直接删除 return; &#125; Remove(T[p].ch[val &lt; T[p].val ? 0 : 1], val); // 递归删除 maintain(p); &#125; 合并后代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 2147483647; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; struct Node &#123; int ch[2]; int val, dat; int size, cnt; &#125;; class Treap &#123; private: Node T[1100005]; int tot; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + T[p].cnt; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(); T[tot].size = T[tot].cnt = 1; return tot; &#125; inline void rotate(int &amp;p, int d) &#123; int q = T[p].ch[d^1]; T[p].ch[d^1] = T[q].ch[d], T[q].ch[d] = p, p = q; maintain(T[p].ch[d]), maintain(p); &#125; public: int root; inline void build(void) &#123; srand(time(0)); // 不写这个，小心毒瘤 Hack 你 newNode(-INF), newNode(INF); T[1].ch[1] = 2, root = 1; maintain(root); &#125; void insert(int &amp;p, int val) &#123; if (p == 0) &#123; p = newNode(val); return; &#125; if (val == T[p].val) ++T[p].cnt; else &#123; int d = (val &lt; T[p].val ? 0 : 1); insert(T[p].ch[d], val); if (T[T[p].ch[d]].dat > T[p].dat) rotate(p, d^1); &#125; maintain(p); &#125; int Rank(int p, int val) &#123; if (p == 0) return 1; if (val == T[p].val) return T[T[p].ch[0]].size + 1; if (val &lt; T[p].val) return Rank(T[p].ch[0], val); return Rank(T[p].ch[1], val) + T[T[p].ch[0]].size + T[p].cnt; &#125; int kth(int p, int rnk) &#123; if (p == 0) return INF; if (rnk &lt;= T[T[p].ch[0]].size) return kth(T[p].ch[0], rnk); if (rnk &lt;= T[T[p].ch[0]].size + T[p].cnt) return T[p].val; return kth(T[p].ch[1], rnk - T[T[p].ch[0]].size - T[p].cnt); &#125; inline int GetPre(int val) &#123; int ans = 1, p = root; while (p) &#123; if (val == T[p].val) &#123; if (T[p].ch[0]) &#123; p = T[p].ch[0]; while (T[p].ch[1]) p = T[p].ch[1]; ans = p; &#125; break; &#125; if (T[p].val &lt; val &amp;&amp; T[p].val > T[ans].val) ans = p; p = T[p].ch[val &lt; T[p].val ? 0 : 1]; &#125; return T[ans].val; &#125; inline int GetNext(int val) &#123; int ans = 2, p = root; while (p) &#123; if (val == T[p].val) &#123; if (T[p].ch[1]) &#123; p = T[p].ch[1]; while (T[p].ch[0]) p = T[p].ch[0]; ans = p; &#125; break; &#125; if (T[p].val > val &amp;&amp; T[p].val &lt; T[ans].val) ans = p; p = T[p].ch[val &lt; T[p].val ? 0 : 1]; &#125; return T[ans].val; &#125; inline void Remove(int &amp;p, int val) &#123; if (p == 0) return; if (T[p].val == val) &#123; if (T[p].cnt > 1) &#123; --T[p].cnt; maintain(p); return; &#125; if (T[p].ch[0] || T[p].ch[1]) &#123; int d = (T[p].ch[1] == 0 || T[T[p].ch[0]].dat > T[T[p].ch[1]].dat) ? 1 : 0; rotate(p, d); Remove(T[p].ch[d], val); maintain(p); &#125; else p = 0; return; &#125; Remove(T[p].ch[val &lt; T[p].val ? 0 : 1], val); maintain(p); &#125; &#125;T; int main(void) &#123; int n = read(), m = read(); T.build(); while (n--) T.insert(T.root, read()); int ans = 0, last = 0; while (m--) &#123; int opt = read(), x = read(); x ^= last; if (opt == 1) T.insert(T.root, x); else if (opt == 2) T.Remove(T.root, x); else if (opt == 3) last = T.Rank(T.root, x) - 1; else if (opt == 4) last = T.kth(T.root, x + 1); else if (opt == 5) last = T.GetPre(x); else last = T.GetNext(x); if (opt > 2) ans ^= last; &#125; printf(\"%d\\n\", ans); return 0; &#125; FHQ-Treap 正常的 Treap 并不支持分裂与合并，但是由范浩强提出的无旋 Treap 可以快速地分裂与合并，实现 Splay 的大部分功能，而且效率比 Splay 高很多。 这种平衡树甚至被称为“最好写的平衡树”，情况远远没有 Splay 那么复杂。 实现 所有 Treap 的基本模板都适用，但是要注意，我们不再记录一个 valvalval 出现的次数 cntcntcnt，因为基于分裂与合并实现的平衡树没办法简单的实现找的一个节点的位置。但是不用担心，即使不记录 cntcntcnt，树中的节点键值可以重复，它依然可以正常工作。 struct Node &#123; int ch[2]; int size; int val, dat; &#125; T[1100005]; int tot = 0; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + 1; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(), T[tot].size = 1; return tot; &#125; int main(void) &#123; srand(time(0)); &#125; 分裂与合并 由于 FHQ 并不支持旋转，所以一切维护平衡的手段都依赖于分裂与合并，其时间复杂度均为 O(log⁡n)O(\\log n)O(logn)。 什么是平衡树的分裂与合并呢？简单地说，之前的平衡树之能有一个根，但是现在可以有多个。由于 BST 的递归性质，所以可以很方便地合并两个 BST。 分裂 按 val 分裂。按照键值 val 将 Treap 分裂成两棵子树，其中一棵树 xxx 的值全部小于等于 valvalval，剩下的是另外一棵 yyy 全部大于 valvalval 的。 函数定义为 split(p, key, x, y)，代表遍历到 ppp，根据 keykeykey 作为键值分裂成两棵子树 x,yx,yx,y。具体怎么做呢？ 如果 val[p]≤keyval[p]\\le keyval[p]≤key，那么应该被放到 xxx 上，否则被放到 yyy 上。而放在子树中的具体哪一个位置？很显然需要递归进行。 void split(int p, int key, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); // 空了，分裂之后都是 0 if (T[p].val &lt;= key) &#123; // p 应该被分裂到 x 上 x = p; // 让 p 作为 x 的根，现在左子树全归 x 了 split(T[p].ch[1], key, T[p].ch[1], y); // 开始分裂右子树，右子树中有 &lt;= key 的应该给 x 的右子树 &#125; else &#123; y = p; split(T[p].ch[0], key, x, T[p].ch[0]); &#125; maintain(p); // 当前节点的信息需要重新计算 &#125; 按 size 分裂。按照子树的大小，前 sizsizsiz 给 xxx，剩余的给 yyy，也很容易实现。 void split(int p, int siz, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[T[p].ch[0]].size + 1 &lt;= siz) &#123; // p 应该被分裂到 x 上 x = p; // 让 p 作为 x 的根，现在左子树全归 x 了 split(T[p].ch[1], siz - T[T[p].ch[0]].size - 1, T[p].ch[1], y); // 开始分裂右子树，右子树中应有 siz - p->l->size - 1 归 x &#125; else &#123; y = p; split(T[p].ch[0], siz, x, T[p].ch[0]); &#125; maintain(p); &#125; 合并 合并的时候显然要求 xxx 中的每一个节点都小于 yyy 中的每一个节点，然后根据 Treap 的堆性质来判断是将 xxx 合并到 yyy 还是将 yyy 合并到 xxx。 int merge(int x, int y) // 要求 x 中的每一个节点都小于 y 中的每一个节点 &#123; if (x == 0 || y == 0) return x + y; // 有一棵是空的，那么返回另一棵 if (T[x].dat > T[y].dat) // 需要维护大根堆性质，将 y 合并到 x &#123; T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; 实现名次树 分裂与合并是 FHQ-Treap 的核心操作，剩下的所有操作都基于分裂与合并。 插入 将 keykeykey 分裂出来，然后合并三次即可。 void insert(int key) &#123; int x, y; split(root, key - 1, x, y); // 到时候 val 的左子节点是 x，右子节点是 y root = merge(merge(x, newNode(key)), y); &#125; 删除 分裂两次将 keykeykey 分裂出来，然后进行删除。 void Remove(int key) &#123; // 将 root 按照 key 分裂成 x, z // 将 x 按照 key - 1 分裂成 x, y // 这时 x &lt; key, y = key, z > key // y 中的只需要删一个 // 如果删去所有的，那么合并时直接 root = merge(x, z) int x, y, z; split(root, key, x, z); split(x, key - 1, x, y); if (y) y = merge(T[y].ch[0], T[y].ch[1]); root = merge(merge(x, y), z); &#125; 求排名 将 keykeykey 分裂出来，然后就是 xxx 树的大小 +1 了。 int Rank(int key) &#123; int x, y, ans; split(root, key - 1, x, y); ans = T[x].size + 1; // 排名等于 &lt; key 的个数 +1 root = merge(x, y); // 再把它合并回去，还原现场 return ans; &#125; 求 k 小 有两种方式，但是比较推荐类似于之前普通 BST 的方式。 另一种是利用基于大小的分裂，但是这样代码会变多。 前驱后继 对于前驱，将小于的分裂出来，然后再这棵树上尽可能往右走。后继大致同理。 int GetPre(int key) &#123; int x, y, p, ans; split(root, key - 1, x, y); // 找到小于等于的 p = x; while (T[p].ch[1]) p = T[p].ch[1]; // 尽可能往右走 ans = T[p].val; // 在还原现场之前先记录答案 root = merge(x, y); return ans; &#125; int GetNext(int key) &#123; int x, y, p, ans; split(root, key, x, y); p = y; while (T[p].ch[0]) p = T[p].ch[0]; ans = T[p].val; root = merge(x, y); return ans; &#125; 性能 FHQ-Treap 通过平衡树模板的代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstdlib> #include &lt;ctime> using namespace std; struct Node &#123; int ch[2], size; int val, dat; &#125; T[1100005]; int tot = 0, root; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + 1; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(), T[tot].size = 1; return tot; &#125; void split(int p, int key, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[p].val &lt;= key) &#123; x = p; split(T[p].ch[1], key, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], key, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].dat > T[y].dat) &#123; T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; void insert(int key) &#123; int x, y; split(root, key - 1, x, y); root = merge(merge(x, newNode(key)), y); &#125; void Remove(int key) &#123; int x, y, z; split(root, key, x, z); split(x, key - 1, x, y); if (y) y = merge(T[y].ch[0], T[y].ch[1]); root = merge(merge(x, y), z); &#125; int Rank(int key) &#123; int x, y, ans; split(root, key - 1, x, y); ans = T[x].size + 1; root = merge(x, y); return ans; &#125; int kth(int rnk) &#123; int p = root; while (p) &#123; if (T[T[p].ch[0]].size + 1 == rnk) break; else if (T[T[p].ch[0]].size + 1 > rnk) p = T[p].ch[0]; else &#123; rnk -= T[T[p].ch[0]].size + 1; p = T[p].ch[1]; &#125; &#125; return T[p].val; &#125; int GetPre(int key) &#123; int x, y, p, ans; split(root, key - 1, x, y); p = x; while (T[p].ch[1]) p = T[p].ch[1]; ans = T[p].val; root = merge(x, y); return ans; &#125; int GetNext(int key) &#123; int x, y, p, ans; split(root, key, x, y); p = y; while (T[p].ch[0]) p = T[p].ch[0]; ans = T[p].val; root = merge(x, y); return ans; &#125; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int main(void) &#123; srand(time(0)); int n = read(), m = read(); while (n--) insert(read()); int ans = 0, last = 0; while (m--) &#123; int opt = read(), x = read(); x ^= last; if (opt == 1) insert(x); else if (opt == 2) Remove(x); else if (opt == 3) last = Rank(x); else if (opt == 4) last = kth(x); else if (opt == 5) last = GetPre(x); else last = GetNext(x); if (opt > 2) ans ^= last; &#125; printf(\"%d\\n\", ans); return 0; &#125; 测试性能之后发现，Treap 用时 9.78s，FHQ-Treap 用时 12.60s，FHQ 还是会慢一些，不过足够了。 正如我们所说，Treap 是 OI 范围内能用到的最快的平衡树，FHQ 结合了 Treap 的优点并且支持 Splay 的分裂与合并，是很棒的平衡树。 分裂与合并的序列 FHQ 可以用来实现 Splay 的快速分裂合并功能。 区间翻转 模板。 我们先看一下如何实现分裂与合并的序列：我们只需要把区间的下标依次插入 Treap 中，也就是我们不再利用二叉搜索树的性质，不再是根据权值而建立平衡树，只是利用了它们能够分裂与合并的特性，此时节点的键值只是表示序列中一个数的相应大小，而序列的顺序由 Treap 的中序遍历保证。 区间翻转的时候，我们按照大小分裂为 [1,l−1],[l,r],[r+1,n][1,l-1],[l,r],[r+1,n][1,l−1],[l,r],[r+1,n]，然后给中间的树打上一个 revrevrev 标记，代表是否将左右儿子翻转（由于中序遍历的性质，将左右儿子反转后的序列便是原序列），然后操作的时候要进行 pushdown。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;random> #include &lt;ctime> using namespace std; struct Node &#123; int ch[2], siz, dat, id; bool rev; &#125; T[100005]; int tot = 0, root; mt19937 Rand(time(0)); void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + 1; &#125; int newNode(int id) &#123; T[++tot].id = id; T[tot].dat = Rand(); T[tot].siz = 1; return tot; &#125; void pushdown(int p) &#123; if (!T[p].rev) return; swap(T[p].ch[0], T[p].ch[1]); T[T[p].ch[0]].rev ^= 1; T[T[p].ch[1]].rev ^= 1; T[p].rev = 0; &#125; void print(int x) &#123; if (!x) return; pushdown(x); print(T[x].ch[0]); printf(\"%d \", T[x].id); print(T[x].ch[1]); &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); pushdown(p); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], S, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].dat > T[y].dat) &#123; pushdown(x); T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; pushdown(y); T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; void update(int l, int r) &#123; int x, y, z; split(root, l - 1, x, y); split(y, r - l + 1, y, z); T[y].rev ^= 1; root = merge(merge(x, y), z); &#125; int n, m; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) root = merge(root, newNode(i)); while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); update(l, r); &#125; print(root); putchar('\\n'); return 0; &#125; 一般序列操作 注意延迟标记的使用，大致是跟线段树一样的，覆盖当前节点的时候需要直接修改当前节点的相关信息。 再就是建树，采用类似于线段树的建树方式可以使合并的操作次数达到最少。 合理利用分裂与合并，将想要搞的信息直接分裂出来即可，合并可以合理安排序列的顺序。 模板，代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500000; mt19937 Rand(time(0)); struct Node &#123; int ch[2], siz, rnd, val; int sum, lmax, rmax, dat; bool rev, setv; &#125; T[500005]; int st[500005], tot, root, a[500005]; int newNode(int val) &#123; int p = st[tot--]; T[p].rnd = Rand(); T[p].siz = 1; T[p].ch[0] = T[p].ch[1] = T[p].rev = T[p].setv = 0; T[p].val = T[p].sum = T[p].dat = val; T[p].lmax = T[p].rmax = max(val, 0); return p; &#125; void maintain(int p) &#123; int l = T[p].ch[0], r = T[p].ch[1]; T[p].siz = T[l].siz + T[r].siz + 1; T[p].sum = T[l].sum + T[r].sum + T[p].val; T[p].lmax = max(T[l].lmax, T[l].sum + T[p].val + T[r].lmax); T[p].rmax = max(T[r].rmax, T[r].sum + T[p].val + T[l].rmax); T[p].dat = max(T[l].rmax + T[r].lmax, 0) + T[p].val; if (l) T[p].dat = max(T[p].dat, T[l].dat); if (r) T[p].dat = max(T[p].dat, T[r].dat); &#125; void cover(int p, int k) &#123; T[p].val = k; T[p].sum = k * T[p].siz; T[p].lmax = T[p].rmax = max(T[p].sum, 0); T[p].dat = max(T[p].sum, T[p].val); T[p].setv = 1; T[p].rev = 0; &#125; void rever(int p) &#123; swap(T[p].ch[0], T[p].ch[1]); swap(T[p].lmax, T[p].rmax); T[p].rev ^= 1; &#125; void pushdown(int p) &#123; if (!p) return; if (T[p].rev) &#123; if (T[p].ch[0]) rever(T[p].ch[0]); if (T[p].ch[1]) rever(T[p].ch[1]); T[p].rev = 0; &#125; if (T[p].setv) &#123; if (T[p].ch[0]) cover(T[p].ch[0], T[p].val); if (T[p].ch[1]) cover(T[p].ch[1], T[p].val); T[p].setv = 0; &#125; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); pushdown(p); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], S, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; pushdown(x); T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; pushdown(y); T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; void rmv(int x) &#123; st[++tot] = x; if (T[x].ch[0]) rmv(T[x].ch[0]); if (T[x].ch[1]) rmv(T[x].ch[1]); &#125; int add(int l, int r) &#123; if (l == r) return newNode(a[l]); int mid = l + r >> 1; return merge(add(l, mid), add(mid + 1, r)); &#125; int n, m; int main(void) &#123; for (int i = 1; i &lt;= N; ++i) st[++tot] = i; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); root = merge(root, add(1, n)); char op[15]; while (m--) &#123; scanf(\"%s\", op); if (op[0] == 'I') &#123; int l, cnt, x, y; scanf(\"%d%d\", &amp;l, &amp;cnt); split(root, l, x, y); for (int i = 1; i &lt;= cnt; ++i) scanf(\"%d\", a + i); root = merge(merge(x, add(1, cnt)), y); &#125; else if (op[0] == 'D') &#123; int l, cnt, x, y, z; scanf(\"%d%d\", &amp;l, &amp;cnt); split(root, l - 1, x, y); split(y, cnt, y, z); rmv(y); root = merge(x, z); &#125; else if (op[4] == '-') &#123; int l, cnt, k, x, y, z; scanf(\"%d%d%d\", &amp;l, &amp;cnt, &amp;k); split(root, l - 1, x, y); split(y, cnt, y, z); cover(y, k); root = merge(merge(x, y), z); &#125; else if (op[0] == 'R') &#123; int l, cnt, x, y, z; scanf(\"%d%d\", &amp;l, &amp;cnt); split(root, l - 1, x, y); split(y, cnt, y, z); rever(y); root = merge(merge(x, y), z); &#125; else if (op[0] == 'G') &#123; int l, cnt, x, y, z; scanf(\"%d%d\", &amp;l, &amp;cnt); split(root, l - 1, x, y); split(y, cnt, y, z); printf(\"%d\\n\", T[y].sum); root = merge(merge(x, y), z); &#125; else printf(\"%d\\n\", T[root].dat); &#125; return 0; &#125; Splay Splay，就是大名鼎鼎的“伸展树（因为伸展是它最经典的操作）”，也叫“自适应查找树”。1985 年由 Daniel Sleator 和 Robert Endre Tarjan（对，就是这个著名的 Tarjan）发明。 Splay 的平衡方式是通过旋转来伸展（有时候叫做“提根”），即把一个叶子节点通过旋转提到根节点。 值得一提的是，Splay 具有“自适应性”，就是它会根据你的操作调整自身结构，使得接下来的查询变得越来越快（像不像并查集）。但即使如此，这货还是很慢。 伸展树有什么用呢？虽然它可以用来实现名次树，但在竞赛中要实现名次树的话，还是乖乖用 Treap 吧。Splay 的伸展操作最大的用处是进行快速地分裂与合并（嗯，就是 fhq-treap 干的事，但实践中还是伸展树用的更多）。 Splay 在旋转时会涉及到节点的爷爷，所以它是双旋平衡树。 伸展操作 Splay 的节点怎么定义呢？一般来说有两种方式。第一种是记录节点的父亲的，因为（哪来那么多因为，这不是上文说的定义吗）。第二种是不记录父亲的。但是第一种相对来讲逻辑更为清晰（尽管旋转操作中的编码较为复杂），第二种在某些情况下会用到。因为笔者是傻瓜，不会第二种，所以这里只介绍第一种情况。 但是这之前，我们还需要搞明白 Splay 最关键的操作：伸展操作（splay 操作）如何进行。 splay 操作要分三种情况考虑。 xxx 的父节点是根节点，这时候进行一次单旋转即可，就完成了 splay 操作。 xxx，它的父节点和它的爷爷“三点共线”，这时进行两次方向相同的旋转操作即可。而且先转 xxx 的父节点再转 xxx； 三点不共线。这是需要将 xxx 进行不同方向的两次旋转。 通过以上方式我们就能完成 splay 操作啦！ 这里可以自行画图感受伸展操作的过程，使得更容易理解接下来的内容。 Splay 实际上有两种写法，第一种方法的节点像这样定义： struct Node &#123; int ch[2], fa; int val; // otherthings, such as size and cnt &#125;; 然后我们要实现一些基本的模板，如下： class Splay &#123; private: Node T[100005]; int tot; /* inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + T[p].cnt; &#125; */ &#125;; 怎么实现旋转呢？由于我们记录了父亲节点，所以可以换一种方式定义旋转：定义 rotate(x) 为将 xxx 的父亲节点上旋到 xxx 的爷爷。我们可以写一个函数来判断它是父亲节点的左儿子还是右儿子。 inline int get(int x) &#123; return x == T[T[x].fa].ch[1]; &#125; 旋转操作要注意：因为我们记录了父亲节点，意味着在旋转时需要对每个节点的父亲进行维护。但同时我们也不需要考虑旋转方向了。 inline void rotate(int x) &#123; // y: father, z: grandfather int y = T[x].fa, z = T[y].fa, d = get(x); // d 是左右儿子，不是方向 T[y].ch[d] = T[x].ch[d^1]; if (T[x].ch[d^1]) T[T[x].ch[d^1]].fa = y; T[x].ch[d^1] = y, T[y].fa = x; // 原来的儿子把原来的爸爸当成儿子（上旋） // 接下来把本来是爸爸的 y 的爸爸给 x T[x].fa = z; if (z) T[z].ch[get(y)] = x; // 本来 z 的儿子是 y，现在却变成了 x。如果 z 都等于 0 了还改就没什么意思了，是不？（况且我们还要根据是否等于 0 来判断父亲存不存在） maintain(y), maintain(x); // 从下到上重新计算 &#125; 感觉很绕？还是建议自行模拟一下。 有了旋转操作，就不难实现伸展操作了。伸展的原理之前已经讲过，这里直接给出代码： inline void splay(int x) // 把 x 提根 &#123; // 定义 f 为 x 的爸爸 // 我们需要保证 f 存在（它是 0 就结束了）才能继续循环 // 常规来讲，我们需要上旋 x for (int f = T[x].fa; f = T[x].fa; rotate(x)) if (T[f].fa) // 如果 T[f].fa 存在，就意味着是情况 2 或 3，需要进行第一次旋转 &#123; rotate(get(x) == get(f) ? f : x); // 当 get(x) == get(f) 时，意为着三点共线，转 f // 否则三点不共线，转两次 x（还有一次在循环更新处） // 这里的循环顺序很巧妙，保证处理完情况 2 和 3 的特别旋转放送后，立马会进行一次 rotate(x)（for 循环的更新） &#125; root = x; // 根变成了 x &#125; Splay 的第二种写法不记录节点的父亲，这时就变成了递归版的 Splay。由于笔者很弱不会，所以想学习这种写法请参考《算法竞赛入门经典·训练指南》，或者网上的其它资料。实际上本文介绍的这种写法逻辑更为清晰，这里做无耻推荐（ 某些情况下我们会使用指针实现 Splay。实际上笔者更推荐指针，但你的代码必须能跟现有的模块集成。现在大多数选手的 Splay 都是用数组伪指针的形式写的，如果不采用这种形式可能会在今后的学习中造成困扰，所以这里推荐大家使用伪指针。 用 Splay 实现名次树 名次树最终要的就是要保证平衡。但是 Splay 怎么保证平衡？好像很难搞。想想我们 Treap 是怎么搞的吧！用随机来创造平衡。那我们就随机伸展来保证平衡。 此处应该有 BGM。 不要笑，真是这么搞。听上去比 Treap 更不靠谱？我也是这么认为的。这里用 Splay 实现名次树仅仅是作为一个练习，考场上用 Treap 就好。 所以结论是：Splay 实现的名次树照样是弱平衡的随机平衡树（而且比 Treap 还慢），不过 Treap 在竞赛中已经足够用了，不建议作死去学 RBT。 注意到一个问题，由于 Splay 是记录父亲的，所以这时候如果我们还使用递归代码就会很麻烦（需要传父亲或者到处都是 get 函数），尤其是插入操作，进行伸展操作前要对性质进行维护，而递归的维护依赖于递归性质，所以这时不如使用迭代。 由于实现删除操作需要运用伸展树的分裂与合并，故这回我们写最初的弱化版。 唯一不同的只有插入操作，剩下的代码都可以照搬。插入要这样进行：动态记录当前节点和当前节点的父亲，如果找到了与要插入的值相同的节点，那么 cnt++，同时伸展这个点；否则递归地往下找，找到了空节点就创建新节点，然后伸展这个点，代码如下： inline void insert(int val) &#123; int cur = root, fa = 0; while (1) &#123; if (T[cur].val == val) // 找到了值相等的节点 &#123; ++T[cur].cnt; maintain(cur); maintain(fa); // 以上为进行维护 splay(cur); // 伸展 return; &#125; fa = cur; cur = T[cur].ch[val > T[cur].val]; // 往下走 if (cur == 0) &#123; newNode(val); // 新建节点 // 重新计算父子关系和子树大小 T[tot].fa = fa; T[fa].ch[val > T[fa].val] = tot; maintain(fa); splay(tot); // 伸展 return; &#125; &#125; &#125; 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int INF = 0x7fffffff; struct Node &#123; int ch[2], fa; int val; int size, cnt; &#125;; class Splay &#123; public: int root; private: Node T[100005]; int tot; inline void newNode(int val) &#123; T[++tot].val = val; T[tot].size = T[tot].cnt = 1; &#125; inline void maintain(int p) &#123; T[p].size = T[T[p].ch[0]].size + T[T[p].ch[1]].size + T[p].cnt; &#125; inline int get(int x) &#123; return x == T[T[x].fa].ch[1]; &#125; inline void rotate(int x) &#123; int y = T[x].fa, z = T[y].fa, d = get(x); T[y].ch[d] = T[x].ch[d^1]; if (T[x].ch[d^1]) T[T[x].ch[d^1]].fa = y; T[x].ch[d^1] = y, T[y].fa = x; T[x].fa = z; if (z) T[z].ch[y == T[z].ch[1]] = x; maintain(y); maintain(x); &#125; inline void splay(int x) &#123; for (int f = T[x].fa; f = T[x].fa; rotate(x)) if (T[f].fa) rotate(get(x) == get(f) ? f : x); root = x; &#125; public: inline void build(void) &#123; newNode(-INF), newNode(INF); T[1].ch[1] = 2, T[2].fa = 1; maintain(root = 1); &#125; inline void insert(int val) &#123; int cur = root, fa = 0; while (1) &#123; if (T[cur].val == val) &#123; ++T[cur].cnt; maintain(cur); maintain(fa); splay(cur); return; &#125; fa = cur; cur = T[cur].ch[val > T[cur].val]; if (cur == 0) &#123; newNode(val); T[tot].fa = fa; T[fa].ch[val > T[fa].val] = tot; maintain(fa); splay(tot); return; &#125; &#125; &#125; int Rank(int p, int val) &#123; if (p == 0) return 1; if (val == T[p].val) return T[T[p].ch[0]].size + 1; if (val &lt; T[p].val) return Rank(T[p].ch[0], val); return Rank(T[p].ch[1], val) + T[T[p].ch[0]].size + T[p].cnt; &#125; int kth(int p, int rnk) &#123; if (p == 0) return INF; if (rnk &lt;= T[T[p].ch[0]].size) return kth(T[p].ch[0], rnk); if (rnk &lt;= T[T[p].ch[0]].size + T[p].cnt) return T[p].val; return kth(T[p].ch[1], rnk - T[T[p].ch[0]].size - T[p].cnt); &#125; inline int GetPre(int val) &#123; int ans = 1, p = root; while (p) &#123; if (val == T[p].val) &#123; if (T[p].ch[0]) &#123; p = T[p].ch[0]; while (T[p].ch[1]) p = T[p].ch[1]; ans = p; &#125; break; &#125; if (T[p].val &lt; val &amp;&amp; T[p].val > T[ans].val) ans = p; p = T[p].ch[val &lt; T[p].val ? 0 : 1]; &#125; return T[ans].val; &#125; inline int GetNext(int val) &#123; int ans = 2, p = root; while (p) &#123; if (val == T[p].val) &#123; if (T[p].ch[1]) &#123; p = T[p].ch[1]; while (T[p].ch[0]) p = T[p].ch[0]; ans = p; &#125; break; &#125; if (T[p].val > val &amp;&amp; T[p].val &lt; T[ans].val) ans = p; p = T[p].ch[val &lt; T[p].val ? 0 : 1]; &#125; return T[ans].val; &#125; &#125;T; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int main(void) &#123; int q = read(); T.build(); while (q--) &#123; int op = read(), x = read(); if (op == 1) printf(\"%d\\n\", T.Rank(T.root, x) - 1); else if (op == 2) printf(\"%d\\n\", T.kth(T.root, x + 1)); else if (op == 3) printf(\"%d\\n\", T.GetPre(x)); else if (op == 4) printf(\"%d\\n\", T.GetNext(x)); else T.insert(x); &#125; return 0; &#125; 分裂与合并 由于 Splay 支持伸展操作，因此它可以很方便的进行分裂与合并，进而实现可以分裂与合并的序列。模板。 神风敢死队炸毁了此处的内容。鉴定为不如 FHQ，以后再说。 Problemset 直接的平衡树应用很少，但是也有。 可分裂与合并的序列 用于维护序列，但可能需要一些思考。 [JSOI2008] 火星人 Portal. LCQ 的查询直接二分即可，剩下就是直接平衡树。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; const int B = 10009, N = 100000; int n, m; u64 h[100005]; char s[100005]; mt19937 Rand(time(0)); struct Node &#123; int ch[2], siz, rnd; u64 w; char c; &#125; T[100005]; int tot, root; int newNode(char c) &#123; T[++tot].rnd = Rand(); T[tot].siz = 1; T[tot].w = T[tot].c = c; return tot; &#125; void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + 1; T[p].w = T[T[p].ch[0]].w * h[T[T[p].ch[1]].siz + 1] + T[p].c * h[T[T[p].ch[1]].siz] + T[T[p].ch[1]].w; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], S, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; int add(int l, int r) &#123; if (l == r) return newNode(s[l]); int mid = l + r >> 1; return merge(add(l, mid), add(mid + 1, r)); &#125; u64 Get(int l, int len) &#123; int x, y, z; split(root, l - 1, x, y); split(y, len, y, z); u64 res = T[y].w; root = merge(merge(x, y), z); return res; &#125; int main(void) &#123; for (int i = h[0] = 1; i &lt;= N; ++i) h[i] = h[i - 1] * B; scanf(\"%s\", s + 1); n = strlen(s + 1); root = merge(root, add(1, n)); scanf(\"%d\", &amp;m); char op[5]; int p, q, x, y, z; while (m--) &#123; scanf(\"%s%d\", op, &amp;p); if (op[0] == 'Q') &#123; scanf(\"%d\", &amp;q); int L = 0, R = T[root].siz - q + 2; while (L + 1 != R) &#123; int mid = L + R >> 1; if (Get(p, mid) == Get(q, mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", L); &#125; else if (op[0] == 'R') &#123; scanf(\"%s\", s); split(root, p - 1, x, y); split(y, 1, y, z); T[y].w = T[y].c = s[0]; root = merge(merge(x, y), z); &#125; else &#123; scanf(\"%s\", s); split(root, p, x, y); root = merge(merge(x, newNode(s[0])), y); &#125; &#125; return 0; &#125; [HNOI2011] 括号修复 Portal. 修复一个括号序列的代价这样计算：设 ( = -1, ) = 1，前缀最大值为 aaa，后缀最小值为 bbb，代价是 ⌈a÷2⌉+⌈−b÷2⌉\\lceil a\\div 2\\rceil+\\lceil -b\\div 2\\rceil⌈a÷2⌉+⌈−b÷2⌉。然后直接使用平衡树维护即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;random> using namespace std; mt19937 Rand(time(0)); struct Node &#123; int ch[2], siz, rnd; int setv; bool rev, inv; int lmax, lmin, rmax, rmin, sum, val; &#125; T[100005]; int root, tot, n, m; int newNode(int val) &#123; T[++tot].rnd = Rand(); T[tot].siz = 1; T[tot].sum = T[tot].val = val; if (val == 1) T[tot].lmax = T[tot].rmax = 1; else T[tot].lmin = T[tot].rmin = -1; return tot; &#125; void maintain(int p) &#123; int l = T[p].ch[0], r = T[p].ch[1]; T[p].siz = T[l].siz + T[r].siz + 1; T[p].sum = T[l].sum + T[r].sum + T[p].val; T[p].lmax = max(T[l].lmax, T[l].sum + T[p].val + T[r].lmax); T[p].lmin = min(T[l].lmin, T[l].sum + T[p].val + T[r].lmin); T[p].rmax = max(T[r].rmax, T[r].sum + T[p].val + T[l].rmax); T[p].rmin = min(T[r].rmin, T[r].sum + T[p].val + T[l].rmin); &#125; void Replace(int p, int val) &#123; T[p].val = T[p].setv = val; T[p].sum = val * T[p].siz; T[p].lmax = T[p].rmax = max(0, val * T[p].siz); T[p].lmin = T[p].rmin = min(0, val * T[p].siz); &#125; void Swap(int p) &#123; swap(T[p].ch[0], T[p].ch[1]); swap(T[p].lmax, T[p].rmax); swap(T[p].lmin, T[p].rmin); T[p].rev ^= 1; &#125; void Invert(int p) &#123; T[p].val = -T[p].val; T[p].sum = -T[p].sum; T[p].setv = -T[p].setv; int x = T[p].lmax, y = T[p].lmin; T[p].lmax = -y, T[p].lmin = -x; x = T[p].rmax, y = T[p].rmin; T[p].rmax = -y, T[p].rmin = -x; T[p].inv ^= 1; &#125; void pushdown(int p) &#123; int l = T[p].ch[0], r = T[p].ch[1]; if (T[p].inv) &#123; if (l) Invert(l); if (r) Invert(r); T[p].inv = 0; &#125; if (T[p].rev) &#123; if (l) Swap(l); if (r) Swap(r); T[p].rev = 0; &#125; if (T[p].setv) &#123; if (l) Replace(l, T[p].setv); if (r) Replace(r, T[p].setv); T[p].setv = 0; &#125; &#125; void split(int p, int S, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); pushdown(p); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y); &#125; else &#123; y = p; split(T[p].ch[0], S, x, T[p].ch[0]); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; pushdown(x); T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); return x; &#125; else &#123; pushdown(y); T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); return y; &#125; &#125; char s[100005]; int add(int l, int r) &#123; if (l == r) return newNode(s[l] == '(' ? -1 : 1); int mid = l + r >> 1; return merge(add(l, mid), add(mid + 1, r)); &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, s + 1); root = add(1, n); char op[15]; int l, r, x, y, z; while (m--) &#123; scanf(\"%s%d%d\", op, &amp;l, &amp;r); if (op[0] == 'R') &#123; scanf(\"%s\", s); split(root, l - 1, x, y); split(y, r - l + 1, y, z); Replace(y, s[0] == '(' ? -1 : 1); root = merge(merge(x, y), z); &#125; else if (op[0] == 'S') &#123; split(root, l - 1, x, y); split(y, r - l + 1, y, z); Swap(y); root = merge(merge(x, y), z); &#125; else if (op[0] == 'I') &#123; split(root, l - 1, x, y); split(y, r - l + 1, y, z); Invert(y); root = merge(merge(x, y), z); &#125; else &#123; split(root, l - 1, x, y); split(y, r - l + 1, y, z); printf(\"%d\\n\", (T[y].lmax + 1) / 2 + (1 - T[y].rmin) / 2); root = merge(merge(x, y), z); &#125; &#125; return 0; &#125; [ZJOI2006] 书架 Portal. 问题在于如何高效找到一个节点在平衡树上的位置（中序遍历的编号）。维护每一个节点的父亲，然后直接从这个节点的位置跳到根，维护中序遍历的位置。这之后直接乱做即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; struct Node &#123; int ch[2], fa, siz, dat, val; &#125; T[200005]; int tot = 0, root, id[200005]; // 编号为 i 的节点是平衡树中的 id[i] 号节点 mt19937 Rand(time(0)); void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + 1; &#125; int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = Rand(); T[tot].siz = 1; return id[val] = tot; &#125; void split(int p, int S, int &amp;x, int &amp;y, int fax = 0, int fay = 0) &#123; if (!p) return x = y = 0, void(); if (T[T[p].ch[0]].siz + 1 &lt;= S) &#123; x = p; T[x].fa = fay; split(T[p].ch[1], S - T[T[p].ch[0]].siz - 1, T[p].ch[1], y, fax, x); &#125; else &#123; y = p; T[y].fa = fax; split(T[p].ch[0], S, x, T[p].ch[0], y, fay); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].dat > T[y].dat) &#123; T[x].ch[1] = merge(T[x].ch[1], y); maintain(x); T[T[x].ch[1]].fa = x; return x; &#125; else &#123; T[y].ch[0] = merge(x, T[y].ch[0]); maintain(y); T[T[y].ch[0]].fa = y; return y; &#125; &#125; int find(int ID) &#123; // 中序遍历的编号 int res = T[T[ID].ch[0]].siz + 1; while (ID != root &amp;&amp; ID) &#123; if (T[T[ID].fa].ch[1] == ID) res += T[T[T[ID].fa].ch[0]].siz + 1; ID = T[ID].fa; &#125; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (n--) &#123; int x; scanf(\"%d\", &amp;x); root = merge(root, newNode(x)); &#125; char op[10]; int s, t; while (m--) &#123; scanf(\"%s%d\", op, &amp;s); if (op[0] == 'T') &#123; int x, y, z; s = find(id[s]); split(root, s - 1, x, y); split(y, 1, y, z); root = merge(y, merge(x, z)); &#125; else if (op[0] == 'B') &#123; int x, y, z; s = find(id[s]); split(root, s - 1, x, y); split(y, 1, y, z); root = merge(x, merge(z, y)); &#125; else if (op[0] == 'I') &#123; scanf(\"%d\", &amp;t); s = find(id[s]); int r1, r2, r3, r4; if (t == 1) &#123; split(root, s - 1, r1, r2); split(r2, 1, r2, r3); split(r3, 1, r3, r4); root = merge(r1, merge(r3, merge(r2, r4))); &#125; else if (t == -1) &#123; split(root, s - 2, r1, r2); split(r2, 1, r2, r3); split(r3, 1, r3, r4); root = merge(r1, merge(r3, merge(r2, r4))); &#125; &#125; else if (op[0] == 'A') printf(\"%d\\n\", find(id[s]) - 1); else &#123; int x, y; split(root, s, x, y); int node = x; while (T[node].ch[1]) node = T[node].ch[1]; printf(\"%d\\n\", T[node].val); root = merge(x, y); &#125; &#125; return 0; &#125; 综合应用 一些平衡树的简单应用。 [POI2015] LOG Portal. 使用一棵维护权值的平衡树。在减 111 的过程中，大于等于 sss 的是随便用，剩下的只需要考虑它们的和是否够用即可（可以将后面的向前移来叠到 sss，这样保证一层中不会有来自同一个位置的数）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; mt19937 Rand(time(0)); struct Node &#123; int ls, rs, siz, rnd; i64 sum, val; &#125; T[2000005]; int root, tot; int newNode(int x) &#123; ++tot; T[tot].rnd = Rand(); T[tot].siz = 1; T[tot].sum = T[tot].val = x; return tot; &#125; inline void maintain(int p) &#123; T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz + 1; T[p].sum = T[T[p].ls].sum + T[T[p].rs].sum + T[p].val; &#125; void split(int p, int k, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[p].val &lt;= k) &#123; x = p; split(T[p].rs, k, T[p].rs, y); &#125; else &#123; y = p; split(T[p].ls, k, x, T[p].ls); &#125; maintain(p); &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) &#123; T[x].rs = merge(T[x].rs, y); maintain(x); return x; &#125; else &#123; T[y].ls = merge(x, T[y].ls); maintain(y); return y; &#125; &#125; void insert(int v) &#123; int x, y; split(root, v, x, y); root = merge(x, merge(newNode(v), y)); &#125; void remove(int v) &#123; int x, y, z; split(root, v, x, z); split(x, v - 1, x, y); if (y) y = merge(T[y].ls, T[y].rs); root = merge(x, merge(y, z)); &#125; int bigger(int s) &#123; int x, y; split(root, s - 1, x, y); int ans = T[y].siz; root = merge(x, y); return ans; &#125; i64 query(int v) &#123; int x, y; split(root, v - 1, x, y); i64 ans = T[x].sum; root = merge(x, y); return ans; &#125; int n, m, a[1000005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); char op[5]; int x, y; for (int i = 1; i &lt;= n; ++i) insert(0); while (m--) &#123; scanf(\"%s%d%d\", op, &amp;x, &amp;y); if (op[0] == 'U') remove(a[x]), insert(a[x] = y); else &#123; int num = bigger(y); if (query(y) >= 1ll * (x - num) * y) puts(\"TAK\"); else puts(\"NIE\"); &#125; &#125; return 0; &#125; [HNOI2012] 永无乡 Portal. 用 Treap 维护名次，然后启发式合并。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct Node &#123; int ch[2]; int val, dat; int siz; &#125; T[3000005]; int tot, root[100005], f[100005], idx[100005]; int find(int x) &#123; if (f[x] == x) return x; return find(f[x]); &#125; void maintain(int p) &#123; T[p].siz = T[T[p].ch[0]].siz + T[T[p].ch[1]].siz + 1; &#125; inline int newNode(int val) &#123; T[++tot].val = val; T[tot].dat = rand(); T[tot].siz = 1; T[tot].ch[0] = T[tot].ch[1] = 0; return tot; &#125; inline void rotate(int&amp; p, int d) &#123; int q = T[p].ch[d ^ 1]; T[p].ch[d ^ 1] = T[q].ch[d], T[q].ch[d] = p, p = q; maintain(T[p].ch[d]), maintain(p); &#125; void insert(int&amp; p, int val) &#123; if (p == 0) return p = newNode(val), void(); else &#123; int d = (val &lt; T[p].val ? 0 : 1); insert(T[p].ch[d], val); if (T[T[p].ch[d]].dat > T[p].dat) rotate(p, d ^ 1); &#125; maintain(p); &#125; int kth(int p, int rnk) &#123; if (p == 0) return 0; if (rnk &lt;= T[T[p].ch[0]].siz) return kth(T[p].ch[0], rnk); if (rnk &lt;= T[T[p].ch[0]].siz + 1) return T[p].val; return kth(T[p].ch[1], rnk - T[T[p].ch[0]].siz - 1); &#125; void dfs(int x, int y) &#123; insert(root[y], T[x].val); if (T[x].ch[0]) dfs(T[x].ch[0], y); if (T[x].ch[1]) dfs(T[x].ch[1], y); &#125; inline void merge(int u, int v) &#123; u = find(u); v = find(v); if (u == v) return; if (T[root[u]].siz > T[root[v]].siz) swap(u, v); f[u] = v; dfs(root[u], v); &#125; int n, m, q; int a[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), root[i] = newNode(a[i]), f[i] = idx[a[i]] = i; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); merge(u, v); &#125; char op[5]; int x, y; for (scanf(\"%d\", &amp;q); q--; ) &#123; scanf(\"%s%d%d\", op, &amp;x, &amp;y); if (op[0] == 'Q') &#123; x = find(x); int k = kth(root[x], y); if (!k) puts(\"-1\"); else printf(\"%d\\n\", idx[k]); &#125; else merge(x, y); &#125; return 0; &#125; [Luogu P3987] 我永远喜欢珂朵莉~ Portal. 一个数最多被除 log⁡\\loglog 次，那么可以暴力修改并使用 Fenwick 树查询，使用平衡树维护有因数 xxx 的数，每次修改时直接 DFS 分裂出的子树。时间复杂度 O(nd(V)+nlog⁡nlog⁡v+mlog⁡n)O(nd(V)+n\\log n\\log v+m\\log n)O(nd(V)+nlognlogv+mlogn)。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; int n, m, a[100005]; vector&lt;int> g[500005]; i64 C[100005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; i64 query(int x) &#123; i64 res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; mt19937 Rand(time(0)); struct Node &#123; int ls, rs, rnd, v, siz; &#125; T[65000005]; int tot, root[500005]; void maintain(int o) &#123; T[o].siz = T[T[o].ls].siz + T[T[o].rs].siz + 1; &#125; int newNode(int v) &#123; ++tot; T[tot].ls = T[tot].rs = 0; T[tot].v = v; T[tot].siz = 1; T[tot].rnd = Rand(); return tot; &#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (T[x].rnd > T[y].rnd) return T[x].rs = merge(T[x].rs, y), maintain(x), x; return T[y].ls = merge(x, T[y].ls), maintain(y), y; &#125; void split(int p, int k, int &amp;x, int &amp;y) &#123; if (!p) return x = y = 0, void(); if (T[p].v &lt;= k) x = p, split(T[p].rs, k, T[p].rs, y); else y = p, split(T[p].ls, k, x, T[p].ls); maintain(p); &#125; int cur, q[100005]; int build(int l, int r) &#123; if (l > r) return 0; if (l == r) return newNode(q[l]); int mid = l + r >> 1; return merge(build(l, mid), build(mid + 1, r)); &#125; void dfs(int x, int v) &#123; if (!x) return; if (T[x].ls) dfs(T[x].ls, v); int p = T[x].v; if (a[p] % v == 0) &#123; add(p, -a[p]), a[p] /= v, add(p, a[p]); if (a[p] % v == 0) q[++cur] = p; &#125; if (T[x].rs) dfs(T[x].rs, v); &#125; void update(int x, int l, int r) &#123; int a, b, c; split(root[x], r, b, c); split(b, l - 1, a, b); cur = 0; dfs(b, x); root[x] = merge(a, merge(build(1, cur), c)); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); add(i, a[i]); for (int j = 1; j * j &lt;= a[i]; ++j) if (a[i] % j == 0) &#123; g[j].emplace_back(i); if (j * j != a[i]) g[a[i] / j].emplace_back(i); &#125; &#125; for (int i = 1; i &lt;= 500000; ++i) &#123; cur = 0; for (int x : g[i]) q[++cur] = x; root[i] = build(1, cur); &#125; while (m--) &#123; int op, l, r, x; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) &#123; scanf(\"%d\", &amp;x); if (x > 1) update(x, l, r); &#125; else printf(\"%lld\\n\", query(r) - query(l - 1)); &#125; return 0; &#125; 对于数据加强版 [Ynoi2013] 大学，平衡树常数过大，不能通过。对于每一个约数采用一个并查集，开始时每个数都指向自己，删除时将当前数的父亲设置为下一个数。另外 STL vector 的常数过大，需要手写内存池。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) #define i64 long long using namespace std; int n, m, a[100005], o[500005], pool[40000005]; int *g[500005], *poi = pool, *fa[500005]; int find(int k, int x) &#123; if (x == o[k] || fa[k][x] == x) return x; return fa[k][x] = find(k, fa[k][x]); &#125; i64 C[100005]; inline void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; inline i64 query(int x) &#123; i64 res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int maxx = 0, op, l, r, x; i64 last = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); add(i, a[i]); maxx = max(maxx, a[i]); ++o[a[i]]; &#125; for (int i = 1; i &lt;= maxx; ++i) for (int j = i + i; j &lt;= maxx; j += i) o[i] += o[j]; for (int i = 1; i &lt;= maxx; ++i) &#123; g[i] = poi; poi += o[i]; fa[i] = poi; poi += o[i]; for (int j = 0; j &lt; o[i]; ++j) fa[i][j] = j; o[i] = 0; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j * j &lt;= a[i]; ++j) if (a[i] % j == 0) &#123; g[j][o[j]++] = i; if (j * j != a[i]) g[a[i] / j][o[a[i] / j]++] = i; &#125; while (m--) &#123; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); l ^= last, r ^= last; if (op == 1) &#123; scanf(\"%d\", &amp;x); x ^= last; if (x == 1 || !o[x]) continue; for (int i = find(x, lower_bound(g[x], g[x] + o[x], l) - g[x]); i &lt; o[x] &amp;&amp; g[x][i] &lt;= r; i = find(x, i + 1)) &#123; if (a[g[x][i]] % x == 0) add(g[x][i], a[g[x][i]] / x - a[g[x][i]]), a[g[x][i]] /= x; if (a[g[x][i]] % x) fa[x][i] = i + 1; &#125; &#125; else printf(\"%lld\\n\", last = query(r) - query(l - 1)); &#125; return 0; &#125; [Ynoi2010] y-fast trie Portal. 神仙题。 加入集合时将 xxx 取模，然后对于两个答案数 i,ji,ji,j 分类讨论： C≥i+j&lt;2CC\\ge i+j&lt;2CC≥i+j&lt;2C，这样只需要维护集合的最大和次大值即可。 0≤i+j&lt;C0\\le i+j&lt;C0≤i+j&lt;C，我们讨论这种情况。 称一个数 iii 在集合中满足 i+j&lt;Ci+j&lt;Ci+j&lt;C 的最大数 jjj 是 iii 的最优匹配，我们需要实现一个可以求出 iii 的匹配的函数，并且能够向它指定是否不能匹配到自身。 一个数的改变可能会影响 O(n)O(n)O(n) 个匹配。根据经验，我们需要删去一些无用的匹配，让需要修改的匹配个数控制在 O(1)O(1)O(1) 级别。比如 xxx 的最优匹配是 yyy，而 yyy 的最优匹配是 zzz，有 x≤zx\\le zx≤z，那么 xxx 加入时就不需要修改 yyy 的最优匹配，因为现有的答案 y+zy+zy+z 一定比 x+yx+yx+y 大，进而 y,zy,zy,z 必须双向互为最优匹配这个答案才需要被删除，但是 x+yx+yx+y 一定要被插入。 删除 xxx 时，x+yx+yx+y 一定要被删除，如果 y,zy,zy,z 互为最优匹配需要将 y+zy+zy+z 插入回来。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, C, siz; multiset&lt;int> a, b; int find(int x, int op) &#123; // 寻找 i + j &lt; C 的最大 j, op = 1 为强制不等于自己 if (x == -1) return -1; auto it = a.upper_bound(C - 1 - x); if (it == a.begin()) return -1; --it; // 满足 x + j &lt; C 的最大 j if (op &amp;&amp; *it == x &amp;&amp; a.count(x) == 1) return it == a.begin() ? -1 : *--it; return *it; &#125; inline void insert(int x) &#123; if (++siz == 1) return a.insert(x), void(); int y = find(x, 0), z = find(y, 1), w = find(z, 1); // 看 x 的最优匹配 y，x 是否能对 y 本身的最优匹配 z 产生影响，而且 y,z 双向匹配 // 寻找 x 的匹配可以是 x，因为 x 还没进集合 if (y != -1 &amp;&amp; z &lt; x) &#123; if (z != -1 &amp;&amp; w == y) b.erase(b.find(y + z)); b.insert(x + y); &#125; a.insert(x); &#125; inline void remove(int x) &#123; a.erase(a.find(x)); if (--siz == 0) return; int y = find(x, 0), z = find(y, 1), w = find(z, 1); // 删除了 x，将 x 的最优匹配 y 的最优匹配进行修改 if (y != -1 &amp;&amp; z &lt; x) &#123; if (z != -1 &amp;&amp; w == y) b.insert(y + z); b.erase(b.find(x + y)); &#125; &#125; inline int query(int x) &#123; // i + j >= C auto it = --a.end(); if (a.count(*it) >= 2) return *it * 2 % C; int tmp = *it; --it; return (tmp + *it) % C; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;C); int last = 0; while (n--) &#123; int op, x; scanf(\"%d%d\", &amp;op, &amp;x); x = (x ^ last) % C; if (op == 1) insert(x); else remove(x); if (siz &lt; 2) puts(\"EE\"), last = 0; else printf(\"%d\\n\", last = max(query(x), b.empty() ? 0 : *--b.end())); &#125; return 0; &#125; * [Ynoi2015] 人人本着正义之名 Portal. 首先看一看操作 3∼63\\sim 63∼6 是个什么东西。 将 [l,r−1][l,r-1][l,r−1] 中的数 aia_iai​ 同时变为 aia_iai​ 与 ai+1a_{i+1}ai+1​ 按位或的值？简单，就是所有极长 000 段最右边一个 000 变成 111。 搞一个平衡树，打一个标记表示左右端点的移动量。只有两个问题： 如何保证区间极长？区间染色时向左右拓展一下即可。 如何保证没有空区间？区间数量是 O(n+m)O(n+m)O(n+m) 的，维护最短 01 区间长度，暴力找，然后将其左右区间合并即可。 本质上不难，但代码比较壮观，需要使用指针实现平衡树进行卡常。 查看代码 #include &lt;bits/stdc++.h> #define PTREE(x) printf(\"root = %d\\n\", x); printT(x) #define DEBUG fprintf(stderr, \"Passed Line %d, in Function %s\\n\", __LINE__, __FUNCTION__) using namespace std; const int INF = 1e9; mt19937 Rand(time(0)); inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar(); return x; &#125; void print(int x) &#123; if (x > 9) print(x / 10); putchar(x % 10 ^ 48); &#125; struct Node &#123; int rnd; int col, sum, siz[2]; // 区间颜色，区间和，01 区间数量 int l, r; // 左右端点 int dL, dR; // 1 的左右端点位移 int minLen[2]; // 最短 01 区间长度 Node *ls, *rs; void reset(void) &#123; siz[col] = 1; siz[!col] = 0; sum = col * (r - l + 1); dL = dR = 0; minLen[col] = r - l + 1; minLen[!col] = INF; &#125; Node(int col = 0, int l = 0, int r = 0) : rnd(Rand()), col(col), l(l), r(r), ls(NULL), rs(NULL) &#123; reset(); &#125; void add(const Node &amp;a) &#123; sum += a.sum; siz[0] += a.siz[0]; siz[1] += a.siz[1]; minLen[0] = min(minLen[0], a.minLen[0]); minLen[1] = min(minLen[1], a.minLen[1]); &#125; &#125; T[5000005]; Node* root; int tot; inline Node* newNode(int col, int l, int r) &#123; return &amp;(T[++tot] = Node(col, l, r)); &#125; inline void maketag(Node* o, int dL, int dR) &#123; o->dL += dL; o->dR += dR; o->minLen[0] -= dL + dR; o->minLen[1] += dL + dR; o->sum += (dL + dR) * o->siz[1]; if (o->col == 1) o->l -= dL, o->r += dR; else o->l += dR, o->r -= dL; &#125; inline void pushdown(Node* o) &#123; if (!o->dL &amp;&amp; !o->dR) return; if (o->ls != NULL) maketag(o->ls, o->dL, o->dR); if (o->rs != NULL) maketag(o->rs, o->dL, o->dR); o->dL = o->dR = 0; &#125; inline void pushup(Node* o) &#123; o->reset(); if (o->ls) o->add(*(o->ls)); if (o->rs) o->add(*(o->rs)); &#125; Node* merge(Node* x, Node* y) &#123; if (x == NULL) return y; if (y == NULL) return x; if (x->rnd &lt; y->rnd) &#123; pushdown(x); x->rs = merge(x->rs, y); pushup(x); return x; &#125; else &#123; pushdown(y); y->ls = merge(x, y->ls); pushup(y); return y; &#125; &#125; // 左端点 &lt;= k 划到 x void split1(Node* o, int k, Node*&amp; x, Node*&amp; y) &#123; if (o == NULL) return x = y = NULL, void(); pushdown(o); if (o->l &lt;= k) x = o, split1(x->rs, k, x->rs, y); else y = o, split1(y->ls, k, x, y->ls); pushup(o); &#125; // 右端点 &lt;= k 划到 x void split2(Node* o, int k, Node*&amp; x, Node*&amp; y) &#123; if (o == NULL) return x = y = NULL, void(); pushdown(o); if (o->r &lt;= k) x = o, split2(x->rs, k, x->rs, y); else y = o, split2(y->ls, k, x, y->ls); pushup(o); &#125; // 删除空区间 Node* Eraser[3000005]; int L = 1, R = 0; const int B = 4194303; void findEmpty(Node* o) &#123; if (o == NULL) return; if (o->minLen[0] &amp;&amp; o->minLen[1]) return; pushdown(o); if (o->l > o->r) Eraser[(++R) &amp; B] = o; findEmpty(o->ls); findEmpty(o->rs); &#125; inline void Erase(void) &#123; while (L &lt;= R) &#123; Node *o = Eraser[(L++) &amp; B]; Node *nodeL, *TM, *nodeR, *TR; split1(root, o->l - 1, root, TM); split1(TM, o->l, TM, TR); // TM.l = o->l split2(root, o->l - 2, root, nodeL); nodeR = (o == TM ? o->rs : TM); if (nodeL &amp;&amp; nodeR) nodeL->r = nodeR->r, nodeL->reset(), nodeR = NULL; root = merge(root, merge(nodeL, merge(nodeR, TR))); &#125; &#125; void printT(Node* o) &#123; if (o == NULL) return; pushdown(o); if (o->ls) printT(o->ls); printf(\"%d %d %d %d %d\\n\", o->l, o->r, o->dL, o->dR, o->col); if (o->rs) printT(o->rs); &#125; // 操作列表 inline void cover(int l, int r, int col) &#123; Node *nodeL, *TM, *nodeR, *TR; // root = TL split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l - 1, nodeL, TM); split2(TM, r, TM, nodeR); if (nodeL) &#123; if (nodeL->r > r) nodeR = newNode(nodeL->col, r, nodeL->r); nodeL->r = l - 1; nodeL->reset(); &#125; else split2(root, l - 2, root, nodeL); if (nodeR) nodeR->l = r + 1, nodeR->reset(); else split1(TR, r + 1 , nodeR, TR); TM = newNode(col, l, r); if (nodeL &amp;&amp; TM->col == nodeL->col) TM->l = nodeL->l, TM->reset(), nodeL = NULL; if (nodeR &amp;&amp; TM->col == nodeR->col) TM->r = nodeR->r, TM->reset(), nodeR = NULL; root = merge(root, merge(nodeL, merge(TM, merge(nodeR, TR)))); &#125; // 0 区间右端点 -1，1 区间左端点 -1 inline void opt3(int l, int r) &#123; --r; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l, node, TM); if (node &amp;&amp; node->col == 1) root = merge(root, node); else TM = merge(node, TM); split2(TM, r - 1, TM, node); if (node &amp;&amp; node->col == 0) &#123; if (node->r > r) TR = merge(node, TR); else &#123; TM = merge(TM, node); split1(TR, r + 1, node, TR); TM = merge(TM, node); &#125; &#125; else TM = merge(TM, node); // PTREE(TM); if (TM) maketag(TM, 1, 0); // PTREE(TM); root = merge(merge(root, TM), TR); findEmpty(root); Erase(); &#125; // 0 区间左端点 +1，1 区间右端点 +1 inline void opt4(int l, int r) &#123; ++l; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l, node, TM); if (node &amp;&amp; node->col == 0) &#123; if (node->l &lt; l) root = merge(root, node); else &#123; TM = merge(node, TM); split2(root, l - 2, root, node); TM = merge(node, TM); &#125; &#125; else TM = merge(node,TM); split2(TM, r - 1, TM, node); if (node &amp;&amp; node->col == 1) TR = merge(node, TR); else TM = merge(TM, node); if (TM) maketag(TM, 0, 1); root = merge(root, merge(TM, TR)); findEmpty(root); Erase(); &#125; // 0 区间左端点 -1，1 区间右端点 -1 inline void opt5(int l, int r) &#123; --r; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l, node, TM); if (node &amp;&amp; node->col == 0) root = merge(root, node); else TM = merge(node, TM); split2(TM, r - 1, TM, node); if (node &amp;&amp; node->col == 1) &#123; if (node->r > r) TR = merge(node, TR); else &#123; TM = merge(TM, node); split1(TR, r + 1, node, TR); TM = merge(TM, node); &#125; &#125; else TM = merge(TM, node); if (TM) maketag(TM, 0, -1); root = merge(root, merge(TM, TR)); findEmpty(root); Erase(); &#125; // 0 区间右端点 +1，1 区间左端点 +1 inline void opt6(int l, int r) &#123; ++l; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); split1(TM, l, node, TM); if (node &amp;&amp; node->col == 1) &#123; if (node->l &lt; l) root = merge(root, node); else &#123; TM = merge(node, TM); split2(root, l - 2, root, node); TM = merge(node, TM); &#125; &#125; else TM = merge(node, TM); split2(TM, r - 1, TM, node); if (node &amp;&amp; node->col == 0) TR = merge(node, TR); else TM = merge(TM, node); if (TM) maketag(TM, -1, 0); root = merge(root, merge(TM, TR)); findEmpty(root); Erase(); &#125; inline int opt7(int l, int r) &#123; Node *TM, *TR, *node; split2(root, l - 1, root, TM); split1(TM, r, TM, TR); int ans = 0; if (TM) ans += TM->sum; split1(TM, l - 1, node, TM); if (node) ans -= node->col * (l - node->l); TM = merge(node, TM); split2(TM, r, TM, node); if (node) ans -= node->col * (node->r - r); TM = merge(TM, node); root = merge(root, merge(TM, TR)); return ans; &#125; int n, m; int a[3000005]; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); int lst = 1; for (int i = 2; i &lt;= n; ++i) if (a[i] != a[i - 1]) root = merge(root, newNode(a[i - 1], lst, i - 1)), lst = i; root = merge(root, newNode(a[n], lst, n)); // PTREE(root); for (lst = 0; m--; ) &#123; int op = read(), l = read() ^ lst, r = read() ^ lst; if (op == 1) cover(l, r, 0); else if (op == 2) cover(l, r, 1); else if (op == 3) opt3(l, r); else if (op == 4) opt4(l, r); else if (op == 5) opt5(l, r); else if (op == 6) opt6(l, r); else print(lst = opt7(l, r)), putchar('\\n'); // PTREE(root); lst = 0; &#125; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"算法竞赛/学习笔记/数据结构","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"https://james1badcreeper.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"Treap","slug":"Treap","permalink":"https://james1badcreeper.github.io/tags/Treap/"},{"name":"Splay","slug":"Splay","permalink":"https://james1badcreeper.github.io/tags/Splay/"},{"name":"FHQ-Treap","slug":"FHQ-Treap","permalink":"https://james1badcreeper.github.io/tags/FHQ-Treap/"}]},{"title":"组合计数进阶","slug":"notes/数学/combination-ex","date":"2022-12-23T00:00:00.000Z","updated":"2022-12-23T00:00:00.000Z","comments":true,"path":"cb620531/","link":"","permalink":"https://james1badcreeper.github.io/cb620531/","excerpt":"高阶的计数问题更为困难。在阅读本文之前，请确保你对生成函数和多项式有一定的了解。","text":"高阶的计数问题更为困难。在阅读本文之前，请确保你对生成函数和多项式有一定的了解。 常见构造手段 计数问题有一些常有的求解手段。在研究更多内容前，我们先了解一下这些方法。 构造双射 不同的两个组合类中的组合对象可以一一对应，这样对两个组合类进行计数是等价的。 有时同一组合类中的组合对象可以建立一一对应（或多个为一组），我们只需抽取每对（或每组）中的一个进行计数，再乘上或除以相应的大小即可。 增量法 计数问题的常见手段，莫队的扩展也是这一思想。就是从 (n,m)(n,m)(n,m) 扩展到 (n+1,m+1)(n+1,m+1)(n+1,m+1)，考虑贡献增加的量。 有时问题无法直接处理，只能考虑增量法。 差分法 比如说查询恰好为 xxx 的方案数，可以用 ≤x\\le x≤x 的方案数和 ≤x−1\\le x-1≤x−1 的方案数相减得到。 权值的贡献 一般我们会从权值的角度去考虑，可以从权值下标的顺序进行考虑，也可以从每一个权值对式子的贡献考虑。 算两次 如维度的变换（枚举下标、权值）、贡献的计算（直接或增量计算）。选择合适的角度后，再使用加法原理和乘法原理等计数方法解决问题。 有时也可以考虑更换计数顺序，或者用两种不同的方式计算同一个量，从而建立相等关系。 Prufer 序列 这是一种将无根树转化为一个唯一的整数序列的表示方法（前提是，这个树应该至少有两个节点）。 构造 Prufer 序列可以将一个 nnn 个节点的无根树用 [1,n][1,n][1,n] 中的 n−2n-2n−2 个整数表示，常用于组合计数。 建立时，每次选择一个编号最小的叶子删除它，然后在序列中记录下它连接到的那个节点，重复 n−2n-2n−2 次算法结束。可以使用如下方法进行 O(n)O(n)O(n) 构造： 自增 ppp 使其指向编号最小的叶节点，将其删除； 检查是否产生新的叶节点，如果产生且编号比 ppp 小，则立即删除，重复此操作； ppp 自增，回到步骤 111 直到 Prufer 序列构造完毕。 还原 根据 Prufer 序列也可以还原树。方法是一样的，注意先将 prufer[n−1]prufer[n-1]prufer[n−1] 设为 nnn，并将赋值的内容反过来即可。具体见代码。 模板，代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 5000000; int n, m; i64 ans = 0; int fa[N + 5], du[N + 5]; int p[N + 5]; void treeToPrufer(void) &#123; for (int i = 1; i &lt; n; ++i) scanf(\"%d\", fa + i), ++du[fa[i]]; for (int i = 1, now = 1; i &lt; n; ++i, ++now) &#123; while (du[now]) ++now; p[i] = fa[now]; while (i &lt; n - 2 &amp;&amp; --du[p[i]] == 0 &amp;&amp; p[i] &lt; now) p[i + 1] = fa[p[i]], ++i; &#125; for (int i = 1; i &lt; n - 1; ++i) ans ^= 1ll * i * p[i]; &#125; void pruferToTree(void) &#123; for (int i = 1; i &lt; n - 1; ++i) scanf(\"%d\", p + i), ++du[p[i]]; p[n - 1] = n; for (int i = 1, now = 1; i &lt; n; ++i, ++now) &#123; while (du[now]) ++now; fa[now] = p[i]; while (i &lt; n - 1 &amp;&amp; --du[p[i]] == 0 &amp;&amp; p[i] &lt; now) fa[p[i]] = p[i + 1], ++i; &#125; for (int i = 1; i &lt; n; ++i) ans ^= 1ll * i * fa[i]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); if (m == 1) treeToPrufer(); else pruferToTree(); printf(\"%lld\\n\", ans); return 0; &#125; 性质 每个节点在 Prufer 序列中出现次数是其度数减 111。 完全图有 nn−2n^{n-2}nn−2 棵生成树，因为每一个 Prufer 序列都对应一棵树。这就是 Cayley 公式。 容斥原理与反演 反演是指两个函数（数列）之间的双射（比如前缀和和差分）。 子集反演 子集反演是针对集合交并的容斥，可以在恰好是某个集合和至多/至少是这个集合反演。 我们先来看与至多是这个集合的反演。现在有其元素满足某种条件的集合 AAA。定义 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 代表 S⊆AS\\subseteq AS⊆A 时的答案。 钦定选了 SSS 这个集合中的子集 TTT，有 g(S)=∑T⊆Sf(T)g(S)=\\sum_{T\\subseteq S}f(T)g(S)=∑T⊆S​f(T)，这时有 f(S)=∑T⊆S(−1)∣S∣−∣T∣g(T)f(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}g(T)f(S)=∑T⊆S​(−1)∣S∣−∣T∣g(T)。使用容斥原理不难感性理解。 类似的，如果 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 表示 A⊆SA\\subseteq SA⊆S 时的答案，有 g(S)=∑S⊆Tf(T)g(S)=\\sum_{S\\subseteq T}f(T)g(S)=∑S⊆T​f(T)，反演得 f(S)=∑S⊆T(−1)∣T∣−∣S∣g(T)f(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}g(T)f(S)=∑S⊆T​(−1)∣T∣−∣S∣g(T)。 实际上这是容斥原理的代数形式，它是我们用容斥原理解决问题的基础。因为在钦定时，一个“有两个元素满足条件”的东西会在“至少有一个元素满足条件”的东西计算时计算两次，也就因此成了一个子集反演的形式。 二项式反演 二项式反演是容斥原理的代数形式。假设全集 U={S1,S−2,⋯ ,Sn−1,Sn}U=\\{S_1, S-2, \\cdots, S_{n-1}, S_n\\}U={S1​,S−2,⋯,Sn−1​,Sn​}，且满足其中任意 iii 个集合的并集、交集大小都相等。g(x)g(x)g(x) 是其中任意 xxx 个集合的交集的大小，f(x)f(x)f(x) 是任意 xxx 个集合的补集的交集的大小。特别地，g(0)=f(0)=∣U∣g(0)=f(0)=|U|g(0)=f(0)=∣U∣。 我们有： g(n)= ∣S1∩S2∩⋯Sn−1∩Sn∣= ∣U∣−∣S1‾∪⋯∪Sn‾∣= ∣U∣−∑m=1n(−1)m−1∑ai&lt;ai+1∣Sa1‾∩⋯∩Sam‾∣= ∣U∣−∑i=1n(−1)i−1(ni)f(i)= ∑i=0n(−1)i(ni)f(i)\\begin{aligned} g(n)=\\ &amp;|S_1\\cap S_2\\cap\\cdots S_{n-1}\\cap S_n|\\\\ =\\ &amp;|U|-|\\overline{S_1}\\cup\\cdots\\cup\\overline{S_n}|\\\\ =\\ &amp;|U|-\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i &lt;a_{i+1}}|\\overline{S_{a_1}}\\cap\\cdots\\cap\\overline{S_{a_m}}|\\\\ =\\ &amp; |U|-\\sum_{i=1}^n(-1)^{i-1}\\binom{n}{i}f(i)\\\\ =\\ &amp;\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}f(i) \\end{aligned} g(n)= = = = = ​∣S1​∩S2​∩⋯Sn−1​∩Sn​∣∣U∣−∣S1​​∪⋯∪Sn​​∣∣U∣−m=1∑n​(−1)m−1ai​&lt;ai+1​∑​∣Sa1​​​∩⋯∩Sam​​​∣∣U∣−i=1∑n​(−1)i−1(in​)f(i)i=0∑n​(−1)i(in​)f(i)​ g(n)=∑i=0n(−1)i(ni)f(i) ⟺ f(n)=∑i=0n(−1)i(ni)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=0}^n(-1)^{i}\\binom{n}{i}g(i) \\end{aligned} ⟺​g(n)=i=0∑n​(−1)i(in​)f(i)f(n)=i=0∑n​(−1)i(in​)g(i)​ 如果令 f(i)′=(−1)if(i)f(i)&#x27;=(-1)^i f(i)f(i)′=(−1)if(i)，那么可以得到另一个形式（这个形式更为常用，因为大多数题并不会凑出一个 −1-1−1，以下式子中的 f,gf,gf,g 均没有特定的含义）： g(n)=∑i=0n(ni)f(i) ⟺ f(n)=∑i=0n(−1)n−i(ni)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=0}^n\\binom{n}{i}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=0}^n(-1)^{n-i}\\binom{n}{i}g(i) \\end{aligned} ⟺​g(n)=i=0∑n​(in​)f(i)f(n)=i=0∑n​(−1)n−i(in​)g(i)​ 同时还有一种上指标的二项式反演： g(n)=∑i=nN(−1)i(in)f(i) ⟺ f(n)=∑i=nN(−1)i(in)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=n}^N(-1)^i\\binom{i}{n}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=n}^N(-1)^i\\binom{i}{n}g(i) \\end{aligned} ⟺​g(n)=i=n∑N​(−1)i(ni​)f(i)f(n)=i=n∑N​(−1)i(ni​)g(i)​ g(n)=∑i=nN(in)f(i) ⟺ f(n)=∑i=nN(−1)i−n(in)g(i)\\begin{aligned} &amp;g(n)=\\sum_{i=n}^N\\binom{i}{n}f(i)\\\\ \\iff&amp; f(n)=\\sum_{i=n}^N(-1)^{i-n}\\binom{i}{n}g(i) \\end{aligned} ⟺​g(n)=i=n∑N​(ni​)f(i)f(n)=i=n∑N​(−1)i−n(ni​)g(i)​ 具体应用请见 Problemset。 斐波那契数 卡特兰数 格路计数问题 在平面直角坐标系中，横坐标和纵坐标都是整数的点称为格点，格路是指只经过格点的路径，格路的长度是其经过格点所走的步数。 看似简单的问题实则有非常多的变种，这里仅看几种简单的。 自由路问题 从 (0,0)(0,0)(0,0) 到 (n,m)(n,m)(n,m)，只能向上走或者向右走的格路称为自由路，不难看出方案数为 (n+mm)\\dbinom{n+m}{m}(mn+m​)。 斯特林数 其它计数数列 贝尔数 伯努利数 分拆数 欧拉数 Problemset 知识点比较杂，可能需要经常回顾。 Prufer 序列 基本上只将树转化为 Prufer，应用于计数。 [HNOI2004] 树的计数 Portal. Prufer 序列可以任意构造，而一个数会在 Prufer 序列中重复出现 di−1d_i-1di​−1 次，所以实际上这是多重集的排列数。另外，注意判无解。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, s; int d[155]; int c1[155], c2[155]; void divide(int x, int *c) &#123; for (int i = 2; i * i &lt;= x; ++i) while (x % i == 0) ++c[i], x /= i; if (x > 1) ++c[x]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", d + i), s += d[i]; if (n * 2 != s + 2) return !puts(\"0\"); if (n == 1) return !puts(d[1] == 0 ? \"1\" : \"0\"); for (int i = 1; i &lt; n - 1; ++i) divide(i, c1); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; d[i]; ++j) divide(j, c2); if (d[i] == 0) return !puts(\"0\"); &#125; i64 ans = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= c1[i] - c2[i]; ++j) ans *= i; printf(\"%lld\\n\", ans); return 0; &#125; [CF156D] Clues Portal. 只剩下 k−2k-2k−2 个点的 Prufer 序列来填，而已经填了的连通块可以根据乘法原理随便选来代表将此联通块抽象成一个点来根据 Prufer 序列构建树。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int P; int poww(int a, int b) &#123; if (b &lt; 0) return 1; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n, m; int col[100005], cnt, siz[100005]; vector&lt;int> G[100005]; void dfs(int x) &#123; ++siz[col[x] = cnt]; for (int y : G[x]) if (!col[y]) dfs(y); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;P); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; for (int i = 1; i &lt;= n; ++i) if (!col[i]) ++cnt, dfs(i); if (cnt == 1) return printf(\"%d\\n\", 1 % P), 0; int ans = poww(n, cnt - 2); for (int i = 1; i &lt;= cnt; ++i) ans = 1ll * ans * siz[i] % P; printf(\"%d\\n\", ans); return 0; &#125; [CF1762E] Tree Sum Portal. 设连接 iii 的边权为 did_idi​，而每条边对 ∏di\\prod d_i∏di​ 的贡献为 111，然而 nnn 为奇数时 ∏di=−1\\prod d_i=-1∏di​=−1 永远不可能满足，因此 nnn 为奇数时无解。 如果 nnn 为偶数且树的形态固定，那么参考 Prufer 序列的构造方式，从叶子开始赋予边权，那么方式一定是唯一的！也就是说，对于给定的树的形态只有一种方式。 这样的话，一条边 (u,v)(u,v)(u,v) 的权值为 111 的充要条件是：断掉这条边之后两个连通块大小均为偶数。因为这样两个连通块都满足条件了，这条边填 111 即可。 考虑逐边计算贡献，枚举 111 所在的连通块大小 iii，这样 nnn 所对应的连通块大小便为 n−in-in−i。 此时这条边的边权为 (−1)i(-1)^i(−1)i。 剩下 nnn 个点中随便扔，方案数为 (n−2i−1)\\binom{n-2}{i-1}(i−1n−2​)。 两块随便制造无根树，根据 Cayley 公式计算即可。 随便找两个点连接。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n; int fac[500005], ifac[500005]; int C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; int f(int n) &#123; if (n == 1) return 1; return poww(n, n - 2); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); if (n &amp; 1) return puts(\"0\"), 0; for (int i = fac[0] = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; ifac[n] = poww(fac[n], P - 2); for (int i = n - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; int ans = 0; for (int i = 1; i &lt; n; ++i) ans = (ans + (i &amp; 1 ? -1ll : 1ll) * i * (n - i) % P * C(n - 2, i - 1) % P * f(i) % P * f(n - i) % P) % P; printf(\"%d\\n\", (ans % P + P) % P); return 0; &#125; 格路计数问题 其变种很多，感兴趣的读者可以自行研究。 [CF559C] Gerald and Giant Chess Portal. 设 f(i)f(i)f(i) 为走到第 iii 个点的方案数，然后直接转移即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #define X first #define Y second using namespace std; typedef long long i64; const int MOD = 1000000007; int poww(i64 a, int b) &#123; a %= MOD; int res = 1; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int h, w, n; pair&lt;int, int> a[2005]; i64 fac[200005], f[2005]; int C(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || n &lt; m) return 0; return fac[n] * poww(fac[m] * fac[n - m], MOD - 2) % MOD; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;h, &amp;w, &amp;n); fac[0] = 1; for (int i = 1; i &lt;= 200000; ++i) fac[i] = fac[i - 1] * i % MOD; for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;a[i].X, &amp;a[i].Y); sort(a + 1, a + n + 1); a[n + 1] = &#123;h, w&#125;; for (int i = 1; i &lt;= n + 1; ++i) &#123; f[i] = C(a[i].X + a[i].Y - 2, a[i].X - 1); for (int j = 1; j &lt; i; ++j) f[i] = (f[i] - f[j] * C(a[i].X - a[j].X + a[i].Y - a[j].Y, a[i].X - a[j].X)) % MOD; f[i] = (f[i] + MOD) % MOD; &#125; printf(\"%lld\\n\", f[n + 1]); return 0; &#125; [JLOI2015] 骗我呢 Portal.说起来，毕业之后 B 君也就见过 R 君两面而已。R 君有一个 n×mn \\times mn×m 的数组 xi,j(1≤i≤n;1≤j≤m)x_{i,j}(1 \\le i \\le n; 1 \\le j \\le m)xi,j​(1≤i≤n;1≤j≤m)。对于 1≤i≤n;1≤j≤m1 \\le i \\le n; 1 \\le j \\le m1≤i≤n;1≤j≤m，满足0≤xi,j≤m0 \\le x_{i,j} \\le m0≤xi,j​≤m。求 可能的数组xi,jx_{i,j}xi,j​ 的解数。B 君觉得限制太宽松，还要求对于 1≤i≤n;1≤j&lt;m1 \\le i \\le n; 1 \\le j&lt;m1≤i≤n;1≤j&lt;m，满足 xi,j&lt;xi,j+1x_{i,j} &lt;x_{i,j+1}xi,j​&lt;xi,j+1​，对于 1&lt;i≤n;1≤j&lt;m1 &lt;i \\le n; 1 \\le j&lt;m1&lt;i≤n;1≤j&lt;m，满足 xi,j&lt;xi−1,j+1x_{i,j} &lt;x_{i-1,j+1}xi,j​&lt;xi−1,j+1​。B 君认为 R 君可以直接 pwn 掉这个题。R 君说：「黑的实在逼真 =.=，你起码把解数模 109+710^9+7109+7 吧。」B 君觉得 R 君说的有道理，于是想让你求解数模 109+710^9+7109+7 的结果。对于 100%100\\%100% 的数据，1≤m,n≤1061 \\leq m, n \\leq 10^61≤m,n≤106。 写出暴力 DP 转移方程后发现这其实是个格路计数问题，起点是 (0,0)(0,0)(0,0)，终点是 (n+m+1,n)(n+m+1,n)(n+m+1,n)，不能碰到 y=x+1,y=x−m−2y=x+1, y=x-m-2y=x+1,y=x−m−2。 我们将终点 TTT 做关于两条直线的对称，得到 T1,T2T1,T2T1,T2（翻转之后的路径也是可以翻转的）。这样我们只需要减去经过两条直线的方案数，而且是最后经过的（否则先经过一条直线再经过另一条的这种会算重，要及时减去）。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 1000000007; const int N = 3000000; int n, m; int fac[N + 5]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int C(int n, int m) &#123; if (n &lt; m || n &lt; 0 || m &lt; 0) return 0; return 1ll * fac[n] * poww(1ll * fac[m] * fac[n - m] % MOD, MOD - 2) % MOD; &#125; void trans(int &amp;x, int &amp;y, int k) &#123; swap(x, y); x -= k; y += k; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); fac[0] = 1; for (int i = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; int ans, x, y; for (x = n + m + 1, y = n, ans = C(x + y, y); x >= 0 &amp;&amp; y >= 0;) &#123; trans(x, y, 1); ans = (ans - C(x + y, y)) % MOD; trans(x, y, -m - 2); ans = (ans + C(x + y, y)) % MOD; &#125; for (x = n + m + 1, y = n; x >= 0 &amp;&amp; y >= 0;) &#123; trans(x, y, - m - 2); ans = (ans - C(x + y, y)) % MOD; trans(x, y, 1); ans = (ans + C(x + y, y)) % MOD; &#125; printf(\"%d\\n\", (ans % MOD + MOD) % MOD); return 0; &#125; 组合反演与容斥原理 包括二项式反演和子集反演，和一些容斥原理难题。 [Luogu P4859] 已经没有什么好害怕的了 Portal.给定长度为 nnn 的两个序列 A,BA,BA,B，要求两两配对使得 a&gt;ba&gt;ba&gt;b 的对数减去 a&lt;ba&lt;ba&lt;b 的对数等于 kkk 的情况个数，对 109+910^9+9109+9 取模，保证没有重复数字，n≤2000n\\le 2000n≤2000。 将 A,BA,BA,B 排序。设 a&gt;ba&gt;ba&gt;b 的数量为 xxx，那么 x=n+k2x=\\cfrac{n+k}{2}x=2n+k​（接下来的 kkk 均指 xxx），令 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个 aaa 中选了 jjj 组 a&gt;ba&gt;ba&gt;b 的方案数，易得 f0,0=1,fi,j=fi−1,j+fi−1,j−1∗(l[i]−j+1)f_{0,0}=1,f_{i,j}=f_{i-1,j}+f_{i-1,j-1}*(l[i]-j+1)f0,0​=1,fi,j​=fi−1,j​+fi−1,j−1​∗(l[i]−j+1)（l[i]l[i]l[i] 代表 BBB 中最后一个可以选的）。 设 g(i)g(i)g(i) 代表满足 a&gt;ba&gt;ba&gt;b 的组数 ≥i\\ge i≥i 的方案数，而 f(i)f(i)f(i) 代表恰好。显然 gi=fn,i×(n−i)!, g(k)=∑i=kn(ik)f(i)g_i=f_{n,i}\\times (n-i)!,\\ g(k)=\\sum_{i=k}^{n}\\binom{i}{k}f(i)gi​=fn,i​×(n−i)!, g(k)=∑i=kn​(ki​)f(i)（在 iii 中选择 kkk 个作为“至少”所要求的内容），使用二项式反演即可求出 f(k)f(k)f(k)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 1000000009; int poww(i64 a, int b) &#123; int res = 1; a %= MOD; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int n, k; int a[2005], b[2005], l[2005]; i64 f[2005][2005], g[2005], fac[2005]; int C(int n, int m) &#123; return fac[n] * poww(fac[m] * fac[n - m], MOD - 2) % MOD; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); k = (n + k) / 2; fac[0] = 1; for (int i = 1; i &lt;= 2002; ++i) fac[i] = fac[i - 1] * i % MOD; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i); sort(a + 1, a + n + 1); sort(b + 1, b + n + 1); f[0][0] = 1; for (int i = 1, p = 0; i &lt;= n; ++i) &#123; while (p &lt; n &amp;&amp; b[p + 1] &lt; a[i]) ++p; l[i] = p; &#125; for (int i = 1; i &lt;= n; ++i) &#123; f[i][0] = f[i-1][0]; for (int j = 1; j &lt;= i; ++j) f[i][j] = (f[i-1][j] + f[i-1][j-1] * max(0, l[i] - j + 1)) % MOD; &#125; for (int i = 0; i &lt;= n; ++i) g[i] = f[n][i] * fac[n - i] % MOD; int ans = 0; for (int i = k; i &lt;= n; ++i) ans = (ans + C(i, k) * g[i] * (i - k &amp; 1 ? -1 : 1)) % MOD; printf(\"%d\\n\", (ans % MOD + MOD) % MOD); return 0; &#125; [NOI Online #2 提高组] 游戏 Portal. 设 g(n)g(n)g(n) 代表恰好有 nnn 个非平局，f(n)f(n)f(n) 代表至少有 nnn 个非平局（可以通过树形背包求出），两者是一个二项式反演的形式。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 998244353; int poww(i64 a, int b) &#123; int res = 1; a %= MOD; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int n, a[5005], fac[5005], ifac[5005]; int siz[5005], sz[5005], g[5005], f[5005][5005]; // f: 至少有 i 个非平局 vector&lt;int> G[5005]; i64 C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % MOD * ifac[n - m] % MOD; &#125; void dfs(int x, int fa) &#123; siz[x] = 1; sz[x] = a[x]; f[x][0] = 1; for (auto y : G[x]) if (y != fa) &#123; dfs(y, x); for (int k = 0; k &lt;= siz[x] + siz[y]; ++k) g[k] = 0; for (int i = 0; i &lt;= min(siz[x], n / 2); ++i) if (f[x][i]) for (int j = 0; j &lt;= min(siz[y], n / 2); ++j) if (f[y][j]) g[i + j] = (g[i + j] + 1ll * f[x][i] * f[y][j] % MOD) % MOD; for (int k = 0; k &lt;= siz[x] + siz[y]; ++k) f[x][k] = g[k]; siz[x] += siz[y]; sz[x] += sz[y]; &#125; for (int i = min(sz[x], siz[x] - sz[x]); i >= 1; --i) f[x][i] = (f[x][i] + 1ll * f[x][i - 1] * ((a[x] ? siz[x] - sz[x] : sz[x]) - (i - 1))) % MOD; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%1d\", a + i); fac[i] = 1ll * fac[i - 1] * i % MOD; ifac[i] = poww(fac[i], MOD - 2); &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 0; i &lt;= n / 2; ++i) f[1][i] = 1ll * f[1][i] * fac[n / 2 - i] % MOD; // 除平局外，剩下的随便 for (int i = 0; i &lt;= n / 2; ++i) &#123; i64 res = 0; for (int j = i; j &lt;= n / 2; ++j) res = (res + (j - i &amp; 1 ? -1 : 1) * C(j, i) * f[1][j]) % MOD; printf(\"%lld\\n\", (res % MOD + MOD) % MOD); &#125; return 0; &#125; [ZJOI2016] 小星星 Portal.给定一张 nnn 个点的无向图和一棵 nnn 个节点的树。你可以给这棵树重编号，问有多少种方式使得这棵树是原图的生成树。n≤17n\\le 17n≤17。 想的暴力点，设 fi,j,Sf_{i,j,S}fi,j,S​ 代表考虑 iii 的子树，iii 的编号为 jjj，子树内的集合编号集合状压后为 SSS 的方案数。但是还得枚举子集，乘一个 O(3n)O(3^n)O(3n) 受不了！ 如果我们能求出允许重复的答案也可以。定义 f(S)f(S)f(S) 代表 SSS 没有重复时的方案数，而 g(S)g(S)g(S) 代表 SSS 中每个元素至少用一次。这样求出 ggg 之后直接用子集反演碾过去即可。 设 fi,j,Sf_{i,j,S}fi,j,S​ 代表点 iii 代表点 jjj，子树内点只能使用 SSS 内的作为映射，但是无需不重复。 有： fi,j,S=∏y∈son(x)(∑k∈S,(j,k)∈Efy,k,S)f_{i,j,S}=\\prod_{y\\in son(x)}\\left(\\sum_{k\\in S,(j,k)\\in E}f_{y,k,S}\\right) fi,j,S​=y∈son(x)∏​​k∈S,(j,k)∈E∑​fy,k,S​​ 时间复杂度降至 O(2nn3)O(2^n n^3)O(2nn3)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, S, v[20], tot; int E[20][20]; i64 f[20][20]; vector&lt;int> G[20]; void dfs(int x, int fa) &#123; for (int i = 1; i &lt;= tot; ++i) f[x][i] = 1; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); for (int i = 1; i &lt;= tot; ++i) &#123; // f[x][i] i64 tmp = 0; for (int j = 1; j &lt;= tot; ++j) if (E[v[i]][v[j]]) tmp += f[y][j]; f[x][i] *= tmp; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u][v] = E[v][u] = 1; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; i64 ans = 0; for (int S = 0; S &lt; 1 &lt;&lt; n; ++S) &#123; tot = 0; for (int i = 0; i &lt; n; ++i) if (S >> i &amp; 1) v[++tot] = i + 1; dfs(1, 0); i64 g = 0; for (int i = 1; i &lt;= tot; ++i) g += f[1][i]; ans += (n - tot &amp; 1) ? -g : g; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [ZJOI2022] 树 Portal. 开 幕 雷 击。 数数题优先考虑 DP。转移只能对每个点在两棵树上的父亲进行决策，这样 DP 状态只能记录可行的决策点个数，也就是可以作为父亲的点的个数。这样就要钦定剩余节点为叶子节点。 设 f(S)f(S)f(S) 代表第一棵树的叶子集合恰好为 SSS，g(T)g(T)g(T) 代表第二棵子树的叶子集合恰好为 TTT。但是不好搞！考虑子集反演，设 f′(S′)f&#x27;(S&#x27;)f′(S′) 代表钦定了第一棵树的叶子节点至多为 S′S&#x27;S′，g′(T′)g&#x27;(T&#x27;)g′(T′) 同理，则： Ans=∑S∩T=∅,S∪T={1,2,⋯ ,n}f(S)g(T)=∑S∩T=∅,S∪T={1,2,⋯ ,n}∑S′⊆S,T′⊆Tf′(S′)g′(T′)(−1)∣S∣−∣S′∣+∣T∣−∣T′∣=∑S′∩T′=∅f′(S′)g′(T′)(−1)n−∣S′∣−∣T′∣2n−∣S′∣−∣T′∣=∑S′∩T′=∅f′(S′)g′(T′)(−2)n−∣S′∣−∣T′∣\\begin{aligned} Ans&amp;=\\sum_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,\\cdots,n\\}}f(S)g(T)\\\\&amp;=\\sum_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,\\cdots,n\\}}\\sum_{S&#x27;\\subseteq S,T&#x27;\\subseteq T}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{|S|-|S&#x27;|+|T|-|T&#x27;|} \\\\&amp;=\\sum_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{n-|S&#x27;|-|T&#x27;|}2^{n-|S&#x27;|-|T&#x27;|}\\\\&amp;=\\sum_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-2)^{n-|S&#x27;|-|T&#x27;|} \\end{aligned} Ans​=S∩T=∅,S∪T={1,2,⋯,n}∑​f(S)g(T)=S∩T=∅,S∪T={1,2,⋯,n}∑​S′⊆S,T′⊆T∑​f′(S′)g′(T′)(−1)∣S∣−∣S′∣+∣T∣−∣T′∣=S′∩T′=∅∑​f′(S′)g′(T′)(−1)n−∣S′∣−∣T′∣2n−∣S′∣−∣T′∣=S′∩T′=∅∑​f′(S′)g′(T′)(−2)n−∣S′∣−∣T′∣​ 相当于钦定了 S′,T′S&#x27;,T&#x27;S′,T′ 作为可选做父亲的集合（选择一个叶子变成父亲），这样设 fi,j,kf_{i,j,k}fi,j,k​ 代表考虑到第 iii 个节点，∣{1,⋯ ,i}∩S′∣=j,∣{i+1⋯n}∩T′∣=k|\\{1,\\cdots,i\\}\\cap S&#x27;|=j,|\\{i+1\\cdots n\\}\\cap T&#x27;|=k∣{1,⋯,i}∩S′∣=j,∣{i+1⋯n}∩T′∣=k 的方案数。在第一棵子树当中有 jjj 中选择父亲的方法，第二棵树中有 kkk 种，总共 j×kj\\times kj×k 种。 fi−1,j,kf_{i-1,j,k}fi−1,j,k​ 可以转移到如下状态： iii 本来属于 S′S&#x27;S′，可以转移到 fi,j+1,kf_{i,j+1,k}fi,j+1,k​； iii 本来属于 T′T&#x27;T′，转移到 fi,j,k−1f_{i,j,k-1}fi,j,k−1​； 两个都不属于，转移到 fi,j,kf_{i,j,k}fi,j,k​，容斥系数为 −2-2−2。 好像有人在考场上直接猜出了容斥系数，神秘的。 初始时 f1,1,k=1f_{1,1,k}=1f1,1,k​=1，统计 k=1k=1k=1 时的答案即可（SSS 确定 TTT 自然也确定了）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int f[505][505][505], P; int main(void) &#123; scanf(\"%d%lld\", &amp;n, &amp;P); for (int i = 1; i &lt; n; ++i) f[1][1][i] = 1; for (int i = 2; i &lt;= n; ++i) &#123; int ans = 0; for (int j = 1; j &lt; i; ++j) for (int k = 1; k &lt;= n - i + 1; ++k) if (f[i - 1][j][k]) &#123; f[i][j][k] = (f[i][j][k] + -2ll * f[i - 1][j][k] % P * j * k % P) % P; f[i][j + 1][k] = (f[i][j + 1][k] + 1ll * f[i - 1][j][k] * j * k % P) % P; if (k) &#123; f[i][j][k - 1] = (f[i][j][k - 1] + 1ll * f[i - 1][j][k] * j * k % P) % P; if (k == 1) ans = (ans + 1ll * f[i - 1][j][k] * j * k % P) % P; &#125; &#125; printf(\"%d\\n\", (ans % P + P) % P); &#125; return 0; &#125; 组合综合 非常有意思！ [LNOI2022] 盒 Portal. 发现 wiw_iwi​ 会被使用 ∑∣∑j=1ibj−∑j=1iaj∣\\sum |\\sum_{j=1}^i b_j-\\sum_{j=1}^i a_j|∑∣∑j=1i​bj​−∑j=1i​aj​∣ 次。枚举 j=∑k=1ibkj=\\sum_{k=1}^i b_kj=∑k=1i​bk​，将 aaa 转化为其前缀和，合法的 i,ji,ji,j 的出现条件是前 iii 个数和为 jjj，后 n−in-in−i 个数和为 S−jS-jS−j，于是直接插板可以得到总贡献： ∑i=1n−1wi∑j=0S∣j−ai∣(j+i−1i−1)(S−j+n−i−1n−i−1)\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^S |j-a_i|\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} i=1∑n−1​wi​j=0∑S​∣j−ai​∣(i−1j+i−1​)(n−i−1S−j+n−i−1​) 这样的时间复杂度是 O(nS)O(nS)O(nS) 的。考虑拆绝对值，大概像这样： ∑i=1n−1wi∑j=0S(j−ai)(j+i−1i−1)(S−j+n−i−1n−i−1)+2∑i=1n−1wi∑j=0ai(ai−j)(j+i−1i−1)(S−j+n−i−1n−i−1)\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^S (j-a_i)\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1}+2\\sum_{i=1}^{n-1}w_i\\sum_{j=0}^{a_i} (a_i-j)\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} i=1∑n−1​wi​j=0∑S​(j−ai​)(i−1j+i−1​)(n−i−1S−j+n−i−1​)+2i=1∑n−1​wi​j=0∑ai​​(ai​−j)(i−1j+i−1​)(n−i−1S−j+n−i−1​) 这样让 jjj 从 000 开始枚举的目的是让接下来好算。后面的式子显然条件更强，因此以后面那个为例。由于出现减法不好搞，因此拆掉： ∑j=0aiai(j+i−1i−1)(S−j+n−i−1n−i−1)−∑j=0aij(j+i−1i−1)(S−j+n−i−1n−i−1)\\sum_{j=0}^{a_i} a_i \\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1}-\\sum_{j=0}^{a_i} j\\binom{j+i-1}{i-1}\\binom{S-j+n-i-1}{n-i-1} j=0∑ai​​ai​(i−1j+i−1​)(n−i−1S−j+n−i−1​)−j=0∑ai​​j(i−1j+i−1​)(n−i−1S−j+n−i−1​) 前面那个 aia_iai​ 可以直接搞出来，后面那个利用 (nm)=(nm−1)(n−m+1)\\binom{n}{m}=\\binom{n}{m-1}(n-m+1)(mn​)=(m−1n​)(n−m+1) 将 jjj 改为 iii 再扔出来。 现在仅剩的问题就是快速计算： f(n,m,i,k)=∑j=0k(j+i−1i−1)(m−j−1+n−in−i−1)f(n,m,i,k)=\\sum_{j=0}^k \\binom{j+i-1}{i-1}\\binom{m-j-1+n-i}{n-i-1} f(n,m,i,k)=j=0∑k​(i−1j+i−1​)(n−i−1m−j−1+n−i​) 快速计算 f(n,m,i,k)f(n,m,i,k)f(n,m,i,k)？然而这个式子是拆不动了，考虑使用增量法计算。kkk 的增量是好处理的，但是 iii 呢？不知道。从组合意义的角度考虑，fff 是将前 iii 个和 ≤k\\le k≤k 的数，且所有 nnn 个数和为 mmm 的方案数。相当于是将 mmm 个相同的球放到 nnn 个不同的盒子中，前 iii 个盒子最多只能放 kkk 个球，相当于第 k+1k+1k+1 个小球不在前 iii 个盒子里！那么枚举放的位置，插板有： f(n,m,i,k)=∑j=i+1n(k+j−1j−1)(m−k−1+n−jn−j)f(n,m,i,k)=\\sum_{j=i+1}^n \\binom{k+j-1}{j-1}\\binom{m-k-1+n-j}{n-j} f(n,m,i,k)=j=i+1∑n​(j−1k+j−1​)(n−jm−k−1+n−j​) 那么就可以使用这个式子维护 iii 的增量了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; const int N = 4000000; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x; &#125; inline int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n; int a[500005], w[500005]; int fac[4000005], ifac[4000005]; int C(int n, int m) &#123; if (m &lt; 0 || n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; &#125; struct Creeper &#123; int n, m, i, k, ans; Creeper(int n, int m, int i, int k) : n(n), m(m), i(i), k(k), ans(0) &#123; for (int j = 0; j &lt;= k; ++j) ans = (ans + 1ll * C(j + i - 1, i - 1) * C(m - j + n - i - 1, n - i - 1)) % P; &#125; void mvi(int mi) &#123; for (int j = i + 1; j &lt;= mi; ++j) ans = (ans - 1ll * C(k + j - 1, j - 1) * C(m - k - 1 + n - j, n - j)) % P; i = mi; &#125; void mvk(int mk) &#123; for (int j = k + 1; j &lt;= mk; ++j) ans = (ans + 1ll * C(j + i - 1, i - 1) * C(m - j - 1 + n - i, n - i - 1)) % P; k = mk; &#125; &#125;; int main(void) &#123; for (int i = fac[0] = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % P; ifac[N] = poww(fac[N], P - 2); for (int i = N - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; for (int T = read(); T--; ) &#123; n = read(); int ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = a[i - 1] + read(); for (int i = 1; i &lt; n; ++i) w[i] = read(); Creeper A(n + 1, a[n] - 1, 1, a[n] - 1); Creeper B(n, a[n], 1, a[n]); Creeper C(n, a[n], 1, 0); Creeper D(n + 1, a[n] - 1, 1, -1); for (int i = 1; i &lt; n; ++i) &#123; int res = 0; C.mvk(a[i]); D.mvk(a[i] - 1); A.mvi(i + 1); B.mvi(i); C.mvi(i); D.mvi(i + 1); res = (res + 1ll * i * A.ans) % P; res = (res - 1ll * a[i] * B.ans) % P; res = (res + 2ll * a[i] * C.ans) % P; res = (res - 2ll * i * D.ans) % P; ans = (ans + 1ll * res * w[i]) % P; &#125; printf(\"%d\\n\", (ans % P + P) % P); &#125; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"算法竞赛/学习笔记/数学","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://james1badcreeper.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"数学","slug":"数学","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"多项式与生成函数基础","slug":"notes/数学/polynomial","date":"2022-12-23T00:00:00.000Z","updated":"2022-12-23T00:00:00.000Z","comments":true,"path":"18f7c808/","link":"","permalink":"https://james1badcreeper.github.io/18f7c808/","excerpt":"多项式很有工程价值（不仅限于计算机科学），研究多项式计算及其性质，可以加速许多运算。而以 FFT 为基础的算法可以直接操纵生成函数。","text":"多项式很有工程价值（不仅限于计算机科学），研究多项式计算及其性质，可以加速许多运算。而以 FFT 为基础的算法可以直接操纵生成函数。 概念 一个环 RRR 上的多项式写作 f(x)f(x)f(x)，代表 ∑i=0fixi\\sum\\limits_{i=0} f_ix^{i}i=0∑​fi​xi。其中 fi∈Rf_i\\in Rfi​∈R。xxx 被称为这个多项式的自由元，所有 RRR 上的多项式组成多项式环R[x]R[x]R[x]。 如果允许项数无穷的，即 f(x)=f0+f1x+f2x2+⋯f(x)=f_0+f_1x+f_2x^2+\\cdotsf(x)=f0​+f1​x+f2​x2+⋯，那么可以得到形式幂级数环 R[[x]]R[[x]]R[[x]]，其中的每个元素 fff 称为形式幂级数。 对于一个多项式 f(x)f(x)f(x)，称其系数非零的最高次项的次数为该多项式的度（Degree），记作 deg⁡F\\deg FdegF。 使得 f(x)=0f(x)=0f(x)=0 的所有 xxx 称为多项式的根。 如果 fif_ifi​ 均为实数，那么 fff 称为实系数多项式；若可以为复数，则成为复系数多项式。 表示方法 形式幂级数形式表示的多项式称为系数表示法，而将 x=xix=x_ix=xi​ 带入多项式，求出的 yi=f(xi)y_i=f(x_i)yi​=f(xi​)，称 (xi,yi)(x_i,y_i)(xi​,yi​) 为 fff 在 xix_ixi​ 处的点值，使用若干点值表示多项式的方式称为点值表示法。 拉格朗日插值算法可以将点值表示法转化为系数表示法。 多项式加减 有： f(x)+g(x)=∑i=0n(fi+gi)xif(x)+g(x)=\\sum_{i=0}^n (f_i+g_i)x^i f(x)+g(x)=i=0∑n​(fi​+gi​)xi 时间复杂度为 O(n)O(n)O(n)。 卷积 设 f, g\\textbf{f, g}f, g 是两个数列，那么这两个数列的卷积 h\\textbf{h}h 定义为： hk=∑i+j=kfigjh_k=\\sum_{i+j=k}f_ig_j hk​=i+j=k∑​fi​gj​ 多项式乘法 给定多项式 f(x),g(x)f(x),g(x)f(x),g(x)，那么其乘积 q(x)q(x)q(x) 满足： q(x)=∑i=0n∑j=0maibjxi+jq(x)=\\sum_{i=0}^{n}\\sum_{j=0}^m a_ib_jx^{i+j} q(x)=i=0∑n​j=0∑m​ai​bj​xi+j 这个过程可以使用 FFT 加速，将在下文介绍。 普通生成函数 生成函数（generating function），又称母函数，是一种形式幂级数（它不是函数，xxx 不是自变量而是自由元），其每一项的系数可以提供关于这个序列的信息[1]。这是个很有用的东西，是用于刻画数列的组合工具，能够将很多复杂的组合问题赋以简洁的代数形式，考场上也会出现不需要多项式算法只用生成函数就能解决的问题。 大多数生成函数可以表示为： F(x)=∑iaiki(x)F(x)=\\sum_{i} a_i k_i(x) F(x)=i∑​ai​ki​(x) 其中 ki(x)k_i(x)ki​(x) 被称之为核函数，对于普通的生成函数，ki(x)=xik_i(x)=x^iki​(x)=xi。注意这个 aaa 既可以是有穷序列，也可以是无穷序列。 在本小节中我们只讨论普通生成函数（OGF），它的核函数为 kn(x)=xnk_n(x)=x^nkn​(x)=xn。实际上，普通生成函数的系数就是序列 aaa 的通项公式。 术语约定 对于 OGF F(x)F(x)F(x)，xxx 是自由元，因此没有实际意义，只是一个占位符，xix_ixi​ 用来代表它是第 iii 个占位符，F[i]F[i]F[i] 可以表示 F(x)F(x)F(x) 的第 iii 次项系数，简称 iii 次项，000 次项称为常数项。 为了方便提取其中某一项的系数，有 [xi]F(x)=F[i][x^i]F(x)=F[i][xi]F(x)=F[i]。 生成函数中的求和符号并不是无穷项求和，它只是一个记号，代表的是序列。两个生成函数 F(x),G(x)F(x),G(x)F(x),G(x) 相等当且仅当 ∀i∈N,F[i]=G[i]\\forall i\\in\\mathbb{N}, F[i]=G[i]∀i∈N,F[i]=G[i]。 对于序列 aaa，如果从某一项开始它后面都是 000，那么可以认为它是一个有穷序列。如果它是有穷的，那么它的生成函数是一个有穷幂级数，否则是无穷幂级数。 基本运算 考虑两个序列 a,ba,ba,b 的普通生成函数F(x),G(x)F(x),G(x)F(x),G(x)，那么它们的加减法和乘法运算是跟多项式一样的。因此对于生成函数 F(x),G(x)F(x),G(x)F(x),G(x)，有： F(x)±G(x)=∑n(an±bn)xn,F(x)G(x)=∑nxn∑i=0naibn−i=∑i∑jF[i]G[j]xijF(x)\\pm G(x)=\\sum_{n}(a_n\\pm b_n)x^n,\\\\ \\begin{aligned} F(x)G(x)&amp;=\\sum_{n}x^n\\sum_{i=0}^n a_i b_{n-i}\\\\ &amp;=\\sum_{i}\\sum_j F[i]G[j]x^{ij} \\end{aligned} F(x)±G(x)=n∑​(an​±bn​)xn,F(x)G(x)​=n∑​xni=0∑n​ai​bn−i​=i∑​j∑​F[i]G[j]xij​ 因此 F(x)±G(x)F(x)\\pm G(x)F(x)±G(x) 是序列 &lt;an±bn&gt;\\left&lt;a_n\\pm b_n\\right&gt;⟨an​±bn​⟩ 的普通生成函数，F(x)G(x)F(x)G(x)F(x)G(x) 是 序列&lt;∑i=0naibn−i&gt;\\left&lt;\\sum_{i=0}^n a_i b_{n-i}\\right&gt;⟨∑i=0n​ai​bn−i​⟩ 的普通生成函数。 对于幂次运算，F(x)F(x)F(x) 的 nnn 次幂记作 Fn(x)F^n(x)Fn(x)，特别地，F0(x)=1F^0(x)=1F0(x)=1。 对 F(x)F(x)F(x) 的 nnn 次幂提取 mmm 次项系数，可以记 Fn[m]F^n[m]Fn[m] 为： Fn[m]=[xm]Fn(x)F^n[m]=[x^m]F^n(x) Fn[m]=[xm]Fn(x) 封闭形式 形式幂级数的生成函数不一定好算，有时会将其转换为封闭形式。 比如说 &lt;1,1,⋯ &gt;\\left&lt;1,1,\\cdots\\right&gt;⟨1,1,⋯⟩ 的普通生成函数为 F(x)=∑n≥0xnF(x)=\\sum_{n\\ge 0}x^nF(x)=∑n≥0​xn，发现 F(x)x+1=F(x)F(x)x+1=F(x)F(x)x+1=F(x)，因此得到 F(x)=11−xF(x)=\\cfrac{1}{1-x}F(x)=1−x1​，这就是生成函数的封闭形式。 作为练习，可以看一下将这几个题： 010203（二项式定理）04（求导，前缀和与差分，数学归纳法） 写出 a=&lt;0,1,1,⋯ &gt;a=\\left&lt;0,1,1,\\cdots \\right&gt;a=⟨0,1,1,⋯⟩ 的生成函数。 有 F(x)=∑n≥1xnF(x)=\\sum_{n\\ge 1}x^nF(x)=∑n≥1​xn，因此 F(x)x+x=F(x)⇒F(x)=x1−xF(x)x+x=F(x)\\Rightarrow F(x)=\\cfrac{x}{1-x}F(x)x+x=F(x)⇒F(x)=1−xx​。 写出 a=&lt;1,0,1,0,1,0⋯ &gt;a=\\left&lt;1,0,1,0,1,0\\cdots \\right&gt;a=⟨1,0,1,0,1,0⋯⟩ 的生成函数。 有 F(x)=∑n≥0x2n=∑n≥0(x2)nF(x)=\\sum_{n\\ge 0} x^{2n}=\\sum_{n\\ge 0} (x^{2})^nF(x)=∑n≥0​x2n=∑n≥0​(x2)n，因此 F(x)x2+1=F(x)⇒11−x2F(x)x^2+1=F(x)\\Rightarrow \\cfrac{1}{1-x^2}F(x)x2+1=F(x)⇒1−x21​。 写出序列 an=(mn)a_n=\\dbinom{m}{n}an​=(nm​) 的生成函数（mmm 是常数，n≥0n\\ge 0n≥0）。 F(x)=∑n≥0(mn)xn=(1+x)m\\begin{aligned} F(x)&amp;=\\sum_{n\\ge 0}\\binom{m}{n}x^n\\\\ &amp;=(1+x)^m \\end{aligned} F(x)​=n≥0∑​(nm​)xn=(1+x)m​ 写出 a=&lt;1,2,3,4,5,6⋯ &gt;a=\\left&lt;1,2,3,4,5,6\\cdots \\right&gt;a=⟨1,2,3,4,5,6⋯⟩ 的生成函数。 F(x)=∑n≥0nxn−1=∑n≥0(xn)′=1(1−x)2\\begin{aligned} F(x)&amp;=\\sum_{n\\ge 0}nx^{n-1}\\\\ &amp;=\\sum_{n\\ge 0} (x^n)&#x27;\\\\ &amp;=\\frac{1}{(1-x)^2} \\end{aligned} F(x)​=n≥0∑​nxn−1=n≥0∑​(xn)′=(1−x)21​​ 可以发现求一个序列的前缀和的生成函数只需要乘上 11−x\\cfrac{1}{1-x}1−x1​，求差分只需要乘上 1−x1-x1−x。 实际上我们有： 1(1−x)n+1=∑i(n+in)xi\\frac{1}{(1-x)^{n+1}}=\\sum_{i}\\binom{n+i}{n}x^i (1−x)n+11​=i∑​(nn+i​)xi 为什么呢？当 n=1n=1n=1 时，原式成立；当 n&gt;1n&gt;1n&gt;1 时，有： 1(1−x)n+1=11−x1(1−x)n=∑ixi∑i(n+i−1n−1)xi=∑ixi∑j=0i(n+j−1j)=∑i(n+in)xi\\begin{aligned} \\frac{1}{(1-x)^{n+1}}&amp;=\\frac{1}{1-x}\\frac{1}{(1-x)^{n}}\\\\ &amp;=\\sum_{i}x^i\\sum_{i}\\binom{n+i-1}{n-1}x^i\\\\ &amp;=\\sum_{i}x^i\\sum_{j=0}^i\\binom{n+j-1}{j}\\\\ &amp;=\\sum_{i}\\binom{n+i}{n}x^i \\end{aligned} (1−x)n+11​​=1−x1​(1−x)n1​=i∑​xii∑​(n−1n+i−1​)xi=i∑​xij=0∑i​(jn+j−1​)=i∑​(nn+i​)xi​ 它还可以说明一个问题：如果 f(x)f(x)f(x) 是关于 xxx 的 kkk 次多项式，那么 f(x)f(x)f(x) 的差分是 k−1k-1k−1 次多项式，前缀和是 k+1k+1k+1 次多项式。 简单题 说了这么多感觉很绕？我们通过几道简单的题目来见证生成函数的强大威力，即使多项式算法还没有登场。 生成函数能简单的将序列的运算转换为式子的运算，并通过系数来还原序列。对于无穷项的序列，可以试将其转化为封闭形式进行计算；当封闭形式无法直接得出结果，也可以将其转化会形式幂级数。 [六省联考 2017] 组合数问题 Portal. 令 F(x)=∑i(nki)xi=(1+x)nk\\displaystyle F(x)=\\sum_{i} \\binom{nk}{i}x^i=(1+x)^{nk}F(x)=i∑​(ink​)xi=(1+x)nk，那么要求的就是 ∑i mod k=rF[i]\\displaystyle\\sum_{i\\bmod k=r}F[i]imodk=r∑​F[i]。 前者直接暴力计算生成函数的卷积，然后快速幂即可。底数是什么？千万记住，xxx 只是自由元，因此 1+x⇒a[0]=a[1]=11+x\\Rightarrow a[0]=a[1]=11+x⇒a[0]=a[1]=1。由于是求对 kkk 取模的结果，因此幂次可以在模 kkk 的意义下进行，最终答案就是 ans[r]ans[r]ans[r]。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef vector&lt;int> VI; typedef long long i64; int n, p, k, r; VI operator * (const VI &amp;a, const VI &amp;b) &#123; VI ans(k); for (int i = 0; i &lt; k; ++i) for (int j = 0; j &lt; k; ++j) ans[(i + j) % k] = (ans[(i + j) % k] + 1ll * a[i] * b[j]) % p; return ans; &#125; int main(void) &#123; cin >> n >> p >> k >> r; vector&lt;int> a(k), ans(k); ans[0] = 1; if (k == 1) a[0] = 2; else a[0] = a[1] = 1; i64 e = 1ll * n * k; for (; e; e >>= 1, a = a * a) if (e &amp; 1) ans = ans * a; cout &lt;&lt; ans[r] &lt;&lt; \"\\n\"; return 0; &#125; [Luogu P2000] 拯救世界 Portal. 对于一种召唤方式，设 ana_nan​ 代表这种召唤方式选择 nnn 个的方案数，求出序列 aaa 的生成函数。那么两种召唤方式一共有 nnn 块石头的选择方式就是这两个生成函数的卷积 FFF 的第 nnn 项系数。 一共有 101010 个限制条件，依次写出它们的生成函数（封闭形式），然后把它们都乘起来得到 1(1−x)5\\cfrac{1}{(1-x)^5}(1−x)51​。转化成形式幂级数就是 ∑i(i+44)xi\\displaystyle\\sum_{i}\\binom{i+4}{4}x^ii∑​(4i+4​)xi。因此答案是 (n+44)\\dbinom{n+4}{4}(4n+4​)。 查看代码 # decimal 采用压位 NTT 实现，足够快 from decimal import * getcontext().prec = 1000000 n = Decimal(input()) print((n + 1) * (n + 2) * (n + 3) * (n + 4) // 24) 拉格朗日插值 拉格朗日插值是沟通多项式的系数形式与点值形式的重要公式。 事实上，nnn 个点确定唯一的多项式，其最高项次数为 n−1n-1n−1。 从系数表示法转化为点值表示法可以考虑直接带入，时间复杂度为 O(n2)O(n^2)O(n2)。可以使用多项式算法加速到 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。 可以使用拉格朗日插值法将点值表示法转化为系数表示法，通用情况时时间复杂度为 O(n2)O(n^2)O(n2)，可以用多项式算法加速到 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。 一般形式 模板。nnn 个点可以确定一个多项式 f(x)f(x)f(x)，请求出 f(k)f(k)f(k)。 核心思想是利用点值的可加性。什么意思？ 构造一个函数 f(x)f(x)f(x) 经过 P(x1,y1),⋯P(xn,yn)P(x_1,y_1),\\cdots P(x_n,y_n)P(x1​,y1​),⋯P(xn​,yn​)，设第 iii 个点在 xxx 轴上的投影为 Pi′(xi,0)P_i^{\\prime}(x_i,0)Pi′​(xi​,0)。考虑构造 nnn 个函数，使得 fi(x)f_i(x)fi​(x) 的图像经过 {Pj′(xj,0),(j≠i)Pi(xi,yi)\\begin{cases}P_j^{\\prime}(x_j,0),(j\\neq i)\\\\P_i(x_i,y_i)\\end{cases}{Pj′​(xj​,0),(j=i)Pi​(xi​,yi​)​，则 f(x)=∑i=1nfi(x)f(x)=\\sum_{i=1}^{n}f_i(x)f(x)=∑i=1n​fi​(x)。 设 fi(x)=a∏j≠i(x−xj)f_i(x)=a\\prod_{j\\ne i}(x-x_j)fi​(x)=a∏j=i​(x−xj​)，然后将 PiP_iPi​ 的坐标代入求出 a=yi∏j≠i(xi−xj)a=\\cfrac{y_i}{\\prod_{j\\ne i}(x_i-x_j)}a=∏j=i​(xi​−xj​)yi​​，进而导出： f(k)=∑i=1nyi∏i≠jk−xjxi−xjf(k)=\\sum_{i=1}^n y_i\\prod_{i\\ne j}\\frac{k-x_j}{x_i-x_j} f(k)=i=1∑n​yi​i=j∏​xi​−xj​k−xj​​ 这就是拉格朗日插值表达式。 如果要求出系数，用 O(n2)O(n^2)O(n2) 卷出 F(x)=∏i=1n(x−xi)F(x)=\\prod_{i=1}^n (x-x_i)F(x)=∏i=1n​(x−xi​)，然后对于每个 iii 暴力将 FFF 除掉 x−xix-x_ix−xi​ 算出 F(x)x−xi\\cfrac{F(x)}{x-x_i}x−xi​F(x)​ 的各项系数，再乘 yi∏j≠ixi−xj\\cfrac{y_i}{\\prod_{j\\ne i}{x_i-x_j}}∏j=i​xi​−xj​yi​​ 即可得到 fif_ifi​ 的各项系数，加起来即可。时间复杂度为 O(n2)O(n^2)O(n2)。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int n, k; int x[2005], y[2005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", x + i, y + i); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int s1 = y[i], s2 = 1; for (int j = 1; j &lt;= n; ++j) if (i != j) s1 = 1ll * s1 * (k - x[j]) % MOD, s2 = 1ll * s2 * (x[i] - x[j]) % MOD; ans = (ans + 1ll * s1 * poww(s2, MOD - 2)) % MOD; &#125; printf(\"%d\\n\", (ans % MOD + MOD) % MOD); return 0; &#125; 连续情况 当已知点的坐标是连续整数时，可以 O(n)O(n)O(n) 完成拉格朗日插值。以 0,1⋯n−10,1\\cdots n-10,1⋯n−1 为例： 有： f(x)=∑i=0n−1yi∏i≠jx−ji−jf(x)=\\sum_{i=0}^{n-1} y_i\\prod_{i\\ne j}\\frac{x-j}{i-j} f(x)=i=0∑n−1​yi​i=j∏​i−jx−j​ 分子是一堆数的乘积挖掉了一个项，典型维护前后缀积。 对于 i&gt;ji&gt;ji&gt;j 的分母，有 ∏j=0i−1(i−j)=i!\\displaystyle \\prod_{j=0}^{i-1}(i-j)=i!j=0∏i−1​(i−j)=i!，对于 i&lt;ji&lt;ji&lt;j，有 ∏j=i+1n−1(i−j)=(−1)(−2)⋯(i−n+1)\\displaystyle \\prod_{j=i+1}^{n-1}(i-j)=(-1)(-2)\\cdots(i-n+1)j=i+1∏n−1​(i−j)=(−1)(−2)⋯(i−n+1)，也就是 (−1)n−i+1(n−i−1)!(-1)^{n-i+1}(n-i-1)!(−1)n−i+1(n−i−1)!。 所以： f(x)=∑i=0n−1yipisii!(−1)n−i+1(n−i−1)!f(x)=\\sum\\limits_{i=0}^{n-1} y_i \\frac{p_is_i}{i!(-1)^{n - i + 1}(n-i-1)!} f(x)=i=0∑n−1​yi​i!(−1)n−i+1(n−i−1)!pi​si​​ 集合幂级数 形式幂级数是刻画数列的重要方式，而集合幂级数是处理集合的特殊形式。 由于笔者现在不会 FFT，因此会避开其与 FFT 相关的内容。 定义 形式化地，域 FFF 上的集合幂级数 fff 是 2U→F2^U\\rightarrow F2U→F 的函数，对于每个 S⊂US\\subset US⊂U，函数 fff 均有对应的取值 fS∈Ff_S\\in FfS​∈F。 集合幂级数的加法非常容易，按位相加即可。而乘法比较复杂，有很多种，但是都满足分配律（包括逆运算）。 FMT &amp; FWT 给定序列 an,bn{a_n},{b_n}an​,bn​，求出序列 cn{c_n}cn​，满足 ci=∑j⊕k=iajbkc_i=\\sum_{j\\oplus k=i}a_j b_kci​=∑j⊕k=i​aj​bk​，这样的操作称之为卷积。当其为加号时是我们熟悉的多项式乘法（和卷积），而其为乘号时为狄利克雷卷积。 模板。用 FMT 解决与卷积和或卷积（或卷积被称为并卷积），用 FWT 来解决异或卷积（异或卷积为对称差卷积）。 我们首先来介绍 FMT（快速莫比乌斯变换）。以或卷积为例，定义序列 {a0,⋯a2n−1}\\{a_0,\\cdots a_{2^n-1}\\}{a0​,⋯a2n−1​} 的 FMT 变换为：FMT⁡(a)i=∑j⊆iaj\\operatorname{FMT}(a)_i=\\sum_{j\\subseteq i}a_jFMT(a)i​=∑j⊆i​aj​，IFMT 为上述变换的逆变换。那么或卷积等价于 c=IFMT⁡(FMT⁡(a)⋅FMT⁡(b))c=\\operatorname{IFMT}(\\operatorname{FMT}(a)\\cdot \\operatorname{FMT}(b))c=IFMT(FMT(a)⋅FMT(b))。 然后我们来介绍 FWT（快速沃尔什变换），其本质就是高维不进位的加法卷积。其定义式为：FWT⁡(a)i=∑j⊆i(−1)∣i−j∣aj\\operatorname{FWT}(a)_i = \\sum_{j\\subseteq i} (-1)^{|i-j|}a_jFWT(a)i​=∑j⊆i​(−1)∣i−j∣aj​。IFWT 为上述变换的逆变换。 时间复杂度均为 O(n×2n)O(n\\times 2^n)O(n×2n)。 性质 FMT 和 FWT 以及它们的逆运算都是一种线性变换。 以 FMT 或卷积为例（FWT 同理），设 fif_ifi​ 代表第 iii 个集合幂级数，那么： ∏fi=IFMT⁡(∏FMT⁡(fi))\\prod f_i=\\operatorname{IFMT}(\\prod\\operatorname{FMT}(f_i)) ∏fi​=IFMT(∏FMT(fi​)) 左边的求积符号代表集合并卷积，右边的代表对应系数相乘。 这样我们就可以解决模板题了： 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1 &lt;&lt; 17; const int P = 998244353; int n, a[N], b[N], A[N], B[N]; void in(void) &#123; memcpy(A, a, N &lt;&lt; 2), memcpy(B, b, N &lt;&lt; 2); &#125; void get(void) &#123; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) A[i] = 1ll * A[i] * B[i] % P; &#125; void print(void) &#123; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) printf(\"%d \", A[i]); putchar('\\n'); &#125; void OR(int *f, int c) &#123; for (int i = 1; i &lt; 1 &lt;&lt; n; i &lt;&lt;= 1) for (int j = 0; j &lt; 1 &lt;&lt; n; ++j) if (i &amp; j) f[j] = (f[j] + 1ll * c * f[j ^ i] % P + P) % P; &#125; void AND(int *f, int c) &#123; for (int i = 1; i &lt; 1 &lt;&lt; n; i &lt;&lt;= 1) for (int j = 0; j &lt; 1 &lt;&lt; n; ++j) if (i &amp; j) f[j ^ i] = (f[j ^ i] + 1ll * c * f[j] + P) % P; &#125; void XOR(int *f, int c) &#123; for (int k = 1; k &lt; 1 &lt;&lt; n; k &lt;&lt;= 1) for (int i = 0; i &lt; 1 &lt;&lt; n; i += k &lt;&lt; 1) for (int j = 0, x, y; j &lt; k; ++j) x = f[i | j], y = f[i | j | k], f[i | j] = (x + y) % P, f[i | j | k] = (x - y + P) % P; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) f[i] = 1ll * f[i] * c % P; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) scanf(\"%d\", a + i); for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) scanf(\"%d\", b + i); in(); OR(A, 1); OR(B, 1); get(); OR(A, P - 1); print(); in(); AND(A, 1); AND(B, 1); get(); AND(A, P - 1); print(); int inv = (P + 1) >> 1; for (int i = 1; i &lt; n; ++i) inv = 1ll * inv * (P + 1 >> 1) % P; in(); XOR(A, 1); XOR(B, 1); get(); XOR(A, inv); print(); return 0; &#125; 高维前缀和 集合幂级数 fff 经过 FMT 得到的莫比乌斯变换形式与高维前缀和有着密不可分的关系。 FMT 在令第 iii 位为 111 开始操作时可以看作在第 iii 个维度进行高维前缀和。 子集卷积 定义子集卷积为： ci=∑jor⁡k=i,jand⁡k=0ajbkc_i=\\sum_{j\\operatorname{or} k = i,j\\operatorname{and}k=0}a_j b_k ci​=jork=i,jandk=0∑​aj​bk​ 注意当 jor⁡k=i,jand⁡k=0j\\operatorname{or}k = i,j\\operatorname{and}k=0jork=i,jandk=0 的充要条件是 ∣j∣+∣k∣=i|j|+|k|=i∣j∣+∣k∣=i。设 fi,S=[∣S∣=i]fSf_{i,S}=[|S|=i]f_Sfi,S​=[∣S∣=i]fS​，ggg 同理。令 Hi=∑j+k=ifjgkH_i=\\sum_{j+k=i}f_jg_kHi​=∑j+k=i​fj​gk​，这里的 HiH_iHi​ 代表一个集合幂级数。 等式两边同时 FMT，计算出 HHH 之后 IFMT 回来即可。时间复杂度 O(n22n)O(n^2 2^n)O(n22n)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000009, N = 20; int n; int f[21][1 &lt;&lt; N], g[21][1 &lt;&lt; N], h[1 &lt;&lt; N], ans[1 &lt;&lt; N], popcnt[1 &lt;&lt; N]; void FMT(int *f, int c) &#123; for (int i = 1; i &lt; 1 &lt;&lt; n; i &lt;&lt;= 1) for (int j = 0; j &lt; 1 &lt;&lt; n; ++j) if (i &amp; j) f[j] = (f[j] + c * f[j ^ i]) % P; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) f[i] = (f[i] % P + P) % P; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) popcnt[i] = popcnt[i >> 1] + (i &amp; 1); for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) scanf(\"%d\", &amp;f[popcnt[i]][i]); for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) scanf(\"%d\", &amp;g[popcnt[i]][i]); for (int i = 0; i &lt;= n; ++i) FMT(f[i], 1), FMT(g[i], 1); ans[0] = 1ll * f[0][0] * g[0][0] % P; for (int i = 1; i &lt;= n; ++i) &#123; memset(h, 0, sizeof h); for (int j = i; j >= 0; --j) for (int k = 0; k &lt; 1 &lt;&lt; n; ++k) h[k] = (h[k] + 1ll * f[j][k] * g[i - j][k] % P) % P; FMT(h, -1); for (int j = 0; j &lt; 1 &lt;&lt; n; ++j) if (popcnt[j] == i) ans[j] = h[j]; &#125; for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) printf(\"%d \", (ans[i] % P + P) % P); return putchar('\\n'), 0; &#125; 快速傅里叶变换（FFT） 万恶之源，快速傅里叶变换，FFT，它可以快速计算多项式的卷积。 模板，代码如下： 快速数论变换（NTT） Problemset 前 222 个小节没有使用多项式算法。 拉格朗日插值 很有用。 [CF622F] The Sum of the k-th Powers Portal. 将其写成一个序列：∑i=11ik,∑i=12ik,∑i=13ik,⋯\\sum_{i=1}^1 i^k,\\sum_{i=1}^2 i^k,\\sum_{i=1}^3 i^k,\\cdots∑i=11​ik,∑i=12​ik,∑i=13​ik,⋯。 差分后得到：1k,2k,3k⋯1^k,2^k,3^k\\cdots1k,2k,3k⋯，这个数列的通项公式是一个 kkk 次多项式，那么取前缀和之后是一个 k+1k+1k+1 次多项式。 使用连续情况的拉格朗日插值，不预处理逆元的话是线性对数的。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int n, k, pre[1000005], suf[1000005], fac[1000005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); fac[0] = pre[0] = suf[k + 3] = 1; for (int i = 1; i &lt;= k + 2; ++i) fac[i] = 1ll * fac[i - 1] * i % P; for (int i = 1; i &lt;= k + 2; ++i) pre[i] = 1ll * pre[i - 1] * (n - i) % P; for (int i = k + 2; i >= 1; --i) suf[i] = 1ll * suf[i + 1] * (n - i) % P; int ans = 0, y = 0; for (int i = 1; i &lt;= k + 2; ++i) &#123; y = (y + poww(i, k)) % P; int a = 1ll * pre[i - 1] * suf[i + 1] % P; int b = 1ll * fac[i - 1] * (k - i &amp; 1 ? -1 : 1) * fac[k + 2 - i] % P; ans = (ans + 1ll * y * a % P * poww(b, P - 2) % P) % P; &#125; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; [集训队互测 2012] calc Portal. 设 fi,jf_{i,j}fi,j​ 表示考虑前 iii 个数，值域为 [1,j][1,j][1,j]，而且限制取的要上升，这样： fi,j=fi−1,j−1×j+fi,j−1f_{i,j}=f_{i-1,j-1}\\times j + f_{i,j-1} fi,j​=fi−1,j−1​×j+fi,j−1​ 最终答案为 fn,k×n!f_{n,k}\\times n!fn,k​×n!。 推测 fn,if_{n,i}fn,i​ 是关于 iii 的 g(n)g(n)g(n) 次多项式。这个转移方程有差分的形式： fn,i−fn,i−1=fn−1,i−1×if_{n,i}-f_{n,i-1}=f_{n-1,i-1}\\times i fn,i​−fn,i−1​=fn−1,i−1​×i 左边是关于 iii 的 g(n)−1g(n)-1g(n)−1 次多项式，右边是关于 iii 的 g(n−1)+1g(n-1)+1g(n−1)+1 次多项式，因此： g(n)−1=g(n−1)+1g(n)-1=g(n-1)+1 g(n)−1=g(n−1)+1 而 g(0)=0g(0)=0g(0)=0，这样可以得出 g(n)=2ng(n)=2ng(n)=2n。 那么我们只需要求出 f(n,1)⋯f(n,2n+1)f(n,1)\\cdots f(n,2n+1)f(n,1)⋯f(n,2n+1)，然后就可以使用拉格朗日插值求出 f(n,k)f(n,k)f(n,k)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int P; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) res = 1ll * res * a % P; return res; &#125; int k, n, fac = 1; int f[505][1005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;k, &amp;n, &amp;P); for (int i = 1; i &lt;= n; ++i) fac = 1ll * fac * i % P; for (int j = 0; j &lt;= n * 2 + 1; ++j) f[0][j] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n * 2 + 1; ++j) f[i][j] = (1ll * f[i - 1][j - 1] * j % P + f[i][j - 1]) % P; int ans = 0; for (int i = 1; i &lt;= n * 2 + 1; ++i) &#123; int a = 1ll * f[n][i] * fac % P, b = 1; for (int j = 1; j &lt;= n * 2 + 1; ++j) if (i != j) a = 1ll * a * (k - j) % P, b = 1ll * b * (i - j) % P; ans = (ans + 1ll * a * poww(b, P - 2)) % P; &#125; printf(\"%d\\n\", (ans + P) % P); return 0; &#125; [省选联考 2022] 填树 Portal. 考虑钦定一个最小值 www，选择的范围就是 [w,w+K][w,w+K][w,w+K]，然后容斥减去没有取到最小值的 [w+1,w+K][w+1,w+K][w+1,w+K] 的部分。 确定一个 www 时答案可以直接进行一次树形 DP 求出。不同取值范围可以划分成不同段，在同一段内的答案是一个关于 www 的多项式（一个点的方案数是一次的，权值是二次的，链求和后依然是多项式），拉格朗日插值维护每一段即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int sgn[2] = &#123;1, P - 1&#125;; inline int poww(int a, int b) &#123; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int n, K, l[205], r[205]; vector&lt;int> G[205]; int f[205], g[205], d1[205], d2[205]; // f 经过，d 从开始 int ans1, ans2; void dfs(int x, int fa, int L, int R) &#123; f[x] = g[x] = d1[x] = d2[x] = 0; int ql = max(L, l[x]), qr = min(R, r[x]); int cntx = (ql &lt;= qr) ? qr - ql + 1 : 0; int sumx = (ql &lt;= qr) ? 1ll * (ql + qr) * (qr - ql + 1) / 2 % P : 0; f[x] = d1[x] = cntx; g[x] = d2[x] = sumx; for (int y : G[x]) if (y != fa) &#123; dfs(y, x, L, R); f[x] = (f[x] + f[y]) % P; g[x] = (g[x] + g[y]) % P; g[x] = (g[x] + 1ll * d2[x] * d1[y] + 1ll * d1[x] * d2[y]) % P; d2[x] = (d2[x] + 1ll * d2[y] * cntx + 1ll * d1[y] * sumx) % P; f[x] = (f[x] + 1ll * d1[x] * d1[y]) % P; d1[x] = (d1[x] + 1ll * d1[y] * cntx) % P; &#125; &#125; int m, a[805]; int Y1[805], Y2[805], pre[805], suf[805], inv[405]; void solve(int w) &#123; m = 0; a[++m] = w + 1; a[++m] = 1000000001; for (int i = 1; i &lt;= n; ++i) &#123; if (l[i] > w) a[++m] = l[i]; if (r[i] > w) a[++m] = r[i]; if (l[i] > K) a[++m] = l[i] - K + w; if (r[i] > K) a[++m] = r[i] - K + w; &#125; sort(a + 1, a + m + 1); m = unique(a + 1, a + m + 1) - (a + 1); for (int i = 1; i &lt; m; ++i) &#123; int k = min(a[i + 1] - a[i] + 3, n + 5); for (int j = 1; j &lt;= k; ++j) dfs(1, 0, a[i] + (j - 1), a[i] + (j - 1) + K - w), Y1[j] = f[1], Y2[j] = g[1]; for (int j = 1; j &lt;= k; ++j) Y1[j] = (Y1[j] + Y1[j - 1]) % P, Y2[j] = (Y2[j] + Y2[j - 1]) % P; int x = a[i + 1] - a[i]; pre[0] = suf[k + 1] = 1; for (int j = 1; j &lt;= k; ++j) pre[j] = 1ll * pre[j - 1] * (x - j + P) % P; for (int j = k; j >= 1; --j) suf[j] = 1ll * suf[j + 1] * (x - j + P) % P; for (int j = 1; j &lt;= k; ++j) &#123; int t = 1ll * pre[j - 1] * suf[j + 1] % P * inv[j - 1] % P * inv[k - j] % P * sgn[(k - j) &amp; 1] % P * sgn[w] % P; ans1 = (ans1 + 1ll * t * Y1[j]) % P; ans2 = (ans2 + 1ll * t * Y2[j]) % P; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;K); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", l + i, r + i); inv[0] = inv[1] = 1; for (int i = 2; i &lt;= n + 5; ++i) inv[i] = 1ll * (P - P / i) * inv[P % i] % P; for (int i = 3; i &lt;= n + 5; ++i) inv[i] = 1ll * inv[i - 1] * inv[i] % P; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; solve(0); solve(1); return printf(\"%d\\n%d\\n\", ans1, ans2), 0; &#125; 集合幂级数 [ABC212H] Nim Counting Portal.给定两个数 N,KN,KN,K，以及一个长度为 KKK 的整数数组 (Ai,A2...AK)(A_i,A_2...A_K)(Ai​,A2​...AK​)。现在通过以下方式生成一个 Nim 游戏：任意选择一个 1≤M≤N1\\le M\\le N1≤M≤N，MMM 表示石子堆数。对于每一堆，其石子数是 AAA 中任意一个数。对于 ∑i=1NKi\\sum_{i=1}^N K^i∑i=1N​Ki 种游戏，求先手获胜的游戏数，答案对 998244353998244353998244353 取模。1≤N≤2×1051\\le N\\le 2\\times 10^51≤N≤2×105，1≤Ai,K&lt;2161\\le A_i,K&lt;2^{16}1≤Ai​,K&lt;216。AiA_iAi​ 两两不同。 相当于是给定了一个集合幂级数。nnn 堆式子就是 nnn 个这样的集合幂级数的异或卷积。 利用 FWT 的性质就可以先将集合幂级数们加起来（等比数列求和），再 IFWT 一次。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 16, P = 998244353; inline int poww(int a, int b) &#123; a %= P; int r = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int n, k, f[1 &lt;&lt; N]; void FWT(int *f, int c) &#123; for (int k = 1; k &lt; 1 &lt;&lt; N; k &lt;&lt;= 1) for (int i = 0; i &lt; 1 &lt;&lt; N; i += k &lt;&lt; 1) for (int j = 0, x, y; j &lt; k; ++j) x = f[i | j], y = f[i | j | k], f[i | j] = (x + y) % P, f[i | j | k] = (x - y + P) % P; for (int i = 0; i &lt; 1 &lt;&lt; N; ++i) f[i] = 1ll * f[i] * c % P; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1, x; i &lt;= k; ++i) scanf(\"%d\", &amp;x), ++f[x]; FWT(f, 1); for (int i = 0; i &lt; 1 &lt;&lt; N; ++i) if (f[i] == 1) f[i] = n; else f[i] = 1ll * (poww(f[i], n + 1) - f[i] + P) * poww(f[i] - 1 + P, P - 2) % P; FWT(f, poww(P + 1 >> 1, N)); int ans = 0; for (int i = 1; i &lt; 1 &lt;&lt; N; ++i) ans = (ans + f[i]) % P; return printf(\"%d\\n\", ans), 0; &#125; [省选联考 2022] 卡牌 Portal. 根号分治，≤2000\\le \\sqrt{2000}≤2000​ 的质数只有 131313 个（到 414141）。考虑维护 fif_ifi​ 代表有多少种选择方式使得恰好覆盖 iii 的高维前缀和。预处理时 fff 只维护幂次（这样可以减少取模）。 对于含有大质数的卡牌，直接每个都乘上当前质数的选择即可。 最后直接 IFMT 求出真实值。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; const int P[13] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41&#125;; const int V = 1 &lt;&lt; 13; inline void add(int &amp;x, int t) &#123; x += t; if (x >= MOD) x -= MOD; &#125; inline void sub(int &amp;x, int t) &#123; x -= t; if (x &lt; 0) x += MOD; &#125; int n, m; int a[2005], pw[1000005]; int c, p[18005], f[V], g[2005][V], h[V]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), ++a[x]; for (int i = pw[0] = 1; i &lt;= n; ++i) pw[i] = (pw[i - 1] &lt;&lt; 1) % MOD; for (int i = 1; i &lt;= 2000; ++i) if (a[i]) &#123; int tmp = i, msk = 0; for (int j = 0; j &lt; 13; ++j) while (tmp % P[j] == 0) tmp /= P[j], msk |= 1 &lt;&lt; j; for (int j = 0; j &lt; V; ++j) if ((j &amp; msk) == msk) f[j] += a[i]; if (tmp == 43 * 43) tmp = 43; // 43 * 43 &lt; 2000, 43 * 47 > 2000 if (tmp > 1) &#123; for (int j = 0; j &lt; V; ++j) if ((j &amp; msk) == msk) g[tmp][j] += a[i]; &#125; &#125; scanf(\"%d\", &amp;m); while (m--) &#123; scanf(\"%d\", &amp;c); int ans = 0, msk = 0; for (int i = 1; i &lt;= c; ++i) scanf(\"%d\", p + i); sort(p + 1, p + c + 1); c = unique(p + 1, p + c + 1) - (p + 1); memcpy(h, f, sizeof h); for (int i = 1; i &lt;= c; ++i) if (p[i] &lt;= 41) &#123; for (int j = 0; j &lt; 13; ++j) if (p[i] == P[j]) msk |= 1 &lt;&lt; j; &#125; else &#123; // 将这个大质数的贡献减去，到时候重新统计 for (int j = 0; j &lt; V; ++j) h[j] -= g[p[i]][j]; &#125; for (int i = 0; i &lt; V; ++i) h[i] = pw[h[i]]; for (int i = 1; i &lt;= c; ++i) if (p[i] > 41) for (int j = 0; j &lt; V; ++j) h[j] = 1ll * h[j] * (pw[g[p[i]][j]] - 1) % MOD; // 排掉一个都不选 // IFMT 或卷积逆运算，高维差分 for (int i = 1; i &lt; V; i &lt;&lt;= 1) for (int j = 0; j &lt; V; ++j) if (i &amp; j) sub(h[j], h[j ^ i]); for (int i = 0; i &lt; V; ++i) if ((i &amp; msk) == msk) add(ans, h[i]); printf(\"%d\\n\", ans); &#125; return 0; &#125; 具体的各类生成函数请参考《组合计数进阶》，这里仅介绍基本内容。 ↩︎","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"多项式","slug":"多项式","permalink":"https://james1badcreeper.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"组合计数基础","slug":"notes/数学/combination","date":"2022-12-20T00:00:00.000Z","updated":"2022-12-20T00:00:00.000Z","comments":true,"path":"6513c499/","link":"","permalink":"https://james1badcreeper.github.io/6513c499/","excerpt":"组合计数是组合数学的基础，研究某组离散对象满足一定条件的安排的存在性、构造及计数等问题。看似名字人畜无害，实则“算死人，不偿命”。本文将引导你学习简单的组合计数，为接下来学习毒瘤的计数问题作准备。","text":"组合计数是组合数学的基础，研究某组离散对象满足一定条件的安排的存在性、构造及计数等问题。看似名字人畜无害，实则“算死人，不偿命”。本文将引导你学习简单的组合计数，为接下来学习毒瘤的计数问题作准备。 基本概念 组合计数中有一些基本概念，在这里简略地进行介绍。 加法原理 比如 james1 要吃东西，他可以吃傻瓜果和笨蛋果两种果子，市面上在售的傻瓜果有 333 种，笨蛋果有 444 种，如果 james1 只吃一颗果子就能吃饱，那么他就有 3+4=73+4=73+4=7 种选择去吃饱。 形式化地，完成一个 Project 可以有 nnn 类办法，aia_iai​ 代表第 iii 类方法的数目。那么完成这个 Project 共有 S=a1+a2+⋯+an=∑i=1naiS=a_1+a_2+\\cdots+a_n=\\sum\\limits_{i=1}^{n}a_iS=a1​+a2​+⋯+an​=i=1∑n​ai​ 种不同的方法。 乘法原理 比如 james1 要变傻（雾），要吃一种傻瓜果和一种笨蛋果，市面上在售的傻瓜果有 333 种，笨蛋果有 444 种，那么 james1 变傻的方式就有 3×4=123 \\times 4 = 123×4=12。 形式化地，完成一个 Project 可以有 nnn 个步骤，aia_iai​ 代表完成第 iii 步的方法数目。那么完成这个 Project 共有 S=a1×a2×⋯×an=∏i=1naiS=a_1 \\times a_2\\times\\cdots\\times a_n=\\prod\\limits_{i=1}^{n}a_iS=a1​×a2​×⋯×an​=i=1∏n​ai​ 种不同的方法。 抽屉原理（鸽笼原理） 常用于存在性证明与极端情况求解，分为两种情况： 简单形式 james1 要将 n+1n+1n+1 个笨蛋果放到 nnn 个鸽笼中，那么可以得出至少有一个鸽笼中有两个（或以上）笨蛋果。 证明： 采用反证法。假如每个分组有至多 111 个物体，那么最多有 nnn 个物体，而却有 n+1n+1n+1 个物体，矛盾。 证毕。 推广 james1 要将 nnn 个傻瓜果放到 kkk 个鸽笼中，那么可以得出至少有一个鸽笼中有大于或等于 ⌈nk⌉\\lceil \\cfrac{n}{k} \\rceil⌈kn​⌉ 个笨蛋果。 证明同样采用反证法，留给读者撕烤。 排列数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照一定的顺序排成一列，方案个数记作 AnmA_{n}^{m}Anm​（推荐）或 PnmP_{n}^{m}Pnm​。 显然，第一个数有 nnn 种取法。 第二个数有 n−1n-1n−1 种。 …\\dots… 第 mmm 个数有 n−m+1n-m+1n−m+1 种取法。 综上所述，有： Anm=n(n−1)(n−2)⋯(n−m+1)=n!(n−m)!A_{n}^{m}=n(n-1)(n-2)\\cdots(n-m+1)=\\cfrac{n!}{(n-m)!} Anm​=n(n−1)(n−2)⋯(n−m+1)=(n−m)!n!​ 置换和排列 一个有限集合 SSS 到自身的双射称为 SSS 的一个置换，集合 S=a1,⋯ ,anS={a_1,\\cdots,a_n}S=a1​,⋯,an​ 的置换可以表示为： f=(a1,a2,…,anap1,ap2,…,apn)f=\\begin{pmatrix}a_1,a_2,\\dots,a_n\\\\ a_{p_1},a_{p_2},\\dots,a_{p_n} \\end{pmatrix} f=(a1​,a2​,…,an​ap1​​,ap2​​,…,apn​​​) 是将 aia_iai​ 映射为 apia_{p_i}api​​，这样 ppp 是 1⋯n1\\cdots n1⋯n 的一个排列，SSS 上的所有置换的数量为 n!n!n!。 置换的过程可以使用有向图来理解，连边 i→pii\\rightarrow p_ii→pi​，就是所有点移动 111 的距离。 对于两个置换 f,gf,gf,g 的乘积记作 f∘gf\\circ gf∘g，代表先通过 fff 的映射，再通过 ggg 的映射。 一个排列中的逆序对个数，也叫做反序数，如果是偶数就是偶排列，奇数则是奇排列。 对于一个排列 1,⋯ ,n1,\\cdots,n1,⋯,n，如果将任意两个数 i,ji,ji,j 交换，其它数保持不动，就会得到一个新的排列，那么这样一个变换叫做对换，用 (i,j)(i,j)(i,j) 表示。 组合数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照任意的顺序组成一个集合，方案个数记作 CnmC_{n}^{m}Cnm​。 这 mmm 个人是没有顺序的，所以 AmmA_{m}^{m}Amm​ 个方案是同一个方案，所以总方案数为： Cnm=AnmAmm=n!(n−m)!÷m!=n!(n−m)!m!Cnm=AnmAmm=n(n−1)(n−2)⋯(n−m+1)m!=∏i=n−m+1nim!C_{n}^{m}=\\cfrac{A_{n}^{m}}{A_{m}^{m}}=\\cfrac{n!}{(n-m)!} \\div m! = \\cfrac{n!}{(n-m)!m!}\\\\ C_{n}^{m}=\\cfrac{A_{n}^{m}}{A_{m}^{m}}=\\cfrac{n(n-1)(n-2)\\cdots(n-m+1)}{m!}=\\cfrac{\\prod_{i=n-m+1}^n i}{m!} Cnm​=Amm​Anm​​=(n−m)!n!​÷m!=(n−m)!m!n!​Cnm​=Amm​Anm​​=m!n(n−1)(n−2)⋯(n−m+1)​=m!∏i=n−m+1n​i​ 实际上，组合数也通常用 (nm)\\dbinom{n}{m}(mn​) 表示，相当于 CnmC_{n}^{m}Cnm​，这也被称之为二项式系数。 组合数有以下性质： Cnm=Cnn−mC_{n}^{m} = C_{n}^{n-m}Cnm​=Cnn−m​； Cn0+Cn1+Cn2+⋯+Cnn=∑i=0nCni=2nC_{n}^{0}+C_{n}^{1}+C_{n}^{2}+\\cdots+C_{n}^{n}=\\sum\\limits_{i=0}^{n}C_{n}^{i}=2^nCn0​+Cn1​+Cn2​+⋯+Cnn​=i=0∑n​Cni​=2n； (nk)=n−k+1k(nk−1)\\dbinom{n}{k}=\\cfrac{n-k+1}{k}\\dbinom{n}{k-1}(kn​)=kn−k+1​(k−1n​)。 证明： 从 nnn 个数中选 mmm 作为子集，剩下的 n−mn-mn−m 个数也对应一个集合（这一点可以用公式证明，留给读者撕烤）。从 nnn 个不同元素取出若干个元素组成一个集合，当然可以取 0∼n0\\sim n0∼n 个数，即 ∑i=0nCni\\sum\\limits_{i=0}^{n}C_{n}^{i}i=0∑n​Cni​，每个数又有取和不取两种可能，所以它等于 2n2^n2n。由组合数的公式可以推导出，它经常被用来递推求单个组合数。大概长这样：int C(int n, int m) &#123; int res = 1; for (int i = 1; i &lt;= m; ++i) res = 1ll * res * (n - i + 1) / i; return res; &#125; 然后是一些不是那么好想，但是在关键时刻非常有用的内容，推荐背诵： (nm)=nm(n−1m−1)\\dbinom{n}{m}=\\cfrac{n}{m}\\dbinom{n-1}{m-1}(mn​)=mn​(m−1n−1​)； ∑i=0m(ni)(mm−i)=(m+nm)(n≥m)\\sum\\limits_{i=0}^m\\dbinom{n}{i}\\dbinom{m}{m-i}=\\dbinom{m+n}{m}(n\\ge m)i=0∑m​(in​)(m−im​)=(mm+n​)(n≥m)，当 n=mn=mn=m 时有 ∑i=0n(ni)2=(2nn)\\sum\\limits_{i=0}^{n}{\\dbinom{n}{i}}^2=\\dbinom{2n}{n}i=0∑n​(in​)2=(n2n​)； ∑i=0n(ik)=(n+1k+1)\\sum\\limits_{i=0}^{n}\\dbinom{i}{k}=\\dbinom{n+1}{k+1}i=0∑n​(ki​)=(k+1n+1​)； (nr)(rk)=(nk)(n−kr−k)\\dbinom{n}{r}\\dbinom{r}{k}=\\dbinom{n}{k}\\dbinom{n-k}{r-k}(rn​)(kr​)=(kn​)(r−kn−k​)，相当于是 nnn 只喵喵中选 rrr 个队长，再在队长中选择 kkk 个大队长，等价于 nnn 只喵喵先选 kkk 个大队长再选 r−kr-kr−k 个队长，因为大队长也是队长。 杨辉三角 杨辉三角长这样（所有的空格值都为 000）： 杨辉三角 第 000 列 第 111 列 第 222 列 第 333 列 第 444 列 第 000 行 111 第 111 行 111 111 第 222 行 111 222 111 第 333 行 111 333 333 111 第 444 行 111 444 666 444 111 可以观察出 Cnm=Cn−1m+Cn−1m−1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnm​=Cn−1m​+Cn−1m−1​。 证明： 想选出 mmm 个数，要么选第 nnn 个数，要么不选，分别对应 Cn−1mC_{n-1}^{m}Cn−1m​ 和 Cn−1m−1C_{n-1}^{m-1}Cn−1m−1​。 所以组合数的杨辉三角递推代码如下： C[0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; j++) C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; &#125; 二项式定理 高中学过二项式定理： (a+b)n=∑i=1n(ni)an−ibi(a+b)^n = \\sum_{i=1}^{n}\\binom{n}{i}a^{n-i}b^i (a+b)n=i=1∑n​(in​)an−ibi 这个式子非常有用，一定要熟记。另外可以发现，多项式的系数就是杨辉三角。 排列组合方法 我们来看三个问题，来引出排列组合的经典计算方法。 捆绑法 nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子关系特别好，它们一定要站在一块。那么有多少种排列方法？ 我们把这 mmm 只兔子看作一只大兔子，那么总共就有 n−m+1n-m+1n−m+1 只兔子，排列方案数是 (n−m+1)!(n-m+1)!(n−m+1)!，然而大兔子里面也有 m!m!m! 中方法，那么总方法数就是 (n−m+1)!m!(n-m+1)!m!(n−m+1)!m!。这就是捆绑法。 插空法 nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子有着不共戴天之仇，它们一定要不能站在一块。那么有多少种排列方法？ 我们先把 n−mn-mn−m 只兔子给排列好，有 (n−m)!(n-m)!(n−m)! 种方法。这些兔子之间有 (n−m+1)(n-m+1)(n−m+1) 个空（算最左和最右），再把这些不共戴天的兔子放到这些空里，有 An−m+1mA_{n-m+1}^{m}An−m+1m​ 个方法。总方案数就是 (n−m)!×An−m+1m(n-m)!\\times A_{n-m+1}^{m}(n−m)!×An−m+1m​。这就是插空法。 插板法 james1 要将 nnn 个相同的胡萝卜分给 mmm 只兔子，他秉持雨露均沾的原则，每只兔子至少分到 111 根胡萝卜，有多少种方案？ 我们先介绍隔板法（插板法），是指在 nnn 个元素的 n−1n-1n−1 个空中插入 kkk 个板，可以把 nnn 个元素分为 k+1k+1k+1 组。 我们把这 nnn 个胡萝卜排成 111 行，当中就有 n−1n-1n−1 个空。现在往里面插入 m−1m-1m−1 个板，就可以将胡萝卜分为 mmm 组，正好可以分给 mmm 只兔子，而且由于不存在在同一个地方插两个板的情况，所以正好每一只兔子都能至少分到 111 根胡萝卜。那么答案就是 (n−1m−1)\\dbinom{n-1}{m-1}(m−1n−1​)。 实际上这个问题相当于求不定方程 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的正整数解的数量。 如果他是个大魔王（不可能，绝对不可能），有的兔子可能 111 根胡萝卜都得不到，那么有多少种方案？ 同样的方法，如果允许有兔子分到 000 根胡萝卜，我们只需要再加上 mmm 根胡萝卜，就相当于刚才的问题了。答案是 (n+m−1m−1)=(n+m−1n)\\dbinom{n+m-1}{m-1}=\\dbinom{n+m-1}{n}(m−1n+m−1​)=(nn+m−1​)。 这个问题本质上是要求 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的自然数解的数量。 如果 james1 偏爱一些兔子，要求第 iii 个兔子至少分到 eie_iei​ 个胡萝卜，那么有多少种分法呢？ 类比上一个问题，我们再加上 ∑e\\sum e∑e 个胡萝卜，答案就是 (n+∑e−1n)\\dbinom{n+\\sum e - 1}{n}(nn+∑e−1​)。 在 nnn 个数中选 mmm 个组合，要求任意两个数都不相邻，那么方案数有多少？ (n−m+1n)\\dbinom{n-m+1}{n}(nn−m+1​)，因为我们需要插入 m−1m-1m−1 个空。 简单问题 真的只是加法原理和乘法原理而已。 [Luogu P1866] 编号 Portal. 为了尽可能防止负数需要先排序，然后使用乘法原理计算。但如果负数真的出现了，就无解。 查看代码 #include &lt;bits/stdc++.h> #define i64 long long using namespace std; const i64 MOD = 1000000007; int n; int a[55]; i64 ans = 1; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); for (int i = 1, k; i &lt;= n; i++) &#123; if ((k = a[i] - (i - 1)) > 0) ans = ans * k % MOD; else return puts(\"0\"), 0; &#125; printf(\"%d\\n\", ans); return 0; &#125; [NOIP2016 提高组] 组合数问题 Portal. 我们直接利用杨辉三角预处理组合数，然后使用二维前缀和计算答案即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int C[2005][2005]; int ans[2005][2005]; int main(void) &#123; int T, k; scanf(\"%d%d\", &amp;T, &amp;k); for (int i = 0; i &lt;= 2002; ++i) &#123; C[i][0] = 1, C[i][i] = 1; for (int j = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k; &#125; for (int i = 0; i &lt;= 2002; ++i) &#123; for (int j = 1; j &lt;= i; ++j) ans[i][j] = ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1] + (C[i][j] == 0); ans[i][i + 1] = ans[i][i]; &#125; while (T--) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", ans[n][min(n, m)]); &#125; return 0; &#125; [Luogu P1287] 盒子与球 Portal. 设 f(i,j)f(i,j)f(i,j) 代表考虑前 iii 个球，有 jjj 个盒子的方案数。显然可以是由前 i−1i-1i−1 个球，jjj 个盒子放在这 jjj 个盒子中的任意一个，也可以只考虑 j−1j-1j−1 个盒子，只能放在第 jjj 个盒子，但是这第 jjj 个盒子的位置可以任意摆放。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, r; int f[15][15]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;r); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= min(i, r); ++j) f[i][j] = j * (f[i - 1][j] + f[i - 1][j - 1]); printf(\"%d\\n\", f[n][r]); return 0; &#125; 那么盒子相同呢？这样可以乘 jjj 的就只有 f(i−1,j)f(i-1,j)f(i−1,j) 了，可以做一下 [Luogu P1655] 小朋友的球。 [Luogu P2638] 安全系统 Portal. 不难看出放 01 可以分开计算，最后使用乘法原理组合在一起。而任何一个都可以使用插板法的结论进行计算。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; int n, a, b; u64 C[105][105]; int main(void) &#123; C[0][0] = 1; for (int i = 1; i &lt;= 100; ++i) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; ++j) C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; &#125; scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b); u64 ans = 0; for (int i = 0; i &lt;= a; ++i) for (int j = 0; j &lt;= b; ++j) ans += C[n + i - 1][i] * C[n + j - 1][j]; printf(\"%llu\\n\", ans); return 0; &#125; [Luogu P8557] 炼金术 Portal. 一种金属有 2k−12^k-12k−1 种可能被熔炼出来，然后每一种金属的可能都要乘起来（乘法原理）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; inline int poww(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % MOD; a = 1ll * a * a % MOD; b >>= 1; &#125; return res; &#125; int main(void) &#123; int n, k; cin >> n >> k; cout &lt;&lt; poww(poww(2, k) - 1, n) &lt;&lt; '\\n'; return 0; &#125; [UVA11609] Teams Portal. 队长有 nnn 中可能，每一个人当队长剩下的人都有 2n−12^{n-1}2n−1 种可能。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; int poww(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % MOD; a = 1ll * a * a % MOD; b >>= 1; &#125; return res; &#125; int main(void) &#123; int T, kase = 0, n; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); printf(\"Case #%d: %d\\n\", ++kase, 1ll * n * poww(2, n - 1) % MOD); &#125; return 0; &#125; 组合工具 计数问题有一些常见的工具可以辅助计算。 组合公式 还记得有关组合数的公式吗？事实上，最重要的内容有名有姓，并且非常有用： 吸收恒等式：(rk)=rk(r−1k−1)\\dbinom{r}{k}=\\dfrac{r}{k}\\dbinom{r-1}{k-1}(kr​)=kr​(k−1r−1​)，当二项式外有一个无用的系数时，我们可以将它“吸收”进二项式系数。 下指标求和（行求和）：∑i=0n(ni)=2n\\displaystyle \\sum_{i=0}^{n}\\binom{n}{i}=2^ni=0∑n​(in​)=2n，相当于是二项式定理中 a=b=1a=b=1a=b=1，它还有变式： ∑i=0n(−1)i(ni)=0\\displaystyle \\sum_{i=0}^{n}(-1)^i\\binom{n}{i}=0i=0∑n​(−1)i(in​)=0，这是二项式定理中 a=1,b=−1a=1,b=-1a=1,b=−1； ∑i=0ni×(ni)=n2n−1\\displaystyle \\sum_{i=0}^{n}i\\times \\binom{n}{i}=n2^{n-1}i=0∑n​i×(in​)=n2n−1，因为 m×(nm)=n×(n−1m−1)m\\times \\dbinom{n}{m}=n\\times \\dbinom{n-1}{m-1}m×(mn​)=n×(m−1n−1​)。 上指标求和（列求和）：∑i=0n(im)=(n+1m+1)\\displaystyle \\sum_{i=0}^{n}\\binom{i}{m}=\\binom{n+1}{m+1}i=0∑n​(mi​)=(m+1n+1​)，可以看作是枚举第 m+1m+1m+1 个数的位置 i+1i+1i+1。 对角线求和：∑i=0n(m+ii)=(m+n+1n)\\displaystyle\\sum_{i=0}^{n}\\binom{m+i}{i}=\\binom{m+n+1}{n}i=0∑n​(im+i​)=(nm+n+1​)，反复利用 Cnm=Cn−1m+Cn−1m−1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnm​=Cn−1m​+Cn−1m−1​ 即可证明。 范德蒙德卷积：∑i=0k(ni)(mk−i)=(n+mk)\\displaystyle \\sum_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}i=0∑k​(in​)(k−im​)=(kn+m​)。从组合意义上很容易证明（枚举 nnn 和 mmm 中选的个数），常用于合并组合数，考虑它的推论： ∑i=1n(ni)(ni−1)=(2nn−1)\\displaystyle \\sum_{i=1}^n\\binom{n}{i}\\binom{n}{i-1}=\\binom{2n}{n-1}i=1∑n​(in​)(i−1n​)=(n−12n​)，证明很简单，因为 (ni−1)=(nn−i+1),(2nn−1)=(2nn+1)\\dbinom{n}{i-1}=\\dbinom{n}{n-i+1},\\dbinom{2n}{n-1}=\\dbinom{2n}{n+1}(i−1n​)=(n−i+1n​),(n−12n​)=(n+12n​)； ∑i=0n(ni)2=(2nn)\\displaystyle\\sum_{i=0}^n\\binom{n}{i}^2=\\binom{2n}{n}i=0∑n​(in​)2=(n2n​)，证明基本同理； ∑i=0m(ni)(mi)=(n+mm)\\displaystyle\\sum_{i=0}^m\\binom{n}{i}\\binom{m}{i}=\\binom{n+m}{m}i=0∑m​(in​)(im​)=(mn+m​)，这个也是网格图路径计数方案。 N 项式定理 二项式定理也能扩展为 nnn 项式定理： (x1+⋯+xt)n=∑ni≥0,n1+⋯+nt(nn1,⋯ ,nt)x1n1⋯xtnt(x_1+\\cdots+x_t)^n=\\sum_{n_i\\ge 0,n_1+\\cdots+n_t}\\binom{n}{n_1,\\cdots,n_t}x_{1}^{n_1}\\cdots x_{t}^{n_t} (x1​+⋯+xt​)n=ni​≥0,n1​+⋯+nt​∑​(n1​,⋯,nt​n​)x1n1​​⋯xtnt​​ 其中 (nn1,⋯ ,nt)=n!n1!⋯nt!\\binom{n}{n_1,\\cdots,n_t}=\\cfrac{n!}{n_1!\\cdots n_t!} (n1​,⋯,nt​n​)=n1​!⋯nt​!n!​ Lucas 定理 Lucas 定理是说，对于质数 ppp，有： (nm) mod p=(⌊n/p⌋⌊m/p⌋)⋅(n mod pm mod p) mod p\\binom{n}{m}\\bmod p = \\binom{\\left\\lfloor n/p \\right\\rfloor}{\\left\\lfloor m/p\\right\\rfloor}\\cdot\\binom{n\\bmod p}{m\\bmod p}\\bmod p (mn​)modp=(⌊m/p⌋⌊n/p⌋​)⋅(mmodpnmodp​)modp 模板，代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, p; int fac[100005]; void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a % b, y, x); y -= a / b * x; &#125; int inv(int t) &#123; int x, y; exgcd(t, p, x, y); return (x % p + p) % p; &#125; int C(int n, int m) &#123; if (m > n) return 0; if (m == 0 || m == n) return 1; return 1ll * fac[n] * inv(fac[m]) % p * inv(fac[n - m]) % p; &#125; int Lucas(int n, int m) &#123; if (m == 0 || m == n) return 1; return 1ll * Lucas(n / p, m / p) * C(n % p, m % p) % p; &#125; int main(void) &#123; fac[0] = 1; int T; cin >> T; while (T--) &#123; cin >> n >> m >> p; for (int i = 1; i &lt;= p; ++i) fac[i] = 1ll * fac[i - 1] * i % p; cout &lt;&lt; Lucas(n + m, m) &lt;&lt; '\\n'; &#125; return 0; &#125; 因此可以发现，Lucas 定理面对的模数不会很大，否则是无法计算的。 而且当模数小的时候，往往需要使用 Lucas 定理。因为 nnn 可能很大，用公式计算会使得阶乘在模意义下直接变成 000。 扩展 Lucas 定理 模板。 容斥原理 容斥原理是非常重要的计数原理，能够对问题的角度进行转化，弱化或者加强问题的限制，从而使问题更加简洁。 引入 容斥原理大家一定不陌生，我们现在要给出 nnn 个集合的情况。设全集为 UUU，拥有属性 PiP_iPi​ 的元素构成集合 SiS_iSi​，那么： ∣⋃i=1nSi∣=∑m=1n(−1)m−1∑ai&lt;ai+1∣⋂i=1mSai∣\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i&lt;a_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right| ​i=1⋃n​Si​​=m=1∑n​(−1)m−1ai​&lt;ai+1​∑​​i=1⋂m​Sai​​​ 集合的交集 可以使用全集 UUU 减去补集的并集得到。 ∣⋂i=1nSi∣=∣U∣−∣⋃i=1nSi‾∣\\left|\\bigcap_{i=1}^{n}S_i\\right|=|U|-\\left|\\bigcup_{i=1}^n\\overline{S_i}\\right| ​i=1⋂n​Si​​=∣U∣−​i=1⋃n​Si​​​ 子集枚举 子集枚举可以让容斥原理的计算变得非常简便，代码如下： for (int i = S; i; i = i - 1 &amp; S) 这样 iii 枚举的就是 SSS 的非空子集。 应用 容斥原理最经典的用处是“至少”与“恰好”之间的转化，实际上是一个子集反演的过程。比较抽象，请参考《组合计数进阶》。 经典计数 包括一些经典问题和计数数列。但是限于本文的定位，并不会讲的很深，更深的内容请参考《组合计数进阶》，并先阅读《多项式与生成函数基础》中的生成函数部分。 错排数 是指没有任何元素出现在其有序位置的排列，也就是说不存在 Pi=iP_i=iPi​=i。 我们使用递推计算这个问题，设 f(i)f(i)f(i) 为长度为 iii 的答案。那么可以前 i−1i-1i−1 个全部排错，只需要第 iii 个与前 i−1i-1i−1 个中的任意一个互换即可，方案数为 (i−1)fi−1(i-1)f_{i-1}(i−1)fi−1​；也可以前面仅有一个没有排错，只需要将这个与 iii 互换，方案数为 (i−1)fi−2(i-1)f_{i-2}(i−1)fi−2​（没错排的可以是任意一个）。 因此：fi=(i−1)(fi−1+fi−2)f_i=(i-1)(f_{i-1}+f_{i-2})fi​=(i−1)(fi−1​+fi−2​)。 斯特林数 分为第一类斯特林数和第二类斯特林数。由于后者更为常用，因此我们先来研究后者。 第二类斯特林数 第二类斯特林数使用 {nk}\\begin{Bmatrix}n\\\\ k\\end{Bmatrix}{nk​} 或者 S(n,k)S(n,k)S(n,k) 来表示，意义是将 1∼n1\\sim n1∼n 的整数划分为 kkk 个不交的集合的方案数。显然 {n0}=[n=0]\\begin{Bmatrix}n\\\\ 0\\end{Bmatrix}=[n=0]{n0​}=[n=0]。可以采用暴力递推法求解： {nk}={n−1k−1}+k{n−1k}\\begin{Bmatrix}n\\\\ k\\end{Bmatrix}=\\begin{Bmatrix}n-1\\\\ k-1\\end{Bmatrix}+k\\begin{Bmatrix}n-1\\\\ k\\end{Bmatrix} {nk​}={n−1k−1​}+k{n−1k​} 什么意思呢？将第 nnn 个元素放入一个新的集合有 {n−1k−1}\\begin{Bmatrix}n-1\\\\ k-1\\end{Bmatrix}{n−1k−1​} 种方案，将第 nnn 个元素插入原来任意一个集合有 k{n−1k}k\\begin{Bmatrix}n-1\\\\ k\\end{Bmatrix}k{n−1k​} 的方案，根据加法原理可得递推式。 可能需要记住一些第二类斯特林数（就比如说，一个出现 1,7,6,11,7,6,11,7,6,1 的问题就很大能与第二类斯特林数有关）： 1 1 1 1 3 1 1 7 6 1 1 15 25 10 1 1 31 90 65 15 1 1 63 301 350 140 21 1 1 127 966 1701 1050 266 28 1 1 255 3025 7770 6951 2646 462 36 1 1 511 9330 34105 42525 22827 5880 750 45 1 第二类斯特林数的通项公式： {nm}=∑i=0m(−1)m−iini!(m−i)!\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\sum\\limits_{i=0}^m\\frac{(-1)^{m-i}i^n}{i!(m-i)!} {nm​}=i=0∑m​i!(m−i)!(−1)m−iin​ 第一类斯特林数 称之为斯特林轮换数，记作 [nk],s(n,k)\\begin{bmatrix}n\\\\ k\\end{bmatrix},s(n,k)[nk​],s(n,k)，表示将 1∼n1\\sim n1∼n 的整数划分为 kkk 个互不区分的非空轮换方案数。 一个轮换是指一个首尾相接的环形排列，两个可以通过旋转而互相得到的轮换是等价的。 第一类斯特林数的递推式： [nk]=[n−1k−1]+(n−1)[n−1k]\\begin{bmatrix}n\\\\ k\\end{bmatrix}=\\begin{bmatrix}n-1\\\\ k-1\\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\\\ k\\end{bmatrix} [nk​]=[n−1k−1​]+(n−1)[n−1k​] 前者是将 nnn 放在一个单独的轮换中，后者是将其放入一个现有的轮换中。 这个玩意没有实用的通项公式。 卡特兰数 前几项长这样：1 1 2 5 14 42 132，需要记住。它有非常多的含义： nnn 个节点可构造的不同二叉树个数； nnn 个数不同的出栈序列个数； …… 常见公式： Hn=Hn−1(4n−2)n+1Hn=(2nn)−(2nn−1)Hn=∑i=0n−1Hi×Hn−i−1(n≥2)H_n=\\frac{H_{n-1}(4n-2)}{n+1}\\\\ H_n=\\binom{2n}{n}-\\binom{2n}{n-1}\\\\ H_n=\\sum_{i=0}^{n-1}H_i\\times H_{n-i-1}(n\\ge 2) Hn​=n+1Hn−1​(4n−2)​Hn​=(n2n​)−(n−12n​)Hn​=i=0∑n−1​Hi​×Hn−i−1​(n≥2) 多重集相关问题 我们知道一个多重集 SSS 可以不满足互异性。设 S={n1×a1⋯nk×ak}S=\\{n_1\\times a_1\\cdots n_k\\times a_k\\}S={n1​×a1​⋯nk​×ak​} 代表由 nin_ini​ 个 aia_iai​ 组成的多重集。 多重集的排列数 | 多重组合数 这两个是同一个概念，是要求大小为 nnn，第 iii 个数出现次数为 nin_ini​ 的多重集 SSS 的全排列个数，我们要除掉重复的个数，那么 SSS 的全排列个数等于（其实就是把相同的数除掉了）： (nn1,…,nk)=n!∏i=1kni!\\binom{n}{n_1,\\dots,n_k}=\\frac{n!}{\\prod_{i=1}^k n_i!} (n1​,…,nk​n​)=∏i=1k​ni​!n!​ 多重组合数的意义就是先选 n1n_1n1​ 个，再在剩下的选择 n2n_2n2​ 个，以此类推。 [UVA11076] Add Again.给出 nnn 个数字，求出他们排列后能形成的所有整数的和，形成的整数不重复。 数的个数显然就是多重组合数，然后有 nnn 个位置，总共的序列个数有多重组合数 sss 个。设所有数的和为 sumsumsum，那么平均每一位的值就是 sum÷nsum\\div nsum÷n，然后再乘上基数，全是 111 即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef unsigned long long u64; int main(void) &#123; int n; u64 f[15] = &#123;1&#125;; const u64 one[] = &#123;0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111, 11111111111, 111111111111&#125;; for (int i = 1; i &lt;= 12; ++i) f[i] = f[i - 1] * i; while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; static int cnt[10]; u64 sum = 0; memset(cnt, 0, sizeof(cnt)); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), ++cnt[x], sum += x; u64 s = f[n]; for (int i = 0; i &lt; 10; ++i) s /= f[cnt[i]]; printf(\"%llu\\n\", sum * s * one[n] / n); &#125; return 0; &#125; Problemset 这里的题目都是比较基础的数数题。 简单问题 可以用来巩固基础。 [USACO20FEB] Help Yourself G Portal.在一个数轴上有 NNN 条线段，第 iii 条线段覆盖了 [li,ri][l_i,r_i][li​,ri​]。定义若干条线段的并为一个包含了所有被至少一个线段覆盖的点的集合。定义若干条线段的复杂度为这些线段的并形成的连通块的数目。现在 Bessie 想要求出给定 NNN 条线段的所有子集（共有 2N2^N2N 个）的复杂度之和对 109+710^9+7109+7 取模的结果。 好题！似乎没有什么特殊做法，那么考虑计数 DP。设 fif_ifi​ 代表考虑前 iii 条线段的复杂度之和。如果不选第 iii 条线段，那么复杂度和是 fi−1f_{i-1}fi−1​；如果选第 iii 条线段，那么是多少？不好做！加入这一条线段之后可能新增联通块，也可能合并联通块，鬼知道贡献是什么！ 换句话说，状态的转移顺序有问题，导致贡献不好计算。我们可以按照线段的左端点从小到大排序之后再进行计算。这样就不可能合并联通块，所以原来的贡献 fi−1f_{i-1}fi−1​ 都在；新增联通块是可以的，假设前面与当前线段不交的线段有 xxx 条（可以使用前缀和统计），那么新增的复杂度就是 2x2^x2x（就是只选这 xxx 条线段的子集时，复杂度会增加 111）。 查看代码 #include &lt;bits/stdc++.h> #define L first #define R second using namespace std; const int MOD = 1000000007; int n, f[100005], s[200005]; pair&lt;int, int> a[100005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;a[i].L, &amp;a[i].R), s[a[i].R]++; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n * 2; ++i) s[i] += s[i - 1]; for (int i = 1; i &lt;= n; ++i) f[i] = (f[i - 1] * 2 % MOD + poww(2, s[a[i].L - 1])) % MOD; printf(\"%d\\n\", f[n]); return 0; &#125; [CF340E] Iahub and Permutations 本质上是一个错排问题，但是其中的 −1-1−1 可以有随便填的，加一个转移来处理它！ 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, a[2005], tot1, tot2; // 不能放自身，可以随便放 bool p[2005]; int f[2005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] == i) return puts(\"0\"), 0; if (a[i] != -1) p[a[i]] = true; else ++tot1; &#125; for (int i = 1; i &lt;= n; ++i) if (a[i] == -1 &amp;&amp; p[i]) tot1--, tot2++; for (int i = f[0] = 1; i &lt;= tot2; ++i) f[0] = 1ll * f[0] * i % P; f[1] = 1ll * tot2 * f[0] % P; for (int i = 2; i &lt;= tot1; ++i) &#123; f[i] = 1ll * (f[i - 1] + f[i - 2]) * (i - 1) % P; f[i] = (f[i] + 1ll * tot2 * f[i - 1]) % P; &#125; return !printf(\"%d\\n\", f[tot1]); &#125; [AHOI2022] 排列 Portal. 建出置换的有向图，每个环独立，那么 vvv 就是每个环大小的 LCM。如果 i,ji,ji,j 在一个环里，那么 f(i,j)=0f(i,j)=0f(i,j)=0。 这个 swap 操作相当于合并了两个环，设第 iii 个环的大小为 aia_iai​，那么由于 ∑ai=n\\sum a_i=n∑ai​=n，因此值不同的 aia_iai​ 在 n\\sqrt{n}n​ 级别。我们只需要暴力枚举两个环的大小，这样的时间复杂度是 O(n)O(n)O(n) 的。 也就是说，我们需要维护一个集合的 LCM，支持删除两个数并加入一个新的数求出 LCM。将数质因数分解，对于每个质数只保留三个幂次最大的（删除两个数时最坏只会删掉两个最大的），加入的时候暴力统计一下即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int N = 500000; void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; int n; int a[500005]; int fa[500005], siz[500005]; int find(int x) &#123; if (fa[x] == x) return x; return find(fa[x]); &#125; void uni(int x, int y) &#123; x = find(x), y = find(y); if (x == y) return; if (siz[x] > siz[y]) swap(x, y); fa[x] = y; siz[y] += siz[x]; &#125; int cnt[500005]; int prime[500005], tot, p[500005], inv[500005]; // p: 最小质因子 vector&lt;pair&lt;int, int>> fac[500005]; // fac[i] 保存 i 质因数分解后的结果，first 为底数，second 为幂 vector&lt;int> G[500005]; // G[i] 保存质数 i 为底数的最大幂 vector&lt;pair&lt;int, int>> E[500005]; // E 为临时附加 int A[1005], t, now; int C[500005]; int get(int v) &#123; // 获取质数 v 的最大幂 int mx = 1; for (int x : G[v]) ++C[x]; for (auto [x, k] : E[v]) C[x] += k; for (int x : G[v]) if (C[x]) mx = max(mx, x), C[x] = 0; for (auto [x, k] : E[v]) if (C[x]) mx = max(mx, x), C[x] = 0; return mx; &#125; void update(int v, int flag) &#123; for (auto [x, y] : fac[v]) &#123; now = 1ll * now * inv[get(x)] % P; E[x].emplace_back(y, flag); now = 1ll * now * get(x) % P; &#125; &#125; void remove(int v) &#123; for (auto [x, y] : fac[v]) E[x].clear(); &#125; int main(void) &#123; p[1] = inv[1] = 1; for (int i = 2; i &lt;= N; ++i) inv[i] = 1ll * (P - P / i) * inv[P % i] % P; for (int i = 2; i &lt;= N; ++i) &#123; if (!p[i]) prime[++tot] = i, p[i] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; p[i * prime[j]] = prime[j]; if (i % prime[j] == 0) break; &#125; &#125; for (int i = 1; i &lt;= N; ++i) &#123; int x = i; while (x != 1) &#123; int tmp = p[x], v = 1; while (x % tmp == 0) x /= tmp, v *= tmp; fac[i].emplace_back(tmp, v); &#125; &#125; int T; scanf(\"%d\", &amp;T); while (T--) &#123; memset(cnt, 0, sizeof cnt); t = 0; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), fa[i] = i, siz[i] = 1; for (int i = 1; i &lt;= n; ++i) uni(i, a[i]), G[i].clear(); for (int i = 1; i &lt;= n; ++i) if (find(i) == i) &#123; ++cnt[siz[i]]; for (auto [x, y] : fac[siz[i]]) G[x].emplace_back(y); &#125; for (int i = 1; i &lt;= n; ++i) if (cnt[i]) A[++t] = i; now = 1; for (int i = 1; i &lt;= n; ++i) if (G[i].size()) &#123; sort(G[i].begin(), G[i].end(), greater&lt;int>()); while (G[i].size() > 3) G[i].pop_back(); now = 1ll * now * G[i][0] % P; &#125; int ans = 0; for (int i = 1; i &lt;= t; ++i) &#123; int u = A[i]; if (cnt[u] > 1) &#123; int last = now; update(u, -1); update(u, -1); update(u + u, 1); add(ans, 1ll * cnt[u] * (cnt[u] - 1) % P * u % P * u % P * now % P); remove(u); remove(u + u); now = last; &#125; for (int j = i + 1; j &lt;= t; ++j) &#123; int last = now, v = A[j]; update(u, -1); update(v, -1); update(u + v, 1); add(ans, 2ll * cnt[u] * cnt[v] % P * u % P * v % P * now % P); remove(u); remove(v); remove(u + v); now = last; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [CF348D] Turtles Portal. 只有一只乌龟的话是经典问题，现在考虑两条路径什么时候有交。 只能是一只乌龟从 (1,2)(1,2)(1,2) 走到 (n−1,m)(n-1,m)(n−1,m)，另一只乌龟从 (2,1)(2,1)(2,1) 走到 (n,m−1)(n,m-1)(n,m−1)。如果一只乌龟从 (1,2)(1,2)(1,2) 走到 (n,m−1)(n,m-1)(n,m−1)，另一只乌龟从 (2,1)(2,1)(2,1) 走到 (n−1,m)(n-1,m)(n−1,m)，那么这样路径是会有交的。 但是发现前者自身也有可能有路径交！比如说中途在一个点路径相交。我们把这个点之后的路径互换，发现都可以对应到第二种的走法。这样只需要用前者减去后者即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; int n, m; char s[3005][3005]; int f[3005][3005]; int dp(int x, int y, int n, int m) &#123; memset(f, 0, sizeof f); for (int i = x; i &lt;= n; ++i) for (int j = y; j &lt;= m; ++j) if (s[i][j] != '#') &#123; if (i == x &amp;&amp; j == y) f[i][j] = 1; else f[i][j] = (f[i - 1][j] + f[i][j - 1]) % P; &#125; return f[n][m]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); f[1][1] = 1; for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", s[i] + 1); printf(\"%d\\n\", ((1ll * dp(1, 2, n - 1, m) * dp(2, 1, n, m - 1) - 1ll * dp(1, 2, n, m - 1) * dp(2, 1, n - 1, m)) % P + P) % P); return 0; &#125; 实际上本题是 LGV 引理的一个应用，相关内容在《组合计数进阶》有介绍。由于本题只有两只乌龟，因此可以比较方便的用容斥原理理解。 计数问题 借助动态规划算法的多阶段决策，可以高效的解决计数问题。 [HAOI2008] 硬币购物 Portal. 共有 444 种硬币。面值分别为 c1,c2,c3,c4c_1,c_2,c_3,c_4c1​,c2​,c3​,c4​。某人去商店买东西，去了 nnn 次，对于每次购买，他带了 did_idi​ 枚 iii 种硬币，想购买 sss 的价值的东西。请问每次有多少种付款方法。 如果每一种硬币都有无限多，那么这就成了个完全背包，直接做就可以，记为 f(s)f(s)f(s)。 接下来考虑性质。利用补集思想，我们可以用 f(s)f(s)f(s) 减去至少有一个超过。也就是 f(s−(d1+1)×c1)f(s-(d_1+1)\\times c_1)f(s−(d1​+1)×c1​)，以此类推。使用容斥原理计算即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int M = 100000; int c1, c2, c3, c4, q; i64 f[M + 5]; inline i64 g(i64 x) &#123; return x &lt; 0 ? 0 : f[x]; &#125; int main(void) &#123; cin >> c1 >> c2 >> c3 >> c4 >> q; f[0] = 1; for (int i = c1; i &lt;= M; ++i) f[i] += f[i - c1]; for (int i = c2; i &lt;= M; ++i) f[i] += f[i - c2]; for (int i = c3; i &lt;= M; ++i) f[i] += f[i - c3]; for (int i = c4; i &lt;= M; ++i) f[i] += f[i - c4]; while (q--) &#123; int d1, d2, d3, d4, s; cin >> d1 >> d2 >> d3 >> d4 >> s; d1 = (d1 + 1) * c1, d2 = (d2 + 1) * c2, d3 = (d3 + 1) * c3, d4 = (d4 + 1) * c4; cout &lt;&lt; g(s) - g(s - d1) - g(s - d2) - g(s - d3) - g(s - d4) + g(s - d1 - d2) + g(s - d1 - d3) + g(s - d1 - d4) + g(s - d2 - d3) + g(s - d2 - d4) + g(s - d3 - d4) - g(s - d1 - d2 - d3) - g(s - d1 - d3 - d4) - g(s - d1 - d2 - d4) - g(s - d2 - d3 - d4) + g(s - d1 - d2 - d3 - d4) &lt;&lt; '\\n'; &#125; return 0; &#125; [ZJOI2010] 排列计数 Portal.称一个 1∼n1 \\sim n1∼n 的排列 p1,p2,…,pnp_1,p_2, \\dots ,p_np1​,p2​,…,pn​ 是 Magic 的，当且仅当：∀i∈[2,n],pi&gt;p⌊i/2⌋\\forall i \\in [2,n],p_i &gt; p_{\\lfloor i/2 \\rfloor}∀i∈[2,n],pi​&gt;p⌊i/2⌋​计算 1∼n1 \\sim n1∼n 的排列中有多少是 Magic 的，答案可能很大，只能输出模 mmm 以后的值。1≤n≤1061\\le n \\le 10^61≤n≤106, 1≤m≤1091\\le m \\le 10^91≤m≤109，mmm 是一个质数。 发现这个序列描述的就是一个小根堆。设 f(i)f(i)f(i) 为 iii 个数组成的满足排列的个数。我们先计算出这个堆的根节点的左子节点个数和右子节点个数，那么当前方案数就是左子树方案数和右子树方案数。左子树可以在 i−1i-1i−1 中选择 lll 个，那么右子树能选的数也就确定，方案数就是 f(l)×(i−1l)×f(r)f(l)\\times \\binom{i-1}{l} \\times f(r)f(l)×(li−1​)×f(r) 了。注意使用 Lucas 定理计算（nnn 可能大于模数，逆元计算不成立）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, p; int f[1000005], lg[1000005], fac[1000005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % p) if (b &amp; 1) res = 1ll * res * a % p; return res; &#125; int C(int n, int m) &#123; return 1ll * fac[n] * poww(fac[m], p - 2) % p * poww(fac[n - m], p - 2) % p; &#125; int Lucas(int n, int m) &#123; if (m == n || m == 0) return 1; return 1ll * Lucas(n / p, m / p) * C(n % p, m % p) % p; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); f[0] = f[1] = 1; for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % p; int l = 0, r = 0; for (int i = 2; i &lt;= n; ++i) &#123; int dep = lg[i] + 1; if (i &lt; ((1 &lt;&lt; dep) - (1 &lt;&lt; (dep - 2)))) ++l; else ++r; f[i] = 1ll * f[l] * Lucas(i - 1, l) % p * f[r] % p; &#125; printf(\"%d\\n\", f[n]); return 0; &#125; 『JROI-4』沈阳大街 2 Portal. 相当于是可以随便排，那么将 A,BA,BA,B 合并为 CCC，将其从大到小排序后可得贡献是最后一个数。设 f(i,j)f(i,j)f(i,j) 代表考虑到 CiC_iCi​ 选了 jjj 对，然后转移。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int n, f[10005][5005], cnt[2][10005]; pair&lt;int, bool> a[10005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i].first); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i + n].first), a[i + n].second = 1; sort(a + 1, a + n * 2 + 1, greater&lt;pair&lt;int, bool>>()); f[0][0] = 1; for (int i = 1; i &lt;= n * 2; ++i) &#123; cnt[0][i] = cnt[0][i - 1], cnt[1][i] = cnt[1][i - 1]; f[i][0] = 1; ++cnt[a[i].second][i]; int t = cnt[!a[i].second][i]; for (int j = 1; j &lt;= (i >> 1); ++j) &#123; if (t - j + 1 >= 0) f[i][j] = 1ll * f[i - 1][j - 1] * a[i].first % MOD * (t - j + 1) % MOD; f[i][j] = (f[i][j] + f[i - 1][j]) % MOD; &#125; &#125; int res = 1; for (int i = 1; i &lt;= n; ++i) res = 1ll * res * i % MOD; printf(\"%d\\n\", 1ll * poww(res, MOD - 2) * f[n * 2][n] % MOD); return 0; &#125; 经典模型 这些问题与经典模型关系很大！ [SDOI2016] 排列计数 Portal. 除掉这 mmm 个数就是错排问题，而选择 mmm 个数共有 (nm)\\dbinom{n}{m}(mn​) 种方案。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; const int N = 1000000; int n, m; int fac[1000005], f[1000005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int C(int n, int m) &#123; return 1ll * fac[n] * poww(1ll * fac[m] * fac[n - m] % MOD, MOD - 2) % MOD; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); fac[0] = 1; f[2] = 1; f[0] = 1; for (int i = 1; i &lt;= N; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; for (int i = 3; i &lt;= N; ++i) f[i] = 1ll * (i - 1) * (f[i - 1] + f[i - 2]) % MOD; while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", 1ll * C(n, m) * f[n - m] % MOD); &#125; return 0; &#125; [CF785D] Anton and School - 2 Portal. 直接暴力计数，然后使用范德蒙德卷积化简。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 1000000007; int n, a[200005], b[200005]; i64 fac[200005] = &#123;1&#125;; char s[200005]; i64 poww(i64 a, int b) &#123; i64 res = 1; a %= MOD; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) a[i] = a[i - 1] + (s[i] == '('); for (int i = n; i >= 1; --i) b[i] = b[i + 1] + (s[i] == ')'); for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % MOD; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) if (s[i] == '(') &#123; int x = a[i], y = b[i]; ans = (ans + fac[x + y - 1] * poww(fac[y - 1] * fac[x], MOD - 2)) % MOD; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [Cnoi2020] 四角链 Portal. 设 f(n,k)f(n,k)f(n,k) 为答案，那么 f(n,k)=f(n−1,k)+(n−k+1)×f(n−1,k−1)f(n,k)=f(n-1,k)+(n-k+1)\\times f(n-1,k-1)f(n,k)=f(n−1,k)+(n−k+1)×f(n−1,k−1)。试几个数发现 f(n,k)=S(n,n−k)f(n,k)=S(n,n-k)f(n,k)=S(n,n−k)，因此使用第二类斯特林数求解即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; int n, m, k; int fac[1000005]; int f[5005][5005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); m = n - k; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; int ans = 0; for (int i = 0; i &lt;= m; ++i) &#123; int tmp = 1ll * poww(i, n) * poww(fac[i], MOD - 2) % MOD * poww(fac[m - i], MOD - 2) % MOD; ans = (ans + tmp * ((m - i) % 2 == 0 ? 1 : -1)) % MOD; &#125; printf(\"%d\\n\", (ans + MOD) % MOD); return 0; &#125; [NOI2021] 量子通信 Portal. k≤15k\\le 15k≤15 是关键突破点，我们把每 161616 位压成一位，必然有一个数是不同的（鸽巢原理）。将相同的压成一位的单词存在一个 vector 里，暴力判断即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long ull; bool s[400005][256]; inline ull myRand(ull &amp;k1, ull &amp;k2) &#123; ull k3 = k1, k4 = k2; k1 = k4; k3 ^= (k3 &lt;&lt; 23); k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26); return k2 + k4; &#125; void gen(int n, ull a1, ull a2) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; 256; j++) s[i][j] = (myRand(a1, a2) &amp; (1ull &lt;&lt; 32)) ? 1 : 0; &#125; int n, m, val[400005][16], aa[16]; vector&lt;int> buc[16][65536]; ull a1, a2; bool a[256]; int main(void) &#123; cin >> n >> m >> a1 >> a2; gen(n, a1, a2); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; 16; ++j) &#123; for (int k = 0; k &lt; 16; ++k) val[i][j] += (s[i][j * 16 + k] &lt;&lt; k); buc[j][val[i][j]].emplace_back(i); &#125; &#125; bool last = 0; int k; while (m--) &#123; for (int i = 0; i &lt; 64; ++i) &#123; char c = getchar(); int v; if (isdigit(c)) v = c - '0'; else if (c >= 'A' &amp;&amp; c &lt;= 'F') v = 10 + c - 'A'; else &#123; --i; continue; &#125; for (int j = 0; j &lt; 4; ++j) a[i * 4 + j] = (((v >> (3 - j)) &amp; 1) ^ last); &#125; bool flag = 0; scanf(\"%d\", &amp;k); memset(aa, 0, sizeof(aa)); // aa 存储当前字符串被压缩后的结果 for (int i = 0; i &lt; 16; ++i) for (int j = 0; j &lt; 16; ++j) aa[i] += (a[i * 16 + j] &lt;&lt; j); for (int i = 0; i &lt; 16 &amp;&amp; !flag; ++i) &#123; for (auto x : buc[i][aa[i]]) &#123; int it = x, cnt = 0; for (int j = 0; j &lt; 16 &amp;&amp; cnt &lt;= k; ++j) cnt += __builtin_popcount(val[it][j] ^ aa[j]); if (cnt &lt;= k) &#123; flag = true; break; &#125; &#125; &#125; printf(\"%d\\n\", (last = flag)); &#125; return 0; &#125; [JSOI2015] 染色问题 Portal. 设 f(i)f(i)f(i) 代表最多使用 iii 种颜色完成目标的方案数。考虑 SiS_iSi​ 代表有第 iii 种颜色的方案集合。“每个颜色都至少出现一次”为 ∣⋂i=1nSi∣\\displaystyle\\left|\\bigcap_{i=1}^{n}S_i\\right|​i=1⋂n​Si​​，可以写为： ∣U∣−∣⋃i=1nSi‾∣=∣U∣−∑m=1n(−1)m−1∑ai&lt;ai+1∣⋂i=1mSai‾∣\\begin{aligned} &amp;\\left|U\\right|-\\left|\\bigcup_{i=1}^{n}\\overline{S_i}\\right|\\\\ =&amp;\\left|U\\right| - \\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i&lt;a_{i+1} }\\left|\\bigcap_{i=1}^m\\overline{S_{a_i}}\\right| \\end{aligned} =​∣U∣−​i=1⋃n​Si​​​∣U∣−m=1∑n​(−1)m−1ai​&lt;ai+1​∑​​i=1⋂m​Sai​​​​​ 后面这个 ∣⋂i=1mSai‾∣\\displaystyle\\left|\\bigcap_{i=1}^m\\overline{S_{a_i}}\\right|​i=1⋂m​Sai​​​​ 是说至少不选 mmm 种颜色，有 (cm)\\dbinom{c}{m}(mc​) 种选择方式，单个选择方式有 f[c−m]f[c-m]f[c−m] 种合法方案数。可以使用容斥原理计算，那么最终： ans=f(c)−∑i=1c(−1)i−1(ci)×f[c−i]=∑i=0c(−1)i(ci)×f[c−i]\\begin{aligned} ans&amp;=f(c)-\\displaystyle\\sum\\limits_{i=1}^c(-1)^{i-1}\\binom{c}{i}\\times f[c-i]\\\\ &amp;=\\displaystyle\\sum\\limits_{i=0}^c(-1)^{i}\\binom{c}{i}\\times f[c-i] \\end{aligned} ans​=f(c)−i=1∑c​(−1)i−1(ic​)×f[c−i]=i=0∑c​(−1)i(ic​)×f[c−i]​ fff 也可以使用类似的方式计算出来。SiS_iSi​ 代表第 iii 列有颜色的方案集合，然后推导出来的 ∣⋂i=1kSai‾∣\\displaystyle\\left|\\bigcap_{i=1}^k\\overline{S_{a_i}}\\right|​i=1⋂k​Sai​​​​ 就是 a1⋯aka_1\\cdots a_ka1​⋯ak​ 这 kkk 列没有颜色，那么： fi=∑k=0m(−1)k(mk)((i+1)m−k−1)nf_i=\\sum_{k=0}^{m}(-1)^{k}\\binom{m}{k}((i+1)^{m-k}-1)^n fi​=k=0∑m​(−1)k(km​)((i+1)m−k−1)n 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 1000000007; i64 poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; void add(i64 &amp;a, int t) &#123; a = ((a + t) % MOD + MOD) % MOD; &#125; int n, m, c; int C[405][405]; i64 f[405]; int main(void) &#123; for (int i = 0; i &lt;= 400; ++i) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD; &#125; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c); for (int i = 1; i &lt;= c; ++i) for (int k = 0; k &lt;= m; ++k) add(f[i], (k &amp; 1 ? -1 : 1) * C[m][k] * poww(poww(i + 1, m - k) - 1, n) % MOD); i64 ans = 0; for (int i = 0; i &lt;= c; ++i) add(ans, (i &amp; 1 ? -1 : 1) * C[c][i] * f[c - i] % MOD); printf(\"%lld\\n\", ans); return 0; &#125; 数学推导 推式子（柿子）是一件有趣的事情！ [CF1545B] AquaMoon and Chess Portal. 只有 000 和 111111 是有用的，答案是 (a+ba)\\dbinom{a+b}{a}(aa+b​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; int n; char a[100005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int C(int n, int m) &#123; int res = 1; for (int i = 1; i &lt;= m; ++i) res = 1ll * res * (n - i + 1) % MOD * poww(i, MOD - 2) % MOD; return res; &#125; void solve(void) &#123; cin >> n >> a; int x = 0, y = 0; for (int i = 0; i &lt; n; ++i) if (i &lt; n - 1 &amp;&amp; a[i] == '1' &amp;&amp; a[i + 1] == '1') ++x, ++i; else if (a[i] == '0') ++y; cout &lt;&lt; C(x + y, y) &lt;&lt; '\\n'; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; [SCOI2010] 生成字符串 Portal. 把 nnn 个 111 和 mmm 个 000 组成字符串，在任意的前 kkk 个字符中，111 的个数不能少于 000 的个数。满足要求的字符串共有多少个？ 考虑其几何意义：选 1 代表向右上走，选 0 代表向右下走，要走到 (n+m,n−m)(n+m,n-m)(n+m,n−m)，而且需要满足任意时刻的纵坐标是非负的。 怎么办呢？利用补集思想，总共有 (n+mm)\\dbinom{n+m}{m}(mn+m​) 种走法（网格图路径计数），能够走到 y=−1y=-1y=−1，相当于从 (0,−2)(0,-2)(0,−2) 开始走，n′=n+1,m′=m−1n&#x27;=n+1,m&#x27;=m-1n′=n+1,m′=m−1，走到 (n+m,n−m)(n+m,n-m)(n+m,n−m)，方案数为 (n+1+m−1m−1)\\dbinom{n+1+m-1}{m-1}(m−1n+1+m−1​)，因此答案为 (n+mm)−(n+mm−1)\\dbinom{n+m}{m}-\\dbinom{n+m}{m-1}(mn+m​)−(m−1n+m​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 20100403; int fac[2000005]; int poww(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % MOD; a = 1ll * a * a % MOD; b >>= 1; &#125; return res; &#125; int inv(int a) &#123; return poww(a, MOD - 2); &#125; int C(int n, int m) &#123; return 1ll * fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD; &#125; int main(void) &#123; fac[0] = 1; for (int i = 1; i &lt;= 2000000; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", (C(n + m, m) - C(n + m, m - 1) + MOD) % MOD); return 0; &#125; [GXOI/GZOI2019] 逼死强迫症 Portal. 设 f(i)f(i)f(i) 表示 2×i2\\times i2×i 的答案，那么 f(i)=f(i−1)+f(i−2)+2∑j=0i−3F(j)f(i)=f(i-1)+f(i-2)+2\\sum_{j=0}^{i-3}F(j)f(i)=f(i−1)+f(i−2)+2∑j=0i−3​F(j)。使用矩阵快速幂计算即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; struct Matrix &#123; int a[5][5]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 5; ++i) for (int k = 0; k &lt; 5; ++k) &#123; int r = a.a[i][k]; for (int j = 0; j &lt; 5; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b.a[k][j]) % MOD; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; for (int i = 0; i &lt; 5; ++i) res.a[i][i] = 1; for (; b; b >>= 1, a = a * a) if (b &amp; 1) res = res * a; return res; &#125; int main(void) &#123; int T, n; scanf(\"%d\", &amp;T); Matrix f, a; a.a[2][0] = a.a[3][0] = a.a[4][0] = 1; f.a[0][0] = f.a[0][1] = f.a[1][0] = f.a[2][2] = f.a[2][3] = f.a[3][3] = f.a[3][4] = f.a[4][3] = 1; f.a[0][2] = 2; Matrix t = f * a; while (T--) &#123; scanf(\"%d\", &amp;n); if (n &lt;= 2) &#123; puts(\"0\"); continue; &#125; printf(\"%d\\n\", (poww(f, n - 2) * a).a[0][0]); &#125; return 0; &#125; 「KDOI-02」一个仇的复 Portal.你有 1×x1\\times x1×x（xxx 为任意正整数）的矩形各无穷多个和一个 2×n2\\times n2×n 的网格，请求出恰好选择其中 kkk 个矩形（可以选择相同的矩形）不重不漏地铺满整个网格的方案数。矩形可以旋转。答案对 998244353998244353998244353 取模，n≤2×107,k≤5000n\\le 2\\times 10^7,k\\le 5000n≤2×107,k≤5000。 先解决一个简单问题，只允许横着放？插板，枚举第 111 行用 iii 个，那么总方案数为 ∑i=1a−1(b−1i−1)(b−1a−i−1)=∑i=0a−2(b−1i)(b−1a−2−i)\\displaystyle \\sum_{i=1}^{a-1}\\binom{b-1}{i-1}\\binom{b-1}{a-i-1}=\\sum_{i=0}^{a-2}\\binom{b-1}{i}\\binom{b-1}{a-2-i}i=1∑a−1​(i−1b−1​)(a−i−1b−1​)=i=0∑a−2​(ib−1​)(a−2−ib−1​)，用范德蒙德卷积合并可得答案是 (2b−2a−2)\\dbinom{2b-2}{a-2}(a−22b−2​)。 由于宽度为 222，竖着的长方形仅能有 1×21\\times 21×2。考虑先用 jjj 个 1×21\\times 21×2 的竖着的长方形，然后分割成了 2×al2\\times a_l2×al​ 的小长方形，独立统计即可。 设要分成 iii 段，使用 jjj 个竖着的，那么分段方式插板计算有 (j+1i)\\dbinom{j+1}{i}(ij+1​) 种（只有两头允许放空，增加 111 个板），然后要将剩余的 n−jn-jn−j 个位置分给 iii 段，插板有 (n−j−1i−1)\\dbinom{n-j-1}{i-1}(i−1n−j−1​) 种方案。 然后就是把 k−jk-jk−j 个横着的放到每段长度为 ala_lal​ 的每段中，方案数： ∑∑l=1ibl = k−j∏l=1i(2al−2bl−2)\\sum_{\\sum\\limits_{l=1}^i b_l\\ =\\ k-j}\\prod_{l=1}^{i}\\binom{2a_l-2}{b_l-2} l=1∑i​bl​ = k−j∑​l=1∏i​(bl​−22al​−2​) 这是个什么？想一想范德蒙德卷积的组合意义，就会发现跟那个是一样的：枚举每个子集选的个数，选的总数是 k−j−2ik-j-2ik−j−2i。于是我们将它合起来（就是原本二项式系数上面的和下面的和形成新的二项式系数），就成了：(∑2al−2∑bl−2)=(2(n−j)−2ik−j−2i)\\dbinom{\\sum 2a_l-2}{\\sum b_l-2}=\\dbinom{2(n-j)-2i}{k-j-2i}(∑bl​−2∑2al​−2​)=(k−j−2i2(n−j)−2i​)。 注意一下需要特判 k=nk=nk=n 的时候，可以放 kkk 个竖着的。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; inline int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int n, k; int fac[40000005]; int C(int n, int m) &#123; return 1ll * fac[n] * poww(1ll * fac[m] * fac[n - m] % MOD, MOD - 2) % MOD; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); fac[0] = 1; for (int i = 1; i &lt;= n * 2; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; int ans = 0; for (int i = 1; i &lt;= k; ++i) &#123; int R = min(&#123;k - 2 * i, n - i, 2 * n - k&#125;); for (int j = i - 1; j &lt;= R; ++j) &#123; int a = C(2 * (n - j) - 2 * i, k - j - 2 * i); int b = C(j + 1, i), c = C(n - j - 1, i - 1); ans = (ans + 1ll * a * b % MOD * c % MOD) % MOD; &#125; &#125; printf(\"%lld\\n\", ans + (k == n)); return 0; &#125; [FJOI2017] 矩阵填数 Portal.给定一个 h×wh \\times wh×w 的矩阵，在这个矩阵中你需要在每个格子中填入 1∼m1 \\sim m1∼m 中的某个数。给这个矩阵填数的时候有一些限制，给定 nnn 个该矩阵的子矩阵，以及该子矩阵的最大值 vvv，要求你所填的方案满足该子矩阵的最大值为 vvv。现在，你的任务是求出有多少种填数的方案满足 nnn 个限制。输出答案对 109+710^9+7109+7 取模后的结果。对于 100%100\\%100% 的数据，T≤5T \\le 5T≤5，1≤h,w,m≤1041 \\le h, w, m \\le 10 ^ 41≤h,w,m≤104，1≤n≤101 \\le n \\le 101≤n≤10，1≤v≤m1 \\le v \\le m1≤v≤m。 没有矩形限制的地方是可以任意填的。 将限制条件按照 vvv 从小到大排序，然后大小相同的统一处理（先考虑限制更严的，限制更松的自然满足）。对于一个 vvv，使用一个套路：最大值等于 vvv 可以转化为最大值不超过 vvv 和最大值不超过 v−1v-1v−1。这样就可以很方便的使用容斥原理计算了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 1000000007; const int N = 10; i64 poww(i64 a, int b) &#123; int res = 1; for (; b; b >>= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res; &#125; int h, w, m, n; int bitcount[1030]; int s[1030], u[1030]; // 交集，并集 struct rec &#123; int x1, y1, x2, y2, v; rec(int x1 = 0, int y1 = 0, int x2 = 0, int y2 = 0) : x1(x1), y1(y1), x2(x2), y2(y2) &#123;&#125; void rd(void) &#123; scanf(\"%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;v); &#125; bool empty(void) &#123; return x1 > x2 || y1 > y2; &#125; int square(void) &#123; return (x2 - x1 + 1) * (y2 - y1 + 1); &#125; void operator&amp;= (const rec &amp;a) &#123; x1 = max(x1, a.x1), y1 = max(y1, a.y1); x2 = min(x2, a.x2), y2 = min(y2, a.y2); &#125; bool operator&lt; (const rec &amp;a) const &#123; return v &lt; a.v; &#125; &#125; a[15]; int main(void) &#123; for (int s = 0; s &lt; 1 &lt;&lt; N; ++s) bitcount[s] = bitcount[s >> 1] + (s &amp; 1); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d%d\", &amp;h, &amp;w, &amp;m, &amp;n); int xtot = 0, ytot = 0; for (int i = 0; i &lt; n; ++i) a[i].rd(); sort(a, a + n); for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) &#123; rec tmp(1, 1, h, w); s[i] = -1; for (int p = i, j = 0; p; p >>= 1, ++j) if (p &amp; 1) &#123; tmp &amp;= a[j]; if (tmp.empty()) &#123; s[i] = 0; break; &#125; &#125; if (s[i] == -1) s[i] = tmp.square(); &#125; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) &#123; u[i] = 0; for (int j = i; j; j = j - 1 &amp; i) if (bitcount[j] % 2) u[i] += s[j]; else u[i] -= s[j]; &#125; int ns = 0, ls = 0; i64 res = 1; for (int i = 0; i &lt; n; ++i) &#123; ns |= (1 &lt;&lt; i); if (a[i].v == a[i + 1].v) continue; int tot = u[ns | ls] - u[ls], st = tot; i64 ret = poww(a[i].v, tot); // 最大值不超过 v for (int j = ns; j; j = j - 1 &amp; ns) &#123; tot = u[j | ls] - u[ls]; i64 del = poww(a[i].v - 1, tot) * poww(a[i].v, st - tot) % MOD; // 枚举的子集中的这些最大值不超过 v-1，剩下的随便 if (bitcount[j] % 2) ret = (ret - del + MOD) % MOD; else ret = (ret + del) % MOD; &#125; res = res * ret % MOD; ls |= ns; ns = 0; &#125; printf(\"%lld\\n\", res * poww(m, h * w - u[(1 &lt;&lt; n) - 1]) % MOD); &#125; return 0; &#125; 组合综合 这里的问题会与数论、DP 等内容结合在一起，综合性会比较强。 [SDOI2010] 古代猪文 Portal. 翻译成人话，就是要求： g∑k∣n(nk) mod 999911659g^{\\sum_{k\\mid n} \\binom{n}{k}} \\bmod 999911659 g∑k∣n​(kn​)mod999911659 使用费马小定理降幂可得： g∑k∣n(nk) mod 999911658 mod 999911659g^{\\sum_{k\\mid n} \\binom{n}{k} \\bmod 999911658} \\bmod 999911659 g∑k∣n​(kn​)mod999911658mod999911659 999911658=2×3×4679×35617999911658=2\\times 3\\times 4679 \\times 35617999911658=2×3×4679×35617，这样小的质数模数已经可以使用 Lucas 定理，求四遍之后使用 CRT 合并出解即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 999911659; int fac[40005] = &#123;1&#125;; int poww(int a, int b, int p) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % p; a = 1ll * a * a % p; b >>= 1; &#125; return res % p; &#125; void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) return x = 1, y = 0, void(); exgcd(b, a % b, y, x); y -= a / b * x; &#125; int inv(int t, int p) &#123; int x, y; exgcd(t, p, x, y); return (x % p + p) % p; &#125; int C(int n, int m, int p) &#123; if (m > n) return 0; if (m == 0 || m == n) return 1; return 1ll * fac[n] * inv(fac[m], p) % p * inv(fac[n - m], p) % p; &#125; int Lucas(int n, int m, int p) &#123; if (m == 0 || m == n) return 1; return 1ll * Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p; &#125; int a[10], m[10] = &#123;0, 2, 3, 4679, 35617&#125;, M[10]; int CRT(void) &#123; int ans = 0, x; for (int i = 1; i &lt;= 4; ++i) &#123; M[i] = (MOD - 1) / m[i]; ans = (ans + 1ll * a[i] * M[i] % (MOD - 1) * inv(M[i], m[i])) % (MOD - 1); &#125; return (ans % (MOD - 1) + (MOD - 1)) % (MOD - 1); &#125; int n, g; int calc(void) &#123; for (int op = 1; op &lt;= 4; ++op) &#123; for (int i = 1; i &lt;= 40000; ++i) fac[i] = 1ll * fac[i - 1] * i % m[op]; for (int i = 1; i * i &lt;= n; ++i) if (n % i == 0) &#123; a[op] = (a[op] + Lucas(n, i, m[op])) % m[op]; if (i * i != n) a[op] = (a[op] + Lucas(n, n / i, m[op])) % m[op]; &#125; &#125; return CRT(); &#125; int main(void) &#123; cin >> n >> g; int t = calc(); if (g == MOD &amp;&amp; t == 0) puts(\"0\"); // 注意这里，因为费马小定理取模的原因，所以 t == 0 时其实 t == k(MOD - 1)，所以答案是 0 不是 1，扩展欧拉定理降幂的时候也有类似的问题 else cout &lt;&lt; poww(g, t, MOD) &lt;&lt; '\\n'; return 0; &#125; 组合数奇偶性公式 | [CTSC2017] 吉夫特 Portal.输入一个长度为 nnn 的数列 a1,a2,⋯ ,ana_1, a_2, \\cdots , a_na1​,a2​,⋯,an​ 问有多少个长度大于等于 222 的不上升的子序列满足：∏i=2k(abi−1abi) mod 2=(ab1ab2)×(ab2ab3)×⋯(abk−1abk) mod 2&gt;0\\prod _{i=2}^{k} \\binom{a_{b_{i-1}}}{a_{b_i}} \\bmod 2 = \\binom{a_{b_1}}{a_{b_2}} \\times \\binom{a_{b_2}}{a_{b_3}} \\times \\cdots \\binom{a_{b_{k-1}}}{a_{b_k}} \\bmod 2 &gt; 0i=2∏k​(abi​​abi−1​​​)mod2=(ab2​​ab1​​​)×(ab3​​ab2​​​)×⋯(abk​​abk−1​​​)mod2&gt;0输出这个个数对 100000000710000000071000000007 取模的结果。1≤n≤2119851\\leq n\\leq 2119851≤n≤211985，1≤ai≤2333331\\leq a_i\\leq 2333331≤ai​≤233333。所有的 aia_iai​ 互不相同，也就是说不存在 i,ji, ji,j 同时满足 1≤i&lt;j≤n1\\leq i &lt; j\\leq n1≤i&lt;j≤n 和 ai=aja_i = a_jai​=aj​。 结论：(nm)≡1(mod2) ⟺ n &amp; m=m\\binom{n}{m}\\equiv 1 \\pmod 2 \\iff n\\ \\&amp; \\ m=m(mn​)≡1(mod2)⟺n &amp; m=m。使用 Lucas 定理来证明，需保证不出现 (01)\\binom{0}{1}(10​)。这就是组合数奇偶性公式。 于是直接整一个 DP，设 f(i)f(i)f(i) 代表以 iii 结尾的子序列个数，然后采用刷表转移。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 1000000007; int n, ans = 0; int f[233340]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, a; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;a); f[a] += 1; for (int S = a - 1 &amp; a; S; S = S - 1 &amp; a) f[S] = (f[S] + f[a]) % MOD; ans = (ans + f[a]) % MOD; &#125; printf(\"%d\\n\", ans - n); // 减去只有一个数的 return 0; &#125; 「KDOI-03」构造数组 Portal.你现在有一个长度为 nnn 的数组 aaa。一开始，所有 aia_iai​ 均为 000。给出一个同样长度为 nnn 的目标数组 bbb。求有多少种方案，使得通过若干次以下操作，可以让 aaa 数组变成 bbb。选出两个不同的下标 1≤i&lt;j≤n1\\leq i&lt;j\\leq n1≤i&lt;j≤n，并将 aia_iai​ 和 aja_jaj​ 同时增加 111。两种方案被称之为不同的，当且仅当存在一个 xxx 使得一种方案中第 xxx 次操作选择的两个下标 (i,j)(i,j)(i,j) 与另一种方案中的不同。答案对 998244353998244353998244353 取模。对于 100%100\\%100% 的数据，1≤n≤5 0001\\le n\\le5~0001≤n≤5 000，1≤bi≤30 0001\\leq b_i\\le30~0001≤bi​≤30 000，∑bi≤30 000\\sum b_i\\le30~000∑bi​≤30 000。 整一个 DP。设 f(i,m2)f(i, m2)f(i,m2) 代表考虑到第 iii 个数，填好了 m2m2m2 个操作数对，可以计算出此时填了 m1m1m1 个操作数对的一个数和 m0m0m0 个空的操作数对。采用刷表法转移，f(i,m2)f(i,m2)f(i,m2) 可以转移到 f(i+1,m2+k)f(i+1,m2+k)f(i+1,m2+k)，有 (m1k)(m0bi−k)\\dbinom{m1}{k}\\dbinom{m0}{b_i-k}(km1​)(bi​−km0​) 种方案数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 998244353; inline int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int n, m; int b[5005], s[5005], fac[30005], inv[30005]; int f[2][30005]; inline int C(int n, int m) &#123; return 1ll * fac[n] * inv[m] % MOD * inv[n - m] % MOD; &#125; inline void add(int &amp;x, int k) &#123; x = (x + k) % MOD; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i), s[i] = s[i - 1] + b[i]; m = s[n]; if (m &amp; 1) return !puts(\"0\"); m >>= 1; fac[0] = 1; for (int i = 1; i &lt;= m; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; inv[m] = poww(fac[m], MOD - 2); for (int i = m - 1; i >= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD; f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= m; ++j) f[i &amp; 1][j] = 0; for (int j = 0; j &lt;= m; ++j) &#123; int m2 = j, m1 = s[i - 1] - 2 * m2, m0 = m - m1 - m2; if (m0 &lt; 0 || m1 &lt; 0) continue; int R = min(&#123;m1, b[i], m - m2&#125;); for (int k = max(0, b[i] - m0); k &lt;= R; ++k) add(f[i &amp; 1][m2 + k], 1ll * f[i - 1 &amp; 1][m2] * C(m1, k) % MOD * C(m0, b[i] - k) % MOD); &#125; &#125; printf(\"%d\\n\", f[n &amp; 1][m]); return 0; &#125; [CF985G] Team Players Portal. 一眼看去在补图上跑三元环计数，然后发现边数爆炸，直接告辞。 但是唯一会的好像就是数三元环。考虑求答案的补集，答案应该是所有三元组的答案，减去至少有一条边的三元组的答案。 然后后面这个怎么做呢？我们肯定是要去看边的，这样就会导致对于一个有两条边的三元组，被统计两次。因此后面这个也需要容斥。 最终答案就是所有三元组的答案（1），减去至少有一条边的答案（2），加上至少有两条边的答案（3），减去有三条边的答案（4）。接下来分别看这四个东西怎么做。 枚举 u∈[0,n)u\\in [0,n)u∈[0,n) 中在三元组 (i,j,k)(i,j,k)(i,j,k) 的位置，然后利用乘法原理计算答案。 只有一条边，那么枚举所有边 (x,y)(x,y)(x,y)，不妨令 x&lt;yx&lt;yx&lt;y，然后令第三个点为 zzz，考虑 x,y,zx,y,zx,y,z 对三元组 (i,j,k)(i,j,k)(i,j,k) 的贡献。 x=ix=ix=i，此时 z&gt;xz&gt;xz&gt;x，xxx 的贡献为 A×x×(n−x−2)A\\times x\\times (n-x-2)A×x×(n−x−2)； x=jx=jx=j，此时 z&lt;xz&lt;xz&lt;x，xxx 的贡献为 B×x×xB\\times x\\times xB×x×x； y=jy=jy=j，此时 z&gt;yz&gt;yz&gt;y，yyy 的贡献为 B×y×(n−y−1)B\\times y\\times (n-y-1)B×y×(n−y−1)； y=ky=ky=k，此时 z&lt;yz&lt;yz&lt;y，yyy 的贡献为 C×y×(y−1)C\\times y\\times (y-1)C×y×(y−1)； z=iz=iz=i，此时 0≤z&lt;x0\\le z&lt;x0≤z&lt;x，zzz 的贡献为 A×∑p=0x−1p=A×x×(x−1)2\\displaystyle A\\times \\sum_{p=0}^{x-1}p=A\\times \\frac {x\\times (x-1)} 2A×p=0∑x−1​p=A×2x×(x−1)​； z=jz=jz=j，此时 x&lt;z&lt;yx&lt;z&lt;yx&lt;z&lt;y，zzz 的贡献为 B×∑p=x+1y−1p=B×(x+y)×(y−x−1)2\\displaystyle B\\times \\sum_{p=x+1}^{y-1}p=B\\times\\frac{(x+y) \\times (y-x-1)} 2B×p=x+1∑y−1​p=B×2(x+y)×(y−x−1)​； z=kz=kz=k，此时 y&lt;z&lt;ny&lt;z&lt;ny&lt;z&lt;n，zzz 的贡献为 C×∑p=y+1n−1p=C×(n+y)×(n−y−1)2\\displaystyle C\\times \\sum_{p=y+1}^{n-1}p=C\\times \\frac{(n+y)\\times (n-y-1)} 2C×p=y+1∑n−1​p=C×2(n+y)×(n−y−1)​。 两条边，要求的是三个点的链。不妨考虑枚举的是中间点 xxx，此时 x=jx=jx=j。枚举 xxx 的每一条出边到达点 yyy，设 xxx 的出度为 ttt。由于 xxx 也会影响 yyy 充当的是 i,ji,ji,j 还是 kkk，因此不妨把 xxx 也加进 xxx 的出边中（ttt 同时也增大 111）。设 yyy 在这些数中的排名为 rrr，分两种情况计算 yyy 的贡献： y&lt;xy&lt;xy&lt;x，此时考虑第三个点 zzz ： z&gt;yz&gt;yz&gt;y，yyy 的贡献为 A×y×(t−r−2)A\\times y\\times (t-r-2)A×y×(t−r−2)； z&lt;yz&lt;yz&lt;y，yyy 的贡献为 B×y×rB\\times y\\times rB×y×r； y&gt;xy&gt;xy&gt;x，此时考虑第三个点 zzz； z&gt;yz&gt;yz&gt;y，yyy 的贡献为 B×y×(t−r−1)B\\times y\\times (t-r-1)B×y×(t−r−1)； z&lt;yz&lt;yz&lt;y，yyy 的贡献为 C×y×(r−1)C\\times y\\times (r-1)C×y×(r−1)。 然后对于 xxx 自己要进行一个统计，考虑三种情况： y,z&lt;xy,z&lt;xy,z&lt;x，xxx 的贡献为 C×x×r×(r−1)2C\\times x\\times \\dfrac{r\\times (r-1)}{2}C×x×2r×(r−1)​； y,z&gt;xy,z&gt;xy,z&gt;x，xxx 的贡献为 A×x×(t−r−1)×(t−r−2)2A\\times x\\times \\dfrac{(t-r-1)\\times (t-r-2)}{2}A×x×2(t−r−1)×(t−r−2)​； y&lt;x,z&gt;xy&lt;x,z&gt;xy&lt;x,z&gt;x，xxx 的贡献为 B×x×r×(t−r−1)B\\times x\\times r\\times (t-r-1)B×x×r×(t−r−1)。 直接搞一个三元环计数模板就行。 于是就很高兴地做完了，时间复杂度应该是 O(n)+O(m)+O(n+m)+O(mm)=O(n+mm)O(n)+O(m)+O(n+m)+O(m\\sqrt{m})=O(n+m\\sqrt{m})O(n)+O(m)+O(n+m)+O(mm​)=O(n+mm​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; int n, m, u[200005], v[200005], deg[200005]; u64 A, B, C; vector&lt;int> G[200005], E[200005]; u64 calc0(void) &#123; u64 ans = 0; for (int i = 0; i &lt; n; ++i) &#123; ans += A * (n - i - 1) * (n - i - 2) / 2 * i; ans += B * i * (n - i - 1) * i; ans += C * i * (i - 1) / 2 * i; &#125; cerr &lt;&lt; \"A0 \" &lt;&lt; ans &lt;&lt; \"\\n\"; return ans; &#125; u64 calc1(void) &#123; u64 ans = 0; for (int i = 0; i &lt; m; ++i) &#123; int x = u[i], y = v[i]; ans += A * x * (n - x - 2); ans += B * x * x; ans += B * y * (n - y - 1); ans += C * y * (y - 1); ans += A * x * (x - 1) / 2; ans += B * (x + y) * (y - x - 1) / 2; ans += C * (n + y) * (n - y - 1) / 2; &#125; cerr &lt;&lt; \"A1 \" &lt;&lt; ans &lt;&lt; \"\\n\"; return ans; &#125; u64 calc2(void) &#123; u64 ans = 0; for (int x = 0; x &lt; n; ++x) &#123; int t = G[x].size(); // 算 x 自己 for (int i = 0; i &lt; t; ++i) &#123; int y = G[x][i]; if (y &lt; x) &#123; ans += A * y * (t - i - 2); ans += B * y * i; &#125; else if (y > x) &#123; ans += B * y * (t - i - 1); ans += C * y * (i - 1); &#125; else &#123; ans += C * i * (i - 1) / 2 * x; ans += A * (t - i - 1) * (t - i - 2) / 2 * x; ans += B * i * (t - i - 1) * x; &#125; &#125; &#125; cerr &lt;&lt; \"A2 \" &lt;&lt; ans &lt;&lt; \"\\n\"; return ans; &#125; int vis[200005]; u64 calc3(void) &#123; u64 ans = 0; memset(vis, 0xff, sizeof vis); for (int x = 0; x &lt; n; ++x) &#123; for (int y : E[x]) vis[y] = x; for (int y : E[x]) for (int z : E[y]) if (vis[z] == x) &#123; int t[] = &#123;x, y, z&#125;; sort(t, t + 3); ans += A * t[0] + B * t[1] + C * t[2]; &#125; &#125; cerr &lt;&lt; \"A3 \" &lt;&lt; ans &lt;&lt; \"\\n\"; return ans; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m >> A >> B >> C; for (int i = 0; i &lt; m; ++i) &#123; cin >> u[i] >> v[i]; ++deg[u[i]]; ++deg[v[i]]; G[u[i]].emplace_back(v[i]); G[v[i]].emplace_back(u[i]); if (u[i] > v[i]) swap(u[i], v[i]); &#125; for (int i = 0; i &lt; n; ++i) G[i].emplace_back(i), sort(G[i].begin(), G[i].end()); for (int i = 0; i &lt; m; ++i) &#123; int x = u[i], y = v[i]; if (deg[x] > deg[y] || (deg[x] == deg[y] &amp;&amp; x > y)) swap(x, y); E[x].emplace_back(y); &#125; cout &lt;&lt; calc0() - calc1() + calc2() - calc3() &lt;&lt; \"\\n\"; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://james1badcreeper.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"数学","slug":"数学","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"复杂树形问题","slug":"notes/DS/tree-ex","date":"2022-12-13T00:00:00.000Z","updated":"2022-12-13T00:00:00.000Z","comments":true,"path":"6a4a6864/","link":"","permalink":"https://james1badcreeper.github.io/6a4a6864/","excerpt":"高阶的树形问题更为困难，包括一些比较复杂的算法技巧和数据结构。","text":"高阶的树形问题更为困难，包括一些比较复杂的算法技巧和数据结构。 基环树 如果一个连通无向图有 nnn 个点和 nnn 条边，相当于在一棵树上加了一条边，长出了一个环，那么这个东西就成了基环树。除了这个基环之外，剩下的每一部分都是若干棵子树。 概念 nnn 个点 nnn 条边的无向图也有可能是“基环树森林”。如果图是有向的，那么还有内向基环树（每个点仅有 111 条出边）和外向基环树（每个点仅有 111 条入边）。 在求解与基环树相关的问题时，一般都要找到基环，把基环作为广义的“根节点”进行处理。 基环树 DP 基环树上的 DP 大致与树形 DP 一致。 [ZJOI2008] 骑士。树的最大独立集，但是基环树。 注意这有可能是一个基环树森林，所以需要进行多次 DP。 笛卡尔树 笛卡尔树是一种特殊的 Treap，其节点权值不再是随机的，而是给定的。每个节点的权值用 (xi,yi)(x_i,y_i)(xi​,yi​) 表示，只考虑 xxx 时它是 BST，只考虑 yyy 时它是堆（此处以小根堆为例）。 在 xxx 递增时，我们可以以线性复杂度建出笛卡尔树。插入新节点时，为了保证 xxx 的性质满足，要将 xxx 插入到尽量右的地方。 具体来讲，维护一个从根节点一直走到右儿子的链。设当前需要插入 uuu，则需要找到第一个 yv&lt;yuy_v&lt;y_uyv​&lt;yu​，将 vvv 的右儿子设为 uuu（不存在则将 uuu 设为根），如果 vvv 原本有右子树，则将 vvv 的右子树改连在 uuu 的左子树下面来满足 BST 性质。使用单调栈维护此链，时间复杂度为 O(n)O(n)O(n)。 模板题核心代码如下： for (int i = 1, tot = 0, cur = 0; i &lt;= n; ++i) &#123; scanf(\"%d\", p + i); cur = tot; while (cur &amp;&amp; p[st[cur]] > p[i]) --cur; if (cur) rs[st[cur]] = i; if (cur &lt; tot) ls[i] = st[cur + 1]; // 放到左节点以满足 BST 性质 st[++cur] = i; tot = cur; &#125; 性质：如果节点编号 1∼n1\\sim n1∼n 为 BST 权值，然后点权满足小根堆性质，那么 min⁡{ax,⋯ ,ay}=aLCA⁡(x,y)\\min\\{a_x,\\cdots,a_y\\}=a_{\\operatorname{LCA}(x,y)}min{ax​,⋯,ay​}=aLCA(x,y)​。 树上启发式合并 还记得并查集的按秩合并吗？当秩定义为集合的大小时，就变成了启发式合并。树上启发式合并（dsu on tree）让点数小的树成为点数较大的树的子树，在处理一些可以离线的树上问题时非常简单，而且复杂度是 log⁡\\loglog 的。我们来看一道简单题： 给定一棵 n(n≤2×105)n(n\\le 2\\times 10^5)n(n≤2×105) 个节点的树，节点 xxx 的颜色是 cxc_xcx​，现在询问对于 xxx 的子树里出现了多少不同种颜色。强制离线。 我们先处理出每个子节点的子树大小和重儿子，还有当前节点子树中的最大最小时间戳，使用类似于重链剖分的过程就可以完成。用 cnt[i]cnt[i]cnt[i] 表示颜色 iii 出现的次数，ans[x]ans[x]ans[x] 代表节点 xxx 的答案。 接下来我们进行第二次 dfs(x, fa, keep)，keepkeepkeep 代表是否保留影响： 先遍历 xxx 的轻儿子，并设置 keep=falsekeep=falsekeep=false； 遍历 xxx 的重儿子，设置 keep=truekeep=truekeep=true； 将轻儿子的答案全部加入（遍历时间戳），统计答案，完成后删除。 这相当于是干了个什么呢？我们要统计一个 xxx 子树的答案，肯定是要将它的所有儿子的也都遍历的。但问题是我们不能保留这些，遍历一个儿子的答案之后必须马上删除，否则下一个儿子的答案是错误的。而最后一个儿子的答案是不用删除的，因为马上就会回溯，这个答案肯定还要再次被使用，我们肯定选择最重的一个保留。 理论时间复杂度是 O(nlog⁡n)O(n\\log n)O(nlogn)，具体证明较为复杂，到时候再补吧。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, siz[200005], son[200005]; int L[200005], R[200005], idx[200005], num = 0; vector&lt;int> G[200005]; void dfs1(int x, int fa) &#123; siz[x] = 1; L[x] = ++num; idx[num] = x; int max_part = -1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > max_part) son[x] = y, max_part = siz[y]; &#125; R[x] = num; &#125; int c[200005], cnt[200005], anscol; int ans[200005]; void add(int x) &#123; if (cnt[c[x]] == 0) ++anscol; ++cnt[c[x]]; &#125; void del(int x) &#123; if (cnt[c[x]] == 1) --anscol; --cnt[c[x]]; &#125; void dfs2(int x, int fa, bool keep) &#123; for (int y : G[x]) if (y != fa &amp;&amp; y != son[x]) dfs2(y, x, false); if (son[x] != -1) dfs2(son[x], x, true); for (int y : G[x]) if (y != fa &amp;&amp; y != son[x]) for (int i = L[y]; i &lt;= R[y]; ++i) add(idx[i]); add(x); ans[x] = anscol; if (!keep) for (int i = L[x]; i &lt;= R[x]; ++i) del(idx[i]); // 实际上上一步会全部清空，因为当前子树中没有需要保留的内容 &#125; int main(void) &#123; memset(son, -1, sizeof(son)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", c + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs1(1, 0); dfs2(1, 0, false); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", ans[i]); putchar('\\n'); return 0; &#125; Kruskal 重构树 得益于 Kruskal 的美妙性质，Kruskal 重构树是解决一些路径最值相关问题的强有力武器。 其本质上是启发式合并的一种应用。 定义 在求解 Kruskal 的时候，我们会从小到大加入若干条边。开始时我们建立 nnn 个集合，每个集合恰好有一个节点，点权为 000。 每次加边会合并两个集合，这时候我们新建一个节点，点权为加入的边的边权，同时将两个集合的根节点分别设为新建节点的左右儿子，这时这两个集合和新建点会并为一个集合，新建点为集合的根。 当 Kruskal 完成时，我们就得到了一棵恰好包含 nnn 个叶子的二叉树（总节点数为 2n−12n-12n−1），同时每个非叶子节点恰好有两个儿子，得到的这棵树就叫做 Kruskal 重构树。 性质 父亲节点的点权大于等于儿子的点权。 原图中的两点间所有简单路径上最大边权的最小值，就是最小生成树上两个点之间的简单路径上的最大边权值，就是 Kruskal 重构树上两点的 LCA 的权值。 [CF1706E] Qpwoeirut and Vertices. 根据边的顺序赋予权值，构建出 Kruskal 重构树，询问相当于求区间点的 LCA 的权值，可以使用线段树维护。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; struct edge &#123; int u, v, w; &#125; e[200005]; int n, m, q, a[200005], bin[200005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; vector&lt;int> G[200005]; void addedge(int x, int fa) &#123; G[x].emplace_back(fa); G[fa].emplace_back(x); &#125; int f[17][200005], dep[200005], dfn[200005], num = 0; void dfs(int x, int fa) &#123; f[0][x] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= 16; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 16; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = 16; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; int T[400005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = l, void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = LCA(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return LCA(query(o &lt;&lt; 1, l, mid, x, y), query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); &#125; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;e[i].u, &amp;e[i].v), e[i].w = i; for (int i = 1; i &lt;= n * 2; ++i) bin[i] = i, a[i] = 0, G[i].clear(); int tot = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v, w = e[i].w; int x = find(u), y = find(v); if (x == y) continue; a[++tot] = w; bin[x] = bin[y] = tot; addedge(x, tot); addedge(y, tot); if (tot == 2 * n - 1) break; &#125; dfs(tot, 0); build(1, 1, n); while (q--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d \", a[query(1, 1, n, l, r)]); &#125; putchar('\\n'); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; 点权重构树 对于点权的限制一样可以处理。 一种选择是，限制经过的点权最大值，因为走 (u,v)(u,v)(u,v) 需要满足均不超过 wu,wvw_u,w_vwu​,wv​，因此将边权赋值为 max⁡{wu,wv}\\max\\{w_u,w_v\\}max{wu​,wv​}。 然而事实上我们可以造一个多叉重构树。比如限制经过点权的最大值，那么将节点按照权值从小到大排序，遍历每个节点 uuu 和能到达的节点 vvv，若 vvv 已经遍历，则 wu≥wvw_u\\ge w_vwu​≥wv​，max⁡{wu,wv}\\max\\{w_u,w_v\\}max{wu​,wv​} 取到 wuw_uwu​，若不连通则 uuu 是 vvv 所属集合的父亲。 虚树 如果树的规模很大，但是每次询问的点比较少怎么办？ 引入 [SDOI2011] 消耗战。 如果查询只有一次，可以直接树形 DP：设 f(i)f(i)f(i) 代表与其子树内任意询问点不连通的最小代价，如果它自己是询问点则 f(i)=+∞f(i)=+\\inftyf(i)=+∞，否则 fx=∑y∈son(x)min⁡{fy,wx,y}f_x=\\sum_{y\\in son(x)}\\min\\{f_y,w_{x,y}\\}fx​=∑y∈son(x)​min{fy​,wx,y​}。 但是多次询问！存在很多无用值，比如说一条链上面没有东西，我们只关心这条链的权值；还有关键点全在一棵子树内，我们根本不需要去 DP 其它子树。由于一般从根节点开始 DP，因此推荐默认把 111 号节点加入虚树。 我们只需要记录关键点的 LCA 即可，这样就能完整保存树中的子孙后代关系。但是还能 O(n2)O(n^2)O(n2) 枚举 LCA 吗？不能！将关键点按照 DFS 序排序，排序后相邻的两个关键点求 LCA 并把它加入虚树即可。但是这样很慢，可以使用一个 DFS 序递增的单调栈建立虚树： 将 111 加入虚树。 如果 deplca≤dept−1dep_{lca}\\le dep_{t-1}deplca​≤dept−1​，那么 t,t−1t,t-1t,t−1 之间一定有边，不断弹栈直到条件不满足。 如果 lcalcalca 不是栈顶，则将 lcalcalca 向栈顶连边。 点 pip_ipi​ 入栈。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, k, dep[250005], lg[250005]; int mi[18][250005], dfn[250005], num, d[18][250005], fa[18][250005]; int p[250005]; bool tag[250005]; vector&lt;pair&lt;int, int>> G[250005]; int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int ff) &#123; mi[0][dfn[x] = ++num] = ff; dep[x] = dep[fa[0][x] = ff] + 1; for (auto [y, w] : G[x]) if (y != ff) d[0][y] = w, dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int dist(int x, int y) &#123; int res = 1e9; for (int i = lg[dep[y] - dep[x]]; i >= 0; --i) if (dfn[fa[i][y]] >= dfn[x]) &#123; res = min(res, d[i][y]); y = fa[i][y]; &#125; return res; &#125; vector&lt;int> E[250005]; inline void addedge(int x, int y) &#123; // x 是父亲，y 是儿子 E[x].emplace_back(y); E[y].emplace_back(x); &#125; int st[250005], tot; i64 f[250005]; void dp(int x, int ff) &#123; if (tag[x]) f[x] = 1e15; for (int y : E[x]) if (y != ff) &#123; dp(y, x); if (!tag[x]) f[x] += min(f[y], (i64)dist(x, y)); &#125; E[x].clear(); &#125; void build_tree(void) &#123; sort(p + 1, p + k + 1, [](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;); st[tot = 1] = 1; for (int i = 1; i &lt;= k; ++i) if (p[i] != 1) &#123; int lca = LCA(st[tot], p[i]); while (tot > 1 &amp;&amp; dep[lca] &lt;= dep[st[tot - 1]]) addedge(st[tot - 1], st[tot]), --tot; if (lca != st[tot]) f[lca] = 0, addedge(lca, st[tot]), st[tot] = lca; st[++tot] = p[i]; &#125; for (int i = 1; i &lt; tot; ++i) addedge(st[i], st[i + 1]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].emplace_back(v, d); G[v].emplace_back(u, d); &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j &lt;= n; ++j) &#123; fa[i][j] = fa[i - 1][fa[i - 1][j]]; d[i][j] = min(d[i - 1][j], d[i - 1][fa[i - 1][j]]); if (j + (1 &lt;&lt; i) - 1 &lt;= n) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); &#125; scanf(\"%d\", &amp;m); while (m--) &#123; scanf(\"%d\", &amp;k); f[1] = 0; for (int i = 1; i &lt;= k; ++i) scanf(\"%d\", p + i), tag[p[i]] = 1, f[p[i]] = 0; build_tree(); dp(1, 0); printf(\"%lld\\n\", f[1]); f[1] = 0; for (int i = 1; i &lt;= k; ++i) tag[p[i]] = 0; &#125; return 0; &#125; 性质 点集 SSS 的虚树边权和等于所有时间戳相邻的节点的距离之和除以 222。也就是说，设排序后的时间戳为 a0,⋯a∣S∣−1a_0,\\cdots a_{|S|-1}a0​,⋯a∣S∣−1​，那么边权和为 ∑i=0∣S∣dist(ai,a(i+1) mod ∣S∣)÷2\\sum_{i=0}^{|S|}dist(a_i,a_{(i+1)\\bmod |S|})\\div 2∑i=0∣S∣​dist(ai​,a(i+1)mod∣S∣​)÷2。这其实就是 DFS 序的性质。 树上分治算法 分治又来了！树上分治算法一般分为点分治（更为常用）和边分治，类似将区间分成两半。 静态点分治 模板。给定一棵边带权的树，多次询问树上距离为 kkk 的点是否存在。 我们先看一看这个问题在链上如何解决：对于当前区间 [l,r],mid=(l+r)/2[l,r],mid=(l+r)/2[l,r],mid=(l+r)/2，答案区间 [i,j][i,j][i,j] 要么满足 i,j≤mid,i,j&gt;midi,j\\le mid,i,j&gt;midi,j≤mid,i,j&gt;mid，要么跨越中点 i≤mid&lt;ji\\le mid&lt;ji≤mid&lt;j。当跨越中点时，对原序列的前缀和数组求一组 sj−si=ks_j-s_i=ksj​−si​=k，那么在分治的同时对 sss 进行归并排序，枚举 sjs_jsj​，判断 sj−ks_j-ksj​−k 是否在 [l,mid][l,mid][l,mid] 中出现过。时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 我们先任意选择一个节点作为根节点 rootrootroot（显然重心比较好），所有完全位于其子树中的路径可以分为： 不经过当前根节点的路径； 经过当前根节点的路径，又可以分为两种： 以根节点为一个端点的路径； 跨越根节点的路径，实际上是有两条以一个根节点为端点的路径合并而成，分治的时候只需要合并这种信息。 所以我们就可以使用类似分治的方式进行求解！找到重心 rrr 作为分治中心，打上删除标记，并 dfs 它的每一棵子树（遇到打了删除标记的点就要立即停止）。求出子树内每个节点到分治重心的距离和来源于哪个儿子的子树，统一存在一个 vector 里，使用双指针来合并答案（注意只能合并不同的子树）。 离线统一处理可以将时间复杂度降低为 O(nlog⁡n(m+log⁡n))O(n\\log n(m+\\log n))O(nlogn(m+logn))，正常单次点分治的时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; typedef pair&lt;int, int> pii; int n, m, k[10005], siz[10005], maxx[10005]; int root = 0; bool vis[10005], ans[10005]; vector&lt;pii> G[10005]; void froot(int x, int fa, int tot) &#123; siz[x] = 1; maxx[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; froot(y, x, tot); siz[x] += siz[y]; maxx[x] = max(maxx[x], siz[y]); &#125; maxx[x] = max(maxx[x], tot - siz[x]); if (maxx[x] &lt; maxx[root]) root = x; &#125; vector&lt;pii> info; void getinfo(int x, int fa, int anc, int d) &#123; info.emplace_back(make_pair(d, anc)); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; getinfo(y, x, anc, d + G[x][i].second); &#125; &#125; void divide(int x) &#123; vis[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; getinfo(y, x, y, G[x][i].second); &#125; info.emplace_back(make_pair(0, x)); sort(info.begin(), info.end()); for (int i = 1; i &lt;= m; ++i) &#123; int l = 0, r = info.size() - 1; while (l &lt; r &amp;&amp; !ans[i]) &#123; if (info[l].first + info[r].first > k[i]) --r; else if (info[l].first + info[r].first &lt; k[i]) ++l; else &#123; if (info[l].second != info[r].second) ans[i] = true; if (info[l].first == info[l + 1].first) ++l; else --r; &#125; &#125; &#125; info.clear(); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].emplace_back(make_pair(v, w)); G[v].emplace_back(make_pair(u, w)); &#125; for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", k + i); maxx[0] = n + 1; froot(1, 0, n); divide(root); for (int i = 1; i &lt;= m; ++i) puts(ans[i] ? \"AYE\" :\"NAY\"); return 0; &#125; 静态边分治 每次分治时找一条边，然后统计经过这条边的路径，再删去这条边递归统计。发现其更好地对应了序列分治（只分成了两部分）。 三度化 但是这样复杂度有问题！如果树是菊花图，那么可以被卡到 O(n2)O(n^2)O(n2)。此时应该对该树进行三度化，增加虚点来让该节点的度数变为 333。 动态点分治 其可以处理带修问题。 点分树 对于一个节点 xxx 长链剖分 将子树深度最大的儿子作为重儿子（虽然应该不能叫这个名字），拥有如下性质： 链的规模是 O(n)O(\\sqrt{n})O(n​) 的。 一个节点的 kkk 级祖先所在长链的长度一定不小于 kkk。 每个节点所在的长链末端是其子树内的最深节点。 树上 k 级祖先 模板。 最直接的方式就是重链剖分，然后如果链的长度 ≤k\\le k≤k 就往上跳，否则直接输出（因为重链上的 DFS 序是连续的），时间复杂度为 O(n+qlog⁡n)O(n+q\\log n)O(n+qlogn)。 考虑长链剖分，倍增预处理出每个节点的 2k2^k2k 级祖先，并对于每条长链求出其从顶端向上/向下走 iii 步能走到哪个节点。对于询问 x,kx,kx,k，先跳到 kkk 的二进制最高位 ttt，即 2t2^t2t 级父亲。这样可以将 kkk 缩减一半，这样就可以直接从长链顶端根据深度开跳了。时间复杂度为 O(nlog⁡n+q)O(n\\log n + q)O(nlogn+q)。 查看代码 #include &lt;bits/stdc++.h> #define ui unsigned int #define i64 long long using namespace std; ui s; inline ui get(ui x) &#123; x ^= x &lt;&lt; 13; x ^= x >> 17; x ^= x &lt;&lt; 5; return s = x; &#125; int n, q, root, lg[500005]; int f[19][500005], dep[500005], h[500005]; int son[500005], top[500005]; vector&lt;int> G[500005], up[500005], down[500005]; void dfs1(int x) &#123; dep[x] = dep[f[0][x]] + 1; h[x] = 1; for (int i = 1; i &lt; 19; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) &#123; dfs1(y); h[x] = max(h[x], h[y] + 1); if (h[son[x]] &lt; h[y]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; if (x == topf) up[x].resize(h[x]), down[x].resize(h[x]); down[topf][dep[x] - dep[topf]] = x; top[x] = topf; if (son[x]) dfs2(son[x], topf); for (int y : G[x]) if (y != son[x]) dfs2(y, y); &#125; int main(void) &#123; scanf(\"%d%d%u\", &amp;n, &amp;q, &amp;s); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;f[0][i]); if (f[0][i] == 0) root = i; else G[f[0][i]].emplace_back(i); &#125; dfs1(root); dfs2(root, root); for (int i = 1; i &lt;= n; ++i) if (top[i] == i) // 长链顶端 for (int j = 0, cur = i; j &lt; h[i] &amp;&amp; cur; ++j, cur = f[0][cur]) up[i][j] = cur; i64 ans = 0; for (int last = 0, i = 1; i &lt;= q; ++i) &#123; int x = (get(s) ^ last) % n + 1, k = (get(s) ^ last) % dep[x]; x = (k == 0 ? x : f[lg[k]][x]), k -= (k == 0 ? 0 : (1 &lt;&lt; lg[k])); int t = top[x]; if (dep[x] - k >= dep[t]) last = down[t][dep[x] - k - dep[t]]; else last = up[t][dep[t] - dep[x] + k]; ans ^= 1ll * i * last; &#125; printf(\"%lld\\n\", ans); return 0; &#125; 优化深度相关的 DP Portal.给定一棵 n(n≤106)n(n\\le 10^6)n(n≤106) 个节点的树，设 d(u,x)d(u,x)d(u,x) 为 uuu 子树中到 uuu 的距离为 xxx 的节点数。对于每个点，求最小的 kkk 使 d(u,k)d(u,k)d(u,k) 最大。 我们只关心每个节点内深度为 jjj 的节点个数，深度相同的节点是等价的。设 fi,jf_{i,j}fi,j​ 表示子树 iii 内深度为 jjj 的节点个数，则 fi,j=∑k∈son(i)fk,j−1f_{i,j}=\\sum_{k\\in son(i)}f_{k,j-1}fi,j​=∑k∈son(i)​fk,j−1​。 考虑长链剖分优化：对于重儿子，直接继承它的答案。然后合并轻儿子的答案，每个节点最多被合并一次。 可以看出，这实际上是基于长链剖分的树上启发式合并，如果点只有深度信息有用的时候可以使用，时间复杂度是线性的。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, fa[1000005], h[1000005], son[1000005]; int *f[1000005], buf[1000005], *poi = buf; int ans[1000005], mx[1000005]; vector&lt;int> G[1000005]; void dfs1(int x, int ff) &#123; fa[x] = ff; h[x] = 1; for (int y : G[x]) if (y != ff) &#123; dfs1(y, x); h[x] = max(h[x], h[y] + 1); if (h[son[x]] &lt; h[y]) son[x] = y; &#125; &#125; void dfs2(int x) &#123; if (son[x]) f[son[x]] = f[x] + 1, dfs2(son[x]), mx[x] = mx[son[x]], ans[x] = ans[son[x]] + 1; // 长链的修改直接修改自己 for (int y : G[x]) if (y != fa[x] &amp;&amp; y != son[x]) &#123; f[y] = poi; poi += h[y]; dfs2(y); for (int i = 1; i &lt;= h[y]; ++i) &#123; f[x][i] += f[y][i - 1]; if (f[x][i] > mx[x] || f[x][i] == mx[x] &amp;&amp; ans[x] > i) mx[x] = f[x][i], ans[x] = i; &#125; &#125; f[x][0] = 1; if (mx[x] &lt;= 1) mx[x] = 1, ans[x] = 0; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(1, 0); f[1] = poi; poi += h[1]; dfs2(1); for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; 性质 Problemset 可能会比较多。 树上启发式合并 主要用于处理一些离线不带修改的问题，还可以吊打树上莫队。 [CF600E] Lomsat gelral Portal.n(n≤105)n(n\\le 10^5)n(n≤105) 树的节点有颜色，一种颜色占领了一个子树，当且仅当没有其他颜色在这个子树中出现得比它多（当然可能有多个）。求占领每个子树的所有颜色编号之和。 几乎是树上启发式合并的板子，在加入的时候重新统计答案，清空的时候直接将答案清零即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int c[100005], son[100005], siz[100005]; int L[100005], R[100005], idx[100005], num = 0; vector&lt;int> G[100005]; void dfs1(int x, int fa) &#123; L[x] = ++num; idx[num] = x; siz[x] = 1; int max_part = -1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > max_part) max_part = siz[y], son[x] = y; &#125; R[x] = num; &#125; int cnt[100005]; i64 ans[100005], nowAns, maxcnt; void add(int x) &#123; ++cnt[c[x]]; if (cnt[c[x]] > maxcnt) maxcnt = cnt[nowAns = c[x]]; else if (cnt[c[x]] == maxcnt) nowAns += c[x]; &#125; void dfs2(int x, int fa, bool keep) &#123; for (int y : G[x]) if (y != fa &amp;&amp; y != son[x]) dfs2(y, x, false); if (son[x] != -1) dfs2(son[x], x, true); for (int y : G[x]) if (y != fa &amp;&amp; y != son[x]) for (int i = L[y]; i &lt;= R[y]; ++i) add(idx[i]); add(x); ans[x] = nowAns; if (!keep) &#123; for (int i = L[x]; i &lt;= R[x]; ++i) --cnt[c[idx[i]]]; maxcnt = nowAns = 0; &#125; &#125; int main(void) &#123; memset(son, -1, sizeof(son)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", c + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs1(1, 0); dfs2(1, 0, 1); for (int i = 1; i &lt;= n; ++i) printf(\"%lld \", ans[i]); putchar('\\n'); return 0; &#125; Kruskal 重构树 能高效解决路径最值的相关问题。 [NOI2018] 归程 Portal. 对图建立出 Kruskal 重构树，满足的点就是选择的出发点跳到满足条件的最浅的点，预处理出子树内最短路的最小值即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; struct edge &#123; int u, v, w; bool operator &lt; (const edge &amp;a) const &#123; return w > a.w; &#125; &#125; e[400005]; struct Dijkstra &#123; bool v[200005]; int d[200005]; vector&lt;pair&lt;int, int>> G[200005]; void dijkstra(void) &#123; memset(v, 0, sizeof(v)); memset(d, 0x3f, sizeof(d)); #define pii pair&lt;int, int> priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.push(&#123;d[1] = 0, 1&#125;); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (v[u]) continue; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int to = G[u][i].first, w = G[u][i].second; if (d[to] > d[u] + w) q.push(&#123;d[to] = d[u] + w, to&#125;); &#125; &#125; &#125; &#125; Solver; int bin[400005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; vector&lt;int> G[400005]; int d[400005], a[400005]; int dep[400005], f[21][400005]; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; f[0][x] = fa; d[x] = (x &lt;= n ? Solver.d[x] : 1e9); for (int i = 1; i &lt;= 20; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x), d[x] = min(d[x], d[y]); &#125; int query(int x, int y) &#123; for (int i = 20; i >= 0; --i) if (a[f[i][x]] > y) x = f[i][x]; return d[x]; &#125; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) Solver.G[i].clear(); for (int i = 1; i &lt;= n &lt;&lt; 1; ++i) bin[i] = i, a[i] = 0, G[i].clear(); for (int i = 1; i &lt;= m; ++i) &#123; int u, v, l, a; scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;l, &amp;a); Solver.G[u].emplace_back(make_pair(v, l)); Solver.G[v].emplace_back(make_pair(u, l)); e[i].u = u, e[i].v = v, e[i].w = a; &#125; Solver.dijkstra(); sort(e + 1, e + m + 1); int tot = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v, w = e[i].w; int x = find(u), y = find(v); if (x == y) continue; a[++tot] = w; bin[x] = tot; bin[y] = tot; G[x].emplace_back(tot); G[tot].emplace_back(x); G[y].emplace_back(tot); G[tot].emplace_back(y); &#125; dfs(tot, 0); int q, k, s, last; scanf(\"%d%d%d\", &amp;q, &amp;k, &amp;s); while (q--) &#123; int v, p; scanf(\"%d%d\", &amp;v, &amp;p); v = (v + k * last - 1) % n + 1; p = (p + k * last) % (s + 1); printf(\"%d\\n\", last = query(v, p)); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [IOI2018] Werewolf Portal. 是针对点权限制的 Kruskal 重构树。建立一个 LLL 来代表子树中都比它小，RRR 来代表子树中都比它大。将 sss 在 RRR 上倍增到 a≥la\\ge la≥l 的最小 aaa，将 eee 在 LLL 上倍增到 b≤rb\\le rb≤r 的最大 bbb，然后就是询问这两个子树有没有公共的子节点，就是二维数点问题。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, q, idx[200005]; vector&lt;int> G[200005]; vector&lt;pair&lt;int, int>> E[200005]; struct Tree &#123; int bin[200005], f[21][200005]; int dfn[200005], num, siz[200005]; vector&lt;int> G[200005]; int find(int x) &#123; return bin[x] == x ? x : bin[x] = find(bin[x]); &#125; void init(void) &#123; for (int i = 1; i &lt;= n; ++i) bin[i] = i; &#125; void merge(int u, int v) &#123; // 将 v 的祖先设置为 u v = find(v); if (u == v) return; bin[v] = u; f[0][v] = u; G[u].emplace_back(v); &#125; void dfs(int x, int fa) &#123; siz[x] = 1; dfn[x] = ++num; for (int i = 1; i &lt;= 20; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) dfs(y, x), siz[x] += siz[y]; &#125; int query(int x, int lim, bool t) &#123; // 将 x 跳到 t = 1 则跳到第一个 >= lim，t = 0 跳到第一个 &lt;= lim for (int i = 20; i >= 0; --i) if (f[i][x] &amp;&amp; (t ? f[i][x] >= lim : f[i][x] &lt;= lim)) x = f[i][x]; return x; &#125; &#125; L, R; // L 限制最大值，R 限制最小值 int C[200005], ans[200005], ql[200005], qr[200005]; void add(int x) &#123; for (; x &lt;= n; x += x &amp; -x) ++C[x]; &#125; int query(int x) &#123; int s = 0; for (; x; x -= x &amp; -x) s += C[x]; return s; &#125; int query(int x, int y) &#123; return query(y) - query(x - 1); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); ++u, ++v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; L.init(); R.init(); for (int u = 1; u &lt;= n; ++u) for (int v : G[u]) if (u > v) L.merge(u, v); for (int u = n; u >= 1; --u) for (int v : G[u]) if (u &lt; v) R.merge(u, v); L.dfs(n, 0); R.dfs(1, 0); for (int i = 1; i &lt;= n; ++i) idx[L.dfn[i]] = R.dfn[i]; for (int i = 1; i &lt;= q; ++i) &#123; int s, e, l, r; scanf(\"%d%d%d%d\", &amp;s, &amp;e, &amp;l, &amp;r); ++s, ++e, ++l, ++r; s = R.query(s, l, 1); e = L.query(e, r, 0); E[L.dfn[e] - 1].emplace_back(i, -1); E[L.dfn[e] + L.siz[e] - 1].emplace_back(i, 1); ql[i] = R.dfn[s], qr[i] = R.dfn[s] + R.siz[s] - 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; add(idx[i]); for (auto [x, flag] : E[i]) ans[x] += query(ql[x], qr[x]) * flag; &#125; for (int i = 1; i &lt;= q; ++i) printf(\"%d\\n\", ans[i] > 0); return 0; &#125; [CF1583H] Omkar and Tours Portal. 第一问比较经典，离线，将询问按照 vvv 从大到小排序，依次加入边，DFS 合并连通块，维护最大值即可。 第二问，希望路径上 ttt 的最大值尽可能大，Kruskal 重构树！建立一棵基于 ttt 的边权重构树。设能到达的节点是 yyy，那么答案为 max⁡{aLCA⁡(x,y)}\\max\\{a_{\\operatorname{LCA}(x,y)}\\}max{aLCA(x,y)​}。 由于 LCA 必定在 xxx 到根节点的路径上，也就是说，我们希望该 LCA 的深度尽可能小。什么时候满足呢？将所有 yyy 按照 DFS 序排序，其中 DFS 序最小和最大的可能称为答案（Kruskal 重构树是一棵二叉树，想要 LCA 离 xxx 越远，那么 yyy 就必定离 xxx 越远，也就是 DFS 序差越大）。 实现上只需要先建出 Kruskal 重构树，然后在第一问时并查集维护 DFS 序最大最小值。时间复杂度在 O(nlog⁡n)O(n\\log n)O(nlogn) 级别。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, q, ans1[200005], ans2[200005]; int a[200005]; struct Query &#123; int v, x, id; bool operator&lt; (const Query &amp;a) const &#123; return v > a.v; &#125; &#125; Q[200005]; struct edge &#123; int a, b, c, t; bool operator&lt; (const edge &amp;a) const &#123; return c > a.c; &#125; &#125; e[200005]; vector&lt;int> G[400005]; int bin[400005], val[400005], mx[200005], mn[200005]; int find(int x) &#123; return bin[x] == x ? x : bin[x] = find(bin[x]); &#125; int dfn[400005], num, mi[19][400005], lg[400005], idx[400005]; inline int get(int x, int y) &#123; return dfn[x] &lt; dfn[y] ? x : y; &#125; void dfs(int x, int fa) &#123; mi[0][dfn[x] = ++num] = fa; idx[num] = x; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; inline int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> q; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1; i &lt;= n * 2; ++i) bin[i] = i; for (int i = 2; i &lt;= n * 2; ++i) lg[i] = lg[i >> 1] + 1; // 建立 Kruskal 重构树 for (int i = 1; i &lt; n; ++i) cin >> e[i].a >> e[i].b >> e[i].c >> e[i].t; sort(e + 1, e + n, [&amp;](edge a, edge b) &#123; return a.t &lt; b.t; &#125;); int tot = n; for (int i = 1; i &lt; n; ++i) &#123; int u = find(e[i].a), v = find(e[i].b); val[++tot] = e[i].t; bin[u] = bin[v] = tot; G[tot].emplace_back(u); G[u].emplace_back(tot); G[tot].emplace_back(v); G[v].emplace_back(tot); &#125; dfs(tot, 0); for (int i = 1; i &lt;= lg[n * 2]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n * 2 - 1; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1; i &lt;= q; ++i) cin >> Q[i].v >> Q[i].x, Q[i].id = i; for (int i = 1; i &lt;= n; ++i) bin[i] = i, val[i] = a[i], mn[i] = mx[i] = dfn[i]; sort(e + 1, e + n); sort(Q + 1, Q + q + 1); for (int i = 1, j = 0; i &lt;= q; ++i) &#123; while (j &lt; n - 1 &amp;&amp; e[j + 1].c >= Q[i].v) &#123; ++j; int u = find(e[j].a), v = find(e[j].b); if (val[u] == val[v]) mx[v] = max(mx[v], mx[u]); else mx[v] = val[u] > val[v] ? mx[u] : mx[v]; if (val[u] == val[v]) mn[v] = min(mn[v], mn[u]); else mn[v] = val[u] > val[v] ? mn[u] : mn[v]; val[v] = max(val[v], val[u]); bin[u] = v; &#125; int id = Q[i].id, x = Q[i].x, u = find(x); ans1[id] = val[u]; if (idx[mx[u]] != x) ans2[id] = max(ans2[id], val[LCA(x, idx[mx[u]])]); if (idx[mn[u]] != x) ans2[id] = max(ans2[id], val[LCA(x, idx[mn[u]])]); &#125; for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; ans1[i] &lt;&lt; \" \" &lt;&lt; ans2[i] &lt;&lt; \"\\n\"; return 0; &#125; 虚树 这里的不会很难，难的虚树会和别的树上算法综合。 [HEOI2014] 大工程 Portal. 建出虚树后进行 DP，设 szx,mnx,mxxsz_x,mn_x,mx_xszx​,mnx​,mxx​ 分别代表子树内关键点个数，当前节点到关键点的最小和最大距离，用它们更新 ansansans 即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k, q, lg[1000005], p[1000005]; int dep[1000005]; int dfn[1000005], num, mi[20][1000005]; vector&lt;int> G[1000005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; mi[0][dfn[x] = ++num] = fa; dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int st[1000005], tot, ans2, ans3; i64 ans1; int sz[1000005], mx[1000005], mn[1000005]; vector&lt;int> E[1000005]; inline void addedge(int x, int y) &#123; E[x].emplace_back(y); E[y].emplace_back(x); &#125; void dp(int x, int fa) &#123; for (int y : E[x]) if (y != fa) &#123; dp(y, x); int d = dep[y] - dep[x]; ans1 += 1ll * sz[y] * (k - sz[y]) * d; ans2 = min(ans2, mn[x] + mn[y] + d); ans3 = max(ans3, mx[x] + mx[y] + d); mn[x] = min(mn[x], mn[y] + d); mx[x] = max(mx[x], mx[y] + d); sz[x] += sz[y]; &#125; E[x].clear(); &#125; void build_tree(void) &#123; sort(p + 1, p + k + 1, [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;); st[tot = 1] = 1; if (p[1] != 1) sz[1] = 0, mn[1] = 1e9, mx[1] = -1e9; for (int i = 1; i &lt;= k; ++i) if (p[i] != 1) &#123; int lca = LCA(st[tot], p[i]); while (tot > 1 &amp;&amp; dep[lca] &lt;= dep[st[tot - 1]]) addedge(st[tot - 1], st[tot]), --tot; if (lca != st[tot]) &#123; sz[lca] = 0; mn[lca] = 1e9; mx[lca] = -1e9; addedge(lca, st[tot]), st[tot] = lca; &#125; st[++tot] = p[i]; &#125; for (int i = 1; i &lt; tot; ++i) addedge(st[i], st[i + 1]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); scanf(\"%d\", &amp;q); while (q--) &#123; scanf(\"%d\", &amp;k); ans1 = ans3 = 0, ans2 = 1e9; for (int i = 1; i &lt;= k; ++i) scanf(\"%d\", p + i), sz[p[i]] = 1, mn[p[i]] = mx[p[i]] = 0; build_tree(); dp(1, 0); printf(\"%lld %d %d\\n\", ans1, ans2, ans3); &#125; return 0; &#125; [CF613D] Kingdom and its Cities Portal. 首先如果关键点相邻直接无解，否则设计 DP：g(x)g(x)g(x) 为以 xxx 为根，子树内是否有关节点；f(x)f(x)f(x) 为以 xxx 为根的答案。 如果 xxx 是关键点，那么儿子内有关键点的需要全部断掉。若不是关键点，儿子内有超过两个关键点则直接删掉自己（否则就连上了），否则可以留到父亲处再做考虑。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, k, p[100005], lg[100005]; int tot, st[100005], tag[100005], fa[100005]; int dfn[100005], num, mi[17][100005], dep[100005]; vector&lt;int> E[100005], G[100005]; inline void addedge(int x, int y) &#123; G[x].emplace_back(y); G[y].emplace_back(x); &#125; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int ff) &#123; mi[0][dfn[x] = ++num] = ff; fa[x] = ff; dep[x] = dep[ff] + 1; for (int y : E[x]) if (y != ff) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; int f[100005], g[100005]; void build_tree(void) &#123; sort(p + 1, p + k + 1, [](int x, int y)&#123; return dfn[x] &lt; dfn[y]; &#125;); st[tot = 1] = 1; f[1] = g[1] = 0; for (int i = 1; i &lt;= k; ++i) if (p[i] != 1) &#123; int lca = LCA(st[tot], p[i]); while (tot > 1 &amp;&amp; dep[lca] &lt;= dep[st[tot - 1]]) addedge(st[tot - 1], st[tot]), --tot; if (lca != st[tot]) addedge(lca, st[tot]), st[tot] = lca, f[lca] = g[lca] = 0; st[++tot] = p[i]; &#125; for (int i = 1; i &lt; tot; ++i) addedge(st[i], st[i + 1]); &#125; void dp(int x, int fa) &#123; int num = 0; for (int y : G[x]) if (y != fa) &#123; dp(y, x); f[x] += f[y]; num += g[y]; &#125; if (tag[x]) f[x] += num, g[x] = 1; // 将儿子全断掉 else if (num > 1) ++f[x], g[x] = 0; else g[x] = num; G[x].clear(); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); E[u].emplace_back(v); E[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); scanf(\"%d\", &amp;m); while (m--) &#123; scanf(\"%d\", &amp;k); for (int i = 1; i &lt;= k; ++i) scanf(\"%d\", p + i), tag[p[i]] = 1, f[p[i]] = g[p[i]] = 0; for (int i = 1; i &lt;= k; ++i) if (tag[fa[p[i]]]) &#123; puts(\"-1\"); goto over; &#125; build_tree(); dp(1, 0); printf(\"%d\\n\", f[1]); over: for (int i = 1; i &lt;= k; ++i) tag[p[i]] = 0; &#125; return 0; &#125; 树上分治算法 部分题目相当复杂，但是对训练非常有益。 [Luogu P4178] Tree Portal. 似乎使用双指针计算比较难防止算重同一棵子树内的点，于是我们在采集子树信息的时候直接算一遍子树内的贡献，减去它就好了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; typedef pair&lt;int, int> pii; int n, k, root, siz[40005], mx[40005], ans = 0; bool vis[40005]; vector&lt;pii> G[40005]; void froot(int x, int fa, int tot) &#123; siz[x] = 1; mx[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; froot(y, x, tot); siz[x] += siz[y]; mx[x] = max(mx[x], siz[y]); &#125; mx[x] = max(mx[x], tot - siz[x]); if (mx[root] > mx[x]) root = x; &#125; int calc(vector&lt;int> &amp;val) &#123; int res = 0; sort(val.begin(), val.end()); for (int l = 0, r = val.size() - 1; l &lt; r; ++l) &#123; while (l &lt; r &amp;&amp; val[l] + val[r] > k) --r; res += r - l; &#125; return res; &#125; vector&lt;int> val, t; void getinfo(int x, int fa, int anc, int d) &#123; t.push_back(d); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; getinfo(y, x, anc, d + G[x][i].second); &#125; &#125; void divide(int x) &#123; vis[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; t.clear(); getinfo(y, x, y, G[x][i].second); ans -= calc(t); for (int z : t) val.push_back(z); &#125; val.push_back(0); ans += calc(val); val.clear(); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); mx[0] = n + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].push_back(&#123;v, w&#125;); G[v].push_back(&#123;u, w&#125;); &#125; scanf(\"%d\", &amp;k); froot(1, 0, n); divide(root); printf(\"%d\\n\", ans); return 0; &#125; [IOI2011] Race Portal. 由于 kkk 不是很大，开一个桶记录权值对应的最小边数即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> #include &lt;cstring> using namespace std; const int MAXD = 1000005; typedef pair&lt;int, int> pii; int n, k, ans, root; int siz[200005], maxx[200005]; int buc[1000005]; bool vis[200005]; vector&lt;pii> G[200005]; void froot(int x, int fa, int tot) &#123; siz[x] = 1; maxx[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y == fa || vis[y]) continue; froot(y, x, tot); siz[x] += siz[y]; maxx[x] = max(maxx[x], siz[y]); &#125; maxx[x] = max(maxx[x], tot - siz[x]); if (maxx[x] &lt; maxx[root]) root = x; &#125; vector&lt;pii> f[200005]; void getinfo(int x, int fa, int anc, int d, int cnt) &#123; f[anc].emplace_back(make_pair(d, cnt)); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y] || y == fa) continue; getinfo(y, x, anc, min(MAXD, d + G[x][i].second), cnt + 1); &#125; &#125; void divide(int x) &#123; vis[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; getinfo(y, x, y, G[x][i].second, 1); for (pii info : f[y]) &#123; int dis = info.first, w = info.second; if (dis &lt;= k) ans = min(ans, buc[k - dis] + w); &#125; for (pii info : f[y]) &#123; int dis = info.first, w = info.second; if (dis &lt;= k) buc[dis] = min(buc[dis], w); &#125; &#125; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; for (pii info : f[y]) buc[info.first] = 0x3f3f3f3f; f[y].clear(); &#125; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (vis[y]) continue; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); memset(buc, 0x3f, sizeof(buc)); buc[0] = 0; for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); ++u, ++v; G[u].emplace_back(make_pair(v, w)); G[v].emplace_back(make_pair(u, w)); &#125; ans = maxx[0] = n + 1; froot(1, 0, n); divide(root); if (ans == n + 1) puts(\"-1\"); else printf(\"%d\\n\", ans); return 0; &#125; [省选联考 2020 B 卷] 消息传递 Portal. 我们给所有节点开一个 vector 来保存询问，然后对传播路径是否经过当前点 xxx 进行分治。获取子树信息时，我们将当前距离 ddd 加在一个桶中，每扫描到一个节点 iii 都查看当前节点的询问，它应该满足 k≥dk\\ge dk≥d，在获取完所有信息后在桶中查 k−dk-dk−d 的数量来获取答案。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, root, siz[100005], maxx[100005], ans[100005]; bool vis[100005]; vector&lt;int> G[100005]; vector&lt;pair&lt;int, int>> Q[100005]; // x, id void froot(int x, int fa, int tot) &#123; siz[x] = 1; maxx[x] = 0; for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) &#123; froot(y, x, tot); siz[x] += siz[y]; maxx[x] = max(maxx[x], siz[y]); &#125; maxx[x] = max(maxx[x], tot - siz[x]); if (maxx[x] &lt; maxx[root]) root = x; &#125; vector&lt;pair&lt;int, int> > info; int buc[100005], maxd; void getinfo(int x, int fa, int d) &#123; ++buc[d]; maxd = max(d, maxd); for (auto [k, id] : Q[x]) if (k - d >= 0) info.emplace_back(k - d, id); // 找当前这个点的询问 for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) getinfo(y, x, d + 1); &#125; void divide(int x) &#123; vis[x] = true; for (int y : G[x]) if (!vis[y]) &#123; getinfo(y, x, 1); for (auto [k, id] : info) ans[id] -= buc[k]; for (int i = 0; i &lt;= maxd; ++i) buc[i] = 0; maxd = 0; info.clear(); &#125; getinfo(x, 0, 0); for (auto [k, id] : info) ans[id] += buc[k]; for (int i = 0; i &lt;= maxd; ++i) buc[i] = 0; maxd = 0; info.clear(); for (int y : G[x]) if (!vis[y]) &#123; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); maxx[0] = n + 1; for (int i = 1; i &lt;= n; ++i) G[i].clear(), Q[i].clear(), vis[i] = 0; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x, k; scanf(\"%d%d\", &amp;x, &amp;k); Q[x].emplace_back(k, i); ans[i] = 0; &#125; root = 0; froot(1, 0, n); divide(root); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); &#125; return 0; &#125; [SDOI2016] 模式字符串 Portal. 点分治，然后使用字符串 Hash 来判断是否能作为模式串的前后缀，然后用一个桶来统计进行答案合并。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; const int N = 1000000; typedef unsigned long long u64; int n, m, root, ans; char s[1000005], t[1000005]; int maxx[1000005], siz[1000005], buc[1000005]; u64 poww[1000005], pre[1000005], suf[1000005]; bool vis[1000005]; vector&lt;int> G[1000005]; void froot(int x, int fa, int tot) &#123; siz[x] = 1; maxx[x] = 0; for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) &#123; froot(y, x, tot); siz[x] += siz[y]; maxx[x] = max(maxx[x], siz[y]); &#125; maxx[x] = max(maxx[x], tot - siz[x]); if (maxx[x] &lt; maxx[root]) root = x; &#125; int calc(vector&lt;int> &amp;x, vector&lt;int> &amp;y) &#123; int res = 0; for (int it : x) ++buc[1 + (it - 1) % m]; for (int it : y) res += buc[m - (it - 1) % m]; for (int it : x) --buc[1 + (it - 1) % m]; return res; &#125; vector&lt;int> p, q, pt, qt; void getinfo(int x, int fa, u64 hash, int dep) &#123; hash += s[x] * poww[dep - 1]; if (pre[dep] == hash) pt.emplace_back(dep); if (suf[dep] == hash) qt.emplace_back(dep); for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) getinfo(y, x, hash, dep + 1); &#125; void divide(int x) &#123; vis[x] = true; p.clear(); q.clear(); if (s[x] == t[1]) p.emplace_back(1); if (s[x] == t[m]) q.emplace_back(1); for (int y : G[x]) if (!vis[y]) &#123; getinfo(y, x, s[x], 2); ans -= calc(pt, qt); for (int it : pt) p.emplace_back(it); for (int it : qt) q.emplace_back(it); pt.clear(); qt.clear(); &#125; ans += calc(p, q); for (int y : G[x]) if (!vis[y]) &#123; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; void solve(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, s + 1); maxx[0] = n + 1; for (int i = 1; i &lt;= n; ++i) G[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; scanf(\"%s\", t + 1); for (int i = 1; i &lt;= n; ++i) &#123; pre[i] = pre[i - 1] * 239 + t[1 + (i - 1) % m]; suf[i] = suf[i - 1] * 239 + t[m - (i - 1) % m]; &#125; memset(vis, 0, sizeof(vis)); ans = root = 0; froot(1, 0, n); divide(root); printf(\"%d\\n\", ans); &#125; int main(void) &#123; for (int i = poww[0] = 1; i &lt;= N; ++i) poww[i] = poww[i - 1] * 239; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [CF914E] Palindromes in a Tree Portal. 只要出现奇数次的字符最多只有一个，那么就可以重排为回文，可以状压来统计字符的奇偶性。 对回文路径是否经过点 pospospos 进行点分治，获取子树状压的字符信息放在 vector 里，在统计答案时将异或信息放在桶里。点的答案要加上子树的答案，因为子树的回文路径也会经过这个点。 子树的会算重，因此提前减去。分治重心的答案的两个端点在不同子树答案会算重，因此除以二。分治重心自己也可以称为答案，要加一。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, root, mx[200005], siz[200005]; i64 ans[200005], d[200005]; char s[200005]; bool vis[200005]; vector&lt;int> G[200005]; void froot(int x, int fa, int tot) &#123; mx[x] = 0; siz[x] = 1; for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) &#123; froot(y, x, tot); siz[x] += siz[y]; mx[x] = max(mx[x], siz[y]); &#125; mx[x] = max(mx[x], tot - siz[x]); if (mx[x] &lt; mx[root]) root = x; &#125; int buc[1 &lt;&lt; 20]; void calc(vector&lt;pair&lt;int, int>> &amp;a, int flag, int msk) &#123; for (auto it : a) buc[it.first] += flag; for (auto [x, pos] : a) &#123; int cnt = buc[x ^ msk]; // 排掉分治中心统计另一端 for (int i = 0; i &lt; 20; ++i) cnt += buc[x ^ msk ^ (1 &lt;&lt; i)]; d[pos] += cnt; &#125; for (auto it : a) buc[it.first] = 0; &#125; vector&lt;pair&lt;int, int>> info, q; void getinfo(int x, int fa, int msk) &#123; d[x] = 0; msk ^= 1 &lt;&lt; s[x]; q.emplace_back(msk, x); for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) getinfo(y, x, msk); &#125; void getans(int x, int fa) &#123; for (int y : G[x]) if (y != fa &amp;&amp; !vis[y]) &#123; getans(y, x); d[x] += d[y]; &#125; if (!fa) d[x] = d[x] / 2 + 1; ans[x] += d[x]; &#125; void divide(int x) &#123; vis[x] = 1; d[x] = 0; int msk = 1 &lt;&lt; s[x]; for (int y : G[x]) if (!vis[y]) &#123; getinfo(y, x, msk); calc(q, -1, msk); for (auto tmp : q) info.emplace_back(tmp); q.clear(); &#125; info.emplace_back(msk, x); calc(info, 1, msk); info.clear(); getans(x, 0); for (int y : G[x]) if (!vis[y]) &#123; root = 0; froot(y, x, siz[y]); divide(root); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); mx[0] = n + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; scanf(\"%s\", s + 1); for (int i = 1; i &lt;= n; ++i) s[i] -= 'a'; froot(1, 0, n); divide(root); for (int i = 1; i &lt;= n; ++i) printf(\"%lld \", ans[i]); putchar('\\n'); return 0; &#125; 复杂树上乱搞 非常奇怪，但很有趣。 在思考这些内容时，请回顾树上问题的常见处理手段： [CF1580D] Subsequence Portal. 先来看一下要求的这个东西： 原式=∑i=1m(m⋅abi)−∑i=1m∑j=1mf(min⁡(bi,bj),max⁡(bi,bj))=(m−1)∑i=1mabi−2∑i=1m∑j=i+1mmin⁡{abi,abi+1⋯ ,abj−1,abj}\\begin{aligned} \\text{原式}&amp;=\\sum_{i = 1}^m (m \\cdot a_{b_i}) - \\sum_{i = 1}^m \\sum_{j = 1}^m f(\\min(b_i, b_j), \\max(b_i, b_j))\\\\ &amp;=(m-1)\\sum_{i = 1}^m a_{b_i}-2\\sum_{i=1}^m\\sum_{j=i+1}^m \\min\\{a_{b_i},a_{b_i+1}\\cdots,a_{b_j-1},a_{b_j}\\} \\end{aligned} 原式​=i=1∑m​(m⋅abi​​)−i=1∑m​j=1∑m​f(min(bi​,bj​),max(bi​,bj​))=(m−1)i=1∑m​abi​​−2i=1∑m​j=i+1∑m​min{abi​​,abi​+1​⋯,abj​−1​,abj​​}​ 要求这个东西的最大值，后面这个区间最小值可以考虑放到笛卡尔树上，然后用树形 DP 求解这个问题。 设 fx,kf_{x,k}fx,k​ 代表 xxx 中选择 kkk 个节点的最大价值，初始 fi,1=(m−1)aif_{i,1}=(m-1)a_ifi,1​=(m−1)ai​，然后转移是一个类似树形背包的过程： fx,i+j=max⁡{fx,i+fy,j−2×ax×i×j}f_{x,i+j}=\\max\\{f_{x,i}+f_{y,j}-2\\times a_x\\times i\\times j\\} fx,i+j​=max{fx,i​+fy,j​−2×ax​×i×j} 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; inline void ckmax(i64 &amp;x, i64 t) &#123; if (x &lt; t) x = t; &#125; int n, m, rt; int a[4005], ls[4005], rs[4005], st[4005], siz[4005]; i64 f[4005][4005]; bool v[4005]; void dfs(int x) &#123; f[x][1] = 1ll * (m - 1) * a[x]; siz[x] = 1; function&lt;void(int)> work = [&amp;] (int y) &#123; dfs(y); for (int i = siz[x]; i >= 0; --i) for (int j = 0; j &lt;= siz[y]; ++j) ckmax(f[x][i + j], f[x][i] + f[y][j] - 2ll * a[x] * i * j); siz[x] += siz[y]; &#125;; if (ls[x]) work(ls[x]); if (rs[x]) work(rs[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, cur = 0, tot = 0; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); cur = tot; while (cur &amp;&amp; a[st[cur]] > a[i]) --cur; if (cur) rs[st[cur]] = i; if (cur &lt; tot) ls[i] = st[cur + 1]; st[++cur] = i; tot = cur; &#125; for (int i = 1; i &lt;= n; ++i) v[ls[i]] = v[rs[i]] = 1; for (int i = 1; i &lt;= n; ++i) if (!v[i]) dfs(i), printf(\"%lld\\n\", f[i][m]); return 0; &#125; [CF983E] NN country Portal. 考虑在链上怎么做。贪心的乘坐能到达的最远的车，并使用倍增加速。放到树上就是预处理出数组 gi,jg_{i,j}gi,j​ 表示乘坐 i+1i+1i+1 次车，从 jjj 能到达的最浅节点。 特判掉 u,vu,vu,v 其中一个是另一个的祖先的情况，我们让 u,vu,vu,v 分别乘坐到它们 LCA 的底下，然后再乘坐两次车就可以到了。但是如果有一辆车可以直接从一个子树到另一个子树，那么可以选择乘坐它。这样就成了一个二维数点问题，判断两棵子树内是否有相同的公交车，DFS 序加主席树即可在线维护。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, q, lg[200005], dep[200005], g[18][200005]; int f[200005], mi[18][200005], dfn[200005], num, L[200005], R[200005]; vector&lt;int> G[200005], bus[200005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; mi[0][dfn[x] = L[x] = ++num] = fa; dep[x] = dep[fa] + 1; for (int y : G[x]) dfs(y, x); R[x] = num; &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; struct Node &#123; int ls, rs; int val; &#125; T[40 * 200005]; int root[200005], tot; int build(int l, int r) &#123; int o = ++tot; if (l == r) return o; int mid = l + r >> 1; T[o].ls = build(l, mid); T[o].rs = build(mid + 1, r); return o; &#125; int update(int pre, int l, int r, int x) &#123; int o = ++tot; T[tot] = T[pre]; T[tot].val++; if (l == r) return o; int mid = l + r >> 1; if (x &lt;= mid) T[o].ls = update(T[pre].ls, l, mid, x); else T[o].rs = update(T[pre].rs, mid + 1, r, x); return o; &#125; int query(int o, int l, int r, int x, int y) &#123; if (!o) return 0; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].val; int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(T[o].ls, l, mid, x, y); if (mid &lt; y) res += query(T[o].rs, mid + 1, r, x, y); return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i); G[f[i]].emplace_back(i); lg[i] = lg[i >> 1] + 1; &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= n; ++i) g[0][i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); int l = LCA(x, y); g[0][x] = min(g[0][x], l); g[0][y] = min(g[0][y], l); bus[dfn[x]].emplace_back(dfn[y]); bus[dfn[y]].emplace_back(dfn[x]); &#125; for (int i = n; i >= 1; --i) g[0][f[i]] = min(g[0][f[i]], g[0][i]); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j &lt;= n; ++j) g[i][j] = g[i - 1][g[i - 1][j]]; root[0] = build(1, n); for (int i = 1; i &lt;= n; ++i) &#123; root[i] = root[i - 1]; for (int k : bus[i]) root[i] = update(root[i], 1, n, k); &#125; scanf(\"%d\", &amp;q); while (q--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (u == v) &#123; puts(\"0\"); continue; &#125; int l = LCA(u, v); if (g[lg[n]][u] > l || g[lg[n]][v] > l) &#123; puts(\"-1\"); continue; &#125; // 跳不到 LCA 上，无答案 int ans = 2; for (int i = lg[n]; i >= 0; --i) if (g[i][u] > l) u = g[i][u], ans += 1 &lt;&lt; i; for (int i = lg[n]; i >= 0; --i) if (g[i][v] > l) v = g[i][v], ans += 1 &lt;&lt; i; if (u == l || v == l) --ans; else ans -= (query(root[R[u]], 1, n, L[v], R[v]) - query(root[L[u] - 1], 1, n, L[v], R[v])) > 0; printf(\"%d\\n\", ans); &#125; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"省选优化技巧","slug":"notes/杂项/sx-tricks","date":"2022-12-12T00:00:00.000Z","updated":"2022-12-12T00:00:00.000Z","comments":true,"path":"75dc3e62/","link":"","permalink":"https://james1badcreeper.github.io/75dc3e62/","excerpt":"省选同样有很多杂项算法，当中不乏一些非常实用的小技巧。","text":"省选同样有很多杂项算法，当中不乏一些非常实用的小技巧。 更新日志 2023/10/16完成重构。2023/4/16开始重构文章，整理了构成和需要写的部分。 实际上都是必备技能。 log 优化技巧 多种方式可以得到 log⁡\\loglog 级别的优化，但是当中有一些别的。 基于二分的优化 二分是对单调性的利用，只要有单调性都可以试试二分！ 三分法 现在有一个函数，它是一个单峰或者单谷函数，要求出它的极值。 传统的二分法似乎并不好做，找到 mid 之后，无法确定极值在那一边。我们可以使用三分法：在 l,rl,rl,r 内任取两点 lmid,rmidlmid,rmidlmid,rmid，如果 f(lmid)&lt;f(rmid)f(lmid)&lt;f(rmid)f(lmid)&lt;f(rmid)，则函数在 [rmid,r][rmid,r][rmid,r] 中必然单调递增或者单调递减（画个图，然后分类讨论，看 lmid,rmidlmid,rmidlmid,rmid 是否分布在极值点两侧，就知道了），反之同理。那么这样就可以分出极值。 模板，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const double eps = 1e-7; int n; double l, r, a[20]; double f(double x) &#123; double ans = 0, b = 1; for (int i = n; i >= 0; --i, b *= x) ans += a[i] * b; return ans; &#125; int main(void) &#123; scanf(\"%d%lf%lf\", &amp;n, &amp;l, &amp;r); for (int i = 0; i &lt;= n; ++i) scanf(\"%lf\", a + i); while (l + eps &lt; r) &#123; double lmid = (l + r) / 2, rmid = (mid + r) / 2; if (f(lmid) > f(rmid)) r = mid; else l = mid; &#125; printf(\"%.5lf\\n\", l); return 0; &#125; 分数规划 分数规划，一般指 01 分数规划，用来求一个分式的极值，也就求一组 wi={0,1}w_i=\\{0,1\\}wi​={0,1}，最大化或者最小化： ∑ai×wi∑bi×wi\\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i} ∑bi​×wi​∑ai​×wi​​ 有的时候题目还有一些限制，比如分母至少为 WWW，恰好有 kkk 个 wiw_iwi​ 是 111。 我们一般使用二分答案来解决这个问题。以最大值为例： ∑ai×wi∑bi×wi&gt;mid⟹∑ai×wi−mid×∑bi×wi&gt;0⟹∑wi(ai−mid×bi)&gt;0\\begin{aligned} &amp;\\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i}&gt;mid\\\\ \\Longrightarrow&amp; \\sum a_i\\times w_i - mid\\times \\sum b_i\\times w_i &gt; 0\\\\ \\Longrightarrow&amp; \\sum w_i(a_i-mid\\times b_i)&gt;0 \\end{aligned} ⟹⟹​∑bi​×wi​∑ai​×wi​​&gt;mid∑ai​×wi​−mid×∑bi​×wi​&gt;0∑wi​(ai​−mid×bi​)&gt;0​ 我们使用贪心的方式就可以求出左边的最大值。 模板，要求恰好 kkk 个 111。那么排序即可。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; const double eps = 1e-6; int n, k; double t[100005]; int a[100005], b[100005]; bool check(double x) &#123; for (int i = 1; i &lt;= n; ++i) t[i] = a[i] - x * b[i]; sort(t + 1, t + n + 1); double ans = 0; for (int i = n - k + 1; i &lt;= n; ++i) ans += t[i]; return ans > 0; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i); double l = 0, r = 1e18; while (l + eps &lt; r) &#123; double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; &#125; printf(\"%.4lf\\n\", r); return 0; &#125; 基于二分单调性的优化 将会在《DP 优化》中出现。 倍增 倍增和二分都需要具有单调性，但是倍增能够解决一些二分不能解决的问题，就像二分出 mid 之后发现 mid 无法简单 check，但是倍增却可以方便的合并信息。 倍增答案 二分答案？倍增答案！二分答案要求答案是具有单调性的，但是倍增同样可以做到！ 二分上界不确定的内容的最佳方式是倍增。初始时使用倍增求出上界；求解时，类似于倍增 LCA 的方式，从上界开始，合法的最小值就是不合法的最大值 +1，那么我们从二进制位高到低枚举，如果加上这么多还不满足就一定跳! // 使用类似于下面的方式求解上界 int st = query(); // 初始边界值 int pw = 0; while (1) &#123; if (query(r + (1ll &lt;&lt; pw)) != st) break; r += 1ll &lt;&lt; pw; ++pw; &#125; // 使用类似于下面的方式求解答案 int ans = 0; for (int i = 30; i >= 0; --i) if (!check(ans | (1 &lt;&lt; i))) ans |= (1 &lt;&lt; i); ans += 1; 倍增优化 DP 这是倍增的一个重要应用，就是利用 DP 转移状态的单调性来设计一个形如 f(i,j)f(i,j)f(i,j)，其中 jjj 代表长度为 2j2^j2j 的段。 分治 普及组算法的复仇。 我们知道分治是将复杂的问题拆成多个（一般是两个）相似的子问题，直到最后分成的子问题可以简单求解，然后通过子问题的答案合并出大问题的答案。 我知道你早就知道了上面说的，所以我们还是来看点有意思的吧（在这里没出现的分治均在其它文章里出现）。 普通分治 就是正常分治，我们来看一道题： [Luogu P7883] 平面最近点对（加强加强版）。求一个平面上最近的点对，点数在 4×1054\\times 10^54×105 级别。 先将所有点按照 xxx 坐标排序，然后开始分治。关键在于如何合并：如果一个点满足 ∣x[mid]−x[i]∣&lt;d|x[mid]-x[i]|&lt;d∣x[mid]−x[i]∣&lt;d，其中 ddd 代表左右两边答案的最小值，那么我们称点 iii 是合法的。然后将这些合法的点再按照 yyy 坐标排序，再进行枚举，yyy 坐标距离大于 ddd 就 break 掉。 这样可以保证合并的时间复杂度是 O(n)O(n)O(n) 的（需要采用归并排序），具体证明需要通过一些几何的方式，不打算研究。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 1e15; int n; struct Point &#123; int x, y; bool operator &lt; (const Point &amp;a) const &#123; if (x == a.x) return y &lt; a.y; return x &lt; a.x; &#125; &#125; a[400005]; i64 dist(int i, int j) &#123; i64 x = 1ll * (a[i].x - a[j].x) * (a[i].x - a[j].x); i64 y = 1ll * (a[i].y - a[j].y) * (a[i].y - a[j].y); return x + y; &#125; bool cmp(const int &amp;x, const int &amp;y) &#123; return a[x].y &lt; a[y].y; &#125; int g[400005]; i64 merge(int l, int r) &#123; if (l == r) return INF; if (l + 1 == r) return dist(l, r); int mid = l + r >> 1; i64 d1 = merge(l, mid), d2 = merge(mid + 1, r); i64 d = min(d1, d2); int tot = 0; for (int i = l; i &lt;= r; ++i) &#123; i64 k = abs(a[mid].x - a[i].x); if (k &lt; INF &amp;&amp; k * k &lt; d) g[++tot] = i; &#125; sort(g + 1, g + tot + 1, cmp); for (int i = 1; i &lt; tot; ++i) for (int j = i + 1; j &lt;= tot &amp;&amp; 1ll * (a[g[j]].y - a[g[i]].y) * (a[g[j]].y - a[g[i]].y) &lt; d; ++j) d = min(d, dist(g[i], g[j])); return d; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); sort(a + 1, a + n + 1); printf(\"%lld\\n\", merge(1, n)); return 0; &#125; 二维分治 其实就是对两个东西进行分治，每次将其中一个东西切半（为了保证效率，一般选择其中区间更长的一个切半），然后合并答案。 [CF364E] Empty Rectangles.给定一个 n×m(1≤n,m≤2.5×103)n\\times m(1\\le n, m\\le 2.5\\times 10^3)n×m(1≤n,m≤2.5×103) 的 01 矩阵，询问有多少个子矩阵满足只有 k(1≤k≤6)k(1\\le k\\le 6)k(1≤k≤6) 个 1。 本题要求恰好有 kkk 个 1 的子矩形数量，我们将当前矩形劈成两半（以劈成左一半和右一半为例），那么符合条件的子矩形要么在左半，要么在右半，要么跨越中线。 考虑跨越中线的如何合并。我们枚举子矩形的上下边界，然后开个桶 ppp 统计左半矩形所含 111 数量小于 iii 时左边界的最小值（右半矩形同理），然后直接枚举左半边的 111 的个数就可以统计了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, K; i64 ans = 0; int s[2505][2505], p[10], q[10]; int F(int x1, int y1, int x2, int y2) &#123; if (x1 > x2 || y1 > y2) return 0; return s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]; &#125; void divide(int xl, int yl, int xr, int yr) &#123; if (xl > xr || yl > yr) return; if (xl == xr &amp;&amp; yl == yr) &#123; ans += (F(xl, yl, xr, yr) == K); return; &#125; int d = (xr - xl > yr - yl); if (d) &#123; int mid = xl + xr >> 1; divide(xl, yl, mid, yr); divide(mid + 1, yl, xr, yr); for (int i = yl; i &lt;= yr; ++i) &#123; p[0] = mid + 1; q[0] = mid; for (int k = 1; k &lt;= K + 1; ++k) p[k] = xl, q[k] = xr; for (int j = i; j &lt;= yr; ++j) &#123; for (int k = 1; k &lt;= K + 1; ++k) &#123; while (F(p[k], i, mid, j) >= k) ++p[k]; while (F(mid + 1, i, q[k], j) >= k) --q[k]; &#125; for (int k = 0; k &lt;= K; ++k) ans += (p[k] - p[k + 1]) * (q[K - k + 1] - q[K - k]); &#125; &#125; &#125; else &#123; int mid = yl + yr >> 1; divide(xl, yl, xr, mid); divide(xl, mid + 1, xr, yr); for (int i = xl; i &lt;= xr; ++i) &#123; p[0] = mid + 1; q[0] = mid; for (int k = 1; k &lt;= K + 1; ++k) p[k] = yl, q[k] = yr; for (int j = i; j &lt;= xr; ++j) &#123; for (int k = 1; k &lt;= K + 1; ++k) &#123; while (F(i, p[k], j, mid) >= k) ++p[k]; while (F(i, mid + 1, j, q[k]) >= k) --q[k]; &#125; for (int k = 0; k &lt;= K; ++k) ans += (p[k] - p[k + 1]) * (q[K - k + 1] - q[K - k]); &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;K); for (int i = 1; i &lt;= n; ++i) &#123; char t[2505]; scanf(\"%s\", t + 1); for (int j = 1; j &lt;= m; ++j) s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + (t[j] - '0'); &#125; divide(1, 1, n, m); printf(\"%lld\\n\", ans); return 0; &#125; CDQ 分治 记得归并排序吗？我们要求计算分治中心左右两边部分的信息合并，这部分求值的先后顺序没有要求。这样信息可能可以简单地合并以得到一个分治做法。这种做法用来对时间维度进行降维（就是去掉一个偏序限制），也可以处理带有时间限制的问题（限定合并方向）。这种操作被称为 CDQ 分治。 三维偏序问题。给定 nnn 个三维空间上的点，设 f(i)f(i)f(i) 表示满足 xj≤xi,yj≤yi,zj≤zix_j\\le x_i,y_j\\le y_i,z_j\\le z_ixj​≤xi​,yj​≤yi​,zj​≤zi​ 的 jjj 的数量，求满足 f(i)=df(i)=df(i)=d 的 iii 的数量，要求对所有 ddd 给出相应的答案。 解决这类问题的流程如下： 找到这个序列的中点 midmidmid； 将所有点对 (i,j)(i,j)(i,j) 划分为三类： 1≤i,j≤mid1\\le i,j\\le mid1≤i,j≤mid， 1≤i≤mid,mid+1≤j≤n1\\le i\\le mid,mid+1\\le j\\le n1≤i≤mid,mid+1≤j≤n， mid+1≤i,j≤nmid+1\\le i,j\\le nmid+1≤i,j≤n。 拆成左右两半的子序列，然后递归求解； 设法处理第二种点对。 也就是说，CDQ 分治就是不断把点对通过递归的方式分给左右两个区间。现在我们来看如何解决三维偏序问题： 分别处理三个信息。第一维可以将原数组按照 xxx 排序，xi≤xjx_i\\le x_jxi​≤xj​ 转化为 i&lt;ji&lt;ji&lt;j。注意此时如果数都相同会出问题，因此去个重。 第二维可以在分治时采用类似于归并排序的方式解决（求正序对），不过由于第三维的限制，并不是所有的信息都可以加到答案里的，需要整一个权值树状数组来处理第三维的信息：左半段序列的信息加入树状数组，右半段信息进行统计。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, k; struct Node &#123; int a, b, c, cnt, ans; bool operator&lt; (const Node &amp;a) const &#123; if (this->a != a.a) return this->a &lt; a.a; if (b != a.b) return b &lt; a.b; return c &lt; a.c; &#125; &#125; a[100005], T[100005]; int ans[100005]; int C[200005]; void add(int x, int t) &#123; for (; x &lt;= k; x += x &amp; -x) C[x] += t; &#125; int sum(int x) &#123; int s = 0; for (; x; x -= x &amp; -x) s += C[x]; return s; &#125; void CDQ(int l, int r) &#123; if (l == r) return a[l].ans += a[l].cnt - 1, void(); int mid = l + r >> 1; CDQ(l, mid); CDQ(mid + 1, r); int p = l, q = mid + 1; for (int i = l; i &lt;= r; ++i) &#123; if (p &lt;= mid &amp;&amp; (q > r || a[p].b &lt;= a[q].b)) add(a[p].c, a[p].cnt), T[i] = a[p++]; else a[q].ans += sum(a[q].c), T[i] = a[q++]; &#125; for (int i = l; i &lt;= mid; ++i) add(a[i].c, -a[i].cnt); for (int i = l; i &lt;= r; ++i) a[i] = T[i]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d%d\", &amp;a[i].a, &amp;a[i].b, &amp;a[i].c), a[i].cnt = 1; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) if (a[i].a != a[m].a || a[i].b != a[m].b || a[i].c != a[m].c) a[++m] = a[i]; else ++a[m].cnt; CDQ(1, m); for (int i = 1; i &lt;= m; ++i) ans[a[i].ans] += a[i].cnt; for (int i = 0; i &lt; n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; 整体操作上来讲，CDQ 分治的过程与归并排序基本无异。 CDQ 分治在其它地方的应用都是将各类信息转化为偏序关系然后求解，具体可以见 Problemset。 整体二分 如果分治中遵循先递归左子树，再递归右子树的法则，那么维护一个指针去“跟踪”分治中心，这个指针的移动距离是 O(nlog⁡n)O(n\\log n)O(nlogn) 的。 很多题目都可以使用二分来解决，但是它们只有一组询问。如果有多组询问怎么办？整体二分！又称基于值域的分治算法。 记 [l,r][l,r][l,r] 为答案的值域，[L,R][L,R][L,R] 为答案的定义域（人话：考虑下标在区间 [L,R][L,R][L,R] 内的操作和询问，询问的答案在 [l,r][l,r][l,r] 内）。 我们把所有操作按照时间顺序存入数组中，然后开始分治，并利用合适的数据结构（Fenwick 树最为常用）统计当前查询的答案和分治中心 midmidmid 之间的关系，根据查询出来的结果将序列按照分成两份递归处理，最后只有一个点就找到了答案。 你确定这是人话？！嗯，确实不是。 那么我们使用题目来讲人话： 静态区间 kkk 小问题。静态区间 kkk 小，但是空间限制 10MB。想写主席树和树套树的人洗洗睡吧 我们考虑使用整体二分解决这个题目。先想一想，正常用二分解决全局 kkk 小问题怎么做？我们先将数组排序，然后再二分。而多次询问的话，就猜测当前的答案是 midmidmid，依次验证每个询问的答案应该是小于等于 midmidmid 还是大于 midmidmid，根据此将询问划分成两个部分。注意，如果一个询问的答案是大于 midmidmid，那么需要更新它的 kkk：减去在值域 [l,mid][l,mid][l,mid] 上比它小的数。理由很简单，接下来对右半段询问时不会再考虑之前在左半段比它小的，需要提前把这些减去。 还有一点，不要真的去二分值域，将原数组排序后二分答案的位置。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; typedef pair&lt;int, int> pii; int n, m, C[200005], id[200005]; struct Query &#123; int l, r, k; &#125; Q[200005]; struct Number &#123; int x, id; bool operator &lt; (const Number &amp;a) const &#123; return x &lt; a.x; &#125; &#125; a[200005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int sum(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int ans[200005], t1[200005], t2[200005], cur[200005]; void solve(int l, int r, int ql, int qr) &#123; // 值域 [l, r]，询问区间 [ql, qr] if (ql > qr) return; // 没有操作，再见 if (l == r) &#123; for (int i = ql; i &lt;= qr; ++i) ans[id[i]] = a[l].x; return; &#125; int mid = l + r >> 1; for (int i = l; i &lt;= mid; ++i) add(a[i].id, 1); // 将值域的前一半加上 1 int p = 0, q = 0; for (int i = ql; i &lt;= qr; ++i) &#123; int u = id[i]; int s = sum(Q[u].r) - sum(Q[u].l - 1); // 在区间内比小于等于 mid 的数 if (s >= Q[u].k) t1[++p] = u; // 在 [l, mid] 中比它小的数大于其排名，答案应在 [l, mid] else t2[++q] = u, Q[u].k -= s; &#125; int tot = ql - 1; for (int i = 1; i &lt;= p; ++i) id[++tot] = t1[i]; for (int i = 1; i &lt;= q; ++i) id[++tot] = t2[i]; for (int i = l; i &lt;= mid; ++i) add(a[i].id, -1); // 撤销修改操作 solve(l, mid, ql, ql + p - 1); // 前 p 个询问的答案在 [l, mid] solve(mid + 1, r, ql + p, qr); // 剩下的在 [mid+1, r] &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i].x), a[i].id = i; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;Q[i].l, &amp;Q[i].r, &amp;Q[i].k), id[i] = i; solve(1, n, 1, m); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; 整体二分还可以用来解决具有单调性的 DP 转移问题： [CF868F] Yet Another Minimization Problem.题目描述：给定一个序列 aaa，要把它分成 kkk 个子段。每个子段的费用是其中相同元素的对数。求所有子段的费用之和的最小值。2≤n≤1052 \\leq n \\leq 10^52≤n≤105，2≤k≤min⁡(n,20)2 \\leq k \\leq \\min(n,20)2≤k≤min(n,20)，1≤ai≤n1 \\leq a_i \\leq n1≤ai​≤n 。 最暴力的做法是设将序列前 iii 个数划分为 jjj 段的最小费用为 fi,jf_{i,j}fi,j​，转移为 fi,j=min⁡{fx,j−1+wx+1,i}f_{i,j}=\\min\\{f_{x,j-1}+w_{x+1,i}\\}fi,j​=min{fx,j−1​+wx+1,i​}。 这个转移是具有单调性的，也就是说如果 j1=j2,i1&lt;i2j_1=j_2,i_1&lt;i_2j1​=j2​,i1​&lt;i2​，那么转移过来的地方一定满足 x1≤x2x_1\\le x_2x1​≤x2​。 证明 假定 x1&gt;x2x_1&gt;x_2x1​&gt;x2​，那么有 fx1,j−1+wx1+1,i1≤fx2,j−1+wx2+1,i1,fx2,j−1+wx2+1,i2≤fx1,j−1+wx1+1,i2f_{x_1,j-1}+w_{x_1+1, i_1}\\le f_{x2,j-1}+w_{x_2+1, i_1},f_{x_2,j-1}+w_{x_2+1,i_2}\\le f_{x_1,j-1}+w_{x_1+1,i_2}fx1​,j−1​+wx1​+1,i1​​≤fx2,j−1​+wx2​+1,i1​​,fx2​,j−1​+wx2​+1,i2​​≤fx1​,j−1​+wx1​+1,i2​​。当两个等号同时成立时，令 x2≥x1x_2\\ge x_1x2​≥x1​ 一定能取到一个最优解。否则可以得到 wx2+1,i1−wx1+1,i1&gt;wx2+1,i2−wx1+1,i2w_{x_2+1,i_1}-w_{x_1+1,i_1} &gt; w_{x_2+1,i_2} - w_{x_1+1,i_2}wx2​+1,i1​​−wx1​+1,i1​​&gt;wx2​+1,i2​​−wx1​+1,i2​​，由于i2&gt;i1i_2&gt;i_1i2​&gt;i1​，这个东西显然是不成立的。 这个 DP 我们可以看作是做 kkk 轮。我们可以采用整体二分的思想，求解的询问是当前这一轮 DP 数组的值，每一次分治我们要求解 midmidmid 的答案，找到其转移点作为单调性的分界点。 时间复杂度 O(knlog⁡n)O(kn\\log n)O(knlogn)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 1e12; int n, k, m; int a[100005], cnt[100005], L = 1, R; i64 f[22][100005], sum; i64 calc(int cl, int cr) &#123; for (; L > cl; --L) sum += cnt[a[L - 1]], ++cnt[a[L - 1]]; for (; R &lt; cr; ++R) sum += cnt[a[R + 1]], ++cnt[a[R + 1]]; for (; L &lt; cl; ++L) --cnt[a[L]], sum -= cnt[a[L]]; for (; R > cr; --R) --cnt[a[R]], sum -= cnt[a[R]]; return sum; &#125; void divide(int ql, int qr, int l, int r) &#123; // 求 [ql, qr] 的 DP 值，最优决策点在 [l, r] if (l > r) return; int mid = ql + qr >> 1, pos; i64 minn = INF; for (int i = l; i &lt;= min(mid, r); ++i) &#123; // 最大只能到 mid i64 val = f[k - 1][i - 1] + calc(i, mid); if (val &lt; minn) minn = val, pos = i; &#125; f[k][mid] = minn; if (ql == qr) return; divide(ql, mid, l, pos); divide(mid + 1, qr, pos, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); f[0][0] = 0; for (int i = 1; i &lt;= n; ++i) f[0][i] = INF; for (k = 1; k &lt;= m; ++k) divide(1, n, 1, n); printf(\"%lld\\n\", f[m][n]); return 0; &#125; 实际上这一类问题的共同特征是转移点单调，所以维护指针来跟踪分治重心，时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 线段树分治 其实之前就见过线段树分治：数学计算。我们基于时间用线段树进行操作。基于时间？这不就是 CDQ 分治吗？ 实际上线段树分治就是一种维护时间区间的数据结构，而且这玩意是可以在线的（只需要每次都查询一下即可，虽然这样可能很慢）！而且还可以支持撤销操作！这是普通 CDQ 达不到的高度！ [CF601E] A Museum Robbery.维护一个固定体积的 01 背包，支持添加、删除物品和查询答案。 背包添加物品好做删除不好做。建立一棵基于询问时间的线段树，统计每一个物品的有效期并在线段树上区间修改添加物品，最后统一查询计算一遍即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int B = 10000019; const int M = 1000000007; int n, k, m, tot = 0, tt = 1, tmp[1005]; struct item &#123; int l, r, v, w; &#125; E[15005]; vector&lt;item> T[120005]; void update(int o, int l, int r, int x, int y, int val) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].emplace_back(E[val]), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, val); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, val); &#125; void solve(int o, int l, int r, int *f) &#123; int g[1005]; memcpy(g, f, sizeof(g)); for (item x : T[o]) for (int j = k; j >= x.v; --j) g[j] = max(g[j], g[j - x.v] + x.w); if (l == r) &#123; int res = 0; for (int i = k; i >= 1; --i) res = (1ll * res * B + g[i]) % M; return printf(\"%d\\n\", res), void(); &#125; int mid = l + r >> 1; solve(o &lt;&lt; 1, l, mid, g); solve(o &lt;&lt; 1 | 1, mid + 1, r, g); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; int v, w; scanf(\"%d%d\", &amp;w, &amp;v); E[++tot] = &#123;tt, -1, v, w&#125;; &#125; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int op; scanf(\"%d\", &amp;op); if (op == 1) &#123; int v, w; scanf(\"%d%d\", &amp;w, &amp;v); E[++tot] = &#123;tt, -1, v, w&#125;; &#125; else if (op == 2) &#123; int x; scanf(\"%d\", &amp;x); E[x].r = tt - 1; &#125; else ++tt; &#125; --tt; for (int i = 1; i &lt;= tot; ++i) &#123; if (E[i].r == -1) E[i].r = tt; if (E[i].l &lt;= E[i].r) update(1, 1, tt, E[i].l, E[i].r, i); &#125; solve(1, 1, tt, tmp); return 0; &#125; 树分治 参考《树形问题进阶》。 经典问题 这里记录了一些经典问题，但是往往遇到时又不知该如何处理。 随机化算法 有的时候不知道怎么做？或者遇到神秘的提交答案题（有些提交答案是不可做优化题）？可以考虑使用随机化。 随机化有两种，一种是操作次数一定，正确性与进行的轮数有关（模拟退火等）；另一种是期望操作次数，要求数据随机（除非你的方法很神秘，出题人没想到，但是如果交互库是自适应的就没辙了）。 随机化函数 mt19937 Rnd(time(0)); int rndint(int l, int r) &#123; return uniform_int_distribution&lt;>(l, r)(Rnd); &#125; double rnddb(int l, int r) &#123; return uniform_real_distribution&lt;>(l, r)(Rnd); &#125; 爬山法 对于单峰函数，三分可能很难实现，那么可以考虑使用爬山。如果当目前无法直接到达最优解，但是可以判断两个解哪个更优的时候，根据一些反馈信息生成一个新的可能解。 [JSOI2008] 球形空间产生器。给出 nnn 维空间的 n+1n+1n+1 个点，求出球心（保证存在）。 对于每一个维度都是单峰函数，因此可以采用爬山法。 假定球心为所有点的重心，然后求出所有点到球心距离的平均值，然后可以计算每个维度上球心距离的改变值（到某个点的距离与平均距离差 ×\\times× 差距贡献）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; double dis[15]; // 答案到点的距离 double ans[15], cans[15], a[15][15]; void check(void) &#123; double tot = 0; for (int i = 1; i &lt;= n + 1; ++i) &#123; dis[i] = cans[i] = 0; for (int j = 1; j &lt;= n; ++j) dis[i] += (a[i][j] - ans[j]) * (a[i][j] - ans[j]); tot += (dis[i] = sqrt(dis[i])) / (n + 1); &#125; for (int i = 1; i &lt;= n + 1; ++i) for (int j = 1; j &lt;= n; ++j) cans[j] += (dis[i] - tot) / tot * (a[i][j] - ans[j]); // dis[i] - tot 为当前点与原球心的距离差与平均距离的差，除以 tot 以计算这一维度对平均距离的贡献占比 // a[i][j] - ans[j] 为在当前维度的当前点与原球心距离差，根据此值进行移动 &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n + 1; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%lf\", &amp;a[i][j]), ans[j] += a[i][j]; for (int i = 1; i &lt;= n; ++i) ans[i] /= (n + 1); // 放到重心 for (double T = 20000; T > 1e-4; T *= 0.99996) &#123; check(); for (int i = 1; i &lt;= n; ++i) ans[i] += cans[i] * T; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%.3lf \", ans[i]); return putchar('\\n'), 0; &#125; 模拟退火 [JSOI2004] 平衡点。 给出模拟退火的一般实现方式：新的答案选择要为随机整数乘上当前的温度，然后以 eΔ/Te^{\\Delta / T}eΔ/T 的概率接受当前非最优解（保证 Δ\\DeltaΔ 为正，大于 rnd(0, 1) 接受，小于不接受）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int x[1005], y[1005], w[1005]; mt19937 Rand(20070521); double energy(double X, double Y) &#123; double r = 0; for (int i = 1; i &lt;= n; ++i) r += hypot(X - x[i], Y - y[i]) * w[i]; return r; &#125; int rndint(int l, int r) &#123; return uniform_int_distribution&lt;int>(l, r)(Rand); &#125; void sa(double a, double b) &#123; double ax = a, ay = b, T = 100, ans = energy(ax, ay); const double delta = 0.99; while (T > 1e-14) &#123; double xx = ax + rndint(-INT_MAX, INT_MAX) * T, yy = ay + rndint(-INT_MAX, INT_MAX) * T; double now = energy(xx, yy), cmp = ans - now; if (cmp > 0) ans = now, ax = xx, ay = yy; else if (exp(cmp / T) * INT_MAX > rndint(0, INT_MAX)) ax = xx, ay = yy; T *= delta; &#125; printf(\"%.3lf %.3lf\\n\", ax, ay); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); double a = 0, b = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d%d\", x + i, y + i, w + i), a += x[i] * w[i] / n, b += y[i] * w[i] / n; return sa(a, b), 0; &#125; 实际上对于模拟退火，只有在 ΔT\\Delta TΔT 较小的时候，取所有情况的最优答案会得到非常棒的答案，但是 ΔT\\Delta TΔT 足够大时没什么区别，直接将答案也改成不优的也可。 其它随机化 没有统一的方式。有些套路如随机撒点，随机化贪心等，更多的还是要根据具体的问题进行分析。 其它优化技巧 这里放置了一些杂项优化技巧。 简单内容 在《提高优化技巧》出现。 贪心：包括排序贪心和反悔贪心。 双指针：扫描具有单调性的内容。 前缀和与差分：必备技能。 单调栈与单调队列：维护单调性的常见手段。 根号分治 根号分治是一种按规模大小分类讨论的思想。对于规模为 xxx 的问题，如果我们可以使用 O(x)O(x)O(x) 和 O(nx)O(\\frac{n}{x})O(xn​) 的复杂度解决，那么可以在 x≤nx\\le \\sqrt{n}x≤n​ 时使用 O(x)O(x)O(x) 算法，否则使用 O(nx)O(\\frac{n}{x})O(xn​) 算法。这样的时间复杂度为 O(n)O(\\sqrt{n})O(n​)。 [Luogu P3396] 哈希冲突。B 君对 hash 冲突很感兴趣。他会给出一个正整数序列 value\\text{value}value。自然，B 君会把这些数据存进 hash 池。第 valuek\\text{value}_kvaluek​ 会被存进 (k mod p)(k \\bmod p)(kmodp) 这个池。这样就能造成很多冲突。B 君会给定许多个 ppp 和 xxx，询问在模 ppp 时，xxx 这个池内 数的总和。另外，B 君会随时更改 valuek\\text{value}_kvaluek​。每次更改立即生效。对于 100%100\\%100% 的数据，有 n≤150000,m≤150000n\\leq 150000,m\\leq 150000n≤150000,m≤150000. 当 x&gt;nx&gt;\\sqrt{n}x&gt;n​ 的时候，暴力即可。 当 x≤nx\\le\\sqrt{n}x≤n​，考虑在修改时就更新答案，询问时直接输出。 这样的时间复杂度为 O(mn)O(m\\sqrt{n})O(mn​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, t; int a[150005]; int res[400][400]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); t = sqrt(n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); for (int j = 1; j &lt;= t; ++j) res[j][i % j] += a[i]; &#125; char s[5]; int x, y; while (m--) &#123; scanf(\"%s%d%d\", s, &amp;x, &amp;y); if (s[0] == 'A') &#123; if (x > t) &#123; int ans = 0; for (int i = y; i &lt;= n; i += x) ans += a[i]; printf(\"%d\\n\", ans); &#125; else printf(\"%d\\n\", res[x][y]); &#125; else &#123; for (int i = 1; i &lt;= t; ++i) res[i][x % i] += y - a[x]; a[x] = y; &#125; &#125; return 0; &#125; 无向图三元环计数 Portal. 让度数小的点向度数大的点连边，然后暴力 for 查找。如果一个点的度数大于 m\\sqrt{m}m​，这样的点不超过 m\\sqrt{m}m​ 个；如果一个点度数小于 m\\sqrt{m}m​，那么这样的点最多 mmm 个。因此时间复杂度为 O(mm)O(m\\sqrt{m})O(mm​)。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, m, ans, deg[100005]; int u[200005], v[200005], vis[100005]; vector&lt;int> G[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", u + i, v + i); ++deg[u[i]]; ++deg[v[i]]; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x = u[i], y = v[i]; if (deg[x] > deg[y] || (deg[x] == deg[y] &amp;&amp; x > y)) swap(x, y); G[x].emplace_back(y); &#125; for (int u = 1; u &lt;= n; ++u) &#123; for (int v : G[u]) vis[v] = u; for (int v : G[u]) for (int w : G[v]) if (vis[w] == u) ++ans; &#125; printf(\"%d\\n\", ans); return 0; &#125; 四元环计数 模板。整体思路跟三元环计数一样，考虑怎样数的不重不漏。枚举一个起点 uuu，保证它是排名最大的点，然后枚举与它距离为 222 的点，统计其中无序对 (x,y)(x,y)(x,y) 的个数即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, ans, cnt[100005]; int deg[100005], a[100005], rk[100005]; vector&lt;int> G[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); ++deg[u]; ++deg[v]; &#125; for (int i = 1; i &lt;= n; ++i) a[i] = i; sort(a + 1, a + n + 1, [&amp;](int x, int y) &#123; return deg[x] &lt; deg[y] || (deg[x] == deg[y] &amp;&amp; x &lt; y); &#125;); for (int i = 1; i &lt;= n; ++i) rk[a[i]] = i; for (int u = 1; u &lt;= n; ++u) &#123; for (int v : G[u]) if (rk[u] > rk[v]) for (int w : G[v]) if (rk[u] > rk[w]) ans += cnt[w]++; for (int v : G[u]) if (rk[u] > rk[v]) for (int w : G[v]) cnt[w] = 0; &#125; return !printf(\"%d\\n\", ans); &#125; Problemset 嗯，题目真的很杂！ 二分与三分 包括二分和三分法以及它们的应用。 [JXOI2017] 加法 Portal. 二分答案，扫描线维护操作的左端点，右端点贪心地选最大的。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, k, v; int a[200005]; struct Operation &#123; int l, r; bool operator&lt;(const Operation&amp; a) const &#123; if (l != a.l) return l &lt; a.l; return r > a.r; &#125; &#125; d[200005]; int C[200005]; inline void add(int x, int k) &#123; for (; x &lt;= n; x += x &amp; -x) C[x] += k; &#125; inline void add(int l, int r, int k) &#123; add(l, k); add(r + 1, -k); &#125; inline int query(int x) &#123; int r = 0; for (; x; x -= x &amp; -x) r += C[x]; return r; &#125; bool check(int x) &#123; // 最小值大于等于 x memset(C, 0, sizeof C); for (int i = 1; i &lt;= n; ++i) add(i, a[i] - a[i - 1]); int cnt = 0, p = 0; priority_queue&lt;int> q; for (int i = 1; i &lt;= n; ++i) &#123; while (p &lt; m &amp;&amp; d[p + 1].l == i) q.push(d[++p].r); while (!q.empty() &amp;&amp; query(i) &lt; x) &#123; // printf(\"A %d %d\\n\", i, q.top()); add(i, q.top(), v), q.pop(), ++cnt; &#125; if (query(i) &lt; x) return 0; &#125; return cnt &lt;= k; &#125; int main(void) &#123; ios::sync_with_stdio(0); int T; cin >> T; while (T--) &#123; cin >> n >> m >> k >> v; int L = 2e8, R; for (int i = 1; i &lt;= n; ++i) cin >> a[i], L = min(L, a[i]); for (int i = 1; i &lt;= m; ++i) cin >> d[i].l >> d[i].r; sort(d + 1, d + m + 1); R = L + m * v + 1; L -= 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) L = mid; else R = mid; &#125; cout &lt;&lt; L &lt;&lt; \"\\n\"; &#125; return 0; &#125; [CF1661F] Teleporters Portal. 可以将原问题划分成几段，然后对于每一段放置传送器的话分的约均匀越好，全局的最小两相邻传送机距离应该是一个（尽可能满足平均），这样就可以用 f(x,k)f(x,k)f(x,k) 来表示 0→x0\\rightarrow x0→x 中额外插入 kkk 个的最小代价，显然是好求的。 直接二分需要安装的传送机数量？我们好像没有办法 check，只知道最多传送机数量的话没有一个合适的贪心策略。我们对另一个条件——总花费进行考虑。因为花费越大直接意味着传送机数量越少。 注意到 f(x,k−1)−f(x,k)f(x,k-1)-f(x,k)f(x,k−1)−f(x,k) 随着 kkk 的增大单调不增，这样可以在外层二分其值 vvv 来代表一个段内的最小传送机距离（类似 wqs 的思想），找出一个 f(x,k−1)−f(x,k)≥vf(x,k-1)-f(x,k)\\ge vf(x,k−1)−f(x,k)≥v 的最大 kkk，而 kkk 越大花费越小，直接利用 kkk 来进行贪心求出每一段的最小代价，与 mmm 比较来确定二分的答案。 设二分出来的答案是 kkk，选完之后 mmm 的值还有剩余，我们尽可能多的值选择 k+1k+1k+1 来榨干 mmm 的剩余价值。 时间复杂度 O(nlog⁡2V)O(n\\log^2 V)O(nlog2V)。 查看代码 #include &lt;bits/stdc++.h> #define i64 long long #define pii pair&lt;i64, int> #define fi first #define se second using namespace std; const i64 INF = 1e18 + 500; int n; i64 m; int a[200005]; inline i64 f(int x, int k) &#123; // 0->x 放 k i64 va = (x + k) / (k + 1), vb = x / (k + 1); int ra = x % (k + 1), rb = k + 1 - ra; return ra * va * va + rb * vb * vb; &#125; int calc(int len, i64 v) &#123; // f(len, x - 1) - f(len, x) >= v 的最小 x int L = 0, R = len; while (L + 1 != R) &#123; int mid = L + R >> 1; if (f(len, mid - 1) - f(len, mid) >= v) L = mid; else R = mid; &#125; return L; &#125; pii check(i64 v) &#123; pii ans(0, 0); for (int i = 1; i &lt;= n; ++i) &#123; int x = calc(a[i], v); ans.fi += f(a[i], x), ans.se += x; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = n; i >= 1; --i) a[i] -= a[i - 1]; scanf(\"%lld\", &amp;m); i64 L = -1, R = INF + 1; while (L + 1 != R) &#123; i64 mid = L + R >> 1; if (check(mid).fi &lt;= m) L = mid; else R = mid; &#125; pii res = check(L + 1); printf(\"%lld\\n\", res.se + (res.fi - m + L - 1) / L); return 0; &#125; [ZJOI2018] 胖 Portal. 从 000 号点到达某一个点后，可以被更新的瞭望塔显然是一段连续的区间，这样我们就可以分别对做右端点进行二分。 设要从 ppp 更新，这条路的距离为 lll，到达第 xxx 个点，那么令 d=∣l−x∣d=|l-x|d=∣l−x∣，在 [x−d,x+d][x-d,x+d][x−d,x+d] 当中不应该存在距离小于 ppp 时距离的点。预处理出图上距离的前缀和 disdisdis，距离的最小值要分在 xxx 的左右讨论，在 xxx 左边时是 disx+(l−disp)dis_x+(l-dis_p)disx​+(l−disp​)，右边时是 −disx+(l+disp)-dis_x+(l+dis_p)−disx​+(l+disp​)，询问前 ST 表预处理两个信息即可求出距离的最小值（建立大小为 KKK 的 ST 表，询问的时候直接二分出左右端点的位置）。 注意距离相等时更新顺序的问题，二分右端点时要对 x+dx+dx+d 的位置做一个单独的讨论。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 2e18; int n, m, K; struct Node &#123; int p, d; bool operator&lt; (const Node &amp;a) const &#123; return p &lt; a.p; &#125; &#125; a[200005]; i64 dis[200005]; namespace ST &#123; int lg[200005]; i64 f[18][200005], g[18][200005]; i64 query(int op, int l, int r) &#123; l = max(1, l); r = min(r, n); Node tmp = &#123;l, 0&#125;; l = lower_bound(a + 1, a + K + 1, tmp) - a; tmp = &#123;r, 0&#125;; r = upper_bound(a + 1, a + K + 1, tmp) - (a + 1); if (l > r) return INF; int k = lg[r - l + 1]; if (op == 1) return min(f[k][l], f[k][r - (1 &lt;&lt; k) + 1]); return min(g[k][l], g[k][r - (1 &lt;&lt; k) + 1]); &#125; void init(void) &#123; for (int i = 2; i &lt;= K; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= K; ++i) f[0][i] = a[i].d - dis[a[i].p], g[0][i] = a[i].d + dis[a[i].p]; for (int i = 1; i &lt;= lg[K]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= K; ++j) f[i][j] = min(f[i - 1][j], f[i - 1][j + (1 &lt;&lt; i - 1)]), g[i][j] = min(g[i - 1][j], g[i - 1][j + (1 &lt;&lt; i - 1)]); &#125; &#125; using namespace ST; bool checkl(int p, int x) &#123; // p 更新到 x，x &lt; p if (p == x) return 1; int d = abs(p - x); i64 t1 = query(1, x - d, x) + dis[x]; i64 t2 = query(2, x, x + d - 1) - dis[x]; i64 now = query(2, p, p) - dis[x]; return t1 > now &amp;&amp; t2 > now; &#125; int calcl(int p) &#123; int L = 0, R = p + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (checkl(p, mid)) R = mid; else L = mid; &#125; return R; &#125; bool checkr(int p, int x) &#123; // 从 p 能否更新到 x，x > p if (p == x) return 1; int d = abs(p - x); i64 t1 = query(1, x - d + 1, x) + dis[x]; i64 t2 = query(2, x, x + d - 1) - dis[x]; i64 now = query(1, p, p) + dis[x]; if (t1 &lt;= now || t2 &lt;= now) return 0; if (x + d &lt;= n) return query(2, x + d, x + d) - dis[x] >= now; // p 在 x 左边，相等时会先更新 return 1; &#125; int calcr(int p) &#123; int L = p - 1, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (checkr(p, mid)) L = mid; else R = mid; &#125; return L; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) scanf(\"%lld\", dis + i), dis[i] += dis[i - 1]; while (m--) &#123; scanf(\"%d\", &amp;K); for (int i = 1; i &lt;= K; ++i) scanf(\"%d%d\", &amp;a[i].p, &amp;a[i].d); sort(a + 1, a + K + 1); ST::init(); i64 ans = 0; for (int i = 1; i &lt;= K; ++i) ans += (calcr(a[i].p) - calcl(a[i].p) + 1); printf(\"%lld\\n\", ans); &#125; return 0; &#125; [USACO18OPEN] Talent Show G Portal.分数规划，但是限制 bbb 的和至少为 WWW。 这回不能简单的排序了。但是！我们可以用 01 背包的模型解决这个问题。设 f(i)f(i)f(i) 代表体积为 iii 时的最大价值。特别的，当 i≥Wi\\ge Wi≥W 时，将 iii 强行赋值为 WWW，转移的时候采用刷表法。这样并不会影响答案，因为是刷表，刷出一个 &gt;W&gt;W&gt;W 的状态可以直接存在 f[W]f[W]f[W] 里。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const double eps = 1e-5; int n, W; int a[300], b[300]; double f[1005]; bool check(double x) &#123; for (int i = 1; i &lt;= W; ++i) f[i] = -1e9; for (int i = 1; i &lt;= n; ++i) for (int j = W; j >= 0; --j) &#123; int k = min(W, j + b[i]); f[k] = max(f[k], f[j] + a[i] - x * b[i]); &#125; return f[W] > 0; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;W); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", b + i, a + i); double L = 0, R = 1e9; while (L + eps &lt; R) &#123; double mid = (L + R) / 2; if (check(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", int(L * 1000)); return 0; &#125; 倍增 题目都比较简单。 [SCOI2015] 国旗计划 Portal. 先将战士按照左端点排序，然后将环复制成二倍链。注意到每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含，所以这样排序后右端点就是递增的。设 f(i)f(i)f(i) 代表第 iii 个战士能将国旗传递给的最远的战士编号，那么我们就可以依次求解，但是这样单次时间复杂度为 O(n)O(n)O(n)！注意到答案具有单调性（战士越多奔袭距离越长），二分答案似乎并不是很好做（不知道这个战士跳到了哪里），因此考虑倍增！设 f(i,j)f(i,j)f(i,j) 代表第 iii 个战士开始借用 2j2^j2j（包括自己）的战士的力量可以传递给最远的战士的编号，那么参考倍增 LCA 的方式从高到低开始枚举。同时注意，最后不能跑到 a[i].l+ma[i].l+ma[i].l+m，只能跑到它前一个，这样再来一个战士就一定能跑过去（因为很可能跑过，所以最后再 +1）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int f[22][400005]; // 第 i ~ i+2^j-1 个战士的奔袭位置 int Ans[200005]; struct soldier &#123; int id, l, r; bool operator &lt; (const soldier &amp;a) const &#123; return l &lt; a.l; &#125; &#125; a[400005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;a[i].l, &amp;a[i].r); if (a[i].r &lt; a[i].l) a[i].r += m; a[i].id = i; &#125; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i + n].id = a[i].id; a[i + n].l = a[i].l + m; a[i + n].r = a[i].r + m; &#125; for (int i = 1, p = i; i &lt;= n * 2; ++i) &#123; while (p &lt;= n * 2 &amp;&amp; a[p].l &lt;= a[i].r) ++p; f[0][i] = p - 1; &#125; for (int i = 1; i &lt; 20; ++i) for (int j = 1; j &lt;= n * 2; ++j) f[i][j] = f[i - 1][f[i - 1][j]]; for (int i = 1; i &lt;= n; ++i) &#123; int mx = a[i].l + m, ans = 1, p = i; // 初始有 1 个战士 for (int j = 19; j >= 0; --j) if (f[j][p] &amp;&amp; a[f[j][p]].r &lt; mx) ans += 1 &lt;&lt; j, p = f[j][p]; // 奔袭到 f[j][p] 的右端点 Ans[a[i].id] = ans + 1; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", Ans[i]); putchar('\\n'); return 0; &#125; [CF1809F] Traveling in Berland Portal. 如果当前位置油价是 111，那么肯定能加满就加满（会用完），222 的话能加多少加多少。设 fif_{i}fi​ 代表 iii 到下一个油价是 111 的位置的位置，sis_{i}si​ 代表代价，倍增这个过程即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k; int a[400005], b[400005], f[19][400005]; // f 为从 j 开始走的下一个 1 的位置 i64 d[400005], s[19][400005]; // s 为从 j 开始走到下一个 1 位置的消耗 i64 calc(int s, int t) &#123; i64 di = d[t] - d[s - 1]; if (b[s] == 1) return di &lt;= k ? di : di * 2 - k; return di * 2; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;k); int lg = 18; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), a[n + i] = a[i]; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i), b[n + i] = b[i]; for (int i = 1; i &lt;= n * 2; ++i) d[i] = d[i - 1] + a[i]; int nxt = n * 2 + 1; f[0][nxt] = nxt, s[0][nxt] = 0; for (int i = n * 2; i >= 1; --i) &#123; f[0][i] = nxt; s[0][i] = calc(i, nxt - 1); if (b[i] == 1) nxt = i; &#125; for (int i = 1; i &lt;= lg; ++i) for (int j = 1; j &lt;= n * 2 + 1; ++j) f[i][j] = f[i - 1][f[i - 1][j]], s[i][j] = s[i - 1][j] + s[i - 1][f[i - 1][j]]; for (int i = 1; i &lt;= n; ++i) &#123; int cur = i; i64 res = 0; for (int j = lg; j >= 0; --j) if (f[j][cur] &lt;= i + n) &#123; res += s[j][cur]; cur = f[j][cur]; &#125; printf(\"%lld \", res + calc(cur, i + n - 1)); &#125; putchar('\\n'); &#125; return 0; &#125; [???] 最小生成树 给定一张带权无向图，其中边的编号为 1∼m1\\sim m1∼m。把这些边分组，每组构成原图的一棵生成树，且每棵生成树的边权和都不超过 SSS。同时，她还希望任意两棵生成树都是&quot;不相交&quot;的，即分组后边的编号是连续的。数据范围在 10510^5105 级别。 可以直接贪心+二分答案。但是如果 nnn 很小，那么可能会导致二分次数过多。因此可以将二分答案改为倍增答案。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, S; int fa[100005], u[100005], v[100005], w[100005]; struct edge &#123; int u, v, w; bool operator&lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[100005]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; inline bool Kruskal(int l, int r) &#123; int ans = 0; for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = l; i &lt;= r; ++i) e[i].u = u[i], e[i].v = v[i], e[i].w = w[i]; int tot = 1; sort(e + l, e + r + 1); for (int i = l; i &lt;= r; ++i) &#123; int u = find(e[i].u), v = find(e[i].v), w = e[i].w; if (u == v) continue; fa[u] = v; ++tot; if ((ans += w) > S) return 0; if (tot == n) break; &#125; return ans &lt;= S &amp;&amp; tot == n; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;S); int ans = 0; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", u + i, v + i, w + i); for (int i = 1, flag = 1; i &lt;= m &amp;&amp; flag; ) &#123; int pw = 0; while (1) &#123; if (i + (1 &lt;&lt; pw) > m) &#123; ans += Kruskal(i, m); goto over; &#125; if (!Kruskal(i, i + (1 &lt;&lt; pw))) ++pw; else break; &#125; if (!flag) break; int acc = 1 &lt;&lt; pw; for (int j = pw; j >= 0; --j) if (Kruskal(i, i + acc - (1 &lt;&lt; j))) acc -= 1 &lt;&lt; j; // printf(\"MST %d %d\\n\", i, i + acc); ++ans; i += acc + 1; &#125; over: printf(\"%d\\n\", ans); &#125; return 0; &#125; 「Wdoi-2」死亡之后愈发愉悦 Portal. i+1i+1i+1 个可爱数连着 iii 个非可爱数。设 j(a)j(a)j(a) 代表 aaa 是否为可爱数。求出 j(a)=j(a+p)j(a)=j(a+p)j(a)=j(a+p) 的最大 ppp，j(a+p+1)=j(a+p+q)j(a+p+1)=j(a+p+q)j(a+p+1)=j(a+p+q) 的最大 qqq，则容易根据 p,q,j(a)p,q,j(a)p,q,j(a) 解出 aaa。 对于求解 p,qp,qp,q，考虑倍增。注意倍增时要先跳两个 202^020，这样保证每一次跳跃的长度不大于以前跳跃的长度，因为区间并不是严格单调的，这样防止跳出区间。 对于 qqq 的倍增并不需要从 000 开始，可以发现 p≤qp\\le qp≤q，因此可以直接先跳一个不超过 p−1p-1p−1 的数而不是 111。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; map&lt;int, bool> ans; inline bool query(i64 x) &#123; if (ans.find(x) != ans.end()) return ans[x]; cout &lt;&lt; \"? \" &lt;&lt; x &lt;&lt; endl; cin >> ans[x]; return ans[x]; &#125; inline void answer(i64 x) &#123; cout &lt;&lt; \"! \" &lt;&lt; x &lt;&lt; endl; &#125; i64 calc(i64 x, i64 acc) &#123; // 求 j(a + x) ~ j(a + p) 相等的最大 p bool st = query(x); if (query(x + 1) != st) return x; int pw = 0; while (1ll &lt;&lt; pw + 1 &lt;= acc) ++pw; while (1) &#123; if (query(x + acc + (1ll &lt;&lt; pw)) != st) break; acc += 1ll &lt;&lt; pw; ++pw; &#125; for (int i = pw - 1; i >= 0; --i) if (query(x + acc + (1 &lt;&lt; i)) == st) acc += 1ll &lt;&lt; i; return x + acc; &#125; int main(void) &#123; ios::sync_with_stdio(0); int T; cin >> T; while (T--) &#123; ans.clear(); i64 p = calc(0, 1); i64 q = calc(p + 1, max(1ll, p - 1)) - p; if (query(0)) answer(q * (q + 1) - p); // a 是可爱数 else answer((q - 1) * (q - 1) - 1 - p); // a 不是可爱数 &#125; return 0; &#125; 分治 分治是很实用的思想，这里看几道题来体会一下，因为分治在到处都有渗透。 [UVA1608] Non-boring sequences Portal. 一定能在中间找到一个唯一的元素，然后分治求解两边即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int a[200005], b[200005], p[200005]; int pre[200005], nxt[200005]; bool divide(int l, int r) &#123; if (l >= r) return true; int p = l, q = r; while (p &lt;= q) &#123; if (pre[q] &lt; l &amp;&amp; nxt[q] > r) if (divide(l, q - 1) &amp;&amp; divide(q + 1, r)) return true; if (pre[p] &lt; l &amp;&amp; nxt[p] > r) if (divide(l, p - 1) &amp;&amp; divide(p + 1, r)) return true; --q; ++p; &#125; return false; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i), b[i] = a[i]; p[i] = 0; pre[i] = 0; nxt[i] = n + 1; &#125; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b; for (int i = 1; i &lt;= n; ++i) &#123; if (p[a[i]]) pre[i] = p[a[i]], nxt[p[a[i]]] = i; p[a[i]] = i; &#125; if (divide(1, n)) puts(\"non-boring\"); else puts(\"boring\"); &#125; return 0; &#125; [CF1442D] Sum Portal.给定 nnn 个不降的数组。有一个值 ansansans，初始为 000。你需要进行如下操作 kkk 次：选择一个数组，把 ansansans 加上数组的第一个元素，之后把它删除。请求出 ansansans 最大是多少。所有数组的元素总个数 ≤106\\leq 10^6≤106，n,k≤3000n,k\\leq 3000n,k≤3000。 注意到数组是单调不降的，因此要取一个数组就会一直取下去直到不能取或者取光了。 所以可以想到一个暴力一点的做法：将一个数组视为一个有体积有价值的物品，然后正反做两遍 01 背包，枚举没取满的那个数组和这个数组取多少个，再枚举前面取的体积，这样就可以得出后面取的体积，并计算出总价值，时间复杂度为 O(nk2)O(nk^2)O(nk2)。 这样肯定过不去，发现就是合并太慢了，考虑使用分治算法合并：求解 (l,r)(l,r)(l,r) 时，我们先将 (l,mid)(l,mid)(l,mid) 加入背包，然后递归求解 (mid+1,r)(mid+1,r)(mid+1,r)，当 l=rl=rl=r 时就可以枚举当前体积了。时间复杂度 O(nklog⁡n)O(nk\\log n)O(nklogn)。 这个问题被称为缺一背包，意思是其中有一个可以取不满，一般采用上述分治法解决。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k; vector&lt;i64> a[3005]; i64 ans = 0, f[3005]; void merge(int l, int r) &#123; if (l == r) &#123; for (int i = 0; i &lt;= min(k, (int)a[l].size() - 1); ++i) ans = max(ans, a[l][i] + f[k - i]); return; &#125; int mid = l + r >> 1; i64 g[3005]; memcpy(g, f, sizeof(g)); for (int i = mid + 1; i &lt;= r; ++i) for (int j = k; j >= a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(l, mid); memcpy(f, g, sizeof(f)); for (int i = l; i &lt;= mid; ++i) for (int j = k; j >= a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(mid + 1, r); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; int m; scanf(\"%d\", &amp;m); a[i].resize(m + 1); for (int j = 1, x; j &lt;= m; ++j) scanf(\"%lld\", &amp;a[i][j]), a[i][j] += a[i][j - 1]; &#125; merge(1, n); printf(\"%lld\\n\", ans); return 0; &#125; CDQ 分治 维护的是偏序关系。 [CQOI2011] 动态逆序对 Portal.给定一个 1∼n1\\sim n1∼n 的排列，按照顺序依次删除 mmm 个元素，统计每个元素被删除之前整个序列的逆序对数。 删除不太好做，于是我们把这个过程反过来，改成添加元素，这样每个元素就多了一个“时间”，自身还有“位置”和“大小”，要求 ti≤tj,i&lt;j,ai&gt;ajt_i\\le t_j,i&lt;j,a_i&gt;a_jti​≤tj​,i&lt;j,ai​&gt;aj​，这就成了三维偏序问题。 注意在合并的时候，两边的序列位置 ppp 都是按顺序排好的，因此要正反做两遍，分别对 i&lt;j,ai&gt;aji&lt;j,a_i&gt;a_ji&lt;j,ai​&gt;aj​ 和 i&gt;j,ai&lt;aji&gt;j,a_i&lt;a_ji&gt;j,ai​&lt;aj​ 进行统计。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; struct Node &#123; int t, p, v; bool operator &lt; (const Node &amp;a) const &#123; if (t == a.t) return p &lt; a.p; return t &lt; a.t; &#125; &#125; a[100005], T[100005]; int n, m, idx[100005]; i64 ans[100005]; int C[100005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int sum(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; void CDQ(int l, int r) &#123; if (l == r) return; int mid = l + r >> 1; CDQ(l, mid); CDQ(mid + 1, r); int p = l, q = mid + 1; for (int i = l; i &lt;= r; ++i) &#123; if (p &lt;= mid &amp;&amp; (q > r || a[p].p &lt; a[q].p)) add(a[p].v, 1), T[i] = a[p++]; else ans[a[q].t] += sum(n) - sum(a[q].v), T[i] = a[q++]; &#125; for (int i = l; i &lt;= mid; ++i) add(a[i].v, -1); p = mid, q = r; for (int i = l; i &lt;= r; ++i) &#123; if (p >= l &amp;&amp; (q &lt; mid + 1 || a[p].p > a[q].p)) add(a[p].v, 1), --p; else ans[a[q].t] += sum(a[q].v), --q; &#125; for (int i = l; i &lt;= mid; ++i) add(a[i].v, -1); for (int i = l; i &lt;= r; ++i) a[i] = T[i]; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i].v), a[i].p = i, idx[a[i].v] = i, a[i].t = 1; for (int i = 1, x; i &lt;= m; ++i) scanf(\"%d\", &amp;x), a[idx[x]].t = m - i + 1; sort(a + 1, a + n + 1); CDQ(1, n); for (int i = 1; i &lt;= m; ++i) ans[i] += ans[i - 1]; for (int i = m; i >= 1; --i) printf(\"%lld\\n\", ans[i]); return 0; &#125; [Violet] 天使玩偶 Portal. 绝对值不好处理，考虑拆开分类讨论，假定 x1≤x2,y1≤y2x_1\\le x_2,y_1\\le y_2x1​≤x2​,y1​≤y2​，只需要找到最大的 x1+y1x_1+y_1x1​+y1​ 即可。离线时间维转化为第三维，CDQ 分治处理四个方向即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1000002; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar_unlocked(); return x; &#125; int n, m; struct Node &#123; int x, y, t; bool f; // f 记录是否为询问 bool operator&lt; (const Node &amp;a) &#123; return x &lt; a.x; &#125; Node(int x = 0, int y = 0, int t = 0, bool f = 0) : x(x), y(y), t(t), f(f) &#123;&#125; &#125; a[600005], p[600005], T[600005]; int ans[600005]; int C[1000005]; inline void add(int x, int k) &#123; for (; x &lt;= N; x += x &amp; -x) C[x] = max(C[x], k); &#125; inline int qmax(int x) &#123; int r = 0; for (; x; x -= x &amp; -x) r = max(r, C[x]); return r; &#125; inline void clear(int x) &#123; for (; x &lt;= N; x += x &amp; -x) C[x] = 0; &#125; void CDQ(int l, int r) &#123; if (l == r) return; int mid = l + r >> 1; CDQ(l, mid); CDQ(mid + 1, r); // 左端点对右端询问点的影响 for (int p = l, q = mid + 1, tmp; q &lt;= r; ++q) if (a[q].f) &#123; for (; p &lt;= mid &amp;&amp; a[p].x &lt;= a[q].x; ++p) if (!a[p].f) add(a[p].y, a[p].x + a[p].y); if (tmp = qmax(a[q].y)) ans[a[q].t] = min(ans[a[q].t], a[q].x + a[q].y - tmp); // 注意有可能没有点 &#125; for (int i = l; i &lt;= mid; ++i) if (!a[i].f) clear(a[i].y); merge(a + l, a + mid + 1, a + mid + 1, a + r + 1, T + l); for (int i = l; i &lt;= r; ++i) a[i] = T[i]; &#125; int main(void) &#123; n = read(), m = read(); memset(ans, 0x3f, sizeof ans); for (int i = 1; i &lt;= n; ++i) p[i].x = read() + 1, p[i].y = read() + 1; for (int i = 1; i &lt;= m; ++i) p[++n].f = read() - 1, p[n].x = read() + 1, p[n].y = read() + 1, p[n].t = i; for (int i = 1; i &lt;= n; ++i) a[i] = p[i]; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) a[i] = p[i], a[i].x = N - a[i].x; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) a[i] = p[i], a[i].y = N - a[i].y; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) a[i] = p[i], a[i].x = N - a[i].x, a[i].y = N - a[i].y; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) if (p[i].f) printf(\"%d\\n\", ans[p[i].t]); return 0; &#125; [SDOI2011] 拦截导弹 Portal. 设 fif_ifi​ 代表以 iii 结尾的最长子序列（记为 XLIS）长度，那么 fi=max⁡{fj∣i&gt;j,hi&lt;hj,vi&lt;vj}+1f_i=\\max\\{f_j|i&gt;j,h_i&lt;h_j,v_i&lt;v_j\\}+1fi​=max{fj​∣i&gt;j,hi​&lt;hj​,vi​&lt;vj​}+1，gig_igi​ 代表 XLIS 个数，是三维偏序！然后处理以当前点为起点和终点的答案，然后最终答案就很好统计了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct Node &#123; int x, y, z; friend bool operator&lt; (const Node &amp;a, const Node &amp;b) &#123; return a.x &lt; b.x; &#125; &#125; a[50005]; bool cmp(Node &amp;a, Node &amp;b) &#123; return a.y &lt; b.y; &#125; bool cmp2(Node &amp;a, Node &amp;b) &#123; return a.x > b.x; &#125; int n, h[50005], v[50005]; int mh, mv, b[50005]; int f1[50005], f2[50005]; double g1[50005], g2[50005]; void init(int *a, int &amp;m) &#123; for (int i = 1; i &lt;= n; ++i) b[i] = a[i]; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = m - a[i] + 1; &#125; int C[50005]; double F[50005]; void add(int o, int x, double y) &#123; for (int i = o; i &lt;= n; i += i &amp; -i) if (C[i] &lt; x) C[i] = x, F[i] = y; else if (C[i] == x) F[i] += y; &#125; auto query(int x) &#123; int r1 = 0; double r2 = 0; for (int i = x; i; i -= i &amp; -i) if (r1 &lt; C[i]) r1 = C[i], r2 = F[i]; else if (r1 == C[i]) r2 += F[i]; return make_pair(r1, r2); &#125; void clear(int o) &#123; for (int i = o; i &lt;= n; i += i &amp; -i) C[i] = F[i] = 0; &#125; void CDQ(int l, int r, int *f, double *g, int type) &#123; if (l == r) return; int mid = l + r >> 1; CDQ(l, mid, f, g, type); sort(a + l, a + mid + 1, cmp); sort(a + mid + 1, a + r + 1, cmp); for (int p = l, q = mid + 1; q &lt;= r; ++q) &#123; for (; p &lt;= mid &amp;&amp; a[p].y &lt;= a[q].y; ++p) add(a[p].z, f[a[p].x], g[a[p].x]); auto r = query(a[q].z); if (r.first + 1 == f[a[q].x]) g[a[q].x] += r.second; else if (r.first + 1 > f[a[q].x]) f[a[q].x] = r.first + 1, g[a[q].x] = r.second; &#125; for (int i = l; i &lt;= mid; ++i) clear(a[i].z); if (type == 1) sort(a + mid + 1, a + r + 1); else sort(a + mid + 1, a + r + 1, cmp2); CDQ(mid + 1, r, f, g, type); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", h + i, v + i), f1[i] = g1[i] = f2[i] = g2[i] = 1; init(h, mh); init(v, mv); for (int i = 1; i &lt;= n; ++i) a[i].x = i, a[i].y = h[i], a[i].z = v[i]; CDQ(1, n, f1, g1, 1); for (int i = 1; i &lt;= n; ++i) a[i].x = i, a[i].y = mh - h[i] + 2, a[i].z = mv - v[i] + 2; reverse(a + 1, a + n + 1); CDQ(1, n, f2, g2, 2); int ans = 0; double s = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f1[i]); printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (f1[i] == ans) s += g1[i]; for (int i = 1; i &lt;= n; ++i) if (f1[i] + f2[i] - 1 == ans) printf(\"%.6lf \", g1[i] * g2[i] / s); else fputs(\"0 \", stdout); return putchar('\\n'), 0; &#125; 整体二分 通过跟踪分治中心来得到优秀的做法。 [POI2011] MET-Meteors Portal.有 n​n​n​ 个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为 m​m​m​ 份（第 m​m​m​ 份和第 1​1​1​ 份相邻），第 i​i​i​ 份上有第 ai​a_i​ai​​ 个国家的太空站。这个星球经常会下陨石雨。BIU 已经预测了接下来 kkk 场陨石雨的情况。BIU 的第 iii 个成员国希望能够收集 pip_ipi​ 单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。 一次询问的话二分答案是可做的，那么我们就考虑整体二分。将环展成二倍链，用一个树状数组维护每个区间的值。注意陨石雨可能落在同一个国家使得答案很大，请使用合理的变量类型。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; int n, m, k, ans[300005], id[300005]; int L[300005], R[300005], T[300005]; vector&lt;int> a[300005]; int Q[300005], t1[300005], t2[300005]; __int128 C[600005]; void add(int x, int k) &#123; for (; x &lt;= 2 * m; x += lowbit(x)) C[x] += k; &#125; __int128 query(int x) &#123; __int128 ans = 0; for (; x; x -= lowbit(x)) ans += C[x]; return ans; &#125; void solve(int l, int r, int ql, int qr) &#123; if (ql > qr) return; if (l == r) &#123; for (int i = ql; i &lt;= qr; ++i) ans[id[i]] = l; return; &#125; int mid = l + r >> 1, p = 0, q = 0; for (int i = l; i &lt;= mid; ++i) add(L[i], T[i]), add(R[i] + 1, -T[i]); for (int i = ql; i &lt;= qr; ++i) &#123; int u = id[i]; __int128 s = 0; for (int j : a[u]) s += query(j) + query(j + m); if (s >= Q[u]) t1[++p] = u; else t2[++q] = u, Q[u] -= s; &#125; int tot = ql - 1; for (int i = 1; i &lt;= p; ++i) id[++tot] = t1[i]; for (int i = 1; i &lt;= q; ++i) id[++tot] = t2[i]; for (int i = l; i &lt;= mid; ++i) add(L[i], -T[i]), add(R[i] + 1, T[i]); solve(l, mid, ql, ql + p - 1); solve(mid + 1, r, ql + p, qr); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, x; i &lt;= m; ++i) scanf(\"%d\", &amp;x), a[x].push_back(i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;Q[i]), id[i] = i; scanf(\"%d\", &amp;k); for (int i = 1; i &lt;= k; ++i) &#123; scanf(\"%d%d%d\", L + i, R + i, T + i); if (R[i] &lt; L[i]) R[i] += m; &#125; L[k + 1] = 1, R[k + 1] = m, T[k + 1] = 1e9; solve(1, k + 1, 1, n); for (int i = 1; i &lt;= n; ++i) if (ans[i] != k + 1) printf(\"%d\\n\", ans[i]); else puts(\"NIE\"); return 0; &#125; [CTSC2018] 混合果汁 Portal. 可以二分出美味度的答案，而又有多组询问，因此考虑整体二分。先加入一个美味度为 −1-1−1，可以无限买的免费果汁方便处理。将果汁按照美味度从大到小排序。 我们将美味度 ≤mid\\le mid≤mid 的果汁全部加入树状数组。对当前询问的分组需要二分出满足其体积限制的最小价格，只需要考虑比这个价格低的果汁一定要全买，不足的用价格等于这个的果汁补即可。 时间复杂度 O(nlog⁡3n)O(n\\log^3 n)O(nlog3n)，换成树状数组倍增可以做到 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, id[100005], ans[100005]; int t1[100005], t2[100005]; struct Query &#123; i64 g, l; &#125; Q[100005]; struct juice &#123; int d, p; i64 l; // 美味度，每升价格，最大体积 juice(int d = 0, int p = 0, i64 l = 0) : d(d), p(p), l(l) &#123;&#125; bool operator &lt; (const juice &amp;a) const &#123; return d > a.d; &#125; &#125; a[100005]; struct Fenwick &#123; #define lowbit(x) (x &amp; -x) i64 C[100005]; void add(int x, i64 k) &#123; ++x; for (; x &lt;= 100000; x += lowbit(x)) C[x] += k; &#125; i64 query(int x) &#123; ++x; i64 res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; &#125; P, L; // 总价格，总体积 inline void update(int i, i64 flag) &#123; L.add(a[i].p, flag * a[i].l); P.add(a[i].p, flag * a[i].l * a[i].p); &#125; int find(int x) &#123; // 二分出满足体积限制的最小价格 int l = 0, r = 100001; while (l + 1 != r) &#123; int mid = l + r >> 1; if (L.query(mid) >= Q[x].l) r = mid; else l = mid; &#125; return r; &#125; int now; void solve(int l, int r, int ql, int qr) &#123; if (ql > qr) return; if (l == r) &#123; for (int i = ql; i &lt;= qr; ++i) ans[id[i]] = a[l].d; return; &#125; int mid = l + r >> 1, p = 0, q = 0; while (now &lt; mid) update(++now, 1); while (now > mid) update(now--, -1); for (int i = ql; i &lt;= qr; ++i) &#123; int u = id[i]; int x = find(u); i64 Pv = P.query(x), Pl = L.query(x); if (Pl >= Q[u].l &amp;&amp; Pv - x * (Pl - Q[u].l) &lt;= Q[u].g) t1[++p] = u; else t2[++q] = u; &#125; int tot = ql - 1; for (int i = 1; i &lt;= p; ++i) id[++tot] = t1[i]; for (int i = 1; i &lt;= q; ++i) id[++tot] = t2[i]; solve(l, mid, ql, ql + p - 1); solve(mid + 1, r, ql + p, qr); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d%d\", &amp;a[i].d, &amp;a[i].p, &amp;a[i].l); a[++n] = juice(-1, 0, 1e18); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= m; ++i) scanf(\"%lld%lld\", &amp;Q[i].g, &amp;Q[i].l), id[i] = i; solve(1, n, 1, m); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; 整体二分带修 | [Luogu P2617] Dynamic Rankings Portal. 带修改的整体二分也很好处理，只需要将修改也作为事件。由于带修数很杂，因此可以选择直接二分值域。这样只需要将 ≤mid\\le mid≤mid 的数加入树状数组统计即可。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; int n, m; int w[100005], ans[300005]; struct operation &#123; int type, l, r, k; &#125; Q[300005]; int id[300005], t1[300005], t2[300005]; int C[100005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int ask(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int ask(int l, int r) &#123; return ask(r) - ask(l - 1); &#125; void solve(int l, int r, int ql, int qr) &#123; if (ql > qr) return; if (l == r) &#123; for (int i = ql; i &lt;= qr; ++i) if (!Q[id[i]].type) ans[id[i]] = l; return; &#125; int mid = l + r >> 1, p = 0, q = 0; for (int i = ql; i &lt;= qr; ++i) &#123; int u = id[i]; if (Q[u].type) &#123; if (Q[u].r &lt;= mid) add(Q[u].l, Q[u].k), t1[++p] = u; else t2[++q] = u; &#125; else &#123; int tmp = ask(Q[u].l, Q[u].r); if (tmp >= Q[u].k) t1[++p] = u; else Q[u].k -= tmp, t2[++q] = u; &#125; &#125; int tot = ql - 1; for (int i = 1; i &lt;= p; ++i) id[++tot] = t1[i]; for (int i = 1; i &lt;= q; ++i) id[++tot] = t2[i]; for (int i = 1; i &lt;= p; ++i) &#123; int u = t1[i]; if (Q[u].type &amp;&amp; Q[u].r &lt;= mid) add(Q[u].l, -Q[u].k); &#125; solve(l, mid, ql, ql + p - 1), solve(mid + 1, r, ql + p, qr); &#125; int main(void) &#123; cin >> n >> m; int tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", w + i); Q[++tot] = &#123;1, i, w[i], 1&#125;; &#125; for (int i = 1; i &lt;= m; ++i) &#123; char s[2]; scanf(\"%s\", s); if (s[0] == 'Q') &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); Q[++tot] = &#123;0, l, r, k&#125;; &#125; else &#123; int x, k; scanf(\"%d%d\", &amp;x, &amp;k); Q[++tot] = &#123;1, x, w[x], -1&#125;; w[x] = k; Q[++tot] = &#123;1, x, w[x], 1&#125;; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) id[i] = i, ans[i] = -1; solve(0, 1e9, 1, tot); for (int i = 1; i &lt;= tot; ++i) if (ans[i] != -1) printf(\"%d\\n\", ans[i]); return 0; &#125; 线段树分治 可以很方便地支持撤销。 [Luogu P5787] 二分图 /【模板】线段树分治 Portal. 判断二分图可以使用扩展域并查集（拆成黑点和白点），而且需要支持可撤销，因此需要使用启发式合并地并查集。然后线段树分治糊上去即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, k, f[200005], siz[200005]; struct edge &#123; int x, y; &#125; e[200005]; vector&lt;int> T[400005]; struct Node &#123; int x, y, s; &#125; st[200005]; int tot; int find(int x) &#123; if (f[x] == x) return x; return find(f[x]); &#125; void merge(int x, int y) &#123; x = find(x), y = find(y); if (x == y) return; if (siz[x] > siz[y]) swap(x, y); st[++tot] = &#123;x, y, siz[x]&#125;; f[x] = y; siz[y] += siz[x]; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].emplace_back(k), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); &#125; void solve(int o, int l, int r) &#123; bool flag = 1; int lst = tot; for (int i : T[o]) &#123; int x = find(e[i].x), y = find(e[i].y); if (x == y) &#123; // 属于一个集合 for (int j = l; j &lt;= r; ++j) puts(\"No\"); flag = 0; break; &#125; merge(e[i].x, e[i].y + n); merge(e[i].y, e[i].x + n); &#125; if (flag) &#123; if (l == r) puts(\"Yes\"); else &#123; int mid = l + r >> 1; solve(o &lt;&lt; 1, l, mid); solve(o &lt;&lt; 1 | 1, mid + 1, r); &#125; &#125; while (tot > lst) &#123; f[st[tot].x] = st[tot].x; siz[st[tot].y] -= st[tot].s; --tot; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; ++i) &#123; int l, r; scanf(\"%d%d%d%d\", &amp;e[i].x, &amp;e[i].y, &amp;l, &amp;r); ++l; update(1, 1, k, l, r, i); &#125; for (int i = 1; i &lt;= n * 2; ++i) f[i] = i, siz[i] = 1; solve(1, 1, k); return 0; &#125; [CF576E] Painting Edges Portal. 跟上一道题似乎很像，只需要使用 kkk 个可撤销并查集维护每一个颜色即可。但是如果答案是 NO 不执行此操作如何处理？ 线段树分治的特性是 1→q1\\rightarrow q1→q 依次处理，第 iii 次询问的生效区间是 [i+1,y−1][i+1,y-1][i+1,y−1]（yyy 代表下一次修改这条边的时间）。可以在每个叶子上再考虑是否满足二分图的条件（每个询问只会多一条边），然后不满足的话这个修改的颜色改为边当前的颜色。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, k, q, u[500005], v[500005]; int a[500005], c[500005], p[500005], tmp[500005]; int fa[55][1000005], siz[55][1000005], tot; struct Node &#123; int o, x, y, z; &#125; st[3000005]; inline int find(int o, int x) &#123; while (x != fa[o][x]) x = fa[o][x]; return x; &#125; inline void merge(int o, int x, int y) &#123; x = find(o, x); y = find(o, y); if (x == y) return; if (siz[o][x] > siz[o][y]) swap(x, y); st[++tot] = &#123;o, x, y, siz[o][x]&#125;; fa[o][x] = y; siz[o][y] += siz[o][x]; &#125; vector&lt;int> T[2000005]; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].emplace_back(k), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); &#125; void solve(int o, int l, int r) &#123; int lst = tot; for (int i : T[o]) if (c[i]) merge(c[i], u[a[i]], v[a[i]] + n), merge(c[i], v[a[i]], u[a[i]] + n); if (l == r) &#123; if (find(c[l], u[a[l]]) == find(c[l], v[a[l]])) // 检查这次操作是否合法 puts(\"NO\"), c[l] = tmp[a[l]]; // 不合法，阻止接下来的合并 else puts(\"YES\"), tmp[a[l]] = c[l]; &#125; else &#123; int mid = l + r >> 1; solve(o &lt;&lt; 1, l, mid); solve(o &lt;&lt; 1 | 1, mid + 1, r); &#125; for (; tot > lst; --tot) &#123; int x = st[tot].x, o = st[tot].o; fa[o][x] = x, siz[o][st[tot].y] -= st[tot].z; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;q); for (int i = 1; i &lt;= k; ++i) for (int j = 1; j &lt;= n * 2; ++j) fa[i][j] = j, siz[i][j] = 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", u + i, v + i), p[i] = q + 1; for (int i = 1; i &lt;= q; ++i) scanf(\"%d%d\", a + i, c + i); for (int i = q; i >= 1; --i) &#123; if (i &lt; p[a[i]] - 1) update(1, 1, q, i + 1, p[a[i]] - 1, i); // 在此次操作之后再生效 p[a[i]] = i; &#125; return solve(1, 1, q), 0; &#125; [CF603E] Pastoral Oddities Portal. 满足题目条件意味着所有连通块的大小都是偶数。将边按照权值从小到大排序，然后线段树分治从右到左依次处理每一条边，计算每一条边可以被记入答案的范围。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, ans[300005]; struct edge &#123; int u, v, w, id; bool operator&lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[300005]; int fa[300005], siz[300005]; struct Node &#123; int x, y, s, t; &#125; st[300005]; int tot, odd; int find(int x) &#123; return fa[x] == x ? x : find(fa[x]); &#125; void merge(int x, int y) &#123; x = find(x); y = find(y); if (x == y) return; if (siz[x] > siz[y]) swap(x, y); st[++tot] = &#123;x, y, siz[x]&#125;; if (siz[x] % 2 &amp;&amp; siz[y] % 2) odd -= 2, st[tot].t += 2; fa[x] = y; siz[y] += siz[x]; &#125; vector&lt;int> T[1200005]; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].push_back(k), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); &#125; int pos; void solve(int o, int l, int r) &#123; int lst = tot; for (int i : T[o]) merge(e[i].u, e[i].v); if (l == r) &#123; while (1) &#123; if (odd == 0 || pos == m) break; if (e[pos + 1].id &lt;= l) &#123; merge(e[pos + 1].u, e[pos + 1].v); if (e[pos + 1].id &lt; l) update(1, 1, m, e[pos + 1].id, l - 1, pos + 1); &#125; ++pos; &#125; ans[l] = (odd ? -1 : e[pos].w); &#125; else &#123; int mid = l + r >> 1; solve(o &lt;&lt; 1 | 1, mid + 1, r); solve(o &lt;&lt; 1, l, mid); &#125; for (; tot > lst; --tot) &#123; int x = st[tot].x, y = st[tot].y, s = st[tot].s, t = st[tot].t; fa[x] = x, siz[y] -= s, odd += t; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); odd = n; for (int i = 1; i &lt;= n; ++i) fa[i] = i, siz[i] = 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w), e[i].id = i; sort(e + 1, e + m + 1); solve(1, 1, m); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; 随机化算法 比较有趣。 [CF1305F] Kuroni and the Punishment Portal. 发现答案至多为 nnn，因此方案中不变、+1/−1+1/-1+1/−1 的数至少有一半，随机钦定这些数，答案必定是它们的质因数的倍数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; i64 a[200005], ans = 1e18; mt19937 Rand(time(0)); void getAns(i64 x) &#123; // 全部变为 x 的倍数 i64 res = 0; for (int i = 1; i &lt;= n; ++i) &#123; i64 t = x - a[i] % x; if (a[i] >= x) t = min(t, a[i] % x); res += t; &#125; ans = min(ans, res); &#125; void work(i64 x) &#123; // x 的全部质因数可能成为答案 for (i64 i = 2; i * i &lt;= x; ++i) if (x % i == 0) &#123; getAns(i); while (x % i == 0) x /= i; &#125; if (x > 1) getAns(x); &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; shuffle(a + 1, a + n + 1, Rand); for (int i = 1; i &lt;= min(n, 50); ++i) &#123; if (a[i] > 1) work(a[i] - 1); work(a[i]); work(a[i] + 1); &#125; return cout &lt;&lt; ans &lt;&lt; \"\\n\", 0; &#125; [THUSCH2017] 巧克力 Portal. 如果颜色数比较少的话直接用斯坦纳树做，但是颜色数很多，钦定的可能也很多。 这种 NPC 问题可以直接考虑乱搞，kkk 很小，因此考虑将所有颜色随机映射到 [0,k)[0,k)[0,k)，然后求最小斯坦纳树即可求出最小的巧克力个数 www。这 kkk 个点被分配到不同的颜色时答案合法，正确概率是 k!/kkk!/k^kk!/kk。随机化做 200200200 次即可。 然后二分出中位数，将小于等于二分值的权值都设为 inf−1inf-1inf−1，大于的都设为 inf+1inf+1inf+1，然后最小斯坦纳树要 ≤w×inf\\le w\\times inf≤w×inf（infinfinf 设置为一个不会影响斯坦纳树选择的巧克力数的一个数即可）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; const int DX[] = &#123;-1, 1, 0, 0&#125;, DY[] = &#123;0, 0, 1, -1&#125;; int n, m, k, tot; int c[240][240], a[240][240], w[240][240]; int cc[240], f[240][240][32], to[240]; bool inq[240][240]; mt19937 Rand(time(0)); queue&lt;pair&lt;int, int>> q; void SPFA(int s) &#123; while (!q.empty()) &#123; auto u = q.front(); q.pop(); int x = u.first, y = u.second; inq[x][y] = 0; for (int i = 0; i &lt; 4; ++i) &#123; int tx = x + DX[i], ty = y + DY[i]; if (tx &lt; 1 || tx > n || ty &lt; 1 || ty > m || c[tx][ty] == -1) continue; if (f[tx][ty][s] > f[x][y][s] + w[tx][ty]) &#123; f[tx][ty][s] = f[x][y][s] + w[tx][ty]; if (!inq[tx][ty]) q.emplace(tx, ty), inq[tx][ty] = 1; &#125; &#125; &#125; &#125; int work(void) &#123; // 选择 k 个点的最小代价 int ans = INF; for (int opt = 1; opt &lt;= 200; ++opt) &#123; shuffle(cc + 1, cc + tot + 1, Rand); for (int i = 1; i &lt;= tot; ++i) to[cc[i]] = (i - 1) % k; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; for (int s = 1; s &lt; 1 &lt;&lt; k; ++s) f[i][j][s] = INF; if (c[i][j] != -1) f[i][j][1 &lt;&lt; to[c[i][j]]] = w[i][j]; &#125; for (int s = 1; s &lt; 1 &lt;&lt; k; ++s) &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (c[i][j] != -1) &#123; for (int t = s - 1 &amp; s; t; t = t - 1 &amp; s) f[i][j][s] = min(f[i][j][s], f[i][j][t] + f[i][j][s ^ t] - w[i][j]); if (f[i][j][s] &lt; INF) q.emplace(i, j), inq[i][j] = 1; &#125; SPFA(s); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) ans = min(ans, f[i][j][(1 &lt;&lt; k) - 1]); &#125; return ans; &#125; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); tot = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;c[i][j]); if (c[i][j] != -1) cc[++tot] = c[i][j]; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[i][j]), w[i][j] = 1; sort(cc + 1, cc + tot + 1); tot = unique(cc + 1, cc + tot + 1) - (cc + 1); int rec = work(); if (rec == INF) return puts(\"-1 -1\"), void(); int L = 0, R = 1000001; while (L + 1 != R) &#123; int mid = L + R >> 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) w[i][j] = (a[i][j] &lt;= mid ? 54289 : 54291); if (work() &lt;= rec * 54290) R = mid; else L = mid; &#125; printf(\"%d %d\\n\", rec, R); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; 根号分治 就是针对根号的分类讨论，或者针对两种数据范围给出不同的解法。 [CF797E] Array Queries Portal. 当 k≥nk\\ge \\sqrt{n}k≥n​ 时暴力，否则预处理出答案。时间复杂度 O(nn)O(n\\sqrt{n})O(nn​)。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int BLOCK_SIZE = 200; int n, m; int a[100005], f[205][100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int k = 1; k &lt; BLOCK_SIZE; ++k) for (int p = n; p >= 1; --p) f[k][p] = (p + a[p] + k > n ? 1 : f[k][p + a[p] + k] + 1); scanf(\"%d\", &amp;m); while (m--) &#123; int p, k; scanf(\"%d%d\", &amp;p, &amp;k); if (k >= BLOCK_SIZE) &#123; int res = 0; while (p &lt;= n) p += a[p] + k, ++res; printf(\"%d\\n\", res); &#125; else printf(\"%d\\n\", f[k][p]); &#125; return 0; &#125; [CF710F] String Set Queries Portal. 不同长度的字符串最多只有 n\\sqrt{n}n​ 个，对每一个开一个 multiset 统计出现次数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 B = 10079, P = 110765311; const int N = 300000; int n, id[300005], tot, rev[300005]; char s[300005]; i64 b[300005], h[300005]; unordered_multiset&lt;i64> H[805]; int main(void) &#123; int m, op; scanf(\"%d\", &amp;m); for (int i = b[0] = 1; i &lt;= N; ++i) b[i] = b[i - 1] * B % P; while (m--) &#123; scanf(\"%d%s\", &amp;op, s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) h[i] = (h[i - 1] * B + s[i]) % P; if (op == 1) &#123; if (!id[n]) rev[id[n] = ++tot] = n; H[id[n]].insert(h[n]); &#125; else if (op == 2) H[id[n]].erase(h[n]); else &#123; int ans = 0; for (int i = 1, L; i &lt;= tot; ++i) for (int j = L = rev[i]; j &lt;= n; ++j) ans += H[i].count((h[j] - h[j - L] * b[L] % P + P) % P); printf(\"%d\\n\", ans); fflush(stdout); &#125; &#125; return 0; &#125; [CF1446D2] Frequency Problem (Hard Version) Portal. 首先一个结论：其中一定有一个众数是全局众数。否则一定可以扩展这个子段使得全局众数变为其中之一。 采用根号分治，如果一个数的出现次数大于 n\\sqrt{n}n​，那么可以直接扫描序列，记录一个 resresres 代表全局众数和当前选择数的差值，记录可以取到这个差值的位置最小值就是候选答案子段的左侧。 否则，枚举出现次数 xxx，然后用双指针扫描序列，RRR 往右走，LLL 是满足所有数的出现次数都 ≤x\\le x≤x 的最左端，如果出现次数为 xxx 的数的个数至少为 222，那么当前子段可以成为答案。 时间复杂度 O(nn)O(n\\sqrt{n})O(nn​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, t; int a[200005], cnt[200005]; int tmp[400005]; int main(void) &#123; scanf(\"%d\", &amp;n); t = sqrt(n); int ans = 0, mode = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i), ++cnt[a[i]]; if (cnt[a[i]] > cnt[mode]) mode = a[i]; &#125; for (int x = 1; x &lt;= n; ++x) if (cnt[x] > t) &#123; // 出现次数大于 sqrt n if (x == mode) continue; int res = 0; memset(tmp, 0, sizeof tmp); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] == mode) ++res; else if (a[i] == x) --res; if (tmp[res + n] || res == 0) ans = max(ans, i - tmp[res + n]); else tmp[res + n] = i; &#125; &#125; for (int x = 1; x &lt;= t; ++x) &#123; // 枚举出现次数 x int L = 1, res = 0; memset(tmp, 0, sizeof tmp); // i 的出现次数 for (int R = 1; R &lt;= n; ++R) &#123; if (++tmp[a[R]] == x) ++res; for (; L &lt;= R &amp;&amp; tmp[a[R]] > x; ++L) if (tmp[a[L]]-- == x) --res; if (res >= 2) ans = max(ans, R - L + 1); &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; [Ynoi2011] 初始化 Portal. 将原序列按照 BBB 分块，对于 x≥Bx\\ge Bx≥B 的时候可以直接暴力修改，否则对于不同的 xxx 可以按照 xxx 分块，对于一个块内修改前后缀和（单点修改区间查询转化成区间修改单点查询）。 时间复杂度 O(nn)O(n\\sqrt{n})O(nn​)，但是块长可以调小，因为暴力常数很小。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; const int BLOCK_SIZE = 110; inline void add(int &amp;x, int t) &#123; x += t; if (x >= P) x -= P; &#125; inline void del(int &amp;x, int t) &#123; x -= t; if (x &lt; 0) x += P; &#125; int n, m, a[200005], sum[3005]; int pos[200005], L[3005], R[3005]; int pre[155][155], suf[155][155]; int query(int l, int r) &#123; int p = pos[l], q = pos[r], res = 0; if (p == q) for (int i = l; i &lt;= r; ++i) add(res, a[i]); else &#123; for (int i = L[q]; i &lt;= r; ++i) add(res, a[i]); for (int i = R[p]; i >= l; --i) add(res, a[i]); for (int i = p + 1; i &lt; q; ++i) add(res, sum[i]); &#125; return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int t = n / BLOCK_SIZE; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; if (R[t] &lt; n) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = n; &#125; for (int i = 1; i &lt;= t; ++i) for (int j = L[i]; j &lt;= R[i]; ++j) pos[j] = i, add(sum[i], a[j]); while (m--) &#123; int op; scanf(\"%d\", &amp;op); if (op == 1) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); if (x >= BLOCK_SIZE) for (int i = y; i &lt;= n; i += x) add(a[i], z), add(sum[pos[i]], z); else &#123; for (int i = 1; i &lt;= y; ++i) add(suf[x][i], z); for (int i = y; i &lt;= x; ++i) add(pre[x][i], z); &#125; &#125; else &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); int ans = query(l, r); for (int i = 1; i &lt; BLOCK_SIZE; ++i) &#123; int p = (l - 1) / i + 1, q = (r - 1) / i + 1; if (p == q) &#123; del(ans, pre[i][(l - 1) % i]); add(ans, pre[i][(r - 1) % i + 1]); &#125; else &#123; add(ans, 1ll * (q - p - 1) * pre[i][i] % P); add(ans, pre[i][(r - 1) % i + 1]); add(ans, suf[i][(l - 1) % i + 1]); &#125; &#125; printf(\"%d\\n\", (ans % P + P) % P); &#125; &#125; return 0; &#125; [CF1039D] You Are Given a Tree Portal. 如果 kkk 给定，那么考虑 O(n)O(n)O(n) 树形 DP（因为只要能选一定不劣）就可解决。 发现答案的取值比较少。考虑根号分治，对于小于等于阈值的部分可以直接 O(n)O(n)O(n) 树形 DP 解决（需要卡常，考虑转到 DFS 序上 DP）。 大于阈值的部分发现答案只有 nB\\cfrac{n}{B}Bn​ 种，考虑二分哪些部分的答案是一样的，只会进行 nB\\cfrac n BBn​ 次二分，时间复杂度为 O(nBnlog⁡n)O(\\cfrac n B n\\log n)O(Bn​nlogn)。 取 B=nlog⁡nB=\\sqrt{n\\log n}B=nlogn​，理论最优时间复杂度为 O(nnlog⁡n)O(n\\sqrt{n\\log n})O(nnlogn​)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int BLOCK_SIZE = 600; int n, ans[100005]; int fa[100005], num, idx[100005]; int f[100005]; vector&lt;int> G[100005]; void dfs(int x, int fa) &#123; ::fa[x] = fa; for (int y : G[x]) if (y != fa) dfs(y, x); idx[++num] = x; &#125; int solve(int k) &#123; int res = 0; f[0] = -1; for (int i = 1; i &lt;= n; ++i) f[i] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int x = idx[i]; if (f[fa[x]] != -1 &amp;&amp; f[x] != -1) &#123; if (f[x] + f[fa[x]] >= k) ++res, f[fa[x]] = -1; else f[fa[x]] = max(f[fa[x]], f[x] + 1); &#125; &#125; return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; ans[1] = n; dfs(1, 0); for (int k = 2; k &lt;= BLOCK_SIZE; ++k) ans[k] = solve(k); for (int k = BLOCK_SIZE + 1; k &lt;= n; ) &#123; int L = k - 1, R = n + 1, res = solve(k); while (L + 1 != R) &#123; int mid = L + R >> 1; if (res == solve(mid)) L = mid; else R = mid; &#125; for (int i = k; i &lt;= L; ++i) ans[i] = res; k = R; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"网络流问题","slug":"notes/图论/flow","date":"2022-12-07T00:00:00.000Z","updated":"2022-12-07T00:00:00.000Z","comments":true,"path":"ecebf309/","link":"","permalink":"https://james1badcreeper.github.io/ecebf309/","excerpt":"网络流是个很有用的东西，很多问题都可以转化为网络流。","text":"网络流是个很有用的东西，很多问题都可以转化为网络流。 目前本文会很快切入建图，证明什么有时间再补。 概述 一个网络是一张有向图 G=(V,E)G=(V,E)G=(V,E)，对于每条有向边 (u,v)∈E(u,v)\\in E(u,v)∈E 存在容量限制 c(u,v)c(u,v)c(u,v)，当 (u,v)∉E(u,v)\\not\\in E(u,v)∈E 时，c(u,v)=0c(u,v)=0c(u,v)=0。网络的可行流分为有源汇（指定了两个节点 s,ts,ts,t，代表图的源点和汇点）和无源汇，但是都存在一个定义域为节点二元组的流函数 f(x,y)f(x,y)f(x,y)，f(x,y)f(x,y)f(x,y) 代表边 x→yx\\rightarrow yx→y 的流量，满足： fff 满足容量限制：f(x,y)≤c(x,y)f(x,y)\\le c(x,y)f(x,y)≤c(x,y)，当两者相等时，x→yx\\rightarrow yx→y 就流满了； 斜对称性质：f(x,y)=−f(y,x)f(x,y)=-f(y,x)f(x,y)=−f(y,x)，也就是说，反向边其实是负的流量[1]； 流量守恒：除源点和汇点外（当然只限于有源汇可以除了这两个节点），从每个节点流入和流出的流量相等，即 ∀i≠s,t,∑f(u,i)=∑f(i,v)\\forall i\\ne s,t,\\sum f(u,i)=\\sum f(i,v)∀i=s,t,∑f(u,i)=∑f(i,v)，也就是说，每个节点不储存流量，进去多少就流出来多少。 以下是一些定义： 对于有源汇，有 ∑f(S,i)=∑f(i,T)\\sum f(S,i)=\\sum f(i,T)∑f(S,i)=∑f(i,T)，此时这个相等的和成为当前流 fff 的流量。 定义流 fff 在网络 GGG 上的残量网络 Gf=(V,Ef)G_f=(V,E_f)Gf​=(V,Ef​) 为容量函数 cf=c−fc_f=c-fcf​=c−f。根据容量限制，cf(x,y)≥0c_f(x,y)\\ge 0cf​(x,y)≥0，当 cf(x,y)=0c_f(x,y)=0cf​(x,y)=0 时，则视为 x→yx\\rightarrow yx→y 在残量网络上不存在。也就是说，在残量网络中我们要删掉满流边。 定义增广路 PPP 是残量网络 GfG_fGf​ 上源点到汇点的一条路径，而无源汇则没有增广路。 将点集分为两个互补相交的 A,BA,BA,B，且满足 S∈A,T∈BS\\in A, T\\in BS∈A,T∈B，这种划分方式称为割，割的容量为 ∑u∈A∑v∈Bc(u,v)\\sum_{u\\in A}\\sum_{v\\in B}c(u,v)∑u∈A​∑v∈B​c(u,v)，流量为 ∑u∈A∑v∈Bf(u,v)\\sum_{u\\in A}\\sum_{v\\in B}f(u,v)∑u∈A​∑v∈B​f(u,v)。如果 u∈A,v∈Bu\\in A,v\\in Bu∈A,v∈B，那么 (u,v)(u,v)(u,v) 是割边，可以看出，割边一般不止一条。 接下来讨论的内容默认都是有源流！ 最大流问题 最大流是求一个网络的最大流量。 增广 找到一条残量网络 GfG_fGf​ 上的增广路 PPP，并为 PPP 上的每一条边增加 cf(P)=min⁡(u,v)∈Pcf(u,v)c_f(P)=\\min_{(u,v)\\in P}c_f(u,v)cf​(P)=min(u,v)∈P​cf​(u,v) 的流量。也就是说，流量能流满就能流满。这一过程称之为增广。 怎样证明这个贪心策略？不需要！实际上在当前边的流量增加 cf(x,y)c_f(x,y)cf​(x,y) 时，我们要给它的反向边的容量增加 cf(y,x)c_f(y,x)cf​(y,x)，其实这是一个反悔贪心的策略，可以回收原来的流量，正确性得以保证。 最大流最小割定理 割中割边容量和最小的划分方式称为最小割，而且最大流等于最小割。证明如下： 存在一组流的流量等于一组割的容量：只需要让割边流满即可，最大流存在的时候残量网络不连通，也就提供了一组割。 任意一组流的流量不大于任意一组割的容量。如果割掉这些边，那么网络流量尚未最大化，仍然可以找到增广路，与最大流的求解方式矛盾。 Dinic 算法 Edmonds-Karp 和其他高级算法在本文中不会出现，只会介绍 Dinic。 模板。 Dinic 会不断进行 bfs 来在残量网络上构造分层图（根据节点的层次 d[x]d[x]d[x]，从 SSS 到 xxx 最少需要经过的边数），然后在分层图上进行 dfs 寻找增广路。时间复杂度为 O(n2m)O(n^2m)O(n2m)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 1e18; struct edge &#123; int u, v, w; edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; &#125;; int n, m, s, t, d[1205], cur[1205]; // cur 为当前弧下标 vector&lt;int> G[1205]; vector&lt;edge> edges; inline void addedge(int u, int v, int w) &#123; edges.emplace_back(edge(u, v, w)); G[u].emplace_back(edges.size() - 1); &#125; bool bfs(void) &#123; memset(cur, 0, sizeof(cur)); memset(d, -1, sizeof(d)); queue&lt;int> q; q.push(s); d[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; q.push(e.v); d[e.v] = d[u] + 1; if (e.v == t) return true; &#125; &#125; &#125; return false; &#125; i64 dinic(int x, i64 res) &#123; if (x == t || res == 0) return res; i64 flow = 0; for (int i = cur[x]; i &lt; G[x].size() &amp;&amp; res; ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; i64 c = min(res, (i64)e.w); if (d[e.v] == d[x] + 1 &amp;&amp; c) &#123; i64 k = dinic(e.v, c); flow += k; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; return flow; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, 0); &#125; i64 flow = 0, maxflow = 0; while (bfs()) while (flow = dinic(s, INF)) maxflow += flow; printf(\"%lld\\n\", maxflow); return 0; &#125; 无负环费用流 指的是最小费用最大流，也就是说，在原有网络的基础上，每一条边多了一个权值 w(x,y)w(x,y)w(x,y)，要求在保证最大流前提下，找出 ∑(x,y)∈Ef(x,y)×w(x,y)\\sum_{(x,y)\\in E} f(x,y)\\times w(x,y)∑(x,y)∈E​f(x,y)×w(x,y) 的最小值。通常使用 SPP 算法解决这个问题。 SSP 实现时只需要将 Dinic 的 bfs 替换为 SPFA 即可（每条边的长度为权值 www）。相应的地方改一下即可。理论上限时间复杂度很高，但是实际表现不错，而且业界公约不卡。 模板，代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const i64 INF = 1e18; struct edge &#123; int u, v, w, c; edge(int u = 0, int v = 0, int w = 0, int c = 0) : u(u), v(v), w(w), c(c) &#123;&#125; &#125;; int n, m, s, t, cur[5005], d[5005]; bool inq[5005]; vector&lt;int> G[5005]; vector&lt;edge> edges; inline void addedge(int u, int v, int w, int c) &#123; edges.emplace_back(edge(u, v, w, c)); G[u].emplace_back(edges.size() - 1); &#125; bool SPFA(void) &#123; memset(cur, 0, sizeof(cur)); memset(d, 0x3f, sizeof(d)); queue&lt;int> q; q.push(s); d[s] = 0; inq[s] = true; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] > d[u] + e.c) &#123; d[e.v] = d[u] + e.c; if (!inq[e.v]) q.push(e.v), inq[e.v] = true; &#125; &#125; &#125; return d[t] &lt; 0x3f3f3f3f; &#125; i64 cost; bool vis[5005]; i64 dinic(int x, i64 res) &#123; if (x == t) return res; i64 flow = 0; vis[x] = true; for (int i = cur[x]; i &lt; G[x].size() &amp;&amp; res; ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; i64 c = min(res, i64(e.w)); if (!vis[e.v] &amp;&amp; c &amp;&amp; d[e.v] == d[x] + e.c) &#123; i64 k = dinic(e.v, c); flow += k; cost += k * e.c; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = 0x3f3f3f3f; vis[x] = false; return flow; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); while (m--) &#123; int u, v, w, c; scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;w, &amp;c); addedge(u, v, w, c); addedge(v, u, 0, -c); &#125; i64 maxflow = 0, flow; while (SPFA()) while (flow = dinic(s, INF)) maxflow += flow; printf(\"%lld %lld\\n\", maxflow, cost); return 0; &#125; 解题思路 网络流本质上是一种反悔贪心，将贪心的反悔策略用一条反向边简单的表示。在解题时，关键在于找到题目中的方案和一种流或割对应。我们来看一个例子： [SHOI2007] 善意的投票。幼儿园里有 nnn 个小朋友打算通过投票来决定睡不睡午觉。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。给出每个小朋友的意愿和每一对好朋友。我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？输出可能的最小冲突数。对于 100%100\\%100% 的数据，2≤n≤3002\\le n\\le3002≤n≤300，1≤m≤n(n−1)21\\le m \\le \\frac{n(n-1)}21≤m≤2n(n−1)​。 这看起来很像一个最小割的模型，考虑如何使用一组割来表示一种意见方案。每割掉一条边需要付出 111 的代价。于是将支持的小朋友与 SSS 连边，反对的小朋友与 TTT 连边，每对朋友之间连边，求出图的最小割即可。这其实是一个集合划分模型。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; struct edge &#123; int u, v, w; edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; &#125;; vector&lt;edge> edges; vector&lt;int> G[305]; int d[305], cur[305]; inline void addedge(int u, int v, int w) &#123; edges.emplace_back(edge(u, v, w)); G[u].emplace_back(edges.size() - 1); &#125; bool bfs(void) &#123; memset(d, -1, sizeof(d)); memset(cur, 0, sizeof(cur)); queue&lt;int> q; q.push(0); d[0] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; q.push(e.v); d[e.v] = d[u] + 1; if (e.v == n + 1) return true; &#125; &#125; &#125; return false; &#125; int dinic(int x, int res) &#123; if (x == n + 1 || res == 0) return res; int flow = 0; for (int i = cur[x]; i &lt; G[x].size(); ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; int c = min(res, e.w); if (d[e.v] == d[x] + 1 &amp;&amp; c) &#123; int k = dinic(e.v, c); flow += k; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; return flow; &#125; int type[305]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", type + i); if (type[i]) addedge(0, i, 1), addedge(i, 1, 0); else addedge(i, n + 1, 1), addedge(n + 1, i, 0); &#125; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (type[u] == 0 &amp;&amp; type[v] == 1) swap(u, v); addedge(u, v, 1); addedge(v, u, 0); &#125; int flow = 0, maxflow = 0; while (bfs()) while (flow = dinic(0, 1e9)) maxflow += flow; printf(\"%d\\n\", maxflow); return 0; &#125; 如果要求输出集合划分模型的一组方案，那么就看残余网络上的 sss 到每个点的距离。如果能走到就是在 AAA，否则就是在 BBB。 上下界网络流 有的题目的流量限制除了有上界，还有下界。 网络流常见模型 我们来看一些网络流的常见模型。 点边转化 | 最小割点 如果删去点 iii 有代价 wiw_iwi​，求使得 S,TS,TS,T 不连通的最小代价？ 将每个点拆成入点 iini_{in}iin​ 和出点 iouti_{out}iout​，在它们之间连一条容量为 wiw_iwi​ 的边，表示删去这个点。对于原图的每一条边 u,vu,vu,v，连接 uout→vinu_{out}\\rightarrow v_{in}uout​→vin​ 一条 +∞+\\infty+∞ 容量的边，这样我们只能删点而不会割边。 集合划分模型 这个内容非常常见。 min⁡x1,x2,⋯xn∈{0,1}∑(u,v)∈Ecu,vxuxv‾+∑uauxu+buxu‾\\min_{x_1,x_2,\\cdots x_n\\in\\{0,1\\}}\\sum_{(u,v)\\in E} c_{u,v}x_u\\overline{x_v}+\\sum_{u}a_ux_u+b_u\\overline{x_u} x1​,x2​,⋯xn​∈{0,1}min​(u,v)∈E∑​cu,v​xu​xv​​+u∑​au​xu​+bu​xu​​ 说的就是为 xix_ixi​ 选定合适的值，使得和式的值最小。 连 S→iS\\rightarrow iS→i 的容量为 bib_ibi​ 的边，i→Ti\\rightarrow Ti→T 的容量为 aia_iai​ 的边。如果割掉了 i→Ti\\rightarrow Ti→T，说明将 iii 划分到了集合 AAA，代价为 aia_iai​。 给 u,vu,vu,v 连容量限制为 cu,vc_{u,v}cu,v​ 的双向边，这样如果 u,vu,vu,v 不属于同一集合，至少会割掉其中一条边。 这样这个网络的最小割就是答案。 还有一种限制：xxx 在集合 AAA 且 yyy 在集合 BBB 时有代价 www，那么连 x→yx\\rightarrow yx→y 的容量为 www 的边，这样如果 xxx 和 SSS 相连且 yyy 和 TTT 相连，那么这条边需要被割掉。 如何输出方案？要注意什么是割边：在最后的残量网络上 d(x)d(x)d(x) 是否存在，存在则属于集合 AAA，否则是集合 BBB。 最大权闭合子图 一张有向图 G=(V,E)G=(V,E)G=(V,E) 的闭合子图 G′G&#x27;G′ 定义在点集 V′⊆VV&#x27;\\subseteq VV′⊆V 上，一个点集 V′V&#x27;V′ 符合要求当且仅当 V′V&#x27;V′ 内部每个点的所有出边仍指向 V′V&#x27;V′，即点集内部每个点在有向图上能够到达的点仍然属于该点集。 而最大权闭合子图则是每个点有点权，求闭合子图的最大权值。 考虑集合划分模型，对于每个节点，可以将其划分到选或不选的集合中，也就是 S→iS\\rightarrow iS→i 连 000，i→Ti\\rightarrow Ti→T 连 wiw_iwi​。如果 (u,v)∈E(u,v)\\in E(u,v)∈E，就是如果 uuu 分到选的集合中，vvv 也必须分到选的集合中，即 u→vu\\rightarrow vu→v 有容量 −∞-\\infty−∞，求网络的最大割即可。 但是最大割是 NPH 的，因此考虑取相反数求最小割。然而这样会出现负容量的边！将负容量的边改到 S→iS\\rightarrow iS→i 来连。这样答案为所有正权值的和减去最小割即可。 模板，代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; int m, n, ans; struct edge &#123; int v, w; edge(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; struct Graph &#123; int S, T, cur[205], d[205]; vector&lt;edge> edges; vector&lt;int> G[205]; inline void addedge(int u, int v, int w) &#123; edges.emplace_back(edge(v, w)); G[u].emplace_back(edges.size() - 1); edges.emplace_back(edge(u, 0)); G[v].emplace_back(edges.size() - 1); &#125; bool bfs(void) &#123; memset(cur, 0, sizeof cur); memset(d, -1, sizeof d); queue&lt;int> q; q.push(S); d[S] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; d[e.v] = d[u] + 1; q.push(e.v); if (e.v == T) return true; &#125; &#125; &#125; return false; &#125; int dinic(int x, int res) &#123; if (x == T) return res; int flow = 0; for (int i = cur[x]; i &lt; G[x].size() &amp;&amp; res; ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; int c = min(res, e.w); if (d[e.v] == d[x] + 1 &amp;&amp; c) &#123; int k = dinic(e.v, c); flow += k; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; return flow; &#125; int maxFlow(int s, int t) &#123; S = s, T = t; int flow, maxflow = 0; while (bfs()) while (flow = dinic(S, 1e9)) maxflow += flow; return maxflow; &#125; &#125; G; int main(void) &#123; scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) &#123; int w, x; scanf(\"%d\", &amp;w); G.addedge(0, i, w); ans += w; while (scanf(\"%d\", &amp;x) == 1 &amp;&amp; x) G.addedge(i, x + m, 1e9); &#125; for (int i = 1, w; i &lt;= n; ++i) scanf(\"%d\", &amp;w), G.addedge(i + m, n + m + 1, w); printf(\"%d\\n\", ans - G.maxFlow(0, n + m + 1)); return 0; &#125; 二分图 设无向图 G=(V,E)G=(V,E)G=(V,E)，若能够将 VVV 分成两个点集 V1,V2V_1,V_2V1​,V2​ 满足 V1∩V2=∅,V1∪V2=VV_1\\cap V_2=\\varnothing,V_1\\cup V_2=VV1​∩V2​=∅,V1​∪V2​=V 且 ∀(u,v)∈E,u∈V1,v∈V2\\forall(u,v)\\in E,u\\in V_1,v\\in V_2∀(u,v)∈E,u∈V1​,v∈V2​（也可以反过来），这样 GGG 是一张二分图，V1,V2V_1,V_2V1​,V2​ 分别称为左部点和右部点。 二分图的充要条件是不存在奇环，这样我们可以给二分图进行黑白染色。 从某个点开始 DFS，遍历当前点 uuu 和邻居 vvv，如果 vvv 未被访问，则 vvv 的颜色与 uuu 相反；如果访问过，说明存在奇环。 二分图匹配 给定二分图 G=(V,E)G=(V,E)G=(V,E)，若边集 M⊆EM\\subseteq EM⊆E 满足 MMM 中任意两条边不交于同一端点，则称 MMM 是 GGG 的一组匹配，其大小为 ∣M∣|M|∣M∣。 特别的，若 ∣V1∣=∣V2∣,∣M∣=∣V1∣|V_1|=|V_2|,|M|=|V_1|∣V1​∣=∣V2​∣,∣M∣=∣V1​∣，则称 MMM 为完美匹配。 最大匹配 我们希望求出边集 MMM 的最大大小。 显然，我们从 SSS 向 V1V_1V1​ 的所有点连一条 111 的边，V2V_2V2​ 向 TTT 连一条 111 的边，根据 EEE 从 V1V_1V1​ 向 V2V_2V2​ 连边，跑最大流即可。在这里 Dinic 的时间复杂度为 O(mn)O(m\\sqrt{n})O(mn​)。 最大多重匹配 即节点 uuu 不能与超过 LuL_uLu​ 条边相连，这样只需要将每个点与源点或汇点的容量设为 LuL_uLu​ 即可。时间复杂度依然正确。 匈牙利算法 匈牙利算法可以以 O(nm)O(nm)O(nm) 的时间复杂度解决二分图的最大匹配问题。 工作过程如下： 加入一个左部点 uuu，然后让 uuu 去尝试匹配。 如果 uuu，已经匹配，则增广失败。 遍历 uuu 能到达的所有右部点 vvv： yyy 被访问过了，那么直接再见。 yyy 没被匹配，让 xxx 匹配 yyy，增广成功。 yyy 被匹配，考虑 yyy 原来匹配的 x′x&#x27;x′，如果 x′x&#x27;x′ 还能够成功匹配，那么改为让 yyy 匹配 xxx，形成新的增广路。 实际上，如果当前点失配，vis 数组是不需要清空的！模板，代码如下： int n, m, E, mch[505], vis[505]; vector&lt;int> G[505]; bool dfs(int x) &#123; if (vis[x]) return 0; vis[x] = 1; for (int y : G[x]) if (!mch[y] || dfs(mch[y])) return mch[y] = x, 1; return 0; &#125; int main(void) &#123; cin >> n >> m >> E; for(int i = 1; i &lt;= E; i++) &#123; int u, v; cin >> u >> v; G[u].push_back(v); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) if (dfs(i)) &#123; memset(vis, 0, sizeof(vis)); ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 二分图相关问题 二分图有一些常见问题。我们来看： 最小点覆盖集 给定二分图 G=(V,E)G=(V,E)G=(V,E)，若点集 C⊆VC\\subseteq VC⊆V 满足对于任意 (u,v)∈E(u,v)\\in E(u,v)∈E 都有 u∈Cu\\in Cu∈C 或 v∈Cv\\in Cv∈C，则称 CCC 是 GGG 的点覆盖集。 考虑一组点覆盖集，不存在边 (u,v)∈E(u,v)\\in E(u,v)∈E 使得 u,vu,vu,v 同时不属于 CCC，这是集合划分模型？但是有问题，我们要设置在同一个集合是代价是无穷的，集合划分模型没有这样的操作。 但是 GGG 是二分图，任意一条边连接两部点，因此考虑将一部分点的状态取反。即左部点与 SSS 不连通表示它不属于 CCC，但右部点与 SSS 连通表示它属于 CCC。这样限制就会变为，如果左部点 uuu 与 SSS 连通，u,vu,vu,v 之间有连边，但是右部点 vvv 与 TTT 连通，则 u,vu,vu,v 同时不属于 CCC，不合法。 我们将两部点之间的连边容量设为 +∞+\\infty+∞，对该网络求最大流，就是最小点覆盖集大小。由于每个点最多流入或流出 111 的流量，因此两部点之间的连边容量可以设为 111，这证明了最小点覆盖集大小等于最大匹配。 它可以求解这样的问题：对于每条限制 limlimlim 恰有两种方案 u,vu,vu,v 能满足，求最少需要选择多少种方案满足所有限制。 最大独立集 给定二分图 G=(V,E)G=(V,E)G=(V,E)，若点集 I⊆VI\\subseteq VI⊆V 满足任意两点不直接相连，则称 III 是 GGG 的独立集。二分图最大独立集等于 VVV 减去最小点覆盖集。 模板，代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; struct edge &#123; int v, w; edge(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; struct Graph &#123; int s, t, cur[1005], d[1005]; vector&lt;edge> edges; vector&lt;int> G[1005]; inline void addedge(int u, int v, int w) &#123; edges.emplace_back(v, w); G[u].emplace_back(edges.size() - 1); edges.emplace_back(u, 0); G[v].emplace_back(edges.size() - 1); &#125; bool bfs(void) &#123; memset(cur, 0, sizeof cur); memset(d, -1, sizeof d); queue&lt;int> q; q.push(s); d[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.w &amp;&amp; d[e.v] == -1) &#123; q.push(e.v); d[e.v] = d[u] + 1; if (e.v == t) return 1; &#125; &#125; &#125; return 0; &#125; int dinic(int x, int res) &#123; if (x == t) return res; int flow = 0; for (int i = cur[x]; i &lt; G[x].size(); ++i) &#123; edge &amp;e = edges[G[x][i]]; cur[x] = i; int c = min(res, e.w); if (d[e.v] == d[x] + 1 &amp;&amp; c) &#123; int k = dinic(e.v, c); flow += k; res -= k; edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k; &#125; &#125; if (!flow) d[x] = -1; return flow; &#125; int maxflow(int S, int T) &#123; s = S, t = T; int maxflow = 0, flow = 0; while (bfs()) while (flow = dinic(s, 1e9)) maxflow += flow; return maxflow; &#125; &#125; G; int col[1005]; vector&lt;int> E[1005]; void dfs(int x) &#123; if (col[x]) G.addedge(0, x, 1); else G.addedge(x, n + 1, 1); for (int y : E[x]) &#123; if (col[y] == -1) col[y] = col[x] ^ 1, dfs(y); if (col[x]) G.addedge(x, y, 1); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); ++u; ++v; E[u].emplace_back(v); E[v].emplace_back(u); &#125; memset(col, -1, sizeof col); for (int i = 1; i &lt;= n; ++i) if (col[i] == -1) col[i] = 1, dfs(i); printf(\"%d\\n\", n - G.maxflow(0, n + 1)); return 0; &#125; Problemset 最重要的还是那些经典模型，然后进行大量题目训练。 网络流 24 题 没有固定的顺序（但基本上按照难度排序）。虽然非常老，但是其中有些建模方式相当经典。 软件补丁问题 Portal. 状压来表示点即可，压根就不是网络流。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, d[1100005]; bool inq[1100005]; char s[25]; struct edge &#123; int u1, u2, v1, v2, t; &#125; e[105]; queue&lt;int> q; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%s\", &amp;e[i].t, s); for (int j = 0; j &lt; n; ++j) &#123; int t = (s[j] == '+' ? 1 : (s[j] == '-' ? 2 : 0)); if (t == 1) e[i].u1 |= (1 &lt;&lt; j); if (t == 2) e[i].u2 |= (1 &lt;&lt; j); &#125; scanf(\"%s\", s); for (int j = 0; j &lt; n; ++j) &#123; int t = (s[j] == '+' ? 2 : (s[j] == '-' ? 1 : 0)); if (t == 1) e[i].v1 |= (1 &lt;&lt; j); if (t == 2) e[i].v2 |= (1 &lt;&lt; j); &#125; &#125; q.push((1 &lt;&lt; n) - 1); inq[(1 &lt;&lt; n) - 1] = true; memset(d, 0x3f, sizeof(d)); d[(1 &lt;&lt; n) - 1] = 0; while (!q.empty()) &#123; int x = q.front(); q.pop(); inq[x] = false; for (int i = 1; i &lt;= m; ++i) if ((x &amp; e[i].u1) == e[i].u1 &amp;&amp; (x &amp; e[i].u2) == 0) &#123; int y = (x | e[i].v1 | e[i].v2) ^ e[i].v1; if (d[y] > d[x] + e[i].t) &#123; d[y] = d[x] + e[i].t; if (!inq[y]) q.push(y), inq[y] = true; &#125; &#125; &#125; if (d[0] == 0x3f3f3f3f) puts(\"0\"); else printf(\"%d\\n\", d[0]); return 0; &#125; 孤岛营救问题 将钥匙状压后 bfs 最短路即可，压根不是网络流。 Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; const int DX[4] = &#123;-1, 0, 0, 1&#125;, DY[4] = &#123;0, -1, 1, 0&#125;; int n, m, p, k, S; int key[15][15], e[15][15][15][15], d[15][15][2050]; struct Node &#123; int x, y, msk, d; &#125;; int main(void) &#123; memset(e, -1, sizeof e); scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;p, &amp;k); for (int i = 1; i &lt;= k; ++i) &#123; int a, b, c, d, x; scanf(\"%d%d%d%d%d\", &amp;a, &amp;b, &amp;c, &amp;d, &amp;x); --a; --b; --c; --d; e[a][b][c][d] = e[c][d][a][b] = x; &#125; cin >> S; for (int i = 1; i &lt;= S; ++i) &#123; int a, b, x; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;x); key[a - 1][b - 1] |= 1 &lt;&lt; x - 1; &#125; queue&lt;Node> q; memset(d, 0x3f, sizeof(d)); d[0][0][key[0][0]] = 0; q.push(&#123;0, 0, key[0][0], 0&#125;); while (!q.empty()) &#123; Node u = q.front(); q.pop(); if (u.x == n - 1 &amp;&amp; u.y == m - 1) return printf(\"%d\\n\", u.d), 0; for (int dir = 0; dir &lt; 4; ++dir) &#123; int x = u.x + DX[dir], y = u.y + DY[dir]; if (x &lt; 0 || y &lt; 0 || x >= n || y >= m) continue; int v = e[u.x][u.y][x][y], msk = u.msk | key[x][y]; if (d[x][y][msk] &lt; INF) continue; if (!v || v > 0 &amp;&amp; !(u.msk >> v - 1 &amp; 1)) continue; q.push(&#123;x, y, msk, d[x][y][msk] = u.d + 1&#125;); &#125; &#125; puts(\"-1\"); return 0; &#125; 试题库问题 Portal. 将试题看作左部点，类型看作右部点，每个试题向对应的类型连边。源点向试题连边，类型向汇点连边。 有解仅当最大流为 mmm，方案的输出可以根据哪些边流满来判断。 查看代码 int k, n, m; int main(void) &#123; scanf(\"%d%d\", &amp;k, &amp;n); int T = n + k + 1; for (int i = 1, v; i &lt;= k; ++i) &#123; scanf(\"%d\", &amp;v); m += v; g.addedge(n + i, T, v); &#125; for (int i = 1; i &lt;= n; ++i) &#123; g.addedge(0, i, 1); int p, k; scanf(\"%d\", &amp;p); while (p--) scanf(\"%d\", &amp;k), g.addedge(i, n + k, 1); &#125; if (g.maxflow(0, T) != m) return puts(\"No Solution!\"), 0; for (int i = 1; i &lt;= k; ++i) &#123; printf(\"%d: \", i); for (int j = 0; j &lt; g.G[n + i].size(); ++j) &#123; int it = g.edges[g.G[n + i][j]].v; if (it &lt;= n &amp;&amp; g.edges[g.G[n + i][j]].w) printf(\"%d \", it); &#125; putchar('\\n'); &#125; return 0; &#125; 飞行员配对方案问题 Portal. 二分图最大匹配模板。 查看代码 int n, m; int main(void) &#123; scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) G.addedge(0, i, 1); for (int i = m + 1; i &lt;= n; ++i) G.addedge(i, n + 1, 1); while (1) &#123; int x, y; cin >> x >> y; if (x == -1) break; G.addedge(x, y, 1); &#125; printf(\"%d\\n\", G.maxFlow(0, n + 1)); G.print(); return 0; &#125; 圆桌问题 Portal. 二分图最大多重匹配模板。 查看代码 int m, n, s; int main(void) &#123; scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1, r; i &lt;= m; ++i) scanf(\"%d\", &amp;r), G.addedge(0, i, r), s += r; for (int i = 1, c; i &lt;= n; ++i) scanf(\"%d\", &amp;c), G.addedge(m + i, n + m + 1, c); for (int u = 1; u &lt;= m; ++u) for (int v = m + 1; v &lt;= m + n; ++v) G.addedge(u, v, 1); if (G.maxFlow(0, n + m + 1) != s) return puts(\"0\"), 0; G.print(); return 0; &#125; 太空飞行计划问题 Portal. 将仪器和实验抽象成点，就是最大权闭合子图模板。 查看代码 int m, n; int main(void) &#123; cin >> m >> n; int t = m + n + 1, ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; int w, x; cin >> w; G.addedge(0, i, w); ans += w; string s; getline(cin, s); stringstream ss(s); while (ss >> x) G.addedge(i, x + m, 1e9); &#125; for (int i = 1, x; i &lt;= n; ++i) cin >> x, G.addedge(i + m, t, x); int flow = G.maxFlow(0, t); for (int i = 1; i &lt;= m; ++i) if (G.d[i] != -1) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\\n'; for (int i = 1; i &lt;= n; ++i) if (G.d[i + m] != -1) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\\n' &lt;&lt; ans - flow &lt;&lt; \"\\n\"; return 0; &#125; 骑士共存问题 Portal. 将棋盘上的点划分为左部点和右部点，使得骑士的位置和其能走到的位置在不同的点部。这样就成了二分图最大独立集的模板。 查看代码 const int DX[] = &#123;-2, -2, -1, -1, 1, 1, 2, 2&#125;; const int DY[] = &#123;-1, 1, -2, 2, -2, 2, -1, 1&#125;; int n, m; bool a[205][205]; int f(int i, int j) &#123; return (i - 1) * n + j; &#125; int main(void) &#123; cin >> n >> m; for (int i = 1, u, v; i &lt;= m; ++i) cin >> u >> v, a[u][v] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (!a[i][j]) &#123; if (i + j &amp; 1) &#123; G.addedge(0, f(i, j), 1); for (int k = 0; k &lt; 8; ++k) &#123; int x = i + DX[k], y = j + DY[k]; if (x > 0 &amp;&amp; y > 0 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n &amp;&amp; !a[x][y]) G.addedge(f(i, j), f(x, y), 1); &#125; &#125; else G.addedge(f(i, j), n * n + 1, 1); &#125; cout &lt;&lt; n * n - m - G.maxFlow(0, n * n + 1) &lt;&lt; \"\\n\"; return 0; &#125; 最长不下降子序列问题 Portal. 通过 DP 来求解答案，拆点限制一个点的使用次数。 查看代码 int n; int a[505], f[505]; int in(int x) &#123; return x * 2 - 1; &#125; int out(int x) &#123; return x * 2; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; i; ++j) if (a[i] >= a[j]) f[i] = max(f[i], f[j] + 1); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); if (ans == 1) return !printf(\"%d\\n%d\\n\", n, n); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) if (a[i] >= a[j] &amp;&amp; f[i] == f[j] + 1) G.addedge(out(j), in(i), 1); for (int i = 1; i &lt;= n; ++i) &#123; if (f[i] == 1) G.addedge(0, in(i), 1e9); if (f[i] == ans) G.addedge(out(i), n * 2 + 1, 1e9); &#125; E = G; for (int i = 1; i &lt;= n; ++i) &#123; G.addedge(in(i), out(i), 1); E.addedge(in(i), out(i), i == 1 || i == n ? n : 1); &#125; printf(\"%d\\n%d\\n\", G.maxFlow(0, n * 2 + 1), E.maxFlow(0, n * 2 + 1)); return 0; &#125; 最小路径覆盖问题 Portal. 将点拆成左点和右点，进行二分图最大匹配。每次多流上一个，就说明又有一对点连在了一起。最后 DFS 输出答案即可。 查看代码 int in[155], to[155]; void dfs(int x) &#123; printf(\"%d \", x); if (to[x]) dfs(to[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) G.addedge(0, i, 1); for (int i = 1; i &lt;= n; ++i) G.addedge(i + n, n * 2 + 1, 1); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G.addedge(u, v + n, 1); &#125; int ans = G.maxFlow(0, n * 2 + 1); for (int u = 1; u &lt;= n; ++u) for (int i : G.G[u]) &#123; int v = G.edges[i].v, w = G.edges[i].w; if (v > n &amp;&amp; w == 0) in[to[u] = v - n] = 1; &#125; for (int i = 1; i &lt;= n; ++i) if (!in[i]) dfs(i), putchar('\\n'); return !printf(\"%d\\n\", n - ans); &#125; 魔术球问题 Portal. 枚举数，然后连可以放在一起的数的边，发现就是最小路径覆盖问题。 查看代码 int in[100005], to[100005]; void dfs(int x) &#123; printf(\"%d \", x); if (to[x]) dfs(to[x]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); int t = 100001; for (int i = 1, flow = 0; ; ++i) &#123; G.addedge(0, i * 2 - 1, 1); G.addedge(i * 2, t, 1); for (int j = 1; j &lt; i; ++j) &#123; int d = sqrt(i + j); if (d * d == i + j) G.addedge(j * 2 - 1, i * 2, 1); &#125; flow += G.maxFlow(0, t); if (i - flow > n) &#123; printf(\"%d\\n\", i - 1); for (int u = 1; u &lt; i; ++u) for (int j : G.G[u * 2 - 1]) &#123; int v = G.edges[j].v / 2, w = G.edges[j].w; if (v &amp;&amp; v &lt; i &amp;&amp; w == 0) in[to[u] = v] = 1; &#125; for (int j = 1; j &lt; i; ++j) if (!in[j]) dfs(j), putchar('\\n'); return 0; &#125; &#125; return 0; &#125; 简单网络流 没有什么趣味性。 [USACO05NOV] Asteroids G Portal. 将行抽象成第一个条件，列抽象成第二个条件，就是二分图的最小点覆盖集。 查看代码 int n, k; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) G.addedge(0, i, 1), G.addedge(i + n, n * 2 + 1, 1); for (int i = 1; i &lt;= k; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G.addedge(x, y + n, 1); &#125; printf(\"%d\\n\", G.maxflow(0, n * 2 + 1)); return 0; &#125; [THUPC2022 初赛] 分组作业 Portal. 考虑集合划分模型。 唯一犯难的是这个喜欢关系，考虑将每个组也再建个点。如果组 iii 在最终的残量网络上与 SSS 相连则表示合作，与 TTT 相连则表示不合作。任何一个人不同意这个组就不合作，因此组向它的组员连 +∞+\\infty+∞ 的边，表示如果 SSS 与组这个点连通，说明合作，就只能断掉组员与 TTT 的连接。 将 BBB 向 AAA 对应的组连 aia_iai​ 的边，这样如果 BBB 同意了（它连向了 SSS），AAA 组没有合作（连向了 TTT），则要割掉 aia_iai​。类似地，BBB 的组向 AAA 连 bib_ibi​。 查看代码 int n, m; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n * 2; ++i) &#123; int c, d, e; scanf(\"%d%d%d\", &amp;c, &amp;d, &amp;e); G.addedge(0, i, d); G.addedge(i, n * 3 + 1, c); G.addedge(i, i % 2 == 0 ? i - 1 : i + 1, e); G.addedge(n * 2 + (i + 1) / 2, i, 1e18); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int A, B, a, b; scanf(\"%d%d%d%d\", &amp;A, &amp;B, &amp;a, &amp;b); G.addedge(B, n * 2 + (A + 1) / 2, a); G.addedge(n * 2 + (B + 1) / 2, A, b); &#125; printf(\"%lld\\n\", G.maxFlow(0, n * 3 + 1)); return 0; &#125; [Luogu P1402] 酒店之王 Portal. 其实是一个三分图匹配的结构，将人拆成两个点放在中间即可。 查看代码 int n, p, q; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> p >> q; int t = n + p + q + n + 1; for (int i = 1; i &lt;= p; ++i) G.addedge(0, i, 1); for (int i = 1; i &lt;= n; ++i) G.addedge(p + i, p + n + i, 1); for (int i = 1; i &lt;= q; ++i) G.addedge(p + n * 2 + i, t, 1); for (int i = 1, x; i &lt;= n; ++i) for (int j = 1; j &lt;= p; ++j) &#123; cin >> x; if (x) G.addedge(j, p + i, 1); &#125; for (int i = 1, x; i &lt;= n; ++i) for (int j = 1; j &lt;= q; ++j) &#123; cin >> x; if (x) G.addedge(p + n + i, p + n * 2 + j, 1); &#125; cout &lt;&lt; G.maxFlow(0, t) &lt;&lt; \"\\n\"; return 0; &#125; [Luogu P4313] 文理分科 Portal. 考虑用全部价值减去最小的需要割掉的价值。前面两种是容易处理的，后面两种只需要各建立一个虚点，然后与一个点关联的虚点向这个点连 +∞+\\infty+∞ 的边即可。 查看代码 int cal(int x, int y, int t) &#123; return (x - 1) * m + y + n * m * t; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int ans = 0, s = 0, t = n * m * 3 + 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;a[i][j]); ans += a[i][j]; G.addedge(s, cal(i, j, 0), a[i][j]); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;b[i][j]); ans += b[i][j]; G.addedge(cal(i, j, 0), t, b[i][j]); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;c[i][j]); ans += c[i][j]; G.addedge(s, cal(i, j, 1), c[i][j]); G.addedge(cal(i, j, 1), cal(i, j, 0), 1e9); if (i > 1) G.addedge(cal(i - 1, j, 1), cal(i, j, 0), 1e9); if (i &lt; n) G.addedge(cal(i + 1, j, 1), cal(i, j, 0), 1e9); if (j > 1) G.addedge(cal(i, j - 1, 1), cal(i, j, 0), 1e9); if (j &lt; m) G.addedge(cal(i, j + 1, 1), cal(i, j, 0), 1e9); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;d[i][j]); ans += d[i][j]; G.addedge(cal(i, j, 2), t, d[i][j]); G.addedge(cal(i, j, 0), cal(i, j, 2), 1e9); if (i > 1) G.addedge(cal(i - 1, j, 0), cal(i, j, 2), 1e9); if (i &lt; n) G.addedge(cal(i + 1, j, 0), cal(i, j, 2), 1e9); if (j > 1) G.addedge(cal(i, j - 1, 0), cal(i, j, 2), 1e9); if (j &lt; m) G.addedge(cal(i, j + 1, 0), cal(i, j, 2), 1e9); &#125; return !printf(\"%d\\n\", ans - G.maxFlow(s, t)); &#125; 二分图 一些题。 「Wdoi-6」最澄澈的空与海 Portal. 必要条件是有一个节点入度为 111，从这个节点开始跑 bfs 看是否存在完美匹配。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, in[2000005]; bool del[2000005]; vector&lt;int> G[2000005]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n * 2; ++i) G[i].clear(), in[i] = del[i] = 0; while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); v += n; ++in[u]; ++in[v]; G[u].emplace_back(v); G[v].emplace_back(u); &#125; queue&lt;int> q; int cnt = 0; for (int i = 1; i &lt;= n * 2; ++i) if (in[i] == 1) q.push(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (del[u] || in[u] != 1) continue; del[u] = 1; ++cnt; int buf = 0; while (del[G[u][buf]]) ++buf; del[G[u][buf]] = 1; ++cnt; for (int v : G[G[u][buf]]) if (!del[v] &amp;&amp; (--in[v]) == 1) q.push(v); &#125; if (cnt == n * 2) puts(\"Renko\"); else puts(\"Merry\"); &#125; return 0; &#125; [CF1139E] Maximize Mex Portal. 考虑静态的情况怎么做。将能力值定义为左部点，学生定义为右部点，初始令答案为 000，然后看 111 是否能够增广，能够增广就再看 222。 倒着考虑这个过程，将删边改为加边即可。 查看代码 int n, m, q; int a[5005], c[5005], d[5005], ans[5005]; bool v[5005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) G.addedge(n + i, n + m + 1, 1); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", c + i); scanf(\"%d\", &amp;q); for (int i = 1; i &lt;= q; ++i) scanf(\"%d\", d + i), v[d[i]] = 1; for (int i = 1; i &lt;= n; ++i) if (!v[i]) if (a[i] &lt; n) G.addedge(a[i] + 1, n + c[i], 1); G.addedge(0, 1, 1); for (int i = q, cur = 0; i >= 1; --i) &#123; while (G.maxFlow(0, n + m + 1)) if (++cur &lt; n) G.addedge(0, cur + 1, 1); ans[i] = cur; if (a[d[i]] &lt; n) G.addedge(a[d[i]] + 1, n + c[d[i]], 1); &#125; for (int i = 1; i &lt;= q; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; [CF1592F] Alice and Recoloring F1，F2。 不难发现 2,32,32,3 操作是小丑，我们都可以使用 111 操作来代替。 先考虑 F1。将 W 看成 000，B 看成 111，然后考虑什么东西要被翻转。如果它自己是 111 需要翻吗？不一定！(i,j)(i,j)(i,j) 是 111 需要翻，当且仅当 (i+1,j),(i,j+1),(i+1,j+1)(i+1,j),(i,j+1),(i+1,j+1)(i+1,j),(i,j+1),(i+1,j+1) 当中有 000 或 222 个是 111。如果它自己不是 111 就不需要翻吗？也不是，同样是那三个位置，如果当中有 1,31,31,3 个 111 就需要翻。 令 ai,j=si,j⊕si,j+1⊕si+1,j⊕si+1,j+1a_{i,j}=s_{i,j}\\oplus s_{i,j+1}\\oplus s_{i+1,j}\\oplus s_{i+1,j+1}ai,j​=si,j​⊕si,j+1​⊕si+1,j​⊕si+1,j+1​，只考虑 111 操作，答案就是 ∑ai,j\\sum a_{i,j}∑ai,j​。 444 干了什么？相当于翻了 ai,j,ai,m,an,j,an,ma_{i,j},a_{i,m},a_{n,j},a_{n,m}ai,j​,ai,m​,an,j​,an,m​，显然，它只能使用 111 次。代码。 再考虑 F2。我们考虑在刚才的基础上加一些限制。 首先，基于之前说过的 444 干的事情，我们只会操作 ai,j,ai,m,an,ja_{i,j},a_{i,m},a_{n,j}ai,j​,ai,m​,an,j​ 均为 111 的，否则不如来 111 操作。然后这样就发现了一个事情，一次操作 ai,ja_{i,j}ai,j​ 之后会将 ai,ma_{i,m}ai,m​ 和 an,ja_{n,j}an,j​ 废掉，也就是说，同行同列最多进行一次 444 操作。 这看上去很像一个二分图匹配问题了！将每行抽象为左部点，每列抽象为右部点（前提是 111），然后根据 ai,ja_{i,j}ai,j​ 进行连边。 查看代码 int n, m, a[505][505]; char s[505][505]; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; int ans = 0; for (int i = 1; i &lt;= n; ++i) cin >> s[i] + 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = (s[i][j] != 'W'); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] ^= a[i + 1][j] ^ a[i][j + 1] ^ a[i + 1][j + 1]; for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt; m; ++j) if (a[i][j] &amp;&amp; a[i][m] &amp;&amp; a[n][j]) G.addedge(i, n + j, 1); for (int i = 1; i &lt; n; ++i) if (a[i][m]) G.addedge(0, i, 1); for (int i = 1; i &lt; m; ++i) if (a[n][i]) G.addedge(i + n, n + m + 1, 1); int flow = G.maxFlow(0, n + m + 1); a[n][m] ^= (flow &amp; 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) ans += a[i][j]; return cout &lt;&lt; ans - flow &lt;&lt; \"\\n\", 0; &#125; 综合应用 一些比较好玩的题。 [CF1728F] Fishermen Portal. 我们需要构造一个 ai∣bia_i\\mid b_iai​∣bi​ 且 bib_ibi​ 互不相同，这样这个 bbb 就一定是满足条件的。 构造所有的 k×ai,k∈[1,n]k\\times a_i,k\\in [1,n]k×ai​,k∈[1,n]，我们用这些数来匹配 aia_iai​。这样点数和边数都是 O(n2)O(n^2)O(n2) 的。 考虑匈牙利算法，在找到匹配时清空 vis 数组，由于只有 O(n)O(n)O(n) 个匹配，因此时间复杂度 O(n3)O(n^3)O(n3)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, a[1005], b[1000005]; int buc[1000005], mch[1000005]; bool vis[1000005]; vector&lt;int> G[1000005]; bool dfs(int x) &#123; if (vis[x]) return 0; vis[x] = 1; for (int y : G[x]) if (!mch[y] || dfs(mch[y])) return mch[y] = x, 1; return 0; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); for (int j = 1; j &lt;= n; ++j) b[++m] = a[i] * j; &#125; sort(b + 1, b + m + 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; int p = lower_bound(b + 1, b + m + 1, a[i] * j) - b; G[p].emplace_back(i); &#125; i64 ans = 0; for (int i = 1; i &lt;= m; ++i) if (dfs(i)) ans += b[i], memset(vis, 0, sizeof vis); return !printf(\"%lld\\n\", ans); &#125; [WC2007] 剪刀石头布 Portal. 如果一个三元组不是三元环，那么有一个点的出度为 222。假定一个点的出度为 ddd，那么它会使得三元环减少 d(d−1)2\\frac{d(d-1)}{2}2d(d−1)​，那么最终答案为： (n3)−∑i=1nd(d−1)2\\binom n 3 - \\sum_{i=1}^n \\frac{d(d-1)}{2} (3n​)−i=1∑n​2d(d−1)​ 考虑最小费用最大流。每个人向汇点连容量为 nnn 的边，源点向每个不确定的边连边、边向两个人连边，容量均为 111。 一个人的贡献可以看成 0+1+⋯+di−10+1+\\cdots+d_i-10+1+⋯+di​−1，这是等差数列的费用。套路地，考虑拆点，拆成 nnn 个，费用依次为 0,1,⋯ ,n−10,1,\\cdots,n-10,1,⋯,n−1 即可。代码。 虽然在《算法导论》中并没有这个定义，但是这样可以简单的支持反悔。 ↩︎","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"算法竞赛/学习笔记/图论","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://james1badcreeper.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"非传统题目与算法综合题","slug":"notes/杂项/special","date":"2022-12-07T00:00:00.000Z","updated":"2022-12-07T00:00:00.000Z","comments":true,"path":"26972790/","link":"","permalink":"https://james1badcreeper.github.io/26972790/","excerpt":"常规的传统题目采用黑箱评测，让选手程序读入输入数据，将选手输出与输出数据全文比较或者采用 Special Judge 比较。但比赛中还有一些非传统题目。对于题目解法也有特殊的手段，比如随机化算法。当然，也可以尝试各种方法来乱搞。","text":"常规的传统题目采用黑箱评测，让选手程序读入输入数据，将选手输出与输出数据全文比较或者采用 Special Judge 比较。但比赛中还有一些非传统题目。对于题目解法也有特殊的手段，比如随机化算法。当然，也可以尝试各种方法来乱搞。 把它们放在一起讲的另一个原因是它们之间有联系。 交互题 这是什么呢？大概就是说，你要写一个程序和计算机做游戏，选手程序向测评程序发出询问，并得到其反馈，最终要获取答案。 交互方式 交互方式是指交互题的实现方式，一般有两种。 Grader 交互 NOI、IOI 系列比赛的交互题均采用了 Grader 交互，通常不需要选手实现 main 函数，只需要实现特定的函数。它会下发一个 grader.cpp 文件[1]，供选手检验自己的程序。 常规情况下你只需要在程序中引用一个头文件（题目会给定），但是常用 OJ 洛谷的交互方式比较奇怪，请参考题目说明（都会说明的）。 模板，代码如下： #include &lt;iostream> #include &lt;cstdio> using namespace std; extern \"C\" int Seniorious(int); extern \"C\" int Chtholly(int n, int c) &#123; int L = 0, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (Seniorious(mid) == 1) R = mid; else L = mid; &#125; return L; &#125; STDIO 交互 Codeforces 和 ATCoder 采用的都是这种交互方式，ICPC 系列比赛中也是。这种类型可以正常编写程序，只需要刷新缓冲区就可以从标准输入读取结果。C++ 的刷新方式有两种：调用 fflush(stdout) 或者输出一个 endl。 模板，代码如下： #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int L = 0, R = 1e9 + 1; while (L + 1 != R) &#123; int mid = L + R >> 1, t; printf(\"%d\\n\", mid); fflush(stdout); scanf(\"%d\", &amp;t); if (t == 0) return printf(\"%d\\n\", mid), 0; else if (t == 1) R = mid; else L = mid; &#125; return 0; &#125; 注意，当你的交互方式有问题时，可能会获得 Idleness limit exceeded（ILE，懒惰超过限制）的评测结果。 简单交互题 我们来看几道简单的交互题，交互题的具体方法请见构造一节。 [CF843B] Interactive LowerBound Portal. 由于完全不知道链表的构造，因此唯一的逼近方式就是随机撒点，找出一个最大的小于 xxx 的然后开始暴力找。 查看代码 #include &lt;bits/stdc++.h> using namespace std; mt19937 Rand(time(0)); int n, start, x, m, ans = -1, p; int a[50005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;start, &amp;x); m = min(1000, n); p = start; printf(\"? %d\\n\", p); fflush(stdout); int val, nxt; scanf(\"%d%d\", &amp;val, &amp;nxt); ans = val; for (int i = 1; i &lt;= n; ++i) a[i] = i; shuffle(a + 1, a + n + 1, Rand); for (int i = 1; i &lt;= m; ++i) &#123; printf(\"? %d\\n\", a[i]); fflush(stdout); int val, nxt; scanf(\"%d%d\", &amp;val, &amp;nxt); if (val &lt; x &amp;&amp; val > ans) ans = val, p = a[i]; &#125; while (p != -1 &amp;&amp; ans &lt; x) &#123; printf(\"? %d\\n\", p); fflush(stdout); int val, nxt; scanf(\"%d%d\", &amp;val, &amp;nxt); ans = val; p = nxt; &#125; printf(\"! %d\\n\", ans &lt; x ? -1 : ans); return 0; &#125; [CF1592D] Hemose in ICPC ? Portal.给定一棵树，但是不知道边权。定义距离 d(u,v)d(u,v)d(u,v) 为路径上的边权的 gcd⁡\\gcdgcd。你可以询问交互库一个点集，交互库会回答这些点两两点对的距离的最大值。你最多可以询问交互库 121212 次，要找出 d(u,v)d(u,v)d(u,v) 最大的 (u,v)(u,v)(u,v)。可以输出任意一组解，2≤n≤1032\\le n\\le 10^32≤n≤103。 可以发现距离定义为 gcd⁡\\gcdgcd，那么最大距离就相当于找出最大边权。 首先询问一次所有点来找出最大的边权，叫做答案。对树进行一次 dfs，求出遍历的顺序，这样每两个树上相邻的点都可以在序列中找到。我们对序列进行二分，最大值等于答案的那一半就是答案出现的地方。这样就可以求出点对了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, maxx, a[2005], tot = 0; vector&lt;int> G[1005]; void dfs(int x, int fa) &#123; a[++tot] = x; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); a[++tot] = x; &#125; &#125; int p[1005]; int check(int L, int R) &#123; memset(p, 0, sizeof(p)); int cnt = 0; for (int i = max(0, L); i &lt;= R; ++i) p[a[i]] = true; for (int i = 1; i &lt;= n; ++i) if (p[i]) ++cnt; printf(\"? %d \", cnt); for (int i = 1; i &lt;= n; ++i) if (p[i]) printf(\"%d \", i); cout &lt;&lt; endl; int t; scanf(\"%d\", &amp;t); return t; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v), G[v].emplace_back(u); &#125; printf(\"? %d \", n); for(int i = 1; i &lt;= n; ++i) printf(\"%d \", i); cout &lt;&lt; endl; scanf(\"%d\", &amp;maxx); dfs(1, 0); int L = 1, R = tot; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(L, mid) != maxx) L = mid; else R = mid; &#125; int x = a[L], y = a[R]; printf(\"! %d %d\\n\", a[L], a[R]); return 0; &#125; 构造与交互 构造题是指构造满足题目要求的答案，是一种考察选手智力的非传统题目。虽然交互题是交互，但有些交互就是构造方案，因此这里有的方法会出现一些交互题。 另外，很多些题目可能没有特别的办法，需要发挥“人类智慧”，也就是 Ad-Hoc 类题目，可能需要从多个角度思考并发挥自己的想象力。 鸽笼原理 在构造时，如果遇到了 n÷kn\\div kn÷k 的限制操作次数，可以考虑将所有数划分为 kkk 个集合，这样最小的那个集合就一定小于等于 n÷kn\\div kn÷k。 [CF1198C] Matching vs Independent Set Portal. 我们暴力查找边的独立集，如果最后独立集中有 xxx 条边，那么点的独立集至少有 3n−2x3n-2x3n−2x 个点，这两个至少有一个 ≥n\\ge n≥n。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; bool a[300005]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); fill(a + 1, a + n * 3 + 1, 0); vector&lt;int> ans; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (!a[u] &amp;&amp; !a[v]) a[u] = a[v] = 1, ans.emplace_back(i); &#125; if (ans.size() >= n) &#123; puts(\"Matching\"); for (int i = 0; i &lt; n; ++i) printf(\"%d \", ans[i]); &#125; else &#123; puts(\"IndSet\"); for (int i = 1, cnt = 0; i &lt;= n * 3 &amp;&amp; cnt &lt; n; ++i) if (!a[i]) printf(\"%d \", i), ++cnt; &#125; putchar('\\n'); &#125; return 0; &#125; [CF1534D] Lost Tree Portal. 令这棵树的根为 111，先求出所有点的深度，深度为奇数的和深度为偶数的点的个数中至少有一个不大于 n÷2n\\div 2n÷2，因此询问那个小的，所有距离为 111 的点对间都有一条边。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, dep[2005], c[2]; vector&lt;pair&lt;int, int>> e; int main(void) &#123; scanf(\"%d\", &amp;n); puts(\"? 1\"); fflush(stdout); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", dep + i), ++c[dep[i] &amp; 1]; if (c[1] &lt; c[0]) &#123; for (int i = 1; i &lt;= n; ++i) if (dep[i] &amp; 1) &#123; printf(\"? %d\\n\", i); fflush(stdout); for (int j = 1, x; j &lt;= n; ++j) &#123; scanf(\"%d\", &amp;x); if (x == 1) e.emplace_back(i, j); &#125; &#125; &#125; else &#123; for (int i = 1; i &lt;= n; ++i) if (dep[i] == 1) e.emplace_back(1, i); for (int i = 2; i &lt;= n; ++i) if (!(dep[i] &amp; 1)) &#123; printf(\"? %d\\n\", i); fflush(stdout); for (int j = 1, x; j &lt;= n; ++j) &#123; scanf(\"%d\", &amp;x); if (x == 1) e.emplace_back(i, j); &#125; &#125; &#125; puts(\"!\"); for (auto [u, v] : e) printf(\"%d %d\\n\", u, v); return 0; &#125; [CF1450C2] Errich-Tac-Toe Portal. 根据坐标 (x+y) mod 3(x+y)\\bmod 3(x+y)mod3 将格子分成三类，只需要将其中两类分别改成 X，O 就能满足条件。这样总修改次数是 kkk，最小的修改次数必定 ≤⌊k3⌋\\le \\left\\lfloor\\frac{k}{3}\\right\\rfloor≤⌊3k​⌋ 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, k1, k2, k3; char a[305][305]; char a1[305][305], a2[305][305], a3[305][305]; void print(char s[][305]) &#123; for (int i = 1; i &lt;= n; ++i) printf(\"%s\\n\", s[i] + 1); &#125; void solve(void) &#123; scanf(\"%d\", &amp;n); k1 = k2 = k3 = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", a[i] + 1); memcpy(a1, a, sizeof(a)); memcpy(a2, a, sizeof(a)); memcpy(a3, a, sizeof(a)); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; int t = (i + j) % 3; if (t == 0) &#123; if (a[i][j] == 'O') a1[i][j] = 'X', ++k1; if (a[i][j] == 'X') a3[i][j] = 'O', ++k3; &#125; else if (t == 1) &#123; if (a[i][j] == 'O') a2[i][j] = 'X', ++k2; if (a[i][j] == 'X') a1[i][j] = 'O', ++k1; &#125; else &#123; if (a[i][j] == 'O') a3[i][j] = 'X', ++k3; if (a[i][j] == 'X') a2[i][j] = 'O', ++k2; &#125; &#125; if (k1 &lt;= k2 &amp;&amp; k1 &lt;= k3) print(a1); else if (k2 &lt;= k3 &amp;&amp; k2 &lt;= k1) print(a2); else print(a3); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; 问题化简 | [CF618F] Double Knapsack Portal.给定两个长度为 n(n≤106)n(n\\le 10^6)n(n≤106) 的序列 A,BA,BA,B，当中每个元素都在 [1,n][1,n][1,n] 中。请分别选出 A,BA,BA,B 的一个子序列，使得这两个子序列的元素之和相等，无解输出 −1-1−1。 本题会初步告诉你什么叫做“人类智慧”。 事实上，一定有解，而且不需要找子序列，找子段就可以了。 怎么想的？我也不知道。事实上，构造题有一种解法是主动加强条件来减少决策量，尽量简化问题。当然，也可以考虑弱化条件（绝对值拆开，max⁡(x,y)\\max(x,y)max(x,y) 改成主动选择是 xxx 或 yyy）。 现在我们来证明为什么只需要找子段就有解。设原序列为 a,ba,ba,b，其前缀和序列为 A,BA,BA,B，并令 A[n]≤B[n]A[n]\\le B[n]A[n]≤B[n]（反之同理）。 定义 jij_iji​ 代表满足 A[i]≥B[ji]A[i]\\ge B[j_i]A[i]≥B[ji​] 的最大数，那么 A[i]&lt;B[ji]+b[ji+1]⇒A[i]−B[ji]&lt;b[ji+1]⇒0≤A[i]−B[ji]&lt;nA[i]&lt;B[j_i]+b[j_i+1]\\Rightarrow A[i]-B[j_i]&lt;b[j_i+1]\\Rightarrow 0\\le A[i]-B[j_i]&lt;nA[i]&lt;B[ji​]+b[ji​+1]⇒A[i]−B[ji​]&lt;b[ji​+1]⇒0≤A[i]−B[ji​]&lt;n，有 nnn 种取值，但是这个下标有 0∼n0\\sim n0∼n 共 n+1n+1n+1 种取值。根据鸽笼原理，A[i]−B[ji]A[i]-B[j_i]A[i]−B[ji​] 一定有一组相等的。 找出这个 A[p0]−B[q0]=A[p1]−B[q1]⇒A[p1]−A[p0]=B[p1]−B[p0]A[p_0]-B[q_0]=A[p_1]-B[q_1]\\Rightarrow A[p_1]-A[p_0]=B[p_1]-B[p_0]A[p0​]−B[q0​]=A[p1​]−B[q1​]⇒A[p1​]−A[p0​]=B[p1​]−B[p0​]，直接输出就好。 查看代码 #include &lt;bits/stdc++.h> #define i64 long long using namespace std; int n; int a[1000005], b[1000005]; i64 A[1000005], B[1000005]; int j[1000005], cnt[1000005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), A[i] = A[i - 1] + a[i]; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i), B[i] = B[i - 1] + b[i]; int is_swap = 0; if (A[n] > B[n]) &#123; for (int i = 1; i &lt;= n; ++i) swap(a[i], b[i]), swap(A[i], B[i]); is_swap = 1; &#125; for (int i = 0, q = 0; i &lt;= n; ++i) &#123; while (q &lt; n &amp;&amp; B[q + 1] &lt;= A[i]) ++q; j[i] = q; &#125; int finder = -1, p[2], q[2]; for (int i = 0; i &lt;= n; ++i) &#123; if (cnt[A[i] - B[j[i]]]) &#123; finder = A[i] - B[j[i]]; p[1] = i, q[1] = j[i]; break; &#125; ++cnt[A[i] - B[j[i]]]; &#125; for (int i = 0; i &lt;= n; ++i) if (A[i] - B[j[i]] == finder) &#123; p[0] = i, q[0] = j[i]; break; &#125; if (is_swap) swap(p[0], q[0]), swap(p[1], q[1]); cout &lt;&lt; p[1] - p[0] &lt;&lt; \"\\n\"; for (int i = p[0] + 1; i &lt;= p[1]; ++i) printf(\"%d \", i); putchar('\\n'); cout &lt;&lt; q[1] - q[0] &lt;&lt; \"\\n\"; for (int i = q[0] + 1; i &lt;= q[1]; ++i) printf(\"%d \", i); putchar('\\n'); return 0; &#125; 归纳法 考虑找到有解的充要条件来判掉无解，然后将原文题转化成规模减一的一定有解的子问题。 [CF1470D] Strange Housing Portal. n=1n=1n=1 时一定有解，而且染不染都无所谓，我们可以将所有染色状况取反。 若 n−1n-1n−1 有解，则考虑将点 nnn 加入。如果点 nnn 连接的点都没有被染色那么它必须染色，否则不能染色。 最后如果有点没有加入，那么是无解的。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; bool v[300005]; int tag[300005]; // -1 未遍历，0 不染，1 染 vector&lt;int> G[300005]; queue&lt;int> q; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) G[i].clear(), v[i] = 0, tag[i] = -1; while (!q.empty()) q.pop(); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; q.emplace(1); v[1] = 1; tag[1] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); bool flag = true; for (int y : G[x]) if (tag[y] != -1) flag &amp;= !tag[y]; tag[x] = flag; for (int y : G[x]) if (!v[y]) v[y] = 1, q.emplace(y); &#125; for (int i = 1; i &lt;= n; ++i) if (!v[i]) return puts(\"NO\"), void(); puts(\"YES\"); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += tag[i]; printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (tag[i]) printf(\"%d \", i); putchar('\\n'); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [CF1515F] Phoenix and Earthquake Portal. 首先图必须连通，点权之和需要大于等于 x(n−1)x(n-1)x(n−1)，否则必定无解。 可以证明任意一棵生成树都是有解的，证明： 若 au≥xa_u\\ge xau​≥x，那么直接修建和它父亲的边，这样仍然满足条件； au&lt;xa_u&lt;xau​&lt;x，修建了之后点权之和的减小量小于 xxx，这样只需要最后修建这个即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, x; i64 a[300005], sum; int fa[300005], ans[300005], tot1, tot2; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; pair&lt;int, int> e[300005]; vector&lt;pair&lt;int, int>> G[300005]; void dfs(int u, int fa, int id) &#123; for (auto [v, p] : G[u]) if (v != fa) dfs(v, u, p); if (u == 1) return; if (a[u] >= x) a[fa] += a[u] - x, ans[++tot1] = id; else ans[--tot2] = id; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;x); tot2 = n; for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i), fa[i] = i, sum += a[i]; if (sum &lt; 1ll * (n - 1) * x) return puts(\"NO\"), 0; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", &amp;e[i].first, &amp;e[i].second); if (find(e[i].first) == find(e[i].second)) continue; fa[find(e[i].first)] = find(e[i].second); G[e[i].first].emplace_back(e[i].second, i); G[e[i].second].emplace_back(e[i].first, i); &#125; for (int i = 1; i &lt;= n; ++i) if (find(i) != find(1)) return puts(\"NO\"), 0; puts(\"YES\"); dfs(1, 0, 0); for (int i = 1; i &lt; n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; [ARC122E] Increasing LCMs Portal. 考虑归纳构造。 n=1n=1n=1 时显然成立。 对于 n&gt;1n&gt;1n&gt;1，我们考虑找出这个序列的最后一个数。这最后一个数需要满足前面数的 lcm⁡\\operatorname{lcm}lcm 不是它的倍数，也就是说 gcd⁡(lcm⁡j≠i{aj},ai)&lt;ai\\gcd(\\operatorname{lcm}_{j\\ne i}\\{a_j\\},a_i)&lt;a_igcd(lcmj=i​{aj​},ai​)&lt;ai​。这个式子相当于 lcm⁡j≠i{gcd⁡(aj,ai)}&lt;ai\\operatorname{lcm}_{j\\ne i}\\{\\gcd(a_j,a_i)\\}&lt;a_ilcmj=i​{gcd(aj​,ai​)}&lt;ai​，这样就可以转化为规模为 n−1n-1n−1 的问题。 由于 lcm⁡\\operatorname{lcm}lcm 随着问题规模的减小不会上升，可以放在最后一个的 aaa 越来越多，因此找到一个就放入答案不会使少掉可能的解。因此如果找不到这最后一个 aaa 就无解。 时间复杂度 O(n3log⁡V)O(n^3\\log V)O(n3logV)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; vector&lt;i64> ans; i64 gcd(i64 x, i64 y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; i64 lcm(i64 x, i64 y) &#123; return x / gcd(x, y) * y; &#125; void solve(vector&lt;i64> a) &#123; if (a.size() == 1) return ans.emplace_back(a[0]), void(); for (int i = 0; i &lt; a.size(); ++i) &#123; bool flag = 1; i64 l = 1; for (int j = 0; j &lt; a.size(); ++j) if (i != j) l = lcm(l, gcd(a[j], a[i])); if (l &lt; a[i]) &#123; ans.emplace_back(a[i]); vector&lt;i64> tmp; for (int j = 0; j &lt; a.size(); ++j) if (i != j) tmp.emplace_back(a[j]); solve(tmp); return; &#125; &#125; &#125; int main(void) &#123; cin >> n; vector&lt;i64> a(n); for (int i = 0; i &lt; n; ++i) cin >> a[i]; solve(a); if (ans.size() != n) puts(\"No\"); else &#123; puts(\"Yes\"); reverse(ans.begin(), ans.end()); for (i64 x : ans) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; '\\n'; &#125; return 0; &#125; [CF963B] Destruction of a Tree Portal. nnn 为偶数时度数是不对的，奇数时考虑归纳构造。 找一个 DFS 序最小的来杀，这样可以将原问题分裂成规模更小的子问题。 查看代码 #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> using namespace std; int n, root, deg[200005]; int f[200005]; int st[200005], tot; bool del[200005]; vector&lt;int> G[200005], ans; void dfs(int x) &#123; st[++tot] = x; for (int y : G[x]) if (y != f[x]) dfs(y); &#125; void dfs2(int x) &#123; del[x] = 1; ans.emplace_back(x); for (int y : G[x]) &#123; --deg[y]; if (y == f[x] || del[y]) continue; if (deg[y] % 2 == 0) dfs2(y); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i); if (!f[i]) root = i; else &#123; ++deg[i]; ++deg[f[i]]; G[i].emplace_back(f[i]); G[f[i]].emplace_back(i); &#125; &#125; dfs(root); while (tot) &#123; int u = st[tot--]; if (deg[u] % 2 == 0) dfs2(u); &#125; if (ans.size() == n) &#123; puts(\"YES\"); for (int x : ans) printf(\"%d\\n\", x); &#125; else puts(\"NO\"); return 0; &#125; DFS 树 DFS 树可以处理一些与图论相关的问题。 [CF1364D] Ehab’s Last Corollary Portal. 找环！如果环的大小 ≤k\\le k≤k 可以直接输出，否则就在环上每隔一个点输出一个来输出独立集。当然图有可能是树，要判掉。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, k, S, T, mx = 1e9; int dep[100005], cnt[100005]; vector&lt;int> G[100005], ans; void dfs(int x) &#123; ans.emplace_back(x); dep[x] = ans.size(); for (int y : G[x]) &#123; if (!dep[y]) dfs(y); if (dep[y] &lt; dep[x] - 1) &#123; // 回到非爸爸祖先，或者是 int t = dep[x] - dep[y] + 1; if (t &lt;= k) &#123; printf(\"2\\n%d\\n\", t); for (int i = dep[y] - 1; i &lt;= dep[x] - 1; ++i) printf(\"%d \", ans[i]); putchar('\\n'); exit(0); &#125; if (t &lt;= mx) &#123; mx = t; S = x; T = y; &#125; &#125; &#125; ans.pop_back(); &#125; void print(int x) &#123; ans.emplace_back(x); dep[x] = ans.size(); if (x == T) &#123; puts(\"1\"); for (int i = 0; i &lt; k; i += 2) printf(\"%d \", ans[i]); putchar('\\n'); &#125; for (int y : G[x]) &#123; if (x == S &amp;&amp; y == T) continue; if (!dep[y]) print(y); &#125; ans.pop_back(); &#125; int col[100005]; vector&lt;int> res[2]; void dfs2(int x) &#123; res[col[x]].emplace_back(x); for (int y : G[x]) if (col[y] == -1) &#123; col[y] = !col[x]; dfs2(y); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1); if (S) return memset(dep, 0, sizeof dep), print(S), 0; memset(col, -1, sizeof col); col[1] = 0; int t = (k + 1) / 2; dfs2(1); puts(\"1\"); if (res[0].size() >= t) &#123; for (int i = 0; i &lt; t; ++i) printf(\"%d \", res[0][i]); putchar('\\n'); &#125; else &#123; for (int i = 0; i &lt; t; ++i) printf(\"%d \", res[1][i]); putchar('\\n'); &#125; return 0; &#125; 与图论相关的问题 最优化问题 二进制分组 调整法 提交答案题 很谔谔的一类题目。正常的题目是黑箱评测，但是提交答案题会将输入数据下发给你（但是在 Problemset 中有更离谱的！），然后让你求出输出，直接提交。 通常以下类型的数据点会被组合成提交答案题： 可以被手玩或者超级大暴力解出来的数据点； 特殊构造的数据点，可以使用特别的解法； 需要使用乱搞方法解决的数据点。 这种题如果出现一般就很离谱，我们来看几道相对正常的。 不是那么离谱的题 很正常的题。 [eJOI2018] 互素树 Portal. 由于题目中保证存在 X=0X=0X=0，随机一个排列然后按照条件贪心往树里填都是很容易出解的，因此直接随机化加贪心即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, id[100005], a[100005], tmp[100005], res; vector&lt;int> G[100005]; mt19937 Rand(time(0)); set&lt;int> s; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; void dfs(int x, int fa) &#123; if (res) return; for (int i : s) if (!fa || gcd(tmp[fa], id[i]) == 1) &#123; // 给当前点填数 tmp[x] = id[i]; s.erase(i); break; &#125; if (!tmp[x]) return ++res, void(); for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; vector&lt;int> tmp; G[i].swap(tmp); id[i] = i; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v), G[v].emplace_back(u); &#125; int ans = n; for (int op = 1;; ++op) &#123; shuffle(id + 1, id + n + 1, Rand); s.clear(); for (int i = 1; i &lt;= n; ++i) tmp[i] = 0, s.insert(i); res = 0; dfs(1, 0); if (res &lt; ans) &#123; ans = res; for (int i = 1; i &lt;= n; ++i) a[i] = tmp[i]; &#125; if (!ans) break; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); &#125; return 0; &#125; [JRKSJ R2] Dark Forest Portal. O(1)O(1)O(1) 计算交换位置的贡献，然后随机接受时把答案也给接受了就行（因为方案不好存储）。注意特判 #3。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, p[1005]; i64 a[1005], ans; mt19937 Rand(time(0)); inline int rndint(int l, int r) &#123; return uniform_int_distribution&lt;>(l, r)(Rand); &#125; inline double rnddb(double l, double r) &#123; return uniform_real_distribution&lt;>(l, r)(Rand); &#125; inline int P(int x) &#123; if (x &lt;= 0) return x + n; if (x > n) return x - n; return x; &#125; void calc(int x, int y) &#123; // 将 p[x] 赋值为 y 时答案改变 int A = p[P(x - 2)], B = p[P(x - 1)], &amp;C = p[x], D = p[P(x + 1)], E = p[P(x + 2)]; ans -= (B * a[A] * a[B] + C * a[B] * a[D] + D * a[D] * a[E]) * a[C]; C = y; ans += (B * a[A] * a[B] + C * a[B] * a[D] + D * a[D] * a[E]) * a[C]; &#125; void SA(double T, const double ET, const double delta) &#123; for (int i = 1; i &lt;= n; ++i) calc(i, i); while (T > ET) &#123; int x = rndint(1, n), y = rndint(1, n), px = p[x], py = p[y]; i64 tmp = ans; calc(x, py); calc(y, px); if (ans &lt;= tmp &amp;&amp; exp((ans - tmp) / T) &lt; rnddb(0, 1)) // 回退答案 ans = tmp, swap(p[x], p[y]); T *= delta; &#125; cerr &lt;&lt; \"ans = \" &lt;&lt; ans &lt;&lt; \"\\n\"; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", p[i]); putchar('\\n'); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); return SA(1e15, 1e-15, 0.99999), 0; &#125; Problemset Problemset 不倒，陪你到老！ 简单构造 都非常的有趣！ [CF1278E] Tests for problem D Portal. 使用如下的构造方式：对于一个节点 xxx 的所有儿子 yyy 都在右边和 xxx 相交，并且互相包含，父亲则在左边和 xxx 相交。 显然是对的，如何构造呢？计算当前线段的右端点会到哪里，然后让儿子的左端点从右端点开始从右往左排，并递归遍历即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, l[500005], r[500005], num; vector&lt;int> G[500005]; void dfs(int x, int fa) &#123; num += G[x].size() + (fa == 0); r[x] = num; int cnt = 1; for (int y : G[x]) if (y != fa) &#123; l[y] = r[x] - cnt; ++cnt; dfs(y, x); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); num = 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; l[1] = 1; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d %d\\n\", l[i], r[i]); return 0; &#125; 深入分析问题 挖掘题目的性质，根据此设计解法。此类问题的思维难度可能会很大。 [NOIP2022] 喵了个喵 Portal. k=2n−2k=2n-2k=2n−2 显然是好做的，我们留一个空栈，如果来的牌与栈顶有相同就消除，否则就与栈底相同，放到空栈来消除栈底。 现在来看多的那种牌怎么安放。如果下一张牌是它自己那么随便找一个位置放，如果下一张牌是一个栈底牌那么把它放到那个栈上，然后消掉栈底它就成为了新的栈顶。 而如果下一张牌是栈顶牌呢？谔谔的事情发生了，似乎不能简单处理。我们将空栈设为 spspsp，当前这个神秘的牌为 xxx。不像羊了个羊，这题中我们可以看到后面所有的牌。我们找到下一个 xxx 或栈底元素 bbb（看哪个先出现）。 找到了 xxx！将 xxx 加入空栈，由于接下来还没有栈底元素进来，因此不需要这个空栈干活。期间出现的所有栈顶元素都可以直接消掉。 没有 xxx，悲。设这个栈底元素 bbb 对应的栈顶元素为 ttt。 这个 ttt 在 bbb 之前出现了奇数次，那么将 xxx 加入 spspsp，处理完之后会发现 ttt 被消掉了，这样 bbb 放进去即可。这样会发现其成为了新的空栈。 这个 ttt 在 bbb 之前出现了偶数次，则将 xxx 放入 bbb 所在的栈。这样我们可以在 spspsp 将 ttt 杀干净（甚至不用空栈，在原来的栈上方也可），然后 bbb 来了，消掉栈底，ttt 就成为了栈底，而 xxx 成为了新的栈顶。 实现也是个问题，上述过程可能细节很多，我们需要一个高效的实现（因为数据不小）。记录一下每个数在栈的位置位于的编号，每个栈的值。并且注意多测清空。 这样可以做到 O(n+m)O(n+m)O(n+m)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, k, a[2000005]; int up[605], down[605]; // 元素作为栈顶、栈底，栈的编号 int val[605][2], siz[605]; // 栈 x 上面(0)和下面(1)的元素 int cnt[605]; // 记录卡牌出现次数 vector&lt;pair&lt;int, int>> ans; vector&lt;int> L; void solve(void) &#123; for (int i = 1; i &lt; n; ++i) L.emplace_back(i); int sp = n; // 空栈 for (int l = 1, r = 0; l &lt;= m; l = r + 1) &#123; r = l; int i = l; if (down[a[i]]) &#123; // 有 a[i] 作为栈底 int u = down[a[i]]; ans.emplace_back(sp, 0); ans.emplace_back(sp, u); if (siz[u] == 2) &#123; int v = val[u][0]; siz[u] = 1; val[u][1] = val[u][0]; val[u][0] = 0; down[v] = u; up[v] = 0; L.emplace_back(u); &#125; else &#123; siz[u] = 0; val[u][1] = 0; &#125; down[a[i]] = 0; &#125; else if (up[a[i]]) &#123; // 作为栈顶 int u = up[a[i]]; ans.emplace_back(u, 0); up[a[i]] = 0; siz[u] = 1; val[u][0] = 0; L.emplace_back(u); &#125; else if (!L.empty()) &#123; // 还有空栈 int u = L.back(); L.pop_back(); ans.emplace_back(u, 0); if (siz[u] == 0) &#123; siz[u] = 1; val[u][1] = a[i]; down[a[i]] = u; L.emplace_back(u); &#125; else &#123; siz[u] = 2; val[u][0] = a[i]; up[a[i]] = u; &#125; &#125; else &#123; // 谔谔，此时一定除了空栈全满，并且当前是谔谔牌 while (r + 1 &lt;= m) &#123; ++r; if (a[r] == a[i]) &#123; // 找到了 x！ ans.emplace_back(sp, 0); for (int j = l + 1; j &lt; r; ++j) ans.emplace_back(up[a[j]], 0); for (int j = l + 1; j &lt; r; ++j) if (up[a[j]] &amp;&amp; cnt[up[a[j]]]) &#123; int u = up[a[j]]; cnt[u] = 0; up[a[j]] = 0; siz[u] = 1; val[u][0] = 0; L.emplace_back(u); &#125; ans.emplace_back(sp, 0); break; &#125; if (down[a[r]]) &#123; // 这是个栈底，悲 int u = down[a[r]]; if (cnt[u]) ans.emplace_back(sp, 0); else ans.emplace_back(u, 0); for (int j = l + 1; j &lt; r; ++j) ans.emplace_back(up[a[j]], 0); for (int j = l + 1; j &lt; r; ++j) if (up[a[j]] &amp;&amp; cnt[up[a[j]]] &amp;&amp; up[a[j]] != u) &#123; int u = up[a[j]]; cnt[u] = 0; up[a[j]] = 0; siz[u] = 1; val[u][0] = 0; L.emplace_back(u); &#125; if (cnt[u]) &#123; ans.emplace_back(u, 0); cnt[u] = 0; down[val[u][1]] = up[val[u][0]] = 0; val[u][1] = val[u][0] = 0; down[a[l]] = sp; val[sp][1] = a[l]; siz[sp] = 1; L.emplace_back(sp); sp = u; &#125; else &#123; ans.emplace_back(sp, 0); ans.emplace_back(sp, u); down[val[u][1]] = 0; up[val[u][0]] = 0; down[val[u][0]] = u; up[a[l]] = u; val[u][1] = val[u][0]; val[u][0] = a[l]; siz[u] = 2; &#125; break; &#125; cnt[up[a[r]]] ^= 1; &#125; &#125; &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", a + i); L.clear(); ans.clear(); memset(down, 0, sizeof down); memset(up, 0, sizeof up); memset(val, 0, sizeof val); memset(siz, 0, sizeof siz); memset(cnt, 0, sizeof cnt); solve(); printf(\"%d\\n\", ans.size()); for (auto [x, y] : ans) if (!y) printf(\"1 %d\\n\", x); else printf(\"2 %d %d\\n\", x, y); &#125; return 0; &#125; [eJOI2018] 循环排序 Portal. 实际上可以套路地分析。 弱化题目条件。最优解？我不管！我们可以只交换两个数，但是这样还是很难办，数没有放的唯一位置，那么就先做排列！ 观察样例。比如样例 555，它合并了两个操作，但是后面多出了一个操作。手玩后发现操作是可以合并的，但是最后要多出来一个长度为合并的操作数的操作。 现在考虑怎么将这个做法扩展到可以重复的数上。排列给了什么便利？每个点的入度出度都为 111，但如果它不是排列，它只会满足入度出度相等。 可以使用有向图的方式刻画这个过程：将 aia_iai​ 的最终位置向 aia_iai​ 连边，然后在这个图上找环，并且每条边经过恰好一次。这是欧拉路！在存边的时候记录一下 iii，因为这就是方案。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, s, m; int a[200005], b[200005], to[200005]; bool vis[200005]; vector&lt;pair&lt;int, int>> G[200005]; vector&lt;bool> ban[200005]; vector&lt;vector&lt;int> > ans; vector&lt;int> road; int cur[200005]; void dfs(int x) &#123; vis[x] = 1; for (; cur[x] &lt; G[x].size(); ++cur[x]) if (!ban[x][cur[x]]) &#123; int y = G[x][cur[x]].first, w = G[x][cur[x]].second; ban[x][cur[x]] = 1; dfs(y); road.emplace_back(w); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;s); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) to[i] = a[i] = lower_bound(b + 1, b + nn + 1, a[i]) - b; sort(to + 1, to + n + 1); // to 为最终的 a for (int i = 1; i &lt;= n; ++i) if (a[i] != to[i]) &#123; ++m; G[to[i]].emplace_back(a[i], i); ban[to[i]].emplace_back(0); &#125; if (m > s) return puts(\"-1\"), 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i] &amp;&amp; G[i].size()) &#123; road.clear(); dfs(i); ans.push_back(road); &#125; for (int i = 0; i &lt; ans.size(); ++i) reverse(ans[i].begin(), ans[i].end()); if (min(int(ans.size()), s - m) > 1) &#123; int t = min(int(ans.size()), s - m); road.clear(); road.emplace_back(ans[0][0]); for (int i = ans.size() - t + 1; i &lt; ans.size(); ++i) &#123; for (int x : ans[i]) ans[0].emplace_back(x); road.emplace_back(ans[i][0]); ans[i].clear(); &#125; for (int i = 1; i &lt; t; ++i) ans.pop_back(); reverse(road.begin(), road.end()); ans.push_back(road); &#125; printf(\"%u\\n\", ans.size()); for (int i = 0; i &lt; ans.size(); ++i) &#123; printf(\"%u\\n\", ans[i].size()); for (int x : ans[i]) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; [CF1764G] Doremy’s Perfect DS Class G1，G2，G3。给定一个 1∼n1\\sim n1∼n 的排列 ppp（n≤1024n \\le 1024n≤1024，注意 210=10242^{10}=1024210=1024），每次你可以询问 l,r,kl,r,kl,r,k，交互库会返回 ⌊plk⌋,⌊pl+1k⌋,⋯ ,⌊prk⌋\\left\\lfloor\\cfrac{p_l}k\\right\\rfloor,\\left\\lfloor\\cfrac{p_{l+1}}k\\right\\rfloor,\\cdots,\\left\\lfloor\\cfrac{p_r}k\\right\\rfloor⌊kpl​​⌋,⌊kpl+1​​⌋,⋯,⌊kpr​​⌋ 中不同数的个数，需要找到 111 的位置。交互次数分别限制在 30,25,2030,25,2030,25,20 次。 询问能告诉我们什么？好奇怪啊，不知道。尝试从给定的 kkk 值开始分析。k=1k=1k=1 没什么意义，然后尝试从特殊的，比如 k=2,nk=2,nk=2,n 开始分析。k=nk=nk=n 比较好说，只有 nnn 可以被记入答案，可以根据此找出 nnn 的位置。k=2k=2k=2 则可以将数分为两组，在 nnn 为奇数时只有 111 是单独一组，nnn 为偶数时只有 1,n1,n1,n 是单独一组。 从别的地方再想一想，都要求 log⁡\\loglog 级别的询问，不难想到二分。设 solve(l, r) 代表答案在 [l,r][l,r][l,r] 的位置中，我们需要确定 111 在 [l,mid][l,mid][l,mid] 还是 [mid+1,r][mid+1,r][mid+1,r] 里。咦，感觉不太对，不是严格的子问题！但是我们只需要寻找答案在哪里，因此只需要分别答案在 [1,mid][1,mid][1,mid] 还是 [mid+1,n][mid+1,n][mid+1,n] 就好了。 选择从 k=2k=2k=2 入手，x,yx,yx,y 分为一组仅当它们除以二下取整后的值相等。我们可以求出两个区间中在自己区间内没有匹配的数的数量，然后这个数量大的，答案就在那里（因为剩下的每有一个都是成对的）。 nnn 是偶数怎么办呢？我们只需要找到 nnn 就行，不难发现 k=nk=nk=n 可以很好的完成这个任务。当两个区间的值相等时，说明 1,n1,n1,n 各占一个，我们令 k=nk=nk=n，询问其中一个，看 nnn 是否在其中。找到 nnn 的位置之后发现之后的递归不会受到影响（如果 pn&gt;midp_n&gt; midpn​&gt;mid，我们会递归到 [l,mid][l,mid][l,mid]，必定有 pn&gt;mid′p_n&gt;mid&#x27;pn​&gt;mid′）。 这个做法可以通过 G2，代码。想过掉 G3，我们需要想方法杀掉那一次多余的询问。 怎么杀？对于 r−l+1=2r-l+1=2r−l+1=2 的情况，使用两次询问有点扯皮，我们看能不能只用一次询问杀掉它。核心思想是，充分利用我们之前问出来的信息。当我们递归到 [l,r][l,r][l,r] 时，曾令一个 mid=l−1mid=l-1mid=l−1，也令了一个 mid=rmid=rmid=r，因此我们知道 Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l-1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2) 的答案。现在 l,rl,rl,r 中一个是 111，一个是和其他数能匹配上的某个奇怪的东西，吗？注意，另一个可能是 nnn，如果我们还没有确定 nnn 的位置，那么通过询问 Q(r,n,n)Q(r,n,n)Q(r,n,n) 或 Q(1,l,n)Q(1,l,n)Q(1,l,n) 将其判掉。 现在再看怎么搞 l,rl,rl,r 一个是 111，另一个是可匹配数。可匹配数只能配在 [1,l−1][1,l-1][1,l−1] 或 [r+1,n][r+1,n][r+1,n]，如果 Q(1,l−1,2)+1=Q(1,r,2)Q(1,l-1,2)+1=Q(1,r,2)Q(1,l−1,2)+1=Q(1,r,2)，那么说明可匹配数的匹配数是开在 [1,l−1][1,l-1][1,l−1] 的（这个数除以二下去整的值与 [1,l−1][1,l-1][1,l−1] 中的某个数撞了），否则开在 [r+1,n][r+1,n][r+1,n]。确定了这一点之后，我们就可以锁定 111 的位置了！以开在 [1,l−1][1,l-1][1,l−1] 为例，如果 Q(1,l−1,2)=Q(1,l,2)Q(1,l-1,2)=Q(1,l,2)Q(1,l−1,2)=Q(1,l,2)，说明 lll 处开可匹配数，与 [1,l−1][1,l-1][1,l−1] 中的某个数匹配，111 就开在 rrr 处。 这样在 r−l+1=2r-l+1=2r−l+1=2 时我们只花费了一次询问，可以通过 G3。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, flag; map&lt;pair&lt;int, int>, int> f; int query(int l, int r, int k) &#123; if (l >= r) return l == r; if (l == 1 &amp;&amp; r == n) return n / k + 1; if (k == 2 &amp;&amp; f.find(&#123;l, r&#125;) != f.end()) return f[&#123;l, r&#125;]; printf(\"? %d %d %d\\n\", l, r, k); fflush(stdout); int ans; scanf(\"%d\", &amp;ans); if (k == 2) f[&#123;l, r&#125;] = ans; return ans; &#125; int solve(int l, int r) &#123; if (l == r) return l; if (n % 2 == 0 &amp;&amp; r - l + 1 == 2) &#123; if (!flag) &#123; if (r &lt; n) return query(r, n, n) == 2 ? l : r; return query(1, l, n) == 2 ? r : l; &#125; if (query(1, r, 2) - query(1, l - 1, 2) == 1) &#123; // 与非 1 数的匹配在 [1, l-1] int x = query(1, l - 1, 2), y = query(1, l, 2); if (x + 1 == y) return l; return r; &#125; else &#123; int x = query(r + 1, n, 2), y = query(r, n, 2); if (x + 1 == y) return r; return l; &#125; &#125; int mid = l + r >> 1; int L = 2 * query(1, mid, 2) - mid; int R = 2 * query(mid + 1, n, 2) - (n - mid); if (n % 2 == 0) &#123; if (!flag) &#123; if (L == R) &#123; bool con = 0; if (mid > 1 &amp;&amp; query(1, mid, n) == 2) con = 1; if (con) flag = 1, --L; else flag = -1, --R; &#125; &#125; else &#123; if (flag == 1) --L; else --R; &#125; &#125; return L > R ? solve(l, mid) : solve(mid + 1, r); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); return !printf(\"! %d\\n\", solve(1, n)); &#125; [CF1764E] Joking E1，E2。给定 nnn，猜出一个整数 xxx。可以询问一个集合 SSS，交互库会回答 xxx 是否属于 SSS。但交互库是个骗子，它只保证连续两次询问的回答只至少有一次是真的。最多可以猜测两次答案，n≤105n\\le 10^5n≤105，交互次数分别限制在 82,5382,5382,53 次。交互库自适应。 一个笨蛋做法是，一个询问连续询问两次。回答相同则一定是真的，但是不同就死了。 因此考虑将回答全部变成 YES。很简单，如果回答的是 NO，那么相当于我们询问了一个补集。 由于连续两次询问 S,TS,TS,T，不可能都为假，因此 xxx 在 S∪TS\\cup TS∪T 里。 问题是如何选择合适的 S,TS,TS,T，最小化并集的最大值，也就是最大化 S∩T,S‾∩T,S∩T‾,S‾∩T‾S\\cap T, \\overline{S}\\cap T,S\\cap \\overline{T},\\overline{S}\\cap \\overline{T}S∩T,S∩T,S∩T,S∩T 的最小值。 那么我们将 UUU 平均分成 U1,U2,U3,U4U_1,U_2,U_3,U_4U1​,U2​,U3​,U4​，令 S=U1∪U2,T=U3∪U4S=U_1\\cup U_2,T=U_3\\cup U_4S=U1​∪U2​,T=U3​∪U4​ 即可。 最后需要特判 n=3n=3n=3，得益于我们可以猜测两次，因此只要使用两次或三次询问判掉一个或者两个后问两次即可。可以通过 E1。 问题出在了哪里？上一轮的 TTT 和这一轮的 SSS 的性质我们没有用到。 假定全集为 UUU，上一次交互库告诉我们 x∈Sx\\in Sx∈S，令 T=∁UST=\\complement_{U}ST=∁U​S，那么我们询问的是 S0∪T0S_0\\cup T_0S0​∪T0​ 满足 S0⊂S,T0⊂T,S1=∁SS0,T1=∁TT0S_0\\subset S,T_0\\subset T,S_1=\\complement_{S}S_0,T_1=\\complement_{T}T_0S0​⊂S,T0​⊂T,S1​=∁S​S0​,T1​=∁T​T0​，如果回答了 YES，那么 UUU 就取不到 T1T_1T1​ 了。 考虑 DP 计算出最优的划分方式。设 fi,jf_{i,j}fi,j​ 代表 ∣S∣=i,∣T∣=j|S|=i,|T|=j∣S∣=i,∣T∣=j 的次数，初始 ∀i+j≤2,fi,j=0\\forall i+j\\le 2, f_{i,j}=0∀i+j≤2,fi,j​=0（直接问答案就行了），转移： fi,j=1+min⁡0≤x≤i,0≤y≤jmax⁡{fx+y,i−c,fi+j−x−y,x}f_{i,j}=1+\\min_{0\\le x\\le i,0\\le y\\le j}\\max\\{f_{x+y,i-c},f_{i+j-x-y,x}\\} fi,j​=1+0≤x≤i,0≤y≤jmin​max{fx+y,i−c​,fi+j−x−y,x​} 前者是回答 YES 时新的 SSS 为 S0∪T0S_0\\cup T_0S0​∪T0​，新的 TTT 为 S1S_1S1​；后者是回答 NO 时新的 SSS 为 S1∪T1S_1\\cup T_1S1​∪T1​，新的 TTT 为 S0S_0S0​。 比较大的时候直接折半是很优秀的。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef vector&lt;int> VI; const int N = 100; int n; int f[105][105], x[105][105], y[105][105]; int main(void) &#123; ios::sync_with_stdio(0); memset(f, 0x3f, sizeof(f)); for (int s = 0; s &lt;= N; ++s) for (int i = 0; i &lt;= s; ++i) &#123; int j = s - i; if (s &lt;= 2) &#123; f[i][j] = 0; continue; &#125; for (int x = 0; x &lt;= i; ++x) for (int y = 0; y &lt;= j; ++y) &#123; int v = max(f[x + y][i - x], f[s - x - y][x]) + 1; if (v &lt; f[i][j]) f[i][j] = v, ::x[i][j] = x, ::y[i][j] = y; &#125; &#125; cin >> n; VI S, T; for (int i = 1; i &lt;= n; ++i) S.push_back(i); while (S.size() + T.size() > 2) &#123; int x = S.size() / 2, y = T.size() / 2; if (S.size() + T.size() &lt;= N) x = ::x[S.size()][T.size()], y = ::y[S.size()][T.size()]; VI S0(S.begin(), S.begin() + x); VI S1(S.begin() + x, S.end()); VI T0(T.begin(), T.begin() + y); VI T1(T.begin() + y, T.end()); cout &lt;&lt; \"? \" &lt;&lt; S0.size() + T0.size() &lt;&lt; \" \"; for (int i : S0) cout &lt;&lt; i &lt;&lt; \" \"; for (int i : T0) cout &lt;&lt; i &lt;&lt; \" \"; cout &lt;&lt; endl; string res; cin >> res; S.clear(), T.clear(); if (res == \"YES\") &#123; for (int i : S0) S.push_back(i); for (int i : T0) S.push_back(i); for (int i : S1) T.push_back(i); &#125; else &#123; for (int i : S1) S.push_back(i); for (int i : T1) S.push_back(i); for (int i : S0) T.push_back(i); &#125; &#125; for (int i : T) S.emplace_back(i); for (int i : S) &#123; cout &lt;&lt; \"! \" &lt;&lt; i &lt;&lt; endl; string res; cin >> res; if (res == \":)\") return 0; &#125; return 0; &#125; 这一点不一定，在 NOI2022 D1T3 中，就只下发了一个 grader.cpp 编译后的可执行文件，这样会显著增加难度，因为你不再能打开 grader 源文件来调试或者寻找思路了。 ↩︎","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"提交答案","slug":"提交答案","permalink":"https://james1badcreeper.github.io/tags/%E6%8F%90%E4%BA%A4%E7%AD%94%E6%A1%88/"},{"name":"交互题","slug":"交互题","permalink":"https://james1badcreeper.github.io/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/"},{"name":"构造","slug":"构造","permalink":"https://james1badcreeper.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"随机化","slug":"随机化","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"}]},{"title":"字符串与自动机","slug":"notes/字符串/string-dfa","date":"2022-12-06T00:00:00.000Z","updated":"2022-12-06T00:00:00.000Z","comments":true,"path":"71e30681/","link":"","permalink":"https://james1badcreeper.github.io/71e30681/","excerpt":"高级的字符串算法几乎都与一个重要的概念：确定有限状态自动机（DFA）有关。这是一种重要的数学模型。","text":"高级的字符串算法几乎都与一个重要的概念：确定有限状态自动机（DFA）有关。这是一种重要的数学模型。 概述 这里只讲一些概念，但是非常有用。 OI 中的自动机一般指确定有限状态自动机（DFA）。自动机是一个对信号序列进行判定的数学模型。“信号序列”指的是一连串有顺序的信号，比如字符串从前到后的每一个字符。“判定”是对命题做出真假回答，比如判断一个字符串是否是回文串。 一个 DFA 可以被抽象成一张有向图，由五元组 (Σ,Q,s,F,δ)(\\Sigma, Q, s, F, \\delta)(Σ,Q,s,F,δ) 构成： 字符集 Σ\\SigmaΣ，该自动机只能输入这些字符； 状态集合 QQQ，状态相当于图上的顶点； 起始状态 sss（也可以记作 startstartstart），start∈Qstart\\in Qstart∈Q； 接受状态集合 FFF，F⊆QF\\subseteq QF⊆Q； 转移函数 δ\\deltaδ，δ\\deltaδ 接受一个状态和一个字符，返回一个状态，转移函数相当于有向图上的边，边的权值是字符。 DFA 可以识别字符串。自动机 AAA 如果能识别 SSS，那么 A(S)=TrueA(S)=TrueA(S)=True。DFA 读入字符串时，从初始状态起按照转移函数一个一个字符地转移。如果杜曼一个字符串地所有字符后到达了 FFF 中的一个点，那么 DFA 就识别了这个字符串。 比如说 Trie 就是一个自动机，每一条边都是转移函数，FFF 是标记为字符串的节点集合。 KMP 自动机 KMP 自动机的状态集合 QQQ 为 0∼∣S∣0\\sim |S|0∼∣S∣，如果当前识别的字符串为 ttt，那么每个节点 iii 表示已经输入的所有字符 t[1…p]t[1\\dots p]t[1…p] 与 sss 的最大匹配长度为 iii，即满足 s[p−i+1,p]=s[1,i]s[p-i+1,p]=s[1,i]s[p−i+1,p]=s[1,i]，转移函数为： δ(i,c)={i+1,si+1=c,0,si+1≠c∧i=0,δ(nxti,c),si+1≠c∧i≠0.\\delta(i, c) = \\begin{cases} i+1 ,&amp; s_{i + 1} = c, \\\\ 0 ,&amp; s_{i + 1} \\neq c \\land i = 0, \\\\ \\delta(nxt_i, c) ,&amp; s_{i + 1} \\neq c \\land i \\neq 0. \\\\ \\end{cases} δ(i,c)=⎩⎨⎧​i+1,0,δ(nxti​,c),​si+1​=c,si+1​=c∧i=0,si+1​=c∧i=0.​ int tr[1005][26]; for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt; 26; ++j) &#123; if (i &lt; n &amp;&amp; s[i + 1] == j + 'a') tr[i][j] = i + 1; else if (i) tr[i][j] = tr[nxt[i]][j]; &#125; AC 自动机（ACAM） 它用于解决多模式串 后缀自动机（SAM） 回文自动机（PAM）","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"算法竞赛/学习笔记/字符串","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://james1badcreeper.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"题目选做","slug":"default/old/11problems","date":"2022-12-01T00:00:00.000Z","updated":"2022-12-01T00:00:00.000Z","comments":true,"path":"75849b25/","link":"","permalink":"https://james1badcreeper.github.io/75849b25/","excerpt":"颓一点题！","text":"颓一点题！ 模拟 模拟。 数学模拟 有数的模拟。 [UVA11582] Colossal Fibonacci Numbers! Portal. 寻找循环节！ 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef unsigned long long u64; int poww(u64 a, u64 b, int MOD) &#123; a %= MOD; int res = 1; while (b) &#123; if (b &amp; 1) res = res * a % MOD; a = a * a % MOD; b >>= 1; &#125; return res % MOD; &#125; int n, f[1000010] = &#123;0, 1, 1&#125;; u64 a, b; void MAIN(void) &#123; scanf(\"%llu%llu%d\", &amp;a, &amp;b, &amp;n); if (n == 1 || a == 0) return puts(\"0\"), void(); for (int i = 3;; ++i) &#123; f[i] = (f[i - 1] + f[i - 2]) % n; if (f[i] == 1 &amp;&amp; f[i - 1] == 1) &#123; printf(\"%d\\n\", f[poww(a, b, i - 2)]); return; &#125; &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) MAIN(); return 0; &#125; [UVA12716] GCD XOR Portal. 打表找规律发现 gcd⁡(a,b)=a xor b=c⟹c=a−b\\gcd(a,b)=a\\text{ xor } b=c\\Longrightarrow c=a-bgcd(a,b)=a xor b=c⟹c=a−b，因此枚举 a,ca,ca,c，验证 bbb 即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int N = 3e7; int f[N + 5]; int main(void) &#123; for (int c = 1; c &lt;= N / 2; ++c) for (int a = 2 * c; a &lt;= N; a += c) &#123; int b = a - c; if ((a ^ b) == c) ++f[a]; &#125; for (int i = 2; i &lt;= N; ++i) f[i] += f[i - 1]; int T; scanf(\"%d\", &amp;T); for (int kase = 1; kase &lt;= T; ++kase) &#123; int x; scanf(\"%d\", &amp;x); printf(\"Case %d: %d\\n\", kase, f[x]); &#125; return 0; &#125; [蓝桥杯 2022 国 C] 取模 Portal. 给定 n,m(≤109)n, m(\\le 10^9)n,m(≤109)，问是否存在两个不同的数 x,yx,yx,y 使得 1≤x&lt;y≤m1 \\le x &lt; y \\le m1≤x&lt;y≤m 且 n mod x=n mod ⁡yn \\bmod x = n \\bmod ⁡ynmodx=nmod⁡y。 实际上直接枚举即可，可以证明答案不会很大。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;set> using namespace std; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); bool flag = false; set &lt;int> s; for (int i = 1; i &lt;= m; ++i) if (s.count(n % i)) &#123; flag = true; break; &#125; else s.insert(n % i); puts(flag ? \"Yes\" : \"No\"); &#125; return 0; &#125; [UVA11489] Interger Game Portal. 和是 333 的倍数！ 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int main(void) &#123; int T, n; static char s[1005]; scanf(\"%d\", &amp;T); for (int kase = 1; kase &lt;= T; ++kase) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); if (n == 1) &#123; printf(\"Case %d: S\\n\", kase); continue; &#125; int cnt = 0, res = 0; for (int i = 1; i &lt;= n; ++i) &#123; s[i] -= '0'; res += s[i]; cnt += (s[i] % 3 == 0); &#125; bool flag = false; for (int i = 1; i &lt;= n; ++i) if ((res - s[i]) % 3 == 0) &#123; if (s[i] % 3 == 0) cnt -= 1; flag = true; break; &#125; if (!flag || cnt % 2) printf(\"Case %d: T\\n\", kase); else printf(\"Case %d: S\\n\", kase); &#125; return 0; &#125; 奇怪的模拟 无法分类。 [CSP-S 2022] 策略游戏 Portal. 大型分类讨论现场。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const i64 INF = 2e18; int n, m, q; int a[100005], b[100005]; namespace Subtask2 &#123; const int INF = 2e9; struct Node &#123; int minn, maxx; int maxmi, minp; Node() : minn(INF), maxx(-INF), maxmi(-INF), minp(INF) &#123;&#125; &#125;; inline Node hb(const Node &amp;a, const Node &amp;b) &#123; Node c; c.minn = min(a.minn, b.minn); c.maxx = max(a.maxx, b.maxx); c.maxmi = max(a.maxmi, b.maxmi); c.minp = min(a.minp, b.minp); return c; &#125; struct SegmentTree &#123; Node T[400005]; int *v; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].minn = T[o].maxx = v[l]; if (v[l] >= 0) T[o].minp = v[l]; if (v[l] &lt;= 0) T[o].maxmi = v[l]; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; Node res; if (x &lt;= mid) res = hb(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = hb(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; &#125;A, B; void MAIN(void) &#123; A.v = a, B.v = b; A.build(1, 1, n); B.build(1, 1, n); while (q--) &#123; int l1, r1, l2, r2; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); Node x = A.query(1, 1, n, l1, r1), y = B.query(1, 1, n, l2, r2); i64 ans = -2e18; ans = max(ans, 1ll * x.maxx * (x.maxx >= 0 ? y.minn : y.maxx)); ans = max(ans, 1ll * x.minn * (x.minn >= 0 ? y.minn : y.maxx)); if (x.minp != INF) ans = max(ans, 1ll * x.minp * y.minn); if (x.maxmi != -INF) ans = max(ans, 1ll * x.maxmi * y.maxx); printf(\"%lld\\n\", ans); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", b + i); Subtask2::MAIN(); return 0; &#125; [EER2] 谔运算 Portal. 位运算可以按位进行讨论。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; uint n, x, ans = 0; uint a[35]; int main(void) &#123; scanf(\"%u\", &amp;n); uint tot = n * n; for (uint i = 1; i &lt;= n; ++i) &#123; scanf(\"%u\", &amp;x); for (int j = 0; j &lt; 32; ++j) if ((x >> j) &amp; 1) ++a[j]; &#125; for (uint i = 0; i &lt; 32; ++i) &#123; uint x = a[i] * a[i], y = (n - a[i]) * (n - a[i]); ans += (x * y + (tot - x) * (tot - y)) &lt;&lt; i; &#125; printf(\"%u\\n\", ans); return 0; &#125; DP 动态规划。 简单 DP 大概是 KH 114514−1919810ms114514^{-1919810}\\text{ms}114514−1919810ms 一道的难度。 [UVA10003] Cutting Sticks Portal. 区间 DP 模板。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int l, n; int a[55], f[55][55]; int main(void) &#123; while (scanf(\"%d\", &amp;l) == 1 &amp;&amp; l) &#123; scanf(\"%d\", &amp;n); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); a[n + 1] = l; for (int len = 2; len &lt;= n + 2; ++len) for (int i = 0; i &lt;= n - len + 2; ++i) &#123; int j = i + len - 1; if (len == 2) &#123; f[i][j] = 0; continue; &#125; for (int k = i + 1; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k][j]); f[i][j] += a[j] - a[i]; &#125; printf(\"The minimum cutting is %d.\\n\", f[0][n + 1]); &#125; return 0; &#125; [UVA1626] Brackets sequence Portal. 还是区间 DP 模板。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; char s[110]; int f[105][105]; bool check(int i, int j) &#123; if (s[i] == '(' &amp;&amp; s[j] == ')') return true; return s[i] == '[' &amp;&amp; s[j] == ']'; &#125; void print(int i, int j) &#123; if (i > j) return; if (i == j) &#123; if (s[i] == '(' || s[i] == ')') printf(\"()\"); else printf(\"[]\"); return; &#125; int ans = f[i][j]; if (check(i, j) &amp;&amp; ans == f[i + 1][j - 1]) &#123; printf(\"%c\", s[i]); print(i + 1, j - 1); printf(\"%c\", s[j]); return; &#125; for (int k = i; k &lt; j; ++k) if (ans == f[i][k] + f[k + 1][j]) &#123; print(i, k); print(k + 1, j); return; &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); fgets(s, 105, stdin); while (T--) &#123; fgets_unlocked(s + 1, 105, stdin); fgets_unlocked(s + 1, 105, stdin); n = strlen(s + 1) - 1; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) f[i][i] = 1, f[i + 1][i] = 0; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = len; if (check(i, j)) f[i][j] = min(f[i][j], f[i + 1][j - 1]); for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); &#125; print(1, n); putchar('\\n'); if (T) putchar('\\n'); &#125; return 0; &#125; [EER2] 直接自然溢出啥事没有 Portal. 依照题意计数即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef unsigned long long ull; int n; ull f[10005][5]; // 0: 语句 // 1: 程序片段 // 2: 语句块 // 3: 函数 // 4: 值 int main(void) &#123; scanf(\"%d\", &amp;n); f[0][1] = f[1][0] = f[1][1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; f[i][2] = f[i - 2][1]; f[i][3] = f[i - 2][2] + f[i - 2][3]; if (i >= 4) f[i][3] += f[i - 4][2]; f[i][4] = f[i][3] + f[i - 2][4]; f[i][0] = f[i][2] + f[i - 1][4]; for (int j = 0; j &lt; i; ++j) f[i][1] += f[j][1] * f[i - j][0]; &#125; printf(\"%llu\\n\", f[n][1]); return 0; &#125; 图论 图论。 树 树形问题。 [APIO2007] 风铃 Portal. 树上深度优先遍历。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int INF = 1e9; int n, maxdep = -INF, mindep = INF; int a[100005][2]; void dfs(int x, int dep) &#123; if (x == -1) return mindep = min(dep, mindep), maxdep = max(dep, maxdep), void(); dfs(a[x][0], dep + 1); dfs(a[x][1], dep + 1); &#125; bool flag = false; int ans = 0; int solve(int o, int dep) &#123; // 0 全浅，1 全深，2 都有 if (o == -1) return dep != mindep; int x = solve(a[o][0], dep + 1), y = solve(a[o][1], dep + 1); ans += ((x == 0 &amp;&amp; y) || (x == 2 &amp;&amp; y == 1)); // 如果左面全浅，或者右面全身，需要一次 if (x == 2 &amp;&amp; y == 2) exit((puts(\"-1\"), 0)); // 两个都是都有，GG if (x == 2 || y == 2 || x + y == 1) return 2; if (x + y == 0) return 0; return 1; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;a[i][0], &amp;a[i][1]); dfs(1, 0); if (maxdep == mindep) return puts(\"0\"), 0; if (maxdep - mindep > 1) return puts(\"-1\"), 0; solve(1, 0); printf(\"%d\\n\", ans); return 0; &#125; 数学 数学题。 数论 用到数论知识的简单题。 [UVA10791] Minimum Sum LCM Portal. 唯一分解定理。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef unsigned long long u64; u64 n, kase = 0; u64 calc(void) &#123; if (n == 1) return 2; u64 ans = 0, flag = 0; for (u64 i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; u64 res = 1; while (n % i == 0) res *= i, n /= i; ans += res; flag++; &#125; if (n > 1) ans += n, ++flag; return ans + (flag == 1); &#125; int main(void) &#123; while (scanf(\"%llu\", &amp;n) == 1 &amp;&amp; n) printf(\"Case %llu: %llu\\n\", ++kase, calc()); return 0; &#125; 数学推导 数学推导。 「SWTR-6」GCDs &amp; LCMs Portal. 有 y&lt;x+y+(x,y)=[x,y]=2y&lt;3yy&lt;x+y+(x,y)=[x,y]=2y&lt;3yy&lt;x+y+(x,y)=[x,y]=2y&lt;3y，因此 2y(x,y)=xy2y(x,y)=xy2y(x,y)=xy，所以 y=1.5xy=1.5xy=1.5x，根据此模拟即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;map> using namespace std; typedef long long i64; int n; int a[300005]; map&lt;int, int> s; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), s[a[i]] += 1; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int tmp = a[i]; i64 cnt = 0; while (s[tmp]) &#123; cnt += 1ll * tmp * s[tmp]; if (tmp % 2 == 0) tmp = tmp / 2 * 3; else break; &#125; ans = max(ans, cnt); &#125; printf(\"%lld\\n\", ans); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"刷","slug":"刷","permalink":"https://james1badcreeper.github.io/tags/%E5%88%B7/"}]},{"title":"简单字符串","slug":"notes/字符串/string","date":"2022-11-28T00:00:00.000Z","updated":"2022-11-28T00:00:00.000Z","comments":true,"path":"f51e608c/","link":"","permalink":"https://james1badcreeper.github.io/f51e608c/","excerpt":"字符串，就是由字符连接而成的序列。常见的字符串问题包括字符串匹配问题、子串相关问题、前缀/后缀相关问题、回文串相关问题、子序列相关问题等。具有很高的工程价值，比如搜索引擎。本文将介绍简单的字符串知识。","text":"字符串，就是由字符连接而成的序列。常见的字符串问题包括字符串匹配问题、子串相关问题、前缀/后缀相关问题、回文串相关问题、子序列相关问题等。具有很高的工程价值，比如搜索引擎。本文将介绍简单的字符串知识。 简单内容 这里是一些概念。 定义 一个字符集 Σ\\SigmaΣ 是一个建立了全序关系的集合，也就是说，Σ\\SigmaΣ 中的任意两个不同元素 α,β\\alpha,\\betaα,β 都可以比较大小，其中的元素称之为字符。 一个字符串 SSS 是将 nnn 个字符顺次排列形成的序列，nnn 表示字符串的长度，记为 ∣S∣|S|∣S∣。字符的编号从 000 开始（尽可能这样编号，这样是与标准一致的）。 字典序是以第 iii 个字符作为关键字符进行比较，特别注意，空字符是最小的：&quot;a&quot; &lt; &quot;aa&quot;。 子串、子序列、前缀后缀和回文串就不再赘述了。 char 数组 char s[1005]; // 声明字符数组 const char S[] = \"abab\"; // 常量字符数组 printf(\"%s\", s); scanf(\"%s\", s); // 读入和输出 sprintf(s, \"%d \", a[i]); sscanf(s, \"%d\", &amp;x); // 向字符串输出或从字符串读入 C++ string 类 #include &lt;string> std::string s; string 对 char 数组兼容，上述内容都可以直接使用。除此之外，它还有许多特有内容。 string 很方便，但也很慢，遇到数据规模大的题应当慎重使用。 建议大家熟练掌握字符数组、string 和 sstream，都是很有用的。 字符串算法 字符串算法基本上都基于所求信息的特殊性质和已经求出的信息，类似于动态规划。 Trie 树 Trie，又称字典树或者前缀树，可以用来保存字符串的集合，是一种树形数据结构。 引入 一棵简单的 Trie 采用类似于树上前缀和的计算方式，可以得出 222 号节点代表字符串 a，666 号代表 aaa。 实现 实现时，我们一般把根节点记为 000 号节点，因为它不代表任何字符串，每个节点有 ch[i][sigma_size]，其中 sigma_size 代表 Trie 树的字符集大小（不用 vector 之类的是为了保证时间效率，用空间换时间），表示是否有这个儿子。还有一个 val[i]，可以用于记录这个字符串的权值，比如记录这个节点是不是字符串。 模板，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, q, tot = 0; int ch[3000005][62], val[3000005]; int f(char x) &#123; if (x >= 'A' &amp;&amp; x &lt;= 'Z') return x - 'A'; if (x >= 'a' &amp;&amp; x &lt;= 'z') return x - 'a' + 26; return x - '0' + 52; &#125; void insert(char *s) &#123; int x = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) &#123; int c = f(s[i]); if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; val[x] += 1; &#125; &#125; int find(char *s) &#123; int x = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) &#123; int c = f(s[i]); if (!ch[x][c]) return 0; x = ch[x][c]; &#125; return val[x]; &#125; char s[3000005]; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 0; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; 62; ++j) ch[i][j] = 0; val[i] = 0; &#125; while (n--) &#123; scanf(\"%s\", s); insert(s); &#125; while (q--) &#123; scanf(\"%s\", s); printf(\"%d\\n\", find(s)); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; 字符串 Hash 我们可以将一个字符串通过一个函数 fff 映射为一个整数。 实现 我们通常这样定义 Hash 函数：f(s)=∑i=0l−1s[i]×bl−i(modM)f(s) = \\sum_{i=0}^{l-1} s[i] \\times b^{l-i} \\pmod Mf(s)=∑i=0l−1​s[i]×bl−i(modM)。有的时候是反过来的：f(s)=∑i=0l−1s[i]×bi−1(modM)f(s) = \\sum_{i=0}^{l-1} s[i] \\times b^{i-1} \\pmod Mf(s)=∑i=0l−1​s[i]×bi−1(modM)。不过相比之下，前者更为常用。其中的 bbb 可以根据心情决定其值。 模板，代码如下： 查看代码 #include &lt;bits/stdc++.h> #define LL long long using namespace std; int n, ans = 0; vector &lt;string> v[23333]; void calc(const string &amp;s) &#123; LL hash = 0; for (int i = s.length() - 1; i >= 0; --i) hash = (hash * 130 + s[i]) % 233; for (int i = 0; i &lt; v[hash].size(); ++i) if (v[hash][i] == s) return; v[hash].push_back(s); ++ans; &#125; int main(void) &#123; cin >> n; while (n--) &#123; string s; cin >> s; calc(s); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 上述代码采用了拉链法实现，效率相对来说比较低下，现在我们来介绍一种更为常用的方法： 我们采用两个模数做两次 Hash，如果 Hash 值都相同才判定它们是相同的。两个字符串 Hash 相同的概率本身就很小，双模数之后更小，因此几乎不会出错。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD1 = 998244853; const int MOD2 = 1011000007; i64 H1(const string &amp;s) &#123; i64 hash = 0; for (int i = s.length() - 1; i >= 0; --i) hash = (hash * 233 + s[i]) % MOD1; return hash; &#125; i64 H2(const string &amp;s) &#123; i64 hash = 0; for (int i = s.length() - 1; i >= 0; --i) hash = (hash * 233 + s[i]) % MOD2; return hash; &#125; pair&lt;i64, i64> a[10005]; int main(void) &#123; ios::sync_with_stdio(0); int n; cin >> n; string s; for (int i = 1; i &lt;= n; ++i) &#123; cin >> s; a[i] = make_pair(H1(s), H2(s)); &#125; sort(a + 1, a + n + 1); int ans = 1; for (int i = 2; i &lt;= n; ++i) if (a[i].first != a[i - 1].first &amp;&amp; a[i].second != a[i - 1].second) ++ans; printf(\"%d\\n\", ans); return 0; &#125; 子串 Hash 当哈希函数这样定义时：f(s)=∑i=1ls[i]×bl−i(modM)f(s) = \\sum_{i=1}^{l} s[i] \\times b^{l-i} \\pmod Mf(s)=∑i=1l​s[i]×bl−i(modM)。我们可以采用类似于前缀和的方式来快速求解子串的哈希（从 111 开始编号）。 令 fj(s)f_j(s)fj​(s) 代表 f(s[1…j])f(s[1\\dots j])f(s[1…j])，那么有 fj(s)=∑i=1js[i]×br−i(modM)f_j(s)=\\sum_{i=1}^{j} s[i] \\times b^{r-i} \\pmod Mfj​(s)=∑i=1j​s[i]×br−i(modM)，而 f(s[l…r])=s[l]×br−l+⋯+s[r]f(s[l\\dots r])=s[l]\\times b^{r-l}+\\cdots+s[r]f(s[l…r])=s[l]×br−l+⋯+s[r]，进而有 f(s[l…r])=fr(s)−fl−1(s)×br−l+1f(s[l\\dots r])=f_r(s)-f_{l-1}(s)\\times b^{r-l+1}f(s[l…r])=fr​(s)−fl−1​(s)×br−l+1。 Hash 的应用 字符串哈希能解决很多问题。 字符串匹配 求出模式串的哈希值，然后查找每一个字串的哈希值，比较是否相等。 允许失配的字符串匹配 比如说允许失配 kkk 次。这个问题可以使用 Hash + 二分来解决，设当前枚举的子串为 s′s&#x27;s′，可以二分出 s′s&#x27;s′ 第一个与模式串不同的地方，然后将这个失配的位置以前的内容删去，再查找下一个失配的位置。时间复杂度为 O(knlog⁡m)O(kn\\log m)O(knlogm)。 最长回文子串 记 RiR_iRi​ 代表以 iii 结尾的最长回文长度。由于 Ri≤Ri−1+2R_i\\le R_{i-1}+2Ri​≤Ri−1​+2，因此我们只需要从 Ri−1+2R_{i-1}+2Ri−1​+2 的长度开始递减，找到第一个回文串即可，时间复杂度为 O(n)O(n)O(n)。 Manacher 算法 它可以高效解决回文问题。 概述 Manacher 仅能找到长度为奇数的回文串，因此在它工作前，我们要在它的每个字符间都插入一个相同的分割符。同时还要在字符串前后插入一对不同的字符防止越界。 设以 sis_isi​ 为对称中心的回文串中最长的回文半径（以 iii 为对称中心，回文串的长度为奇数，半径是指从对称中心到一段的字符串长度）为 pip_ipi​。那么如果 xxx 是 iii 的回文半径，则 0∼x0\\sim x0∼x 都是。 Manacher 会记录在遍历过的 1∼i−11\\sim i-11∼i−1 中，以任意一点为对称中心的回文串最大右端点 rrr，并记录此时的对称中心 ddd。若当前 i&gt;ri&gt;ri&gt;r，则让 pi=1p_i=1pi​=1 直接开算；否则将 pip_ipi​ 先赋值成 min⁡{p2d−i,r−i+1}\\min\\{p_{2d-i},r-i+1\\}min{p2d−i​,r−i+1} 再尝试更新。因为 2d−i2d-i2d−i 与 iii 关于 ddd 对称，因此在 [d−r+1,d+r−1][d-r+1,d+r-1][d−r+1,d+r−1] 内，以 2d−i2d-i2d−i 为对称中心的回文串也是以 iii 为对称中心的回文串。当 p2d−i&lt;r−i+1p_{2d-i}&lt;r-i+1p2d−i​&lt;r−i+1 时，pip_ipi​ 已经最大（否则 p2d−ip_{2d-i}p2d−i​ 也可以更大）；否则 pip_ipi​ 被初始化为 r−i+1r-i+1r−i+1（不能超过 ddd 的势力范围，因为这个对称性尽在 [d−r+1,d+r−1][d-r+1,d+r-1][d−r+1,d+r−1] 内生效，需要满足 i+pi−1≤ri+p_i-1\\le ri+pi​−1≤r）。由于每次扩展都会使 rrr 变大，故均摊时间复杂度为 O(n)O(n)O(n)。 模板，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int m, n, p[22000010]; char s[22000010], t[11000005]; int main(void) &#123; scanf(\"%s\", t + 1); m = strlen(t + 1); s[0] = '#'; s[n = 1] = '@'; for (int i = 1; i &lt;= m; ++i) s[++n] = t[i], s[++n] = '@'; s[n + 1] = '!'; int ans = 0; for (int i = 1, r = 0, d = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, p[2 * d - i]); while (s[i - p[i]] == s[i + p[i]]) ++p[i]; if (i + p[i] - 1 > r) d = i, r = i + p[i] - 1; ans = max(ans, p[i] - 1); &#125; printf(\"%d\\n\", ans); return 0; &#125; 应用 我们戏称 Manacher 算法为马拉车，它可以求出以某个字符开头或结尾的最长回文子串。 以固定结尾为例。考虑每一个位置 iii，若我们更新了 rrr，那么在更新 rrr 前要对 [r+1,i+pi−1][r+1,i+p_i-1][r+1,i+pi​−1] 的答案更新为 j−i+1j-i+1j−i+1（jjj 不是分隔符的时候进行）。 均摊之后时间复杂度依然为 O(n)O(n)O(n)。 [国家集训队]最长双回文串。我们正反跑两边 Manacher，找出以某个字符开始或结束的最长回文串。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int m, n, p[200010]; int L[100010], R[100010]; char t[100005], s[200010]; int P(int x) &#123; if (x >= 1 &amp;&amp; x &lt;= n) return p[x]; return 0; &#125; int main(void) &#123; scanf(\"%s\", t + 1); m = strlen(t + 1); s[0] = '#'; s[n = 1] = '@'; for (int i = 1; i &lt;= m; ++i) s[++n] = t[i], s[++n] = '@'; s[n + 1] = '!'; for (int i = 1, d = 0, r = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, P(2 * d - i)); while (s[i + p[i]] == s[i - p[i]]) ++p[i]; if (i + p[i] - 1 > r) &#123; for (int j = r + 1; j &lt;= i + p[i] - 1; ++j) if (j % 2 == 0) R[j / 2] = j - i + 1; d = i, r = i + p[i] - 1; &#125; &#125; for (int i = n, d = 0, r = n; i >= 1; --i) &#123; if (i &lt; r) p[i] = 1; else p[i] = min(i - r + 1, P(2 * d - i)); while (s[i + p[i]] == s[i - p[i]]) ++p[i]; if (i - p[i] + 1 &lt; r) &#123; for (int j = r - 1; j >= i - p[i] + 1; --j) if (j % 2 == 0) L[j / 2] = i - j + 1; d = i, r = i - p[i] + 1; &#125; &#125; int ans = 0; for (int i = 1; i &lt; m; ++i) if (R[i] &amp;&amp; L[i + 1]) ans = max(ans, R[i] + L[i + 1]); printf(\"%d\\n\", ans); return 0; &#125; KMP 模式匹配 虽然说这是个基础算法，但是思想非常棒。 KMP 算法能够在线性时间内判定一个字符串在另一个字符串中所有出现位置，而且为我们提供了一些非常有用的附加信息。 概述 模板。 现在我们要对字符串 AAA 计算其在 BBB 中的出现位置，过程分为两步： 对 AAA 自己进行匹配，求出 nxtnxtnxt 数组，nxt[i]nxt[i]nxt[i] 代表 A 中以 iii 结尾的非前缀子串与 A 的前缀能够匹配的最大长度，也就是说 nxt[i]=max⁡{j∣j&lt;i,A[i−j+1∼i]=A[1∼j]}nxt[i]=\\max\\{j\\mid j&lt;i,A[i-j+1\\sim i]=A[1\\sim j]\\}nxt[i]=max{j∣j&lt;i,A[i−j+1∼i]=A[1∼j]}，如果不存在则 nxt[i]=0nxt[i]=0nxt[i]=0。 对 AAA 和 BBB 进行匹配，求出数组 fff，f[i]f[i]f[i] 代表 BBB 中以 iii 结尾的子串与 AAA 的前缀能够匹配的最大长度。 这两步的实现方式几乎一样，我们以第 111 步为例子。 根据定义，nxt[1]=0nxt[1]=0nxt[1]=0，接下来我们扫描字符串依次计算 nxtnxtnxt。假定 nxt[1∼i−1]nxt[1\\sim i-1]nxt[1∼i−1] 已经计算完毕，记 ppp 为当前扩展的长度，并尝试继续扩展。如果扩展失败，那么令 p=nxt[p]p=nxt[p]p=nxt[p]，直到 ppp 变为 000。如果能够匹配成功，ppp 就加一，此时 nxt[i]nxt[i]nxt[i] 就为 ppp。 均摊时间复杂度为 O(n+m)O(n+m)O(n+m)，这里不作证明[1]。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, nxt[1000005], f[1000005]; char s1[1000005], s2[1000005]; int main(void) &#123; scanf(\"%s%s\", s1 + 1, s2 + 1); n = strlen(s1 + 1), m = strlen(s2 + 1); for (int i = 2, p = 0; i &lt;= m; ++i) &#123; while (p &amp;&amp; s2[i] != s2[p + 1]) p = nxt[p]; // 扩展失败 if (s2[i] == s2[p + 1]) ++p; // 尝试扩展匹配长度 nxt[i] = p; &#125; for (int i = 1, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s1[i] != s2[p + 1]) p = nxt[p]; if (s1[i] == s2[p + 1]) ++p; f[i] = p; if (f[i] == m) printf(\"%d\\n\", i - m + 1); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d \", nxt[i]); putchar('\\n'); return 0; &#125; Border 理论 定义长度为 nnn 的字符串 sss 的 Border(s)\\text{Border}(s)Border(s) 表示 sss 所有相等的真前缀后缀集合。也就是说，如果一个字符串是 Border，那么它同时是 sss 的前缀和后缀。而 sss 中最长的一个 Border 就是 nxt[n]nxt[n]nxt[n]。 如果说 ppp 是 sss 的周期，那么 si=si+p(1≤i≤n−p)s_i=s_{i+p}(1\\le i\\le n-p)si​=si+p​(1≤i≤n−p)。 Border 拥有以下性质： 若 ppp 为 sss 的周期，则 s[1…n−p]s[1\\dots n-p]s[1…n−p] 为 sss 的 Border。由周期的定义即可证明。 如果 sss 存在 Border，那么最短的长度不超过字符串的一半。 字符串 sss 的最小周期为 ∣S∣−nxt[∣S∣]|S| - nxt[|S|]∣S∣−nxt[∣S∣]。 失配树 如果我们从 nxt[i]nxt[i]nxt[i] 向 iii 连边，那么我们会得到一棵以 111 为根的有根树，这就是失配树。 失配树具有一个很好的性质：对于树上任意两个具有祖先后代关系的节点 x,yx,yx,y，s[1…x]s[1\\dots x]s[1…x] 是 s[1…y]s[1\\dots y]s[1…y] 的 Border。因此要查询两个前缀字符串的最长公共 Border，只需要查找两个点在失配树上的 LCA 即可（由于 Border 不能是自己，因此不要特判 x=yx=yx=y）。 模板，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, f[20][1000005], dep[1000005]; char s[1000005]; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 19; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; for (int i = 19; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; int main(void) &#123; scanf(\"%s%d\", s + 1, &amp;m); n = strlen(s + 1); dep[1] = 1; for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = f[0][p]; if (s[i] == s[p + 1]) ++p; dep[i] = dep[f[0][i] = p] + 1; &#125; for (int i = 1; i &lt;= 19; ++i) for (int j = 1; j &lt;= n; ++j) f[i][j] = f[i - 1][f[i - 1][j]]; while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", LCA(x, y)); &#125; return 0; &#125; Z 函数 后缀数组 Problemset 字符串的题很多，也很有趣。 Trie Trie 树看起来很简单，但真的很有用。 [TJOI2010] 阅读理解 Portal. 空间限制很紧张，那么就对询问建立 Trie，然后依次检索文章，最后统一输出答案。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;string> #include &lt;set> using namespace std; int n, m; int ch[200005][26], tot = 0; string tmp; vector&lt;string> a[1005]; vector&lt;int> ret[200005]; set&lt;int> ans[100005]; void insert(int p) &#123; cin >> tmp; int x = 0; for (int i = 0; i &lt; tmp.length(); ++i) &#123; int c = tmp[i] - 'a'; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; ret[x].emplace_back(p); &#125; void check(int p, int y) &#123; int x = 0; string &amp;s = a[p][y]; for (int i = 0; i &lt; s.length(); ++i) &#123; int c = s[i] - 'a'; if (!ch[x][c]) return; x = ch[x][c]; &#125; for (int i = 0; i &lt; ret[x].size(); ++i) ans[ret[x][i]].insert(p); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int l; scanf(\"%d\", &amp;l); while (l--) &#123; cin >> tmp; a[i].push_back(tmp); &#125; &#125; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) insert(i); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; a[i].size(); ++j) check(i, j); for (int i = 1; i &lt;= m; ++i) &#123; for (int x : ans[i]) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; [USACO08DEC] Secret Message G Portal. 直接建 Trie 统计即可，注意不要算重。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; int m, n; int ch[500005][2], tot = 0; int s[500005], e[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) &#123; int len, x = 0; scanf(\"%d\", &amp;len); for (int j = 0; j &lt; len; ++j) &#123; int c; scanf(\"%d\", &amp;c); if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; ++s[x]; &#125; ++e[x]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int len, x = 0, ans = 0; scanf(\"%d\", &amp;len); bool flag = false; for (int j = 0; j &lt; len; ++j) &#123; int c; scanf(\"%d\", &amp;c); if (flag) continue; if (!ch[x][c]) flag = true; x = ch[x][c]; ans += e[x]; &#125; if (!flag) ans += s[x] - e[x]; printf(\"%d\\n\", ans); &#125; return 0; &#125; [USACO12DEC] First! G Portal.有 nnn 个仅有小写字母构成的字符串，你可以任意改变字符的顺序（比如规定 b 比 a 小），问哪些字符串可以通过这种方式变成字典序最小的字符串。 想一想，字典序的比较是从前到后的。首先如果一个字符串是另一个的前缀，那么不作为前缀的那个一定不可以。这样以来，我们建立 Trie 树，在 Trie 上同一父亲，同一层的节点会进行字典序比较，我们只需要给这些字符连一条有向边，代表大小关系，最后会得到一张图。改变的字符顺序就是这个图的拓扑序。如果这个图不是 DAG，那么这个字符串不能作为答案。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;queue> using namespace std; int n; int ch[300005][26], tot = 0; bool e[300005], is_ans[30005]; string s[30005]; void insert(int p) &#123; int x = 0; cin >> s[p]; for (int i = 0; i &lt; s[p].length(); ++i) &#123; int c = s[p][i] - 'a'; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; e[x] = true; &#125; int in[30]; bool G[30][30]; void Kahn(void) &#123; queue&lt;int> q; for (int i = 0; i &lt; 26; ++i) if (in[i] == 0) q.push(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v = 0; v &lt; 26; ++v) if (G[u][v]) &#123; --in[v]; if (in[v] == 0) q.push(v); &#125; &#125; &#125; bool check(int p) &#123; string &amp;t = s[p]; int x = 0; memset(G, 0, sizeof(G)); memset(in, 0, sizeof(in)); for (int i = 0; i &lt; t.length(); ++i) &#123; if (e[x]) return false; int c = t[i] - 'a'; for (int j = 0; j &lt; 26; ++j) if (c != j &amp;&amp; ch[x][j] &amp;&amp; !G[c][j]) &#123; G[c][j] = true; // o->m m->o ++in[j]; &#125; x = ch[x][c]; &#125; Kahn(); for (int i = 0; i &lt; 26; ++i) if (in[i]) return false; return true; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) insert(i); int ans = 0; for (int i = 1; i &lt;= n; ++i) if (check(i)) &#123; ++ans; is_ans[i] = true; &#125; printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (is_ans[i]) cout &lt;&lt; s[i] &lt;&lt; '\\n'; return 0; &#125; [SCOI2016] 背单词 Portal.一共要学习 nnn 个单词，可以自行决定学习单词的顺序，学习第 xxx 个单词要吃的铁轨数量是：如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 n×nn \\times nn×n 个铁轨才能学会；当它的所有后缀都被填入表内的情况下，如果在 1⋯x−11 \\cdots x-11⋯x−1 的位置上的单词都不是它的后缀，那么他吃 xxx 个铁轨就能记住它；当它的所有后缀都被填入表内的情况下，如果 1⋯x−11 \\cdots x-11⋯x−1 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 yyy，那么他只要吃 x−yx-yx−y 个铁轨就能把它记住。 后缀相同可以转化为前缀相同（可以翻转字符串，也可以反着建 Trie），111 决策显然是不优的，利用它省操作怎么都省不下来，而且不存在两个单词互为前缀，所以 111 决策一定可以避免。 222 的话其实是 333 中 y=0y=0y=0 的情况。也就是说，我们可以当作只有 333 操作。 建立好 Trie 树后，为了防止 111 操作的出现，我们一定要按照 DFS 序进行遍历（其它方式并不优）。由于非字符串的节点是没有贡献的，所以我们可以把它们去掉，将剩下的点作为导出子树进行 DFS 序遍历，而且是越重的越靠后遍历。为什么？采用微扰法来证明贪心，一个重的子树和轻的子树交换遍历顺序，那么只有重的子树的根节点的代价和轻的子树的根节点代价会改变，交换前代价是轻子树的大小，交换后代价是重子树的大小，因此不交换更优。 为什么要按照 DFS 序进行遍历？同样可以使用微扰法来证明，可以发现任意交换两个之后它们的贡献都会变大（距离父亲的遍历序号更远了，吃的铁轨数量更多了），因此一定不优。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> #include &lt;vector> using namespace std; typedef long long i64; i64 ans = 0; int n, ch[510005][26], tot = 0, cnt = 0; int siz[500005], dfn[500005], lst[500005]; char s[500005]; bool e[510005]; vector&lt;int> G[500005]; bool cmp(int x, int y) &#123; return siz[x] &lt; siz[y]; &#125; void dfs(int x) &#123; if (e[x]) G[lst[x]].emplace_back(x), lst[x] = x; for (int i = 0; i &lt; 26; ++i) if (ch[x][i]) lst[ch[x][i]] = lst[x], dfs(ch[x][i]); &#125; void dfs2(int x, int fa) &#123; siz[x] = 1; for (int y : G[x]) &#123; dfs2(y, x); siz[x] += siz[y]; &#125; sort(G[x].begin(), G[x].end(), cmp); &#125; void dfs3(int x, int fa) &#123; dfn[x] = ++cnt; ans += dfn[x] - dfn[fa]; for (int y : G[x]) dfs3(y, x); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", s); reverse(s, s + strlen(s)); int x = 0; for (int i = 0; s[i]; ++i) &#123; int c = s[i] - 'a'; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; e[x] = true; &#125; dfs(0); dfs2(0, 0); dfs3(0, 0); printf(\"%lld\\n\", ans); return 0; &#125; [JSOI2009] 电子词典 Portal.有 n(n≤104)n(n\\le 10^4)n(n≤104) 个单词的词典和 m(m≤104)m(m\\le 10^4)m(m≤104) 次询问，每次询问词典中有多少个单词与查询的单词可以模糊匹配（指可以通过一次修改、删除或添加字符变成一样的字符串），如果本来就有这个单词则输出 -1。保证 ∣s∣≤20|s|\\le 20∣s∣≤20。 对词典构建 Trie 树，对于每个询问则直接使用 DFS 暴力查找，记录一个 flag 表示是否编辑过即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;set> using namespace std; int n, m, len, ans; int ch[200000][26], tot = 0; char s[25]; bool e[200000], vis[200000], is_word; set&lt;int> S; void dfs(int x, int p, bool flag) &#123; if (p == len &amp;&amp; e[x]) &#123; if (!flag) is_word = true; else S.insert(x); return; &#125; int c = s[p] - 'a'; if (ch[x][c]) dfs(ch[x][c], p + 1, flag); // 正常写 if (!flag) &#123; if (p &lt; len) dfs(x, p + 1, true); // 删除 for (int i = 0; i &lt; 26; ++i) if (ch[x][i]) &#123; dfs(ch[x][i], p, true); // 添加 if (p &lt; len &amp;&amp; i != c) dfs(ch[x][i], p + 1, true); // 修改 &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (n--) &#123; scanf(\"%s\", s); int x = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) &#123; int c = s[i] - 'a'; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; e[x] = true; &#125; while (m--) &#123; is_word = false; ans = 0; scanf(\"%s\", s); len = strlen(s); S.clear(); dfs(0, 0, 0); if (is_word) puts(\"-1\"); else printf(\"%d\\n\", S.size()); &#125; return 0; &#125; 字符串 Hash Hash 算法很简单，可以完成许多需要高级算法才能完成的任务。 [NOI Online 2021 提高组] 积木小赛 Portal. 我们枚举 Bob 字符串，看是否能匹配，并计算其 Hash 值，然后去重就是答案。这不是正解，需要吸氧。 查看代码 #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef unsigned long long u64; int n, tot = 0; char a[3010], b[3010]; u64 t[9000005]; int main(void) &#123; scanf(\"%d\", &amp;n); fgets_unlocked(a + 1, 5, stdin); fgets_unlocked(a + 1, 3002, stdin); fgets_unlocked(b + 1, 3002, stdin); for (int i = 1; i &lt;= n; ++i) &#123; u64 v = 0; int p = 1; for (int j = i; j &lt;= n; ++j) &#123; while (p &lt;= n &amp;&amp; a[p] != b[j]) ++p; if (p > n) break; ++p; v = v * 233 + b[j]; t[++tot] = v; &#125; &#125; sort(t + 1, t + tot + 1); int ans = 1; for (int i = 2; i &lt;= tot; ++i) if (t[i] != t[i - 1]) ++ans; printf(\"%d\\n\", ans); return 0; &#125; [CF1200E] Compress Words Portal. 使用字符串哈希求出最长的相等前后缀。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int B1 = 233, B2 = 479; const int M1 = 957657979, M2 = 996987653; int n, m, l, b1[1000005], b2[1000005]; char s[100005], ans[1000005]; int ash1[1000005], ash2[1000005]; int main(void) &#123; int n; scanf(\"%d\", &amp;n); b1[0] = b2[0] = 1; for (int i = 1; i &lt;= 1000000; ++i) b1[i] = 1ll * b1[i - 1] * B1 % M1; for (int i = 1; i &lt;= 1000000; ++i) b2[i] = 1ll * b2[i - 1] * B2 % M2; for (int op = 1; op &lt;= n; ++op) &#123; scanf(\"%s\", s + 1); m = strlen(s + 1); int h1 = 0, h2 = 0, len = 0; for (int i = 1; i &lt;= m &amp;&amp; i &lt;= l; ++i) &#123; h1 = (1ll * h1 * B1 + s[i]) % M1; h2 = (1ll * h2 * B2 + s[i]) % M2; if (ash1[l] == (h1 + 1ll * ash1[l - i] * b1[i]) % M1 &amp;&amp; ash2[l] == (h2 + 1ll * ash2[l - i] * b2[i]) % M2) len = i; &#125; for (int i = len + 1; i &lt;= m; ++i) &#123; ans[++l] = s[i]; ash1[l] = (1ll * ash1[l - 1] * B1 + s[i]) % M1; ash2[l] = (1ll * ash2[l - 1] * B2 + s[i]) % M2; &#125; &#125; printf(\"%s\\n\", ans + 1); return 0; &#125; Manacher 算法 就是回文。 [国家集训队] 拉拉队排练 Portal. 直接 Manacher，利用前缀和统计不同长度的回文串即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 19930726; int n, p[1000005], cnt[1000005]; i64 k; char s[1000005]; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int main(void) &#123; scanf(\"%d%lld%s\", &amp;n, &amp;k, s + 1); s[0] = '$', s[n + 1] = '%'; for (int i = 1, r = 0, d = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, p[2 * d - i]); while (s[i - p[i]] == s[i + p[i]]) ++p[i]; if (i + p[i] - 1 > r) d = i, r = i + p[i] - 1; ++cnt[p[i]]; &#125; int ans = 1; for (int i = (n + 1) / 2; i >= 1 &amp;&amp; k > 0; --i) &#123; cnt[i] += cnt[i + 1]; ans = 1ll * ans * poww(i * 2 - 1, min(k, (i64)cnt[i])) % MOD; k -= cnt[i]; &#125; if (k > 0) puts(\"-1\"); else printf(\"%d\\n\", ans); return 0; &#125; [UVA11475] Extend to Palindrome Portal. 用 Manacher 求出第一个可以扩展到结尾的子串，然后根据它扩展即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; const int MOD = 19930726; int n, p[1000005]; char t[1000005], s[2000005]; int main(void) &#123; while (scanf(\"%s\", t + 1) == 1) &#123; s[0] = '$'; s[n = 1] = '@'; int m = strlen(t + 1), pos; for (int i = 1; i &lt;= m; ++i) s[++n] = t[i], s[++n] = '@'; s[n + 1] = '%'; for (int i = 1, d = 0, r = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, p[2 * d - i]); while (s[i - p[i]] == s[i + p[i]]) ++p[i]; if (i + p[i] - 1 > r) d = i, r = i + p[i] - 1; if (i + p[i] - 1 == n) &#123; pos = (i - p[i] + 1) / 2; break; &#125; &#125; printf(\"%s\", t + 1); for (int i = pos; i >= 1; --i) putchar(t[i]); putchar('\\n'); &#125; return 0; &#125; [THUPC2018] 绿绿和串串 Portal.绿绿有一个由小写字母组成的非空字符串 RRR，但 Yazid 不知道它具体是什么。我们定义翻转的操作：把一个串以最后一个字符作对称轴进行翻转复制。形式化地描述就是，如果他翻转的串为 RRR，那么他会将前 ∣R∣−1\\left| R\\right|-1∣R∣−1 个字符倒序排列后，插入到串的最后。举例而言，串 abcd 进行翻转操作后，将得到 abcdcba；串 qw 连续进行 222 次翻转操作后，将得到 qwqwq；串 z 无论进行多少次翻转操作，都不会被改变。贪玩的绿绿进行了若干次（可能为 000 次）翻转操作。淘气的绿绿又展示出了一个非空串 SSS，并表示 SSS 是最终的串 RRR 的前缀。现在，他想考考 Yazid，初始的串 RRR 的长度可能是多少。Yazid 找到了正在参加清华校赛的你，请你来帮他解决这个问题。但聪明的 Yazid 发现，所有超过 ∣S∣\\left| S\\right|∣S∣ 的整数都一定是 RRR 的可能长度，因此你只需要告诉他不超过的 ∣S∣\\left| S\\right|∣S∣ 的 RRR 的可能长度即可。保证 ∣S∣≤106\\left| S\\right|\\leq 10^6∣S∣≤106，∑∣S∣≤5×106\\sum\\left| S\\right|\\leq 5\\times 10^6∑∣S∣≤5×106。 什么样的字符串可以满足？以 nnn 结尾的回文串一定可以。然后呢？我们来看 qwqwq 这个样例。 显然 qwq 是可以的，那么 qw 也是可以的。也就是说，如果 1∼2i−11\\sim 2i-11∼2i−1 是一个以 iii 为回文中心的回文串，那么这部分就可以由 1∼i1\\sim i1∼i 复制出来，只需要 1∼2i−11\\sim 2i-11∼2i−1 条件即可。这样就成了一个递归问题，递推求解即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;set> using namespace std; int m, n, p[10000010]; char t[5000005]; char s[10000010]; bool vis[10000010]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", t + 1); m = strlen(t + 1); s[0] = '$'; s[n = 1] = '@'; for (int i = 1; i &lt;= m; ++i) s[++n] = t[i], s[++n] = '@'; s[n + 1] = '!'; fill(vis + 1, vis + n + 1, 0); for (int i = 1, d = 0, r = 0; i &lt;= n; ++i) &#123; if (i > r) p[i] = 1; else p[i] = min(r - i + 1, p[d * 2 - i]); while (s[i - p[i]] == s[i + p[i]]) ++p[i]; if (i + p[i] - 1 > r) d = i, r = i + p[i] - 1; &#125; for (int i = n; i >= 1; --i) &#123; if (i + p[i] - 1 == n) vis[i] = 1; else if (i == p[i] &amp;&amp; vis[i + p[i] - 2]) vis[i] = 1; &#125; for (int i = 2; i &lt;= n; i += 2) if (vis[i]) printf(\"%d \", i / 2); putchar('\\n'); &#125; return 0; &#125; KMP 模式匹配 很多时候我们使用 KMP 并不是为了求解字符串匹配，而是为了使用 nxtnxtnxt 数组：以 iii 结尾的非前缀子串与 A 的前缀能够匹配的最大长度。 [CF126B] Password Portal. 正反做两次 KMP，然后尝试将它们合并即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int n, nxt1[1000005], nxt2[1000005]; char s[1000005]; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt1[p]; if (s[i] == s[p + 1]) ++p; nxt1[i] = p; &#125; reverse(s + 1, s + n + 1); for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt2[p]; if (s[i] == s[p + 1]) ++p; nxt2[i] = p; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) if (nxt1[i] == nxt2[n - i + nxt1[i]]) ans = max(ans, nxt1[i]); if (ans == 0) puts(\"Just a legend\"); else &#123; for (int i = ans; i >= 1; --i) putchar(s[i]); putchar('\\n'); &#125; return 0; &#125; [CF808G] Anthem of Berland Portal.给定字符串 sss 和 ttt，但是 sss 中的一些字符丢失了。问 ttt 在 sss 中最多出现多少次。两个字符串长度的乘积在 10710^7107 级别。 考虑 DP。设 f(i)f(i)f(i) 代表考虑到第 iii 位的最多出现次数，初始 f(i)=f(i−1)f(i)=f(i-1)f(i)=f(i−1)。除了能直接转移 f(i)=f(i−m)+1f(i)=f(i-m)+1f(i)=f(i−m)+1，中间可能还有 ttt。考虑对 ttt 进行模式匹配，在中间寻找能够进行的转移即可。注意从这个转移过来的不能进行转移 f(i)=f(i−m)+1f(i)=f(i-m)+1f(i)=f(i−m)+1。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, nxt[100005], f[100005], g[100005]; char s[100005], t[100005]; bool check(int p) &#123; if (p - m + 1 &lt; 1) return false; for (int i = 1; i &lt;= m; ++i) if (s[p - m + i] != '?' &amp;&amp; s[p - m + i] != t[i]) return false; return true; &#125; int main(void) &#123; scanf(\"%s%s\", s + 1, t + 1); n = strlen(s + 1), m = strlen(t + 1); for (int i = 2, p = 0; i &lt;= m; ++i) &#123; while (p &amp;&amp; t[i] != t[p + 1]) p = nxt[p]; if (t[i] == t[p + 1]) ++p; nxt[i] = p; &#125; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = f[i - 1]; if (check(i)) &#123; g[i] = f[i - m] + 1; for (int j = nxt[m]; j; j = nxt[j]) g[i] = max(g[i], g[i - m + j] + 1); f[i] = max(f[i], g[i]); &#125; &#125; printf(\"%d\\n\", f[n]); return 0; &#125; [NOI2014] 动物园 Portal. 在 nxtnxtnxt 数组上倍增即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int MOD = 1000000007; int nxt[22][1000005]; char s[1000005]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); int ans, n; while (T--) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1), ans = 1; for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt[0][p]; if (s[i] == s[p + 1]) ++p; nxt[0][i] = p; &#125; for (int j = 1; j &lt;= 19; ++j) for (int i = 1; i &lt;= n; ++i) nxt[j][i] = nxt[j - 1][nxt[j - 1][i]]; for (int i = 1; i &lt;= n; ++i) &#123; int p = i, cnt = 0; for (int j = 19; j >= 0; --j) if (nxt[j][p] * 2 > i) p = nxt[j][p]; for (int j = 19; j >= 0; --j) if (nxt[j][p]) p = nxt[j][p], cnt += (1 &lt;&lt; j); ans = 1ll * (cnt + 1) * ans % MOD; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [NOIP2020] 字符串匹配 Portal. 我们枚举 (AB)(AB)(AB) 的长度和 iii，求出 nxtnxtnxt 数组用于判断这个 iii 是否合法。时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1048580; int n, nxt[N]; int pre[N], suf[N], cnt[26], tmp[27]; // tmp[i] 记录 A 中出现 0~i 个奇数字符的方案数 // pre[i] 记录 s[1...i] 中出现奇数字符的个数 char s[N]; void solve(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); suf[n + 1] = 0; for (int i = 2, p = 0; i &lt;= n; ++i) &#123; while (p &amp;&amp; s[i] != s[p + 1]) p = nxt[p]; if (s[i] == s[p + 1]) ++p; nxt[i] = p; &#125; memset(cnt, 0, sizeof cnt); for (int i = n; i >= 1; --i) &#123; ++cnt[s[i] - 'a']; if (cnt[s[i] - 'a'] &amp; 1) suf[i] = suf[i + 1] + 1; else suf[i] = suf[i + 1] - 1; &#125; memset(cnt, 0, sizeof cnt); for (int i = 1; i &lt;= n; ++i) &#123; ++cnt[s[i] - 'a']; if (cnt[s[i] - 'a'] &amp; 1) pre[i] = pre[i - 1] + 1; else pre[i] = pre[i - 1] - 1; &#125; long long ans = 0; memset(tmp, 0, sizeof tmp); for (int i = 1; i &lt; n; ++i) &#123; // |AB| 的长度 if (i >= 2) &#123; ans += tmp[suf[i + 1]]; for (int j = i + i; j &lt; n &amp;&amp; i % (j - nxt[j]) == 0; j += i) ans += tmp[suf[j + 1]]; &#125; for (int j = pre[i]; j &lt;= 26; ++j) ++tmp[j]; &#125; printf(\"%lld\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; 实际上这是 MP 算法（KMP 在两个字符相等时会直接跳过），不过 MP 已经达到了理论时间复杂度下限。 ↩︎","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://james1badcreeper.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"2022~2023 省选日志","slug":"summaries/游记/SX2022","date":"2022-11-27T00:00:00.000Z","updated":"2022-11-27T00:00:00.000Z","comments":false,"path":"da8ee41/","link":"","permalink":"https://james1badcreeper.github.io/da8ee41/","excerpt":"Burn everything with Raging Hellfire.","text":"Burn everything with Raging Hellfire. 2022 尾声。 11 月 NOIP 没有了！嘎嘎！退钱！ 得出的结论：参加 NOIP-Spring 2023 需要交钱！嘎嘎！ 这几个月没什么事情，该干什么干什么吧。 新冠感冒（12.13） 呜哇！羊了个阳！ 大概是这一天晚上在机房感觉有点不对劲，第二天起来真的不对劲了。于是就请假了。 学校已经很可怕，所以我请假的次日教练让大家都居家了。 亲身经验得出，感觉奥密克戎真的很弱，就跟普通感冒一样，个人没什么大碍，居家即可。 所以说，学校阳的太多了，应该放几只狼进去。 《Charlotte》观后感（12.16 日下午 ~ 12.17 11:40 PM） 我不知道为很么我一口气刷了一部番，然后在次日又对一些内容进行了二刷并补了 SP、看了漫画的尾声。仔细想想我应该是在中考之后第一次看番（期间与 ACG 唯一有关的活动就是推了 Summer Pockets RB 的一条线），这也是第二次接触与 key 的作品。 双向救赎，约定，非常感人。但是我会碰到吗？虽然说是挺羡慕的，但是这种事情可遇不可求。现在，我只有自我救赎（Redemption Zero）。 还有一点，国王排名（虽然可能确实有一点降智打击）、sprb 和 Charlotte 都有人指出有不少缺点，但我在看的时候真的每感觉出来。可能是我没有审美或者比较基数太少，而更重要的应该是我不注重细节。现在 OI 的学习有时候为了“赶进度”，Dinic 都是背的（目前看来确实无伤大雅，而且由于找的资料一般都比较靠谱所以不用太在意正确性），能够严谨对待的事情似乎没有了。在我开来，唯一值得我应该严谨对待的只剩下前沿科学的研究了。虽然这个事现在看起来与我无关，但是我迟早会碰上这些的。 最后说一句，奈绪真可爱。 pixiv: 51873061 时间交换律 &amp; 第一次省选模拟（12.18） 实际上是这样的，想干的事情任何时候都可以干，但是考试时间是定的，说白了就是先学习后娱乐。 模拟赛爆零了，甚至不如 2019 年联合省选考场上的表现，深深认识到了自己的差距。接下来，阳了先写完作业，再以养病为主。 我是垃圾 新的开始（12.19） 不管怎样，装作自己病好了。 这周是数数，啊，大的来的这么快吗。 年终 2022 年的最后一天！ 现在决定改变学习方式，作业里多放了一个 CF、AT 的板刷题单。 2023 实际上只有两个月了，已经过半了。 暴走（1.2） 大概说的意思是谁不卷就斩掉示众。 《魔女の旅々》观后感（1.3） 看完之后又看了几章小说，大概来写一下。 单元剧！并不像传统的轻小说，而是整成了一千零一夜+伊索寓言，加上可爱的伊雷娜，非常好看（至少对于我来说）！ 新年快乐（雾）！ WC 测试（1.17） 难得回一次学校，找找感觉。WC 正常打。 然后铁了。眼睛瞎以为 T1 输出一个 -1，不知道约数有什么用。 所以呢？还是得向前啊。 怎么群友都说 T1 那个约数很容易看出来的，破防。 1.18 为什么，我会如此伤感呢…… 1.24 感觉自己需要写一点东西静静。WC、春节之后，整个人更加杂乱，会对着黑天或灰白的天大喊“天蓝啊！”。其实没什么大不了的，人本来就是这样，就是一种愚蠢的动物。 只要我眼里的星光仍在闪烁，我便能一往无前！ 1.27 机房团建！狼人杀很好玩！ 然后尝试了血染钟楼！非常强大！但是我真没想到樱雪是大狼！搞不懂怎么演的这么像的！ 感觉多哥说的有道理，当坏人的压力真的很大！还是好人舒服！ 2.12 省选计划模拟赛终于过题了（前期 #7）！感动啊老哥！感谢 CYJ！以后也要继续努力呢！ 2.19 省选计划前期最后一场！ 写了 T2 的根号分治，拿到了 505050 的好成绩！正解是利用 bitset 代替掉 unordered_set，时间复杂度可以做到 O(nnw)O\\left(n\\sqrt{\\frac{n}{w}}\\right)O(nwn​​)，直呼 orz！ 落幕 。 3.4 有点寄，写一些需要牢记的事情： 呆呆题不要浪费时间！ 不要忘记你还会 DP！性质可以搞一搞！ 随机化！尽可能搞分！结论！贪心！ 感觉 hack 掉自己看起来很正确的想法的时候想一想是否是 hack 错了。 感觉好像会了的时候不要立刻开始写代码，重新理一下思路。写代码之前仔细地确认一下每一步转化和结论是否正确。 板子不要写错！！！ 数据的各类极限情况都要考虑到！包括负数和零，很大的正数！ 3.5 前往杭州！飞机上开始写题（呆呆题，而且不会）。 海亮学校很大，但是机房很谔谔，不如 24！还是在 24 卷的舒服。 3.12 周日放假，团建，鹅鸭杀！ 但是打完之后又很后悔，感觉自己浪费了几个小时，关键是自己也没有摆的资本。 3.17 今天晚上又有鹅鸭杀！当鸭子赢了两回，但是当鹈鹕只吃了一个人！ 然后总结了一些问题，剩下几天知道该干什么了吗？ 3.19 发现数位 DP 经常可以和自动机结合（两道模拟赛题）！ 3.25 太困难了，这是什么信心赛！ T1 GF，T2 wqs，T3 DDP。被创死。 突然发现自己一堆不会的，这几天需要学习数学 III 和 动态规划 II，要做一点数数和数据结构，可能还要学一点串串（但是又感觉不用）。 3.26 考场上简单题要快速切掉，条件转化时看问题是否变得更简单，经典数据结构应该快速想出来。 构造题想一想如何转化，是可以思考的。 最优化问题没思路时可以想一想 DP，而不是瞎贪心。 当完整想出一道题的做法时可以估计一下写这玩意的时间，然后平衡一下，有时间尽量先去看后面的题。 理论上来说今天上午机房团建要去看《铃芽之旅》，但是因为我下午有模拟赛所以就摆烂了。yurzhang 这么心里有点平衡了，毕竟省选前最好不要摆烂，而且机房里还有另一位机器人也没有去。 嗓子有点疼，保险起见还是请了个假，明天不去上学了。要是是平时我就头铁直接去了，但是省选前我可不想出事。 To the crazy ones, wish us good luck. 4.2 退役。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"Codeforces Div.2 VP 记录","slug":"default/old/cf-constest1","date":"2022-11-14T00:00:00.000Z","updated":"2022-11-14T00:00:00.000Z","comments":true,"path":"d71fa5a7/","link":"","permalink":"https://james1badcreeper.github.io/d71fa5a7/","excerpt":"我不会做普及题了。","text":"我不会做普及题了。 只有有意思的题目才会写题解（当然对笔者这种普及组选手来说，可能所有题都有意思）。 11 月记录 新征途。 Codeforces Round #830 (Div.2) Portal. A. Bestie Portal. (n,n−1)=1(n,n-1)=1(n,n−1)=1，所以最多只需要改 n,n−1n,n-1n,n−1 两次，讨论一下即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; int n, a[25], g = 0; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i], g = gcd(g, a[i]); if (g == 1) puts(\"0\"); else if (gcd(g, n) == 1) puts(\"1\"); else if (gcd(g, n - 1) == 1) puts(\"2\"); else puts(\"3\"); &#125; return 0; &#125; B. Ugu Portal. 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; int main(void) &#123; int T, n; cin >> T; while (T--) &#123; string s; cin >> n >> s; bool rev = 0; int ans = 0; for (int i = 1; i &lt; n; ++i) &#123; int a = s[i] - '0', b = s[i - 1] - '0'; if (a == rev &amp;&amp; b != rev) ++ans, rev = !rev; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; C. Sheikh (Hard Version) Portal.一个数列的价值是数列的总和减去所有元素的异或和。每个询问形如 Li,RiL_i,R_iLi​,Ri​，含义是希望找到一个区间 [l,r][l,r][l,r]，满足 Li≤l≤r≤RiL_i\\le l\\le r\\le R_iLi​≤l≤r≤Ri​，使得这个区间的价值最大。输出所有价值最大的区间中最短的一个（多解则任意）。n,q≤2×105n,q\\le 2\\times 10^5n,q≤2×105 由于异或是不进位的，所以当区间长度变长的时候，价值必然不会变小。 如果一个数是零，那么显然它对答案是没有贡献的，所以可以删掉左右两端的零，中间的也可以删掉。由于最多有 323232 位会导致异或与加法等价，所以去掉 000 之后可以暴力计算。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef long long i64; int n, q; int a[100005]; int pre[100005], nxt[100005]; i64 sum[100005], xxor[100005]; i64 calc(int l, int r) &#123; return (sum[r] - sum[l - 1]) - (xxor[r] ^ xxor[l - 1]); &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; cin >> n >> q; for (int i = 1; i &lt;= n; ++i) cin >> a[i], sum[i] = sum[i - 1] + a[i], xxor[i] = (xxor[i - 1] ^ a[i]); for (int i = 1; i &lt;= n; ++i) if (a[i]) pre[i] = i; else pre[i] = pre[i - 1]; nxt[n + 1] = n + 1; for (int i = n; i >= 1; --i) if (a[i]) nxt[i] = i; else nxt[i] = nxt[i + 1]; while (q--) &#123; int l, r; cin >> l >> r; l = min(r, nxt[l]); r = max(l, pre[r]); if (l == r) &#123; cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; l &lt;&lt; '\\n'; continue; &#125; int u = l, v = r, ans = r - l + 1; i64 res = calc(l, r); for (int i = l; i &lt;= r &amp;&amp; calc(i, r) == res; i = nxt[i + 1]) for (int j = r; j >= i &amp;&amp; calc(i, j) == res; j = pre[j - 1]) if (j - i + 1 &lt; ans) ans = j - i + 1, u = i, v = j; cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; '\\n'; &#125; &#125; return 0; &#125; D. Balance (Hard version) Portal.最初你有一个集合，该集合仅包括一个元素 000，而且它会一直存在。你需要处理 q(≤2×105)q(\\le 2\\times 10^5)q(≤2×105) 个下述类型的操作：+ x 向集合中添加一个整数 xxx 。数据保证集合中原来没有这个整数。- x 从集合中移除整数 xxx 。数据保证集合包含这个就要删除的整数。? k 找出当前是 kkk 的倍数且不被包含在集合中的最小非负整数 xxx。 考虑乱搞，用四个 map 分别记录：s，数是否在集合内；ans，用于类似离线直接跳到之前枚举的最大位置的 ansansans（即对于查询过的 kkk 所查询到的 ansansans）；del，有哪些是被查询过的，但是后来被无情删除的；vis，有哪些数可以被作为 kkk 的答案（查询的时候顺带统计）。 修改的时候要利用 vis 来更新 del。查询的时候一开始直接拿 000 搞，之后再查就从 ans[x]ans[x]ans[x] 开始暴力跳，并且在 visvisvis 中插入；最后再与被删除的当中（因为删除了，又可以取了）取个最小值。 时间复杂度的严格证明很困难，不打算研究了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;set> #include &lt;map> using namespace std; typedef long long i64; map &lt;i64, i64> s, ans; map &lt;i64, set&lt;i64>> del, vis; int main(void) &#123; int q; cin >> q; s[0] = 1; while (q--) &#123; char opt; i64 x; cin >> opt >> x; if (opt == '+') &#123; s[x] = true; for (auto i : vis[x]) del[i].erase(x); &#125; else if (opt == '-') &#123; s[x] = false; for (auto i : vis[x]) del[i].insert(x); &#125; else &#123; while (s[ans[x]]) &#123; vis[ans[x]].insert(x); ans[x] += x; &#125; i64 res = ans[x]; if (!del[x].empty()) res = min(res, *del[x].begin()); cout &lt;&lt; res &lt;&lt; '\\n'; &#125; &#125; return 0; &#125; E. Location Portal.初始给定序列 a,ba,ba,b，需要维护以下操作：给定 l,r,xl,r,xl,r,x，对于 ∀i∈[l,r]\\forall i\\in[l,r]∀i∈[l,r]，令 ai=xa_i=xai​=x。给定 l,rl,rl,r，求 min⁡i∈[l,r]lcm⁡(ai,bi)gcd⁡(ai,bi)\\min_{i\\in[l,r]}\\frac{\\operatorname{lcm}(a_i,b_i)}{\\gcd(a_i,b_i)}mini∈[l,r]​gcd(ai​,bi​)lcm(ai​,bi​)​。数据范围 1≤n,q,ai≤5×1041\\leq n,q,a_i\\leq 5\\times 10^41≤n,q,ai​≤5×104。 说点题外话，这道题对我来说很有实力，也让我更加期待 NOIP 结束后学习数据结构的生活了。 看到这么诡异的查询当然分块。 这玩意相当于是求 f(i)=ai×bigcd⁡(ai,bi)2f(i)=\\cfrac{a_i\\times b_i}{\\gcd(a_i,b_i)^2}f(i)=gcd(ai​,bi​)2ai​×bi​​，显然一开始这玩意的值可以预处理出来。 现在考虑如何修改，零散块当然暴力维护，但是整块怎么办？注意这里修改操作的特殊性，是区间赋值，而且数的值域也很小，因此可以预处理 vi,jv_{i,j}vi,j​ 代表 iii 块修改为 jjj 之后的答案。 但是这样预处理的复杂度就太高了，需要考虑优化。方法是开一个桶 ttt，t[x]t[x]t[x] 记录含有因子 xxx 的最小 bbb，然后枚举每个 aaa 的因数，如果 t[x]t[x]t[x] 存在 aaa 就可能是最大公约数，尝试更新。 基本上不卡常，只要块长不离谱就很容易过的。 查看代码 #include &lt;iostream> #include &lt;vector> #include &lt;cstring> #pragma GCC optimize(3, \"Ofast\") using namespace std; typedef unsigned int uint; const uint BLOCK_SIZE = 160; const uint INF = 0x9f9f9f9f; uint read(void) &#123; uint x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x; &#125; void print(uint x) &#123; if (x > 9) print(x / 10); putchar(x % 10 ^ 48); &#125; uint n, q; uint a[50005], b[50005]; uint L[334], R[334], minn[334]; uint setv[334], v[334][50005]; uint pos[50005]; vector&lt;uint> d[50005]; uint gcd(uint x, uint y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; inline uint F(uint x) &#123; uint g = gcd(a[x], b[x]); return a[x] * b[x] / (g * g); &#125; inline void pushdown(uint o) &#123; if (!setv[o]) return; for (uint i = L[o]; i &lt;= R[o]; ++i) a[i] = setv[o]; setv[o] = 0; &#125; inline void maintain(uint l, uint r, uint x) &#123; uint p = pos[l]; pushdown(p); for (uint i = l; i &lt;= r; ++i) a[i] = x; minn[p] = INF; for (uint i = L[p]; i &lt;= R[p]; ++i) minn[p] = min(minn[p], F(i)); &#125; void update(uint l, uint r, uint x) &#123; uint p = pos[l], q = pos[r]; if (p == q) &#123; maintain(l, r, x); return; &#125; for (uint i = p + 1; i &lt; q; ++i) setv[i] = x, minn[i] = v[i][x]; maintain(l, R[p], x); maintain(L[q], r, x); &#125; uint Query(uint l, uint r) &#123; uint p = pos[l]; pushdown(p); uint ans = INF; for (uint i = l; i &lt;= r; ++i) ans = min(ans, F(i)); return ans; &#125; uint query(uint l, uint r) &#123; uint p = pos[l], q = pos[r]; if (p == q) return Query(l, r); uint ans = INF; for (uint i = p + 1; i &lt; q; ++i) ans = min(ans, minn[i]); ans = min(ans, Query(l, R[p])); ans = min(ans, Query(L[q], r)); return ans; &#125; int main(void) &#123; n = read(), q = read(); for (uint i = 1; i &lt;= n; ++i) a[i] = read(); for (uint i = 1; i &lt;= n; ++i) b[i] = read(); uint t = n / BLOCK_SIZE; for (uint i = 1; i &lt;= t; ++i) L[i] = R[i - 1] + 1, R[i] = i * BLOCK_SIZE; if (R[t] &lt; n) &#123; ++t; L[t] = R[t - 1] + 1; R[t] = n; &#125; for (uint i = 1; i &lt;= t; ++i) &#123; minn[i] = INF; for (uint j = L[i]; j &lt;= R[i]; ++j) pos[j] = i, minn[i] = min(minn[i], F(j)); &#125; for (uint i = 1; i &lt;= 50000; ++i) // 预处理约数 for (uint j = 1; j * j &lt;= i; ++j) if (i % j == 0) &#123; d[i].emplace_back(j); if (j * j != i) d[i].emplace_back(i / j); &#125; static uint tmp[50005]; // tmp[x] 记录含有因子 x 的最小 b memset(v, 0x9f, sizeof(v)); for (uint i = 1; i &lt;= t; ++i) &#123; // 预处理修改后的答案 memset(tmp, 0x9f, sizeof(tmp)); for (uint j = L[i]; j &lt;= R[i]; ++j) for (uint a : d[b[j]]) tmp[a] = min(tmp[a], b[j]); for (uint j = 1; j &lt;= 50000; ++j) for (uint a : d[j]) // 枚举 a 是 j 的因子 if (tmp[a] != INF) v[i][j] = min(v[i][j], j * tmp[a] / (a * a)); // a 可能是最大公约数，尝试更新 &#125; while (q--) &#123; uint op = read(), l = read(), r = read(), x; if (op == 1) &#123; x = read(); update(l, r, x); &#125; else &#123; print(query(l, r)); putchar('\\n'); &#125; &#125; return 0; &#125; Codeforces Round #822 (Div.2) Portal. A. Select Three Sticks Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; int n; int a[305]; inline void solve(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); int ans = 2e9; for (int i = 2; i &lt; n; ++i) ans = min(ans, a[i + 1] - a[i - 1]); cout &lt;&lt; ans &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; B. Bright, Nice, Brilliant GNU Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; inline void solve(void) &#123; int n; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) if (j == 1 || j == i) cout &lt;&lt; \"1 \"; else cout &lt;&lt; \"0 \"; putchar('\\n'); &#125; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; C. Removing Smallest Multiples Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; char s[1000005]; inline void solve(void) &#123; int n; i64 ans = 0; scanf(\"%d%s\", &amp;n, s + 1); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i; j &lt;= n; j += i) if (s[j] != '1') &#123; if (s[j] == '0') ans += i; s[j] = '2'; &#125; else break; &#125; printf(\"%lld\\n\", ans); &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; D. Slime Escape Portal. 贪心的向左右走，只要是正的，就可以走，同时记录左右最大的和用以计算。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k; int a[200005]; i64 s[200005]; void solve(void) &#123; cin >> n >> k; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; if (a[k] &lt; 0) return puts(\"NO\"), void(); s[k] = 0; for (int i = k - 1; i >= 1; --i) s[i] = s[i + 1] + a[i]; for (int i = k + 1; i &lt;= n; ++i) s[i] = s[i - 1] + a[i]; int l = k - 1, r = k + 1; i64 sl = a[k], sr = a[k]; while (l > 0 &amp;&amp; r &lt;= n) &#123; int ll = l, rr = r; while (s[l] + sr >= 0 &amp;&amp; l > 0) sl = max(sl, a[k] + s[l]), l -= 1; while (s[r] + sl >= 0 &amp;&amp; r &lt;= n) sr = max(sr, a[k] + s[r]), r += 1; if (ll == l &amp;&amp; rr == r) return puts(\"NO\"), void(); &#125; puts(\"YES\"); &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; E. Rectangular Congruence Portal.给定一个质数 nnn（n≤350n \\leq 350n≤350） 和一个序列 b1,b2,...,bnb_1, b_2, ..., b_nb1​,b2​,...,bn​（对于 ∀i\\forall i∀i 有 0≤bi&lt;n0 \\leq b_i &lt; n0≤bi​&lt;n），你需要构造一个 n×nn \\times nn×n 的矩阵 aaa，满足：对于 ∀i,j≤n\\forall i, j \\leq n∀i,j≤n 有 0≤ai,j&lt;n0 \\leq a_{i, j} &lt; n0≤ai,j​&lt;n。对于 ∀1≤r1&lt;r2≤n,1≤c1&lt;c2≤n\\forall 1 \\leq r_1 &lt; r_2 \\leq n, 1 \\leq c_1 &lt; c_2 \\leq n∀1≤r1​&lt;r2​≤n,1≤c1​&lt;c2​≤n 有 ar1,c1+ar2,c2≢ar1,c2+ar2,c1(modn)a_{r1, c1} + a_{r2, c2} \\not\\equiv a_{r1, c2} + a_{r2, c1} \\pmod nar1,c1​+ar2,c2​≡ar1,c2​+ar2,c1​(modn)。对于 ∀1≤i≤n\\forall 1 \\le i \\le n∀1≤i≤n 有 ai,i=bia_{i,i}=b_iai,i​=bi​。 将条件二转化为 ar2,c2−ar2,c1≢ar1,c2−ar1,c1(modn)a_{r_2,c_2}-a_{r_2,c_1}\\not\\equiv a_{r_1,c_2}-a_{r_1,c_1}\\pmod nar2​,c2​​−ar2​,c1​​≡ar1​,c2​​−ar1​,c1​​(modn)，这就相当于构造每一行的差不一样即可，分别为 0∼n−10\\sim n-10∼n−1，然后根据 bbb 做相应调整即可。 因为 nnn 是质数，所以列出同余方程之后发现无解，这样构造是成立的。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, b; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;b); int diff = ((i - 1) * (i - 1) % n - b + n) % n; for (int j = 1; j &lt;= n; ++j) printf(\"%d \", ((i - 1) * (j - 1) % n - diff + n) % n); putchar('\\n'); &#125; return 0; &#125; F. Zeros and Ones Portal.SSS 是一个由以下方式生成的无限长 01 字符串：最初，令 SSS 为 “0”。随后进行以下操作无穷多次：将 SSS 与各位取反后的 SSS 连接。以前 4 次操作为例：次数SSS取反后的 SSS操作后得到的 SSS1010120110011030110100101101001401101001100101100110100110010110给定 T(1≤T≤100)T(1\\le T \\le 100)T(1≤T≤100) 组 222 个正整数 n,m(1≤n,m≤1018)n,m(1\\le n,m\\le 10^{18})n,m(1≤n,m≤1018)，求 S0S1⋯Sm−1S_0S_1 \\cdots S_{m-1}S0​S1​⋯Sm−1​ 和 SnSn+1⋯Sn+m−1S_{n}S_{n+1} \\cdots S_{n+m-1}Sn​Sn+1​⋯Sn+m−1​ 有几位不同。 也就是说我们要求解对于多少个 0≤i&lt;m0\\le i&lt;m0≤i&lt;m 有 Si≠Si+nS_i\\ne S_{i+n}Si​=Si+n​。可以发现 SiS_iSi​ 代表 iii 的二进制中 111 的个数的奇偶性。 记 dfs(n, m, flag) 代表 n,mn,mn,m 时，flagflagflag 为真代表相同，假为不同。 当 2∣i2\\mid i2∣i 时设 i=2ki=2ki=2k，那么 Si=Sk,Si+n=Sk+⌊n/2⌋⊕(n mod 2)S_i=S_k,S_{i+n}=S_{k+\\lfloor n/2\\rfloor}\\oplus (n\\bmod 2)Si​=Sk​,Si+n​=Sk+⌊n/2⌋​⊕(nmod2)。前者显然成立，后者分类讨论： 当 2∣n2\\mid n2∣n 时，有 Si+n=S(i+n)/2S_{i+n}=S_{(i+n)/2}Si+n​=S(i+n)/2​，二进制最后一位是 000，所以成立。 当 2∤n2\\nmid n2∤n 时，有 Si+n≠S⌊(i+n)/2⌋S_{i+n}\\ne S_{\\lfloor(i+n)/2\\rfloor}Si+n​=S⌊(i+n)/2⌋​，前者是奇数，最后一位 111 被搞掉了，所以也成立。 我们可以将求解 Si≠Si+nS_{i}\\ne S_{i+n}Si​=Si+n​ 转换为求解 SkS_{k}Sk​ 与 Sk+⌊n/2⌋S_{k+\\lfloor n/2\\rfloor}Sk+⌊n/2⌋​ 的关系。也就是 dfs(n, m, flag) 中 2∣i2\\mid i2∣i 的一部分，答案是 dfs(n &gt;&gt; 1, m + 1 &gt;&gt; 1, n &amp; 1)（最大到 ⌊n/2⌋\\lfloor n/2\\rfloor⌊n/2⌋，满足 2∣i2\\mid i2∣i 的一共有 ⌊(m+1)/2⌋\\lfloor(m+1)/2\\rfloor⌊(m+1)/2⌋ 个）。 当 2∤i2\\nmid i2∤i 时也可以通过相应的方式讨论出来。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;map> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; int bitcount(i64 x) &#123; int ans = 0; while (x) &#123; x -= lowbit(x); ++ans; &#125; return ans; &#125; map&lt;pair&lt;i64, i64>, i64> f; i64 calc(i64 n, i64 m, bool flag) &#123; if (m == 0) return 0; if (flag) return m - calc(n, m, 0); if (m == 1) return bitcount(n) % 2 != 0; if (f.count(&#123;n, m&#125;)) return f[&#123;n, m&#125;]; i64 ans = calc(n >> 1, m + 1 >> 1, n &amp; 1) + calc(n + 1 >> 1, m >> 1, n &amp; 1); return f[&#123;n, m&#125;] = ans; &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; i64 n, m; cin >> n >> m; cout &lt;&lt; calc(n, m, 0) &lt;&lt; \"\\n\"; &#125; return 0; &#125; Codeforces Round #833 (Div.2) Portal. A. The Ultimate Square Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n; cin >> n; cout &lt;&lt; (n + 1) / 2 &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; B. Diverse Substrings Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int a[15]; void solve(void) &#123; int n, ans = 0; static char s[100005]; cin >> n >> s; for (int i = 0; i &lt; n; ++i) &#123; memset(a, 0, sizeof(a)); int maxx = 0, flag = 0; for (int j = i; j &lt; n; ++j) &#123; int x = s[j] - '0'; if (a[x] == 0) ++flag; a[x] += 1; maxx = max(a[x], maxx); if (maxx &lt;= flag) ++ans; if (a[s[j] - '0'] > 10) break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; C. Zero-Sum Prefixes Portal.给定一个长为 nnn 的数列 aaa，你可以将其中的每个 000 分别改成任意整数。求出你最多能让多少个 kkk 满足 a1+⋯+ak=0a_1+\\dots+a_k=0a1​+⋯+ak​=0。 考虑 000 干了什么，可以变动后面一段的前缀和，这样用一个 STL map 记录一下哪一个前缀和最多，然后就把这个 000 变成这个的相反数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[200005]; i64 s[200005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; int ans = 0, maxt = 0; bool fs = true; map&lt;i64, int> se; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] == 0) &#123; if (fs) fs = false; else &#123; ans += maxt; maxt = 0; se.clear(); s[i] = 0; &#125; &#125; s[i] = s[i - 1] + a[i]; if (fs) ans += (s[i] == 0); else maxt = max(maxt, se[s[i]] += 1); &#125; if (!fs) ans += maxt; cout &lt;&lt; ans &lt;&lt; '\\n'; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; D. ConstructOR Portal.给定 a,b,d(&lt;230)a,b,d(&lt;2^{30})a,b,d(&lt;230)，要求构造一个 x(x&lt;260)x(x&lt;2^{60})x(x&lt;260) 使得 d∣(aor⁡x),d∣(bor⁡x)d\\mid (a\\operatorname{or} x),d\\mid(b\\operatorname{or} x)d∣(aorx),d∣(borx)。 当 lowbit(aor⁡b)&lt;lowbit(d)\\text{lowbit}(a\\operatorname{or}b)&lt;\\text{lowbit}(d)lowbit(aorb)&lt;lowbit(d)，显然无解。 否则可以考虑构造一个 xxx 使得 aor⁡x=bor⁡x=xa\\operatorname{or} x=b\\operatorname{or} x=xaorx=borx=x。为了使得 d∣xd\\mid xd∣x，xxx 需要由若干 ddd 构成。 枚举 aor⁡ba\\operatorname{or} baorb 二进制下的每一位，如果当前位是 111，而且已经构造出来的答案的当前位是 000，那么这一位就需要变成 111，同时满足加进去的是由若干 ddd 构成的，因此加上的内容必须是由 ddd 左移得到的。左移多少位呢？要想让第 iii 位恰好为 111，那么令 ddd 第一个 111 出现在第 kkk 位，就需要让它左移 i−ki-ki−k 位。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; inline int lowbit(int x) &#123; return x &amp; -x; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) &#123; i64 a, b, d; cin >> a >> b >> d; if (lowbit(a | b) &lt; lowbit(d)) cout &lt;&lt; \"-1\\n\"; else &#123; i64 x = 0, k = 0; while ((d >> k &amp; 1) ^ 1) ++k; for (int i = 0; i &lt; 30; ++i) if (((a | b) >> i &amp; 1) &amp;&amp; (x >> i &amp; 1) == 0) if (i >= k) x += (d &lt;&lt; i - k); cout &lt;&lt; x &lt;&lt; \"\\n\"; &#125; &#125; return 0; &#125; Codeforces Round #802 (Div.2) Portal. A. Optimal Path Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; i64 n, m; cin >> m >> n; cout &lt;&lt; n * (n - 1) / 2 + (n + n * m) * m / 2 &lt;&lt; \"\\n\"; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; B. Palindromic Numbers Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n; static char a[100005], b[100005], c[100005]; cin >> n >> b; if (b[0] == '9') &#123; for (int i = 0; i &lt;= n; ++i) a[i] = 1; for (int i = 0; i &lt; n; ++i) b[i] -= '0'; for (int i = n - 1; i >= 0; --i) if (a[i] &lt; b[i]) &#123; a[i] += 10; a[i - 1] -= 1; c[i] = a[i] - b[i]; &#125; else c[i] = a[i] - b[i]; for (int i = 0; i &lt; n; ++i) putchar(c[i] + '0'); return; &#125; for (int i = 0; i &lt; n; ++i) putchar('9' - b[i] + '0'); &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; solve(); puts(\"\"); &#125; return 0; &#125; C. Helping the Nature Portal.给定一个长度为 nnn 的序列 AAA，支持以下三种操作：将 A1,…,AiA_1,\\dots,A_iA1​,…,Ai​ 都减去一；将 Ai,…,AnA_i,\\dots,A_nAi​,…,An​ 都减去一；全局加上一。 将序列差分，那么前两种操作对应： Bi+1B_{i+1}Bi+1​ 加上一； BiB_{i}Bi​ 减去一。 那么除了第一个数，剩下的所有数我们都可以将其变成 000，这样序列中的所有数都相等，把第一个数作为“标准”进行维护即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[200005], b[200005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; b[i] = a[i] - a[i - 1]; &#125; i64 ans = 0, h = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; ans += abs(b[i]); if (b[i] &lt; 0) h += b[i]; &#125; cout &lt;&lt; ans + abs(h) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; D. River Locks Portal.有 nnn 个容器，第 iii 个容器容量为 viv_ivi​ 升，可以容纳 [0,vi][0,v_i][0,vi​] 升的水。满出去的水会将从容器 iii 转移到容器 i+1i+1i+1，如果 i+1i+1i+1 也满了会转移得更远。满出最后一个容器的水会倒到河中。现在要将所有容器填满。你可以选择一些容器注水，让这些容器每秒进入一升水。qqq 次询问，问最初所有容器都是空的，最少选择多少个容器注水使得 tit_iti​ 秒内能填满所有容器。1≤n,q≤2×1051\\leq n,q\\leq 2\\times 10^51≤n,q≤2×105，1≤vi,ti≤1091\\leq v_i,t_i\\leq 10^91≤vi​,ti​≤109。 容器一定是要从 111 往 nnn 开的，这样如果能装满，答案就是 ⌈∑vn⌉\\left\\lceil\\frac{\\sum v}{n}\\right\\rceil⌈n∑v​⌉，不能装满当且仅当无法将前 iii 个容器在 ttt 的时间内装满。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, q; i64 a[200005], res = 0; int main(void) &#123; ios::sync_with_stdio(false); cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; a[i] += a[i - 1]; res = max(res, a[i] / i + (a[i] % i == 0 ? 0 : 1)); &#125; cin >> q; while (q--) &#123; int t; cin >> t; cout &lt;&lt; (t &lt; res ? -1 : a[n] / t + (a[n] % t == 0 ? 0 : 1)) &lt;&lt; '\\n'; &#125; return 0; &#125; E. Serega the Pirate Portal.一个 n×mn \\times mn×m 的表格中填入了 1,2,...,n×m1,2,...,n \\times m1,2,...,n×m 的所有数恰一次。称一种填法可解，当可以找出一条路径，它第一次到达每个格子的顺序与格内所填的数同序。换言之，这条路径应该先经过 xxx，再经过 x+1x+1x+1。路径的起点，终点，长度任意，可以重复经过同一个格子。问对给定的填法，至少需要交换几对格子，才能使填法可解。若最小值为 000，输出 000；若最小值为 111，输出 111 和交换方法数；若最小值大于 111，输出 222。n×m≤400000n \\times m \\le 400000n×m≤400000。 啊这题不难，就是很恶心（当然仅对于笔者）！ 首先看看什么时候答案是 000：一个点能够走到，要么它是 111，要么在一个四联通块中有点可以走到它，也就是上下左右有一个数比它小。 当有一些点不满足上述条件时，就必须要执行交换操作了。交换什么？只有交换这个四联通块中的点和局外的一个点才可能让这个点变得合法。但是这道题并不需要我们输出操作数，只有在操作数为 111 的时候才要求我们输出方案数，因此可以暴力枚举：选择其中任意一个不能被走到的点，枚举与它交换的点，交换后看能影响到的 101010 个点（相当于改变了两个四联通块，共 101010 个点）和剩下的原本就不能到的点是否满足条件，满足条件就是一种方案。 如果一开始就不能到达的节点超过了 101010 个，那么一次交换操作就肯定不能完成了（一次交换只能影响至多 101010 个点）。 时间复杂度 O(nm)O(nm)O(nm)，因为需要枚举方向带一个约百倍的常数。但实际上很快就会因为不符合条件而跳出循环，根本跑不满，可以轻松通过。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;set> using namespace std; const int dx[] = &#123;0, 1, -1, 0, 0&#125;, dy[] = &#123;0, 0, 0, 1, -1&#125;; int n, m, X[400005], Y[400005]; vector&lt;vector&lt;int> > a; vector&lt;int> v; bool check(int x, int y) &#123; if (a[x][y] == 1) return true; for (int i = 1; i &lt;= 4; ++i) &#123; int tx = x + dx[i], ty = y + dy[i]; if (tx >= 1 &amp;&amp; tx &lt;= n &amp;&amp; ty >= 1 &amp;&amp; ty &lt;= m &amp;&amp; a[tx][ty] &lt; a[x][y]) return true; &#125; return false; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); a.resize(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i].resize(m + 1); for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;a[i][j]); X[a[i][j]] = i, Y[a[i][j]] = j; &#125; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (!check(i, j)) v.push_back(a[i][j]); if (v.empty()) return puts(\"0\"), 0; if (v.size() >= 10) return puts(\"2\"), 0; set&lt;pair&lt;int, int>> s; for (int i = 0; i &lt; 5; ++i) &#123; int x = X[v[0]] + dx[i], y = Y[v[0]] + dy[i]; if (x &lt; 1 || x > n || y &lt; 1 || y > m) continue; for (int xx = 1; xx &lt;= n; ++xx) for (int yy = 1; yy &lt;= m; ++yy) &#123; swap(a[x][y], a[xx][yy]); bool ok = true; for (int j = 0; j &lt; v.size() &amp;&amp; ok; ++j) if (!check(X[v[j]], Y[v[j]])) ok = false; for (int j = 0; j &lt; 5 &amp;&amp; ok; ++j) &#123; int tx = x + dx[j], ty = y + dy[j]; if (tx >= 1 &amp;&amp; tx &lt;= n &amp;&amp; ty >= 1 &amp;&amp; ty &lt;= m &amp;&amp; !check(tx, ty)) ok = false; &#125; for (int j = 0; j &lt; 5 &amp;&amp; ok; ++j) &#123; int tx = xx + dx[j], ty = yy + dy[j]; if (tx >= 1 &amp;&amp; tx &lt;= n &amp;&amp; ty >= 1 &amp;&amp; ty &lt;= m &amp;&amp; !check(tx, ty)) ok = false; &#125; if (ok) &#123; int u = a[x][y], v = a[xx][yy]; if (u > v) swap(u, v); s.insert(make_pair(u, v)); &#125; swap(a[x][y], a[xx][yy]); &#125; &#125; if (s.empty()) puts(\"2\"); else printf(\"1 %d\\n\", s.size()); return 0; &#125; Codeforces Round #813 (Div. 2) Portal. A. Wonderful Permutation Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k; int p[105]; bool a[105]; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", p + i); memset(a, 0, sizeof(a)); for (int i = 1; i &lt;= k; ++i) a[p[i]] = true; int ans = 0; for (int i = 1; i &lt;= k; ++i) if (!a[i]) ++ans; cout &lt;&lt; ans &lt;&lt; endl; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; B. Woeful Permutation Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[100005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) a[i] = i; for (int i = n; i >= 1; i -= 2) if (i > 1) swap(a[i], a[i - 1]); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; C. Sort Zero Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[100005]; bool b[100005]; void solve(void) &#123; scanf(\"%d\", &amp;n); memset(b, 0, sizeof(b)); set&lt;int> s; int maxx = 0, ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (b[a[i]]) a[i] = 0; if (a[i] &lt; maxx) &#123; ans += s.size(); for (auto x : s) b[x] = true; s.clear(); maxx = 0; &#125; if (b[a[i]]) a[i] = 0; if (a[i] != 0) s.insert(a[i]); maxx = max(maxx, a[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\\n'; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; D. Empty Graph Portal.给定一个长为 nnn 的序列 aaa。定义一 nnn 个点的无向完全图，点 lll 和点 rrr 之间的距离为 min⁡i∈[l,r]{ai}\\min\\limits_{i\\in[l,r]}\\{a_i\\}i∈[l,r]min​{ai​}。你可以进行 kkk 次操作，每次操作可以选定 ∀i∈[1,n]\\forall i \\in [1,n]∀i∈[1,n] 并将 aia_iai​ 赋值为一个 [1,109][1,10^9][1,109] 的整数。请最大化这个图的直径。设 d(u,v)d(u,v)d(u,v) 表示 uuu 到 vvv 的最短路径长度，图的直径定义为 max⁡1≤u&lt;v≤nd(u,v)\\max\\limits_{1\\leq u &lt; v \\leq n} d(u,v)1≤u&lt;v≤nmax​d(u,v)。 二分答案。直径显然只能是 d(ai,ai+1)d(a_i,a_{i+1})d(ai​,ai+1​)，距离要么是直接走，要么是二倍全局最小，根据此 check 即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; const int INF = 1e9; int n, k; int a[100005], b[100005]; bool P(int x) // 最小值最大，现在最小值为 x &#123; int res = 0; for (int i = 1; i &lt;= n; ++i) b[i] = a[i]; for (int i = 1; i &lt;= n; ++i) if (2 * b[i] &lt; x) ++res, b[i] = INF; int t = 2; for (int i = 1; i &lt; n; ++i) t = min(t, (b[i] &lt; x) + (b[i + 1] &lt; x)); return res + t &lt;= k; &#125; void solve(void) &#123; cin >> n >> k; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; int L = 0, R = INF + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) L = mid; else R = mid; &#125; cout &lt;&lt; L &lt;&lt; '\\n'; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; 12 月记录 sto KH. Codeforces Round #825 (Div. 2) Portal. 打的老垃圾了。 A. Make A Equal to B Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[105], b[105]; void solve(void) &#123; cin >> n; int acnt = 0, bcnt = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) cin >> a[i], acnt += a[i]; for (int i = 1; i &lt;= n; ++i) cin >> b[i], bcnt += b[i]; for (int i = 1; i &lt;= n; ++i) if (a[i] != b[i]) ++cnt; int t = abs(acnt - bcnt); if (cnt > t) ++t; cout &lt;&lt; t &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Playing with GCD Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[100005]; int b[100005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; b[1] = a[1]; b[n + 1] = a[n]; for (int i = 2; i &lt;= n; ++i) b[i] = a[i - 1] / __gcd(a[i - 1], a[i]) * a[i]; for (int i = 1; i &lt;= n; ++i) if (__gcd(b[i], b[i + 1]) != a[i]) &#123; cout &lt;&lt; \"NO\\n\"; return; &#125; cout &lt;&lt; \"YES\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; C2. Good Subarrays (Hard Version) Portal.我们定义一个序列 bbb 是好的当且仅当所有的 bi≥ib_i \\ge ibi​≥i。现在给你 qqq 次询问，每次询问有两个数 ppp 和 xxx，问把 apa_pap​ 赋值成 xxx 后 aaa 数组好的子段的个数，询问之间相互独立。1≤n≤2×1051\\le n \\le 2 \\times 10^51≤n≤2×105，1≤q≤2×1051 \\le q \\le 2 \\times 10^51≤q≤2×105。1≤ai≤n1\\le a_i \\le n1≤ai​≤n，1≤pj,xj≤n1 \\le p_j,x_j \\le n1≤pj​,xj​≤n。 查看代码 // D. Equal Binary Subsequences Portal.给你一个长为 2n2n2n 的01串 sss ，你需要将其分成两个相等的子序列。在此之前你需要执行以下操作一次：选一个 sss 的子序列（可能为空），然后将其向右循环移位一位。你能在执行以上操作一次后把 sss 分成两个相等的子序列吗？要求给出方案。1≤n≤1051\\le n\\le 10^51≤n≤105 。 元素出现次数必须是偶数，然后呢？我们将两个数分为一组，如果一样那肯定是一个子序列一个，否则就按照顺序排列成一个 0101...01 的子序列，一个 1010...10 的子序列，然后翻转其中一个即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int p[200005]; bool d[200005]; char s[200005]; void solve(void) &#123; cin >> n >> s + 1; int res = 0; for (int i = 1; i &lt;= n * 2; ++i) &#123; s[i] -= '0'; if (s[i] == 0) ++res; &#125; if (res &amp; 1) return cout &lt;&lt; \"-1\\n\", void(); memset(d, 1, sizeof(d)); int ans = n, t = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x = i * 2 - 1, y = i * 2; if (s[x] == s[y]) &#123; p[i] = x; --ans; d[i] = 0; &#125; else &#123; t ^= 1; if (s[x] == t) p[i] = x; else p[i] = y; &#125; &#125; cout &lt;&lt; ans &lt;&lt; ' '; for (int i = 1; i &lt;= n; ++i) if (d[i]) &#123; int x = i * 2 - 1, y = i * 2; int t = (p[i] == x ? y : x); cout &lt;&lt; t &lt;&lt; ' '; &#125; cout &lt;&lt; '\\n'; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; p[i] &lt;&lt; ' '; cout &lt;&lt; '\\n'; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; E. Swap and Take Portal.给定一个长为 n(1≤n≤500)n(1\\le n \\le 500)n(1≤n≤500) 的正整数序列 aaa。初始你的分数为 000，需要进行 nnn 轮操作。在第 iii 轮，你可以选择交换两个相邻的数并将其中一个变为 000，也可以啥都不干。无论是否交换，第 iii 轮结束后你的分数会多 aia_iai​。求你最大能得到的分数。 先考虑一下交换的意义。贡献的指针是从左跑到右，且速度为 111，而我们的交换也只能一次交换相邻的一对，肯定不能跑过这个指针。也就是说，如果把贡献的数字在原序列中的下标写出来记作序列 ppp，那么一定有 p1≤p2≤⋯≤pnp_1\\le p_2\\le\\cdots\\le p_np1​≤p2​≤⋯≤pn​。若枚举这一轮要获得的分数，那么这个交换次数 kkk 就可以用来简单地判断当前这个分数是否可以拿到。 设 fi,j,kf_{i,j,k}fi,j,k​ 代表当前为第 iii 轮，要获取的贡献是 aja_jaj​，这一轮之后有 kkk 次操作没有使用能够获得的最大价值，初始时有 f1,1,1=a1,f1,2,0=a2f_{1,1,1}=a_1,f_{1,2,0}=a_2f1,1,1​=a1​,f1,2,0​=a2​。这样我们的交换有两种选择：一种是将 iii 前面的交换到 iii 来获取其价值，二是在 iii 后选择两个数进行交换，为第 iii 轮以后做“准备“。因此有转移： 将上一轮的 jjj 转过来，fi,j,k=fi−1,j,k+ajf_{i,j,k}=f_{i-1,j,k}+a_jfi,j,k​=fi−1,j,k​+aj​； 将 aja_jaj​ 从 jjj 换到 iii，需要消耗 j−ij-ij−i 次操作，那么 fi,j,k=fi−1,t,k−1+j−i(j≥i,t&lt;j)f_{i,j,k}=f_{i-1,t,k-1+j-i}(j\\ge i,t&lt;j)fi,j,k​=fi−1,t,k−1+j−i​(j≥i,t&lt;j)，t&lt;jt&lt;jt&lt;j 的原因是贡献下标单调不降，相等是上一种转移；j≥ij\\ge ij≥i 的原因是我们之前说的“速度”。 现在的问题就成了如何快速找到这个最大的 f[i-1][t][k-1+j-i]。我们单独记录一个数组 ggg，用 gi,j,kg_{i,j,k}gi,j,k​ 代表 max⁡{fi,t,k∣1≤t&lt;j}\\max\\{f_{i,t,k}\\mid 1\\le t &lt; j\\}max{fi,t,k​∣1≤t&lt;j} 即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, a[505], INF; int f[2][505][505]; // 进行 i 轮，第 i 轮获得的分数是 a[j]，k 次没用 int g[2][505][505]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0xbf, sizeof(f)); INF = -f[0][0][0]; memset(g, 0xbf, sizeof(g)); f[1][1][1] = a[1]; f[1][2][0] = a[2]; for (int i = 2; i &lt;= n; ++i) g[1][i][1] = a[1]; for (int i = 3; i &lt;= n; ++i) g[1][i][0] = a[2]; for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int k = 0; k &lt;= n; ++k) &#123; int &amp;dp = f[i &amp; 1][j][k]; dp = -INF; if (f[(i - 1) &amp; 1][j][k] != -INF) dp = f[(i - 1) &amp; 1][j][k] + a[j]; if (j >= i &amp;&amp; k - 1 + j - i >= 0 &amp;&amp; k - 1 + j - i &lt;= n) &#123; if (g[(i - 1) &amp; 1][j][k - 1 + j - i] != -INF) dp = max(dp, g[(i - 1) &amp; 1][j][k - 1 + j - i] + a[j]); &#125; g[i &amp; 1][j + 1][k] = max(g[i &amp; 1][j][k], dp); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= n; ++j) ans = max(ans, f[n &amp; 1][i][j]); printf(\"%d\\n\", ans); return 0; &#125; Educational Codeforces Round 67 (Rated for Div. 2) Portal. 打的越来越垃圾，没救了。 A. Stickers and Toys Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n, s, t; cin >> n >> s >> t; cout &lt;&lt; max(s, t) - (s + t - n) + 1 &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Letters Shop Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int sum[26][200005]; string s, t; void solve(void) &#123; cin >> n >> s; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; 26; ++j) sum[j][i] = (i == 0 ? 0 : sum[j][i - 1]); sum[s[i] - 'a'][i]++; &#125; cin >> m; static int c[26]; while (m--) &#123; memset(c, 0, sizeof(c)); int ans = 0; cin >> t; for (int i = 0; i &lt; t.length(); ++i) c[t[i] - 'a']++; for (int op = 0; op &lt; 26; ++op) &#123; int res = lower_bound(sum[op], sum[op] + n, c[op]) - sum[op]; ans = max(ans, res); &#125; cout &lt;&lt; ans + 1 &lt;&lt; \"\\n\"; &#125; &#125; int main(void) &#123; ios::sync_with_stdio(false); solve(); return 0; &#125; C. Vasya And Array Portal.给定 m(1≤m≤1000)m(1\\le m\\le 1000)m(1≤m≤1000) 条限制信息，形如 op l r，代表 [l,r][l,r][l,r] 是否不降排序。问是否能构造出合法的长度为 nnn 的序列，并给出方案。 我们先看一看排好序意味着什么。我们维护一个数组 ccc，c[i]c[i]c[i] 为真代表需要满足 ai≥ai−1a_i\\ge a_{i-1}ai​≥ai−1​（实际上相等就可以了）。然后我们看没有排好序的，如果能够让它没排好的区间 (l,r](l,r](l,r] 都需要排好序，那么就完蛋了。输出的时候不需要排序的直接令输出的数减一即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, c[1005], s[1005]; int l[1005], r[1005], tot = 0; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1; i &lt;= m; ++i) &#123; int t, x, y; cin >> t >> x >> y; if (t) ++c[x + 1], --c[y + 1]; else l[++tot] = x, r[tot] = y; &#125; for (int i = 1; i &lt;= n; ++i) c[i] += c[i - 1]; for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + (c[i] != 0); for (int i = 1; i &lt;= tot; ++i) if (s[r[i]] - s[l[i]] == r[i] - l[i]) return cout &lt;&lt; \"NO\\n\", 0; cout &lt;&lt; \"YES\\n\"; for (int i = 1, p = n + 2; i &lt;= n; ++i) &#123; if (!c[i]) --p; cout &lt;&lt; p &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n\"; return 0; &#125; D. Subarray Sorting Portal.给定长度为 nnn 的数组 aaa 和 bbb。你每次可以选择一段区间 [l,r][l,r][l,r]，令 al∼ara_l\\sim a_ral​∼ar​ 的元素从小到大排序。你可以进行任意次操作。问能否使 aaa 与 bbb 完全相等。 强大的题！ 首先它们的数的集合必须相等，否则肯定无解。 我们依次扫描 bbb，尝试找到一个 aaa 与它相等。有最大可能出解的方式是找第一个可以匹配的 aaa 与它匹配（否则要排序的内容更多，可能造成它不是最小值）。匹配成功的条件是令它的位置为 ppp，它必须是 [1,p][1,p][1,p] 的最小值（将 [i,p][i,p][i,p] 排序是操作），这样排序之后序列剩下元素的相对位置不会改变，使用线段树维护即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;queue> using namespace std; const int INF = 1e9; int n; int a[300005], b[300005]; int cnt[300005], pos[300005]; queue&lt;int> Q[300005]; int T[1200005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = min(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o] = INF, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = min(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = INF; if (x &lt;= mid) res = min(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = min(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); fill(cnt + 1, cnt + n + 1, 0); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), ++cnt[a[i]]; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i), --cnt[b[ i]]; bool flag = true; for (int i = 1; i &lt;= n; ++i) if (cnt[i]) &#123; puts(\"NO\"); flag = false; break; &#125; if (!flag) continue; for (int i = 1; i &lt;= n; ++i) Q[a[i]].push(i); for (int i = 1; i &lt;= n; ++i) pos[i] = Q[b[i]].front(), Q[b[i]].pop(); build(1, 1, n); for (int i = 1; i &lt;= n; ++i) &#123; if (query(1, 1, n, 1, pos[i]) != b[i]) &#123; flag = false; break; &#125; update(1, 1, n, pos[i]); &#125; puts(flag ? \"YES\" : \"NO\"); &#125; return 0; &#125; E. Tree Painting Portal. 板子！发现当第一个点选定之后，剩下的就无所谓了！那么使用换根 DP！多的价值是父亲所对应的子树，少的价值是当前子树！ 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; int n, siz[200005]; i64 f[200005], g[200005]; vector&lt;int> G[200005]; void dp(int x, int fa) &#123; siz[x] = 1; for (int y : G[x]) if (y != fa) &#123; dp(y, x); siz[x] += siz[y]; f[x] += f[y]; &#125; f[x] += siz[x]; &#125; void dfs(int x, int fa) &#123; if (x != 1) g[x] = g[fa] + n - siz[x] * 2; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dp(1, 0); g[1] = f[1]; dfs(1, 0); i64 ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, g[i]); printf(\"%lld\\n\", ans); return 0; &#125; Educational Codeforces Round 126 (Rated for Div. 2) Portal. 呜呜呜。 A. Array Balancing Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[30], b[30]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1; i &lt;= n; ++i) cin >> b[i]; i64 ans = 0; for (int i = 2; i &lt;= n; ++i) &#123; i64 x = abs(a[i] - a[i - 1]) + abs(b[i] - b[i - 1]); i64 y = abs(a[i] - b[i - 1]) + abs(b[i] - a[i - 1]); ans += min(x, y); &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Getting Zero Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int INF = 1e9; int calc(int x) &#123; if (x % 32768 == 0) return 0; if (x % 2) return INF; int res = 15, ans = 0; while (x % 2 == 0) &#123; x /= 2; --res; &#125; return ans + res; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) &#123; int a; cin >> a; int ans = 1e9; for (int i = 0; i &lt; 24; ++i) ans = min(ans, calc(a + i) + i); cout &lt;&lt; ans &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n\"; return 0; &#125; C. Water the Trees Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int h[300005]; i64 calc(int x) &#123; i64 a = 0, b = 0; // 1day, 2day for (int i = 1; i &lt;= n; ++i) a += (x - h[i]) % 2, b += (x - h[i]) / 2; if (a == b) return a * 2; if (a > b) return a * 2 - 1; // a &lt; b i64 t = (b - a) * 2; i64 ans = a * 2 + t / 3 * 2; return ans + t % 3; &#125; void solve(void) &#123; cin >> n; int maxn = 0; for (int i = 1; i &lt;= n; ++i) cin >> h[i], maxn = max(maxn, h[i]); cout &lt;&lt; min(calc(maxn), calc(maxn + 1)) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; D. Progressions Covering Portal.你有两个长度为 nnn 的数组 aaa，bbb。aaa 数组初始为 000。你每次可以执行一个操作，选定一段长度为 kkk 的区间（设区间左端点为 lll，则有 1≤l≤l+k−1≤n1\\leq l\\leq l+k−1 \\leq n1≤l≤l+k−1≤n ），把第一个元素加 111，第二个元素加 222，以此类推。给定 nnn，kkk 与 bbb，求令 ∀i∈[1,n]\\forall i \\in [1, n]∀i∈[1,n]，满足 ai≥bia_i \\ge b_iai​≥bi​ 的最小操作数。 好题！我们从后往前扫描数组，这样就可以发现贪心加就可以了，因为加的是最大的还不会浪费。那么记录总操作数 opopop 和当前加的和 sss。对于当前的数，操作数是 ⌈b[i]−sk⌉\\left\\lceil \\cfrac{b[i]-s}{k}\\right\\rceil⌈kb[i]−s​⌉（实际这个 kkk 需要根据 iii 调整），往前扫一个，当前的和就减少了操作数，操作数会减少 i+k−1i+k-1i+k−1 时增加的操作数。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, k; i64 a[300005], b[300005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", b + i); i64 ans = 0, s = 0, op = 0; for (int i = n; i >= 1; --i) &#123; if (b[i] > s) &#123; int t = (i >= k ? k : i); a[i] = (b[i] - s + t - 1) / t; ans += a[i]; op += a[i]; s += a[i] * t; &#125; s -= op; if (i + k - 1 &lt;= n) op -= a[i + k - 1]; &#125; printf(\"%lld\\n\", ans); return 0; &#125; Codeforces Round #746 (Div. 2) Portal. 好棒！！！ A. Gamer Hemose Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, H; int a[1005]; void solve(void) &#123; cin >> n >> H; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; sort(a + 1, a + n + 1); if (H &lt;= a[n]) return cout &lt;&lt; \"1\\n\", void(); int t = H / (a[n] + a[n - 1]) * 2; H = H % (a[n] + a[n - 1]); if (H == 0) cout &lt;&lt; t &lt;&lt; \"\\n\"; else if (a[n] >= H) cout &lt;&lt; t + 1 &lt;&lt; \"\\n\"; else cout &lt;&lt; t + 2 &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Hemose Shopping Portal. 只要能换到 111 和 nnn 就可以随便换了。所以当 2x&gt;n2x&gt;n2x&gt;n 时，[n−x+1,x][n-x+1,x][n−x+1,x] 会无法进行交换操作，因此它们排好序即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, x; int a[100005], b[100005]; void solve(void) &#123; cin >> n >> x; for (int i = 1; i &lt;= n; ++i) cin >> a[i], b[i] = a[i]; sort(b + 1, b + n + 1); for (int i = n - x + 1; i &lt;= x; ++i) if (b[i] != a[i]) return puts(\"NO\"), void(); puts(\"YES\"); &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; C. Bakry and Partitioning Portal. 显然只有断一条边或者两条边有用。一条边是整棵树异或和为 000；两条边要找出三部分的异或和相等，相当于找两棵子树异或和相等（计入答案的子树要断掉再继续计算），dfs 检查一下即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, k, xc, flag; int a[100005], s[100005]; vector&lt;int> G[100005]; void dfs(int x, int fa) &#123; s[x] = a[x]; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); if (s[y] == xc) ++flag; else s[x] ^= s[y]; &#125; &#125; void solve(void) &#123; cin >> n >> k; xc = flag = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; xc ^= a[i]; G[i].clear(); &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].push_back(v); G[v].push_back(u); &#125; if (xc == 0) return cout &lt;&lt; \"YES\\n\", void(); if (k == 2) return cout &lt;&lt; \"NO\\n\", void(); //cout &lt;&lt; xc &lt;&lt; endl; dfs(1, 0); cout &lt;&lt; (flag >= 2 ? \"YES\" : \"NO\") &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; D. Hemose in ICPC ? Portal.给定一棵树，但是不知道边权。定义距离 d(u,v)d(u,v)d(u,v) 为路径上的边权的 gcd⁡\\gcdgcd。你可以询问交互库一个点集，交互库会回答这些点两两点对的距离的最大值。你最多可以询问交互库 121212 次，要找出 d(u,v)d(u,v)d(u,v) 最大的 (u,v)(u,v)(u,v)。可以输出任意一组解，2≤n≤1032\\le n\\le 10^32≤n≤103。 初做交互题！非常开心！ 可以发现距离定义 gcd⁡\\gcdgcd，那么距离就相当于找出最大边权！ 首先询问一次所有点来找出最大的边权！对树进行一次 dfs，求出遍历的顺序！这样每两个树上相邻的点都可以在序列中找到！于是就可以对序列二分！这样就可以找到最大值！ 为什么我写这题解的时候这么喜欢感叹号！ 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, maxx, a[2005], tot = 0; vector&lt;int> G[1005]; void dfs(int x, int fa) &#123; a[++tot] = x; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); a[++tot] = x; &#125; &#125; int p[1005]; int check(int L, int R) &#123; memset(p, 0, sizeof(p)); int cnt = 0; for (int i = max(0, L); i &lt;= R; ++i) p[a[i]] = true; for (int i = 1; i &lt;= n; ++i) if (p[i]) ++cnt; printf(\"? %d \", cnt); for (int i = 1; i &lt;= n; ++i) if (p[i]) printf(\"%d \", i); cout &lt;&lt; endl; int t; scanf(\"%d\", &amp;t); return t; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v), G[v].emplace_back(u); &#125; printf(\"? %d \", n); for(int i = 1; i &lt;= n; ++i) printf(\"%d \", i); cout &lt;&lt; endl; scanf(\"%d\", &amp;maxx); dfs(1, 0); int L = 1, R = tot; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(L, mid) != maxx) L = mid; else R = mid; &#125; int x = a[L], y = a[R]; printf(\"! %d %d\\n\", a[L], a[R]); return 0; &#125; Codeforces Round #836 (Div. 2) Portal. 这应该是近期打的最后一场了，接下来会把前面的补掉。 A. SSeeeeiinngg DDoouubbllee Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; char s[200005]; void solve(void) &#123; cin >> s; n = strlen(s); cout &lt;&lt; s; reverse(s, s + n); cout &lt;&lt; s &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. XOR = Average Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n; cin >> n; if (n % 2) &#123; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; \"1 \"; cout &lt;&lt; \"\\n\"; return; &#125; for (int i = 1; i &lt;= n - 2; ++i) cout &lt;&lt; n + 1 &lt;&lt; ' '; cout &lt;&lt; \"1 \" &lt;&lt; n + 1 &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; Codeforces Round #838 (Div. 2) Portal. 今年最后一场！ A. Divide and Conquer Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int d = 1e9, s = 0, n, x; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> x; s += x; bool flag = (x &amp; 1); int ret = 0; while (1) &#123; x >>= 1; ++ret; if ((x &amp; 1) != flag) &#123; d = min(d, ret); break; &#125; &#125; &#125; if (s % 2 == 0) cout &lt;&lt; \"0\\n\"; else cout &lt;&lt; d &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; B. Make Array Good Portal. 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; void solve(void) &#123; int n, x; cin >> n; cout &lt;&lt; n &lt;&lt; \"\\n\"; for (int i = 1; i &lt;= n; ++i) &#123; cin >> x; int t = ceil(log2(x)); cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; int(pow(2, t) - x) &lt;&lt; '\\n'; &#125; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"比赛记录","slug":"算法竞赛/比赛记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Div.2","slug":"Div-2","permalink":"https://james1badcreeper.github.io/tags/Div-2/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"},{"name":"比赛","slug":"比赛","permalink":"https://james1badcreeper.github.io/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"并查集","slug":"notes/DS/UnionFind","date":"2022-11-13T00:00:00.000Z","updated":"2022-11-13T00:00:00.000Z","comments":true,"path":"c517589e/","link":"","permalink":"https://james1badcreeper.github.io/c517589e/","excerpt":"并查集（UnionFind-Set 或 Disjoint-Set）是一种可以动态维护若干个不重叠的集合的数据结构，支持合并和查询两个操作。本文将引导你学习并查集，并查集的路径压缩和按秩合并优化，以及一种特殊的并查集——带权并查集，和用并查集解决图连通性问题。","text":"并查集（UnionFind-Set 或 Disjoint-Set）是一种可以动态维护若干个不重叠的集合的数据结构，支持合并和查询两个操作。本文将引导你学习并查集，并查集的路径压缩和按秩合并优化，以及一种特殊的并查集——带权并查集，和用并查集解决图连通性问题。 并查集 并查集维护的是 nnn 个点的集合。正常的并查集有两种操作： 合并（Merge），将两个点所在的集合合并。 查询（Find），查询一个点属于哪个集合。 模板。 我们首先需要定义集合的表示方法。我们为每一个点分配一个数值，代表它所属的集合的编号。但这样做不行，在合并时会修改大量点的编号。正确的方法是这样的：使用森林结构，每棵树代表一个集合，树根是集合代表的元素。于是我们用 fa[x] 记录 xxx 的父亲节点。 如果父亲节点是自己则代表它是这个集合的根节点，初始化时赋值 fa[x] = x，现在我们来看操作如何实现，比如这样一个并查集： 一个并查集 现在我们要查询 777 所在的集合。它的父亲是 666，不是根节点，再找到 222，是根节点，返回 222，代码如下： // 查询 x 所在的集合 int find(int x) &#123; if (fa[x] == x) return x; // 是根节点，直接返回 return find(fa[x]); // 不是根节点，查询父亲 &#125; 现在来看合并如何实现。比如我们要把 999 所在的集合合并到 333 所在的集合，我们直接把 999 的根节点设置成 333 的集合编号即可，像这样： 合并之后 代码如下： inline void uni(int x, int y) // 将 x 合并到 y &#123; fa[find(x)] = find(y); &#125; 以下代码可以通过刚才的模板： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; class UnionFind_Set &#123; private: int fa[10005]; public: inline void init(int n) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i; &#125; int find(int x) &#123; if (fa[x] == x) return x; return find(fa[x]); &#125; inline void uni(int x, int y) &#123; fa[find(x)] = find(y); &#125; inline bool ask(int x, int y) &#123; if (find(x) == find(y)) return 1; else return 0; &#125; &#125;U; int main(void) &#123; int n = read(), m = read(), p = read(); U.init(n); while (m--) U.uni(read(), read()); while (p--) puts(U.ask(read(), read()) ? \"Yes\" : \"No\"); return 0; &#125; 并查集的优化 实际上上述做法是很慢的，比如还是这张图： 如果我要查 13，那么它就会递归三次。万一有 10510^5105 个数组成的链，怎么办？ 看似很棘手的问题，实际上能通过很简单的方法解决。模板。 路径压缩 解决这个问题的第一种方式是路径压缩，也是竞赛中最常用的做法：因为它的代码量极小，只比刚才多了六个可见字符！ 怎么做呢？由于只要在同一集合的元素在同一棵树里，那么树的形态是无所谓的，比如以下两棵树： 方便查询查询困难 它们的意义是相同的，而且第一种查询极快。那我们只需要在查询时将查询的点直接指向它的树根就好。只需做如下代码更改： int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; 可以证明，采用路径压缩的并查集，每次 find 操作的均摊复杂度都是 O(log⁡n)\\mathcal{O}(\\log n)O(logn)。 按秩合并 按秩合并的根本思路是在合并时就减小树的深度，这样使得树的深度本身就减小，从而降低查询的代价。 按秩合并有两种不同的方法。具体取决于秩的定义。秩可定义为树的深度（未路径压缩时）。定义 int rank[MAXN]; /* 初始化为 1，表示子树大小 */。这种方法通常比启发式合并快，代码如下： inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); if (xx == yy) return; if (rank[xx] > rank[yy]) fa[yy] = xx; // 指向大的 else fa[xx] = yy; if (rank[xx] == rank[yy]) ++rank[yy]; // 相同，父亲 +1 &#125; 另一种，当秩定义为集合的大小时，我们每次都会把小的集合合并到大的集合当中，只会增加小集合的查询代价。这样的合并方式称之为启发式合并，在许多数据结构中都能见到它的身影。 开始的时候要这样定义：int size[MAXN]; /* 将 size 数组（表示子树大小）填充为 1 */。然后这样合并： inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); if (xx == yy) return; if (size[xx] > size[yy]) swap(xx, yy); // 小的合并到大的 fa[xx] = yy; size[yy] += size[xx]; &#125; 可以证明，采用按秩合并的并查集，平均每次操作的时间复杂度也是 O(log⁡n)\\mathcal{O}(\\log n)O(logn)。 当两种优化同时采用时，时间复杂度会降至反阿克曼函数级别。具体的资料可以自行搜索。要知道阿克曼函数的增长速度要比指数函数还要可怕，那么反阿克曼函数的增长速度也就慢的吓人，可以看作近似常数。 我们不需要但心路径压缩会对 size 或 rank 数组造成破坏，这并不会影响我们工作。 如果只采用按秩合并，那么并查集就可以实现可怕的功能：支持撤销操作，只需要把之前连上的边再指向自己即可。 并查集的复杂度 可以阅读下面这篇文章。来自 https://oi-wiki.org/ds/dsu-complexity/，根据 CC BY-SA 4.0 和 SATA 协议引用。 查看文章 这里还是说实际应用时怎么办。一般情况下我们采用路径压缩即可，但如果时间特别吃紧，则使用路径压缩加按秩合并。 但某些时候路径压缩不起作用，因为单次合并可能会造成大量修改。这时我们只使用启发式合并，而不使用路径压缩。比如可持久化并查集，线段树分治等。 这里我们采用 Loj 的并查集模板题目 Loj 109，来检验各种方法的速度。开启 O2 优化。 方法 时间 空间 暴力 TLE 15.7 M 路径压缩 690 ms 15.7 M 按秩合并 605 ms 31.0 M 路径压缩 + 按秩合并 579 ms 31.1 M 启发式合并 590 ms 31.0 M 路径压缩 + 启发式合并 601 ms 30.9 M 可以看到路径压缩的副作用还是较大的，要比按秩合并慢。但是同时采用两种优化并不会使代码快多少，所以一般使用路径压缩即可，但不意味着可以不学按秩合并——特殊情况下它能解决比路径压缩更多的问题。这里给出最后一种方法的代码参考： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const i64 MOD = 998244353; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; class UnionFind_Set &#123; private: int fa[4000005], size[4000005]; public: inline void init(int n) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i, size[i] = 1; &#125; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); if (xx == yy) return; if (size[xx] > size[yy]) swap(xx, yy); fa[xx] = yy; size[yy] += size[xx]; &#125; inline bool ask(int x, int y) &#123; if (find(x) == find(y)) return 1; else return 0; &#125; &#125;U; int main(void) &#123; int n = read(), m = read(); i64 ans = 0; U.init(n); while (m--) &#123; int op = read(), x = read(), y = read(); if (op == 0) U.uni(x, y); else &#123; ans &lt;&lt;= 1; ans += U.ask(x, y); ans %= MOD; &#125; &#125; printf(\"%lld\\n\", ans); return 0; &#125; 并查集 Tricks 实际上并查集非常的强大。 边带权 实际上并查集是一个森林，可以拥有点权和边权。在按秩合并中，并查集就有了点权。而只要在合并的时候更新边权，那么并查集就可以统计边上的信息了。 扩展域 将一个点拆成几个点代表不同的信息，来代表具有不同性质的 xxx 的信息。 Problemset 并查集有很多有趣的题目。 简单并查集 就是并查集。 [NOI2015] 程序自动分析 Portal. 并查集擅长维护具有传递性的条件。相等关系就有这种性质，它们在同一个集合中。而不等关系不可以用并查集维护。那么我们可以先考虑相等关系，再看不等关系是否和它们矛盾。注意到数据编号很大，需要离散化。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, tot, m; int a[1000005], b[1000005], type[1000005]; int d[2000005], fa[2000005]; int P(int x) &#123; return lower_bound(d + 1, d + m + 1, x) - d; &#125; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; int T = read(); while (T--) &#123; n = read(), tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(), b[i] = read(), type[i] = read(); d[++tot] = a[i], d[++tot] = b[i]; &#125; sort(d + 1, d + tot + 1); m = unique(d + 1, d + tot + 1) - (d + 1); for (int i = 1; i &lt;= m; ++i) fa[i] = i; for (int i = 1; i &lt;= n; ++i) if (type[i]) fa[find(P(a[i]))] = find(P(b[i])); bool flag = true; for (int i = 1; i &lt;= n; ++i) if (!type[i] &amp;&amp; find(P(a[i])) == find(P(b[i]))) &#123; flag = false; break; &#125; puts(flag ? \"YES\" : \"NO\"); &#125; return 0; &#125; [NOIP2010 提高组] 关押罪犯 Portal. 将关系按照怨气值由大到小排序，如果两个罪犯不一个集合，那么如果没有敌人则标记敌人，否则将新的敌人与原来敌人所在的集合合并。这样如果找到了两个人在一个集合内，也就是之前 b,cb,cb,c 都是 aaa 的敌人，那么只能让 (a,b),(a,c)(a,b),(a,c)(a,b),(a,c) 不发生冲突，(b,c)(b,c)(b,c) 发生冲突。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; struct Node &#123; int a, b, c; bool operator &lt; (const Node &amp;a) const &#123; return c > a.c; &#125; &#125; a[100005]; int n, m, b[20005]; int fa[20005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;a[i].a, &amp;a[i].b, &amp;a[i].c); sort(a + 1, a + m + 1); for (int i = 1; i &lt;= m; ++i) &#123; int x = find(a[i].a), y = find(a[i].b); if (x == y) return printf(\"%d\\n\", a[i].c), 0; if (!b[a[i].a]) b[a[i].a] = a[i].b; else fa[find(b[a[i].a])] = y; if (!b[a[i].b]) b[a[i].b] = a[i].a; else fa[find(b[a[i].b])] = x; &#125; puts(\"0\"); return 0; &#125; 接下来我们会通过几道题目来认识带权并查集。带权并查集有很多种，要具体情况具体分析。 [NOIP2015 提高组] 信息传递 题面。 求有向图的最小环。 假说信息由 A 传递给 B，那么就连一条由 A 指向 B 的边。在连之前判断是否在一个集合里，如果在，就说明出现了环。而我们还想要知道长度，所以需要记录 d[x] 表示到父亲节点的边权。代码如下： #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, ans = 0x7fffffff; int fa[200005], d[200005]; int find(int x) &#123; if (x == fa[x]) return x; // 是自己直接返回 int root = find(fa[x]); // 找所在集合 d[x] += d[fa[x]]; // 为路径压缩做准备，距离设为接到父亲上 return fa[x] = root; // 路径压缩 &#125; inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); // 这里的查找还有一个作用：把之前没更新的都更新，所以不用担心合并两棵树时字节点没有更新导致结果错误，就是所谓的“延迟（懒惰）更新” if (xx != yy) &#123; fa[xx] = yy; // x 的父亲为 y d[x] = d[y] + 1; // x 的距离为 y 到根节点的距离 +1（因为 y 是 x 的父亲） &#125; else ans = min(ans, d[x] + d[y] + 1); // 在同一棵树里，环长度为各自到根节点的距离和 +1 &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= n; ++i) uni(i, read()); // 这是广义的合并，环是不能合并的 printf(\"%d\\n\", ans); return 0; &#125; 这就是所谓的“边带权”并查集。每个节点到树根都有一些信息。可以发现边带权并查集依赖于路径压缩，没有路径压缩它无法正常工作（想一想，为什么）。 最小环是图论中的一个经典问题，并查集并不能解决它的所有变种。请学有余力读者自行寻找 dfs、Tarjan、Floyd 等资料。 [NOI2002] 银河英雄传说 题面。 由于距离的存在，很容易想到用边带权并查集来解决。由于合并时的特殊性，我们还需要记录集合的大小。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int fa[30005]; int d[30005], Size[30005]; int find(int x) &#123; if (fa[x] == x) return x; int root = find(fa[x]); d[x] += d[fa[x]]; return fa[x] = root; &#125; inline void uni(int x, int y) &#123; int xx = find(x), yy = find(y); fa[xx] = yy, d[xx] = Size[yy]; Size[yy] += Size[xx]; &#125; int main(void) &#123; int T = read(); for (int i = 1; i &lt;= 30000; ++i) fa[i] = i, Size[i] = 1; while (T--) &#123; char s[3]; int i, j; scanf(\"%s%d%d\", s, &amp;i, &amp;j); if (s[0] == 'C') &#123; if (find(i) == find(j)) printf(\"%d\\n\", abs(d[i] - d[j]) - 1); else puts(\"-1\"); &#125; else uni(i, j); &#125; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"算法竞赛/学习笔记/数据结构","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://james1badcreeper.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"ATCoder 乱做记录","slug":"default/old/arc-1","date":"2022-11-08T00:00:00.000Z","updated":"2022-11-08T00:00:00.000Z","comments":true,"path":"dae55f85/","link":"","permalink":"https://james1badcreeper.github.io/dae55f85/","excerpt":"听说做点 AT 题非常好玩，于是就来了。但是笔者太菜了，所以都不会。","text":"听说做点 AT 题非常好玩，于是就来了。但是笔者太菜了，所以都不会。 PART-A james1 是菜狗。 AtCoder Regular Contest 104 Portal. A. Plus Minus Portal. 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int a, b; cin >> a >> b; cout &lt;&lt; (a + b) / 2 &lt;&lt; ' ' &lt;&lt; (a - b) / 2 &lt;&lt; endl; return 0; &#125; B. DNA Sequence Portal. 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, ans = 0; char a[5005]; int cnt[4]; int main(void) &#123; scanf(\"%d%s\", &amp;n, a + 1); for (int i = 1; i &lt;= n; ++i) &#123; memset(cnt, 0, sizeof(cnt)); for (int j = i; j &lt;= n; ++j) &#123; if (a[j] == 'A') ++cnt[0]; else if (a[j] == 'T') ++cnt[1]; else if (a[j] == 'G') ++cnt[2]; else ++cnt[3]; if (cnt[0] == cnt[1] &amp;&amp; cnt[2] == cnt[3]) ++ans; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; C. Fair Elevator Portal. 先考虑几个基本条件：必须有 b&gt;ab&gt;ab&gt;a，每一个位置最多有一个人上下，否则显然不合法。 发现 n≤100n\\le 100n≤100，因此可以想的暴力一点。想要给 −1-1−1 的位置填数字不太好搞，那么就依次考虑楼层，给楼层安排上这一层上或者是下的人。 设 f(i)f(i)f(i) 代表考虑前 iii 层楼是否可以做到合法，初始时 f(0)=1f(0)=1f(0)=1，目标为 f(2n)f(2n)f(2n)。转移显然是： f(i)=∨{f(j−1)∧calc(j,i)}(1≤j&lt;i,2∣i−j+1)f(i)=\\vee\\{f(j-1)\\wedge \\text{calc}(j,i)\\}(1\\le j&lt;i,2\\mid i-j+1) f(i)=∨{f(j−1)∧calc(j,i)}(1≤j&lt;i,2∣i−j+1) 注意区间长度一定要是 222 的倍数，否则是不可能合法的（根本填不进去）。 现在问题就是如何实现判断区间合法的 calc 函数。显然这段区间必须是&quot;封闭&quot;的当中的任何位置都不可以跑到区间外面去。再就是必须在前半段上电梯，后半段下电梯，否则必定可以划分成更小的区间。此时上下电梯的位置必须是前半段中的第 iii 个和后半段中的第 iii 个，这样才能保证坐电梯的层数是相等的。 时间复杂度 O(n3)O(n^3)O(n3)。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[105], b[105]; int cnt[205], p[205]; bool f[205]; bool calc(int L, int R) &#123; for (int i = L; i &lt;= R; ++i) &#123; // 在此处下，上来的地方小于 L if (p[i] &lt; 0 &amp;&amp; a[-p[i]] != -1 &amp;&amp; a[-p[i]] &lt; L) return false; // 在此处上，下去的地方大于 R if (p[i] > 0 &amp;&amp; b[p[i]] != -1 &amp;&amp; b[p[i]] > R) return false; &#125; int half = (R - L + 1) >> 1; for (int i = L; i &lt;= L + half - 1; ++i) &#123; if (p[i] &lt; 0) return false; // 前半段下，不行 if (p[i + half] > 0) return false; // 后半段上，不行 if (p[i] &amp;&amp; p[i + half] &amp;&amp; p[i] + p[i + half]) return false; // 距离不相等，不行 &#125; return true; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", a + i, b + i); if (a[i] != -1 &amp;&amp; b[i] != -1 &amp;&amp; a[i] >= b[i]) return puts(\"No\"), 0; if (a[i] != -1) ++cnt[a[i]], p[a[i]] = i; if (b[i] != -1) ++cnt[b[i]], p[b[i]] = -i; &#125; n &lt;&lt;= 1; for (int i = 1; i &lt;= n; ++i) if (cnt[i] > 1) return puts(\"No\"), 0; f[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = ((i &amp; 1) ? 2 : 1); j &lt;= i; j += 2) if (f[j - 1]) f[i] |= calc(j, i); puts(f[n] ? \"Yes\" : \"No\"); return 0; &#125; ATCoder Regular Contest 105 Portal. A. Fourtune Cookies Portal. 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int main(void) &#123; int a[4]; cin >> a[0] >> a[1] >> a[2] >> a[3]; sort(a, a + 4); if (a[3] == a[0] + a[1] + a[2] || a[1] + a[2] == a[0] + a[3] || a[0] + a[1] == a[2] + a[3]) puts(\"Yes\"); else puts(\"No\"); return 0; &#125; B. MAX-=min Portal. 这个过程就是更相减损法，所以求 gcd⁡\\gcdgcd 即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int main(void) &#123; int n, x, g = 0; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); g = gcd(g, x); &#125; printf(\"%d\\n\", g); return 0; &#125; C. Camels and Bridge Portal.有 n(2≤n≤8)n(2\\le n\\le 8)n(2≤n≤8) 只骆驼，第 iii 只骆驼的重量是 wiw_iwi​，你可以任意排列骆驼的顺序，并令骆驼之间的距离为非负实数（可以不等距），骆驼在过一座有 M(1≤M≤105)M(1\\le M \\le 10^5)M(1≤M≤105) 个部分的桥时会保持队形，第 iii 部分桥有一个长度 lil_ili​ 和一个承重能力 viv_ivi​，上面的骆驼质量不可以超过桥的城中能力。找出骆驼过桥的最短队形长度，可以证明这一定是一个整数，若骆驼不可能过去则输出 −1-1−1。 nnn 的范围很小，因此可以想的暴力一点。考虑枚举全排列，然后使用 DP 来计算最小长度：f(i)f(i)f(i) 为到第 iii 个骆驼为止的最小距离，转移的时候要枚举右端点，然后依次向左端扩展寻找最大值。可以使用状态压缩预处理出一个骆驼集合需要的最长那一段的距离。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int n, m, ans = 1e9; int w[10], a[10], f[10], W[500]; int l[100005], v[100005]; bool vis[10]; void dfs(int x) &#123; if (x == n) &#123; memset(f, 0, sizeof(f)); for (int i = 1; i &lt; n; ++i) &#123; int now = (1 &lt;&lt; a[i]); for (int j = i - 1; j >= 0; --j) &#123; now |= (1 &lt;&lt; a[j]); f[i] = max(f[i], f[j] + W[now]); &#125; &#125; ans = min(ans, f[n - 1]); return; &#125; for (int i = 0; i &lt; n; ++i) if (!vis[i]) &#123; vis[a[x] = i] = true; dfs(x + 1); vis[i] = false; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", w + i); sort(w, w + n); for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d%d\", l + i, v + i); if (v[i] &lt; w[n - 1]) return puts(\"-1\"), 0; &#125; for (int i = 1; i &lt; (1 &lt;&lt; n); ++i) &#123; int s = 0; for (int j = 0; j &lt; n; ++j) if ((i >> j) &amp; 1) s += w[j]; for (int j = 0; j &lt; m; ++j) if (s > v[j]) W[i] = max(W[i], l[j]); &#125; dfs(0); printf(\"%d\\n\", ans); return 0; &#125; D. Let’s Play Nim Portal.有 n(1≤n≤105)n(1 \\leq n\\leq 10 ^ 5)n(1≤n≤105) 个背包，nnn 个盘子，背包 iii 里有 ai(1≤ai≤109)a _ i(1 \\leq a _ i \\leq 10 ^ 9)ai​(1≤ai​≤109) 个硬币，初始时盘子里没有硬币。两个人轮流操作，如果还有背包有硬币，那么可以选择一个背包，把全部硬币导入某个盘子中，如果没有背包有硬币，那么可以选择一个盘子，至少取走一个硬币，最后不能操作的人输。 nnn 为奇数时后手必胜，nnn 为偶数时如果所有数的出现次数都为偶数那么还是后手必胜，否则先手必胜。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;map> using namespace std; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n; map&lt;int, int> s; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); s[x] += 1; &#125; if (n &amp; 1) puts(\"Second\"); else &#123; bool flag = false; for (auto x : s) if (x.second &amp; 1) &#123; flag = true; break; &#125; puts(flag ? \"First\" : \"Second\"); &#125; &#125; return 0; &#125; E. Keep Graph Disconnected Portal.给定一张无向图，由两个玩家轮流连边，不可以连重边和自环，不能使 111 和 nnn 相连，谁不能操作谁输。问谁必胜。 最终局面，点归作两个集合，一个与 111 属于同一个集合，一个与 nnn 属于同一个集合，还需要连的边数为 n×(n−1)÷2−m−k(n−k)n\\times(n-1)\\div 2-m-k(n-k)n×(n−1)÷2−m−k(n−k)。 当 nnn 为奇数时，k(n−k)k(n-k)k(n−k) 必定为偶数，那么可以直接根据奇偶性判断。 当 nnn 为偶数时，考虑与 1,n1,n1,n 相连的集合大小分别为 x,yx,yx,y，那么若 x,yx,yx,y 奇偶性不同，则先手可以随意控制 kkk 的奇偶性（第一步达到，然后接下来维护不变），必胜。若相同，则考虑 n×(n−1)÷2−m−xyn\\times (n-1)\\div 2 -m -xyn×(n−1)÷2−m−xy 的奇偶性，因为每一方总能让奇偶性不变。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int fa[100005], siz[100005]; int find(int x) &#123; if (x == fa[x]) return x; return fa[x] = find(fa[x]); &#125; int n, m; void solve(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) fa[i] = i, siz[i] = 1; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); int uu = find(u), vv = find(v); if (uu != vv) fa[vv] = uu, siz[uu] += siz[vv]; &#125; if (find(1) == find(n)) return puts(\"Second\"), void(); if (n % 2) return puts((1ll * n * (n - 1) / 2 - m) % 2 ? \"First\" : \"Second\"), void(); int x = siz[find(1)], y = siz[find(n)]; if (x % 2 != y % 2) return puts(\"First\"), void(); if ((1ll * n * (n - 1) / 2 - m - x * y) % 2) puts(\"First\"); else puts(\"Second\"); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; AtCoder Regular Contest 143 Portal. A. Three Integers Portal. 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef long long i64; int main(void) &#123; i64 a[3]; cin >> a[0] >> a[1] >> a[2]; sort(a, a + 3); if (a[0] + a[1] &lt; a[2]) puts(\"-1\"); else printf(\"%lld\\n\", a[2]); return 0; &#125; C. Piles of Pebbles Portal. 分类讨论。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, x, y; int a[200005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;x, &amp;y); bool flag = 0, g = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); a[i] %= x + y; if (a[i] != 0) flag = true; &#125; if (!flag) return puts(\"Second\"), 0; if (x &lt;= y) puts(\"First\"); else &#123; flag = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &lt; x) flag = true; if (flag) puts(\"Second\"); else puts(\"First\"); &#125; return 0; &#125; AtCoder Regular Contest 145 Portal. A. AB Palindrome Portal. 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; char s[200005]; int main(void) &#123; scanf(\"%d%s\", &amp;n, s); if (s[0] == 'A' &amp;&amp; s[n - 1] == 'A') puts(\"Yes\"); else if (s[0] == 'A' &amp;&amp; s[n - 1] == 'B') puts(\"No\"); else if (s[0] == 'B' &amp;&amp; s[n - 1] == 'A') &#123; if (n > 2) puts(\"Yes\"); else puts(\"No\"); &#125; else puts(\"Yes\"); return 0; &#125; B. AB Game Portal.nnn 轮游戏，第 iii 轮有 iii 个石子。Alice 先手，每次可以取 aaa 的倍数的石子，Bob 后手，可以取 bbb 的倍数的石子。谁取不了石子，谁就输。问 Alice 赢几场。 可以肯定，能取多少就取多少。 当 n&lt;an&lt;an&lt;a 时，显然直接死。 当 a&lt;ba&lt;ba&lt;b 时，除了一开始 n−1n-1n−1 轮，剩下都赢。 当 a≥ba\\ge ba≥b 时，可以发现有胜利循环节。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int main(void) &#123; i64 n, a, b; cin >> n >> a >> b; if (n &lt; a) puts(\"0\"); else if (n == a) puts(\"1\"); else if (a &lt; b) printf(\"%lld\\n\", n - a + 1); else &#123; i64 ans = 1; n -= a; ans += n / a * b; n %= a; ans += min(n, b - 1); printf(\"%lld\\n\", ans); &#125; return 0; &#125; C. Split and Maximize Portal.对于一个 1∼2n1\\sim2n1∼2n 的排列 [p1,p2,…,p2n][p_{1},p_{2},\\dots,p_{2n}][p1​,p2​,…,p2n​]，考虑将 PPP 拆分为两个子序列 [a1,a2,…,an][a_1,a_2,\\dots,a_n][a1​,a2​,…,an​] 和 [b1,b2,…,bn][b_1,b_2,\\dots,b_n][b1​,b2​,…,bn​]，PPP 的分数定义为所有拆分方案中的 ∑aibi\\sum a_i b_i∑ai​bi​ 的最大值。请求出分数取到最大值的排列的数量，对 998244353998244353998244353 取模。 显然只能 (1,2),(3,4)…(2n−1,2n)(1,2),(3,4)\\dots (2n-1,2n)(1,2),(3,4)…(2n−1,2n) 这样配对，而每一个配对的左右顺序是不影响的，所以答案基数为 2n2^n2n。 而且要保证是子序列，所以相当于在 2n2n2n 中选择 nnn 个位置进行放置，方案数为 (2nn)\\binom{2n}{n}(n2n​)。 所以答案为 2n(2nn)2^n\\binom{2n}{n}2n(n2n​)。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 998244353; int poww(int a, int b) &#123; int res = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b &amp; 1) res = 1ll * res * a % MOD; return res; &#125; int main(void) &#123; int n; cin >> n; i64 ans = poww(2, n); for (int i = n + 2; i &lt;= (n &lt;&lt; 1); ++i) ans = ans * i % MOD; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; D. Non Arithmetic Progression Set Portal.构造一个有 nnn 个整数的集合 SSS，满足所有数的和为 MMM，而且每个数的值域均为 [−107,107][-10^7,10^7][−107,107] 中，并且对于任意 x,y,z∈S,x&lt;y&lt;zx,y,z\\in S, x&lt;y&lt;zx,y,z∈S,x&lt;y&lt;z，都有 y−x≠z−yy-x\\neq z-yy−x=z−y。 首先，y−x≠z−yy-x\\neq z-yy−x=z−y 相当于 x+z≠2yx+z\\neq 2yx+z=2y。 我们先抛开和为 MMM 的限制，考虑如何搞定最后那个不等的限制条件。 这里先给出结论：将数写成三进制，当数的所有位都是 0,10,10,1 时可以满足。 为什么呢？考虑 x+z=2yx+z=2yx+z=2y，yyy 乘上 222 之后每一位都是 000 或 222，而 xxx 和 zzz 必定有一位不一样（否则就相等了），加上之后肯定有一位是 111，必定不等于 2y2y2y。所以不等关系永远满足。 现在假定我们构造出来的集合可以表示为递增序列 aaa，然后进行下面对 MMM 的限制的讨论。 假设我们的 sss 与 MMM 的差为 xxx，整个序列如果同时加上或减去一个数，其性质仍然满足。那么我们可以通过这一点将差 xxx 控制在 0∼n−10\\sim n-10∼n−1 内。我们将三进制位的最后一位留白（即最后一位不进行构造，留出来一个 000），然后选择任意 xxx 个数加上 111 即可，最后一位的改变并不会影响答案。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef long long i64; int n, a[10005]; i64 m, s = 0; int main(void) &#123; cin >> n >> m; for (int p = 1; p &lt;= n; ++p) &#123; int x = 0, i = p * 2; for (int j = 0, z = 1; j &lt; 16; ++j, z *= 3) if ((i >> j) &amp; 1) x += z; a[p] = x; s += a[p]; &#125; int x = ((m - s) % n + n) % n; for (int i = 1; i &lt;= x; ++i) ++a[i], ++s; i64 buf = (m - s) / n; s = 0; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i] + buf); putchar('\\n'); return 0; &#125; AtCoder Regular Contest 147 Portal. A. Max Mod Min Portal. 可以预计答案不会很大，直接模拟。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;set> using namespace std; int main(void) &#123; ios::sync_with_stdio(false); int n, x; multiset &lt;int, greater&lt;int>> s; cin >> n; while (n--) &#123; cin >> x; s.insert(x); &#125; int res = 0; while (s.size() > 1) &#123; auto i = s.end(), j = s.begin(); --i; int t = (*j) % (*i); s.erase(j); if (t) s.insert(t); ++res; &#125; printf(\"%d\\n\", res); return 0; &#125; B. Swap to Sort Portal.现有一个 111 到 NNN 的排列 P=(P1,P2,…,PN)P=(P_1,P_2,\\ldots,P_N)P=(P1​,P2​,…,PN​)。你可以重复执行以下两种操作来使PPP从小到大排序。操作 A:A:A: 选择一个整数 iii 满足 1 ≤ i ≤ N−11\\ \\leq\\ i\\ \\leq\\ N-11 ≤ i ≤ N−1，然后交换 PiP_iPi​ 和 Pi+1P_{i+1}Pi+1​。操作 B:B:B: 选择一个整数 iii 满足 1 ≤ i ≤ N−21\\ \\leq\\ i\\ \\leq\\ N-21 ≤ i ≤ N−2，然后交换 PiP_iPi​ 和 Pi+2P_{i+2}Pi+2​。请找出一个操作序列满足操作 AAA 的数量最少。 只要奇数都在奇数位置，偶数都在偶数位置，那么只需要 2 操作就可以完成。因此我们只需要 1 操作修正奇偶性。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef pair&lt;int,int> pii; int n; int a[405]; vector &lt;pii> ans; void f(int ty, int x) &#123; ans.emplace_back(make_pair(ty, x)); swap(a[x], a[x + ty]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); // 奇偶性修正 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n - 2; ++j) if (a[j] % 2 != a[j + 2] % 2 &amp;&amp; a[j] % 2 != j % 2) f(2, j); for (int i = 1; i &lt; n; ++i) if (a[i] % 2 != i % 2) f(1, i); // 维护大小 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n - 2; ++j) if (a[j] > a[j + 2]) f(2, j); cout &lt;&lt; ans.size() &lt;&lt; endl; for (auto x : ans) printf(\"%c %d\\n\", x.first == 1 ? 'A' : 'B', x.second); return 0; &#125; PART-B 想了想可以扩大一下范围，ABC 也可以做一做，但简单题就不写了。 ATCoder Regular Contest 144 Portal. C. K Derangement Portal.求字典序最小的 1∼n1\\sim n1∼n 的排列 ppp 满足 ∣pi−i∣≥k\\left|p_i-i\\right|\\geq k∣pi​−i∣≥k，无解输出 −1-1−1。2≤n≤1052\\leq n\\leq10^52≤n≤105，1≤p&lt;n1\\leq p&lt;n1≤p&lt;n。 显然，k&gt;n2k&gt;\\cfrac{n}{2}k&gt;2n​ 的时候无解。 否则呢？比如我们来看这样一个：9 1，它的答案是 2 1 4 3 6 5 8 9 7。 按位构造，考虑每一个 iii，如果 i+ki+ki+k 不在 A1,…,Ai−1A_1,\\dots,A_{i-1}A1​,…,Ai−1​ 里，而且满足 i+k&gt;n−ki+k&gt;n-ki+k&gt;n−k，那么就让 Ai←i+kA_i\\leftarrow i+kAi​←i+k，这是什么意思？就是说，如果我们只是去找最小的，可能最终的构造会出现死局，这种时候就是要出现死局了，于是就不能使用“否则”这个方式； 否则就找到一个最小的可用的 xxx 满足 ∣x−i∣≥k|x-i|\\ge k∣x−i∣≥k。 现在如何实现更是个难题。 当 n≥4kn\\ge 4kn≥4k 时，我们会以 2k2k2k 的长度作为循环，长成 k+1,…,2k,1,…,kk+1,\\dots,2k,1,\\dots,kk+1,…,2k,1,…,k 这样子。 接下来就不能循环了，否则可能把它后面整成无法构造的。只可能有两种情况（否则已经被判为无解）： 2k≤n≤3k2k\\le n\\le 3k2k≤n≤3k，可以构造成 Ai={i+k,1≤i≤n−k,i−n+k,n−k&lt;i≤n.A_i=\\begin{cases}i+k,&amp;1\\le i \\le n-k,\\\\i-n+k,&amp;n-k&lt;i\\le n.\\end{cases}Ai​={i+k,i−n+k,​1≤i≤n−k,n−k&lt;i≤n.​ 3k&lt;n≤4k3k&lt;n\\le 4k3k&lt;n≤4k，可以构造成 Ai={i+k,1≤i≤k,i−k,k&lt;i≤n−2k,i+k,n−2k&lt;i≤n−k,i−2k,n−k&lt;i≤3k,i−k,3k&lt;i≤n.A_i=\\begin{cases}i+k,&amp;1\\le i\\le k,\\\\i-k,&amp;k&lt;i\\le n-2k,\\\\i+k,&amp;n-2k&lt;i\\le n-k,\\\\i-2k,&amp; n-k&lt;i\\le 3k,\\\\i-k,&amp;3k&lt;i\\le n.\\end{cases}Ai​=⎩⎨⎧​i+k,i−k,i+k,i−2k,i−k,​1≤i≤k,k&lt;i≤n−2k,n−2k&lt;i≤n−k,n−k&lt;i≤3k,3k&lt;i≤n.​ 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, k; cin >> n >> k; if (k > n / 2) return puts(\"-1\"), 0; int m = 0; while (n - m >= k * 4) &#123; for (int i = 1; i &lt;= k; ++i) printf(\"%d \", m + k + i); for (int i = 1; i &lt;= k; ++i) printf(\"%d \", m + i); m += 2 * k; &#125; if (n - m &lt;= 3 * k) &#123; for (int i = m + k + 1; i &lt;= n; ++i) printf(\"%d \", i); for (int i = m + 1; i &lt;= m + k; ++i) printf(\"%d \", i); &#125; else &#123; int d = n - m - 3 * k; for (int i = 1; i &lt;= k; ++i) printf(\"%d \", m + k + i); for (int i = 1; i &lt;= d; ++i) printf(\"%d \", m + i); for (int i = 1; i &lt;= k; ++i) printf(\"%d \", n - k + i); for (int i = d + 1; i &lt;= k; ++i) printf(\"%d \", m + i); for (int i = 1; i &lt;= d; ++i) printf(\"%d \", m + 2 * k + i); &#125; putchar('\\n'); return 0; &#125; ATCoder Regular Contest 144 Portal. A. Digit Sum of 2x Portal. 一个数的第一位是 111，能对答案产生贡献的数的区间是： [1,2)[1,2)[1,2)， [10,20)[10, 20)[10,20)， [100,200)[100, 200)[100,200)， … 第二位是 111 能对答案产生贡献的是： [11,12)[11,12)[11,12)， [110,120)[110,120)[110,120), … 枚举前面 111 的个数作为下界闭区间，再加上 111 作为上界开区间，不断乘 101010 来获得新的上下界，需要注意边界条件 nnn 和当前算的数要取一个最小值。时间复杂度 O(log⁡2n)O(\\log^2 n)O(log2n)。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int main(void) &#123; i64 n, ans = 0, base = 0; scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= 16; ++i) &#123; base = base * 10 + 1; i64 w = base, t = base + 1; for (int j = i; j &lt;= 16 &amp;&amp; w &lt;= n; ++j) &#123; ans += (min(t, n + 1) - w); w *= 10, t *= 10; &#125; &#125; printf(\"%lld\\n\", ans); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"比赛记录","slug":"算法竞赛/比赛记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"刷","slug":"刷","permalink":"https://james1badcreeper.github.io/tags/%E5%88%B7/"},{"name":"ATCoder","slug":"ATCoder","permalink":"https://james1badcreeper.github.io/tags/ATCoder/"}]},{"title":"Codeforces Round #293 左右的简单题","slug":"default/old/cf292","date":"2022-11-06T00:00:00.000Z","updated":"2022-11-06T00:00:00.000Z","comments":true,"path":"c3c4dd23/","link":"","permalink":"https://james1badcreeper.github.io/c3c4dd23/","excerpt":"做不了《高考必刷卷》，那就做做这个吧。","text":"做不了《高考必刷卷》，那就做做这个吧。 实际上是在洛谷 RMJ 做的题。 Codeforces Round 292 (Croc Champ 2013 - Round 1) 大概就是这样。 A. SMSC Portal. 简单模拟。 查看代码 #include &lt;iostream> #include &lt;algorithm> using namespace std; int n; int T[1000005], C[1000005]; int inq, maxx; int main(void) &#123; ios::sync_with_stdio(false); cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> T[i] >> C[i]; for (int i = 1; i &lt;= n; ++i) &#123; if (i > 1) inq = max(0, inq - (T[i] - T[i - 1])); inq += C[i]; maxx = max(inq, maxx); &#125; cout &lt;&lt; T[n] + inq &lt;&lt; ' ' &lt;&lt; maxx &lt;&lt; endl; return 0; &#125; B. Network Topology Portal. 好像还是模拟。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, m; vector &lt;int> G[100005]; bool check_ju(void) &#123; int flag = 0; for (int i = 1; i &lt;= n; ++i) if (G[i].size() != 1) &#123; ++flag; if (flag >= 2) return false; &#125; return flag == 1; &#125; bool check_lian(void) &#123; int cnt1 = 0, cnt2 = 0; for (int i = 1; i &lt;= n; ++i) if (G[i].size() == 1) ++cnt1; else if (G[i].size() == 2) ++cnt2; else return false; return cnt1 == 2 &amp;&amp; cnt2 == n - 2; &#125; bool check_huan(void) &#123; for (int i = 1; i &lt;= n; ++i) if (G[i].size() != 2) return false; return true; &#125; int main(void) &#123; cin >> n >> m; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; if (m != n &amp;&amp; m != n - 1) puts(\"unknown topology\"); else if (m == n - 1) &#123; if (check_ju()) puts(\"star topology\"); else if (check_lian()) puts(\"bus topology\"); else puts(\"unknown topology\"); &#125; else &#123; if (check_huan()) puts(\"ring topology\"); else puts(\"unknown topology\"); &#125; return 0; &#125; C. Beautiful IP Addresses Portal. 应该还是模拟。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #include &lt;vector> using namespace std; int flag = 0; int tot = 0; vector &lt;string> v; bool check(const string &amp;s, int l, int r) &#123; if (s[l] == '0') return r == l + 1; int x = 0; for (int i = l; i &lt; r; ++i) x = x * 10 + s[i] - '0'; return 0 &lt;= x &amp;&amp; x &lt;= 255; &#125; void addIP(const string &amp;s) &#123; int n = s.length(); for (int i = 1; i &lt;= 3; ++i) for (int j = i + 1; j &lt;= i + 3; ++j) for (int k = j + 1; k &lt;= j + 3; ++k) if (1 &lt;= n - k &amp;&amp; n - k &lt;= 3 &amp;&amp; check(s, 0, i) &amp;&amp; check(s, i, j) &amp;&amp; check(s, j, k) &amp;&amp; check(s, k, n)) v.emplace_back(s.substr(0, i) + \".\" + s.substr(i, j - i) + \".\" + s.substr(j, k - j) + \".\" + s.substr(k, n - k)); &#125; void dfs(int x, string s, int n, int state) &#123; if (x == n) &#123; if (state != flag) return; addIP(s); return; &#125; if (x * 2 >= n) &#123; if (state != flag) return; dfs(x + 1, s + s[n - x - 1], n, state); return; &#125; for (int i = 0; i &lt; 10; ++i) if (flag &amp; (1 &lt;&lt; i)) dfs(x + 1, s + char(i + '0'), n, state | (1 &lt;&lt; i)); &#125; int main(void) &#123; ios::sync_with_stdio(false); int n; cin >> n; for (int i = 1, x; i &lt;= n; ++i) &#123; cin >> x; flag |= (1 &lt;&lt; x); &#125; if (n &lt;= 6) &#123; for (int i = 4; i &lt;= 12; ++i) dfs(0, \"\", i, 0); &#125; cout &lt;&lt; v.size() &lt;&lt; '\\n'; for (int i = 0; i &lt; v.size(); ++i) cout &lt;&lt; v[i] &lt;&lt; '\\n'; return 0; &#125; Codeforces Round #178 (Div.2) 好像还是这样。 A. Shaass and Oskols Portal. 就是模拟。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int a[105]; int main(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; cin >> m; while (m--) &#123; int x, y; cin >> x >> y; a[x - 1] += y - 1; a[x + 1] += a[x] - y; a[x] = 0; &#125; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; '\\n'; return 0; &#125; B. Shaass and Bookshelf Portal. 每本书要么是垂直放置，要么将来躺着。设 f(i)f(i)f(i) 为竖卷的总厚度之和为 iii，所用的最大宽度，那么转移的时候就是个 01 背包。 最后要求的是竖着的最小总厚度，那直接枚举判断是否合法，合法仅当当前的厚度要大于等于上面堆着的宽度。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m, s = 0; int t[105], w[105]; int f[205]; int main(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> t[i] >> w[i]; m += t[i]; s += w[i]; f[i] = f[i + n] = -1e9; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = m; j >= t[i]; --j) f[j] = max(f[j], f[j - t[i]] + w[i]); for (int i = 0; i &lt;= m; ++i) if (i >= s - f[i]) return printf(\"%d\\n\", i), 0; return 0; &#125; C. Shaass and Lights Portal. 有 n(1≤n≤103)n(1\\le n\\le 10^3)n(1≤n≤103) 盏灯，有 mmm 盏已经点亮，每次只能点亮与已经点亮的灯相邻的灯，求点亮所有灯的总方案数，答案对 109+710^9+7109+7 取模。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"刷","slug":"刷","permalink":"https://james1badcreeper.github.io/tags/%E5%88%B7/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"}]},{"title":"基于线段树和树状数组的序列维护","slug":"notes/DS/Segmenttree","date":"2022-11-06T00:00:00.000Z","updated":"2022-11-06T00:00:00.000Z","comments":true,"path":"89bb6fd1/","link":"","permalink":"https://james1badcreeper.github.io/89bb6fd1/","excerpt":"线段树（Segment Tree）是一种二叉搜索树，1977 年由 Jon Louis Bentley 发明，可以较为灵活且效率较高地解决信息可合并的序列维护问题。而树状数组可以维护序列的前缀和。","text":"线段树（Segment Tree）是一种二叉搜索树，1977 年由 Jon Louis Bentley 发明，可以较为灵活且效率较高地解决信息可合并的序列维护问题。而树状数组可以维护序列的前缀和。 更新日志 2023/7/14开始大规模地更改代码，重构文章。2023/6/30补充没有理解透彻的内容，增加的部分内容和习题，删除了冗余的习题。 树状数组 又称 Fenwick 树、二叉索引树（BIT）。支持维护前缀后缀的信息。 概述 树状数组将序列拆分成了恰好 nnn 个区间，对于每一个前缀求解都可以拆成 log⁡p\\log plogp 个区间进行求解，而且自带一个卡不掉的 1/21/21/2 的常数，随机数据下则为 1/41/41/4 的常数！我们通过 lowbit⁡\\operatorname{lowbit}lowbit 来支持树状数组的工作。 一个显式的树状数组 模板，区间和我们可以用前缀和相减来求解，代码如下： #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[500005]; i64 C[500005]; void add(int x, int k) &#123; for (; x &lt;= n; x += x &amp; -x) C[x] += k; &#125; i64 sum(int x) &#123; i64 r = 0; for (; x; x -= x &amp; -x) r += C[x]; return r; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), add(i, a[i]); while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) add(x, y); else printf(\"%lld\\n\", sum(y) - sum(x - 1)); &#125; return 0; &#125; 树状数组自身也有许多漂亮的操作，虽然效率上略微胜于线段树和平衡树，但是可扩展性和直观程度上却不如它们。下面我们来看一些必须掌握的。 线性建树 对于树状数组上的每个节点都向上传递，具体过程如下： for (int i = 1; i &lt;= n; ++i) &#123; int x; cin >> x; C[i] += x; if (i + lowbit(i) &lt;= n) C[i + lowbit(i)] += C[i]; &#125; 差分与前缀和 树状数组可以轻松维护序列的高阶前缀和，首先将原序列差分可以直接解决区间加单点查询。 这里直接给出方法。对于 kkk 阶前缀和，写出 (y−x+k−1k−1)\\dbinom{y-x+k-1}{k-1}(k−1y−x+k−1​) 的多项式形式，然后 yyy 表示的是下标，xxx 表示的是当前位置的值。时间复杂度 O(kqlog⁡n)O(kq\\log n)O(kqlogn)。 权值树状数组 构建原序列的权值数列，然后利用树状数组统计。下面的代码可以快速解决逆序对问题： 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; (-(x))) using namespace std; typedef long long i64; inline int read(void) &#123; int x = 0, c = getchar_unlocked(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar_unlocked();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar_unlocked(); return x * f; &#125; int n, m, a[500005], b[500005]; int C[500005]; void update(int x, int k) &#123; while (x &lt;= n) &#123; C[x] += k; x += lowbit(x); &#125; &#125; int query(int x) &#123; i64 res = 0; while (x) &#123; res += C[x]; x -= lowbit(x); &#125; return res; &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) b[i] = a[i] = read(); sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - (b + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b; i64 ans = 0; for (int i = n; i >= 1; --i) &#123; ans += query(a[i] - 1); update(a[i], 1); &#125; printf(\"%lld\\n\", ans); return 0; &#125; 权值数组也可以实现名次树，但是当强制在线时就寄掉了。但是这引出了一个重要 trick：树状数组倍增。 树状数组二分与倍增 我们当然可以使用二分套树状数组达到 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n) 的复杂度，然而有没有更好的方式适配树状数组这种结构呢？有！倍增！ 查询一个权值树状数组里的 kkk 小值。 我们从二进制高位到低位枚举，时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 // 权值树状数组查询第 k 小 int kth(int k) &#123; int sum = 0, x = 0; for (int i = 17; i >= 0; --i) &#123; // 需满足 sum &lt; k x += 1 &lt;&lt; i; // 尝试扩展 if (x >= n || sum + C[x] >= k) x -= 1 &lt;&lt; i; // x 不在树状数组范围内，或扩展失败 else sum += C[x]; &#125; return x + 1; &#125; 简介线段树 “线段树”只是 Segment Tree 的一种称法，因为线段树可以理解为是由很多线段组成的，其它叫法包括区间树（interval tree）、范围树等等。但这些称法一般用于特殊领域（如计算几何），本文均用线段树来代表 Segment Tree。 线段树是一种基于分治思想的二叉树结构，有如下特征： 线段树的每一个节点都代表一个区间。 线段树具有唯一的根节点，代表统计范围，一般为 [1,n][1,n][1,n]。 线段树的每个叶子节点长度都为 111，形如 [x,x][x,x][x,x]。 一般我们定义，若 mid=⌊(l+r)÷2⌋mid=\\lfloor(l+r)\\div2\\rfloormid=⌊(l+r)÷2⌋，那么节点 [l,r][l,r][l,r] 的左子节点是 [l,mid][l,mid][l,mid]，右子节点是 [mid+1,r][mid+1,r][mid+1,r]。 一棵线段树 对于上图这棵维护区间 [1,4][1,4][1,4] 的线段树而言，可以发现，一个节点的左子节点是它的编号乘 222，右子节点是乘 222 加 111。我们可以利用这点方便地来存储线段树。 但凑巧的是，这颗线段树是满二叉树，其它情况类似于这种： 另一棵线段树 其实去掉最后一层这树仍是满二叉树，这种情况依然可以使用上述方法存树。 线段树的存储 线段树的正常写法是堆式线段树。 其实就是只用一个数组 TTT 存储线段树，用堆的编号来表示线段树的左儿子和右儿子（lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1），不过进行操作的时候要多传两个数据 lll 和 rrr。 注意，线段树的节点必须开四倍空间！否则如果遇到非满二叉树的线段树，二倍空间就会爆炸！ 在网上你能看到这样一种堆式线段树： struct N &#123; int l, r; int val; &#125; T[4*MAXN]; 注意，它是记录了当前节点 ooo 的区间 [l,r][l,r][l,r]，在传参时可以省掉两个参数（听不懂？那就不管，往下看就行）。 有时候要维护的信息特别复杂，我们会将数组 TTT 的类型改为结构体，但还是不会使用记录区间的方式。 一般我们使用堆式线段树中的数组方式，而不记录左右儿子（不记慢不了多少）。接下来若不是特殊情况，我们均使用这种方式。 线段树的建树 接下来我们谈谈如何建树，我们再来看这棵线段树： 嘻嘻，还是我 最后一层若当作原序列的值，即 [i,i][i,i][i,i] 保存 AiA_iAi​ 的值。由于线段树是二叉树结构，可以很方便地从下往上传递信息。以区间和为例，令节点 [l,r][l,r][l,r] 表示 ∑i=lrAi\\sum\\limits_{i=l}^{r}A_ii=l∑r​Ai​，显然 [l,r]=[l,mid]+[mid+1,r][l,r]=[l,mid]+[mid+1,r][l,r]=[l,mid]+[mid+1,r]（这里的区间代表区间所对应的值）。 比如原序列是 1 2 3 4，那么对于节点 111~777，可推算出它们的值分别为 10 3 7 1 2 3 4。 那么建树的代码大概就像这样： #define L(x) ((x)&lt;&lt;1) #define R(x) ((x)&lt;&lt;1|1) // 当然，你也可以不用宏定义。 int T[4*N]; inline void maintain(int o) &#123; T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; // 从下往上传递信息。事实上你也可以写在需要调用 maintain 函数的函数里，不过有时传递的信息较为复杂，还是建议写一个 maintain 函数。网上有的教程把它写作 pushup，至于为什么，接下来你了解到 pushdown 就知道了。 &#125; void build(int o, int l, int r) &#123; //o 代表当前维护结点的标号，l 和 r 代表所对应的区间 if (l == r) return T[o] = a[l], void(); //如果这是叶子节点，赋值 int mid = l + r >> 1; // 计算中值 build(o &lt;&lt; 1, l, mid); // 为左半段建树 build(o &lt;&lt; 1 | 1, mid + 1, r); // 为右半段建树 maintain(o); // 计算当前结点的值 &#125; 在 main 用 build(1, 1, n) 来调用 build。 由于每个节点只访问了一次，所以建树的时间复杂度为 O(n)\\mathcal{O}(n)O(n)。 点修改与区间查询 模板。 点修改 还是以这棵线段树为例： 我又来啦 根据刚才的数据，初始化后它应该长这样： 初始化后的线段树 我们先来进行点修改，比如要给原序列的第 222 个元素加上 111，那么这棵线段树会怎么变化呢？ 可以发现，节点 444、222、111 都会加上 111。线段树就变成了这个样子： 点修改后的线段树 那代码怎么实现呢？一般来讲，根节点 111 总是线段树执行的入口，从根节点出发，递归找到需要修改的叶子节点，这里代码如下： void update(int o, int l, int r, int x, int k) &#123; //给原序列第 x 个元素加上 k。 if (l == r) return T[o] += k, void(); // 这是叶子节点，直接加 int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); // 叶子节点在 [l,mid] 处。 else update(o &lt;&lt; 1 | 1, mid+1, r, x, k); // 叶子节点在 [mid+1,r] 处。 maintain(o); //重新计算这个节点的值。 &#125; 由于线段树的层数在 log⁡\\loglog 级别，所以点修改的时间复杂度为 O(log⁡n)\\mathcal{O}(\\log n)O(logn)。 区间查询 查询区间 [l,r][l,r][l,r] 的和，从根节点开始，递归执行下列过程： 若当前区间 [l,r][l,r][l,r] 完全覆盖了需要求解的范围，那么直接返回答案。 若当前区间与左子节点有重叠，访问左子节点 [l,mid][l,mid][l,mid]。 若当前区间与右子节点有重叠，访问右子节点 [mid+1,r][mid+1,r][mid+1,r]（注意不是访问左子节点后就不用访问右子节点了）。 那怎么解释这个东西呢？还是看那棵线段树 （它的出镜率为什么这么高）： 嗯，又是我 比如现在我们要查 [1,3][1,3][1,3]。 [1,3][1,3][1,3] 与 [1,2][1,2][1,2] 和 [3,4][3,4][3,4] 都有重叠，所以我们要分别访问。 [1,2][1,2][1,2] 完全覆盖，直接返回。 [3,4][3,4][3,4] 左子节点有覆盖，右子节点没有，访问左子节点。 [3,3][3,3][3,3] 直接返回。 所以答案是 4+3=74+3=74+3=7。 那么代码就长这样： int query(int o, int l, int r, int ql, int qr) &#123; //[ql,qr] 是要查的区间 if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; //完全包含 int mid = l + r >> 1, res = 0; // 接下来，只要你在（哪怕只有一个元素），我就查 if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); //左子节点 if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr); //右子节点 return res; &#125; 同 update，query 的时间复杂度也是 O(log⁡n)\\mathcal{O}(\\log n)O(logn)。 以下代码就可以通过刚才的模板了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; int n, m; int T[2000005]; int a[500005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid+1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] += k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid+1, r, x, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1, res = 0; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr); return res; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); build(1, 1, n); while (m--) &#123; int op = read(), x = read(), y = read(); if (op == 1) update(1, 1, n, x, y); else printf(\"%d\\n\", query(1, 1, n, x, y)); &#125; return 0; &#125; Problemset 在讨论区间修改之前，我们先看几道线段树的题目。 [Luogu P4513] 小白逛公园 Portal. 最大子段和可以使用 O(nlog⁡n)\\mathcal{O}(n \\log n)O(nlogn) 的分治法进行求解，因为这个子段要么在序列的左半段，要么在右半段，要么跨越中点。加上多组询问，这就是线段树嘛！ 最大和的子段在中点两端好说，现在就来看一下跨越中点的情况。 线段树的每个节点维护三个值：最大子段和、最大前缀和、最大后缀和所对应的区间（此区间是线段树的节点所对应的区间）。那么最大子段和跨越中点时，就是前半区间的最大后缀和，加上后半区间的最大前缀和。 维护四个信息：区间和 sumsumsum，仅靠左端的最大连续和 lmaxlmaxlmax，靠右段的 rmaxrmaxrmax，以及区间最大子段和 datdatdat。 在 query 的时候，我们需要看它是否完全在左区间还是完全在右区间，都不是就是跨区间，需要根据左右节点的查询结果计算当前答案。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, m; int a[500005]; struct Node &#123; int sum, lmax, rmax, dat; Node (int sum = 0, int lmax = 0, int rmax = 0, int dat = 0) : sum(sum), lmax(lmax), rmax(rmax), dat(dat) &#123;&#125; &#125;T[2000005]; inline void maintain(int o) &#123; int ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; T[o].sum = T[ls].sum + T[rs].sum; T[o].lmax = max(T[ls].lmax, T[ls].sum + T[rs].lmax); T[o].rmax = max(T[rs].rmax, T[rs].sum + T[ls].rmax); T[o].dat = max(&#123;T[ls].dat, T[rs].dat, T[ls].rmax + T[rs].lmax&#125;); &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].sum = T[o].lmax = T[o].rmax = T[o].dat = a[l]; return; &#125; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; build(ls, l, mid); build(rs, mid + 1, r); maintain(o); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) &#123; T[o].sum = T[o].lmax = T[o].rmax = T[o].dat = k; return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); maintain(o); &#125; Node query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return query(ls, l, mid, ql, qr); if (ql > mid) return query(rs, mid + 1, r, ql, qr); Node x = query(ls, l, mid, ql, qr), y = query(rs, mid + 1, r, ql, qr), res; res.sum = x.sum + y.sum; res.lmax = max(x.lmax, x.sum + y.lmax); res.rmax = max(y.rmax, y.sum + x.rmax); res.dat = max(&#123;x.dat, y.dat, x.rmax + y.lmax&#125;); return res; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); while (m--) &#123; int k, x, y; scanf(\"%d%d%d\", &amp;k, &amp;x, &amp;y); if (k == 1) &#123; if (x > y) swap(x, y); printf(\"%d\\n\", query(1, 1, n, x, y).dat); &#125; else update(1, 1, n, x, y); &#125; return 0; &#125; [UVa 1400] “Ray, Pass me the dishes!” Portal. 给定一个序列和多组询问 (l,r)(l,r)(l,r)，查询区间 [l,r][l,r][l,r] 的最大子段和，并给出答案对应的字典序最小的子区间。 这回要求输出答案的区间了（），但是也没有什么好怕的。我们只需要记录一个 max_sub 来记录区间。 首先是建树，像这样： void build(int o, int l, int r) &#123; if (l == r) &#123; maxsub[o] = make_pair(l, r); maxpre[o] = l; maxsuf[o] = r; return; &#125; // 以上显然 int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; build(lc, l, mid); build(rc, mid+1, r); // maintain &#125; 如何维护这一节点呢？根据刚才所说，对应三种情况： maxsub[o] = better(maxsub[lc], maxsub[rc]); // 左右区间 maxsub[o] = better(maxsub[o], make_pair(maxsuf[lc], maxpre[rc])); // 跨越中点 其中 better 函数用于比较哪个子区间更好。 maxsuf 和 maxpre 怎么维护呢？以 maxpre 为例子，像这样： LL v1 = sum(l, maxpre[lc]); LL v2 = sum(l, maxpre[rc]); if (v1 == v2) maxpre[o] = min(maxpre[lc], maxpre[rc]); // 右端点肯定是越小越好的 else maxpre[o] = v1 > v2 ? maxpre[lc] : maxpre[rc]; 其中 sum 指原序列的区间和，容易用前缀和求解。 接下来是查询，大概像这样： Interval query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return maxsub[o]; // 在区间范围内 int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return query(lc, l, mid, ql, qr); // 完全在左半端 if (ql > mid) return query(rc, mid+1, r, ql, qr); // 完全在右半段 Interval ans = better(query(lc, l, mid, ql, qr), query(rc, mid+1, r, ql, qr)); // 不跨越中点 return better(ans, make_pair(calc_suf(lc, l, mid, ql).L, calc_pre(rc, mid+1, r, qr).R)); // 跨越中点 &#125; 注意求解前缀和后缀的函数，这里的写法完全符合刚才的定义，这里给出 calc_pre 的实现，calc_suf 的实现大致相同。 Interval calc_pre(int o, int l, int r, int qr) &#123; if (maxpre[o] &lt;= qr) return make_pair(l, maxpre[o]); // 完全在查询范围内 int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return calc_pre(lc, l, mid, qr); // 在左半端 // 注意它要么完全在左半段要么跨越中点，不可能全在右半段 Interval ans = make_pair(l, calc_pre(rc, mid+1, r, qr).R); // 跨越中点 return better(ans, make_pair(l, maxpre[lc])); // 与完全在左半段比较 &#125; 下面是完整代码： 查看代码 #include &lt;iostream> #include &lt;cstdio> #define Interval pair&lt;int, int> #define L first #define R second #define LL long long using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; int n, m; int a[500005]; Interval maxsub[2000005]; LL prefix_sum[500005]; int maxpre[2000005], maxsuf[2000005]; inline LL sum(int l, int r) &#123;return prefix_sum[r] - prefix_sum[l-1];&#125; inline LL sum(Interval x) &#123;return sum(x.L, x.R);&#125; inline Interval better(Interval a, Interval b) &#123; if (sum(a) != sum(b)) return sum(a) > sum(b) ? a : b; return a &lt; b ? a : b; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; maxsub[o] = make_pair(l, r); maxpre[o] = l; maxsuf[o] = r; return; &#125; int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; build(lc, l, mid); build(rc, mid+1, r); LL v1 = sum(l, maxpre[lc]); LL v2 = sum(l, maxpre[rc]); if (v1 == v2) maxpre[o] = min(maxpre[lc], maxpre[rc]); else maxpre[o] = v1 > v2 ? maxpre[lc] : maxpre[rc]; v1 = sum(maxsuf[lc], r); v2 = sum(maxsuf[rc], r); if (v1 == v2) maxsuf[o] = min(maxsuf[lc], maxsuf[rc]); else maxsuf[o] = v1 > v2 ? maxsuf[lc] : maxsuf[rc]; maxsub[o] = better(maxsub[lc], maxsub[rc]); maxsub[o] = better(maxsub[o], make_pair(maxsuf[lc], maxpre[rc])); &#125; Interval calc_pre(int o, int l, int r, int qr) &#123; if (maxpre[o] &lt;= qr) return make_pair(l, maxpre[o]); int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return calc_pre(lc, l, mid, qr); Interval ans = make_pair(l, calc_pre(rc, mid+1, r, qr).R); return better(ans, make_pair(l, maxpre[lc])); &#125; Interval calc_suf(int o, int l, int r, int ql) &#123; if (maxsuf[o] >= ql) return make_pair(maxsuf[o], r); int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (ql > mid) return calc_suf(rc, mid+1, r, ql); Interval ans = make_pair(calc_suf(lc, l, mid, ql).L, r); return better(ans, make_pair(maxsuf[rc], r)); &#125; Interval query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return maxsub[o]; int mid = l + r >> 1, lc = o &lt;&lt; 1, rc = o &lt;&lt; 1 | 1; if (qr &lt;= mid) return query(lc, l, mid, ql, qr); if (ql > mid) return query(rc, mid+1, r, ql, qr); Interval ans = better(query(lc, l, mid, ql, qr), query(rc, mid+1, r, ql, qr)); return better(ans, make_pair(calc_suf(lc, l, mid, ql).L, calc_pre(rc, mid+1, r, qr).R)); &#125; int main(void) &#123; int kase = 0; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2) &#123; printf(\"Case %d:\\n\", ++kase); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); prefix_sum[i] = prefix_sum[i-1] + a[i]; &#125; build(1, 1, n); while (m--) &#123; int l = read(), r = read(); Interval ans = query(1, 1, n, l, r); printf(\"%d %d\\n\", ans.L, ans.R); &#125; &#125; return 0; &#125; 根据以上可以发现，线段树可以维护的是容易按照区间进行划分和合并，这一点又称满足区间可加性。关于这一点，接下来还会详细叙述。 区间 GCD Portal。 给定长度为 n(n⩽5×105)n(n\\leqslant 5\\times 10^5)n(n⩽5×105) 的序列 AAA，m(m⩽105)m(m\\leqslant 10^5)m(m⩽105) 次操作：C l r d，表示区间加 ddd。Q l r，表示求 gcd⁡(Al,Al+1,⋯ ,Ar−1,Ar)\\gcd(A_l,A_{l+1},\\cdots,A_{r-1},A_r)gcd(Al​,Al+1​,⋯,Ar−1​,Ar​)。 这个问题看上去很棘手，怎么办呢？强烈建议读者停下来自行思考——想一想 gcd⁡\\gcdgcd 的性质，利用在树状数组学过的内容将原问题转换为可以用点修改实现的。还有一点可以发现：gcd⁡\\gcdgcd 满足区间可加性，可以通过小区间的 gcd⁡\\gcdgcd 求出大区间的 gcd⁡\\gcdgcd。 请读者先自行撕烤，然后再看解答。 查看解答 根据 gcd⁡(x,y)=gcd⁡(x,y−x)\\gcd(x,y)=\\gcd(x,y-x)gcd(x,y)=gcd(x,y−x)，而且还有 gcd⁡(x,y,z)=gcd⁡(x,y−x,z−y)\\gcd(x,y,z)=\\gcd(x,y-x,z-y)gcd(x,y,z)=gcd(x,y−x,z−y)，这是什么？差分序列！那么我们可以用支持单点修改的线段树来解决这个问题，这样的话，Q l r 相当于求 gcd(a[l], query(1, 1, n, l + 1, r)。AAA 数组的值可以用一个支持“区间修改，单点查询”的树状数组实现。线段树修改时，需要进行两次单点修改。你可能会问一个问题，负数怎么办？实际上 gcd⁡\\gcdgcd 的性质对负数同样成立，但是你的输出总不能是负的吧，所以我们在输出时 abs 一下就好。注意由于有负数，所以 gcd 的代码实现要更改（因为取模运算有坑）。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; inline i64 read(void) &#123; i64 x = 0; int c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; i64 gcd(i64 a, i64 b) &#123; if (b == 0) return a; return gcd(b, (a % b + b) % b); &#125; int n, m; i64 a[500010], b[500010]; class FenwickTree &#123; private: i64 C[500010]; #define lowbit(x) (x &amp; -x) public: inline void add(int x, i64 k) &#123; while (x &lt;= n) &#123; C[x] += k; x += lowbit(x); &#125; &#125; inline i64 sum(int x) &#123; i64 res = 0; while (x) &#123; res += C[x]; x -= lowbit(x); &#125; return res; &#125; &#125;F; class SegmentTree &#123; private: i64 T[2000050]; inline void maintain(int o) &#123; T[o] = gcd(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; public: void build(int o, int l, int r) &#123; if (l == r) return T[o] = b[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; void update(int o, int l, int r, int x, i64 k) &#123; if (l == r) &#123; T[o] += k; return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); maintain(o); &#125; i64 query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1; i64 res = 0; if (ql &lt;= mid) res = gcd(res, query(o &lt;&lt; 1, l, mid, ql, qr)); if (mid &lt; qr) res = gcd(res, query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr)); return res; &#125; &#125; S; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); b[i] = a[i] - a[i-1]; &#125; S.build(1, 1, n); // 树状数组不建树，到时候直接加上 a[l] 即可 while (m--) &#123; char c; cin >> c; int l = read(), r = read(); if (c == 'C') &#123; i64 k = read(); F.add(l, k); S.update(1, 1, n, l, k); if (r &lt; n) &#123; F.add(r + 1, -k); S.update(1, 1, n, r + 1, -k); &#125; &#125; else printf(\"%lld\\n\", abs(gcd(a[l] + F.sum(l), l &lt; r ? S.query(1, 1, n, l + 1, r) : 0))); &#125; return 0; &#125; 区间修改与延迟标记 根据刚才的学习，可以发现线段树是个很厉害的数据结构，但它的威力可不止如此，来看，还有更厉害的： 延迟标记的介绍 [Luogu 3372]【模板】线段树 1 进行下面两种操作：将区间 [l,r][l,r][l,r] 的每一个数加上 xxx；求区间 [l,r][l,r][l,r] 的和。 这回可不一样了，点修改只会影响树中的 log⁡n\\log nlogn 个节点，而区间修改最坏情况下会影响区间中的所有节点，这可怎么办？我们这里要引入一个叫做“延迟标记”的东西（或者叫它懒标记，即 lazy tag）。 试想，如果我们在一次修改操作中发现节点 ooo 代表的区间 [ol,or][o_l,o_r][ol​,or​] 中要修改的区间 [l,r][l,r][l,r] 被完全覆盖，那么更新点 ooo 的子树就是徒劳的。可以给节点 ooo 做一个标记，省掉接下来的操作。就是打完标记后我们可以立即返回，此标记代表“该节点曾经被修改过，但其子节点尚未更新”。 如果在后续的指令中，需要从节点 ooo 向下递归，那么我们就下传 ooo 的标记，并清空 ooo 的标记。 接下来我们看一下这道题该怎么写。首先建树和维护当前节点的过程没有变化，而对于修改操作需要这样写： void update(int o, int l, int r, int x, int y, int k) //区间 [x,y] 加上 k &#123; if (x &lt;= l &amp;&amp; r &lt;= y) //在区间范围内 &#123; T[o] += (LL)k * (r-l+1); tag[o] += k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid+1 &lt;= y) update(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; 这里有几点需要注意，首先是 TTT 数组的修改，别忘了这是区间修改，要加上的数需要乘上区间的长度。 然后是 pushdown 函数（有的版本写成 spread），需要这样： inline void pushdown(int o, int l, int r) &#123; if (tag[o]) //标记不是 0 才有必要下传，但非要传也非不可，慢不了多少 &#123; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; // 下传标记 int mid = l + r >> 1; // 注意区间的长度 T[o &lt;&lt; 1] += (LL)tag[o] * (mid-l+1); T[o &lt;&lt; 1 | 1] += (LL)tag[o] * (r-mid); tag[o] = 0; // 清除父亲节点的标记（因为下传了） &#125; &#125; 需要分别修改左右儿子标记的值和数值。 最后是递归的过程，由于是区间修改，所以左右都需要判断（mid + 1 &lt;= y 有的版本会写成 mid &lt; y ）。 注意查询的时候也需要下传标记（否则你怎么查，子节点没法计算了）。 注意到了吧？pushdown 的反义词是 pushup，所以有人把 maintain 写成 pushup。 想一想，为什么以上操作都可以保证最后的结果时间复杂度是正确的呢（建议手玩）？ 查询操作道理基本相同，相信大家可以自己写出来。 那么对于这道题而言： 查看代码 #include &lt;iostream> #include &lt;cstdio> #define LL long long using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c))&#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; int n, m; LL a[100005]; LL T[400005], tag[400005]; inline void maintain(int o) &#123; T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; inline void pushdown(int o, int l, int r) &#123; if (tag[o]) &#123; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; int mid = l + r >> 1; T[o &lt;&lt; 1] += (LL)tag[o] * (mid-l+1); T[o &lt;&lt; 1 | 1] += (LL)tag[o] * (r-mid); tag[o] = 0; &#125; &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid+1, r); maintain(o); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; T[o] += (LL)k * (r-l+1); tag[o] += k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid+1 &lt;= y) update(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; LL query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1; LL res = 0; pushdown(o, l, r); if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr); return res; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); build(1, 1, n); while (m--) &#123; int op = read(); if (op == 1) &#123; int x = read(), y = read(), k = read(); update(1, 1, n, x, y, k); &#125; else &#123; int x = read(), y = read(); printf(\"%lld\\n\", query(1, 1, n, x, y)); &#125; &#125; return 0; &#125; 是不是有点意思了？还有更复杂的。 多组延迟标记 你以为延迟标记只能由有一组？只要你愿意，都可以整出一百组（不过好像也没有一百组）！ [UVa 11992] Fast Matrix Operations Portal。 有一个 rrr 行 ccc 列的全零矩阵，矩阵不超过 202020 行，支持子矩阵加，子矩阵赋值和查询子矩阵和、最小值和最大值。 由于矩阵最多有 202020 行，所以可以每行造一棵线段树，那么本体转化为一维问题。 现在由于有两种操作，那么就有两个标记，但两个标记总得有个顺序吧！否则不乱套了！ 由于先加后赋值是没有任何意义的，所以我们规定先赋值后加。 值得一提的是，对于这种要维护信息较多的线段树，建议使用结构体，否则代码会显得很乱。 不过这里笔者有点懒，未把自己的代码改成全用结构体，仅在查询时使用了结构体，请大家谅解。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> #define o &lt;&lt; 1 ((o) &lt;&lt; 1) #define o &lt;&lt; 1 | 1 (o &lt;&lt; 1 | 1) using namespace std; struct Answer &#123; int sum, min, max; Answer(int s = 0, int i = 1000000002, int a = -1) &#123; sum = s; min = i; max = a; &#125; &#125;; inline Answer up(Answer a, Answer b) &#123; return Answer(a.sum + b.sum, min(a.min, b.min), max(a.max, b.max)); &#125; struct SegmentTree &#123; int sumv[1000005], minv[1000005], maxv[1000005]; int addv[1000005], setv[1000005]; inline void init(void) &#123; // 没有初值，可以这样建树。 memset(sumv, 0, sizeof(sumv)); memset(minv, 0, sizeof(minv)); memset(maxv, 0, sizeof(maxv)); memset(setv, -1, sizeof(setv)); memset(addv, 0, sizeof(addv)); &#125; inline void maintain(int o) &#123; sumv[o] = sumv[o &lt;&lt; 1] + sumv[o &lt;&lt; 1 | 1]; minv[o] = min(minv[o &lt;&lt; 1], minv[o &lt;&lt; 1 | 1]); maxv[o] = max(maxv[o &lt;&lt; 1], maxv[o &lt;&lt; 1 | 1]); &#125; inline void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; // 先搞 set，再搞 add if (setv[o] >= 0) &#123; setv[o &lt;&lt; 1] = setv[o &lt;&lt; 1 | 1] = setv[o]; addv[o &lt;&lt; 1] = addv[o &lt;&lt; 1 | 1] = 0; // 有 set 标记需清空 add 标记。 sumv[o &lt;&lt; 1] = (mid - l + 1) * setv[o]; sumv[o &lt;&lt; 1 | 1] = (r - mid) * setv[o]; minv[o &lt;&lt; 1] = minv[o &lt;&lt; 1 | 1] = maxv[o &lt;&lt; 1] = maxv[o &lt;&lt; 1 | 1] = setv[o]; setv[o] = -1; &#125; if (addv[o] > 0) &#123; addv[o &lt;&lt; 1] += addv[o]; addv[o &lt;&lt; 1 | 1] += addv[o]; sumv[o &lt;&lt; 1] += (mid - l + 1) * addv[o]; sumv[o &lt;&lt; 1 | 1] += (r - mid) * addv[o]; minv[o &lt;&lt; 1] += addv[o]; minv[o &lt;&lt; 1 | 1] += addv[o]; maxv[o &lt;&lt; 1] += addv[o]; maxv[o &lt;&lt; 1 | 1] += addv[o]; addv[o] = 0; &#125; &#125; inline void update_add(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addv[o] += k; sumv[o] += (r - l + 1) * k; minv[o] += k; maxv[o] += k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update_add(o &lt;&lt; 1, l, mid, x, y, k); if (mid + 1 &lt;= y) update_add(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; inline void update_set(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addv[o] = 0; setv[o] = k; sumv[o] = (r - l + 1) * k; minv[o] = maxv[o] = k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update_set(o &lt;&lt; 1, l, mid, x, y, k); if (mid + 1 &lt;= y) update_set(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; // 强烈不建议在这里使用全局变量计算答案，这是禁忌，会让代码很乱。 inline Answer query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return Answer(sumv[o], minv[o], maxv[o]); pushdown(o, l, r); int mid = l + r >> 1; Answer res; if (ql &lt;= mid) res = up(res, query(o &lt;&lt; 1, l, mid, ql, qr)); if (qr >= mid + 1) res = up(res, query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr)); return res; &#125; &#125;T[21]; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int r, c, m; int main(void) &#123; while (scanf(\"%d%d%d\", &amp;r, &amp;c, &amp;m) == 3) &#123; for (int i = 1; i &lt;= r; ++i) T[i].init(); while (m--) &#123; int op = read(); if (op == 1) &#123; int x1 = read(), y1 = read(), x2 = read(), y2 = read(), v = read(); for (int i = x1; i &lt;= x2; ++i) T[i].update_add(1, 1, c, y1, y2, v); &#125; else if (op == 2) &#123; int x1 = read(), y1 = read(), x2 = read(), y2 = read(), v = read(); for (int i = x1; i &lt;= x2; ++i) T[i].update_set(1, 1, c, y1, y2, v); &#125; else &#123; int x1 = read(), y1 = read(), x2 = read(), y2 = read(); int sumr = 0, minr = 1000000002, maxr = -1; for (int i = x1; i &lt;= x2; ++i) &#123; Answer ret = T[i].query(1, 1, c, y1, y2); sumr += ret.sum; minr = min(minr, ret.min); maxr = max(maxr, ret.max); &#125; printf(\"%d %d %d\\n\", sumr, minr, maxr); &#125; &#125; &#125; return 0; &#125; [AHOI2009] 维护序列 Portal. 区间加，区间乘，区间求和。 根据刚才的经验，要么是现加后乘，要么是先乘后加，但是都可以吗？注意，先加后乘是无法表示的，因为当乘的标记袭来后，原来的加的标记就必须变成一个分数，这就完蛋了。 实现较为简单，这里不做赘述。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define LL long long #define o &lt;&lt; 1 ((o) &lt;&lt; 1) #define o &lt;&lt; 1 | 1 (o &lt;&lt; 1 | 1) using namespace std; int n, p; int a[100005]; int T[400005]; int addv[400005], mulv[400005]; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; inline void maintain(int o) &#123; T[o] = (T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]) % p; &#125; void build(int o, int l, int r) &#123; mulv[o] = 1; if (l == r) &#123; T[o] = a[l] % p; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid+1, r); maintain(o); &#125; inline void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; T[o &lt;&lt; 1] = int(((LL)T[o &lt;&lt; 1] * mulv[o] % p + (LL)addv[o] * (mid - l + 1) % p) % p); T[o &lt;&lt; 1 | 1] = int(((LL)T[o &lt;&lt; 1 | 1] * mulv[o] % p + (LL)addv[o] * (r - mid) % p) % p); mulv[o &lt;&lt; 1] = int((LL)mulv[o &lt;&lt; 1] * mulv[o] % p); mulv[o &lt;&lt; 1 | 1] = int((LL)mulv[o &lt;&lt; 1 | 1] * mulv[o] % p); addv[o &lt;&lt; 1] = int(((LL)addv[o &lt;&lt; 1] * mulv[o] + addv[o]) % p); addv[o &lt;&lt; 1 | 1] = int(((LL)addv[o &lt;&lt; 1 | 1] * mulv[o] + addv[o]) % p); mulv[o] = 1; addv[o] = 0; &#125; void update_mul(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addv[o] = int(addv[o] * (LL)k % p); mulv[o] = int(mulv[o] * (LL)k % p); T[o] = int((LL)T[o] * k % p); return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update_mul(o &lt;&lt; 1, l, mid, x, y, k); if (mid + 1 &lt;= y) update_mul(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; void update_add(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addv[o] = (addv[o] + k) % p; T[o] = int((T[o] + (LL)k * (r - l + 1)) % p); return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update_add(o &lt;&lt; 1, l, mid, x, y, k); if (mid + 1 &lt;= y) update_add(o &lt;&lt; 1 | 1, mid+1, r, x, y, k); maintain(o); &#125; int query(int o, int l, int r, int ql, int qr) &#123; if(ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; pushdown(o, l, r); int mid = l + r >> 1, res = 0; if (ql &lt;= mid) res = (res + query(o &lt;&lt; 1, l, mid, ql, qr)) % p; if (mid + 1 &lt;= qr) res = (res + query(o &lt;&lt; 1 | 1, mid+1, r, ql, qr)) % p; return res; &#125; int main(void) &#123; n = read(), p = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); int m = read(); build(1, 1, n); while (m--) &#123; int op = read(), x = read(), y = read(); if (op == 1) &#123; int k = read(); update_mul(1, 1, n, x, y, k); &#125; else if (op == 2) &#123; int k = read(); update_add(1, 1, n, x, y, k); &#125; else printf(\"%d\\n\", query(1, 1, n, x, y)); &#125; return 0; &#125; 线段树的本质 线段树能干什么呢？ 区间可加性 记得之前提到的“区间可加性”吗？刚才的区间乘方操作满足这一性质吗？线段树的工作原理是将两个小区间的值合并成大区间的值。比如在最初的区间加区间查询问题中，我们可以通过 ∑i=lmidAi+∑i=mid+1rAi\\sum_{i=l}^{mid}A_i+\\sum_{i=mid+1}^{r}A_i∑i=lmid​Ai​+∑i=mid+1r​Ai​ 来得到 ∑i=lrAi\\sum_{i=l}^{r}A_i∑i=lr​Ai​，可以合并。 延迟标记与其它 标记是什么？它是一个“欠条”，相当于告诉线段树我在这欠了东西，继续向下递归需要 pushdown。而且能标记的东西必须可以高效更新当前节点的信息。 不下传标记查询没有办法进行？实际上标记可以永久化，就是在查询的时候累计一下标记，而且常数会小一点。但是只限于特殊的标记，比如区间加是可以做的，以最初的区间加区间查询和为例： 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, a[400005]; i64 T[400005], tag[400005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x, int y, i64 k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] += k, T[o] += (r - l + 1) * k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1] + tag[o] * (r - l + 1); &#125; i64 query(int o, int l, int r, int x, int y, i64 t) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o] + t * (r - l + 1); int mid = l + r >> 1; i64 ans = 0; t += tag[o]; if (x &lt;= mid) ans += query(o &lt;&lt; 1, l, mid, x, y, t); if (mid &lt; y) ans += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y, t); return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); while (m--) &#123; int op, l, r, k; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) scanf(\"%d\", &amp;k), update(1, 1, n, l, r, k); else printf(\"%lld\\n\", query(1, 1, n, l, r, 0)); &#125; return 0; &#125; 但是区间赋值不行，因为查询的过程中无法累加，操作的先后顺序会改变结果，不知道哪个是先做的，无法维护。当标记难以下传时，可以考虑使用标记永久化。 权值线段树 对于序列 AAA 构造一个序列 BBB，其中 BiB_iBi​ 表示 AAA 中数值 iii 出现的次数，也就是 aj=ia_j=iaj​=i 的 jjj 的个数，这样的 BBB 称之为 AAA 的权值数列，对 BBB 造一棵线段树就是权值线段树。 主要应用于一些计数问题，和可持久化搭配有奇效。为了使以后主席树（可持久化权值线段树，应用很多）的学习更加顺利，我们这里通过一道题来谈一下代码实现： 逆序对。 啊，不要问我问什么是这道题，因为它太经典了。 我们知道这道题可以用归并排序或者树状数组解决。今天我们再来用权值线段树解决它。 这种东西一般都需要先离散化。考虑枚举 jjj，对于每个 jjj 只需要找到在它之前有多少个大于它的 aia_iai​ 即可，对 AAA 前 j−1j-1j−1 位建立权值线段树，每次只需要查询线段树上 [aj+1,n][a_j+1,n][aj​+1,n] 的和即可，然后修改对于权值线段树来说就是点修改。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int a[500005], T[2000005]; void init(void) &#123; static int tmp[500005]; for (int i = 1; i &lt;= n; ++i) tmp[i] = a[i]; sort(tmp + 1, tmp + n + 1); int m = unique(tmp + 1, tmp + n + 1) - (tmp + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(tmp + 1, tmp + m + 1, a[i]) - tmp; &#125; int query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1, res = 0; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res; &#125; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o]++, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); init(); long long ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; ans += query(1, 1, n, a[i] + 1, n); update(1, 1, n, a[i]); &#125; printf(\"%lld\\n\", ans); return 0; &#125; 注意，虽然上述代码是正确的，但是对这道题来说显然不是最优的，因为查询不是简单的区间查询，而是一端固定的区间。但是用更通用的方式来写显然不易出错。 动态开点线段树 通过记录左右儿子的编号，而不是使用完全二叉树的编号法则，这种方式称之为动态开点。代码大概长这样： struct Node &#123; int lc, rc; // 左右节点编号 int dat; // 当前维护的值 &#125;T[SIZE * 2]; // 终于只需要二倍空间啦！ int root, tot; // 根节点编号，节点个数 int newNode(void) &#123; ++tot; T[tot].lc = T[tot].rc = T[tot].dat = 0; return tot; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o].dat += k, void(); int mid = l + r >> 1; if (x &lt;= mid) &#123; if (!T[o].lc) T[o].lc = build(); update(T[o].lc, l, mid, x, k); &#125; else &#123; if (!T[o].rc) T[o].rc = build(); update(T[o].rc, mid + 1, r, x, k); &#125; maintain(o); &#125; int main(void) &#123; tot = 0; root = build(); // 建树 &#125; 线段树二分 权值线段树上是可以二分的。 [PA2015] Siano.一片 nnn 亩的土地，第 iii 亩土地的草每天会长高 aia_iai​ 厘米。一共会进行 mmm 次收割，其中第 iii 次收割在第 did_idi​ 天，并把所有高度大于等于 bib_ibi​ 的部分全部割去。每次收割得到的草的高度总和是多少？ 首先发现一个问题，长得快的草一定长得高。那么将草的生长速度从小到大排序，每次割掉的一定是一个后缀区间。 使用线段树维护，查询时在线段树上二分（递归时看左子树是否满足，然后判断进入哪一棵子树）出最后一个大于等于 bbb 的点即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; int a[500005]; i64 s[500005]; struct Node &#123; i64 sum, setv, addv, maxx; Node() : setv(-1) &#123;&#125; &#125; T[2000005]; void grow(int o, int l, int r, i64 val) &#123; T[o].addv += val; T[o].sum += (s[r] - s[l - 1]) * val; T[o].maxx += a[r] * val; &#125; void cut(int o, int l, int r, i64 val) &#123; T[o].setv = T[o].maxx = val; T[o].addv = 0; T[o].sum = (r - l + 1) * val; &#125; void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; if (T[o].setv != -1) &#123; cut(o &lt;&lt; 1, l, mid, T[o].setv); cut(o &lt;&lt; 1 | 1, mid + 1, r, T[o].setv); T[o].setv = -1; &#125; if (T[o].addv) &#123; grow(o &lt;&lt; 1, l, mid, T[o].addv); grow(o &lt;&lt; 1 | 1, mid + 1, r, T[o].addv); T[o].addv = 0; &#125; &#125; i64 modify(int o, int l, int r, int x, int y, i64 val) &#123; if (x > y) return 0; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; i64 tmp = T[o].sum; cut(o, l, r, val); return tmp - T[o].sum; &#125; i64 res = 0; int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) res += modify(o &lt;&lt; 1, l, mid, x, y, val); if (mid &lt; y) res += modify(o &lt;&lt; 1 | 1, mid + 1, r, x, y, val); T[o].sum = T[o &lt;&lt; 1].sum + T[o &lt;&lt; 1 | 1].sum; T[o].maxx = T[o &lt;&lt; 1 | 1].maxx; return res; &#125; int find(int o, int l, int r, i64 val) &#123; if (l == r) return T[o].sum &lt; val ? n + 1 : l; int mid = l + r >> 1; pushdown(o, l, r); if (T[o &lt;&lt; 1].maxx >= val) return find(o &lt;&lt; 1, l, mid, val); return find(o &lt;&lt; 1 | 1, mid + 1, r, val); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + a[i]; i64 last = 0; while (m--) &#123; i64 d, b; scanf(\"%lld%lld\", &amp;d, &amp;b); grow(1, 1, n, d - last); last = d; printf(\"%lld\\n\", modify(1, 1, n, find(1, 1, n, b), n, b)); &#125; return 0; &#125; 线段树的分裂与合并 对于动态开点的权值线段树，它们可以进行分裂和合并的操作。 线段树合并 假设现在有两棵维护相同值域的基于动态开点实现的权值线段树，现在我们想要将它们维护的值相加。这就需要通过线段树合并来实现，从两个根节点开始同步遍历两棵线段树，也就是说，两个指针 o1,o2o_1,o_2o1​,o2​，在实现中采用 p,qp,qp,q，所代表的子区间是一致的。 如果两个其中之一为空，那么返回那个非空的。如果都不是空的，那么需要递归合并两棵子树，然后删去节点 qqq，以 ppp 作为合并的节点（维护最大值）。 int merge(int p, int q, int l, int r) &#123; if (!p) return q; if (!q) return p; if (l == r) &#123; T[p].dat += T[q].dat; return p; &#125; int mid = l + r >> 1; T[p].lc = merge(T[p].lc, T[q].lc, l, mid); T[p].rc = merge(T[p].rc, T[q].rc, mid + 1, r); T[p].dat = max(T[T[p].lc].dat, T[T[p].rc].dat); return p; &#125; 时间复杂度与线段树的规模一致。这样将 qqq 合并到 ppp 之后会导致 qqq 的结构被破坏，所以这样只能离线。如果实时新建节点可以做到在线，这样的空间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)： int merge(int p, int q, int l, int r) &#123; if (p == 0 || q == 0) return p + q; int o = ++tot; if (l == r) &#123; T[o].dat = T[p].dat + T[q].dat; return o; &#125; int mid = l + r >> 1; T[o].ls = merge(T[p].ls, T[q].rs, l, mid); T[o].rs = merge(T[p].rs, T[q].rs, mid + 1, r); pushup(o); return o; &#125; 模板。差分操作，对每一个节点都使用一棵动态开点权值线段树来维护信息，最后前缀和一次做线段树合并回答询问。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 100000; int n, m, dep[100005], mi[17][100005], dfn[100005], num, lg[100005]; int f[100005], ans[100005]; vector&lt;int> G[100005]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; void dfs(int x, int fa) &#123; mi[0][dfn[x] = ++num] = fa; dep[x] = dep[fa] + 1; f[x] = fa; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int k = lg[v - u]; return get(mi[k][u + 1], mi[k][v - (1 &lt;&lt; k) + 1]); &#125; struct Node &#123; int ls, rs; int cnt, ans; &#125; T[6000005]; int root[100005], tot; inline void pushup(int o) &#123; if (T[T[o].ls].cnt >= T[T[o].rs].cnt) T[o].cnt = T[T[o].ls].cnt, T[o].ans = T[T[o].ls].ans; else T[o].cnt = T[T[o].rs].cnt, T[o].ans = T[T[o].rs].ans; &#125; void update(int &amp;o, int l, int r, int x, int k) &#123; if (!o) o = ++tot; if (l == r) return T[o].cnt += k, T[o].ans = x, void(); int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, l, mid, x, k); else update(T[o].rs, mid + 1, r, x, k); pushup(o); &#125; int merge(int p, int q, int l, int r) &#123; if (!p || !q) return p + q; if (l == r) return T[p].cnt += T[q].cnt, p; int mid = l + r >> 1; T[p].ls = merge(T[p].ls, T[q].ls, l, mid); T[p].rs = merge(T[p].rs, T[q].rs, mid + 1, r); pushup(p); return p; &#125; void calc(int x, int fa) &#123; for (int y : G[x]) if (y != fa) &#123; calc(y, x); root[x] = merge(root[x], root[y], 1, N); &#125; ans[x] = T[root[x]].ans; if (!T[root[x]].cnt) ans[x] = 0; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= lg[n]; ++i) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); while (m--) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); int d = LCA(x, y); update(root[x], 1, N, z, 1); update(root[y], 1, N, z, 1); update(root[d], 1, N, z, -1); update(root[f[d]], 1, N, z, -1); &#125; calc(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; 线段树分裂 是将一个可重集前 kkk 小的数之后的数分成两个集合，这样线段树就会分裂成两棵线段树。 可以仿照 FHQ-Treap 的思路，我们可以实现 O(log⁡n)O(\\log n)O(logn) 的线段树分裂。 代填坑。 Problemset 感觉内容很多？的确如此，基础数据结构可以解决很多问题，下面是一些经典题。 简单问题 主要如何拆分或变形要处理的内容，使得更容易维护。以及如何合并简单的标记。 [Luogu P1438] 无聊的数列 Portal. 区间加等差数列，单点查询。 等差数列看作一个整体当成标记的话非常难维护，因为首项一直在改变。对于一次操作，可以拆成对区间的 k-d*l（为当前的 lll）和 +d*i（为当前下标）。这个 +d*? 的操作只需要开一个标记，然后再查询的时候乘上当前的 lll 就可以了。代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; int n, m; int a[100005]; i64 tagk[400005], tagd[400005]; inline void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; tagk[o &lt;&lt; 1] += tagk[o], tagk[o &lt;&lt; 1 | 1] += tagk[o]; tagd[o &lt;&lt; 1] += tagd[o], tagd[o &lt;&lt; 1 | 1] += tagd[o]; tagk[o] = tagd[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k, int d) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tagk[o] += k; tagd[o] += d; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k, d); if (mid + 1 &lt;= y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k, d); &#125; i64 query(int o, int l, int r, int p) &#123; if (l == r) return tagk[o] + l * tagd[o]; int mid = l + r >> 1; pushdown(o, l, r); if (p &lt;= mid) return query(o &lt;&lt; 1, l, mid, p); return query(o &lt;&lt; 1 | 1, mid + 1, r, p); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); while (m--) &#123; int opt; scanf(\"%d\", &amp;opt); if (opt == 1) &#123; int l, r; i64 k, d; scanf(\"%d%d%lld%lld\", &amp;l, &amp;r, &amp;k, &amp;d); update(1, 1, n, l, r, k - d * l, d); &#125; else &#123; int p; scanf(\"%d\", &amp;p); printf(\"%lld\\n\", query(1, 1, n, p) + a[p]); &#125; &#125; return 0; &#125; 为什么是单点查询？因为查询的时候每个下标是变化的，+d*? 的 ? 一直在变化，只能做单点。 [Luogu P6327] 区间加区间 sin 和 Portal. 高中课本介绍了三角函数的和差角公式： sin⁡(α+β)=sin⁡αcos⁡β+cos⁡αsin⁡βcos⁡(α+β)=cos⁡αcos⁡β−sin⁡αsin⁡β\\sin(\\alpha+\\beta)=\\sin \\alpha \\cos \\beta + \\cos\\alpha\\sin\\beta\\\\ \\cos(\\alpha+\\beta)=\\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta sin(α+β)=sinαcosβ+cosαsinβcos(α+β)=cosαcosβ−sinαsinβ 维护两个量 Sin 和 Cos，记录一个标记 tag，update 和 pushdown 的时候用公式维护加上标记的值的三角函数值即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m; int a[200005]; i64 tag[800005]; double Sin[800005], Cos[800005]; inline void maintain(int o) &#123; Sin[o] = Sin[o &lt;&lt; 1] + Sin[o &lt;&lt; 1 | 1]; Cos[o] = Cos[o &lt;&lt; 1] + Cos[o &lt;&lt; 1 | 1]; &#125; inline void maintain(int o, double sinx, double cosx) &#123; double sina = Sin[o], cosa = Cos[o]; Sin[o] = sina * cosx + cosa * sinx; Cos[o] = cosa * cosx - sina * sinx; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; Sin[o] = sin(a[l]); Cos[o] = cos(a[l]); return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; double sinx = sin(tag[o]), cosx = cos(tag[o]); maintain(o &lt;&lt; 1, sinx, cosx); maintain(o &lt;&lt; 1 | 1, sinx, cosx); tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125; int k; double sink, cosk; void update(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; maintain(o, sink, cosk); tag[o] += k; return; &#125; pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y); maintain(o); &#125; double query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return Sin[o]; pushdown(o); double res = 0; int mid = l + r >> 1; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res; &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); build(1, 1, n); m = read(); while (m--) &#123; int op = read(); if (op == 1) &#123; int l = read(), r = read(); k = read(); sink = sin(k), cosk = cos(k); update(1, 1, n, l, r); &#125; else &#123; int l = read(), r = read(); printf(\"%.1lf\\n\", query(1, 1, n, l, r)); &#125; &#125; return 0; &#125; 「Wdsr-2.7」文文的摄影布置 Portal. 观察条件 Ai+Ak−min⁡{Bj},i&lt;j&lt;kA_i+A_k-\\min\\{B_j\\},i&lt;j&lt;kAi​+Ak​−min{Bj​},i&lt;j&lt;k，我们在线段树的节点中维护 AAA 的最大值和 BBB 的最小值，以及区间答案 ansansans。 现在难就难在满足线段树的“区间可加性”，也就是如何从左右儿子合并出当前节点的答案。min⁡{Bj}\\min\\{B_j\\}min{Bj​} 可以当成一个值，就是区间 BBB 最小值。肯定可以三个数全从左子节点或右子节点过来，也可以两个数从一个节点过来，一个数从另一个节点过来。这样的话，我们记 lmaxlmaxlmax 代表 Ai−BjA_i-B_jAi​−Bj​ 的最大值，rmaxrmaxrmax 代表 Ak−BjA_k-B_jAk​−Bj​ 的最大值。这两个可以简单维护，要么从左右节点单独过来，要么两个下标在不同的区间，而且由于 i&lt;j&lt;ki&lt;j&lt;ki&lt;j&lt;k，所以顺序一定。这样 ansansans 就要么是左子节点的 lmaxlmaxlmax 和右子节点的 amaxamaxamax 合并过来，要么是从右子节点的 rmaxrmaxrmax 和左子节点的 lmaxlmaxlmax 合并过来。 那么 lmaxlmaxlmax 和 rmaxrmaxrmax 呢？大致同理，要么都在叶子节点，要么跨区间，跨区间的时候就是通过维护的 A,BA,BA,B 值来计算即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; int n, m; int a[500005], b[500005]; struct Node &#123; int amax, bmin; int lmax, rmax, ans; &#125; T[2000005]; inline Node merge(Node a, Node b) &#123; Node ans; ans.amax = max(a.amax, b.amax); ans.bmin = min(a.bmin, b.bmin); ans.lmax = max(&#123;a.lmax, b.lmax, a.amax - b.bmin&#125;); ans.rmax = max(&#123;a.rmax, b.rmax, b.amax - a.bmin&#125;); ans.ans = max(&#123;a.ans, b.ans, a.amax + b.rmax, a.lmax + b.amax&#125;); return ans; &#125; void build(int o, int l, int r) &#123; T[o].lmax = T[o].rmax = T[o].ans = -INF; // 初始什么都没有，是负无穷 if (l == r) return T[o].amax = a[l], T[o].bmin = b[l], void(); int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = ls | 1; build(ls, l, mid); build(rs, mid + 1, r); T[o] = merge(T[ls], T[rs]); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o].amax = a[l], T[o].bmin = b[l], void(); int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = ls | 1; if (x &lt;= mid) update(ls, l, mid, x, k); else update(rs, mid + 1, r, x, k); T[o] = merge(T[ls], T[rs]); &#125; Node query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = ls | 1; if (qr &lt;= mid) return query(ls, l, mid, ql, qr); if (mid &lt; ql) return query(rs, mid + 1, r, ql, qr); return merge(query(ls, l, mid, ql, qr), query(rs, mid + 1, r, ql, qr)); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", b + i); build(1, 1, n); while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; a[x] = y; update(1, 1, n, x, y); &#125; else if (op == 2) &#123; b[x] = y; update(1, 1, n, x, y); &#125; else printf(\"%d\\n\", query(1, 1, n, x, y).ans); &#125; return 0; &#125; [NOIP2016 提高组] 蚯蚓 Portal. 蚯蚓长度增加这一事我们用一个延迟标记 deltadeltadelta 完成，然后使用三个队列模拟优先队列（因为分裂越晚的蚯蚓长度只能更短）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; struct Queue &#123; int Q[7000005], L = 1, R = 0; inline void push(int x) &#123; Q[++R] = x; &#125; inline void pop(void) &#123; ++L; &#125; inline int front(void) &#123; return L &lt;= R ? Q[L] : -INF; &#125; inline bool empty(void) &#123; return L > R; &#125; &#125; A, B, C; int n, m, q, u, v, t, delta = 0; int a[100005], ans[7100005], tot = 0; int main(void) &#123; scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); for (int i = n; i >= 1; --i) A.push(a[i]); for (int i = 1; i &lt;= m; ++i, delta += q) &#123; int x; if (A.front() >= B.front() &amp;&amp; A.front() >= C.front()) x = A.front(), A.pop(); else if (B.front() >= A.front() &amp;&amp; B.front() >= C.front()) x = B.front(), B.pop(); else x = C.front(), C.pop(); x += delta; if (i % t == 0) printf(\"%d \", x); int y = 1ll * u * x / v; B.push(y - delta - q); C.push(x - y - delta - q); &#125; putchar('\\n'); for (int i = A.L; i &lt;= A.R; ++i) ans[++tot] = A.Q[i]; for (int i = B.L; i &lt;= B.R; ++i) ans[++tot] = B.Q[i]; for (int i = C.L; i &lt;= C.R; ++i) ans[++tot] = C.Q[i]; sort(ans + 1, ans + tot + 1, greater&lt;int>()); for (int i = 1; i &lt;= tot; ++i) if (i % t == 0) printf(\"%d \", ans[i] + delta); putchar('\\n'); return 0; &#125; [SDOI2009] HH 的项链 Portal. 显然同一种类只有最右面的会有用。将询问按照右端点排序，然后可以让前缀和不断向右扩展，方便查询，使用树状数组维护前缀和即可。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; struct Question &#123; int l, r, id; bool operator &lt; (const Question &amp;a) const &#123; return r &lt; a.r; &#125; &#125; q[1000005]; int n, m, C[1000005]; int a[1000005], ans[1000005]; int last[1000005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int sum(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r), q[i].id = i; sort(q + 1, q + m + 1); int r = 1; for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt;= q[i].r) &#123; if (last[a[r]]) add(last[a[r]], -1); add(last[a[r]] = r, 1); ++r; &#125; ans[q[i].id] = sum(q[i].r) - sum(q[i].l - 1); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; [GZOI2017] 配对统计 Portal. 挖掘配对的性质，发现将配对的数排序后一个数的配对只能是它左边第一个或者是它右边第一个。将询问按照右端点排序，然后使用双指针加树状数组来维护当前询问的答案即可。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) ((x) &amp; (-(x))) #define X first #define Y second using namespace std; typedef long long i64; typedef pair&lt;int, int> pii; int n, m, tot = 0; pii b[600005]; bool cmp(pii a, pii b) &#123; if (a.Y != b.Y) return a.Y &lt; b.Y; return a.X &lt; b.X; &#125; struct Node &#123; int val, pos; bool operator &lt; (Node &amp;a) const &#123; return val &lt; a.val; &#125; &#125;a[300005]; struct Question &#123; int l, r; int pos, ans; bool operator &lt; (const Question &amp;a) const &#123; if (r != a.r) return r &lt; a.r; return l &lt; a.l; &#125; &#125;Q[300005]; // ============ Fenwick Tree ============ int C[300005]; void update(int x) &#123; while (x &lt;= n) &#123; C[x]++; x += lowbit(x); &#125; &#125; int query(int x) &#123; int res = 0; while (x) &#123; res += C[x]; x -= lowbit(x); &#125; return res; &#125; void add(int l, int r) &#123; if (l > r) swap(l, r); ++tot; b[tot].X = l, b[tot].Y = r; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); if (n == 1) return puts(\"0\"), 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i].val), a[i].pos = i; sort(a + 1, a + n + 1); add(a[1].pos, a[2].pos); add(a[n - 1].pos, a[n].pos); for (int i = 2; i &lt; n; ++i) &#123; int l = a[i].val - a[i - 1].val, r = a[i + 1].val - a[i].val; if (l == r) add(a[i - 1].pos, a[i].pos), add(a[i].pos, a[i + 1].pos); else if (l &lt; r) add(a[i - 1].pos, a[i].pos); else add(a[i].pos, a[i + 1].pos); &#125; sort(b + 1, b + tot + 1, cmp); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r); Q[i].pos = i; &#125; sort(Q + 1, Q + m + 1); i64 ans = 0; for (int i = 1, j = 0; i &lt;= m; ++i) &#123; while (j &lt; tot &amp;&amp; b[j + 1].Y &lt;= Q[i].r) &#123; ++j; update(b[j].X); &#125; ans += 1ll * Q[i].pos * (j - query(Q[i].l - 1)); &#125; printf(\"%lld\\n\", ans); return 0; &#125; 「Wdsr-3」令人感伤的红雨 Portal. 实际上 Ω(l,r)=max⁡{0,l−A(1,r)}\\Omega(l,r)=\\max\\{0,l-A(1,r)\\}Ω(l,r)=max{0,l−A(1,r)}，因此考虑如何维护前缀 AAA。设所有“最值点”为 bbb，前缀加会导致一些最值点消失，并查集维护每个位置所对应的最值点，链表维护最值点的存在情况即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int a[6000005], fa[6000005], nxt[6000005], b[6000005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(b, -1, sizeof b); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), fa[i] = i, nxt[i] = n + 1; for (int i = 2, p = 1; i &lt;= n; ++i) &#123; if (a[i] >= a[p]) nxt[p] = i, b[p] = a[i] - a[p], p = i; else fa[i] = p; &#125; while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; int t = find(x); b[t] -= y; while (nxt[t] &lt;= n &amp;&amp; b[t] &lt; 0) &#123; b[t] += b[nxt[t]]; fa[nxt[t]] = t; nxt[t] = nxt[nxt[t]]; &#125; &#125; else printf(\"%d\\n\", max(0, x - find(y))); &#125; return 0; &#125; 技巧性问题 这里是线段树的一些经典应用。 [Luogu P4145] 上帝造题的七分钟 2 / 花神游历各国 Portal. 懒标记？ 如果您能提出质疑，那么笔者为您点赞。如果不能，你可能要重新去看《线段树的本质》一节（笔者要被扣工资了）。 要注意到的是，如果使用延迟标记，那么当前的区间和是无法维护的。因为它不像区间加区间 sin 和这种东西可以进行拆解，每个数开平方后区间的和无法简单维护。 但是区间开方这种东西，很容易就开到 111 了。然而对着 111 开方是没有用的。所以如果区间的最大值是 111，那么区间开方这种操作就没必要进行了。 我们直接使用线段树，但是不需要延迟标记，维护到叶子节点为止。如果一个区间已经比 111 小，那么就不用维护了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m; i64 a[100005]; i64 sum[400005], maxx[400005]; inline void maintain(int o) &#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; maxx[o] = max(maxx[o &lt;&lt; 1], maxx[o &lt;&lt; 1 | 1]); &#125; void build(int o, int l, int r) &#123; if (l == r) return sum[o] = maxx[o] = a[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; void update(int o, int l, int r, int x, int y) &#123; if (l == r) // 叶子节点重新维护 &#123; sum[o] = sqrt(sum[o]); maxx[o] = sqrt(maxx[o]); return; &#125; int mid = l + r >> 1; if (x &lt;= mid &amp;&amp; maxx[o &lt;&lt; 1] > 1) update(o &lt;&lt; 1, l, mid, x, y); // 最大值大于 1 才修改 if (mid &lt; y &amp;&amp; maxx[o &lt;&lt; 1 | 1] > 1) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y); maintain(o); &#125; i64 query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return sum[o]; int mid = l + r >> 1; i64 res = 0; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); scanf(\"%d\", &amp;m); build(1, 1, n); while (m--) &#123; int k, l, r; scanf(\"%d%d%d\", &amp;k, &amp;l, &amp;r); if (l > r) swap(l, r); if (k == 0) update(1, 1, n, l, r); else printf(\"%lld\\n\", query(1, 1, n, l, r)); &#125; return 0; &#125; [TJOI2018] 数学计算 Portal. 这不是模拟吗（ 但是不行，我们知道除法是没有随时取模性质的，就算算逆元，也没有保证互质，逆元不一定有。 注意到最多除一次，以时间建立一棵线段树，根节点维护的是当前的 xxx 值。对于一个乘操作，我们就将当前询问的编号乘上 xxx，对于除法，我们就将这个编号改为 111。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int Q, M; int T[400005]; void build(int o, int l, int r) &#123; T[o] = 1; if (l == r) return; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) &#123; T[o] = (k == 0) ? 1 : k; return; &#125; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = ls | 1; if (x &lt;= mid) update(ls, l, mid, x, k); else update(rs, mid + 1, r, x, k); T[o] = (i64)T[ls] * T[rs] % M; &#125; int main(void) &#123; int TT; scanf(\"%d\", &amp;TT); while (TT--) &#123; scanf(\"%d%d\", &amp;Q, &amp;M); build(1, 1, Q); for (int i = 1; i &lt;= Q; ++i) &#123; int op, x; scanf(\"%d%d\", &amp;op, &amp;x); if (op == 1) update(1, 1, Q, i, x); else update(1, 1, Q, x, 0); printf(\"%d\\n\", T[1] % M); &#125; &#125; return 0; &#125; 这种基于时间的操作非常常见，请读者一定要熟记。 [SHOI2015] 脑洞治疗仪 Portal. 对于操作二，考虑线段树上二分：需要先满足填的区间，然后从左子树开始尝试填满（见代码）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct Node &#123; int sum, lmax, rmax, dat, len; &#125; T[800005]; int tag[800005], len[800005]; int n, m; Node hb(const Node &amp;a, const Node &amp;b) &#123; Node c; c.sum = a.sum + b.sum; c.len = a.len + b.len; c.lmax = (a.lmax == a.len ? a.len + b.lmax : a.lmax); c.rmax = (b.rmax == b.len ? b.len + a.rmax : b.rmax); c.dat = max(&#123;a.dat, b.dat, a.rmax + b.lmax&#125;); return c; &#125; void build(int o, int l, int r) &#123; tag[o] = -1; T[o].len = r - l + 1; if (l == r) return T[o].sum = 1, void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void maketag(int o, int l, int r, int k) &#123; T[o].sum = k * (r - l + 1); T[o].lmax = T[o].rmax = T[o].dat = (1 - k) * (r - l + 1); tag[o] = k; &#125; void pushdown(int o, int l, int r) &#123; if (tag[o] == -1) return; int mid = l + r >> 1; maketag(o &lt;&lt; 1, l, mid, tag[o]); maketag(o &lt;&lt; 1 | 1, mid + 1, r, tag[o]); tag[o] = -1; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, l, r, k); int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; pushdown(o, l, r); if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return hb(query(o &lt;&lt; 1, l, mid, x, y), query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); &#125; int cont(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].sum; int res = 0, mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) res += cont(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += cont(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; int dag(int o, int l, int r, int x, int y, int k) &#123; if (k == 0) return 0; if (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; T[o].len - T[o].sum &lt;= k) &#123; int t = T[o].len - T[o].sum; maketag(o, l, r, 1); return k - t; &#125; pushdown(o, l, r); int ans = 0, mid = l + r >> 1; if (y &lt;= mid) ans = dag(o &lt;&lt; 1, l, mid, x, y, k); else if (mid &lt; x) ans = dag(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); else ans = dag(o &lt;&lt; 1 | 1, mid + 1, r, x, y, dag(o &lt;&lt; 1, l, mid, x, y, k)); return T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]), ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); build(1, 1, n); while (m--) &#123; int op, l, r, l1, r1; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 0) update(1, 1, n, l, r, 0); else if (op == 1) &#123; scanf(\"%d%d\", &amp;l1, &amp;r1); int x = cont(1, 1, n, l, r); if (x == 0) continue; update(1, 1, n, l, r, 0); dag(1, 1, n, l1, r1, x); &#125; else printf(\"%d\\n\", query(1, 1, n, l, r).dat); &#125; return 0; &#125; [THUSC2015] 平方运算 Portal. 模意义下区间平方是存在循环节的，多次平方后必定会陷入循环。那么线段树直接暴力维护，提前预处理出每个数的循环，进入了循环节之后就可以开始打标记，维护一个偏移量代表循环到哪里即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125; int n, m, l = 1, P, a[100005]; int vis[10005], p[10005]; bool lp[400005]; int now[400005], tag[400005]; i64 T[400005][60]; inline void chk(int o) &#123; if (p[T[o][0]]) &#123; for (int i = 1; i &lt; l; ++i) T[o][i] = T[o][i - 1] * T[o][i - 1] % P; lp[o] = 1; &#125; &#125; inline void pushup(int o) &#123; lp[o] = (lp[o &lt;&lt; 1] &amp;&amp; lp[o &lt;&lt; 1 | 1]); now[o] = 0; if (!lp[o]) T[o][0] = T[o &lt;&lt; 1][now[o &lt;&lt; 1]] + T[o &lt;&lt; 1 | 1][now[o &lt;&lt; 1 | 1]]; else &#123; int lx = now[o &lt;&lt; 1], rx = now[o &lt;&lt; 1 | 1]; for (int i = 0; i &lt; l; ++i) &#123; T[o][i] = T[o &lt;&lt; 1][lx] + T[o &lt;&lt; 1 | 1][rx]; lx = (lx + 1) % l, rx = (rx + 1) % l; &#125; &#125; &#125; void build(int o, int l, int r) &#123; if (l == r) return T[o][0] = a[l], chk(o); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o); &#125; inline void maketag(int o, int k) &#123; tag[o] = (tag[o] + k) % l; now[o] = (now[o] + k) % l; &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; lp[o]) return maketag(o, 1); if (l == r) return T[o][0] = T[o][0] * T[o][0] % P, chk(o); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y); pushup(o); &#125; i64 query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o][now[o]]; pushdown(o); int mid = l + r >> 1; i64 res = 0; if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; void findloop(int x) &#123; for (int i = 1, y = x;; y = y * y % P, ++i) if (vis[y]) &#123; p[y] = i - vis[y]; break; &#125; else vis[y] = i; for (int y = x; vis[y]; y = y * y % P) vis[y] = 0; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;P); for (int i = 0; i &lt; P; ++i) findloop(i); for (int i = 0; i &lt; P; ++i) if (p[i]) l = lcm(l, p[i]); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); while (m--) &#123; int op, l, r; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) update(1, 1, n, l, r); else printf(\"%lld\\n\", query(1, 1, n, l, r)); &#125; return 0; &#125; 综合应用 这里是一些简单的综合题。 [HEOI2016] 排序 Portal.给定一个 111 到 nnn 的排列，进行 mmm 次操作，可以是将给定的区间升序或者降序排序。问最后第 qqq 个位置上的数字。 先来考虑一个简单的问题，01 排序怎么做？维护区间 01 的数量，排序的时候直接将后面的改为 1，前面的改为 0，可以使用线段树完成。 现在考虑怎么求解原问题。如果将所有 ≥x\\ge x≥x 的数都设置为 111，&lt;x&lt;x&lt;x 的都设置为 000，那么照样求解，如果第 qqq 个位置是 111 就说明 qqq 代表的数一定 ≥x\\ge x≥x。最终二分出的结果就是答案。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 201314; int n, m, q; int a[100005], b[100005]; int op[100005], l[100005], r[100005]; int T[400005], tag[400005]; void build(int o, int l, int r) &#123; tag[o] = -1; if (l == r) return T[o] = (b[l] == 1), void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; inline void pushdown(int o, int l, int r) &#123; if (tag[o] == -1) return; int mid = l + r >> 1; tag[o &lt;&lt; 1] = tag[o &lt;&lt; 1 | 1] = tag[o]; T[o &lt;&lt; 1] = tag[o] * (mid-l+1); T[o &lt;&lt; 1 | 1] = tag[o] * (r-mid); tag[o] = -1; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x > y) return; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] = k, T[o] = k * (r-l+1), void(); int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = 0; pushdown(o, l, r); if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; bool P(int x) &#123; for (int i = 1; i &lt;= n; ++i) b[i] = (a[i] >= x ? 1 : 0); build(1, 1, n); for (int i = 1; i &lt;= m; ++i) &#123; int k = query(1, 1, n, l[i], r[i]); if (op[i] == 0) &#123; update(1, 1, n, l[i], r[i] - k, 0); update(1, 1, n, r[i] - k + 1, r[i], 1); &#125; else &#123; update(1, 1, n, l[i], l[i] + k - 1, 1); update(1, 1, n, l[i] + k, r[i], 0); &#125; &#125; return query(1, 1, n, q, q) == 1; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", op + i, l + i, r + i); scanf(\"%d\", &amp;q); int L = 0, R = n + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", L); return 0; &#125; [Luogu P5278] 算术天才⑨与等差数列 Portal. 发现条件非常严苛，因此可以考虑哈希之类的方法，这里不做赘述。 一段区间可以重排为等差数列，当且仅当满足（d=0d=0d=0 先特判掉）： max⁡−min⁡=d×(len−1)\\max -\\min =d\\times (len-1)max−min=d×(len−1)； gcd⁡i=lr−1(ai+1−ai)=d\\gcd_{i=l}^{r-1}(a_{i+1}-a_i)=dgcdi=lr−1​(ai+1​−ai​)=d； 序列中没有重复的元素。 用线段树维护即可。第三条可以使用 set、map 维护一个数最左边的出现位置，然后用线段树维护这个值的最小值，如果这个数小于 lll，那么一定没有重复元素。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int n, m; int a[300005], c[300005], pre[300005]; unordered_map&lt;int, set&lt;int>> mp; struct Node &#123; int mx, mn, mx_pre; friend Node operator+ (const Node &amp;a, const Node &amp;b) &#123; Node c; c.mx = max(a.mx, b.mx); c.mn = min(a.mn, b.mn); c.mx_pre = max(a.mx_pre, b.mx_pre); return c; &#125; &#125; T[1200005]; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].mx = T[o].mn = a[l]; T[o].mx_pre = pre[l]; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x) &#123; if (l == r) &#123; T[o].mx = T[o].mn = a[l]; T[o].mx_pre = pre[l]; return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; Node res = &#123;-1, INF, 0&#125;; if (x &lt;= mid) res = res + query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res = res + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; int tt[1200005]; void buildx(int o, int l, int r) &#123; if (l == r) return tt[o] = c[l], void(); int mid = l + r >> 1; buildx(o &lt;&lt; 1, l, mid); buildx(o &lt;&lt; 1 | 1, mid + 1, r); tt[o] = gcd(tt[o &lt;&lt; 1], tt[o &lt;&lt; 1 | 1]); &#125; void updatex(int o, int l, int r, int x) &#123; if (l == r) return tt[o] = c[x], void(); int mid = l + r >> 1; if (x &lt;= mid) updatex(o &lt;&lt; 1, l, mid, x); else updatex(o &lt;&lt; 1 | 1, mid + 1, r, x); tt[o] = gcd(tt[o &lt;&lt; 1], tt[o &lt;&lt; 1 | 1]); &#125; int queryx(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tt[o]; int mid = l + r >> 1, res = 0; if (x &lt;= mid) res = gcd(res, queryx(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = gcd(res, queryx(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; bool solve(int l, int r, int k) &#123; if (l == r) return true; Node t = query(1, 1, n, l, r); int g = queryx(1, 1, n - 1, l, r - 1); if (t.mx - t.mn != 1ll * k * (r - l)) return false; if (k &amp;&amp; t.mx_pre >= l) return false; if (g != k) return false; return true; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (mp[a[i]].empty()) pre[i] = -1; else &#123; auto it = mp[a[i]].end(); --it; pre[i] = *it; &#125; mp[a[i]].insert(i); &#125; for (int i = 1; i &lt; n; ++i) c[i] = abs(a[i + 1] - a[i]); build(1, 1, n); if (n - 1) buildx(1, 1, n - 1); int cnt = 0, op, x, y, k; while (m--) &#123; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); x ^= cnt; y ^= cnt; if (op == 1) &#123; auto it = mp[a[x]].find(x); ++it; if (it != mp[a[x]].end()) pre[*it] = pre[x], update(1, 1, n, *it); mp[a[x]].erase(x); a[x] = y; mp[a[x]].insert(x); it = mp[a[x]].upper_bound(x); if (it != mp[a[x]].end()) pre[*it] = x, update(1, 1, n, *it); --it; if (it != mp[a[x]].begin()) --it, pre[x] = *it; else pre[x] = -1; c[x] = abs(a[x + 1] - a[x]); c[x - 1] = abs(a[x] - a[x - 1]); update(1, 1, n, x); if (x &lt; n) updatex(1, 1, n - 1, x); if (x - 1) updatex(1, 1, n - 1, x - 1); &#125; else &#123; scanf(\"%d\", &amp;k); k ^= cnt; if (solve(x, y, k)) puts(\"Yes\"), ++cnt; else puts(\"No\"); &#125; &#125; return 0; &#125; [Luogu P6617] 查找 Search Portal. 定义一下两种关系： “补”表示与数 xxx 相加为 www。 “等”表示与数 xxx 相等。 记录每个数的补前驱，然后用线段树查询区间内补前驱的最大编号？当然可以，但是 1 5 5 5 5 5 这种修改 111 就可以直接炸掉：后面所有数的补前驱都将会变动。 令一个数的补前驱可以被记录，当且仅当它补前驱的位置在它等前驱右边，否则记录为 000。不难发现这样依次修改最多只会影响 555 个数：自身、原来 axa_xax​ 的补后驱和等后驱、yyy 的补后驱和等后驱。使用 set 加线段树维护即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, w; int a[500005], T[2000005], pre[2000005]; set&lt;int> s[500005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = pre[l], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o] = pre[l], void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int res = -1, mid = l + r >> 1; if (x &lt;= mid) res = max(res, query(o &lt;&lt; 1, l, mid, x, y)); if (mid &lt; y) res = max(res, query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res; &#125; void calc(int x, int y) &#123; // a[x] 改成 y，修改 x 的前驱 auto i = s[y].find(x); if (i != s[y].begin()) &#123; --i; // i 是 x 的等前驱 auto j = s[w - y].lower_bound(x); if (j == s[w - y].begin()) pre[x] = 0; else &#123; --j; // j 是 x 的补前驱 if (*j >= *i) pre[x] = *j; else pre[x] = 0; &#125; &#125; else &#123; // 没有等前驱 auto j = s[w - y].lower_bound(x); if (j == s[w - y].begin()) pre[x] = 0; else pre[x] = *(--j); &#125; update(1, 1, n, x); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;w); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (s[w - a[i]].size()) &#123; int it = *(--s[w - a[i]].end()); if (s[a[i]].empty() || it >= *(--s[a[i]].end())) pre[i] = it; &#125; s[a[i]].insert(i); &#125; build(1, 1, n); int cnt = 0; while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; auto k = s[a[x]].find(x); ++k; // k 为 a[x] 的等后驱 auto l = s[w - a[x]].upper_bound(x); // l 为 a[x] 的补后驱 s[a[x]].erase(x); s[y].insert(x); if (k != s[a[x]].end()) calc(*k, a[x]); if (l != s[w - a[x]].end()) calc(*l, w - a[x]); a[x] = y; k = s[a[x]].find(x); ++k; // k 为 y 的等后驱 l = s[w - a[x]].upper_bound(x); // l 为 y 的补后驱 if (k != s[a[x]].end()) calc(*k, a[x]); if (l != s[w - a[x]].end()) calc(*l, w - a[x]); calc(x, y); &#125; else &#123; x ^= cnt; y ^= cnt; if (query(1, 1, n, x, y) >= x) puts(\"Yes\"), ++cnt; else puts(\"No\"); &#125; &#125; return 0; &#125; [BJOI2019] 删数 Portal. 设 xxx 的出现次数为 ttt，那么其能覆盖 [x−t+1,x][x-t+1,x][x−t+1,x] 的区间。答案是 [1,n][1,n][1,n] 中未被覆盖的个数。这样单点修改只会让两个数的出现次数更改，区间平移可以看作询问区间的平移，每次的移动距离也只有 111。 线段树维护区间 000 的个数。由于有区间加的延迟标记，因此记录区间最小值和最小值的出现次数，可以在区间加的时候方便统计。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 450005; int n, m, P = 150001; int a[150005], buc[N + 5]; int tag[N * 4 + 5], mn[N * 4 + 5], cnt[N * 4 + 5], ans[N * 4 + 5]; inline void pushup(int o) &#123; mn[o] = min(mn[o &lt;&lt; 1], mn[o &lt;&lt; 1 | 1]); cnt[o] = (mn[o] == mn[o &lt;&lt; 1] ? cnt[o &lt;&lt; 1] : 0) + (mn[o] == mn[o &lt;&lt; 1 | 1] ? cnt[o &lt;&lt; 1 | 1] : 0); ans[o] = ans[o &lt;&lt; 1] + ans[o &lt;&lt; 1 | 1]; &#125; inline void maketag(int o, int k) &#123; mn[o] += k; ans[o] = (mn[o] == 0 ? cnt[o] : 0); tag[o] += k; &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = 0; &#125; void build(int o, int l, int r) &#123; if (l == r) return ans[o] = cnt[o] = 1, void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, k); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); pushup(o); &#125; int query(int o, int l, int r, int x, int y) &#123; // 查询 [x, y] 当中没有被覆盖的个数 if (x &lt;= l &amp;&amp; r &lt;= y) return ans[o]; pushdown(o); int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; void change(int x, int c) &#123; int k = x - buc[x] + 1 - (c > 0); update(1, 1, N, k, k, c); buc[x] += c; &#125; int main(void) &#123; // 询问区间为 [1 + P, n + P] scanf(\"%d%d\", &amp;n, &amp;m); build(1, 1, N); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), change(a[i] += P, 1); while (m--) &#123; int p, x; scanf(\"%d%d\", &amp;p, &amp;x); if (p > 0) &#123; // 单点修改 if (a[p] &lt;= n + P) change(a[p], -1); else --buc[a[p]]; a[p] = x + P; if (a[p] &lt;= n + P) change(a[p], 1); else ++buc[a[p]]; &#125; else &#123; if (x > 0) &#123; // 询问区间向左平移 int pos = n + P; if (buc[pos]) update(1, 1, N, pos - buc[pos] + 1, pos, -1); --P; &#125; else &#123; ++P; int pos = n + P; if (buc[pos]) update(1, 1, N, pos - buc[pos] + 1, pos, 1); &#125; &#125; printf(\"%d\\n\", query(1, 1, N, 1 + P, n + P)); &#125; return 0; &#125; [GDOI2014] 吃 Portal. 可以将 [1,l)∪(r,n][1,l)\\cup (r,n][1,l)∪(r,n] 拆开，因此一次询问就变成了在 [1,l),[l,r][1,l),[l,r][1,l),[l,r] 中各选一个数。 高效维护这个问题十分困难，发现值域很小，直接处理出所有数的因数再做考虑。离线，按照右端点升序排序。如果 preaipre_{a_i}preai​​ 存在，那么询问的 lll 在 (preai,i](pre_{a_i},i](preai​​,i] 的范围内出现时是可以更新到 aia_iai​ 的，一个区间修改单点查询的线段树就可以完成。时间复杂度为 O(nnlog⁡n)O(n\\sqrt{n}\\log n)O(nn​logn)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1e5; int n, m; int a[100005], pre[100005], nxt[100005]; vector&lt;int> b[100005]; struct Query &#123; int l, r, id; &#125; Q[100005]; int ans[100005]; int T[400005], tag[400005]; inline void maketag(int o, int k) &#123; T[o] = max(T[o], k); tag[o] = max(tag[o], k); &#125; inline void pushdown(int o) &#123; if (!tag[o]) return; maketag(o &lt;&lt; 1, tag[o]); maketag(o &lt;&lt; 1 | 1, tag[o]); tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, k); pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = max(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; int query(int o, int l, int r, int x) &#123; if (l == r) return T[o]; pushdown(o); int mid = l + r >> 1; if (x &lt;= mid) return query(o &lt;&lt; 1, l, mid, x); return query(o &lt;&lt; 1 | 1, mid + 1, r, x); &#125; int main(void) &#123; for (int i = 1; i &lt;= N; ++i) for (int j = i; j &lt;= N; j += i) b[j].emplace_back(i); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + m + 1, [&amp;](auto a, auto b) &#123; return a.r &lt; b.r; &#125;); for (int i = 1, j = 1; i &lt;= n; ++i) &#123; for (int x : b[a[i]]) &#123; if (pre[x]) update(1, 1, N, pre[x] + 1, i, x); // l 在这部分时可以有答案 pre[x] = i; &#125; while (j &lt;= m &amp;&amp; Q[j].r == i) &#123; ans[Q[j].id] = max(ans[Q[j].id], query(1, 1, N, Q[j].l)); ++j; &#125; &#125; memset(T, 0, sizeof T); memset(tag, 0, sizeof tag); sort(Q + 1, Q + m + 1, [&amp;](auto a, auto b) &#123; return a.l > b.l; &#125;); for (int i = n, j = 1; i >= 1; --i) &#123; for (int x : b[a[i]]) &#123; if (nxt[x]) update(1, 1, N, i, nxt[x] - 1, x); nxt[x] = i; &#125; while (j &lt;= m &amp;&amp; Q[j].l == i) &#123; ans[Q[j].id] = max(ans[Q[j].id], query(1, 1, N, Q[j].r)); ++j; &#125; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0; &#125; [CTT2012] 序列操作 Portal. 由于 ccc 很小，因此直接将答案记录在线段树内。 唯一困难的是区间加，发现它所增加的贡献并不直观。比如： [a1,⋯ai]→[a1+c,⋯ai+c][a_1,\\cdots a_i]\\rightarrow [a_1+c,\\cdots a_i+c] [a1​,⋯ai​]→[a1​+c,⋯ai​+c] 然后把他们乘起来，并展开，可以发现其实有规律的： fi←(len−i0)×c0×fi+(len−(i−1)1)×c1×fi−1+⋯f_i\\leftarrow \\binom{len-i}{0}\\times c^0 \\times f_i+\\binom{len-(i-1)}{1}\\times c^1 \\times f_{i-1}+\\cdots fi​←(0len−i​)×c0×fi​+(1len−(i−1)​)×c1×fi−1​+⋯ 这个东西可以线性计算，那么整体就是好维护的了。 查看代码 #include &lt;bits/stdc++.h> #define REV 2000000000 using namespace std; const int P = 19940417; int n, q, C[50005][25]; int a[50005]; int addv[200005]; bool rev[200005]; struct Node &#123; int c[21]; friend Node operator+ (const Node &amp;a, const Node &amp;b) &#123; Node c; memset(c.c, 0, sizeof c.c); for (int i = 0; i &lt;= 20; ++i) for (int j = 0; i + j &lt;= 20; ++j) c.c[i + j] = (c.c[i + j] + 1ll * a.c[i] * b.c[j]) % P; return c; &#125; &#125; T[200005]; void build(int o, int l, int r) &#123; if (l == r) return T[o].c[0] = 1, T[o].c[1] = a[l] % P, void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int tmp[21]; inline void maketag(int o, int l, int r, int k) &#123; if (k == REV) &#123; rev[o] ^= 1; addv[o] = P - addv[o]; for (int i = 1; i &lt;= 20; ++i) if (i &amp; 1) T[o].c[i] = P - T[o].c[i]; return; &#125; addv[o] = (addv[o] + k) % P; for (int i = tmp[0] = 1; i &lt;= 20; ++i) tmp[i] = 1ll * tmp[i - 1] * k % P; for (int i = min(r - l + 1, 20); i; --i) for (int j = 0; j &lt; i; ++j) T[o].c[i] = (T[o].c[i] + 1ll * T[o].c[j] * tmp[i - j] % P * C[r - l + 1 - j][i - j]) % P; &#125; inline void pushdown(int o, int l, int r) &#123; int mid = l + r >> 1; if (rev[o]) &#123; maketag(o &lt;&lt; 1, l, mid, REV); maketag(o &lt;&lt; 1 | 1, mid + 1, r, REV); rev[o] = 0; &#125; if (addv[o]) &#123; maketag(o &lt;&lt; 1, l, mid, addv[o]); maketag(o &lt;&lt; 1 | 1, mid + 1, r, addv[o]); addv[o] = 0; &#125; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return maketag(o, l, r, k); pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; pushdown(o, l, r); int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return query(o &lt;&lt; 1, l, mid, x, y) + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 0; i &lt;= n; ++i) for (int j = C[i][0] = 1; j &lt;= min(i, 20); ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); char op[5]; int l, r, k; while (q--) &#123; scanf(\"%s%d%d\", op, &amp;l, &amp;r); if (op[0] != 'R') scanf(\"%d\", &amp;k); if (op[0] == 'I') update(1, 1, n, l, r, k); else if (op[0] == 'R') update(1, 1, n, l, r, REV); else printf(\"%d\\n\", (query(1, 1, n, l, r).c[k] % P + P) % P); &#125; return 0; &#125; [Ynoi2015] 纵使日薄西山 Portal.珂朵莉想让你维护一个长度为 nnn 的正整数序列 a1,a2,…,ana_1,a_2,\\ldots,a_na1​,a2​,…,an​，支持修改序列中某个位置的值。每次修改后问对序列重复进行以下操作，需要进行几次操作才能使序列变为全 000（询问后序列和询问前相同，不会变为全 000）：选出序列中最大值的出现位置，若有多个最大值则选位置标号最小的一个，设位置为 xxx，则将 ax−1,ax,ax+1a_{x-1},a_x,a_{x+1}ax−1​,ax​,ax+1​ 的值减 111，如果序列中存在小于 000 的数，则把对应的数改为 000。1≤n,q≤1051\\leq n,q\\leq 10^51≤n,q≤105，1≤xi≤n1\\leq x_i\\leq n1≤xi​≤n，1≤ai,yi≤1091\\leq a_i,y_i\\leq 10^91≤ai​,yi​≤109。 考虑哪些数可以被减。如果我们开始减 aia_iai​，那么它一定会一直减下去（因为左右两个永远都比它小）。 将原序列进行单调极长划分，发现对于每个极长单调区间，答案一定是所有奇数位置或者所有偶数位置的和。使用一个 set 存储所有的极长单调区间分割点（称为极值点，令一个极值点代表极长单调区间的结束），修改一个数时最多只会影响到五个极值点（修改一个极值点可能使它右边的极值点不存在，进而影响右边第二个极值点，左边同理），复杂度可以接受。 根据此维护即可，细节很多。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, a[100005]; i64 ans; set&lt;int> s; struct Fenwick &#123; #define lowbit(x) (x &amp; -x) i64 C[100005]; void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; i64 sum(int x) &#123; i64 res = 0; for (; x; x -= lowbit(x)) res += C[x]; return res; &#125; &#125; T[2]; void calc(set&lt;int>::iterator l, set&lt;int>::iterator r, int op) &#123; for (; l != r; --r) &#123; auto it = r; --it; if (a[*r] > a[*it]) &#123; // 当前极长单调区间不受前一个影响 int p = *r &amp; 1; ans += (T[p].sum(*r) - T[p].sum(*it)) * op; &#125; else &#123; int p = *it &amp; 1; ans += (T[p].sum(*r - 1) - T[p].sum(*it)) * op; // 要看 r 这个位置有没有被修改 auto lt = r, rt = r; if (lt != s.begin()) --lt; ++rt; if (rt == s.end()) --rt; // 没有被 it 修改，没有被后面一个极长单调子区间修改 if ((*r - *lt) % 2 == 0 &amp;&amp; (*rt - *r) % 2 == 0) ans += a[*r] * op; &#125; &#125; if (a[*l] >= a[*l + 1]) return; // 此时 l 自己修改自己 auto lt = r, rt = r; if (lt != s.begin()) --lt; ++rt; if (rt == s.end()) --rt; if ((*r - *lt) % 2 == 0 &amp;&amp; (*rt - *r) % 2 == 0) ans += a[*r] * op; &#125; void check(int x) &#123; if ((a[x - 1] &lt; a[x]) == (a[x] &lt; a[x + 1])) s.erase(x); else s.insert(x); &#125; void update(int x, int y) &#123; auto it = s.lower_bound(x), l = it, r = it; --l; if (l != s.begin()) --l; ++r; if (r != s.end()) ++r; if (r == s.end()) --r; calc(l, r, -1); T[x &amp; 1].add(x, y - a[x]); a[x] = y; check(x); if (x > 1) check(x - 1); if (x &lt; n) check(x + 1); calc(l, r, 1); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); s.insert(0); s.insert(n + 1); for (int i = 1, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), update(i, x); scanf(\"%d\", &amp;m); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); update(x, y); printf(\"%lld\\n\", ans); &#125; return 0; &#125; [Code+#1] Yazid 的新生舞会 Portal.给定一个长度为 n(n≤5×105)n(n\\le 5\\times 10^5)n(n≤5×105) 的序列，问其中有多少个子区间存在出现次数严格超过子区间长度一半的众数。 考虑枚举每个种类的数分别计算，设当前选中的数为 www，SiS_iSi​ 为前 iii 个数中 www 的个数。 对于一段区间 [l+1,r][l+1,r][l+1,r]（方便差分），满足条件时有 Sr−Sl&gt;r−l−(Sr−Sl)→2Sr−r&gt;2Sl−lS_r-S_l&gt;r-l-(S_r-S_l)\\rightarrow 2S_r-r&gt;2S_l-lSr​−Sl​&gt;r−l−(Sr​−Sl​)→2Sr​−r&gt;2Sl​−l，也就是在求 Pi=2Si−iP_i=2S_i-iPi​=2Si​−i 的逆序对个数。 对于同一个 www，PiP_iPi​ 可以划分成若干个单调递减区间，总数在 O(n)O(n)O(n) 级别。同一个区间内是没有贡献的，只需要计算 lll 在前面区间内的贡献。 设 cic_ici​ 代表 iii 在 PPP 中的出现次数（由于可能有负的，所以需要加上一个偏移量），TTT 表示 cic_ici​ 的前缀和，那么每一个 PiP_iPi​ 的贡献就是当前的 TPi−1T_{P_i-1}TPi​−1​。对于一段 [x,y][x,y][x,y]，总贡献就是 ∑i=x−1y−1Ti\\sum\\limits_{i=x-1}^{y-1}T_ii=x−1∑y−1​Ti​，再求一个 TTT 的前缀和 GGG 即可。 这个东西可以使用树状数组维护，先将 ccc 差分得到数组 ddd（因为对于 ccc 要进行区间修改），然后： Gx=∑i=1xTi=∑i=1x∑j=1icj=∑i=1x∑j=1i∑k=1jdk=∑i=1x(x+2−i)(x+1−i)2di\\begin{aligned} G_x&amp;=\\sum_{i=1}^{x} T_i\\\\ &amp;=\\sum_{i=1}^{x}\\sum_{j=1}^{i}c_j\\\\ &amp;=\\sum_{i=1}^{x}\\sum_{j=1}^{i}\\sum_{k=1}^j d_k\\\\ &amp;=\\sum_{i=1}^x \\frac{(x+2-i)(x+1-i)}{2} d_i \\end{aligned} Gx​​=i=1∑x​Ti​=i=1∑x​j=1∑i​cj​=i=1∑x​j=1∑i​k=1∑j​dk​=i=1∑x​2(x+2−i)(x+1−i)​di​​ 就可以使用三个树状数组维护了。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; int n, type; int a[500005]; vector&lt;int> b[500005]; i64 C1[1000005], C2[1000005], C3[1000005]; i64 sum(int x) &#123; i64 res = 0; for (int i = x; i > 0; i -= lowbit(i)) res += C1[i] * (x + 2) * (x + 1) - C2[i] * (2 * x + 3) + C3[i]; return res; &#125; void add(int x, i64 k) &#123; for (int i = x; i &lt;= 2 * n + 1; i += lowbit(i)) C1[i] += k, C2[i] += k * x, C3[i] += k * x * x; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;type); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[a[i]].emplace_back(i); i64 ans = 0; const int N = n + 1; for (int i = 0; i &lt; n; ++i) &#123; b[i].emplace_back(n + 1); int last = 0; for (int j = 0; j &lt; b[i].size(); ++j) &#123; int x = 2 * j - (b[i][j] - 1) + N, y = 2 * j - last + N; ans += sum(y - 1) - sum(x - 2); add(x, 1); add(y + 1, -1); last = b[i][j]; &#125; last = 0; for (int j = 0; j &lt; b[i].size(); ++j) &#123; int x = 2 * j - (b[i][j] - 1) + N, y = 2 * j - last + N; add(x, -1); add(y + 1, 1); last = b[i][j]; &#125; &#125; printf(\"%lld\\n\", ans >> 1); return 0; &#125; [RC-03] 记忆 Portal. 考虑使用动态规划解决这个问题的静态版本，一操作会导致 ansansans 增大 cnt+1cnt+1cnt+1，cntcntcnt 增大 111。二操作会导致 ansansans 增大 111，cntcntcnt 清零。转移可以使用矩阵刻画，线段树维护时间轴即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct Matrix &#123; i64 a[3][3]; Matrix() &#123; memset(a, 0, sizeof a); &#125; friend Matrix operator* (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 3; ++i) for (int k = 0; k &lt; 3; ++k) &#123; i64 r = a.a[i][k]; for (int j = 0; j &lt; 3; ++j) c.a[i][j] += r * b.a[k][j]; &#125; return c; &#125; &#125; T[800005], A, B, C; void update(int o, int l, int r, int x, int k) &#123; if (l == r) return T[o] = (k == 1 ? A : (k == 2 ? B : C)), void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o] = T[o &lt;&lt; 1] * T[o &lt;&lt; 1 | 1]; &#125; int n; int op[200005], p[200005]; bool tag[200005]; int main(void) &#123; A.a[0][0] = A.a[1][0] = A.a[1][1] = A.a[2][0] = A.a[2][1] = A.a[2][2] = 1; B.a[0][0] = B.a[2][0] = B.a[2][1] = B.a[2][2] = 1; C.a[0][0] = C.a[1][1] = C.a[2][2] = 1; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n * 4; ++i) T[i] = C; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", op + i); if (op[i] != 3) p[i] = i; else scanf(\"%d\", p + i); if (op[i] == 1) update(1, 1, n, i, 1); else if (op[i] == 2) update(1, 1, n, i, 2); else &#123; p[i] = p[p[i]]; if (tag[p[i]]) tag[p[i]] = 0, update(1, 1, n, p[i], op[p[i]]); else tag[p[i]] = 1, update(1, 1, n, p[i], 3); &#125; Matrix tmp; tmp.a[0][0] = tmp.a[0][1] = tmp.a[0][2] = 1; printf(\"%lld\\n\", (tmp * T[1]).a[0][0]); &#125; return 0; &#125; [省选联考 2020 A/B 卷] 冰火战士 Portal. 将温度离散化，那么求的就是冰人前缀和（IpI_pIp​）和火人后缀和（前缀和记为 FpF_pFp​）的最小值最大为多少。由于能力值不为负，因此只需要求出 Ip≤Fsum−Fp−1I_p\\le F_{sum}-F_{p-1}Ip​≤Fsum​−Fp−1​ 的最大 ppp 和 Ip≥Fsum−Fp−1I_p\\ge F_{sum}-F_{p-1}Ip​≥Fsum​−Fp−1​ 的最大 ppp（但是 Fp−1F_{p-1}Fp−1​ 最小）。 前者好搞，但是后者怎么求？考虑将 FFF 平移一位，条件一变成 Ip≤Fsum−FpI_p\\le F_{sum}-F_{p}Ip​≤Fsum​−Fp​，条件二变成 Ip≥Fsum−FpI_p\\ge F_{sum}-F_{p}Ip​≥Fsum​−Fp​。当求出前面的 ppp 后，取 p←p+1p\\leftarrow p+1p←p+1，那么此时 ppp 就是满足条件二的最小 ppp，然后再次倍增出最大的 ppp 即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 2e6 + 5; int Q, n, b[N]; int op[N], t[N], x[N], y[N]; int ice[N], fire[N], FS; void add(int x, int k, int *c) &#123; while (x &lt;= n) c[x] += k, x += x &amp; -x; &#125; int main(void) &#123; scanf(\"%d\", &amp;Q); int tot = 0; for (int i = 1; i &lt;= Q; ++i) &#123; scanf(\"%d\", op + i); if (op[i] == 1) scanf(\"%d%d%d\", t + i, x + i, y + i), b[++tot] = x[i]; else scanf(\"%d\", t + i); &#125; sort(b + 1, b + tot + 1); n = unique(b + 1, b + tot + 1) - (b + 1); for (int i = 1; i &lt;= Q; ++i) x[i] = lower_bound(b + 1, b + n + 1, x[i]) - b; for (int i = 1; i &lt;= Q; ++i) &#123; if (op[i] == 2) x[i] = x[t[i]], y[i] = -y[t[i]], t[i] = t[t[i]]; if (t[i] == 0) add(x[i], y[i], ice); else add(x[i] + 1, y[i], fire), FS += y[i]; int I = 0, F = 0, p = 0; for (int j = 20; j >= 0; --j) &#123; p ^= 1 &lt;&lt; j; if (p > n || I + ice[p] > FS - F - fire[p]) p ^= 1 &lt;&lt; j; else I += ice[p], F += fire[p]; &#125; int tot = I; if (p &lt; n) &#123; int x = p + 1, _F = 0; for (; x; x -= x &amp; -x) _F += fire[x]; if (I &lt;= FS - _F) &#123; p = F = 0; tot = FS - _F; for (int j = 20; j >= 0; --j) &#123; p ^= 1 &lt;&lt; j; if (p > n || F + fire[p] > _F) p ^= 1 &lt;&lt; j; else F += fire[p]; &#125; &#125; &#125; if (tot) printf(\"%d %d\\n\", b[p], tot * 2); else puts(\"Peace\"); &#125; return 0; &#125; [CF187D] BRT Contract Portal. 如果等了一个灯那么后面就都是一样的了，这个因此问题是如何找到第一个等的灯。 从开始到位置 iii 的距离模 m=(g+r)m=(g+r)m=(g+r) 的余数为 ppp，出发时间为 ttt，如果 g≤(t+p) mod (g+r)g\\le (t+p)\\bmod (g+r)g≤(t+p)mod(g+r) 就需要等这个红灯。如果要等红灯，ttt 的取值有两种情况： p≤g:t∈[g−p,g+r−p−1]p&gt;g:t∈[0,g+r−p−1]∪[m−p+g,m−1]p\\le g: t\\in [g-p,g+r-p-1]\\\\ p&gt;g: t\\in [0,g+r-p-1]\\cup [m-p+g,m-1] p≤g:t∈[g−p,g+r−p−1]p&gt;g:t∈[0,g+r−p−1]∪[m−p+g,m−1] 那么搞一个区间染色单点查询的动态开点线段树就行。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct Node &#123; int ls, rs; int val; &#125; T[20000005]; int n, g, r, m, q, tot = 1, rt; i64 d[100005], f[100005]; inline void pushdown(int o, int l, int r) &#123; if (r - l + 1 > 1 &amp;&amp; T[o].val) &#123; if (!T[o].ls) T[o].ls = ++tot; if (!T[o].rs) T[o].rs = ++tot; T[T[o].ls].val = T[T[o].rs].val = T[o].val; T[o].val = 0; &#125; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; pushdown(o, l, r); if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].val = k, void(); int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, l, mid, x, y, k); if (mid &lt; y) update(T[o].rs, mid + 1, r, x, y, k); &#125; int query(int o, int l, int r, int x) &#123; pushdown(o, l, r); if (l == r) return T[o].val; int mid = l + r >> 1; if (x &lt;= mid) return query(T[o].ls, l, mid, x); return query(T[o].rs, mid + 1, r, x); &#125; inline i64 query(int t) &#123; int p = query(rt, 0, m - 1, t % m); i64 ans = t + f[p] + d[p]; if (p &lt;= n) ans += m - (d[p] + t) % m; return ans; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;g, &amp;r); m = g + r; for (int i = 1; i &lt;= n + 1; ++i) scanf(\"%lld\", d + i), d[i] += d[i - 1]; update(rt, 0, m - 1, 0, m - 1, n + 1); for (int i = n; i >= 1; --i) &#123; int p = m - d[i] % m; f[i] = query(p) - d[i] - p; p = d[i] % m; if (p &lt;= g) update(rt, 0, m - 1, g - p, g + r - p - 1, i); else update(rt, 0, m - 1, 0, g + r - p - 1, i), update(rt, 0, m - 1, m - p + g, m - 1, i); &#125; for (scanf(\"%d\", &amp;q); q--; ) &#123; int t; scanf(\"%d\", &amp;t); printf(\"%lld\\n\", query(t)); &#125; return 0; &#125; 线段树分裂与合并 几乎都是合并的题。 [POI2011] ROT-Tree Rotations Portal. 直接 dfs 遍历这棵树，用线段树维护权值。交换左右子树只会对跨越这两棵子树的逆序对产生影响，统计这个就只剩线段树合并了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 200000; int n; i64 ans, u, v; struct Node &#123; int ls, rs; int siz; &#125; T[22 * N]; int tot; void update(int &amp;o, int l, int r, int x) &#123; if (!o) o = ++tot; T[o].siz += 1; if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, l, mid, x); else update(T[o].rs, mid + 1, r, x); return; &#125; int merge(int p, int q, int l, int r) &#123; if (!p || !q) return p + q; if (l == r) return T[p].siz += T[q].siz, p; int mid = l + r >> 1; u += 1ll * T[T[p].rs].siz * T[T[q].ls].siz; v += 1ll * T[T[p].ls].siz * T[T[q].rs].siz; T[p].ls = merge(T[p].ls, T[q].ls, l, mid); T[p].rs = merge(T[p].rs, T[q].rs, mid + 1, r); T[p].siz = T[T[p].ls].siz + T[T[p].rs].siz; return p; &#125; int dfs(void) &#123; int pos = 0, val; scanf(\"%d\", &amp;val); if (!val) &#123; int ls = dfs(), rs = dfs(); u = v = 0; pos = merge(ls, rs, 1, n); ans += min(u, v); &#125; else update(pos, 1, n, val); return pos; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); dfs(); printf(\"%lld\\n\", ans); return 0; &#125; [湖南集训] 更为厉害 Portal. 如果 aaa 是 bbb 的祖先，那么可以随便选。否则只能选 bbb 子树内的 ccc（而且不能选 bbb），线段树合并预处理出每棵子树以深度为值域的值域线段树。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, dep[300005], siz[300005]; vector&lt;int> G[300005]; struct Node &#123; int ls, rs; i64 val; &#125; T[9000005]; int tot, root[300005]; void update(int &amp;o, int l, int r, int x, int k) &#123; if (!o) o = ++tot; T[o].val += k; if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(T[o].ls, l, mid, x, k); else update(T[o].rs, mid + 1, r, x, k); &#125; i64 query(int o, int l, int r, int x, int y) &#123; if (!o) return 0; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o].val; int mid = l + r >> 1; i64 res = 0; if (x &lt;= mid) res += query(T[o].ls, l, mid, x, y); if (mid &lt; y) res += query(T[o].rs, mid + 1, r, x, y); return res; &#125; int merge(int p, int q, int l, int r) &#123; if (p == 0 || q == 0) return p + q; int mid = l + r >> 1, o = ++tot; T[o].ls = merge(T[p].ls, T[q].ls, l, mid); T[o].rs = merge(T[p].rs, T[q].rs, mid + 1, r); T[o].val = T[p].val + T[q].val; return o; &#125; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; siz[x] = 1; for (int y : G[x]) if (y != fa) dfs(y, x), siz[x] += siz[y]; update(root[x], 1, n, dep[x], siz[x] - 1); if (fa) root[fa] = merge(root[fa], root[x], 1, n); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); while (m--) &#123; int x, k; scanf(\"%d%d\", &amp;x, &amp;k); printf(\"%lld\\n\", query(root[x], 1, n, dep[x] + 1, dep[x] + k) + 1ll * min(k, dep[x] - 1) * (siz[x] - 1)); &#125; return 0; &#125; [NOI2020] 命运 Portal. 考虑设 fx,yf_{x,y}fx,y​ 代表以 xxx 为根的子树中已经全部满足，不满足的距离最多为 yyy（从根节点向下开始）的方案数，答案为 f1,0f_{1,0}f1,0​。 考虑每次将 (x,y)(x,y)(x,y) 合并进当前答案，分别考虑这条边填 1/01/01/0 的贡献： fx,i′←∑j=0depxfx,ify,j+∑j=0ifx,ify,j+∑j=0i−1fx,jfy,if&#x27;_{x,i} \\leftarrow \\sum_{j=0}^{dep_x} f_{x,i}f_{y,j}+\\sum_{j=0}^{i} f_{x,i}f_{y,j}+\\sum_{j=0}^{i-1} f_{x,j}f_{y,i} fx,i′​←j=0∑depx​​fx,i​fy,j​+j=0∑i​fx,i​fy,j​+j=0∑i−1​fx,j​fy,i​ 设 gx,y=∑i=0yfx,ig_{x,y}=\\sum_{i=0}^y f_{x,i}gx,y​=∑i=0y​fx,i​，则： fx,i′=fx,i(gy,depx+gy,i)+fy,igx,i−1f&#x27;_{x,i}=f_{x,i}(g_{y,dep_x}+g_{y,i})+f_{y,i}g_{x,i-1} fx,i′​=fx,i​(gy,depx​​+gy,i​)+fy,i​gx,i−1​ 所有的转移位置都只与深度有关，因此直接线段树合并，维护区间乘法的修改。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int n, q; vector&lt;int> G[500005], p[500005]; int dep[500005]; int f[5005][5005], g[5005][5005]; struct Node &#123; int ls, rs; int dat, tag; #define ls(x) T[x].ls #define rs(x) T[x].rs #define dat(x) T[x].dat #define tag(x) T[x].tag &#125; T[10000005]; int tot, rt[2000005]; void update(int &amp;o, int l, int r, int x) &#123; o = ++tot; dat(o) = tag(o) = 1; if (l == r) return; int mid = l + r >> 1; if (x &lt;= mid) update(ls(o), l, mid, x); else update(rs(o), mid + 1, r, x); &#125; inline void pushdown(int o) &#123; if (ls(o)) &#123; dat(ls(o)) = 1ll * dat(ls(o)) * tag(o) % P; tag(ls(o)) = 1ll * tag(ls(o)) * tag(o) % P; &#125; if (rs(o)) &#123; dat(rs(o)) = 1ll * dat(rs(o)) * tag(o) % P; tag(rs(o)) = 1ll * tag(rs(o)) * tag(o) % P; &#125; tag(o) = 1; &#125; int query(int o, int l, int r, int x) &#123; if (!o || r &lt;= x) return dat(o); pushdown(o); int mid = l + r >> 1, ans = query(ls(o), l, mid, x); if (mid &lt; x) ans = (ans + query(rs(o), mid + 1, r, x)) % P; return ans; &#125; int merge(int x, int y, int l, int r, int &amp;s1, int &amp;s2) &#123; // s1 为 g(y, i)，s2 为 g(x, i-1) if (!x &amp;&amp; !y) return 0; if (!x || !y) &#123; if (!x) &#123; s1 = (s1 + dat(y)) % P; dat(y) = 1ll * dat(y) * s2 % P; tag(y) = 1ll * tag(y) * s2 % P; return y; &#125; s2 = (s2 + dat(x)) % P; dat(x) = 1ll * dat(x) * s1 % P; tag(x) = 1ll * tag(x) * s1 % P; return x; &#125; if (l == r) &#123; int tmp = dat(x); s1 = (s1 + dat(y)) % P; dat(x) = (1ll * dat(x) * s1 + 1ll * dat(y) * s2) % P; s2 = (s2 + tmp) % P; return x; &#125; pushdown(x); pushdown(y); int mid = l + r >> 1; ls(x) = merge(ls(x), ls(y), l, mid, s1, s2); rs(x) = merge(rs(x), rs(y), mid + 1, r, s1, s2); dat(x) = (dat(ls(x)) + dat(rs(x))) % P; return x; &#125; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; int mx = 0; for (int i : p[x]) mx = max(mx, dep[i]); update(rt[x], 0, n, mx); for (int y : G[x]) if (y != fa) &#123; dfs(y, x); int s1 = query(rt[y], 0, n, dep[x]), s2 = 0; rt[x] = merge(rt[x], rt[y], 0, n, s1, s2); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].emplace_back(y); G[y].emplace_back(x); &#125; scanf(\"%d\", &amp;q); while (q--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); p[y].emplace_back(x); &#125; dfs(1, 0); return !printf(\"%d\\n\", query(rt[1], 0, n, 0)); &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"算法竞赛/学习笔记/数据结构","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"复杂结构上的 DP 问题","slug":"notes/DP/graph-dp","date":"2022-11-05T00:00:00.000Z","updated":"2023-10-30T00:00:00.000Z","comments":true,"path":"c2587cc4/","link":"","permalink":"https://james1badcreeper.github.io/c2587cc4/","excerpt":"之前的 DP 都是在线性结构上进行的，实际上 DP 还可以在树上或者 DAG 上进行。本文将对这些内容进行简单的介绍。","text":"之前的 DP 都是在线性结构上进行的，实际上 DP 还可以在树上或者 DAG 上进行。本文将对这些内容进行简单的介绍。 更新日志 2023/10/30更新了少许杂题。 树形 DP 树形 DP 就是将在线性结构上的 DP 变到了树上。 概念 既然 DP 都长到树上去了，那么肯定有不一样的地方。 由于树固有的递归性质，树形 DP 一般都是递归进行的。在树形 DP 中，我们会选根节点为 DP 的开始，然后对于它的每棵子树进行递归，然后考虑转移。递归到了一个叶子节点，就可以进行初始化了。 基础例题 之所以大多数教程都直接上题，是因为这玩意没法讲！ 之前说了树形 DP 就是在树上进行 DP，就是把状态的转移移到了树上。但这么说没人能听得懂，所以我们只能通过题目来学习，那么就来吧。 [Luogu P1352] 没有上司的舞会 Portal. 某大学有 nnn 个职员，编号为 1…n1\\ldots n1…n。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 rir_iri​,但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。计算邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 根据刚才的讲解和在线性 DP 中的经验，我们可以设 f[x]f[x]f[x] 为 xxx 的子树的最大的快乐指数。 但这样不行，我们需要知道 xxx 是否参加舞会，来判断 xxx 的上司是否能参加舞会。 那么根据在线性 DP 中讲过的“打不过就加入”，我们可以设 f[x][0]f[x][0]f[x][0] 为 xxx 不参加舞会，f[x][1]f[x][1]f[x][1] 为 xxx 参加舞会。 那么根据题意，便有转移： f[x][0]=∑s∈son[x]max⁡(f[x][0],f[x][1])f[x][0] = \\sum\\limits_{s\\in son[x]}\\max(f[x][0], f[x][1]) f[x][0]=s∈son[x]∑​max(f[x][0],f[x][1]) f[x][1]=r[x]+∑s∈son[x]f[x][0]f[x][1] = r[x] + \\sum\\limits_{s\\in son[x]}f[x][0] f[x][1]=r[x]+s∈son[x]∑​f[x][0] 那么代码就很容易写出来了： 查看代码 #include &lt;bits/stdc++.h> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; int n; int r[6005]; bool v[6005]; vector &lt;int> son[6005]; int f[6005][2]; void dp(int o) &#123; f[o][0] = 0; // 不参加，初始为 0 f[o][1] = r[o]; // 参加，初始为 r[o] for (int i = 0; i &lt; son[o].size(); ++i) // 遍历所有子树 &#123; int y = son[o][i]; dp(y); // 递归进行 f[o][0] += max(f[y][0], f[y][1]); // 可以参加或不参加 f[o][1] += f[y][0]; // 只能不参加 &#125; &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) r[i] = read(); for (int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); v[x] = 1; son[y].push_back(x); &#125; int root; for (int i = 1; i &lt;= n; ++i) if (!v[i]) &#123; root = i; // 寻找根节点开始 DP break; &#125; dp(root); cout &lt;&lt; max(f[root][0], f[root][1]) &lt;&lt; endl; // 要取最大值 return 0; &#125; 状态有 O(n)O(n)O(n) 个，每个状态在转移时都会被考虑一次，因此时间复杂度为 O(n)O(n)O(n)。 树形 DP 还有另一种实现方式：以拓扑序自底向上迭代，速度比上述递归方法快一点，但实用性不高。感兴趣的读者可以自行了解。 [Luogu P2016] 战略游戏 Portal. n(n≤1500)n(n\\le 1500)n(n≤1500) 的树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。 这道题和上道很相似，但可以注意到这是一棵无根树。而想要做树形 DP，就必须有根。 那怎么办呢？转成有根树就行了。随便找一个结点作根，代码如下： for (int i = 0; i &lt; n; ++i) &#123; int o = read(), k = read(); for (int j = 0; j &lt; k; ++j) &#123; int t = read(); G[o].push_back(t); G[t].push_back(o); &#125; &#125; v[0] = -1; dfs(0); 这里的 vvv 数组代表 v[o]v[o]v[o] 的父亲。dfs(o) 代表遍历节点 ooo。 dfs 的过程如下： void dfs(int o) &#123; done[o] = 1; for (int i = 0; i &lt; G[o].size(); ++i) &#123; if (done[G[o][i]] == 0) &#123; son[o].push_back(G[o][i]); v[G[o][i]] = o; dfs(G[o][i]); &#125; &#125; &#125; 这里用了一个 done 数组来防止重复遍历，还有一种方式如下： void dfs(int o, int fa) &#123; for (int i = 0; i &lt; G[o].size(); ++i) if (G[o][i] != fa) &#123; son[o].push_back(G[o][i]); dfs(G[o][i], o); &#125; &#125; 为什么可以这样做呢？因为加的是无向边，来回遍历时才会造成重复遍历。 我们设 f(i,0)f(i,0)f(i,0) 代表在 iii 的位置上不放士兵，f(i,1)f(i,1)f(i,1) 代表在 iii 的位置上放士兵，它们的子树所需要的最少士兵。 那么完整代码就很容易写出来了： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int f[1505][2]; bool done[1505]; vector &lt;int> son[1505]; vector &lt;int> G[1505]; void dfs(int o, int fa) &#123; done[o] = 1; for (int i = 0; i &lt; G[o].size(); ++i) if (done[G[o][i]] == 0) &#123; son[o].push_back(G[o][i]); dfs(G[o][i], o); &#125; &#125; void dp(int o) &#123; f[o][0] = 0; f[o][1] = 1; for (int i = 0; i &lt; son[o].size(); ++i) &#123; int y = son[o][i]; dp(y); f[o][0] += f[y][1]; // 必须放 f[o][1] += min(f[y][0], f[y][1]); // 可放可不放 &#125; &#125; int main(void) &#123; n = read(); for (int i = 0; i &lt; n; ++i) &#123; int o = read(), k = read(); for (int j = 0; j &lt; k; ++j) &#123; int t = read(); G[o].push_back(t); G[t].push_back(o); &#125; &#125; dfs(0, -1); dp(0); cout &lt;&lt; min(f[0][0], f[0][1]) &lt;&lt; endl; return 0; &#125; [Luogu P1122] 最大子树和 Portal. 这跟上一题很相似，但是我们可以不建树，直接在 DP 的时候判断是否来自 fa 即可。求最大子树和，只需要将正的子树加上即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n; int a[16005], f[16005]; vector &lt;int> G[16005]; void dp(int o, int fa) &#123; f[o] = a[o]; for (int i = 0; i &lt; G[o].size(); ++i) &#123; int y = G[o][i]; if (y == fa) continue; dp(y, o); if (f[y] > 0) f[o] += f[y]; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1, 0); int ans = -2e9; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; 关于树形 DP 有一个问题：为什么我们可以随便选一个点作为根节点进行 DP 呢？这是因为在考虑子树的过程中，如果一个以 root 节点为根的答案会更好，它要么相当于一棵子树，要么相当于它的一个孙辈的子树。 当然也有例外，我们很快就会见到。 [ZJOI2007] 时态同步 Portal. n(n≤105)n(n\\le 10^5)n(n≤105) 个点的有根树，有边权，一次操作可以将某条边的边权 +1+1+1。求最少使用多少次操作，可以让所有叶子结点到根的距离相同。 很容易想到一个贪心做法：优先调整靠上的边。为什么？因为与其在叶子节点的边权都 +1+1+1，不如直接在父亲节点的边 +1+1+1。这样，一个节点只需要调整它的子树，保证它的子树边权相同即可，剩下的交给它的父亲。 那我们记 f(x)f(x)f(x) 为调整好 xxx 的子树的最少操作数。但是想要成功计算，我们还需要知道节点到叶子节点的距离，所以我们记 g(x)g(x)g(x) 为调整后 xxx 到它的最底层的叶子节点的距离。 转移也不难。很容易得出 g(x)g(x)g(x) 的转移： g(x)=max⁡y∈son(x){g[y]+wx,y}g(x)=\\max\\limits_{y\\in son(x)}\\left\\{g[y]+w_{x,y}\\right\\} g(x)=y∈son(x)max​{g[y]+wx,y​} f(x)f(x)f(x) 怎么转？像这样： f(x)=∑y∈son(x)(f(y)+(g(x)−g(y)−wx,y))f(x)=\\sum\\limits_{y\\in son(x)}(f(y)+(g(x)-g(y)-w_{x,y})) f(x)=y∈son(x)∑​(f(y)+(g(x)−g(y)−wx,y​)) 什么意思？首先肯定要加上调整所有子树的代价，然后要开始调整这些子树。代价是多少？显然是 g(x)−g(y)−wx,yg(x)-g(y)-w_{x,y}g(x)−g(y)−wx,y​，也就是当前的深度剪去叶子节点的深度再减去这条边的长度。 代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define pii pair&lt;int, int> #define Y first #define W second using namespace std; using i64 = long long; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, s; i64 f[500005], g[500005]; vector &lt;pii> son[500005]; struct edge &#123; int from, to, dist; edge(int u, int v, int d) : from(u), to(v), dist(d) &#123;&#125; &#125;; vector &lt;edge> edges; vector &lt;int> G[500005]; inline void addedge(int u, int v, int d) &#123; edges.push_back(edge(u, v, d)); G[u].push_back(edges.size() - 1); &#125; void dp(int x) &#123; // 0 就是初始条件，叶子节点不需要调整 for (int i = 0; i &lt; son[x].size(); ++i) dp(son[x][i].Y); // 对儿子进行处理 for (int i = 0; i &lt; son[x].size(); ++i) g[x] = max(g[x], g[son[x][i].Y] + son[x][i].W); // g 的转移 for (int i = 0; i &lt; son[x].size(); ++i) f[x] += f[son[x][i].Y] + (g[x] - g[son[x][i].Y] - son[x][i].W); // f 的转移 &#125; void dfs(int o, int fa) &#123; for (int i = 0; i &lt; G[o].size(); ++i) &#123; edge &amp;e = edges[G[o][i]]; if (e.to != fa) &#123; son[o].push_back(make_pair(e.to, e.dist)); dfs(e.to, o); &#125; &#125; &#125; int main(void) &#123; n = read(), s = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(), d = read(); addedge(u, v, d); addedge(v, u, d); &#125; dfs(s, -1); // 建树 dp(s); printf(\"%lld\\n\", f[s]); return 0; &#125; [ZJOI2006] 三色二叉树 Portal. 设 f(i,0),f(i,1),f(i,2)f(i,0),f(i,1),f(i,2)f(i,0),f(i,1),f(i,2) 分别代表 iii 节点染成绿色、红色、蓝色的绿色节点最多数。转移对于读到这的读者来说应该不是困难。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; char s[500005]; int f[500005][3], g[500005][3]; // f 最多，g 最少，0~2: GRB 的绿色节点 void dp(int o) &#123; if (s[o] == '0') &#123; f[o][0] = g[o][0] = 1; return; &#125; int x, y; dp(x = ++n); if (s[o] == '1') &#123; f[o][0] = max(f[x][1], f[x][2]) + 1; f[o][1] = max(f[x][0], f[x][2]); f[o][2] = max(f[x][0], f[x][1]); g[o][0] = min(g[x][1], g[x][2]) + 1; g[o][1] = min(g[x][0], g[x][2]); g[o][2] = min(g[x][0], g[x][1]); &#125; else &#123; dp(y = ++n); f[o][0] = max(f[x][1] + f[y][2], f[x][2] + f[y][1]) + 1; f[o][1] = max(f[x][0] + f[y][2], f[x][2] + f[y][0]); f[o][2] = max(f[x][0] + f[y][1], f[x][1] + f[y][0]); g[o][0] = min(g[x][1] + g[y][2], g[x][2] + g[y][1]) + 1; g[o][1] = min(g[x][0] + g[y][2], g[x][2] + g[y][0]); g[o][2] = min(g[x][0] + g[y][1], g[x][1] + g[y][0]); &#125; &#125; int main(void) &#123; scanf(\"%s\", s + 1); dp(++n); printf(\"%d %d\\n\", max(&#123;f[1][0], f[1][1], f[1][2]&#125;), min(&#123;g[1][0], g[1][1], g[1][2]&#125;)); return 0; &#125; [UVa 12186] Another Crisis Portal. 状态的定义与转移对于读者来说应该已经不是困难，这里提供另一种实现。由于需要排序，所以将 dp 做成有返回值的函数，这样其实更类似于 dfs。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, t, f[100005]; vector &lt;int> son[100005]; int dp(int x) &#123; if (son[x].empty()) return 1; vector &lt;int> a; for (int i = 0; i &lt; son[x].size(); ++i) a.push_back(dp(son[x][i])); sort(a.begin(), a.end()); int c = ceil(son[x].size() * t / 100.0); int ans = 0; for (int i = 0; i &lt; c; ++i) ans += a[i]; return ans; &#125; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;t) == 2 &amp;&amp; n) &#123; for (int i = 0; i &lt;= n; ++i) &#123; son[i].clear(); f[i] = 0; &#125; for (int i = 1, x; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); son[x].push_back(i); &#125; printf(\"%d\\n\", dp(0)); &#125; return 0; &#125; [UVa 1218] Perfect Service Portal. 这种题有属于自己的套路： f(x,0)f(x,0)f(x,0) 代表 xxx 是服务器，那么儿子随便； f(x,1)f(x,1)f(x,1) 代表 xxx 不是，但是父亲是，那么儿子都不是； f(x,2)f(x,2)f(x,2) 代表 xxx 和父亲都不是，但是有一个儿子是。 转移方程应该不难写出。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; const int INF = 10001; int n, f[10005][3]; vector &lt;int> G[10005]; void dp(int x, int fa) &#123; f[x][0] = 1, f[x][1] = 0, f[x][2] = INF; int sum = 0; for (auto y : G[x]) &#123; if (y == fa) continue; dp(y, x); f[x][0] += min(f[y][0], f[y][1]); f[x][1] += f[y][2]; sum += f[y][2]; &#125; for (auto y : G[x]) if (y != fa) f[x][2] = min(f[x][2], sum - f[y][2] + f[y][0]); &#125; int main(void) &#123; while (n != -1 &amp;&amp; scanf(\"%d\", &amp;n) == 1) &#123; for (int i = 1; i &lt;= n; ++i) G[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1, 0); printf(\"%d\\n\", min(f[1][0], f[1][2])); scanf(\"%d\", &amp;n); &#125; return 0; &#125; 树形背包 问题定义在树形结构上，依照子树设定子问题。常常用 f(x,s)f(x,s)f(x,s) 表示子树 xxx 在状态限制 sss 下的最优解。先递归求解子树的答案，再计算当前结点答案。 普通的背包，如 01 背包可以放到树上，而树形结构还可以用来解决依赖性背包。 普通背包 | [Luogu P2015] 二叉苹果树 Portal. 有一棵苹果树，如果树枝有分叉，一定是分二叉（就是说没有只有一个儿子的结点）这棵树共有 NNN 个结点（叶子点或者树枝分叉点），编号为 1∼N1 \\sim N1∼N，树根编号一定是 111。我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有 444 个树枝的树：2 5 \\ &#x2F; 3 4 \\ &#x2F; 1现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。给定需要保留的树枝数量，求出最多能留住多少苹果。 我们设 f(i,j)f(i,j)f(i,j) 代表以 iii 为根的子树，恰好保留 jjj 条边所能获得的最多苹果数。那么我们考虑左右子树（如果有），由于 f(x,0)f(x,0)f(x,0) 这个状态是存在的，所以我们让 −1-1−1 的体积代表什么都不选。 下面是代码，请仔细阅读。 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, q; int son[105][2], val[105][2]; int s[105]; // s[x] 为 x 及其子节点所含有的边数 int f[105][105]; void dp(int o) &#123; int x = son[o][0], y = son[o][1]; if (!x) return; dp(x), dp(y); s[o] = s[x] + s[y] + 2; // +2 是连接左右子树用掉的 for (int i = -1; i &lt;= s[x]; ++i) for (int j = -1; j &lt;= s[y]; ++j) &#123; int vl = (i == -1 ? 0 : f[x][i] + val[o][0]); // -1 不选就是 0，选了就是儿子的能获得的苹果数值加上儿子上的苹果数（因为这一条边选了） int vr = (j == -1 ? 0 : f[y][j] + val[o][1]); f[o][i + j + 2] = max(f[o][i + j + 2], vl + vr); // i + j 是左子树和右子树用掉的边，+2 是当前节点连接左右子树用掉的边 &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt; n; ++i) &#123; int x; scanf(\"%d\", &amp;x); int b = son[x][0] > 0; // 存在左子树就往右子树里读入 scanf(\"%d%d\", &amp;son[x][b], &amp;val[x][b]); // 这里的树枝上的苹果送给儿子 &#125; dp(1); printf(\"%d\\n\", f[1][q]); return 0; &#125; 可以发现，其实这就是一个 01 背包问题，只不过跑到了树上。 依赖性背包 | [CTSC1997] 选课 Portal. 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 NNN 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 MMM 门课程学习，问他能获得的最大学分是多少？ 在《背包》中我们就讨论过这个问题，不过当时我们给出的方案是暴力枚举子集转换成分组背包，但是显然很慢。现在有了树，这类问题就变的好解了。 如果没有先修课的限制，这就是一个标准的 01 背包问题。由于每门课程的先修课只有一门，这就构成了一棵每门课都以自己的先修课为父亲的森林结构（因为可能会有多门课没有先修课）。既然如此，我们增设一个虚（chao）拟（ji）课（ba）程（ba），0 号节点，作为”实际上没有先修课的课程“。 设 f(x,t)f(x,t)f(x,t) 表示在以 xxx 为根的子树中选 ttt 门课程能获得的最高学分。设它的子节点个数为 ppp，那么有 f(x,0)=0f(x,0)=0f(x,0)=0。当 t&gt;0t&gt;0t&gt;0 时，必须选节点 xxx，那么有（score[x]score[x]score[x] 指课程 xxx 获得的学分，yiy_iyi​ 指 xxx 的子节点）： f(x,t)=max⁡∑i=1pci=t−1{∑i=1pf(yi,ci)}+score[x]f(x,t)=\\max\\limits_{\\sum_{i=1}^{p} c_i=t-1}\\left\\{\\sum\\limits_{i=1}^{p}f(y_i,c_i)\\right\\}+score[x] f(x,t)=∑i=1p​ci​=t−1max​{i=1∑p​f(yi​,ci​)}+score[x] 也就是说，要在满足子节点所选的科目的综合为 (∑i=1pci)=t−1\\left(\\sum_{i=1}^{p} c_i\\right)=t-1(∑i=1p​ci​)=t−1 的前提下，在子树中选课获得最大的得分。 现在想一想，这就是分组背包的处理方式！ 可以这么理解。对于每个节点，有 ppp 个儿子，也就是有 ppp 组物品，每组物品都有 t−1t-1t−1 个（不足的用体积和价值都为 000 的物品来补齐），其中第 iii 组的第 jjj 个物品体积为 jjj，价值为 f(yi,j)f(y_i,j)f(yi​,j)。背包的总容量为 t−1t-1t−1（因为当前节点会吃掉体积为 111 的容量）。 每组中至多只能选一个物品（难不成你还能同时选 f(yi,0)f(y_i,0)f(yi​,0) 和 f(yi,1)f(y_i,1)f(yi​,1) 吗 ），使得物品体积不超过 t−1t-1t−1 的前提下（根据之前背包中所推的原理，不需要取体积分别为 0∼t−10\\sim t-10∼t−1 的最大值），物品价值最大（获得最多的学分）。然而我们的超级爸爸 000 号节点除外，因为它根本不需要被选修，背包总容积为 ttt。 实现时我们可以装作有 m+1m+1m+1 个可选的物品，这样就不用理会超级爸爸了。下面是代码，请仔细阅读。 #include &lt;bits/stdc++.h> using namespace std; int n, m, s[305], siz[305]; int f[305][305]; vector &lt;int> son[305]; void dp(int x) &#123; f[x][0] = 0; f[x][1] = s[x]; siz[x] = 1; for (int y : son[x]) &#123; dp(y); // 递归求解每个物品的价值（每个儿子的价值） for (int i = min(siz[x], m + 1); i >= 1; --i) for (int j = min(siz[y], m + 1 - i); j >= max(1, i - siz[x]); --j) f[x][i + j] = max(f[x][i + j], f[x][i] + f[y][j]); siz[x] += siz[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); son[x].push_back(i); s[i] = read(); &#125; memset(f, 0xff, sizeof(f)); // 求的是最大值 dp(0); // 从超级节点开始 dp printf(\"%d\\n\", f[0][m + 1]); // 必选，所以答案只能是这一个 return 0; &#125; 树形背包中的上下界需要注意，需要卡死，注意不要遍历到无用的状态，一定是一个将子树合并到当前节点的过程，这样才能保证时间复杂度为 O(nm)O(nm)O(nm)，大致原理是：“每对节点只会恰好在 LCA 处合并一次”。 换根 DP POJ3585 Accumulation Degree。 正常来讲，这道题怎么做？很显然，不能随便选一个点作为根节点，这样无法统计答案。如果枚举源点，那么每次都跑一个树形 DP 就可以解决了，但是时间不允许。但是不要紧，一种名为“二次扫描与换根法”的技巧可以只 DP 一次来统计答案，也被称之为换根 DP。在此之前，我们先把 nnn 次 DP 的转移方程写出来： f(x)=∑y∈Son(x){min⁡{f(y),c(x,y)},deg[x]&gt;1,c(x,y),deg[x]=1.f(x) = \\sum_{y\\in Son(x)} \\begin{cases} \\min\\{f(y), c(x, y)\\}&amp;, deg[x]&gt;1,\\\\ c(x,y)&amp;, deg[x] = 1. \\end{cases} f(x)=y∈Son(x)∑​{min{f(y),c(x,y)}c(x,y)​,deg[x]&gt;1,,deg[x]=1.​ void dp(int x, int fa) &#123; f[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].to, w = G[x][i].val; if (y != fa) &#123; dp(y, x); if (deg[y] == 1) f[x] += w; else f[x] += min(f[y], w); &#125; &#125; &#125; 我们任意选择一个节点作为 root 进行如上操作后，就可以开始换根了： 设 g(x)g(x)g(x) 代表以 xxx 作为源点，流向整个水系，流量最大是多少。初始肯定是 g(root)=f(root)g(root)=f(root)g(root)=f(root)。 如果 g(x)g(x)g(x) 已经被求出，那么对于子节点 yyy，g(y)g(y)g(y) 包含两个部分： 从 yyy 流入 yyy 的子树的流量，就是 f(y)f(y)f(y)； 从 yyy 到父亲 xxx 然后继续流的流量。 这个 222 怎么求？还记得我们是怎么求解树的重心的吗？我们用整体的减去了局部的，就等于除了局部以外的内容了。 这里也是一样，像这样： g(y)=f(y)+{min⁡{g(x)−min⁡{f(y),c(x,y)},c(x,y)},deg[x]&gt;1c(x,y),deg[x]=1g(y)=f(y)+\\begin{cases} \\min\\left\\{g(x)-\\min\\left\\{f(y),c(x,y)\\right\\}, c(x,y)\\right\\}&amp;,deg[x]&gt;1\\\\ c(x,y)&amp;,deg[x]=1 \\end{cases} g(y)=f(y)+{min{g(x)−min{f(y),c(x,y)},c(x,y)}c(x,y)​,deg[x]&gt;1,deg[x]=1​ 当 yyy 的父亲 xxx 是个度数为 111 的点时，它就是一个汇点，流量就是 c(x,y)c(x,y)c(x,y)；当它不是一个汇点的时候，就等于以它父亲作为源点的整个水系的流量 g(x)g(x)g(x)，减去从 x→yx\\rightarrow yx→y 的流量 min⁡{f(y),c(x,y)}\\min\\{f(y),c(x,y)\\}min{f(y),c(x,y)}，同时还要将这个差与 c(x,y)c(x,y)c(x,y) 取最小值。 #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int to, val; edge(int to = 0, int val = 0) : to(to), val(val) &#123;&#125; &#125;; int n; int f[200005], g[200005], deg[200005]; vector &lt;edge> G[200005]; inline void addedge(int u, int v, int w) &#123; G[u].push_back(edge(v, w)); &#125; void dp(int x, int fa) &#123; f[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].to, w = G[x][i].val; if (y != fa) &#123; dp(y, x); if (deg[y] == 1) f[x] += w; else f[x] += min(f[y], w); &#125; &#125; &#125; void dfs(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].to, w = G[x][i].val; if (y != fa) &#123; if (deg[x] == 1) g[y] = f[y] + w; // 先计算好当前的 g，然后再遍历 else g[y] = f[y] + min(g[x] - min(f[y], w), w); dfs(y, x); &#125; &#125; &#125; void solve(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) G[i].clear(); memset(deg, 0, sizeof(deg)); memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w), addedge(v, u, w); deg[u]++, deg[v]++; &#125; dp(1, -1); g[1] = f[1]; dfs(1, -1); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, g[i]); printf(\"%d\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; 也就是说，在换根的过程中，要搞明白代价少了什么，又多了什么。 图上 DP 我们说过，DP 需要有无后效性。所以一般我们只能在 DAG 上进行 DP（后面会学习到高斯消元可以进行后效性处理）。当然，不太复杂的问题，如单个环上的问题上的问题也是可以做的。或者，一般图的缩点之后也可以做。 DAG 上的 DP 你有没有想过 DP 的本质是什么？ 简述 线性结构上的 DP 也好，树形结构上的 DP 也罢。它们都有“状态””决策”两个概念。状态对应图上的一个点，而决策对应图上的边。 你有没有发现什么？ 如果 DP 的状态图长成下图这样，会发生什么？ 想要求解状态 333，依赖于状态 222，而状态 222 依赖于状态 111，状态 111 又依赖于状态 333！这成了个无限循环问题。 所以可以得出结论，DP 一般只适用于有向无环图（DAG），遍历顺序便是这个 DAG 的一个拓扑序。如果这个图是带环的，那么一般它就不能 DP。 一个问题可以 DP，是因为这个问题可以从小问题的解，推断出大问题的解。我们可以从初始状态的解，推出最终状态的解，从而解决问题。也就是说有这几条性质： 如果我们按以上方法绘图，那么立即就有几条性质： DP 的每一个状态都对应着一个点； 每种可能的转移方式，都对应着一条有向边； DP 的求解顺序，等同于这张图上的拓扑排序； 整张图必须是 DAG，否则不可能找到合适的求解顺序。 [Luogu P1613] 跑路 Portal. 我们的目的就是建图，然后求最短路。令 G[i,j,k]=1G[i,j,k]=1G[i,j,k]=1 代表存在一条 i→ji\\rightarrow ji→j，长度为 2k2^k2k 的边，这样的边就是可以 1s1s1s 跑完的。那么若 G[i,t,k−1]=G[t,j,k−1]=1G[i,t,k-1]=G[t,j,k-1]=1G[i,t,k−1]=G[t,j,k−1]=1，则 G[i,j,k]=1G[i,j,k]=1G[i,j,k]=1。由于图的规模很小，求最短路时直接使用 Floyd 即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int f[55][55]; bool G[55][55][40]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(f, 0x3f, sizeof f); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); f[u][v] = 1; G[u][v][0] = true; &#125; for (int l = 1; l &lt;= 32; ++l) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int k = 1; k &lt;= n; ++k) if (G[i][j][l - 1] &amp;&amp; G[j][k][l - 1]) &#123; G[i][k][l] = true; f[i][k] = 1; &#125; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) f[i][j] = min(f[i][j], f[i][k] + f[k][j]); printf(\"%d\\n\", f[1][n]); return 0; &#125; 环上 DP 可以考虑使用缩点解决。 Problemset 可能比较麻烦，但都没有什么难度。 树形 DP 基础的树形 DP，后面的题会稍微难一点。 [SDOI2006] 保安站岗 Portal. 设 f(x,0),f(x,1),f(x,2)f(x,0),f(x,1),f(x,2)f(x,0),f(x,1),f(x,2) 分别代表由父亲、自己和儿子来维护。需要注意的就是由儿子维护的，儿子要至少有一个是自己维护自己的。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int w[1505], f[1505][3]; vector &lt;int> G[1505]; void dp(int x, int fa) &#123; f[x][1] = w[x]; int flag = 0, minn = 1e9; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y != fa) &#123; dp(y, x); f[x][0] += min(&#123;f[y][1], f[y][2]&#125;); f[x][1] += min(&#123;f[y][0], f[y][1], f[y][2]&#125;); if (f[y][1] &lt; f[y][2]) f[x][2] += f[y][1], flag = true; else minn = min(minn, f[y][1] - f[y][2]), f[x][2] += f[y][2]; &#125; &#125; if (!flag) f[x][2] += minn; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int p, t, x; scanf(\"%d\", &amp;p); scanf(\"%d%d\", w + p, &amp;t); while (t--) &#123; scanf(\"%d\", &amp;x); G[p].push_back(x), G[x].push_back(p); &#125; &#125; dp(1, 0); printf(\"%d\\n\", min(f[1][1], f[1][2])); return 0; &#125; [CSP-S2019] 括号树 Portal. f(i)f(i)f(i) 表示 iii 到 111 的答案，再记 g(i)g(i)g(i) 为第 iii 个节点的贡献，如果扫描到当前一个 )，就说明这个节点是有贡献的。维护一个记录左括号位置的栈，扫描到一个 ) 就从栈中进行匹配，更新 g(x)=g(k)+1g(x)=g(k)+1g(x)=g(k)+1，其中 kkk 为弹出的栈顶的父亲，这样可以将父亲的贡献值也算上。如果是 ( 就直接入栈。这时候就可以计算当前的答案：父亲节点的答案加上当前节点的贡献。接下来就可以递归计算儿子的贡献，然后要还原现场使得父亲的其它儿子可以正确计算：如果弹出过栈就要把这个再压回去，否则如果发现栈不是空的，就是压进去过元素，把它 pop 出来。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, fa[500005]; i64 ans = 0, f[500005], g[500005]; // g[i] 表示节点 i 的贡献 char s[500005]; vector &lt;int> son[500005]; stack &lt;int> v; void dp(int x) &#123; int tmp = -1; if (s[x] == ')') &#123; if (!v.empty()) &#123; tmp = v.top(); g[x] = g[fa[tmp]] + 1; v.pop(); &#125; &#125; else v.push(x); f[x] = f[fa[x]] + g[x]; for (int i = 0; i &lt; son[x].size(); ++i) dp(son[x][i]); if (tmp != -1) v.push(tmp); // 压回去 else if (!v.empty()) v.pop(); // 还原现场，将压入的 '(' pop 出来 &#125; int main(void) &#123; scanf(\"%d%s\", &amp;n, s + 1); for (int i = 2, x; i &lt;= n; ++i) scanf(\"%d\", &amp;x), son[x].push_back(i), fa[i] = x; dp(1); for (int i = 1; i &lt;= n; ++i) ans ^= f[i] * i; printf(\"%lld\\n\", ans); return 0; &#125; [CF486D] Valid Sets Portal. 发现需要枚举点来统计信息，但是换根 DP 不是很好做，而且数据范围很小，所以考虑枚举每个点然后进行暴力 DP。 我们枚举每一个点，并令它是点权最大的点。设 f(x)f(x)f(x) 代表包含 xxx 的子树的最大连通块数。如果儿子 yyy 的点权差大于了 ddd 不行，如果点权比 rootrootroot 大也不行，相等的时候要判断一下点的编号，只能计算一个，因为枚举 yyy 的时候它还会被计算一遍。 转移也很简单，要乘上子树的大小 +1，设子树的大小为 size(x)size(x)size(x)，对应选 0∼size(y)0\\sim size(y)0∼size(y)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int MOD = 1000000007; int n, d; int a[2005], f[2005]; vector &lt;int> G[2005]; inline void addedge(int u, int v) &#123; G[u].push_back(v); &#125; void dp(int x, int fa, int root) &#123; f[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; if (a[y] > a[root] || (a[y] == a[root] &amp;&amp; y &lt; root)) continue; if (a[root] - a[y] > d) continue; dp(y, x, root); f[x] = 1ll * f[x] * (f[y] + 1) % MOD; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;d, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; memset(f, 0, sizeof(f)); dp(i, 0, i); ans = (ans + f[i]) % MOD; &#125; printf(\"%d\\n\", ans); return 0; &#125; [国家集训队] 聪聪可可 Portal. 设 f(x,i)f(x,i)f(x,i) 代表距离 xxx 为 iii（模意义）的点数，按照类似于点分治的方式统计即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int gcd(int x, int y) &#123; if (y == 0) return x; return gcd(y, x % y); &#125; int n, ans, f[20005][3]; vector&lt;pair&lt;int, int>> G[20005]; int M(int x) &#123; return (x % 3 + 3) % 3; &#125; void dfs(int x, int fa) &#123; f[x][0] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, w = G[x][i].second; if (y == fa) continue; dfs(y, x); for (int i = 0; i &lt; 3; ++i) ans += f[y][i] * f[x][M(-i - w)] * 2; for (int i = 0; i &lt; 3; ++i) f[x][M(i + w)] += f[y][i]; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].emplace_back(make_pair(v, d)); G[v].emplace_back(make_pair(u, d)); &#125; dfs(1, 0); ans += n; int full = n * n; int g = gcd(ans, full); ans /= g, full /= g; printf(\"%d/%d\\n\", ans, full); return 0; &#125; [HNOI2003] 消防局的设立 Portal. 令 f(x,0∼4)f(x,0\\sim 4)f(x,0∼4) 分别代表 xxx 覆盖到它的爷爷，它的父亲，它自己，它的儿子，它的孙子及其子树的最小代价，转移见代码。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int f[1005][5]; vector &lt;int> G[1005]; inline void addedge(int u, int v) &#123; G[u].push_back(v); &#125; void dp(int x, int fa) &#123; int tot = 0, sum3 = 0, sum2 = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; dp(y, x); ++tot; sum3 += f[y][3]; // 记录儿子自行覆盖它们的儿子所在的子树 sum2 += f[y][2]; // 记录儿子自行覆盖它所在的子树 &#125; if (tot == 0) &#123; f[x][0] = f[x][1] = f[x][2] = 1; return; &#125; f[x][0] = 1, f[x][1] = f[x][2] = 1e9; // 只有想要覆盖自己的爷爷是必须要自行执行的，初值为 1 for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; // 距离为 2 的点都覆盖了，只需要儿子覆盖它们的孙子即可 f[x][0] += f[y][4]; // f[x][1] 的由来：它有一个儿子(y)覆盖到了它的爷爷，可以覆盖它的兄弟，但是无法覆盖到它兄弟的子树（不含自己） f[x][1] = min(f[x][1], f[y][0] + sum3 - f[y][3]); // f[x][2] 的由来：它有一个儿子(y)覆盖到了它的父亲，但是它的兄弟无法覆盖 f[x][2] = min(f[x][2], f[y][1] + sum2 - f[y][2]); // 要求它所有的儿子被覆盖，儿子需要覆盖自己和子树 f[x][3] += f[y][2]; // 要求它的孙子被覆盖，儿子需要覆盖它们的儿子即可 f[x][4] += f[y][3]; &#125; for (int i = 1; i &lt; 5; ++i) f[x][i] = min(f[x][i], f[x][i - 1]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2, x; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); addedge(i, x); addedge(x, i); &#125; dp(1, 0); printf(\"%d\\n\", f[1][2]); // 答案是覆盖自己及子树 return 0; &#125; 树上背包 树上背包（分组，依赖性）的模型非常有用，而且类似于 f[x][k]f[x][k]f[x][k] 的状态设计也可以算是广义的树形背包，一定要了解原理。 [Luogu P1273] 有线电视网 Portal. 就是选课的翻版，设 f(i,j)f(i,j)f(i,j) 代表以 iii 为根的子树中，满足了 jjj 个客户的最大收益。然后直接 DP 做就行。注意最多能满足的客户个数。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #define pii pair&lt;int, int> using namespace std; int n, m, f[3005][3005]; // f[i][j] 以 i 为根的子树中，j 个客户转的最大收益 int M[3005]; vector &lt;pii> G[3005]; int dp(int x) &#123; // 返回观众的个数 f[x][0] = 0; if (x > n - m) return 1; int sum = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, w = G[x][i].second; sum += dp(y); for (int j = sum; j >= 0; --j) for (int k = j; k >= 0; --k) f[x][j] = max(f[x][j], f[x][j - k] + f[y][k] - w); &#125; return sum; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n - m; ++i) &#123; int k; scanf(\"%d\", &amp;k); while (k--) &#123; int a, c; scanf(\"%d%d\", &amp;a, &amp;c); G[i].push_back(&#123;a, c&#125;); &#125; &#125; memset(f, 0xbf, sizeof(f)); for (int i = n - m + 1; i &lt;= n; ++i) scanf(\"%d\", &amp;f[i][1]); dp(1); for (int i = m; i >= 0; --i) if (f[1][i] >= 0) &#123; printf(\"%d\\n\", i); break; &#125; return 0; &#125; [Luogu P1272] 重建道路 Portal.一场可怕的地震后，人们用 NNN 个牲口棚（编号 1∼N1\\sim N1∼N）重建了农夫 John 的牧场。由于人们没有时间建设多余的道路，所以现在从一个牲口棚到另一个牲口棚的道路是惟一的。因此，牧场运输系统可以被构建成一棵树。John 想要知道另一次地震会造成多严重的破坏。有些道路一旦被毁坏，就会使一棵含有 PPP 个牲口棚的子树和剩余的牲口棚分离，John 想知道这些道路的最小数目。 设 f(i,j)f(i,j)f(i,j) 代表以 iii 为根，保留 jjj 个点拆掉的最小边数，而且 iii 必须保留。 初始时 f(x,1)f(x,1)f(x,1) 等于 xxx 点的度数，转移的时候按照树形背包的方式转移： f(x,i)=min⁡j=0i−1{f(x,i−j)+f(y,j)−2}f(x,i)=\\min_{j=0}^{i-1}\\{f(x,i-j)+f(y,j)-2\\} f(x,i)=j=0mini−1​{f(x,i−j)+f(y,j)−2} 为什么是减 222 呢？因为 xxx 和 yyy 要连边，那么这条边就不用拆了。显然，这条边之前在 x,yx,yx,y 各被拆了一次，所以减去 222。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, p, f[155][155]; // i 为根，保留 j 个点拆掉的最小边数 int siz[155]; vector &lt;int> G[155]; void dp(int x, int fa) &#123; siz[x] = 1; f[x][1] = G[x].size(); for (int y : G[x]) if (y != fa) &#123; dp(y, x); siz[x] += siz[y]; for (int i = siz[x]; i >= 0; --i) &#123; for (int j = i - 1; j >= 0; --j) f[x][i] = min(f[x][i], f[x][i - j] + f[y][j] - 2); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; memset(f, 0x3f, sizeof(f)); dp(1, 0); int ans = f[1][p]; for (int i = 2; i &lt;= n; ++i) ans = min(ans, f[i][p]); printf(\"%d\\n\", ans); return 0; &#125; [HAOI2015] 树上染色 Portal.有一棵点数为 n(1≤n≤2×103)n(1\\le n \\le 2\\times 10^3)n(1≤n≤2×103) 的树，树边有边权。给你一个在 0∼n0 \\sim n0∼n 之内的正整数 kkk ，你要在这棵树中选择 kkk 个点，将其染成黑色，并将其他 的 n−kn-kn−k 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益。问受益最大值是多少。 考虑每一条边的贡献，这样就可以统计了出一条边被经过了多少次。假设这条边连接的子树中有 kkk 个黑色点，那么经过次数就是 k×(m−k)+(siz[y]−k)×(n−m−siz[y]+k)k\\times (m-k)+(siz[y]-k)\\times(n-m-siz[y]+k)k×(m−k)+(siz[y]−k)×(n−m−siz[y]+k)，然后 kkk 只能选择一个，这就是分组背包！ 那么设 f[x][k]f[x][k]f[x][k] 代表以 xxx 为根，选择了 kkk 个子节点染成黑色的最大贡献。实现时有一个细节：应该把所有 fff 都初始化为 −1-1−1，代表是不合法的。然后令 k=0,1k=0,1k=0,1 时 f=0f=0f=0，因为只选 0,10,10,1 个黑点肯定合法。转移的时候倒序枚举，如果儿子的值是合法的就用树形背包的方式更新。特别的，与普通树形背包不一样，kkk 的选择一定是要选 000 再选其它的，因为本来就要算上儿子点的全白贡献（即使一个黑点不选，也是有贡献的，体积为 000 但是价值不为 000，贡献必须计算）。所以转移的时候可以选择正序或者提前处理好。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct edge &#123; int v, d; &#125;; int n, m, siz[2005]; i64 f[2005][2005]; vector&lt;edge> G[2005]; void dp(int x, int fa) &#123; siz[x] = 1; f[x][0] = f[x][1] = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].v; i64 w = G[x][i].d; if (y != fa) &#123; dp(y, x); siz[x] += siz[y]; for (int j = min(m, siz[x]); j >= 0; --j) &#123; if (f[x][j] != -1) f[x][j] += f[y][0] + w * siz[y] * (n - m - siz[y]); for (int k = min(j, siz[y]); k >= 1; --k) &#123; if (f[x][j - k] == -1) continue; i64 val = 1ll * k * (m - k) + 1ll * (siz[y] - k) * (n - m - (siz[y] - k)); f[x][j] = max(f[x][j], f[x][j - k] + f[y][k] + val * w); &#125; &#125; &#125; &#125; &#125; int main(void) &#123; memset(f, -1, sizeof(f)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(&#123;v, d&#125;); G[v].push_back(&#123;u, d&#125;); &#125; dp(1, 0); printf(\"%lld\\n\", f[1][m]); return 0; &#125; 换根 DP 同样，也不是很难。 [POI2008] STA-Station Portal. 换根 DP 的模板题。在换根的时候，我们需要知道子树大小和父亲 xxx 的答案，那么儿子 yyy 的答案相比父亲来讲，它所有的子树深度都减去 111，而不是它子树的深度都加上了 111。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int s[1000005], dep[1000005]; i64 f[1000005]; vector &lt;int> G[1000005]; inline void addedge(int u, int v) &#123; G[u].push_back(v); &#125; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1, s[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y != fa) dfs(y, x), s[x] += s[y]; &#125; &#125; void dp(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y != fa) &#123; f[y] = f[x] - s[y] + (n - s[y]); // -s[y], +(n - s[y]) dp(y, x); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) f[1] += dep[i]; dp(1, 0); i64 ans = 0; int id = 0; for (int i = 1; i &lt;= n; ++i) if (f[i] > ans) ans = f[i], id = i; printf(\"%d\\n\", id); return 0; &#125; DAG 上的 DP 按照拓扑序转移。 [CF721C] The Journey Portal. 设 f(i,j)f(i,j)f(i,j) 代表在 iii 走过 jjj 个点的最短距离即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; const int INF = 0x3f3f3f3f; int n, m, k, ans, in[5005]; int f[5005][5005]; int pre[5005][5005]; vector&lt;pair&lt;int, int>> G[5005]; void Kahn(void) &#123; queue&lt;int> q; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) q.push(i); f[1][1] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].first, w = G[u][i].second; for (int j = 1; j &lt;= n; ++j) &#123; if (f[v][j + 1] > f[u][j] + w) &#123; f[v][j + 1] = f[u][j] + w; pre[v][j + 1] = u; &#125; if (f[n][j] &lt;= k) ans = max(ans, j); &#125; --in[v]; if (in[v] == 0) q.push(v); &#125; &#125; &#125; int p[5005]; void dfs(int x, int t) &#123; p[t] = x; if (t > 1) dfs(pre[x][t], t - 1); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].emplace_back(make_pair(v, d)); ++in[v]; &#125; Kahn(); printf(\"%d\\n\", ans); dfs(n, ans); for (int i = 1; i &lt;= ans; ++i) printf(\"%d \", p[i]); putchar('\\n'); return 0; &#125; 杂题 补充一些题目。 [CF274B] Zero Tree Portal. 每次必须操作 111 节点的条件过于奇怪，设 f(x),g(x)f(x),g(x)f(x),g(x) 分别代表这个节点应该加减多少，然后需要取子树中的最大值。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, a[100005]; vector&lt;int> G[100005]; i64 f[100005], g[100005]; // f[x] 加，g[x] 减 void dfs(int x, int fa) &#123; for (int y : G[x]) if (y != fa) &#123; dfs(y, x); f[x] = max(f[x], f[y]); g[x] = max(g[x], g[y]); &#125; int k = a[x] + f[x] - g[x]; if (k > 0) g[x] += k; else f[x] -= k; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin >> u >> v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; dfs(1, 0); cout &lt;&lt; f[1] + g[1] &lt;&lt; \"\\n\"; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"算法竞赛/学习笔记/动态规划","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形 DP","slug":"树形-DP","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E5%BD%A2-DP/"},{"name":"图上 DP","slug":"图上-DP","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E4%B8%8A-DP/"}]},{"title":"生成树问题","slug":"notes/图论/span-tree","date":"2022-10-14T00:00:00.000Z","updated":"2022-10-14T00:00:00.000Z","comments":true,"path":"9acb5cb3/","link":"","permalink":"https://james1badcreeper.github.io/9acb5cb3/","excerpt":"在无向图中，生成树指一棵由全部顶点和组成的树，而当中边权之和最小的生成树称为最小生成树（Minimum Spanning Tree，MST）。本文会引导你学习 MST 的 Kruskal 和 Prim 算法。","text":"在无向图中，生成树指一棵由全部顶点和组成的树，而当中边权之和最小的生成树称为最小生成树（Minimum Spanning Tree，MST）。本文会引导你学习 MST 的 Kruskal 和 Prim 算法。 最小生成树 常见的求解 MST 的方法有两种：Kruskal 和 Prim。模板。 Kruskal Kruskal 基于贪心的思想。Kruskal 先把 mmm 条边进行排序，然后检查每条边 u,vu,vu,v，如果 uuu 和 vvv 在同一个连通分量中，那么加入后就会形成环，不能加入。若不在呢？那就直接加入，一定是最优的。证明可以使用反证法，这里略去。 实现上，排序直接用 sort，维护的过程可以采用并查集，参考代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, fa[5005]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; struct edge &#123; int u, v, w; bool operator&lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[200005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); sort(e + 1, e + m + 1); int tot = 1, ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = find(e[i].u), v = find(e[i].v); if (u == v) continue; ++tot; fa[u] = v; ans += e[i].w; if (tot == n) break; &#125; if (tot != n) puts(\"orz\"); else printf(\"%d\\n\", ans); return 0; &#125; 时间复杂度 O(mlog⁡n+nlog⁡n)\\mathcal{O}(m\\log n+n\\log n)O(mlogn+nlogn)（一般认为 m&gt;nm &gt; nm&gt;n，所以写作 O(mlog⁡n)\\mathcal{O}(m\\log n)O(mlogn)）。 Prim Prim 同样基于贪心的思想，读者应该了解过 Dijkstra 算法，Prim 和 Dijkstra 大概就是相同的原理。 Prim 算法维护的是 MST 的一部分。最初，Prim 确定 111 号节点属于 MST（即将 111 作为根节点）。 设确定属于 MST 的点集为 TTT，未确定为 SSS。Prim 会找到边权最小的边 (u,v),u∈T,v∈S(u,v),u\\in T,v\\in S(u,v),u∈T,v∈S，然后将这条边加入 MST。 实现时开一个 ddd 数组，当 i∈Si\\in Si∈S 时，d[i]d[i]d[i] 代表与集合 TTT 中节点之间权值最小的边的权值，最终答案就是 ∑d\\sum d∑d。 发没发现这一过程很像 Dijkstra？的确如此，代码如下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int G[5005][5005], d[5005], v[5005]; void Prim(void) &#123; memset(d, 0x3f, sizeof d); d[1] = 0; for (int op = 1; op &lt; n; ++op) &#123; int x = 0; for (int i = 1; i &lt;= n; ++i) if (!v[i] &amp;&amp; (d[i] &lt; d[x])) x = i; v[x] = 1; for (int y = 1; y &lt;= n; ++y) if (v[y] == 0) d[y] = min(d[y], G[x][y]); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(G, 0x3f, sizeof G); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u][v] = G[v][u] = min(G[u][v], w); &#125; Prim(); int ans = 0; for (int i = 1; i &lt;= n; ans += d[i++]) if (d[i] > 1e9) return puts(\"orz\"), 0; return !printf(\"%d\\n\", ans); &#125; Prim 的复杂度是 O(n2)\\mathcal{O}(n^2)O(n2)，虽然和 Dijkstra 一样可以用优先队列优化到 O(mlog⁡n)\\mathcal{O}(m\\log n)O(mlogn)，但是这时就不如直接用 Kruskal。所以 Prim 用于稠密图（尤其是完全图）的 MST 求解。 Boruvka 对于一个点 iii，其最小权值的临边必定在 MST 上。那么迭代 log⁡n\\log nlogn 次，每次扫描每条边，然后合并连通块。 算法时间复杂度为 O(mlog⁡n)O(m\\log n)O(mlogn)，但是实际中并不常用。实用的是这个思想。比如给定一张 nnn 个点的完全图，边权通过某种方式计算。这时可以使用 Boruvka 算法，利用数据结构快速计算不在当前连通块的最小边权。 其它生成树 生成树问题有一些变种，这里简单介绍一下： 最小瓶颈生成树 这类问题形如这样：给出一个带权无向图，求一棵生成树，使得最大边权值尽量小。 怎么求呢？我们肯定要把所有边都排序，然后求解。等等，这不就是 Kruskal 算法吗？的确如此。原图的最小生成树就一定是最小瓶颈生成树（但要注意最小瓶颈生成树不一定是最小生成树）。 最小瓶颈路 求带权无向图 uuu 和 vvv 的一条路径，使得这条路径上的最大边权值最小，这样的路被称为最小瓶颈路。 怎么做呢？可以使用二分 + 01 BFS 来解决，但效率较低。可以求原图的 MST，然后所有路径必定在 MST 上。为什么可以这么做呢？可以用反证法，会证明出这样一个结论：如果存在一条路径不在 MST 上，那么这个 MST 一定是假的。 次小生成树 模板。 这里只讨论严格次小生成树，非严格的同理。 由于 Kruskal 算法的过程，可以证明次小生成树只和最小生成树有一条边差距。接下来考虑如何替换： 设最小生成树为 TTT，权值和为 SSS，那么遍历每一条边，加入一条边后树上会出现一个环，再断掉这个环中边权最大的边（若加入的也是最大的，那么需要断掉次大的，由于原来已经是 MST，显然加入的只能大于等于），对上述所有生成的答案取 min⁡\\minmin 之后就可以得到答案。 现在的问题就是，如何高校维护 u,vu,vu,v 路径上的最大值呢？ 采用树上倍增法，类似于 ST 表，存储每个点向上 2i2^i2i 条边的最大值与次大值，查询的时候倍增查询即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> #include &lt;cstring> using namespace std; typedef long long i64; const int INF = 1e9; const i64 INF64 = 2e18; struct edge &#123; int u, v, w; bool use; bool operator &lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[300005]; int n, m; int bin[100005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; #define pii pair&lt;int, int> vector&lt;pii> G[100005]; i64 ans0 = 0; void Kruskal(void) &#123; for (int i = 1; i &lt;= n; ++i) bin[i] = i; sort(e + 1, e + m + 1); int tot = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = find(e[i].u), v = find(e[i].v); if (u != v) &#123; ans0 += e[i].w; bin[u] = v; e[i].use = true; G[e[i].u].push_back(&#123;e[i].v, e[i].w&#125;); G[e[i].v].push_back(&#123;e[i].u, e[i].w&#125;); ++tot; &#125; if (tot == n - 1) break; &#125; &#125; int dep[100005], lg[100005]; int f[100005][20]; int mx[100005][20], mx2[100005][20]; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; f[x][0] = fa; mx2[x][0] = -INF; for (int i = 1; (1 &lt;&lt; i) &lt;= dep[x]; ++i) &#123; f[x][i] = f[f[x][i - 1]][i - 1]; int g[4] = &#123;mx[x][i - 1], mx[f[x][i - 1]][i - 1], mx2[x][i - 1], mx2[f[x][i - 1]][i - 1]&#125;; sort(g, g + 4); mx[x][i] = g[3]; int p = 2; while (p >= 0 &amp;&amp; g[p] == g[3]) --p; mx2[x][i] = (p == -1 ? -INF : g[p]); &#125; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, w = G[x][i].second; if (y != fa) &#123; mx[y][0] = w; dfs(y, x); &#125; &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; i64 calc(int x, int y, int val) &#123; int res = -INF; for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) &#123; if (val != mx[x][i]) res = max(res, mx[x][i]); else res = max(res, mx2[x][i]); x = f[x][i]; &#125; return res; &#125; int main(void) &#123; ios::sync_with_stdio(false); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); Kruskal(); dfs(1, 0); i64 ans = INF64; for (int i = 1; i &lt;= m; ++i) if (!e[i].use) &#123; int lca = LCA(e[i].u, e[i].v); i64 tmpa = calc(e[i].u, lca, e[i].w); i64 tmpb = calc(e[i].v, lca, e[i].w); ans = min(ans, ans0 - max(tmpa, tmpb) + e[i].w); &#125; if (ans != INF64) printf(\"%lld\\n\", ans); else puts(\"-1\"); return 0; &#125; 有向图中有一类生成树称为最小树形图。这个问题比较复杂，不在本文中讨论。感兴趣的同学可以自行了解。 还有一类问题称为 k 小生成树，但是这种问题的做法笔者暂时没有了解。据闻在大神刘汝佳的《算法艺术与信息学竞赛》P300 中有说明，感兴趣的读者可以自行挑战 Problemset 这里的题目都比较简单。 简单生成树 这是最基本的生成树问题。 [Luogu P1195] 口袋的天空 Portal. 这个 KKK 是什么？不要紧，我们还是使用 Kruskal 算法，不过不一定要连成一棵树，我们只要把这些云连成 KKK 个即可。也就是说，只需要连 N−KN-KN−K 条边。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, m, k; struct edge &#123; int u, v, d; edge(int u = 0, int v = 0, int d = 0) : u(u), v(v), d(d) &#123;&#125; bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125;a[10005]; int fa[1005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;a[i].u, &amp;a[i].v, &amp;a[i].d); sort(a + 1, a + m + 1); int ans = 0, cnt = 0; for (int i = 1; i &lt;= m; ++i) &#123; int x = find(a[i].u), y = find(a[i].v); if (x == y) continue; fa[x] = y, ans += a[i].d, ++cnt; if (cnt == n - k) &#123; printf(\"%d\\n\", ans); return 0; &#125; &#125; puts(\"No Answer\"); return 0; &#125; [UVa 1395] Slim Span Portal. 给定一个 n(n≤100)n(n\\le 100)n(n≤100) 个点的无向图，求最大边减最小边的值尽量小的生成树。 如果最小边确定，我们求出最小生成树，那么就可以求出这个值了。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int fa[105]; int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]); &#125; struct edge &#123; int u, v, d; edge(int u, int v, int d) : u(u), v(v), d(d) &#123;&#125; inline bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125;; vector &lt;edge> e; int n, m; inline int kruskal(void) &#123; sort(e.begin(), e.end()); int ans = 0x7fffffff; for (int L = 0; L &lt; m; ++L) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i; int cnt = 0; for (int R = L; R &lt; m; ++R) &#123; int a = find(e[R].u), b = find(e[R].v); if (a == b) continue; fa[a] = b; if (++cnt == n - 1) &#123; ans = min(ans, e[R].d - e[L].d); break; &#125; &#125; &#125; if (ans == 0x7fffffff) return -1; return ans; &#125; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; e.clear(); for (int i = 0; i &lt; m; ++i) &#123; int u = read(), v = read(), d = read(); e.push_back(edge(u, v, d)); &#125; printf(\"%d\\n\", kruskal()); &#125; return 0; &#125; [Luogu P2700] 逐个击破 Portal. 我们现假设需要摧毁所有的边，然后按边权从大到小排序。如果两个点都不是敌人节点就连边，注意父亲也要设置为敌人节点（如果连接的点有敌人）。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; struct edge &#123; int u, v, d; edge(int u = 0, int v = 0, int d = 0) : u(u), v(v), d(d) &#123;&#125; bool operator &lt; (const edge &amp;a) const &#123; return d > a.d; &#125; &#125;a[100005]; int n, k, s[100005]; int fa[100005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= k; ++i) &#123; int x; scanf(\"%d\", &amp;x); s[x] = true; &#125; long long ans = 0; for (int i = 1; i &lt; n; ++i) &#123; scanf(\"%d%d%d\", &amp;a[i].u, &amp;a[i].v, &amp;a[i].d); ans += a[i].d; &#125; for (int i = 1; i &lt;= n; ++i) fa[i] = i; sort(a + 1, a + n + 1); for (int i = 1; i &lt; n; ++i) &#123; int x = find(a[i].u), y = find(a[i].v); if (s[x] &amp;&amp; s[y]) continue; fa[x] = y; ans -= a[i].d; s[y] = (s[x] | s[y]); &#125; printf(\"%lld\\n\", ans); return 0; &#125; [USACO08OCT] Watering Hole G Portal. 我们只需要增设一个水井点 000，让每一个牧场都与 000 连一条 WiW_iWi​ 的边，然后使用 Prim（因为是完全图，开大数据范围即可杀死 Kruskal）求解最小生成树。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, d[305]; bool v[305]; int a[305][305]; void Prim(void) &#123; memset(d, 0x3f, sizeof(d)); d[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x = -1; for (int j = 0; j &lt;= n; ++j) if (!v[j] &amp;&amp; (x == -1 || d[j] &lt; d[x])) x = j; v[x] = true; for (int j = 0; j &lt;= n; ++j) if (!v[j]) d[j] = min(d[j], a[x][j]); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int w; scanf(\"%d\", &amp;w); a[0][i] = a[i][0] = w; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[i][j]); Prim(); int ans = 0; for (int i = 0; i &lt;= n; ++i) ans += d[i]; printf(\"%d\\n\", ans); return 0; &#125; [UVa 1151] Buy or Build Portal. 通过二维枚举，我们可以轻松的把这玩意转化成图。对着图使用 Kruskal，得到 n−1n-1n−1 条边，就是可能成为最终答案的边。然后枚举购买哪些套餐即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x * f; &#125; int n, q, cost[8]; vector &lt;int> sub[8]; int x[1005], y[1005]; struct edge &#123; int u, v, d; edge(int u = 0, int v = 0, int d = 0) : u(u), v(v), d(d) &#123;&#125; bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125;; vector &lt;edge> e, es; int fa[1005]; int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]); &#125; inline void UnionFind_init(void) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i; &#125; int kruskal(int cnt, const vector &lt;edge> &amp;G, bool flag) &#123; if (cnt == 1) return 0; int ans = 0; for (int i = 0; i &lt; G.size(); ++i) &#123; int x = find(G[i].u), y = find(G[i].v); if (x == y) continue; fa[x] = y; ans += G[i].d; if (flag) es.push_back(G[i]); --cnt; if (cnt == 1) break; &#125; return ans; &#125; int main(void) &#123; int T = read(); while (T--) &#123; n = read(), q = read(); for (int i = 0; i &lt; q; ++i) &#123; int m = read(); cost[i] = read(); sub[i].clear(); while (m--) sub[i].push_back(read()); &#125; for (int i = 1; i &lt;= n; ++i) x[i] = read(), y[i] = read(); e.clear(), es.clear(); for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) e.push_back(edge(i, j, (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]))); sort(e.begin(), e.end()); UnionFind_init(); int ans = kruskal(n, e, true); for (int i = 0; i &lt; (1 &lt;&lt; q); ++i) &#123; UnionFind_init(); int cnt = n, c = 0; for (int j = 0; j &lt; q; ++j) if (i &amp; (1 &lt;&lt; j)) &#123; c += cost[j]; for (int k = 1; k &lt; sub[j].size(); ++k) &#123; int x = find(sub[j][k]), y = find(sub[j][0]); if (x != y) fa[x] = y, --cnt; &#125; &#125; ans = min(ans, c + kruskal(cnt, es, false)); &#125; printf(\"%d\\n\", ans); if (T) putchar('\\n'); &#125; return 0; &#125; [CF609E] Minimum spanning tree for each edge Portal. 跟次小生成树的思路是一样的，在路径上找一条最大的边换下来即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> using namespace std; typedef long long i64; int n, m; i64 ans = 0; struct edge &#123; int u, v, d, id; bool use; bool operator &lt; (const edge &amp;a) const &#123; return d &lt; a.d; &#125; &#125; e[200005]; int bin[200005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; int f[20][200005], dep[200005], w[20][200005]; vector&lt;pair&lt;int, int>> G[200005]; void dfs(int x, int fa) &#123; f[0][x] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= 18; ++i) f[i][x] = f[i - 1][f[i - 1][x]], w[i][x] = max(w[i - 1][x], w[i - 1][f[i - 1][x]]); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, d = G[x][i].second; if (y != fa) &#123; w[0][y] = d; dfs(y, x); &#125; &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); int ans = 0; for (int i = 18; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) ans = max(ans, w[i][x]), x = f[i][x]; if (x == y) return ans; for (int i = 18; i >= 0; --i) if (f[i][x] != f[i][y]) &#123; ans = max(&#123;ans, w[i][x], w[i][y]&#125;); x = f[i][x], y = f[i][y]; &#125; return max(&#123;ans, w[0][x], w[0][y]&#125;); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].d), e[i].id = i; sort(e + 1, e + m + 1); for (int i = 1; i &lt;= n; ++i) bin[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v, d = e[i].d; int x = find(u), y = find(v); if (x != y) &#123; bin[x] = y; e[i].use = true; G[u].push_back(&#123;v, d&#125;); G[v].push_back(&#123;u, d&#125;); ans += d; &#125; &#125; dfs(1, 0); static i64 p[200005]; for (int i = 1; i &lt;= m; ++i) &#123; if (e[i].use) p[e[i].id] = ans; else p[e[i].id] = ans - LCA(e[i].u, e[i].v) + e[i].d; &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%lld\\n\", p[i]); return 0; &#125; [CF76A] Gift Portal. 枚举能够使用的最大的 ggg，如果一条边没能被选中则删掉这条边。时间复杂度 O(mnlog⁡n)O(mn\\log n)O(mnlogn)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n, m, G, S, g[50005]; struct edge &#123; int u, v, g, s; bool operator &lt; (const edge &amp;a) const &#123; return s &lt; a.s; &#125; &#125; e[50005]; multiset&lt;edge> E; i64 ans = 2e18; int f[205]; int find(int x) &#123; if (f[x] == x) return x; return f[x] = find(f[x]); &#125; bool check(int mxg) &#123; int cnt = 1; for (int i = 1; i &lt;= n; ++i) f[i] = i; for (auto it = E.begin(); it != E.end(); ++it) &#123; auto e = *it; if (e.g > g[mxg]) continue; int x = find(e.u), y = find(e.v); if (x == y) continue; ++cnt; f[x] = y; if (cnt == n) break; &#125; return cnt == n; &#125; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;G, &amp;S); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].g, &amp;e[i].s), E.insert(e[i]), g[i] = e[i].g; sort(g + 1, g + m + 1); int L = 0, R = m + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (check(mid)) R = mid; else L = mid; &#125; if (R == m + 1) return puts(\"-1\"), 0; for (int mxg = R; mxg &lt;= m; ++mxg) &#123; int cnt = 1, now = 0; for (int i = 1; i &lt;= n; ++i) f[i] = i; for (auto it = E.begin(); it != E.end(); ++it) &#123; auto e = *it; if (e.g > g[mxg]) continue; int x = find(e.u), y = find(e.v); if (x == y) &#123; auto id = it; --id; E.erase(it); it = id; continue; &#125; ++cnt; f[x] = y; now = e.s; if (cnt == n) break; &#125; if (cnt == n) ans = min(ans, 1ll * now * S + 1ll * g[mxg] * G); &#125; printf(\"%lld\\n\", ans); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"生成树","slug":"生成树","permalink":"https://james1badcreeper.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"拓扑排序与图的连通性问题","slug":"notes/图论/connectivity","date":"2022-10-04T00:00:00.000Z","updated":"2022-10-04T00:00:00.000Z","comments":true,"path":"242bd056/","link":"","permalink":"https://james1badcreeper.github.io/242bd056/","excerpt":"在图中，如何判断一张图是否连通？如果删掉某条边，它还连通吗？有向图呢？这些操作有什么特殊性质吗？本文将探讨以 Tarjan 算法为核心的有关图的连通性的问题和欧拉路问题。","text":"在图中，如何判断一张图是否连通？如果删掉某条边，它还连通吗？有向图呢？这些操作有什么特殊性质吗？本文将探讨以 Tarjan 算法为核心的有关图的连通性的问题和欧拉路问题。 除了 Tarjan 算法，并查集等内容也能解决一些图连通性问题，请参照笔者相关文章。 拓扑排序 别问我为什么把这个放到这里来讲，因为接下来很多题都要用到它。 严格意义上来说，拓扑排序不是一种排序。是对有向无环图（DAG）GGG，将 GGG 中所有顶点排成一个线性序列，使得图中任意一对顶点 uuu 和 vvv ，若它们之间存在一条有向边 (u,v)(u,v)(u,v),则 uuu 在线性序列中出现在 vvv 之前。 模板。 开一个队列记录所有入度为 000 的点，然后维护即可。这一过程被称之为 Kahn 算法。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int in[105]; vector&lt;int> G[105]; queue&lt;int> q; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; memset(in, 0, sizeof(in)); for (int i = 1; i &lt;= n; ++i) G[i].clear(); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); ++in[y]; &#125; for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) q.push(i); while (!q.empty()) &#123; int t = q.front(); q.pop(); printf(\"%d \", t); for (int i = 0; i &lt; G[t].size(); ++i) &#123; --in[G[t][i]]; if (in[G[t][i]] == 0) q.push(G[t][i]); &#125; &#125; putchar('\\n'); &#125; return 0; &#125; 拓扑排序也可以使用 dfs 实现，感兴趣的读者可以自行学习。 有的时候求的拓扑序要求字典序，这时候直接将队列改为优先队列即可。 无向图的连通性 给定无向图 G=(V,E)G=(V,E)G=(V,E)，如果 x∈Vx\\in Vx∈V，从图中删去节点 xxx 和与 xxx 关联的所有边之后，GGG 被分裂成两个或两个以上的不相连的子图，那么称 xxx 称之为 GGG 的割点或割顶。如果 e∈Ve\\in Ve∈V，将 eee 删去后，GGG 分裂成两个不相连的子图，则称 eee 为 GGG 的桥或割边。 我们可以使用 Tarjan 算法在线性时间内求解无向图的割点和桥。 想要使用 Tarjan 算法，我们需要先了解几个基本概念： Tarjan 算法 时间戳。我们对图进行深度优先遍历，按照每个节点第一次被访问到的顺序，依次给予 nnn 个节点 1∼n1\\sim n1∼n 的整数标记，记为时间戳 dfn[x]dfn[x]dfn[x]，代表在 DFS 序中出现的位置。 搜索树。在无向连通图中任选一个节点出发进行深度优先遍历，每个点只访问一次，所有发生递归的边 (x,y)(x,y)(x,y)（即 xxx 到 yyy 是对 yyy 的第一次遍历），这样的边有 n−1n-1n−1 条，构成一棵树，称之为”无向连通图的搜索树“。如果这张图不连通，那么它会生成若干棵树，称之为”无向图的搜索森林“。 追溯值。除了时间戳外，还有一个概念：追溯值 low[x]low[x]low[x]，也就是能不经过父亲节点到达的最小时间戳。设 subtree(x)\\text{subtree}(x)subtree(x) 代表搜索树中以 xxx 的子树，low[x]low[x]low[x] 定义为以下节点的时间戳的最小值： subtree(x)\\text{subtree}(x)subtree(x) 中的节点； 通过 111 条不在搜索树上的边，可以到达 subtree(x)\\text{subtree}(x)subtree(x) 的节点。 这是一张无向图，粗边标出了搜索树，1 为根节点，每个节点是它的时间戳，括号标出了它的追溯值 如上图，111 节点的追溯值是它自己的时间戳，(1,5)(1,5)(1,5) 一条不在搜索树上的边使得 low[5]=dfn[1]=1low[5]=dfn[1]=1low[5]=dfn[1]=1，所以 2,3,42,3,42,3,4 节点都是 555 的祖先，又因为 (1,5)(1,5)(1,5) 这条边，所以 low[2]=low[3]=low[4]=dfn[1]=1low[2]=low[3]=low[4]=dfn[1]=1low[2]=low[3]=low[4]=dfn[1]=1。剩余节点大致同理。 我们计算追溯值时，应该首先令 low[x]=dfn[x]low[x]=dfn[x]low[x]=dfn[x]，然后考虑 xxx 出发的每条边 (x,y)(x,y)(x,y)：如果在搜索树上 xxx 是 yyy 的父亲，那么 low[x]=min⁡{low[x],low[y]}low[x]=\\min\\{low[x], low[y]\\}low[x]=min{low[x],low[y]}；如果 (x,y)(x,y)(x,y) 不是搜索树上的边，则 low[x]=min⁡{low[x],dfn[y]}low[x]=\\min\\{low[x], dfn[y]\\}low[x]=min{low[x],dfn[y]}。 Tarjan 的时间复杂度为 O(n+m)O(n+m)O(n+m)。 至于追溯值究竟是怎么来的，读者可以自行查阅资料。 割边判定法则 无向边 (x,y)(x,y)(x,y) 是割边，当且仅当搜索树上存在一个 xxx 的子节点 yyy，满足 dfn[x]&lt;low[y]dfn[x]&lt;low[y]dfn[x]&lt;low[y]。也就是说从 subtree(y)\\text{subtree}(y)subtree(y) 出发，若不经过 (x,y)(x,y)(x,y)，怎么走都无法到达 xxx 或比 xxx 更早访问的节点（因为 dfn[x]&lt;low[y]dfn[x]&lt;low[y]dfn[x]&lt;low[y]，即想要到 yyy 必须经过 (x,y)(x,y)(x,y)，即 yyy 被困在 xxx 的子树中了），那么这条边便是桥。 可以发现，桥一定是搜索树中的边，并且一个简单环中的边一定都不是桥。 虚线标出了桥 在存边的时候使用了一个 edges 数组，这样使用”成对变换“可以轻松的找到反向边。记录 fa 的话遇到重边时会出错。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, num = 0; // num 用于时间戳的标记 int dfn[105], low[105]; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; vector &lt;edge> edges; bool bridge[205]; vector &lt;int> G[105]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x, int in_edge) &#123; // in_edge 记录递归进入 x 的边的编号 dfn[x] = low[x] = ++num; // 标记时间戳，并在初始将 low[x] 标记为 dfn[x] for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; // 获取边 (x,y) if (!dfn[y]) &#123; // 未访问 tarjan(y, G[x][i]); // 递归遍历 // 能跑到这里的肯定是搜索树上的 // 所以 x 是 y 的父亲节点了，也就是 y 属于 subtree(x) low[x] = min(low[x], low[y]); // 割边判定法则，在搜索树上存在 x 的一个子节点 y 使得 dfn[x] &lt; low[y] if (dfn[x] &lt; low[y]) bridge[G[x][i]] = bridge[G[x][i] ^ 1] = true; // 标记的时候标记正边和反边 &#125; else if (G[x][i] != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); // 如果当前这条边是 x->y 的反边 y->x，那么这条命令不会被执行，因为它在搜索树上 // 但是有重边的话他就不是搜索树上的边 &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i, -1); // 图不一定连通，每个点都需要 tarjan。最初没有边到 i，用 -1 代替，-1 ^ 1 = -2 puts(\"Bridges:\"); for (int i = 0; i &lt; edges.size(); i += 2) if (bridge[i]) printf(\"%d %d\\n\", edges[i].from, edges[i].to); return 0; &#125; 割点判定法则 模板。 如果 xxx 不是搜索森林中一棵树的根节点，那么 xxx 是割点当且仅当搜索树上存在 xxx 的子节点 yyy 满足 dfn[x]≤low[y]dfn[x]\\le low[y]dfn[x]≤low[y]。如果这是根节点，这样的 yyy 必须有两个或以上，xxx 才是割点。 由于是小于等于，所以父节点和重边即使不考虑也能得到正确结果。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, root, num = 0, ans = 0; int dfn[20005], low[20005]; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; vector &lt;edge> edges; bool cut[20005]; vector &lt;int> G[20005]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; int flag = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; ++flag; if (x != root || flag > 1) cut[x] = true; // 如果不是根节点，或者 flag >= 2，就是割点 &#125; &#125; else low[x] = min(low[x], dfn[y]); // 可以直接更新 &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) root = i, tarjan(i); // 记录根节点，然后 tarjan for (int i = 1; i &lt;= n; ++i) if (cut[i]) ++ans; printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (cut[i]) printf(\"%d \", i); putchar('\\n'); return 0; &#125; [POI2008] BLO-Blockade Portal. 一张连通的无向图，请你对于每个节点 iii 求出，把与节点 iii 关联的所有边去掉以后（不去掉节点 iii 本身），无向图有多少个有序点对 (x,y)(x,y)(x,y)，满足 xxx 和 yyy 不连通。 如果一个点不是割点，那么断掉这个点所连的所有边后图的剩余部分依然连通，只有这个点与图中其它的所有点构成的有序点对满足不连通，共有 (n−1)×2(n-1)\\times 2(n−1)×2 个。 如果这个点是割点，那么断掉后图会分裂成若干个连通块。我们应该求出这些连通块的大小，然后两两相乘再将这些积相加。设再搜索树中，节点 iii 的子节点集合中，有 ttt 个点满足 dfn[x]≤low[sk]dfn[x]\\le low[s_k]dfn[x]≤low[sk​]，断掉之后，无向图至多分裂为 t+2t+2t+2 个连通块，这些连通块分别是：ttt 个断掉之后的小子树，111 个当前节点 xxx 自己构成的连通块，图的剩余部分（xxx 的父亲及其它）。 由于 Tarjan 算法本质上是一个 dfs。我们可以使用类似求树的重心的方式，设在搜索树中 size[x]size[x]size[x] 表示 xxx 的子树大小，那么断掉之后的有序数对数量为： 每棵小子树所对应的： size[s1]×(n−size[s1])+…size[st]×(n−size[st])=∑i=1tsize[si]×(n−size[si])size[s_1]\\times (n-size[s_1]) + \\dots size[s_t]\\times (n-size[s_t]) = \\sum\\limits_{i=1}^{t}size[s_i]\\times (n-size[s_i]) size[s1​]×(n−size[s1​])+…size[st​]×(n−size[st​])=i=1∑t​size[si​]×(n−size[si​]) 当前节点 xxx 对应的： 1×(n−1)=n−11\\times(n-1) = n-1 1×(n−1)=n−1 剩余部分对应的（前者为剩余部分的大小，后者为小子树和当前节点的大小和）： (n−1−∑i=1tsize[si])×(1+∑i=1tsize[si])\\left(n-1-\\sum\\limits_{i=1}^{t} size[s_i]\\right)\\times \\left(1+\\sum\\limits_{i=1}^{t} size[s_i]\\right) (n−1−i=1∑t​size[si​])×(1+i=1∑t​size[si​]) 代码便不难写出： 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; int n, m, num; int dfn[100005], low[100005]; int Size[100005]; i64 ans[100005]; bool cut[100005]; vector &lt;edge> edges; vector &lt;int> G[100005]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; Size[x] = 1; int flag = 0; i64 sum = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (!dfn[y]) &#123; tarjan(y); Size[x] += Size[y]; low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; ++flag; ans[x] += (i64)Size[y] * (n - Size[y]); sum += Size[y]; if (x != 1 || flag > 1) cut[x] = true; &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; if (cut[x]) ans[x] += (n - 1) + (n - 1 - sum) * (1 + sum); else ans[x] = (n - 1) &lt;&lt; 1; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; tarjan(1); // 所有城市都连通，调用一次 tarjan 即可 for (int i = 1; i &lt;= n; ++i) printf(\"%lld\\n\", ans[i]); return 0; &#125; 双连通分量与缩点 如果一张图不存在割边，那么这张图被称为边双连通图。如果它不存在割点，那么称之为点双连通图。 接下来给出的两份代码同时也是无向图连通性的模板。 e-DCC 及其缩点 无向连通图的极大边双连通子图被称之为边双连通分量，简记为 e-DCC。其中极大子图的意思是不存在一个更大的子图，这个子图包含了原来的子图，也满足这个限制条件。 一个图的边双连通分量之间一定是不相交的。如果两个双连通分量相交了，那么顺去它们中的一条边，两个子图依然是连通的，也就是说这两个双连通分量是一个更大的双连通分量的一部分。 模板。 e-DCC 的求解非常容易，因为如果图不存在割边，那么我们就把所有的割边都给删掉，图会分裂成若干个连通块，每一个连通块都是一个 e-DCC。 有一个性质：无向连通图是边双连通图，当且仅当任意一条边都包含在至少一个简单环中。 求解 e-DCC 时，经过一个点就要将这个点压入栈。当 low[x]=dfn[x]low[x]=dfn[x]low[x]=dfn[x] 时，代表 xxx 就是连通块深度最大的点。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; int n, m, num = 0, cnt = 0, c[500005]; int dfn[500005], low[500005]; bool bridge[4000005]; int st[500005], tot = 0; vector &lt;edge> edges; vector &lt;int> G[500005]; vector &lt;int> ans[500005]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x, int in_edge) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (!dfn[y]) &#123; tarjan(y, G[x][i]); low[x] = min(low[x], low[y]); if (dfn[x] &lt; low[y]) bridge[G[x][i]] = bridge[G[x][i] ^ 1] = true; &#125; else if (G[x][i] != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); &#125; if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ans[cnt].push_back(y); &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i, -1); printf(\"%d\\n\", cnt); for (int i = 1; i &lt;= cnt; ++i) &#123; printf(\"%d \", ans[i].size()); for (auto x : ans[i]) printf(\"%d \", x); putchar('\\n'); &#125; return 0; &#125; 将每一个 e-DCC 都看作一个节点，把割边看作连接 e-DCC 的边，这样会产生一棵树（不连通的无向图就是森林）。这种把 e-DCC 缩为一个节点的方式就叫做缩点，在解决连通性问题的时候非常有用。 for (int i = 0; i &lt; edges.size(); ++i) if (c[edges[i].from] != c[edges[i].to]) addedge(c[edges[i].from], c[edges[i].to]); // 不在一个 e-DCC 里面，将 e-DCC 连边 v-DCC 及其缩点 无向连通图的极大点双连通子图被称之为点双连通分量，简记为 v-DCC。 在求解的时候，每访问到一个新的节点，都需要将它入栈。若割点的判定法则成立，那么无论如何，都要不断弹出节点，直到 yyy 被弹出。弹出的所有东西加上 xxx 就是一个 v-DCC。还有，如果一个点是自己单独一个，那么它也是一个 v-DCC，需要特判。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, root, num = 0, tot = 0, cnt = 0; int dfn[500005], low[500005], stack[500005]; vector &lt;int> G[500005], ans[500005]; bool cut[500005]; inline void addedge(int u, int v) &#123; G[u].push_back(v); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; stack[++tot] = x; if (x == root &amp;&amp; G[x].size() == 0) &#123; ans[++cnt].push_back(x); return; &#125; int flag = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; ++cnt; ++flag; if (x != root || flag > 1) cut[x] = true; int z; do &#123; z = stack[tot--]; ans[cnt].push_back(z); &#125; while (z != y); ans[cnt].push_back(x); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (u != v) addedge(u, v), addedge(v, u); // 为了方便判断孤立点，所以自环不能加 &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) root = i, tarjan(i); printf(\"%d\\n\", cnt); for (int i = 1; i &lt;= cnt; ++i) &#123; printf(\"%d \", ans[i].size()); for (int j = 0; j &lt; ans[i].size(); ++j) printf(\"%d \", ans[i][j]); putchar('\\n'); &#125; return 0; &#125; 边双连通分量和点双连通分量统称为双连通分量，即 DCC（Double Connected component）。 点双连通分量可以引出圆方树，是解决点相关路径问题的利器，请参看《省选初级图论》。 有向图的连通性 在有向图中，如果任意两个点都可以互相到达，那么这张图被成为强连通图，有向图的极大强连通子图被称之为强连通分量（SCC）。显然，一个点最多属于一个 SCC。 Tarjan 算法 模板. Tarjan 算法可以求出有向图的强连通分量。当图变成无向图时，该算法也可以正常工作。 这里直接给出代码，原理有时间再写： 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; bool ins[10005]; int dfn[10005], low[10005], num = 0; int st[10005], tot = 0; int cnt = 0, c[10005], siz[10005]; vector &lt;int> G[10005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (auto y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; ++siz[cnt]; &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); int ans = 0; for (int i = 1; i &lt;= cnt; ++i) if (siz[i] > 1) ++ans; printf(\"%d\\n\", ans); return 0; &#125; 缩点 同无向图，将一个 SCC 缩成一个点，便是缩点。有向图在缩点之后可以得到 DAG，然后就可以进行拓扑排序之类的操作。 模板。在做的时候可以发现一个 SCC 内的点都可以到达，缩点之后的权值相当于 SCC 内点的权值综合，而且在 Tarjan 的过程中就可以进行 DP：设 f(s)f(s)f(s) 代表从 iii 开始的最大权值，给 SCC 编号时要进行转移，最后也要加上 SCC 内的点权和。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, ans = 0, a[10005], f[10005]; bool ins[10005]; int dfn[10005], low[10005], num = 0; int st[10005], tot = 0; int cnt = 0, c[10005], siz[10005]; vector &lt;int> G[10005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (auto y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y, sum = 0; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; ++siz[cnt]; sum += a[y]; for (auto v : G[y]) f[cnt] = max(f[cnt], f[c[v]]); &#125; while (x != y); f[cnt] += sum; ans = max(ans, f[cnt]); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); printf(\"%d\\n\", ans); return 0; &#125; 2-SAT 问题 2-SAT 问题。有 nnn 个变量，只有 01 两种取值，并有 mmm 个需要满足的形如“xix_ixi​ 为 aaa 或 xjx_jxj​ 为 bbb”（如果给定的是且逻辑也能转化为这种形式），求出一组使得所有条件满足的变量取值（可能无解），1≤n,m≤1061\\le n,m\\le 10^61≤n,m≤106。 由于每一个条件只和两个变量相关，可以被构建成图的边。 对于每个变量 xxx，我们建立两个点，x,¬xx,\\neg xx,¬x 分别表示 xxx 取真假。对于限制条件 a∨ba\\vee ba∨b，可以转化为 ¬a→b∧¬b→a\\neg a\\rightarrow b\\wedge \\neg b\\rightarrow a¬a→b∧¬b→a，连接这两条边。然后求出这张图的 SCC。 同一 SCC 内的变量值一定相等，那么 x,¬xx,\\neg xx,¬x 就不能在同一个 SCC 内。要满足所有的限制条件，需要 xxx 所在的 SCC 的拓扑序在 ¬x\\neg x¬x 所在的 SCC 的拓扑序之后才是真，所以要输出 c[i] &gt; c[i+n]。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int dfn[2000005], low[2000005], num; int st[2000005], tot = 0, col[2000005], cnt = 0; bool ins[2000005]; vector&lt;int> G[2000005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; col[y] = cnt; &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, a, v, b; scanf(\"%d%d%d%d\", &amp;u, &amp;a, &amp;v, &amp;b); G[u + (!a) * n].emplace_back(v + b * n); G[v + (!b) * n].emplace_back(u + a * n); &#125; for (int i = 1; i &lt;= n &lt;&lt; 1; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) if (col[i] == col[i + n]) return puts(\"IMPOSSIBLE\"), 0; puts(\"POSSIBLE\"); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", col[i + n] &lt; col[i]); return putchar('\\n'), 0; &#125; 还可以规定一个变量的值。比如规定它为真，那么就从 ¬x\\neg x¬x 向 xxx 连一条边即可。 欧拉图 从一笔画引出的一类连通性问题。 概述 给定一张图，若存在一条从一个点走到另一个点，不重不漏地经过图上所有的边一次，那么这条路称之为欧拉路。特别地，如果从一个点出发回到了一个点，那么这条路称之为欧拉回路。存在欧拉回路的图称之为欧拉图。不存在欧拉回路但是存在欧拉路的图称为半欧拉图。 在小学已经学过，对于无向图，如果图中度数为奇数的点是 000 或 222，那么这个图可以一笔画。当为 000 时，这个图是欧拉图，当为 222 时，存在欧拉路。 而对于一张有向图（显然，它至少需要弱连通），是欧拉图当且仅当其是一个强连通图且每个节点的入度和出度相等。如果这张图恰存在一个顶点的出度比入度小 111，另一个点入度比出度小 111，这个图存在欧拉路。 Hierholzer 算法 采用 DFS 不断找环，遍历当前节点 uuu 的所有出边，如果没有走过那就遍历，遍历完所有出边后将 uuu 加入欧拉路径，最后如果遍历的点的个数为 m+1m+1m+1，那么就得到了反着的欧拉路径，否则欧拉路径不存在。 在找欧拉回路时，可以从任意节点出发。否则，需要从根据性质找到的点出发。 模板，代码入下： 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, in[100005]; vector&lt;int> G[100005]; int tot, st[200005], cur[200005]; void dfs(int x) &#123; for (; cur[x] &lt; G[x].size(); ) dfs(G[x][cur[x]++]); st[++tot] = x; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); ++in[v]; &#125; int s = 0; for (int i = 1; i &lt;= n; ++i) &#123; sort(G[i].begin(), G[i].end()); if (abs(int(G[i].size()) - in[i]) > 1) return puts(\"No\"), 0; if (G[i].size() > in[i]) &#123; if (s) return puts(\"No\"), 0; else s = i; &#125; &#125; dfs(s ? s : 1); if (tot != m + 1) return puts(\"No\"), 0; for (int i = tot; i >= 1; --i) printf(\"%d \", st[i]); return putchar('\\n'), 0; &#125; 在使用其求无向图的欧拉路径时，需要标记其反向边不可以走了。 哈密顿图 通过图中所有顶点一次的通路称为哈密顿通路，通过图中所有顶点一次的回路称为哈密顿回路。判断一个图是否存在哈密顿回路是 NPC 的，不存在多项式时间复杂度的求法。 其它性质有时间再写。 Problemset 连通性的问题很有意思，我们来看几道题玩一下。 拓扑排序 基础中的基础。 [Luogu P1347] 排序 Portal. 使用拓扑排序。在过程中记录拓扑序（开一个 ans 数组记录出队的顺序）以便输出答案。矛盾意味着这不是一个 DAG，也就会导致有的点的入度在拓扑排序结束后依然不为 000。如果所有的读入都完成后依然没有唯一的拓扑序（通过记录一个点是第几轮入队的，第 nnn 轮就是唯一），那么就是有多解。 查看代码 #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> #define X first #define Y second #define mp make_pair using namespace std; int n, m, now, kase = 0; int inn[30], in[30], ans[30]; bool s[30]; vector &lt;int> G[30]; int topo(void) &#123; for (int i = 0; i &lt; 26; ++i) in[i] = inn[i]; queue &lt;pii> q; int sum = 0; for (int i = 0; i &lt; 26; ++i) if (s[i] == true &amp;&amp; in[i] == 0) q.push(mp(i, 1)); int res = 0, tot = 0; while (!q.empty()) &#123; int u = q.front().X, val = q.front().Y; q.pop(); ans[++tot] = u; res = max(res, val); for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; --in[v]; if (in[v] == 0) q.push(mp(v, val + 1)); &#125; &#125; if (res == n) return 1; else &#123; for (int i = 0; i &lt; 26; ++i) if (s[i] &amp;&amp; in[i] != 0) return 2; &#125; return 3; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); char gc[5]; while (m--) &#123; ++kase; scanf(\"%s\", gc); G[gc[0] - 'A'].push_back(gc[2] - 'A'); ++inn[gc[2] - 'A']; s[gc[0] - 'A'] = true, s[gc[2] - 'A'] = true; int t = topo(); if (t == 1) &#123; printf(\"Sorted sequence determined after %d relations: \", kase); for (int i = 1; i &lt;= n; ++i) printf(\"%c\", ans[i] + 'A'); printf(\".\\n\"); return 0; &#125; else if (t == 2) &#123; printf(\"Inconsistency found after %d relations.\\n\", kase); return 0; &#125; &#125; puts(\"Sorted sequence cannot be determined.\"); return 0; &#125; [Luogu P1113] 杂务 Portal. 记 f(i)f(i)f(i) 代表完成任务 iii 需要的最短时间。进行拓扑排序，统计一个节点的时候顺带更新它关联的 fff 值。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int len[10005], in[10005], f[10005]; vector &lt;int> G[10005]; void Kahn(void) &#123; queue &lt;int> q; for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) &#123; q.push(i); f[i] = len[i]; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; --in[G[u][i]]; if (in[G[u][i]] == 0) q.push(G[u][i]); f[G[u][i]] = max(f[G[u][i]], f[u] + len[G[u][i]]); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, len + i); while (scanf(\"%d\", &amp;y) == 1 &amp;&amp; y) &#123; G[y].push_back(x); ++in[x]; &#125; &#125; Kahn(); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; [HNOI2015] 菜肴制作 Portal. 很容易想到拓扑排序，但是这个顺序？我们想要让小的编号尽量靠前，但是直接用小根堆就错了：因为这道题要保证的不是字典序，而是小的尽量靠前，即使一个大的出现在了它前面。这样的话发现一个越大的数，它越在后面越有利，因为这样小的就跑到前面去了。 那么，建反图，进行拓扑排序，使用 Kahn 算法配上一个大根堆，这样可以保证最终大的尽可能地晚出，把小的顶到前面。 本题非常经典，强烈建议读者记住这个结论。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, in[100005], ans[100005]; vector &lt;int> G[100005]; void Kahn(void) &#123; int tot = 0; priority_queue &lt;int> q; for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) q.push(i); while (!q.empty()) &#123; int u = q.top(); q.pop(); ans[++tot] = u; for (int i = 0; i &lt; G[u].size(); ++i) &#123; --in[G[u][i]]; if (in[G[u][i]] == 0) q.push(G[u][i]); &#125; &#125; if (tot != n) puts(\"Impossible!\"); else &#123; for (int i = n; i >= 1; --i) printf(\"%d \", ans[i]); putchar('\\n'); &#125; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; memset(in, 0, sizeof(in)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) G[i].clear(); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[v].push_back(u); ++in[u]; &#125; Kahn(); &#125; return 0; &#125; [CSP-S2020] 函数调用 Portal. 操作三会导致别的函数调用很多次，而操作二可以看作是它之前的操作重复执行，因此可以考虑一操作执行的次数。对反图进行一次拓扑排序求出乘法标记，然后对正图进行拓扑排序来执行函数。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 998244353; int n, m, Q; int a[100005], cnt[100005], in[100005]; vector&lt;int> G[100005], E[100005]; int type[100005], p[100005], v[100005], mul[100005]; void Kahn1(void) &#123; // 在 E 上拓扑排序 queue&lt;int> q; for (int i = 0; i &lt;= m; ++i) &#123; in[i] = G[i].size(); if (!in[i]) q.push(i); &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v : E[u]) &#123; mul[v] = 1ll * mul[v] * mul[u] % P; --in[v]; if (!in[v]) q.push(v); &#125; &#125; &#125; void Kahn2(void) &#123; queue&lt;int> q; for (int i = 0; i &lt;= m; ++i) &#123; in[i] = E[i].size(); if (!in[i]) q.push(i); &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); int tag = 1; reverse(G[u].begin(), G[u].end()); // 后调用的函数会让前面的重复执行 for (int v : G[u]) &#123; cnt[v] = (cnt[v] + 1ll * cnt[u] * tag) % P; tag = 1ll * tag * mul[v] % P; --in[v]; if (!in[v]) q.push(v); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); scanf(\"%d\", &amp;m); mul[0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d\", type + i); mul[i] = 1; if (type[i] == 1) scanf(\"%d%d\", p + i, v + i); else if (type[i] == 2) scanf(\"%d\", mul + i); else &#123; int len; scanf(\"%d\", &amp;len); while (len--) &#123; int x; scanf(\"%d\", &amp;x); G[i].emplace_back(x); E[x].emplace_back(i); &#125; &#125; &#125; scanf(\"%d\", &amp;Q); cnt[0] = 1; while (Q--) &#123; int x; scanf(\"%d\", &amp;x); G[0].emplace_back(x); E[x].emplace_back(0); &#125; Kahn1(); Kahn2(); for (int i = 1; i &lt;= n; ++i) a[i] = 1ll * a[i] * mul[0] % P; for (int i = 1; i &lt;= m; ++i) if (type[i] == 1) a[p[i]] = (a[p[i]] + 1ll * cnt[i] * v[i]) % P; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); putchar('\\n'); return 0; &#125; 连通性问题 这里的题都比较基础。 [Luogu P2002] 消息扩散 Portal. 先求出 SCC，如果两个 SCC 相连，那么只需要发布一个消息就可以了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int st[100005], tot = 0; bool ins[100005]; int dfn[100005], low[100005], num = 0; int cnt = 0, c[100005]; vector&lt;int> G[100005]; bool flag[100005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) for (int j : G[i]) if (c[i] != c[j]) flag[c[j]] = true; int ans = 0; for (int i = 1; i &lt;= cnt; ++i) ans += (flag[i] == 0); printf(\"%d\\n\", ans); return 0; &#125; [USACO03FALL] 受欢迎的牛 G Portal. 只有当出度为 000 的 SCC 仅有一个时，才会有明星出现，数量是这个 SCC 的大小。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int st[10005], tot = 0; bool ins[10005]; int out[10005]; int c[10005], siz[10005], cnt = 0; int dfn[10005], low[10005], num = 0; vector &lt;int> G[10005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; siz[cnt] += 1; c[y] = cnt; &#125; while (x != y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) for (int j : G[i]) if (c[i] != c[j]) ++out[c[i]]; int ans = 0, flag = 0; for (int i = 1; i &lt;= cnt; ++i) if (out[i] == 0) ans = siz[i], ++flag; if (flag > 1) puts(\"0\"); else printf(\"%d\\n\", ans); return 0; &#125; [USACO5.3] Network of Schools Portal. 第二问的答案是缩点之后入度为 000 的点的个数和出度为 000 的点的个数的最大值。特别地，当只有一个 SCC 时，答案为 000。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n; int st[10005], tot = 0; bool ins[10005]; int dfn[10005], low[10005], num = 0; int cnt = 0, c[10005]; vector &lt;int> G[10005]; bool flag[10005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; &#125; while (x != y); &#125; &#125; int in[10005], out[10005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int j; while (scanf(\"%d\", &amp;j) == 1 &amp;&amp; j) G[i].push_back(j); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) for (int j : G[i]) if (c[i] != c[j]) &#123; flag[c[j]] = true; ++in[c[j]], ++out[c[i]]; &#125; int ans = 0, p = 0, q = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; ans += (flag[i] == 0); p += (in[i] == 0); q += (out[i] == 0); &#125; printf(\"%d\\n%d\\n\", ans, cnt == 1 ? 0 : max(p, q)); return 0; &#125; [APIO2009] 抢掠计划 Portal. 显然是缩点后进行 DP，不过这里显然用以 iii 为终点的状态比较方便，所以 Tarjan 之后要重新建图。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, s, p; int low[500005], dfn[500005], num = 0; int st[500005], tot = 0, f[500005]; int val[500005], sum[500005], c[500005], cnt = 0; bool ins[500005]; vector&lt;int> G[500005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; sum[cnt] += val[y]; &#125; while (x != y); &#125; &#125; int in[500005]; vector&lt;int> G2[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); &#125; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", val + i); scanf(\"%d%d\", &amp;s, &amp;p); tarjan(s); for (int i = 1; i &lt;= n; ++i) if (c[i]) for (int j : G[i]) if (c[i] != c[j]) &#123; G2[c[i]].push_back(c[j]); ++in[c[j]]; &#125; queue&lt;int> q; q.push(c[s]); f[c[s]] = sum[c[s]]; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v : G2[u]) &#123; f[v] = max(f[v], f[u] + sum[v]); --in[v]; if (in[v] == 0) q.push(v); &#125; &#125; int ans = 0; for (int i = 1; i &lt;= p; ++i) &#123; int x; scanf(\"%d\", &amp;x); ans = max(ans, f[c[x]]); &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P2656] 采蘑菇 Portal. 显然一个 SCC 内的蘑菇可以采干净，那么 SCC 缩点之后在 DAG 上 DP 即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, s; int dfn[80005], low[80005], num = 0; int st[80005], tot = 0; bool ins[80005]; int cnt, c[80005]; vector&lt;int> G[80005]; struct edge &#123; int u, v, w; long double d; edge(int u = 0, int v = 0, int w = 0, long double d = 0) : u(u), v(v), w(w), d(d) &#123;&#125; &#125;; vector&lt;edge> edges; inline void addedge(int u, int v, int w, long double d) &#123; edges.emplace_back(edge(u, v, w, d)); G[u].emplace_back(edges.size() - 1); &#125; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].v; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); &#125; if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; &#125; while (x != y); &#125; &#125; int val[80005], in[80005], f[80005], ans = 0; vector&lt;edge> G2[80005]; void Kahn(void) &#123; queue&lt;int> q; q.push(c[s]); while (!q.empty()) &#123; int u = q.front(); q.pop(); f[u] += val[u]; for (int i = 0; i &lt; G2[u].size(); ++i) &#123; edge &amp;e = G2[u][i]; f[e.v] = max(f[e.v], f[u] + e.w); --in[e.v]; if (in[e.v] == 0) q.push(e.v); &#125; ans = max(ans, f[u]); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v, w; long double d; scanf(\"%d%d%d%Lf\", &amp;u, &amp;v, &amp;w, &amp;d); addedge(u, v, w, d); &#125; scanf(\"%d\", &amp;s); tarjan(s); for (int i = 0; i &lt; edges.size(); ++i) &#123; edge &amp;e = edges[i]; if (dfn[e.u] &amp;&amp; dfn[e.v]) &#123; if (c[e.u] == c[e.v]) &#123; while (e.w) &#123; val[c[e.u]] += e.w; e.w *= e.d; &#125; &#125; else &#123; G2[c[e.u]].push_back(edge(c[e.u], c[e.v], e.w, e.d)); ++in[c[e.v]]; &#125; &#125; &#125; Kahn(); printf(\"%d\\n\", ans); return 0; &#125; [USACO06JAN] Redundant Paths G Portal. 直接求出 e-DCC 缩点后的树，然后将叶子配对即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int from, to; edge(int from = 0, int to = 0) : from(from), to(to) &#123;&#125; &#125;; int n, m, num = 0, cnt = 0; int dfn[5005], low[5005], c[5005], in[5005]; bool bridge[20005]; vector &lt;edge> edges; vector &lt;int> G[5005]; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x, int in_edge) &#123; dfn[x] = low[x] = ++num; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (!dfn[y]) &#123; tarjan(y, G[x][i]); low[x] = min(low[x], low[y]); if (dfn[x] &lt; low[y]) bridge[G[x][i]] = bridge[G[x][i] ^ 1] = true; &#125; else if (G[x][i] != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); &#125; &#125; void dfs(int x) &#123; c[x] = cnt; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].to; if (c[y] || bridge[G[x][i]]) continue; dfs(y); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v), addedge(v, u); &#125; tarjan(1, -1); int res = 0; for (int i = 1; i &lt;= n; ++i) if (!c[i]) &#123; ++cnt; dfs(i); &#125; for (int i = 0; i &lt; edges.size(); i += 2) // 统计叶子的个数，入度为 1 的是叶子 if (c[edges[i].from] != c[edges[i].to]) &#123; ++in[c[edges[i].from]]; ++in[c[edges[i].to]]; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) if (in[i] == 1) ++ans; printf(\"%d\\n\", (ans + 1) / 2); return 0; &#125; 连通性的应用 这里的题都需要一些简单分析能力。 [CF1777E] Edge Reverse Portal. 显然是二分答案，可以反转的边相当于无向边，将图 SCC 缩点后应该恰好有一个入度为 000 的点才能满足条件。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int u, v, w; bool operator &lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125; &#125; e[200005]; int n, m; vector&lt;int> G[200005]; int dfn[200005], low[200005], num, st[200005], tot; int cnt, col[200005], deg[200005]; bool ins[200005]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (dfn[x] == low[x]) &#123; int y; ++cnt; do ins[y = st[tot--]] = false, col[y] = cnt; while (x != y); &#125; &#125; bool P(int x) &#123; for (int i = 1; i &lt;= n; ++i) G[i].clear(), dfn[i] = ins[i] = deg[i] = 0; for (int i = 1; i &lt;= m; ++i) &#123; G[e[i].u].emplace_back(e[i].v); if (i &lt;= x) G[e[i].v].emplace_back(e[i].u); &#125; num = tot = cnt = 0; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int u = 1; u &lt;= n; ++u) for (int v : G[u]) if (col[u] != col[v]) ++deg[col[v]]; int res = 0; for (int i = 1; i &lt;= cnt; ++i) res += (deg[i] == 0); return res == 1; &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); sort(e + 1, e + m + 1); int L = -1, R = m + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) R = mid; else L = mid; &#125; printf(\"%d\\n\", R != m + 1 ? e[R].w : -1); &#125; return 0; &#125; [NOI2017] 游戏 Portal. 我们只要枚举 xxx 是 AAA 还是 BBB，就可以覆盖所有选择的地图，这样就是一个 2-SAT 模板。时间复杂度为 O(2d(n+m))O(2^d(n+m))O(2d(n+m))。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, d; char s[50005]; int dfn[100005], low[100005], num, st[100005], tot; bool ins[100005], flag; vector&lt;int> G[100005]; int col[100005], cnt; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) tarjan(y), low[x] = min(low[x], low[y]); else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; ++cnt; int y; do ins[y = st[tot--]] = false, col[y] = cnt; while (x != y); &#125; &#125; int a[100005], b[100005]; char x[100005], y[100005]; int pos[10]; char val[10]; bool c[3][3]; // 当不允许使用 i 时，使用了 i+1 为真，否则为假 bool solve(void) &#123; num = tot = cnt = 0; for (int i = 1; i &lt;= n &lt;&lt; 1; ++i) dfn[i] = ins[i] = 0, G[i].clear(); for (int i = 1; i &lt;= d; ++i) s[pos[i]] = val[i]; for (int i = 1; i &lt;= m; ++i) &#123; if (s[a[i]] == x[i]) continue; bool p = c[s[a[i]] - 'A'][x[i] - 'A'], q = c[s[b[i]] - 'A'][y[i] - 'A']; if (s[b[i]] == y[i]) &#123; G[a[i] + (!p) * n].emplace_back(a[i] + p * n); // 此时不能满足 a 自己的限制条件，必须让其为假 continue; &#125; G[a[i] + (!p) * n].emplace_back(b[i] + (!q) * n); G[b[i] + q * n].emplace_back(a[i] + p * n); &#125; for (int i = 1; i &lt;= n &lt;&lt; 1; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) if (col[i] == col[i + n]) return 0; for (int i = 1; i &lt;= n; ++i) putchar((s[i] - 'A' + (col[i + n] > col[i] ? 1 : 2)) % 3 + 'A'); return putchar('\\n'), 1; &#125; void dfs(int x) &#123; if (flag) return; if (x > d) return flag = solve(), void(); val[x] = 'A'; dfs(x + 1); val[x] = 'B'; dfs(x + 1); &#125; int main(void) &#123; scanf(\"%d%d%s%d\", &amp;n, &amp;d, s + 1, &amp;m); d = 0; c[0][1] = c[1][2] = c[2][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; s[i] -= 32; if (s[i] == 'X') pos[++d] = i; &#125; for (int i = 1; i &lt;= m; ++i) scanf(\"%d %c %d %c\", a + i, x + i, b + i, y + i); dfs(1); if (!flag) puts(\"-1\"); return 0; &#125; [yLOI2018] 锦鲤抄 Portal.给你一张有向图，每个点有一个点权。任意时刻你可以任意选择一个有入度的点，获得它的点权并把它和它的出边从图上删去。最多能选择 kkk 个点，求最多能获得多少点权。n≤5×105n \\leq 5 \\times 10^5n≤5×105。 先考虑一个 DAG 的情况。我们只要先找到需要删除的点（能够被删除且是前 kkk 大），然后按照这些点的拓扑序的倒序删点，那么可以发现这些点都可以被删去，并不会影响后面的点的入度。 因此对原图进行 SCC 缩点，这样整体上的逻辑是不变的，我们只需要单独考虑一下 SCC 内部怎么删。看一个简单的： 现在 2,3,42,3,42,3,4 在一个 SCC 内，由于这个 SCC 是有一个入度的 1→21\\rightarrow 21→2，因此只要不先删 222，那么这个 SCC 就可以删干净。但是如果没有 1→21\\rightarrow 21→2 这条边呢？那么 SCC 删完必须留一个点（只需要从任意一个位置开始顺着环删，最后就会剩一个点），但是！如果这个 SCC 内存在自环，那么它还是可以被删干净的。 因此我们只需要排除掉本来就入度为 000 的点和一个没有入度没有自环的 SCC 内的点权最小的点，剩下的点取前 kkk 大即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, k; int w[500010]; int dfn[500010], low[500010], num = 0; int st[500010], tot = 0; int cnt = 0, c[500010]; bool ins[500010]; vector&lt;int> G[500010]; vector&lt;int> scc[500010]; bool self[500010]; bool selfscc[500010]; void tarjan(int x) &#123; dfn[x] = low[x] = ++num; ins[st[++tot] = x] = true; for (int y : G[x]) if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (ins[y]) low[x] = min(low[x], dfn[y]); if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; ins[y] = false; c[y] = cnt; scc[cnt].push_back(y); selfscc[cnt] |= self[y]; &#125; while (x != y); &#125; &#125; int in[500010]; int val[500010], tot2 = 0; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", w + i); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if (u != v) G[u].push_back(v); else self[u] = true; &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) for (int j : G[i]) if (c[i] != c[j]) ++in[c[j]]; for (int i = 1; i &lt;= cnt; ++i) &#123; int minn = 1e9, flag = false; for (int j : scc[i]) minn = min(minn, w[j]); for (int j : scc[i]) if (in[i] || selfscc[i]) val[++tot2] = w[j]; else if (w[j] > minn || flag) val[++tot2] = w[j]; else flag = true; &#125; sort(val + 1, val + tot2 + 1, greater&lt;int>()); int ans = 0; for (int i = 1; i &lt;= k; ++i) ans += val[i]; printf(\"%d\\n\", ans); return 0; &#125; [CF51F] Caterpillar Portal. 一个毛毛虫定义为一个无向联通无环图上存在一条路径 ppp 使得任意一个节点距离 ppp 的距离至多为 111。毛毛虫可以包含自环（一条从一个顶点连向自己的边），但是不可以包含重边。这个图片是一个毛毛虫的例子：现在你有一张无向图 GGG（不一定联通） 。你被允许做一些合并操作。每次操作将两个顶点合并成一个顶点。每次选择任意两个顶点 a,b(a≠b)a,b (a\\neq b)a,b(a=b)，这些顶点以及它们的边（至少连接着 a,ba,ba,b 中一个点的边）将被删除，而后顶点 www 会被加入，以及对于每条边 (x,a),(x,b)(x,a),(x,b)(x,a),(x,b) 都会有新边 (x,w)(x,w)(x,w) 加入。如果有一条边 (a,b)(a,b)(a,b) 它会被转换成自环 (w,w)(w,w)(w,w)。得到的图（操作结束后）可能会有重边。我们注意到这个操作减少了 111 个顶点，却没有改变边的数量。合并操作可以简单的描述为将图中两个顶点合并为图中的一个顶点并继承原来所有的边。你可以连续地使用合并操作，从而将给定的图转变成一个毛毛虫。求出这张图转变成一个毛毛虫的最少操作次数。 毛毛虫上不能长出来环，所以把每一个 e-DCC 缩点，图会变成一个森林，我们需要处理每一棵树，然后把这些树合并，需要树的个数减去一的代价。 由于环必须要合并，如果要直接统计操作次数还需要统计环的大小，不妨换一个思路，默认所有点都需要合并，然后减去不需要合并的。 现在考虑最后一个问题，一棵树怎么处理？直觉告诉我们：这条路径 ppp 应该是长度为 ddd 直径，这样才能让要动的点更少。直径可以让我们少合并 ddd 个点，叶子上的点也可以不用合并（画个图看看），但是直径两端还有两个叶子，所以要减去。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct edge &#123; int u, v; edge(int u = 0, int v = 0) : u(u), v(v) &#123;&#125; &#125;; int n, m, cnt = 0, ans = 0, c[50005]; int num = 0, dfn[50005], low[50005]; int st[50005], tot = 0; bool vis[50005]; vector &lt;int> G[50005], F[50005]; vector &lt;edge> edges; inline void addedge(int u, int v) &#123; edges.push_back(edge(u, v)); G[u].push_back(edges.size() - 1); &#125; void tarjan(int x, int in_edge) &#123; dfn[x] = low[x] = ++num; st[++tot] = x; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = edges[G[x][i]].v; if (!dfn[y]) &#123; tarjan(y, G[x][i]); low[x] = min(low[x], low[y]); &#125; else if (G[x][i] != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); &#125; if (low[x] == dfn[x]) &#123; int y; ++cnt; do &#123; y = st[tot--]; c[y] = cnt; &#125; while (x != y); &#125; &#125; vector &lt;int> li; int d[50005]; void dfs(int x, int fa) &#123; d[x] = d[fa] + 1; for (int y : F[x]) if (y != fa) dfs(y, x); &#125; void find(int x) &#123; li.emplace_back(x); vis[x] = true; for (int i : F[x]) if (!vis[i]) find(i); &#125; void kill(int x) &#123; if (F[x].empty()) return ans += 1, void(); li.clear(); find(x); dfs(x, 0); int u = x, leaf = 0; for (int y : li) if (d[y] > d[u]) u = y; d[u] = 0; dfs(u, 0); for (int y : li) if (d[y] > d[u]) u = y; for (int y : li) leaf += (F[y].size() == 1); ans += d[u] + leaf - 2; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i, -1); for (int i = 0; i &lt; edges.size(); ++i) if (c[edges[i].u] != c[edges[i].v]) F[c[edges[i].u]].push_back(c[edges[i].v]); int ret = -1; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) ++ret, kill(i); printf(\"%d\\n\", n - ans + ret); return 0; &#125; 欧拉路问题 与欧拉路径相关的问题。 [Luogu P1341] 无序字母对 Portal. 模板，找无向图的一笔画。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int H(char x) &#123; if (x >= 'A' &amp;&amp; x &lt;= 'Z') return x - 'A' + 1; return x - 'a' + 27; &#125; char V(int x) &#123; if (x &lt;= 26) return x - 1 + 'A'; return x - 27 + 'a'; &#125; int m, G[60][60], tot, in[60]; char st[1005]; void dfs(int x) &#123; for (int i = 1; i &lt;= 52; ++i) if (G[x][i]) &#123; G[x][i] = G[i][x] = false; dfs(i); &#125; st[++tot] = V(x); &#125; int main(void) &#123; scanf(\"%d\", &amp;m); int sta = 1e9; for (int i = 1; i &lt;= m; ++i) &#123; char s[5]; scanf(\"%s\", s); int u = H(s[0]), v = H(s[1]); G[u][v] = G[v][u] = 1; ++in[u]; ++in[v]; sta = min(&#123;sta, u, v&#125;); &#125; int cnt = 0, h = 0; for (int i = 1; i &lt;= 52; ++i) if (in[i] &amp; 1) &#123; ++cnt; if (!h) h = i; &#125; if (cnt == 1 || cnt > 2) return puts(\"No Solution\"), 0; dfs(h ? h : sta); if (tot != m + 1) return puts(\"No Solution\"), 0; for (int i = tot; i >= 1; --i) putchar(st[i]); return putchar('\\n'), 0; &#125; [CF1152E] Neko and Flashback Portal. 对于一个 iii，有 bi=min⁡{ai,ai+1},ci=max⁡{ai,ai+1}b_i=\\min\\{a_i,a_{i+1}\\},c_i=\\max\\{a_i,a_{i+1}\\}bi​=min{ai​,ai+1​},ci​=max{ai​,ai+1​}，也就是说 bi,cib_i,c_ibi​,ci​ 各是 ai,ai+1a_i,a_{i+1}ai​,ai+1​ 其中的一个（当然需要 bi≤cib_i\\le c_ibi​≤ci​，否则无解）。 注意这个输出方式，ppp 的作用是将 aaa 排列，也就是说我们只需要求出 aaa 有哪些数组成即可。将给定的 ai,ai+1a_i,a_{i+1}ai​,ai+1​ 的关系看成一条无向边，走过这个路径就相当于满足了一个限制条件。那么在图上找出欧拉路，就可以得到一个满足所有的限制条件的序列 aaa（需要先离散化后再建图）。时间复杂度 O((n+m)log⁡m)O((n+m)\\log m)O((n+m)logm)。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> using namespace std; int n, tot, cur[100005], deg[200005], st[200005]; int b[100005], c[100005], B[200005]; vector&lt;int> edges; vector&lt;int> G[200005]; inline void addedge(int u, int v) &#123; edges.emplace_back(v); G[u].emplace_back(edges.size() - 1); ++deg[v]; &#125; void dfs(int x) &#123; for (; cur[x] &lt; G[x].size(); ++cur[x]) &#123; int y = edges[G[x][cur[x]]]; if (y) &#123; edges[G[x][cur[x]]] = 0, edges[G[x][cur[x]] ^ 1] = 0; dfs(y); &#125; &#125; st[++tot] = x; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) scanf(\"%d\", b + i), B[++tot] = b[i]; for (int i = 1; i &lt; n; ++i) scanf(\"%d\", c + i), B[++tot] = c[i]; sort(B + 1, B + tot + 1); tot = unique(B + 1, B + tot + 1) - (B + 1); for (int i = 1; i &lt; n; ++i) &#123; b[i] = lower_bound(B + 1, B + tot + 1, b[i]) - B; c[i] = lower_bound(B + 1, B + tot + 1, c[i]) - B; if (b[i] > c[i]) return puts(\"-1\"), 0; addedge(b[i], c[i]); addedge(c[i], b[i]); &#125; int cnt = 0, h = 0; for (int i = 1; i &lt;= tot; ++i) if (deg[i] &amp; 1) &#123; ++cnt; if (!h) h = i; &#125; if (cnt == 1 || cnt > 2) return puts(\"-1\"), 0; tot = 0; dfs(h ? h : 1); if (tot != n) return puts(\"-1\"), 0; for (int i = tot; i >= 1; --i) printf(\"%d \", B[st[i]]); putchar('\\n'); return 0; &#125; [CF36E] Two Paths Portal. 一道值得一想不值得一写的欧拉路。 原图中最多只能有两个连通块，有两个时就是分别找欧拉路，下面来看只有一个。 如果它只有零个或两个奇点，那么有一个欧拉路，我们把这条路径分开一条边作为一部分，这样就是两部分了（分不出来就无解）！ 如果有四个奇点，那么是两个（半）欧拉图拼起来的，因此考虑给两个奇点连一条假边，跑欧拉路，输出的时候以这条假边为分界输出两部分。 由于要输出边的编号，因此用链式前向星方便一些，搞点的时候遍历所有的边寻找对应的是哪一条。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, edgecnt = 1, dcc, oddcnt, head[10005], d[10005]; int dccOdd[10005], v[10005], U[10005], V[10005], b[20005]; bool vis[10005], printed[10005]; vector&lt;int> ans; struct Edge &#123; int to, nxt; &#125; G[20005]; inline void addedge(int u, int v) &#123; G[++edgecnt] = &#123;v, head[u]&#125;; head[u] = edgecnt; ++d[v]; &#125; void mark(int x) &#123; v[x] = dcc; dccOdd[dcc] += d[x] &amp; 1; oddcnt += d[x] &amp; 1; for (int i = head[x], y; i; i = G[i].nxt) if (!v[y = G[i].to]) mark(y); &#125; void dfs(int u) &#123; if (!d[u]) return ans.emplace_back(u), void(); for (int i = head[u], v; i; i = G[i].nxt) if (!vis[i >> 1]) &#123; vis[i >> 1] = true, --d[v = G[i].to], --d[u]; dfs(v); &#125; ans.emplace_back(u); &#125; void print(int l, int r) &#123; for (int i = l; i &lt; r; ++i) for (int j = head[ans[i]]; j; j = G[j].nxt) if (!printed[j >> 1] &amp;&amp; j >> 1 &lt;= m &amp;&amp; ans[i + 1] == G[j].to) &#123; if (i != l) putchar(' '); printed[j >> 1] = true; printf(\"%d\", j >> 1); break; &#125; putchar('\\n'); &#125; int main(void) &#123; freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", U + i, V + i); b[i &lt;&lt; 1] = U[i]; b[(i &lt;&lt; 1) - 1] = V[i]; &#125; sort(b + 1, b + 2 * m + 1); n = unique(b + 1, b + 2 * m + 1) - (b + 1); for (int i = 1; i &lt;= m; ++i) &#123; U[i] = lower_bound(b + 1, b + n + 1, U[i]) - b; V[i] = lower_bound(b + 1, b + n + 1, V[i]) - b; addedge(U[i], V[i]); addedge(V[i], U[i]); &#125; for (int i = 1; i &lt;= n; ++i) if (!v[i]) ++dcc, mark(i); if (oddcnt > 4 || dcc > 2) return puts(\"-1\"), 0; if (dcc == 1) &#123; int ond1 = 0, ond2 = 0, st = 0; if (oddcnt == 0) dfs(1); else if (oddcnt == 2) &#123; for (int i = 1; i &lt;= n; ++i) if (d[i] &amp; 1) &#123; dfs(i); break; &#125; &#125; else &#123; for (int i = 1; i &lt;= n &amp;&amp; !st; ++i) if (d[i] &amp; 1) &#123; if (!ond1) ond1 = i; else if (!ond2) ond2 = i; else st = i; &#125; addedge(ond1, ond2), addedge(ond2, ond1); // 两个奇数点加一条虚拟边 ++d[ond1], ++d[ond2]; dfs(st); &#125; if (oddcnt != 4) &#123; if (ans.size() &lt;= 2) return puts(\"-1\"), 0; printf(\"%d\\n\", 1); print(0, 1); printf(\"%d\\n\", ans.size() - 2); print(1, ans.size()); &#125; else &#123; int _pre = 0; for (int i = 0; i &lt; ans.size(); ++i) &#123; if ((_pre == ond1 &amp;&amp; ans[i] == ond2) || (_pre == ond2 &amp;&amp; ans[i] == ond1)) &#123; printf(\"%d\\n\", i - 1); print(0, i - 1); printf(\"%d\\n\", m - i + 1); print(i, ans.size()); break; &#125; _pre = ans[i]; &#125; &#125; &#125; else &#123; if (dccOdd[1] > 2 || dccOdd[2] > 2) return puts(\"-1\"), 0; int nowVis = 0; for (int i = 1; i &lt;= n; ++i) if ((!nowVis || v[i] != nowVis) &amp;&amp; bool(dccOdd[v[i]]) == (d[i] &amp; 1)) &#123; dfs(i); printf(\"%d\\n\", ans.size() - 1); print(0, ans.size()); ans.clear(); if (nowVis) break; nowVis = v[i]; &#125; &#125; return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"九至十一月 Codeforces 题目选作","slug":"default/old/cf202091","date":"2022-09-10T00:00:00.000Z","updated":"2022-09-10T00:00:00.000Z","comments":true,"path":"d0a8ff8d/","link":"","permalink":"https://james1badcreeper.github.io/d0a8ff8d/","excerpt":"进入 NOIP 计划后期，开始针对性地刷一些 CF 题。","text":"进入 NOIP 计划后期，开始针对性地刷一些 CF 题。 构造与其它技巧 也就是杂题，包括构造，简单方法（如双指针）和思维题等。 1400~1500 Rating 值为 1400~1500 的杂题。 [CF1697C] awoo’s Favorite Problem Portal. 可以发现 a 只能往后走，而 c 只能往前走，而且 a, b 与 b, c 的相对位置不变。 查看代码 #include &lt;iostream> #include &lt;string> #include &lt;cstring> using namespace std; int n; int suma[2][100005], sumc[2][100005]; string a, b; int main(void) &#123; int T; cin >> T; while (T--) &#123; cin >> n >> a >> b; bool flag = true; int b0 = 0, b1 = 0, i = 0, j = 0; for (; i &lt; n; ++i) &#123; while (b[j] == 'b') ++b1, ++j; // 找到 t 中第一个不是 b 的，以匹配当前字符 if (a[i] == 'b') ++b0; // 当前的 s 的这个字符是 b，跳过 else &#123; if (a[i] != b[j] || a[i] == 'a' &amp;&amp; i > j || a[i] == 'c' &amp;&amp; i &lt; j) &#123; flag = false; break; &#125; ++j; // 这个字符匹配过了 &#125; &#125; while (j &lt; n) b1 += (b[j] == 'b'), ++j; if (b0 != b1) flag = false; cout &lt;&lt; (flag ? \"YES\" : \"NO\") &lt;&lt; '\\n'; &#125; return 0; &#125; [CF1728C] Digital Logarithm Portal. 使用两个大根堆贪心地维护即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;queue> using namespace std; int calc(int x) &#123; if (x == 0) return 1; int res = 0; while (x) &#123; ++res; x /= 10; &#125; return res; &#125; void solve(void) &#123; int n; priority_queue &lt;int> a, b; cin >> n; for (int i = 1, x; i &lt;= n; ++i) cin >> x, a.push(x); for (int i = 1, x; i &lt;= n; ++i) cin >> x, b.push(x); int ans = 0; while (!a.empty()) &#123; int x = a.top(), y = b.top(); if (x == y) a.pop(), b.pop(); else if (x &lt; y) b.pop(), b.push(calc(y)), ++ans; else a.pop(), a.push(calc(x)), ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; [CF1722G] Even-Odd XOR Portal. a=b ⟺ a xor b=0a=b \\iff a~\\text{xor}~ b=0a=b⟺a xor b=0，也就是序列的异或和为 000，根据此构造即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; void solve(void) &#123; int n = 0, w = 0, a[2]; cin >> n; for (int i = 1; i &lt; n - 2; ++i) cout &lt;&lt; i &lt;&lt; ' ', w ^= i; cout &lt;&lt; (1 &lt;&lt; 28) &lt;&lt; ' ' &lt;&lt; (1 &lt;&lt; 29) &lt;&lt; ' '; w ^= (1 &lt;&lt; 28); w ^= (1 &lt;&lt; 29); cout &lt;&lt; w &lt;&lt; endl; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125; DP 这里是一些动态规划的题目。 1900~2100 这个档的 DP 题一般都比较基础。 [CF229D] Towers Portal. 令 f(i,j)f(i,j)f(i,j) 代表考虑前 iii 个，将 (j,i](j,i](j,i] 合并起来的最小代价。写好方程后发现具有单调性，然后就只剩一维了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, s[5005]; int f[5005], g[5005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", s + i); s[i] += s[i - 1]; &#125; memset(f, 0x3f, sizeof(f)); f[0] = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; i; ++j) if (s[i] - s[j] >= s[j] - s[g[j]]) &#123; f[i] = f[j] + i - j - 1; g[i] = j; &#125; printf(\"%d\\n\", f[n]); return 0; &#125; 单调队列可以将其优化到 O(n)O(n)O(n)。 [CF9D] How many trees? Portal. 求高度不超过 hhh，有 nnn 个点的二叉树个数。 直接 f(i,j)f(i,j)f(i,j)，然后递推。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, h; i64 f[40][40]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;h); for (int i = 0; i &lt;= n; ++i) f[0][i] = 1; for (int i = 1; i &lt;= n; ++i) // loop h for (int j = 1; j &lt;= n; ++j) for (int k = 0; k &lt; j; ++k) f[j][i] += f[k][i - 1] * f[j - k - 1][i - 1]; printf(\"%lld\\n\", f[n][n] - f[n][h - 1]); return 0; &#125; [CF1012C] Hills Portal. 设 f(i,j,k)f(i,j,k)f(i,j,k) 为当前考虑到 iii，kkk 代表当前是不是需要满足的，jjj 代表总共满足的个数即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int n; int a[5005]; int f[5005][2505][2]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0x3f, sizeof(f)); f[0][0][0] = f[1][0][0] = f[1][1][1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; f[i][0][0] = 0; for (int j = 1; j &lt;= (i + 1) / 2; ++j) &#123; f[i][j][0] = min(f[i - 1][j][0], f[i - 1][j][1] + max(0, a[i] - a[i - 1] + 1)); f[i][j][1] = min(f[i - 2][j - 1][0] + max(0, a[i - 1] - a[i] + 1), f[i - 2][j - 1][1] + max(&#123;0, a[i - 1] - a[i - 2] + 1, a[i - 1] - a[i] + 1&#125;)); &#125; &#125; for (int i = 1; i &lt;= (n + 1) / 2; ++i) printf(\"%d \", min(f[n][i][0], f[n][i][1])); putchar('\\n'); return 0; &#125; [CF533B] Work Group Portal. 设 f[x][0/1]f[x][0/1]f[x][0/1] 代表奇数或偶数。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;algorithm> using namespace std; typedef long long i64; const i64 INF = 1e18; int n, root, a[200005]; i64 f[200005][2], ans = 0; vector &lt;int> G[200005]; void dp(int x) &#123; f[x][0] = 0, f[x][1] = -INF; for (auto y : G[x]) &#123; dp(y); i64 p = f[x][0], q = f[x][1]; f[x][0] = max(p + f[y][0], q + f[y][1]); f[x][1] = max(p + f[y][1], q + f[y][0]); &#125; f[x][1] = max(f[x][1], f[x][0] + a[x]); ans = max(&#123;ans, f[x][0], f[x][1]&#125;); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;x, a + i); if (x != -1) G[x].push_back(i); else root = i; &#125; dp(root); printf(\"%lld\\n\", ans); return 0; &#125; [CF1060E] Sergey and Subway Portal. 不加边的答案很容易计算，加边之后长度应该除以 222，但是奇数长度是需要修正的，应该加上奇数长度的路径数再除。奇数长度的路径数利用深度的奇偶性就能简单计算。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; i64 ans = 0; int n, dep[200005], siz[200005], cnt[2]; vector &lt;int> G[200005]; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1; siz[x] = 1; cnt[dep[x] &amp; 1] += 1; for (auto y : G[x]) &#123; if (y == fa) continue; dfs(y, x); siz[x] += siz[y]; ans += 1ll * siz[y] * (n - siz[y]); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, x, y; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); &#125; dfs(1, 0); printf(\"%lld\\n\", (ans + 1ll * cnt[0] * cnt[1]) / 2); return 0; &#125; DS 这里是一些数据结构的题目。 2000 Rating 值为 2000~2100 的简单数据结构。 [CF242E] XOR on Segment Portal. 由于 xor 的每一位可以分开计算，而且数的值域很小，可以开 20 棵线段树对每一位进行统计。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, m; int a[100005]; int T[400005][20], tag[400005]; inline void maintain(int o) &#123; for (int i = 0; i &lt; 20; ++i) T[o][i] = T[o &lt;&lt; 1][i] + T[o &lt;&lt; 1 | 1][i]; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; for (int i = 0; i &lt; 20; ++i) if ((a[l] >> i) &amp; 1) T[o][i] = 1; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; inline void pushdown(int o, int l, int r) &#123; if (!tag[o]) return; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; for (int i = 0; i &lt; 20; ++i) if ((tag[o] >> i) &amp; 1) &#123; T[ls][i] = mid - l + 1 - T[ls][i]; T[rs][i] = r - mid - T[rs][i]; &#125; tag[ls] ^= tag[o], tag[rs] ^= tag[o]; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; for (int i = 0; i &lt; 20; ++i) if ((k >> i) &amp; 1) T[o][i] = r - l + 1 - T[o][i]; tag[o] ^= k; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); maintain(o); &#125; i64 query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; i64 res = 0; for (int i = 0; i &lt; 20; ++i) res += 1ll * T[o][i] * (1 &lt;&lt; i); return res; &#125; pushdown(o, l, r); int mid = l + r >> 1; i64 res = 0; if (ql &lt;= mid) res += query(o &lt;&lt; 1, l, mid, ql, qr); if (mid &lt; qr) res += query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); build(1, 1, n); scanf(\"%d\", &amp;m); while (m--) &#123; int op, l, r, x; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) printf(\"%lld\\n\", query(1, 1, n, l, r)); else &#123; scanf(\"%d\", &amp;x); update(1, 1, n, l, r, x); &#125; &#125; return 0; &#125; 数学 这里是一些数学题。 图论 这里是图论题。 1600~1800 这个范围内的图论题在 OI 中都不会很难，就是经典算法的简单运用。 综合问题 不止一种算法的题目，或者考验思维。 1700~1900 Rating 值为 1700~1900 的综合性题目。 [CF223B] Two Strings Portal. 我们扫描 sss，然后贪心地配对，详见代码。 查看代码 #include &lt;cstdio> #include &lt;cstring> int n, m, f[30]; // f 记录 t 中每一个字母的位置 +1 int l = 1, cnt = 1; // l 记录当前在 t 中的配对标号 char s[200005], t[200005]; int main(void) &#123; scanf(\"%s%s\", s + 1, t + 1); n = strlen(s + 1), m = strlen(t + 1); for (int i = 1; i &lt;= n; ++i) &#123; // 可以配对就配对 if (s[i] == t[l]) ++l; if (s[i] == t[cnt]) f[s[i] - 'a'] = ++cnt; // 这个字母在 t 中扫不到 // 即使后面有，前面的也不够构成子序列 if (f[s[i] - 'a'] == 0) return puts(\"No\"), 0; // 当 l > 这个字母最后一次的位置+1 时，说明当前的 l 根本不可能匹配上 // 我们将它移到最后一次出现的位置，这样 t 中最后出现的位置之前都是可以与 s 的匹配的，这样只需要匹配 t 中的剩余内容，由于选的是子序列所以肯定是剩的越少越好，所以移到最后一次出现的位置。 if (f[s[i] - 'a'] &lt; l) l = f[s[i] - 'a']; &#125; if (l &lt;= m) puts(\"No\"); // 没有配完 else puts(\"Yes\"); return 0; &#125; [CF959D] Mahmoud and Ehab and another array construction task Portal. 给定一个长度为 nnn 的数列 {an}\\{a_n\\}{an​}。要求构造一个数列 {bn}\\{b_n\\}{bn​} 满足 ∀ i≠j\\forall \\ i\\neq j∀ i=j， bib_ibi​ 与 bjb_jbj​ 互质（即 (bi,bj)=1(b_i,b_j)=1(bi​,bj​)=1），且 {bn}\\{b_n\\}{bn​} 的字典序 ≥\\ge≥ {an}\\{a_n\\}{an​} 的字典序，且 {bn}\\{b_n\\}{bn​} 的字典序是所有满足条件的数列中最小的。1≤n≤1051\\leq n\\leq 10^51≤n≤105， 2≤ai≤1052\\leq a_i\\leq 10^52≤ai​≤105。 一开始所有数都能选，然后找到第一个大于等于 aia_iai​ 的，杀掉它的所有倍数，如果此时已经大于 aia_iai​ 了，那么后面就随便选了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;set> using namespace std; const int N = 2000000; int n; int a[100005]; set &lt;int> s; void kill(int x) &#123; for (int i = x; i &lt;= N; i += x) if (s.count(i)) s.erase(i); &#125; void del(int x) &#123; for (int i = 2; i * i &lt;= N; ++i) &#123; if (x % i == 0) &#123; while (x % i == 0) x /= i; kill(i); &#125; &#125; if (x > 1) kill(x); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 2; i &lt;= N; ++i) s.insert(i); bool flag = false; for (int i = 1; i &lt;= n; ++i) &#123; auto it = flag ? s.begin() : s.lower_bound(a[i]); printf(\"%d \", *it); del(*it); &#125; putchar('\\n'); return 0; &#125; [CF1718A2] Burenka and Traditions (hard version) Portal. 给定一个长度为 nnn 的数组 AAA，一次操作可以选择一个区间 [l,r][l,r][l,r]，将所有数异或上 xxx，代价为 ⌈r−l+12⌉\\lceil \\frac{r-l+1}{2}\\rceil⌈2r−l+1​⌉。问将所有数变成 000 的最小代价。 由于向上取整的性质，可以发现所有操作都可以拆分成区间长度为 1∼21\\sim 21∼2 的操作。一开始 ans=nans=nans=n，当一段子段的异或和为 000 时，可以连着用区间长度为 222 的操作，ansansans 可以减小 111，贪心即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;map> using namespace std; int n; int a[100005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; int ans = n, S = 0; map &lt;int, int> s; s[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; S ^= a[i]; if (s.find(S) != s.end()) &#123; --ans; s.clear(); s[S = 0] = 1; &#125; else s[S] = 1; &#125; cout &lt;&lt; ans &lt;&lt; '\\n'; &#125; int main(void) &#123; int T; cin >> T; while (T--) solve(); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"}]},{"title":"简单概率论","slug":"notes/数学/easy-probability","date":"2022-09-01T00:00:00.000Z","updated":"2022-09-01T00:00:00.000Z","comments":true,"path":"ccbe608c/","link":"","permalink":"https://james1badcreeper.github.io/ccbe608c/","excerpt":"概率论研究的是随机事件，本文将简单介绍概率论。","text":"概率论研究的是随机事件，本文将简单介绍概率论。 事件 这是一些基本概念。 随机事件与样本空间 随机试验指的是在相同的条件下，对某个随机现象进行的大量重复观测。随机试验可以在相同的条件下重复进行，出现的所有可能结果不止一个，但都已知（比如抛一枚无限薄但有一定质量硬币一定是正面朝上或者反面朝上），每次实验总是出现可能结果之一，但实验前无法预知得到哪一种结果[1]。 我们把每一种可能，比如抛硬币出现正面，称之为基本事件，或者样本点，用 A,B,C…A,B,C\\dotsA,B,C… 表示，全体样本点构成的集合称为样本空间，用 Ω\\OmegaΩ 来表示（有的时候也是用 SSS）。 样本空间可以是有限集，也可以是无限集。比如抛硬币时 S={正，反}S=\\{正，反\\}S={正，反}，是有限集；选取一个 [0,1][0,1][0,1] 中的实数时，S={x∈R∣0≤x≤1}S=\\{x\\in\\mathbb{R}\\mid 0\\le x\\le 1\\}S={x∈R∣0≤x≤1}，就是一个无限集。 随机事件 AAA 是 Ω\\OmegaΩ 的一个子集，当 AAA 中的某个基本事件发生的时候，我们称 AAA 事件发生。 若 A=ΩA=\\OmegaA=Ω，则称 AAA 是必然事件，比如 james1 考试得零分； 若 A=∅A=\\varnothingA=∅，则称 AAA 是不可能事件，比如 james1 的智商为正数。 实际上上述例子不太准确，看看就好。 我们关心的事件构成事件域 F\\mathcal{F}F，而且需要 F\\mathcal{F}F 在补运算、和可数并下是封闭的，并且 ∅∈F\\varnothing \\in \\mathcal{F}∅∈F。 P(A)P(A)P(A) 代表其一个随机事件 AAA 发生的概率，PPP 称为概率函数，是一个从事件域 F\\mathcal{F}F 到 [0,1][0,1][0,1] 的映射，满足： 规范性，P(Ω)=1P(\\Omega)=1P(Ω)=1； 可数可加性，也就是下文所说的互斥事件的概率可加。 在研究一个随机现象时，我们通常关注样本空间 Ω\\OmegaΩ，事件域 F\\mathcal{F}F 和概率函数 PPP，将 (Ω,F,P)(\\Omega, \\mathcal{F}, P)(Ω,F,P) 称为一个概率空间。 事件的运算 由于随机事件是集合，所以它们的运算跟集合运算大致同理。 若 A⊆BA\\subseteq BA⊆B，则 AAA 发生时 BBB 一定发生。 也被称为概率函数的单调性，即若 A⊆BA\\subseteq BA⊆B，那么 P(A)≤P(B)P(A)\\le P(B)P(A)≤P(B)。 若 A=BA=BA=B，则它们包含的样本点是相同的； 几个不同的随机事件也会同时发生，发生的情况就是它们的交集，即 A∩BA\\cap BA∩B，简记为 ABABAB。 若 A∩B=∅A\\cap B=\\varnothingA∩B=∅，那么 A,BA,BA,B 不可能同时发生，也就是说 A,BA,BA,B 是互斥事件，或称“互不相容事件“。nnn 个随机事件互斥的充要条件是任意两个随机事件互斥，此时有 P(A+B)=P(A)+P(B)P(A+B)=P(A)+P(B)P(A+B)=P(A)+P(B)，被称为互斥事件的概率加法公式。 A∪BA\\cup BA∪B 表示 A,BA,BA,B 至少有一个发生，简记为 A+BA+BA+B。 AAA 发生，BBB 不发生记为 A−BA-BA−B。 由 AAA 不发生所构成的事件，成为 AAA 的对立事件，也就是说 AAA 的对立事件 A‾=∁ΩA\\overline{A}=\\complement_{\\Omega}AA=∁Ω​A。 AA‾=∅,A+A‾=S,A‾‾=AA\\overline{A}=\\varnothing,A+\\overline{A}=S,\\overline{\\overline{A}}=AAA=∅,A+A=S,A=A。 德·摩根定律，A+B‾=A‾ B‾,AB‾=A‾+B‾\\overline{A+B}=\\overline{A}~\\overline{B},\\overline{AB}=\\overline{A}+\\overline{B}A+B​=A B,AB=A+B。分别指如果 AAA 或 BBB 不发生，那么 A,BA,BA,B 同时不发生；如果 AAA 且 BBB 不发生，那么只需要 AAA 不发生或者 BBB 不发生即可，具体可以通过 Venn 图来理解。 容斥原理：P(A+B)=P(A)+P(B)−P(AB)P(A+B)=P(A)+P(B)-P(AB)P(A+B)=P(A)+P(B)−P(AB)。 P(A−B)=P(A)−P(AB)P(A-B)=P(A)-P(AB)P(A−B)=P(A)−P(AB)。 概率模型 概率要来啦！ 古典概型 当每一个样本点只有有限个基本结果，每个基本结果出现的可能性是一样的，那么： P(A)=card(A)card(S)P(A)=\\cfrac{\\text{card}(A)}{\\text{card}(S)} P(A)=card(S)card(A)​ 生日悖论。一年有 365365365 天，每个人的生日完全随机，有 303030 位同学，问”事件 AAA（存在两个同学生日相同）“的概率。 我们可以求 1−A‾1-\\overline{A}1−A，就可以得出答案。那么利用乘法原理： P(A‾)=A36530∏i=130365=365×⋯×336365×⋯×365≈0.29368P\\left(\\overline{A}\\right)=\\cfrac{A_{365}^{30}}{\\prod_{i=1}^{30}365}=\\cfrac{365\\times \\cdots \\times336}{365\\times\\cdots\\times 365}\\approx 0.29368P(A)=∏i=130​365A36530​​=365×⋯×365365×⋯×336​≈0.29368，也就是说 P(A)≈70%P(A)\\approx 70\\%P(A)≈70%！ 古典概型的应用 我们来看一些简单的题目。 [Luogu P2719] 搞笑世界杯 Portal. card(S)card(S)card(S) 很好求，就是 C2nnC_{2n}^{n}C2nn​。但是计算最末尾两个人拿到相同球票的概率较难（因为不一定需要抛硬币了），考虑计算不同的。也就是说，我们要求出“到最后两人时，两类门票都没有被卖空“的概率。满足条件的事件共有 C2n−2n−1C_{2n-2}^{n-1}C2n−2n−1​ 种，每种事件发生的概率是 122n−2\\cfrac{1}{2^{2n-2}}22n−21​（因为一定需要抛硬币），也就是 C2n−2n−1×122n−2C_{2n-2}^{n-1}\\times\\cfrac{1}{2^{2n-2}}C2n−2n−1​×22n−21​。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; double ans = 1.0; int main(void) &#123; scanf(\"%d\", &amp;n); n >>= 1; for (int i = 1; i &lt; n; ++i) ans = ans * (i + n - 1) / (i &lt;&lt; 2); printf(\"%.4lf\\n\", 1 - ans); return 0; &#125; [UVa 1636] Headshot Portal. 直接抠一枪没有子弹的概率是 00 的个数除以 0 的个数，转一下没有子弹的概率是 0 的个数初一总数。 查看代码 #include &lt;cstdio> #include &lt;cstring> int main(void) &#123; static char s[120]; while (scanf(\"%s\", s) == 1) &#123; int a = 0, b = 0, n = strlen(s); for (int i = 0; i &lt; n; ++i) if (s[i] == '0') &#123; ++b; if (s[(i + 1) % n] == '0') ++a; &#125; // a / b ? b / n if (a * n == b * b) puts(\"EQUAL\"); else if (a * n > b * b) puts(\"SHOOT\"); else puts(\"ROTATE\"); &#125; return 0; &#125; [UVa 10491] Cows and Cars Portal. 直接分刚开始抓到牛和没抓到牛简单讨论即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int a, b, c; while (scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c) == 3) printf(\"%.5lf\\n\", double(a * b + b * b - b) / (double(a + b) * (a + b - c - 1))); // a / (a + b) * b / (a + b - c - 1) // b / (a + b) * (b - 1) / (a + b - c - 1) // a * b + b * b - b return 0; &#125; 几何概型 集合概型的样本空间为无限集。比如说 james1 等车，车在 8:00∼9:008:00\\sim 9:008:00∼9:00 到，那么在八点半之前等到车的时间为 50%50\\%50%。 显然样本空间是无限集，我们不能使用古典概型的公式进行计算。实际上这个问题有自己的几何意义：线段一半的长度。 贝叶斯公式 期望 我们讨论的均是离散型随机变量。 概念 抛 100100100 次硬币，期望有 505050 枚朝上。数学期望指的就是每次实验中期望的结果。形式化地，若随机变量 XXX 的取值有 x1⋯xnx_1\\cdots x_nx1​⋯xn​，那么 E(X)=∑pixiE(X)=\\sum p_i x_iE(X)=∑pi​xi​，前提是这个式子绝对收敛。 期望的性质 期望是一个线性函数，也就是说 E(aX+bY)=a×E(X)+b×(Y)E(aX+bY)=a\\times E(X)+b\\times (Y)E(aX+bY)=a×E(X)+b×(Y)。这个东西很有用。比如 james1 要抛骰子，抛两个六面骰子，三个八面骰子，那么六面骰子的期望抛出值为 E(X)=3.5E(X)=3.5E(X)=3.5，八面骰子的期望抛出值为 E(Y)=4.5E(Y)=4.5E(Y)=4.5，那么 E(2X+3Y)=2E(X)+3E(Y)=20.5E(2X+3Y)=2E(X)+3E(Y)=20.5E(2X+3Y)=2E(X)+3E(Y)=20.5。 数学期望 DP 数学期望的线性性质非常重要，是我们对它进行 DP 的前提。 [Luogu P4316] 绿豆蛙的归宿 Portal.给出张 nnn 个点 mmm 条边的有向无环图，起点为 111，终点为 nnn，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 kkk 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 1k\\frac{1}{k}k1​ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？ 设 f(x)f(x)f(x) 表示从 xxx 走到终点的路径期望长度。等等，为什么不是从 111 到 xxx 呢？想想转移的时候要乘上概率，如果用正的状态定义，我们不知到有多大的概率走到 xxx，这样会使得计算变的相当困难。采用倒序的话，就不存在这种问题了。事实上，很多期望 DP 都是倒序进行的。 那么： f(x)=1k∑i=1k(F[y]+z)f(x)=\\frac{1}{k}\\sum_{i=1}^{k}(F[y]+z) f(x)=k1​i=1∑k​(F[y]+z) 这样我们建反图，在上面进行 DP。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> using namespace std; struct edge &#123; int v, d; edge(int v = 0, int d = 0) : v(v), d(d) &#123;&#125; &#125;; int n, m; int in[100005], deg[100005]; double dis[100005]; vector &lt;edge> G[100005]; queue &lt;int> q; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[v].push_back(edge(u, w)); ++deg[u], ++in[u]; // 进入 u 的度数 &#125; q.push(n); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].v, w = G[u][i].d; dis[v] += (dis[u] + w) / deg[v]; --in[v]; if (in[v] == 0) q.push(v); &#125; &#125; printf(\"%.2lf\\n\", dis[1]); return 0; &#125; [Cnoi2020] 线性生物 Portal.线形生物要从 111 号台阶走到 n+1n+1n+1 号台阶。1,2,3,…,n1,2,3,\\ldots,n1,2,3,…,n 号台阶都有一条连向下一台阶的有向边 i→i+1i\\rightarrow i+1i→i+1。还有 mmm 条返祖边 ui→vi(ui≥vi)u_i \\rightarrow v_i (u_i \\ge v_i)ui​→vi​(ui​≥vi​)，它们构成了一个返祖图。线形生物每步会 等概率地 选取当前台阶的一条出边并走向对应的台阶。当走到 n+1n+1n+1 号台阶时，线形生物就会停止行走。求线性生物期望行走的步数值。 记 E[i]E[i]E[i] 为从 i→i+1i\\rightarrow i+1i→i+1 的期望步数值，那么 Ex→y=∑i=xy−1E[i]E_{x\\rightarrow y}=\\sum_{i=x}^{y-1}E[i]Ex→y​=∑i=xy−1​E[i]。我们记 sumxsum_xsumx​ 代表 ∑i=0xsum[i]\\sum_{i=0}^{x} sum[i]∑i=0x​sum[i]，duxdu_xdux​ 代表返祖边的数量。那么有（第一行代表正常需要一步，加上返祖边）： Ex→x+1=1+∑(x,y)∈EEy→x+1dux+1, Ex→x+1=dux+1+∑(x,y)∈Esumx−1−sumy−1dux+1E_{x\\rightarrow x+1}=\\frac{1+\\sum_{(x,y)\\in E} E_{y\\rightarrow x}+1}{du_x+1},\\\\\\ \\\\ E_{x\\rightarrow x+1}=\\frac{du_x+1+\\sum_{(x,y)\\in E} sum_{x-1}-sum_{y-1}}{du_x+1} Ex→x+1​=dux​+11+∑(x,y)∈E​Ey→x​+1​, Ex→x+1​=dux​+1dux​+1+∑(x,y)∈E​sumx−1​−sumy−1​​ 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; const int MOD = 998244353; const int MAXN = 1000000; int poww(int x, int y) &#123; int res = 1; while (y) &#123; if (y &amp; 1) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; y >>= 1; &#125; return res; &#125; int id, n, m; int E[MAXN + 5], sum[MAXN + 5]; vector &lt;int> G[MAXN + 5]; int main(void) &#123; scanf(\"%d%d%d\", &amp;id, &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); &#125; for (int x = 1; x &lt;= n; ++x) &#123; E[x] = G[x].size() + 1; for (int y : G[x]) E[x] = ((E[x] + sum[x - 1] - sum[y - 1] + 1) % MOD + MOD) % MOD; E[x] = 1ll * E[x] * poww(G[x].size() + 1, MOD - 2) % MOD; sum[x] = (sum[x - 1] + E[x]) % MOD; &#125; printf(\"%lld\\n\", sum[n]); return 0; &#125; Problemset 纯概率的题目不是很多，往往会与其它算法综合。但是也有一些简单题目： 简单题目 这里是一些概率的简单应用。 [国家集训队] 单位选错 Portal. 答案是 ∑1max⁡{ai−1,ai}\\sum \\frac{1}{\\max\\{a_{i-1},a_{i}\\}}∑max{ai−1​,ai​}1​。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, A, B, C; int a[10000005]; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;A, &amp;B, &amp;C, a); for (int i = 1; i &lt; n; i++) a[i] = ((long long) a[i - 1] * A + B) % 100000001; for (int i = 0; i &lt; n; i++) a[i] = a[i] % C + 1; double ans = 0; for (int i = 1; i &lt;= n; ++i) ans += 1.0 / max(a[i - 1], a[i % n]); printf(\"%.3lf\\n\", ans); return 0; &#125; [TJOI2015] 概率论 Portal. nnn 个节点的二叉树数量是卡特兰数。将 nnn 个点的二叉树删去一个叶子可以得到 n−1n-1n−1 个点的二叉树，问题转化为有多少组对应。可以在 n−1n-1n−1 个点的二叉树上放置 nnn 个叶子，因此答案是 n×Cn−1Cn\\frac{n\\times C_{n-1}}{C_n}Cn​n×Cn−1​​。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int main(void) &#123; double n; cin >> n; printf(\"%.11lf\\n\", n * (n + 1) / (2 * (2 * n - 1))); return 0; &#125; [BJOI2019] 光线 Portal. 设 pip_ipi​ 代表从第一面镜子到第 iii 面镜子的透光率，qiq_iqi​ 代表第 iii 面镜子射入光线时的反射率。那么： pi=pi−1×ai×∑i=0∞(biqi−1)kqi=bi+qi−1×ai2×∑i=0∞(biqi−1)kp_i=p_{i-1}\\times a_i\\times \\sum_{i=0}^{\\infty}(b_iq_{i-1})^k\\\\ q_i=b_i+q_{i-1}\\times a_i^2\\times \\sum_{i=0}^{\\infty}(b_iq_{i-1})^k pi​=pi−1​×ai​×i=0∑∞​(bi​qi−1​)kqi​=bi​+qi−1​×ai2​×i=0∑∞​(bi​qi−1​)k 有 ∑i=0∞xk=11−x,∣x∣&lt;1\\displaystyle\\sum_{i=0}^{\\infty}x^k = \\frac{1}{1-x},|x|&lt;1i=0∑∞​xk=1−x1​,∣x∣&lt;1，因此上式可以直接计算。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int P = 1000000007; inline int poww(int a, int b) &#123; int r = 1; a %= P; for (; b; b >>= 1, a = 1ll * a * a % P) if (b &amp; 1) r = 1ll * r * a % P; return r; &#125; int main(void) &#123; int i1 = poww(100, P - 2), p = 1, q = 0; int n, a, b; scanf(\"%d\", &amp;n); while (n--) &#123; scanf(\"%d%d\", &amp;a, &amp;b); a = 1ll * a * i1 % P, b = 1ll * b * i1 % P; int w = poww((1 - 1ll * q * b % P + P) % P, P - 2); // 透过的 p = 1ll * p * a % P * w % P; q = (b + 1ll * q * a % P * a % P * w) % P; &#125; printf(\"%d\\n\", p); return 0; &#125; 期望 主要是一些小概念。 [JXOI2018] 游戏 Portal. 要求的是最后一个必须自己检查自己（称为关键点）的人的数字的期望出现位置，设有 kkk 个这种人，那么最后一个关键点后面的人数期望为 (n−k)×1k+1(n-k)\\times \\cfrac{1}{k+1}(n−k)×k+11​，位置自然可以求出：n−(n−k)×1k+1=k(n+1)k+1n-(n-k)\\times \\cfrac{1}{k+1}=\\cfrac{k(n+1)}{k+1}n−(n−k)×k+11​=k+1k(n+1)​。然后乘上方案数 n!n!n! 即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 1000000007; int l, r, res = 0, ans; bool flag[10000005]; int main(void) &#123; scanf(\"%d%d\", &amp;l, &amp;r); for (int i = l; i &lt;= r; ++i) if (!flag[i]) &#123; ++res; for (int j = i * 2; j &lt;= r; j += i) flag[j] = true; &#125; ans = res; for (int i = 1; i &lt;= r - l + 2; ++i) if (i != res + 1) ans = 1ll * ans * i % MOD; printf(\"%d\\n\", ans); return 0; &#125; 拓扑序期望 DP 依照拓扑序直接动态规划即可。后面有些题难度偏大。 [Luogu P1654] OSU! Portal. 使用增量法分析。当增加一个 111 时，答案变为 (x+1)3=x3+3x2+3x+1(x+1)^3=x^3+3x^2+3x+1(x+1)3=x3+3x2+3x+1，也就是说答案增加了 3x2+3x+13x^2+3x+13x2+3x+1，那么维护 x2x^2x2 和 xxx 的期望值即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; double p, x1[100005], x2[100005], f[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lf\", &amp;p); x1[i] = (x1[i - 1] + 1) * p; x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * p; f[i] = f[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * p; &#125; printf(\"%.1lf\\n\", f[n]); return 0; &#125; [SHOI2014] 概率充电器 Portal. 换根 DP。转移方程：f(x)←f(y)×f(x)+(1−f(x))×wf(x)\\leftarrow f(y)\\times f(x)+(1-f(x))\\times wf(x)←f(y)×f(x)+(1−f(x))×w。换根的时侯算出之前没被 yyy 贡献时 xxx 的答案，拿这个对 yyy 进行贡献。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cmath> using namespace std; const double eps = 1e-8; int n; double f[500005]; vector&lt;pair&lt;int, double>> G[500005]; void dfs1(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; double w = G[x][i].second; if (y == fa) continue; dfs1(y, x); f[x] += f[y] * (1 - f[x]) * w; &#125; &#125; void dfs2(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; double w = G[x][i].second; if (y == fa) continue; if (fabs(1 - f[y] * w) > eps) &#123; double last = (f[x] - f[y] * w) / (1 - f[y] * w); f[y] += last * (1 - f[y]) * w; &#125; dfs2(y, x); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].emplace_back(make_pair(v, w / 100.0)); G[v].emplace_back(make_pair(u, w / 100.0)); &#125; for (int i = 1, t; i &lt;= n; ++i) scanf(\"%d\", &amp;t), f[i] = t / 100.0; dfs1(1, 0); dfs2(1, 0); double ans = 0; for (int i = 1; i &lt;= n; ++i) ans += f[i]; printf(\"%.6lf\\n\", ans); return 0; &#125; 非拓扑序期望 DP 实际情况复杂得多，硬要说的话我只要知道空气流动速度、抛硬币的力的大小方向、接触面积等内容，一定能计算出抛硬币的结果。甚至计算机的随机数计算也是有一个公式的（所以生成的是伪随机数）。真正的随机数还有一些伪随机数不具有的性质，比如与信息熵相关的性质。 ↩︎","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"概率","slug":"概率","permalink":"https://james1badcreeper.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"期望","slug":"期望","permalink":"https://james1badcreeper.github.io/tags/%E6%9C%9F%E6%9C%9B/"}]},{"title":"基础线性代数","slug":"notes/数学/la-basic","date":"2022-08-27T00:00:00.000Z","updated":"2022-08-27T00:00:00.000Z","comments":true,"path":"22ceb96a/","link":"","permalink":"https://james1badcreeper.github.io/22ceb96a/","excerpt":"线性代数是代数学的一个分支，主要处理线性关系问题。OI 中用到的相关知识并不多，主要是矩阵乘法与高斯消元等，本文将简单介绍这些内容。","text":"线性代数是代数学的一个分支，主要处理线性关系问题。OI 中用到的相关知识并不多，主要是矩阵乘法与高斯消元等，本文将简单介绍这些内容。 矩阵乘法 一个 n×mn\\times mn×m 的矩阵可以看作是一个 n×mn\\times mn×m 的二维数组。矩阵加法和减法就是把相对应的数加减，而矩阵乘法则很有意思，拥有几何意义，这里不做展开。 矩阵乘法 设 AAA 是 n×mn\\times mn×m 的矩阵，BBB 是 m×pm\\times pm×p 的矩阵，那么 C=A×BC=A\\times BC=A×B 是 n×pn\\times pn×p 的矩阵，并且： Ci,j=∑k=1Ai,kBk,jC_{i,j}=\\sum_{k=1}A_{i,k}B_{k,j} Ci,j​=k=1∑​Ai,k​Bk,j​ 模板，代码如下： for (int i = 0; i &lt; n; ++i) for (int k = 0; k &lt; n; ++k) &#123; int r = a[i][k]; for (int j = 0; j &lt; n; ++j) c[i][j] += r * b[k][j]; &#125; 注意循环顺序！这样的顺序对答案不会造成影响，但是缓存访问是连续的，因此跑得较快。 矩阵快速幂 矩阵乘法不满足交换律，但是满足结合律（也满足分配律），因此快速幂的计算方式可以直接移用。注意矩阵乘法有一个“单位矩阵”的概念，类似于数的乘法中“1”。 模板，代码入下： 查看代码 struct Matrix &#123; int a[105][105]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125;; void reset(void) &#123; // 构建单位矩阵 for (int i = 1; i &lt;= n; ++i) a[i][i] = 1; &#125; &#125;; Matrix operator * (const Matrix &amp;x, const Matrix &amp;y) &#123; Matrix z; for (int i = 1; i &lt;= n; ++i) for (int k = 1; k &lt;= n; ++k) &#123; int r = x.a[i][k]; for (int j = 1; j &lt;= n; ++j) z.a[i][j] = (z.a[i][j] + 1ll * r * y.a[k][j]) % MOD; &#125; return z; &#125; Matrix poww(Matrix a, i64 b) &#123; Matrix res; res.reset(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; 矩阵与递推 矩阵乘法的一大作用就是加速递推。 概述 递推都有一个递推式子，我们可以把这个式子中的变量写进矩阵，然后再乘上一个矩阵进行变换。由于递推式必变，因此每次乘上的矩阵都是相同的，可以使用矩阵快速幂来进行计算。 [Luogu P1962] 斐波那契数列 Portal. 要将 [Fn−1Fn−2]\\begin{bmatrix}F_{n-1}\\\\F_{n-2}\\end{bmatrix}[Fn−1​Fn−2​​] 变换为 [FnFn−1]\\begin{bmatrix}F_{n}\\\\F_{n-1}\\end{bmatrix}[Fn​Fn−1​​]，利用待定系数法可以求得需要乘上 A=[1110]\\mathbf{A}=\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}A=[11​10​]，即 [FnFn−1]=[1110][Fn−1Fn−2]\\begin{bmatrix}F_{n}\\\\F_{n-1}\\end{bmatrix}=\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}\\begin{bmatrix}F_{n-1}\\\\F_{n-2}\\end{bmatrix}[Fn​Fn−1​​]=[11​10​][Fn−1​Fn−2​​]。要多次变换的话，由于矩阵乘法有结合律，利用矩阵快速幂就可以搞定，最后在乘上初始 FFF 矩阵。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; const int MOD = 1000000007; struct Matrix &#123; int a[3][3]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125;; void reset(void) &#123; for (int i = 1; i &lt;= 2; ++i) a[i][i] = 1; &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 1; i &lt;= 2; ++i) for (int k = 1; k &lt;= 2; ++k) &#123; int r = a.a[i][k]; for (int j = 1; j &lt;= 2; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b .a[k][j]) % MOD; &#125; return c; &#125; &#125;; Matrix poww(Matrix T, i64 b) &#123; Matrix res; res.reset(); while (b) &#123; if (b &amp; 1) res = res * T; T = T * T; b >>= 1; &#125; return res; &#125; int main(void) &#123; i64 n; cin >> n; if (n &lt;= 2) return puts(\"1\"), 0; Matrix a, f; a.a[1][1] = a.a[1][2] = a.a[2][1] = 1; f.a[1][1] = 1; // f 记录 F[1], F[0] a = poww(a, n - 1); // 从 n = 2 变换，所以 -1 f = a * f; cout &lt;&lt; f.a[1][1] &lt;&lt; '\\n'; return 0; &#125; [Luogu P1939] 【模板】矩阵加速（数列） Portal. 方法是相同的。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int MOD = 1000000007; const int N = 3; struct Matrix &#123; int a[4][4]; Matrix(void) &#123; memset(a, 0, sizeof(a)); &#125; void build(void) &#123; for (int i = 1; i &lt;= N; ++i) a[i][i] = 1; &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 1; i &lt;= N; ++i) for (int k = 1; k &lt;= N; ++k) &#123; int r = a.a[i][k]; for (int j = 1; j &lt;= N; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b.a[k][j]) % MOD; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; res.build(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; int main(void) &#123; int T; cin >> T; while (T--) &#123; int n; cin >> n; if (n &lt;= 3) &#123; puts(\"1\"); continue; &#125; Matrix a, f; a.a[1][1] = a.a[1][3] = a.a[2][1] = a.a[3][2] = 1; f.a[1][1] = f.a[2][1] = f.a[3][1] = 1; a = poww(a, n - 3); f = a * f; cout &lt;&lt; f.a[1][1] &lt;&lt; '\\n'; &#125; return 0; &#125; [Luogu P1349] 广义斐波那契数列 Portal. 只是我们的变换矩阵不一样了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int N = 2; int m; struct Matrix &#123; int a[3][3]; Matrix(void) &#123; memset(a, 0, sizeof(a)); &#125; void build(void) &#123; for (int i = 1; i &lt;= N; ++i) a[i][i] = 1; &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 1; i &lt;= N; ++i) for (int k = 1; k &lt;= N; ++k) &#123; int r = a.a[i][k]; for (int j = 1; j &lt;= N; ++j) c.a[i][j] = (c.a[i][j] + 1ll * r * b.a[k][j]) % m; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, int b) &#123; Matrix res; res.build(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; int main(void) &#123; int p, q, a1, a2, n; cin >> p >> q >> a1 >> a2 >> n >> m; if (n &lt;= 2) return (cout &lt;&lt; (n == 1 ? a1 : a2) &lt;&lt; '\\n', 0); Matrix a, f; a.a[1][1] = p, a.a[1][2] = q, a.a[2][1] = 1; f.a[1][1] = a2, f.a[2][1] = a1; a = poww(a, n - 2); f = a * f; cout &lt;&lt; f.a[1][1] &lt;&lt; '\\n'; return 0; &#125; 高斯消元 相关知识点 LGV 引理 矩阵树定理 BEST 定理 线性基 Problemset 主要是应用。 线性代数基础 一些简单题。用到了概念和矩阵乘法。 [NOI2012] 随机数生成器 Portal. 这样： [Fnc]=[a101][Fn−1c]\\begin{bmatrix}F_n\\\\c\\end{bmatrix}=\\begin{bmatrix}a&amp;1\\\\0&amp;1\\end{bmatrix}\\begin{bmatrix}F_{n-1}\\\\c\\end{bmatrix} [Fn​c​]=[a0​11​][Fn−1​c​] 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; typedef __int128_t LL; i64 m, a, c, x0, n, g; struct Matrix &#123; i64 a[2][2]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; void build(void) &#123; a[0][0] = a[1][1] = 1; &#125; Matrix friend operator * (const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix c; for (int i = 0; i &lt; 2; ++i) for (int k = 0; k &lt; 2; ++k) &#123; i64 r = a.a[i][k]; for (int j = 0; j &lt; 2; ++j) c.a[i][j] = (c.a[i][j] + (LL)r * b.a[k][j]) % m; &#125; return c; &#125; &#125;; Matrix poww(Matrix a, i64 b) &#123; Matrix res; res.build(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b >>= 1; &#125; return res; &#125; int main(void) &#123; cin >> m >> a >> c >> x0 >> n >> g; Matrix A, F; A.a[0][0] = a; A.a[0][1] = A.a[1][1] = 1; F.a[0][0] = x0, F.a[1][0] = c; A = poww(A, n); F = A * F; cout &lt;&lt; F.a[0][0] % g &lt;&lt; endl; return 0; &#125; [NOI2013] 向量内积 Portal. 发现模数是 222 或 333，因此考虑乱搞。 维护向量的前缀和，让一个向量乘以它前面的前缀和向量。k=2k=2k=2 时如果不为 (i−1) mod 2(i-1)\\bmod 2(i−1)mod2 说明有一个乘积为 000，暴力找即可。 k=3k=3k=3 时维护前缀平方和可以达到一样的效果。 随机化做几轮即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, k; int a[100005][105], id[100005], b[105], c[105][105]; mt19937 Rand(time(0)); inline bool check(int x, int y) &#123; int r = 0; for (int i = 1; i &lt;= m; ++i) r += a[x][i] * a[y][i]; return r % k == 0; &#125; inline int calc(int x) &#123; int ans = 0; if (k == 2) &#123; for (int i = 1; i &lt;= m; ++i) &#123; ans = (ans + b[i] * a[x][i]) % k; b[i] = (b[i] + a[x][i]) % k; &#125; &#125; else &#123; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= m; ++j) &#123; ans = (ans + c[i][j] * a[x][i] * a[x][j]) % k; c[i][j] = (c[i][j] + a[x][i] * a[x][j]) % k; &#125; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[i][j]), a[i][j] %= k; for (int i = 1; i &lt;= n; ++i) id[i] = i; for (int T = 1; T &lt;= 7; ++T) &#123; shuffle(id + 1, id + n + 1, Rand); memset(b, 0, sizeof b); memset(c, 0, sizeof c); for (int i = 1; i &lt;= n; ++i) if (calc(id[i]) != (i - 1) % k) // 有解 for (int j = 1; j &lt; i; ++j) if (check(id[i], id[j])) &#123; if (id[i] > id[j]) swap(id[i], id[j]); return printf(\"%d %d\\n\", id[i], id[j]), 0; &#125; &#125; puts(\"-1 -1\"); return 0; &#125; 高斯消元","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"线性代数","slug":"线性代数","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://james1badcreeper.github.io/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://james1badcreeper.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]},{"title":"NOIP 范围内较难的 DP","slug":"notes/DP/noip-dp","date":"2022-08-18T00:00:00.000Z","updated":"2022-08-18T00:00:00.000Z","comments":true,"path":"d52d1ad2/","link":"","permalink":"https://james1badcreeper.github.io/d52d1ad2/","excerpt":"在 NOIP 范围内需要掌握的较难 DP 包括：状压 DP、单调队列优化 DP 和倍增优化 DP。","text":"在 NOIP 范围内需要掌握的较难 DP 包括：状压 DP、单调队列优化 DP 和倍增优化 DP。 状态压缩 通过将状态利用压缩为整数，这样的操作称之为状态压缩，运用到动态规划上就是状压 DP。在枚举中有一种操作叫做”子集枚举“，就是枚举整数，然后利用位运算取得其在二进制下的每一位，然后就确定了一个元素的存在状态。 引入 首先先了解一些常用的二进制计算方法： 意义（nnn 位二进制意义下，位数从右起） 运算 解释 nnn 的第 kkk 位 (n &gt;&gt; k) &amp; 1 显然 nnn 的第 kkk 位取反 n xor (1 &lt;&lt; k) 异或可以取反 nnn 的第 kkk 位变 111 n | (1 &lt;&lt; k) 或可以赋值为 111 nnn 的第 kkk 位变 000 n &amp; (~(1 &lt;&lt; k)) 创造出一个除了第 kkk 位都是 111 的东西进行与运算 nnn 的后 kkk 位 n &amp; ((1 &lt;&lt; k) - 1) 创造一个后 kkk 位都是 111 的东西进行与运算 mmm 的非空子集遍历 for (int s = m; s; s = s - 1 &amp; m) 减去最右边的 111，但是它还会回来 将由集合构成的状态通过进制转化为整数，称之为状态压缩。我们通过一道简单的题目来大概认识这玩意。 最短 Hamilton 路径。 对于已经读到这的读者来说，很容易设计出状态：F(a,i)F({a},i)F(a,i) 代表已经经过了 a{a}a 中的所有节点，目前处于点 iii 的长度。这样行吗？要将 a{a}a 用 vector 记录下来，这样 F 就成了一个 map，无法接受。 考虑状态压缩，我们搞一个长度为 202020 的 010101 序列，111 代表经过了，000 代表没有经过。010101 序列是什么？二进制串！二进制串的枚举是什么？枚举整数！ 这样我们就可以定义 f(i,j),i&lt;2nf(i,j),i&lt;2^nf(i,j),i&lt;2n，来表示跟刚才同样的内容。初始时显然 f(1,0)=0f(1,0)=0f(1,0)=0，最终目标是 f(2n−1,n−1)f(2^n-1,n-1)f(2n−1,n−1)（nnn 个 111，终点为 n−1n-1n−1），接下来考虑如何进行转移。 有 f(i,j)=min⁡{f(i xor (1&lt;&lt;j),k)+d(k,j)},(i&gt;&gt;j)&amp;1=1f(i,j)=\\min\\{f(i\\text{ xor } (1 &lt;&lt; j),k)+d(k,j)\\},(i&gt;&gt;j)\\And 1=1f(i,j)=min{f(i xor (1&lt;&lt;j),k)+d(k,j)},(i&gt;&gt;j)&amp;1=1，也就是说当 jjj 已经访问过，f(i,j)f(i,j)f(i,j) 才可以从 k→jk\\rightarrow jk→j 过来，而且状态集合中没有 jjj。kkk 的取值仅限于在 i xor (1&lt;&lt;j)i\\text{ xor } (1 &lt;&lt; j)i xor (1&lt;&lt;j) 中有的。 代码如下： #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int MAXN = 1 &lt;&lt; 20; int n; int a[25][25]; int f[MAXN + 5][25]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) scanf(\"%d\", &amp;a[i][j]); memset(f, 0x3f, sizeof(f)); f[1][0] = 0; for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) for (int j = 0; j &lt; n; ++j) if ((i >> j) &amp; 1) // i 的第 j 位是 1，要取反使得来的状态的第 j 位是 0 for (int k = 0; k &lt; n; ++k) if ((i ^ (1 &lt;&lt; j)) >> k &amp; 1) // i xor (1 &lt;&lt; j) 的第 k 位是 1 f[i][j] = min(f[i][j], f[i ^ (1 &lt;&lt; j)][k] + a[k][j]); printf(\"%d\\n\", f[(1 &lt;&lt; n) - 1][n - 1]); return 0; &#125; 注意到了吗？状态压缩后的状态内容是反的，在人看起来是反的。最后一位代表了第一位的状态。 状态压缩实例 我们来看更多问题来熟练应用状态压缩算法。 [Luogu P1171] 售货员的难题 Portal. 这就是经典的货郎担问题（TSP）。设 d(i,S)d(i,S)d(i,S) 代表当前在城市 iii，经过的城市状压后为 SSS 的最小距离即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int INF = 0x3f3f3f3f; int n; int d[25][25]; int f[25][(1 &lt;&lt; 20) + 5]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) scanf(\"%d\", &amp;d[i][j]); memset(f, 0x3f, sizeof(f)); f[0][1] = 0; // 这里采用了刷表法 for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (int j = 0; j &lt; n; ++j) &#123; if (f[j][i] == INF) continue; for (int k = 0; k &lt; n; ++k) if (((i >> k) &amp; 1) == 0) f[k][i | (1 &lt;&lt; k)] = min(f[k][i | (1 &lt;&lt; k)], f[j][i] + d[j][k]); &#125; int ans = INF; for (int i = 0; i &lt; n; ++i) ans = min(ans, f[i][(1 &lt;&lt; n) - 1] + d[i][0]); printf(\"%d\\n\", ans); return 0; &#125; [SCOI2005] 互不侵犯 Portal. 设 f(i,j,k)f(i,j,k)f(i,j,k) 表示考虑前 iii 行，放了 jjj 个国王，当前行的状态压缩后为 kkk。现在枚举上一行的状态 lll，问题就是判断 lll 合不合法。 不难发现，整个过程中我们只需要判断当前行和上一行的合法情况。对于 kkk，如果它存在相邻的两位都是 111，那就不行。我们可以将它左移或右移一位，这样在跟原来的值做与运算，结果不是 000 的话就说明存在相邻的两位数是 111。跟上一行判断的时候也可以用类似的方法。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int n, K, nn; i64 f[10][85][1030]; int getlen(int x) &#123; int res = 0; while (x) &#123; x -= (x &amp; (-x)); ++res; &#125; return res; &#125; bool check(int x, int y) &#123; if (y &amp; (y >> 1)) return false; // 上一行左右有人 if (x &amp; y) return false; // 当前人的头上有人 if ((x &lt;&lt; 1) &amp; y) return false; // 当前人的左上有人 if ((x >> 1) &amp; y) return false; // 当前人的右上有人 return true; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;K); nn = 1 &lt;&lt; n; f[0][0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= K; ++j) for (int k = 0; k &lt; nn; ++k) &#123; int len = getlen(k); if (len > j) continue; if (k &amp; (k >> 1)) continue; // 左右有人，不行 for (int l = 0; l &lt; nn; ++l) // 上一行的状态 if (check(k, l)) f[i][j][k] += f[i - 1][j - len][l]; &#125; i64 ans = 0; for (int i = 0; i &lt; nn; ++i) ans += f[n][K][i]; printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P2622] 关灯问题 II Portal. 设 f(i)f(i)f(i) 表示当前每盏灯的状态压缩后最少按多少次按钮，转移的时候使用刷表法，从全开开始枚举状态，依次动每个开关，看它能够转移到哪里。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int MAXN = (1 &lt;&lt; 10) + 5; int n, nn, m; int a[105][15], f[MAXN]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); nn = 1 &lt;&lt; n; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[i][j]); memset(f, 0x3f, sizeof(f)); f[nn - 1] = 0; for (int i = nn - 1; i >= 0; --i) for (int j = 1; j &lt;= m; ++j) &#123; int now = i; for (int k = 0; k &lt; n; ++k) if (a[j][k + 1] == 1) now &amp;= (~(1 &lt;&lt; k)); else if (a[j][k + 1] == -1) now |= (1 &lt;&lt; k); f[now] = min(f[now], f[i] + 1); &#125; if (f[0] == 0x3f3f3f3f) puts(\"-1\"); else printf(\"%d\\n\", f[0]); return 0; &#125; [USACO06NOV] Corn Fields G Portal. 我们将每一行的状态状压，然后用类似于“互不侵犯”的方式来判断这一行的状态是否合法（是否自己连着或者跟上一行连着）。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 100000000; int n, m; int a[15][15]; int f[15][4100]; bool check(int row, int x) &#123; if (x &amp; (x &lt;&lt; 1)) return false; for (int i = 0; i &lt; m; ++i) if (((x >> i) &amp; 1) == 1 &amp;&amp; !a[row][i]) return false; return true; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; m; ++j) scanf(\"%d\", &amp;a[i][j]); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; (1 &lt;&lt; m); ++j) if (check(i, j)) for (int k = 0; k &lt; (1 &lt;&lt; m); ++k) if ((k &amp; j) == 0) f[i][j] = (f[i][j] + f[i - 1][k]) % MOD; &#125; int ans = 0; for (int i = 0; i &lt; (1 &lt;&lt; m); ++i) ans = (ans + f[n][i]) % MOD; printf(\"%d\\n\", ans); return 0; &#125; 接下来的题目不再是蛮干了，而是有一些特殊的技巧。 按秩转移 | [CF11D] A Simple Task Portal. 设 f(i,j)f(i,j)f(i,j) 代表终点为 jjj，走过的点状压后为 iii 的方案数。转移呢？不太对，这样不知道当前位置。换句话说，状态定义的不够好，导致无法转移。 下面要求 iii 的二进制位下第一个 111 代表当前走到的位置。这是什么？lowbit！转移的时候要求添加的点只能在 lowbit 后面。这样就很好写了。这种考虑按照顺序的转移被称为按秩转移。 注意这样会把每一个环算重两遍，而且还会出写走 i→j,j→ii\\rightarrow j,j\\rightarrow ii→j,j→i 的错误情况，需要去掉。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, m; i64 f[600000][20]; bool a[20][20]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); --u, --v; a[u][v] = a[v][u] = true; &#125; i64 ans = 0; for (int i = 0; i &lt; n; ++i) f[1 &lt;&lt; i][i] = 1; for (int i = 1; i &lt; (1 &lt;&lt; n); ++i) for (int j = 0; j &lt; n; ++j) &#123; if (!f[i][j]) continue; for (int k = 0; k &lt; n; ++k) &#123; if (!a[j][k]) continue; if ((i &amp; (-i)) > (1 &lt;&lt; k)) continue; if ((1 &lt;&lt; k) &amp; i) &#123; if ((1 &lt;&lt; k) == (i &amp; (-i))) ans += f[i][j]; &#125; else f[i | (1 &lt;&lt; k)][k] += f[i][j]; &#125; &#125; printf(\"%lld\\n\", (ans - m) / 2); return 0; &#125; 三进制状态压缩 | [NOI 2001] 炮兵阵地 Portal. 我们可以这样定义，222 表示放置了炮兵，222 下面必须是 111，111 下边必须是 000，同一行两个 222 间隔不小于 333。 那么： 0 0 0 0 2 0 0 1 0 也就是说一个状态不再由 01 表示，而是由 012 表示，也就是三进制。 把每一行的状态压缩为一个 MMM 位的三进制数，设 f(i,j)f(i,j)f(i,j) 代表第 iii 行的状态压缩后为 jjj 时，前 iii 行最多能放置多少合法的炮兵。 但即使这样，状态也很复杂，使用填表法的话状态转移方程会很复杂，所以我们采用刷表法，利用 dfs 进行更新。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int P[] = &#123;1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147&#125;; int n, m; char s[105][15]; int f[105][59050]; int v[15]; // 标记 row 可以填什么，last 为 row - 1 行的状态 // 0 表示只能填 0，1 表示只能填 1，2 表示只能填 0 或 2 // 结果记录在 v 数组中 inline void mark(int row, int last) &#123; for (int i = 0; i &lt; m; ++i, last /= 3) &#123; if (last % 3 == 2) v[i] = 1; else if (last % 3 == 1) v[i] = 0; else if (s[row][i] == 'H') v[i] = 0; else v[i] = 2; &#125; &#125; // 第 row 行的状态为 last，填第 row + 1 行，扫描到第 col 列，cnt 为填的炮兵数，now 为第 row + 1 行状态 void dfs(int row, int col, int last, int now, int cnt) &#123; if (col == m) // 0 ~ m-1 都填完了 &#123; f[row + 1][now] = max(f[row + 1][now], f[row][last] + cnt); return; &#125; if (v[col] == 2 || v[col] == 0) dfs(row, col + 1, last, now, cnt); // 选择填 0，now 没有变化 if (v[col] == 1) dfs(row, col + 1, last, now + P[col], cnt); // 填了 1，now 的第 col - 1 位加上 P[col - 1] if (v[col] == 2) &#123; int v1 = v[col + 1], v2 = v[col + 2]; // 右起两个不能放 if (v[col + 1] == 2) v[col + 1] = 0; if (v[col + 2] == 2) v[col + 2] = 0; dfs(row, col + 1, last, now + 2 * P[col], cnt + 1); // 填了 2，now 的第 col - 1 位加上 2 * P[col - 1] v[col + 1] = v1, v[col + 2] = v2; // 还原 &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", s[i]); memset(f, 0xff, sizeof f); f[0][0] = 0; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; P[m]; ++j) &#123; if (f[i][j] == -1) continue; mark(i + 1, j); // 标记 dfs 中 row + 1 的可填状态 dfs(i, 0, j, 0, 0); &#125; int ans = 0; for (int i = 0; i &lt; P[m]; ++i) ans = max(ans, f[n][i]); printf(\"%d\\n\", ans); return 0; &#125; 这道题也可以使用二进制状态压缩来做，不过相当麻烦。还可以使用轮廓线动态规划。轮廓线 DP（又称插头 DP）是状压 DP 的一种特殊形式，我们之前讨论的所有状压 DP 都是以“格子”作为状态的，但有的时候图形很复杂，需要以图形的轮廓作为状态。这种 DP 将在笔者后续的文章中论述。 子集和 DP（sosDP） sosDP，指的是 Sum over Substes DP，用来解决子集类的求和问题（也能解决高维空间的求和问题，但是时空往往不允许）。 高维前缀和 sosDP 的最重要应用便是实现高维前缀和。 给定一个含 2n2^n2n 个整数的集合 AAA，我们需要求出每一个子集和，求出前缀和。即子集和为 sis_isi​，那么前缀和 fi=∑j⊆isjf_i=\\sum_{j\\subseteq i}s_jfi​=∑j⊆i​sj​。 这个问题可以直接使用 sosDP 来求解，时间复杂度为 O(n×2n)O(n\\times 2^n)O(n×2n)。 for (int j = 0; j &lt; n; ++j) for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) if ((i >> j) &amp; 1) f[i] += f[i ^ (1 &lt;&lt; j)]; 这是什么？还记得 DP 对前缀和的递推吗？这里是一样的道理。注意到 jjj 在外层，如果第 jjj 位（代表维度）是 111，那么就将前缀和转移过来。 [ARC100E] Or Plus Max Portal.给你一个长度为 2n2^n2n 的序列 aaa，每个1≤K≤2n−11\\le K\\le 2^n-11≤K≤2n−1，找出最大的 ai+aja_i+a_jai​+aj​（iorj≤Ki \\mathbin{\\mathrm{or}} j \\le Kiorj≤K，0≤i&lt;j&lt;2n0 \\le i &lt; j &lt; 2^n0≤i&lt;j&lt;2n）并输出。or\\mathbin{\\mathrm{or}}or 表示按位或运算。gg 记得吗？前缀和可以做区间和，还可以做前缀最大值。而现在是两个最大值相加，那么我们用高维前缀和处理最大值和次大值即可。 注意到这里不是子集，而是最高位，因此还需要对高维前缀和数组取最大值。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e9; int n, nn; struct Node &#123; int max1, max2; Node(int max1 = -INF, int max2 = -INF) : max1(max1), max2(max2) &#123;&#125; Node operator + (const Node &amp;x) &#123; Node y; if (max1 > x.max1) &#123; y.max1 = max1; y.max2 = max(max2, x.max1); &#125; else &#123; y.max1 = x.max1; y.max2 = max(max1, x.max2); &#125; return y; &#125; &#125; a[300000]; int main(void) &#123; scanf(\"%d\", &amp;n); nn = 1 &lt;&lt; n; for (int i = 0; i &lt; nn; ++i) scanf(\"%d\", &amp;a[i].max1); for (int j = 0; j &lt; n; ++j) for (int i = 0; i &lt; nn; ++i) if ((i >> j) &amp; 1) a[i] = a[i] + a[i ^ (1 &lt;&lt; j)]; int ans = 0; for (int i = 1; i &lt; nn; ++i) &#123; ans = max(ans, a[i].max1 + a[i].max2); printf(\"%d\\n\", ans); &#125; return 0; &#125; 单调队列 还记得“限制长度的最大子段和”吗？那就是一个经典的单调队列优化 DP。 单调队列可以维护决策取值范围上下变化（队首队尾均可以弹出），而且每个决策在候选集合中至多插入或删除一次。 简单问题 这里的问题比较简单。 [Luogu P1725] 琪露诺 Portal. 几乎就是模板。设 f(i)f(i)f(i) 为到 iii 的最大分数，转移的时候直接从单调队列里获取。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, l, r; int a[200005], f[200005]; int L = 1, R = 0, q[200005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;l, &amp;r); for (int i = 0; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0xbf, sizeof(f)); f[0] = a[0]; int ans = -1e9; for (int i = l; i &lt;= n; ++i) &#123; while (L &lt;= R &amp;&amp; f[q[R]] &lt;= f[i - l]) --R; while (L &lt;= R &amp;&amp; q[L] + r &lt; i) ++L; q[++R] = i - l; f[i] = f[q[L]] + a[i]; if (i + r > n) ans = max(ans, f[i]); &#125; printf(\"%d\\n\", ans); return 0; &#125; [NOIP2017 普及组] 跳房子 Portal. 考虑二分答案，判定的时候使用单调队列优化 DP 求出最大分数即可。 问题是，如何入队？使用一个指针，在扫描到一个新的位置时开始判断它之前的是否可行，就是一个滑动窗口的过程。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; const i64 INF = 1e18; int n, d, k; int x[500005], s[500005]; i64 f[500005]; // 考虑到第 i 个位置的最大得分 int Q[500005]; bool P(int g) &#123; int l = (d > g ? d - g : 1), r = d + g; int L = 1, R = 0, j = 0; i64 ans = -INF; memset(f, 0xbf, sizeof(f)); memset(Q, 0, sizeof(Q)); f[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (j &lt; i &amp;&amp; x[i] - x[j] >= l) &#123; if (f[j] > -INF) &#123; while (L &lt;= R &amp;&amp; f[Q[R]] &lt;= f[j]) --R; Q[++R] = j; &#125; ++j; &#125; while (L &lt;= R &amp;&amp; x[i] - x[Q[L]] > r) ++L; if (L &lt;= R) f[i] = f[Q[L]] + s[i]; ans = max(ans, f[i]); &#125; return ans >= k; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;d, &amp;k); i64 sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", x + i, s + i); if (s[i] > 0) sum += s[i]; &#125; if (sum &lt; k) return puts(\"-1\"), 0; int L = 0, R = 1000000001; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) R = mid; else L = mid; &#125; printf(\"%d\\n\", R); return 0; &#125; [USACO11OPEN] Mowing the Lawn G Portal.Farmer John 的草坪非常脏乱，因此，Farmer John 只能够让他的奶牛来完成这项工作。Farmer John 有 NNN（1≤N≤1051\\le N\\le 10^51≤N≤105）只排成一排的奶牛，编号为 1…N1\\ldots N1…N。每只奶牛的效率是不同的，奶牛 iii 的效率为 EiE_iEi​（0≤Ei≤1090\\le E_i\\le 10^90≤Ei​≤109）。靠近的奶牛们很熟悉，因此，如果 Farmer John安排超过 KKK 只连续的奶牛，那么，这些奶牛就会罢工去开派对 :)。因此，现在 Farmer John 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 KKK 只奶牛。 设 f(i,0)f(i,0)f(i,0) 表示不取第 iii 头奶牛的最大效率，f(i,1)f(i,1)f(i,1) 则取，那么： f(i,0)=max⁡{f(i−1,0),f(i−1,1)}f(i,1)=max⁡j=i−k+1i{f(j,0)+∑l=jie[l]}f(i,0)=\\max\\{f(i-1,0),f(i-1,1)\\}\\\\ f(i,1)=\\max_{j=i-k+1}^{i}\\left\\{f(j,0)+\\sum_{l=j}^{i}e[l]\\right\\} f(i,0)=max{f(i−1,0),f(i−1,1)}f(i,1)=j=i−k+1maxi​⎩⎨⎧​f(j,0)+l=j∑i​e[l]⎭⎬⎫​ 第二个式子可以使用前缀和变形并拆开： f(i,1)=max⁡j=i−k+1i{f(j,0)−s[j]}+s[i]f(i,1)=\\max_{j=i-k+1}^{i}\\left\\{f(j,0)-s[j]\\right\\}+s[i] f(i,1)=j=i−k+1maxi​{f(j,0)−s[j]}+s[i] max 中的内容便可以使用单调队列来维护。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, k; int a[100005]; int Q[100005], L = 1, R = 0; i64 s[100005], f[100005][2]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); Q[++R] = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); s[i] = s[i - 1] + a[i]; f[i][0] = max(f[i - 1][0], f[i - 1][1]); while (L &lt;= R &amp;&amp; i - Q[L] > k) ++L; f[i][1] = f[Q[L]][0] + s[i] - s[Q[L]]; while (L &lt;= R &amp;&amp; f[i][0] - s[i] > f[Q[R]][0] - s[Q[R]]) --R; Q[++R] = i; &#125; printf(\"%lld\\n\", max(f[n][0], f[n][1])); return 0; &#125; 单调队列优化多重背包 Problemset 有些题需要特定的模型，请参考《动态规划的状态设计》。 状态压缩 DP 这里的题不会很难。 [CF8C] Looking for Order Portal. 一次最多只能拿两个物品，那么转移的时候使用两个 for 循环。记 f(i)f(i)f(i) 代表拿取得物品状态压缩后的最小代价，那么可以直接转移。但是这样的复杂度过高，实际上很多物品的转移都是互不干扰的，只要第一个物品确定了，那么剩下的就可以直接 break 掉了。 本题需要打印解，我们只需要在更新的时候看一下这个状态从哪里来的就可以了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int MAXN = (1 &lt;&lt; 24); const int INF = 0x3f3f3f3f; int n, m; int x[30], y[30]; int f[MAXN + 5], pre[MAXN + 5]; inline int dis(int p, int q) &#123; int a = x[p] - x[q], b = y[p] - y[q]; return a * a + b * b; &#125; int main(void) &#123; scanf(\"%d%d%d\", x, y, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", x + i, y + i); memset(f, 0x3f, sizeof(f)); f[0] = 0; for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) &#123; if (f[i] == INF) continue; for (int j = 0; j &lt; n; ++j) &#123; if (i &amp; (1 &lt;&lt; j)) continue; for (int k = 0; k &lt; n; ++k) &#123; if (i &amp; (1 &lt;&lt; k)) continue; int dp = (i | (1 &lt;&lt; j) | (1 &lt;&lt; k)); int cost = f[i] + dis(0, j + 1) + dis(j + 1, k + 1) + dis(k + 1, 0); if (f[dp] > cost) &#123; f[dp] = cost; pre[dp] = i; &#125; &#125; break; // 接下来的第 j 个物品会有其它的 i 来负责 &#125; &#125; printf(\"%d\\n\", f[(1 &lt;&lt; n) - 1]); int now = (1 &lt;&lt; n) - 1; while (now) &#123; printf(\"0 \"); int update = (now ^ pre[now]); for (int i = 0; i &lt; n; ++i) if (update &amp; (1 &lt;&lt; i)) printf(\"%d \", i + 1); now = pre[now]; &#125; puts(\"0\"); return 0; &#125; [Luogu P3694] 邦邦的大合唱站队 Portal. 类似于上一题，设 f(i)f(i)f(i) 表示当前 MMM 个队伍完成站队的情况，完成记为 111，未完成记为 000，状态压缩后的结果。转移时采用填表法，仅当 iii 的第 jjj 位是 111 时转移： f(i)=min⁡{f(i xor (1&lt;&lt;j)+cnt[j]−sum(x,y))}f(i)=\\min\\{f(i \\text{ xor } (1&lt;&lt;j)+cnt[j]-sum(x,y))\\} f(i)=min{f(i xor (1&lt;&lt;j)+cnt[j]−sum(x,y))} 其中 cnt[j]cnt[j]cnt[j] 代表 jjj 这个乐队的人数，当中有 sum(x,y)sum(x,y)sum(x,y) 个是不需要重新安排的。sumsumsum 的具体求法见代码。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int MM = (1 &lt;&lt; 20) + 5; int n, m, mm; int a[100005], cnt[100005]; int sum[100005][20]; int f[MM]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); mm = 1 &lt;&lt; m; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); --a[i]; // 将它修改为从 0 开始编号的 ++cnt[a[i]]; for (int j = 0; j &lt; m; ++j) sum[i][j] = sum[i - 1][j]; // 将前缀和移过来 ++sum[i][a[i]]; // 修改当前 i 的前缀和 &#125; memset(f, 0x3f, sizeof(f)); f[0] = 0; for (int i = 1; i &lt; mm; ++i) &#123; int len = 0; // 记录需要安排的人数 for (int j = 0; j &lt; m; ++j) if (i &amp; (1 &lt;&lt; j)) len += cnt[j]; for (int j = 0; j &lt; m; ++j) if (i &amp; (1 &lt;&lt; j)) f[i] = min(f[i], f[i ^ (1 &lt;&lt; j)] + cnt[j] - (sum[len][j] - sum[len - cnt[j]][j])); // sum[len][j] 代表在长度为 n 中序列的前 len 位，也就是安排了的人数位，这样 j 的人数 // 减去 sum[len-cnt[j]][j]，给这些人留出 cnt[j] 个位置。这样 j 的人数 &#125; printf(\"%d\\n\", f[mm - 1]); return 0; &#125; [UVA10817] Headmaster’s Headache Portal. 设 f(i,s0,s1,s2)f(i,s_0,s_1,s_2)f(i,s0​,s1​,s2​) 代表扫描到第 iii 个人，没有人教的课程、一个人教和两个人教的课程状压后分别是 s0,s1,s2s_0,s_1,s_2s0​,s1​,s2​，实现采用记忆化搜索。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;sstream> #include &lt;string> #include &lt;cstring> using namespace std; const int INF = 1e9; int S, m, n; int c[125], s[125], f[125][300][300]; int dp(int i, int s0, int s1, int s2) &#123; if (i == m + n) return s2 == (1 &lt;&lt; S) - 1 ? 0 : INF; if (f[i][s1][s2] != -1) return f[i][s1][s2]; int &amp;ans = f[i][s1][s2]; ans = INF; if (i >= m) ans = dp(i + 1, s0, s1, s2); int m0 = s[i] &amp; s0, m1 = s[i] &amp; s1; s0 ^= m0; s1 = (s1 ^ m1) | m0; s2 |= m1; return ans = min(ans, dp(i + 1, s0, s1, s2) + c[i]); &#125; int main(void) &#123; while (cin >> S >> m >> n &amp;&amp; S) &#123; memset(s, 0, sizeof(s)); string st; getline(cin, st); for (int i = 0; i &lt; m + n; ++i) &#123; getline(cin, st); stringstream ss(st); ss >> c[i]; int x; while (ss >> x) s[i] |= (1 &lt;&lt; (x - 1)); &#125; memset(f, -1, sizeof(f)); cout &lt;&lt; dp(0, (1 &lt;&lt; S) - 1, 0, 0) &lt;&lt; '\\n'; &#125; return 0; &#125; 单调队列 DP 这里的单调队列可能会难一点。 [NOI2005] 瑰丽华尔兹 Portal. 设 f(k,i,j)f(k,i,j)f(k,i,j) 代表考虑到第 kkk 个时间段，钢琴位置在 (i,j)(i,j)(i,j) 的最大滑动时间。每一个时间段我们都要枚举起点进行 DP，转移的过程中可以使用滑动窗口寻找最大值。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #define rep(t) for (int i = 1; i &lt;= t; ++i) using namespace std; const int dx[] = &#123;0, -1, 1, 0, 0&#125;, dy[] = &#123;0, 0, 0, -1, 1&#125;; int n, m, sx, sy, k; int f[205][205]; char s[205][205]; pair&lt;int, int> Q[205]; int L, R; void work(int x, int y, int len, int d) &#123; L = 1, R = 0; for (int i = 1; x >= 1 &amp;&amp; x &lt;= n &amp;&amp; y >= 1 &amp;&amp; y &lt;= m; ++i, x += dx[d], y += dy[d]) &#123; if (s[x][y] == 'x') &#123; L = 1, R = 0; continue; &#125; while (L &lt;= R &amp;&amp; Q[R].first + i - Q[R].second &lt; f[x][y]) --R; while (L &lt;= R &amp;&amp; i - Q[L].second > len) ++L; Q[++R] = make_pair(f[x][y], i); f[x][y] = Q[L].first + i - Q[L].second; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;sx, &amp;sy, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", s[i] + 1); memset(f, 0xbf, sizeof(f)); f[sx][sy] = 0; while (k--) &#123; int s, t, d; scanf(\"%d%d%d\", &amp;s, &amp;t, &amp;d); int len = t - s + 1; if (d == 1) rep(m) work(n, i, len, d); else if (d == 2) rep(m) work(1, i, len, d); else if (d == 3) rep(n) work(i, m, len, d); else if (d == 4) rep(n) work(i, 1, len, d); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) ans = max(ans, f[i][j]); printf(\"%d\\n\", ans); return 0; &#125; [SCOI2010] 股票交易 Portal. f(i,j)f(i,j)f(i,j) 代表第 iii 天手里有 jjj 股的价值，那么可以直接买，或是从前一天转移过来，或是从 i−w−1i-w-1i−w−1 天进行买卖。最后一种转移的买的情况的方程如下： f(i,j)=max⁡{f(i−w−1,k)−ap×j+ap×k∣j−as≤k≤j}f(i,j)=\\max\\{f(i-w-1,k)-ap\\times j + ap\\times k\\mid j-as\\le k\\le j\\} f(i,j)=max{f(i−w−1,k)−ap×j+ap×k∣j−as≤k≤j} 这个式子一看就很单调队列，因为相当于找 ap×kap\\times kap×k 的最大值，直接用单调队列维护即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, maxP, w; int f[2005][2005]; // 在第 i 天时，手中持有 j 股，最多的钱 int Q[2005], L = 1, R = 0; void ckmax(int &amp;f, int a) &#123; if (f &lt; a) f = a; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;maxP, &amp;w); memset(f, 0xbf, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; int ap, bp, as, bs; scanf(\"%d%d%d%d\", &amp;ap, &amp;bp, &amp;as, &amp;bs); for (int j = 0; j &lt;= maxP; ++j) f[i][j] = f[i - 1][j]; for (int j = 0; j &lt;= as; ++j) ckmax(f[i][j], -j * ap); L = 1, R = 0; if (i - w &lt;= 1) continue; for (int j = 0; j &lt;= maxP; ++j) &#123; // f[i][j] &lt;- f[i - w - 1][k]，买入 while (L &lt;= R &amp;&amp; Q[L] &lt; j - as) ++L; while (L &lt;= R &amp;&amp; f[i - w - 1][Q[R]] + Q[R] * ap &lt;= f[i - w - 1][j] + j * ap) --R; Q[++R] = j; ckmax(f[i][j], f[i - w - 1][Q[L]] - ap * (j - Q[L])); &#125; L = 1, R = 0; for (int j = maxP; j >= 0; --j) &#123; // f[i][j] &lt;- f[i - w - 1][k]，卖出 while (L &lt;= R &amp;&amp; Q[L] > j + bs) ++L; while (L &lt;= R &amp;&amp; f[i - w - 1][Q[R]] + Q[R] * bp &lt;= f[i - w - 1][j] + j * bp) --R; Q[++R] = j; ckmax(f[i][j], f[i - w - 1][Q[L]] + bp * (Q[L] - j)); &#125; &#125; printf(\"%d\\n\", f[n][0]); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"算法竞赛/学习笔记/动态规划","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压 DP","slug":"状压-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%8A%B6%E5%8E%8B-DP/"},{"name":"单调队列","slug":"单调队列","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"CSP-S & NOIP 2022 游记","slug":"summaries/游记/CSP2022","date":"2022-08-05T00:00:00.000Z","updated":"2022-08-05T00:00:00.000Z","comments":false,"path":"acb544c/","link":"","permalink":"https://james1badcreeper.github.io/acb544c/","excerpt":"本文为 james1 CSP-S 2022 的记录（同时把 NOIP 一起写掉了），大家快来看这个水浸蒟蒻是怎么爆零的吧！","text":"本文为 james1 CSP-S 2022 的记录（同时把 NOIP 一起写掉了），大家快来看这个水浸蒟蒻是怎么爆零的吧！ 暑假 中考之后的故事。 8.5 开坑了文章。这是洛谷 NOIP 计划的第三周，学习图论。刚交完一道 MST 的题目。要求自己坚定意志，钢铁洪流向前进！ 这次，我一定要拿到 300 分。 8.14 NOIP 计划的第四场模拟赛，挂了 100100100 分： 全是 T1 挂的； 正解想到了，但是数组开小了； 不会证明正解，于是还写了个暴力上去； 但是我的正解是倒着输入的，而暴力是正的； 我没有将两个输入分开； 于是暴力 WA 了，正解 RE 了； 265→165265 \\rightarrow 165265→165，rk3 →\\rightarrow→ rk32。 我是废物。 8.20 被 Summer Pockets 刀了（苍线），钻石粒也扛不住啊，被刀哭了…… 为什么末日时（卷三和卷五）和末日再（卷十一）都是刀，魔禁旧约（卷二十二）也是刀（虽然后面回来了），然后这个也是刀啊…… 或者说我看的所有东西都是刀（可能是因为作为提倡者的完美主义压根接受不了刀），或者只是因为这是我第一次玩 Galgame，但是很可能没有第二次了（因为兴趣不在此）。 8.21 早上得知有疫情，军训延期了…… 其实不是很开心（我廿四的军训怎能不参加除非我进了 E 类省队？再延就真的没了）…… 下午 NOIp 计划第五场模拟赛，被打傻了： T1 就是个 Div.4 A，水过去了； T2 感觉正解是搜索+强力的剪枝，但是暴力的搜索都错了，挂了 50 分； T3 写了一个奇怪的剪枝，感觉能得 60，不过多骗了 10 分变成了 70； T4 不会，写二维前缀和得了 50。 为什么这些比赛的部分分都这么水啊qaq。现在的比赛跟以前不一样了啊，以前提高组一道题乱写都能 80+，现在骗分应该都不容易啊。 最后总分是 220220220，rk18。退步了，上一场不挂分有 rk3，这次即使不挂分也只有 rk11。 讲评的时候老师指着我和其它几个人的 T2 的零分：这几个人爆零了我也不太清楚怎么回事…… 公 开 处 刑，有时间的话去复习一下复杂搜索吧…… Extra：T2 是 DP，我是傻子。 不过既然都疫情了，就去多学点高级知识吧（题刷吐了）！ 8.22 原定是这天做核酸检测，但是被取消了。 猜对了，这周学习数论。 8.26 这一段写于 1:24 AM。 第二阶段进行的不是很顺利，但是祝贺学长 @wind_whisper 以 450 分的好成绩夺得 NOI AU，rk 14。%%% 这一段写于 6:05 PM。 来自洛谷 NOIP 计划群 侦测到在途的 3k 打击。 8.28 NOIp 计划第六场模拟赛，被喀秋莎炸死了。 rk41，只有 40 分，rk1 的分数是我的五倍orz。 T2 忘了删掉调试代码，挂了 40； T2 细节实现又出了一些问题，再挂 40； T3 最小瓶颈生成树看成最小生成树了，挂了 40； 我是灯。 舵手，是与他的战舰共存亡的。 8.30 开学，但是上网课前的最后日子！ 稍微写了点文化课，但是发现全都不会。 太菜了，所以拼吧。 8.31 已经开始留作业了，也就意味着这一段的完结。 《蓝色计划》PART-B 需要开启。 网课 虽然是网课，但也是开学了。 钢铁洪流向前进！ 9.2 学校的第一场模拟赛，排名在后一小半。菜是根本，AB 两道数学题，这两周学什么了？而且 C 为什么挂了 75 分？知道数据不可能很强，SPFA 改优先队列肯定能水不少分，但是写挂了？而且明明知道正解要缩点，但是一直没有学有向图的连通性问题？ 9.4 NOIP 计划的第七场模拟赛。 2:00 开考，D 题是 Summer Pockets 好评（但是为什么 CYJian 的背景是䌷啊）。 但是我的语文作业还没有写完，打了大概半个小时浑身难受，脑子不转，读错了两次 T1，还只会最暴力的写法，所以先去写作业了。 刚上高中不会答题，先读了一遍《一本涂书》的对应章节，然后又去做作业，写完快三点半了。 大概用 30min 过掉了 T1，暴力计数碾过去即可，但是二分和快速幂都需要预处理，一开始还自信地认为 O(n2log⁡n)O(n^2 \\log n)O(n2logn) 能过 500050005000，发现并不能（没开 O2 而且常数很大）。 然后看了一下 T2，看不懂。 于是去看直接被标题吸引的 T4，但是不会，而且好像读的题还是错的。 去看 T3，感觉暴力很好写，但是写完有 bug，调了大半个小时没调出来，原地自闭。 给 T4 写了一个 puts(&quot;0&quot;)，并写上了我永远喜欢空门苍。 于是最终 100+0+30+20=150100+0+30+20=150100+0+30+20=150，rk12（实际上没有，因为大神们都没有时间打），为什么 T3 还有 303030 分啊，以为 606060 分的做法要变成 000 了。 然后看了一下群，那个 606060 分的 T3 做法实际上因为数据不够强有 808080 分（我太菜了）。 rk1 的分数是我的两倍，orz。 9.5 这周学习树，最后一周学习内容了。 CCF 喜欢植树造林，而且这是生态环保，所以需要认真学习。 9.6 来自 NOIP 计划群 毒瘤上线了 学习真的是怎么都能学，免费的资料都有不少，关键看怎么推，或者说怎么坚持下来，而且还要保持一定的速度，战争机器不能熄火。 9.7 我真的没有想到我会每天都在这里写字。 学不会 Splay。 9.8 列了计划清单，先整数学和树上问题，数据结构先丢掉。 Unleashed. 9.9 这一段写于 0:06 AM： 其实学起来真的很爽，坚持吧。 另外接到了消息，初赛要在自己家里考（因为疫情），这…… 大概在半夜洛谷 AC 800，NOIP 前必须 AC 1k。 9.10 本来打算去打 pjudge 的，但是又去打洛谷月赛了。 被洛谷月赛爆杀，居然还看错题了。 9.11 学校的第二场模拟赛（跟上周的那场不是一个地方的，这回是八校联考），分数不到三位数，但是题的质量还是真的不错的（大概质量相当于 NOIP 计划最好的一场，就是第六七场）。 稍微做一点文化课和 CF，明天 lxl 场，《最难的线段树》要出现了。 写于半夜： 最近可能会比较累，但是不管怎么说，一定要坚持下来。养成坚持的习惯本身也是一种习惯。真正的大 boss 还没有来呢。 教练的话，害怕 9.12 写于 0:04 AM： 为什么我现在还在写语文作业…… 明天早上定的 6:00 的闹钟写作业，8:00 学校模拟赛，下午 NOIP 计划模拟赛，然后还得准备诺曼底登陆的演讲（不要问我为什么要准备这个玩意，反正就是要讲），然后还得复习文化课，增补部分学习笔记，爆刷 CF…… 加油啊！ 蓝色计划2.0 alpha PART A-III 上午学校的第三场模拟赛，真·被爆杀。 下午 NOIP 计划第八场，比上午简单，但还是不理想，T2 和 T3 啥都不会。 感觉最近状态不太好啊，莫非是睡得太少了？必须赶紧调整回来！ 你怎么睡得着的？你这个阶段睡得着的？我就感觉匪夷所思啊！ 9.13 刷，学，杀。 3k 说 AT 的 Retomejudge 快修好了，期待。 写于 9:25 PM: 学校开始集训了，不过是线上。 被又一道 julian 坑了 90pts。 “鼠”式坦克 9.15 真的，活越来越多。 初赛 以 Day1 代表 9.18 日。 Day -2 9.16。 主要还是学习一些文化课，写作业，补 NOIP 计划题单。 初赛什么不担心的，辽宁省这边只要不作弊就肯定能过。因为是线上考，所以打算明天检查一下设备。 太阳，你在哪里？ Day 1 9.18。 12:00 之后才测了一下设备，不愧是我。 宇宙射线那个题被 NOIP 计划群里的人押中了，orz。 感觉比去年简单了太多，不过选 B 的变少了。 线上考，文件死活不会传，寄了。 作业还没有写完，我明天还需要讲斯大林格勒（不是诺曼底了，改了）。 第二轮 内容预计包括网课的最后一周、复学、国庆秋令营和 CSP 第二轮。 网课的最后 这应该是最后一周的网课了。 9.19（斯大林格勒） 上午边听课边练习斯大林格勒的演讲。 中午讲的时候好像效果还不错？我也要成为钢铁之人！ NOIP 计划真·进入了后期，3k 发威了。 冲！ 做题重心开始转移，按照蓝色计划 PART-A 第四阶段进行冲刺。 晚上发生了某些事情，想哭。 在这里只用了寥寥几个文字替代。 本来还想写点什么，但就是写不出来。 不仅是语文差，更是因为有些心情真的无法用文字表达。 9.20 Burn everything with raging Hellfire. 我们从地狱中归来，只为清算。 教练讲的好有道理（不是上面这句话！）。 9.21 写于 0:06 AM。 Revenge. 写于 9:55 AM。 Revenging. 有的时候总是忘了初心，学习的目的是学会新的知识点。 9.22 斗志不死。 稍微更改了下蓝色计划。 9.23 活怎么这么多……今天学校模拟赛，然后还有 CF，然后还不停课，文化课作业一堆。 但是做的好爽。 明天要去学校做核酸啦，终于可以回去了！ 但是现在真的有点累，吗？ 9.24 蓝色计划 2.0 PART A-V Eschaton 复学 刚开始很乱，但是后面真的很有意思。 9.25 手忙脚乱.jpg 9.26 真的开学啦！ 文化课非常好！然而下午居然还有各种奇怪的课程！ 食堂非常好！价钱是隔壁学校的一半但是质量是两倍！自助餐 20 元一位（我们班主任老师说不要去三四楼吃东西，说的好有道理）！ 反正很好！下午模拟赛！炸死了！ 钢铁洪流！ 9.30 好久没写东西了，来胡乱写点。 最近挺忙，真没有什么时间来写。或者是没什么心情写。 题非常的多，然而还没多少时间去补。 国庆 。。。 10.3 很久没写东西了，主要是真的没时间写。 现在真的没这种闲心了，毕竟高一的这段时间是不可能停课的。想要同时抓文化课和 OI 真的很累。 10.4 上午模拟赛为什么有两个签到题啊qaq 然后这是最后的机会了，否则只能退役了。 我们会不择手段地追求胜利。 10.5 我这个人还有得救。 上午的 NOIp 多校模拟活活出成了省选场难度 垒球洪流。 狂暴模式。 第二轮 我希望我抛掉自己的感情。 I, Robot. 10.16 上午没有去学校打多校，打算下午认真打一下 NOIP 计划的第十二场。 然后 205，但是 Luogu 上测是 270…… 明显是输在了 T2 上（拿了 50 分的特殊性质），这个真的不应该连一个二分都想不出来。 有人 AK 了，但是显然 T3 远远超出了我的能力范围，与 rk1 差这 75 分很正常。T4 暴力冲过去 19 个点拿了 95 把我整懵了，正解也不难想，就是根号分治优化。难度 T1 &lt; T2 &lt; T4 &lt; T3。 然后作业写不完了 突然感觉家长说的好对，在这个阶段，作为一个机器人是真的有用。 无尽的钢铁洪流碾过了地狱，将地狱冰封。明天，一定能到达那蓝色彼端。 10.19 垒球。垒球。垒球！ 禁止摆烂。 购买了垒球。 10.22 今天是星期六，也就是说下一周的这个时候就 CSP 了。 教练说 CSP 只是练兵，但实际上还是感觉不太稳。感觉今年的难度还是会再加强，想要获得一个比较好的成绩至少需要切掉两道题，然而这种事我从来没有干出来过。 综上所述，要寄。 学校模拟赛，被评测系统吞了 100。100 分祭天，CSP 能不能运气好点？ 10.23 文化课！又爱又恨！ 受限于高考的原因，很多内容老师都只开了个头，然后“感兴趣的同学可以研究，竞赛生应该都会”！虽然我理解为了高考只能这么做，毕竟课真的很紧张！ 所以，一定要学竞赛啊！否则高中白上了！ 发生了一件有趣的事情：垒球滚键盘了。 下午是 NOIP 计划的第十三场（没错，上午的多校我又没打），这也是我 CSP 之前（应该是）的最后一场模拟赛了。 然而全程自闭，165165165 在后 80%80\\%80% 菜爆了。 事后发现 T2 贼简单，但是我只会部分分，我是废物。 垒球。 10.24 下午把综合技术和围棋课翘掉了。 拿着垒球在学校狂奔 运动会拿了个倒数第一 10.25 凌晨写下的文字： 正式开始省选学习的预习阶段，反正是 —— Dash！ 蓝色计划 2.0 plus PART B-I DASH Day -3 10/26，晚上到达酒店。 然后大家去打三国杀了，我也不会打，看了一会还是不会，就去干别的了。 跟 KH 一个屋，orz 然后三国杀打到了 11 点，orz Day -2 早上起床困难症。 中午 dqq 订的饭，%%%\\%\\%\\%%%% 今天下午居然有模拟赛，orz 然后被爆杀，orz 晚上写线段树调不出来了，orz Day -1 晚饭的时候 KH 和 dqq 讨论了机器人与意识存在，最后的结论是：这个世界是由 wind_whisper 创造的，KH 是 wind_whisper 的意识，dqq 和我这种异类应该被驱逐。 晚上大家在打块，但是我不会打 Day 1 中午膜拜了垒球和 wind_whisper，然后就进去了。 致命伤：刷题太少，手速太慢。 大概用 1h 写了 T1 的 707070，1.5h 写了 T2 的 757575，太垃圾了。 写了 T4 的 323232 分，但是有一个子任务忘记删去调试代码了，挂了一半，寄。 T3 的暴力就没 Dash 出来。 分倒是没挂，也没什么可挂的了。 然后多个民间数据的结果证明，KH AK 了，太强大了。 晚上学长看我艰难的学习分块 总结：以后的文件输入输出和调试代码都不要注释，用 ifdef 包裹起来，并且将调试内容输出到 stderr，进一步降低出错的可能。 Day 2 考完了，但是却魔了。 这几天的收获真的很多，KH 和 dqq 都教了我很多，感谢。 我或许需要好好规划一下接下来该怎么办。 跟 gg 申请了停课。 NOIP 停课申请成功了！ 鬼城 发现自己必须 Dash，需要考到 NOIP 一等奖才能获得 3k 的奖金，而且还需要冲进 10%10\\%10% 拿到 7 级钩，还需要 Dash 进前面保证课能停到省选，并且排名在前面才能有机会冲过省选。 11.2 垒球。 注意，不是 T1 做不出来就意味着后面废了。难度是主观判断的，所以没有顺序。 停课最大的问题是如何合理安排时间，否则这种自由只会把你送进地狱。 现在熟悉节奏了吧？是时候动真格的了！ 11.3 希望知道自己在做什么。 节奏不要乱，我拿的是自己的键盘。 11.4 看了多头的随笔，真的很深刻。 命运是可以掌控的，运气是可以获得的，但获得的只是运气。 11.5 多校被爆杀，状压 DP 没 Dash 出来 晚上 AT 太刺激了，结束前 5s 交了个卡时做法卡过去了 明天是不是有三场比赛啊…… 11.6 上午学校模拟真好玩 下午 NOIp 计划，T4 我不会 ODT，算错了次数导致没写花神游历各国，直接死掉 505050 分。 科技这种东西还是要稍微爬一下，不能全堆到省选。 晚上 CF 吐了。 冬之夏 眩しさだけは、忘れなかった。\\large\\color{skyblue}眩しさだけは、忘れなかった。 眩しさだけは、忘れなかった。 11.7 CSP 出分了，203，太垃圾了。没有希望了，要退役了。 明明今天冬至，心还在那盛夏。感谢你的陪伴。 11.8 我只能说模拟赛 T2 出母函数，T4 考自动机上 DAG 链剖分的出题人是毒瘤。 11.9 做好觉悟吧。 现在，凛冬将至。This is THE EXILE. 加油啊，james1！ 11.12 打了 CF Div.2，太菜了，C 都不会。 我是什么呀 11.15 模拟赛中阵亡的日常 呜呜呜，太菜了，快去干该干的事情吧。 奋斗仍然是最有意义的答案。 DEAD END 我宣布我将在 NOIP 2022 之后退役。输了就是输了，没有什么好反驳的。在这里祝愿剩下的人能坚持战斗下去。我是废了。既然如此，在考场上，OI 生涯中的最后四个小时，总得好好打吧，至少也打个爆零，别考试作弊了。 11.20 (Day -6) 上下午的模拟赛都自闭了。 再见了，OI。 11.21 (Day -5) 多头好闪，拜谢多头。 准备退役。 归途 NOIP 取消了。可能用 CSP 成绩算，那就没机会了，摆烂吧。 后记 其实也没什么好说的了，开始了。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"简单树形问题","slug":"notes/DS/tree","date":"2022-08-01T00:00:00.000Z","updated":"2022-08-01T00:00:00.000Z","comments":true,"path":"85699f68/","link":"","permalink":"https://james1badcreeper.github.io/85699f68/","excerpt":"本文对简单的树形问题进行了讲解。","text":"本文对简单的树形问题进行了讲解。 有关树的问题在考试时非常常见，所以必须熟练掌握。本文介绍的问题都比较简单，不涉及什么高难的问题。 树的性质与遍历 我们知道，一棵树有 nnn 个点，n−1n-1n−1 条边，且一定是连通的。有几种特殊的树： 链：树退化成链式结构。 “菊花图”：树的深度恰好为 222。 [Luogu P5908] 猫猫和企鹅。 可以简单的使用树的深度优先遍历来解决问题。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, d, ans = 0, dis[100005]; vector &lt;int> G[100005]; void dfs(int o, int f) &#123; if (dis[o] &lt;= d &amp;&amp; o != 1) ++ans; for (int i = 0; i &lt; G[o].size(); ++i) &#123; int &amp;y = G[o][i]; if (y == f) continue; dis[y] = dis[o] + 1; dfs(y, o); &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;d); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 边权转点权。实际上在树形问题中，边权非常不好处理，所以我们可以在深度优先遍历的时候将边权全放给儿子。大概像这样： d[y] = w; // 转移边权为儿子的点权 dfs(y, x); 树的直径 指的是树上的最长路径，可以通过两次 DFS 求出。第一次 DFS 从任意节点开始遍历，走到最远的地方，然后从这个地方开始第二次 DFS，走到最远的地方。这两个最远的地方连接起来就是树的直径。 模板，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, maxx = 0; bool v[10005]; int dis[10005]; vector &lt;int> G[10005]; void dfs(int o, int fa) &#123; for (int i = 0; i &lt; G[o].size(); ++i) &#123; if (G[o][i] == fa) continue; dis[G[o][i]] = dis[o] + 1; if (dis[G[o][i]] > dis[maxx]) maxx = G[o][i]; dfs(G[o][i], o); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, -1); memset(v, 0, sizeof(v)); dis[maxx] = 0; dfs(maxx, -1); printf(\"%d\\n\", dis[maxx]); return 0; &#125; 树的直径有一个显然的性质：直径的某个端点到所有点的距离的最小值一定是所有点中最大的。 树的重心 对于树上的每一个点，计算其所有子树中最大的子树节点数，使得这个值最小的点就是这棵树的重心。树的重心有以下性质： 以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。 使用反证法。设当前的重心为 uuu，与 uuu 相连的子树 vvv 的大小超过了整棵树的一半，那么将 vvv 替换为树的重心，显然这时 uuu 的子树不超过整棵树大小的一半，而 vvv 的子树大小减小了 111，一定比 uuu 作为重心更好。 树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。 因为如果移动了，增加的距离一定大于等于减少的距离。 把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。 如果不在这条路径上，那么只有那个节点的子树的代价会减小，其它的都会增加，得不偿失。 在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。 增加或减少一个叶子，只能使最大的子树恰好比一半多 111，重心只移动 111 即可。 现在我们来看如何求出树的重心。我们假定 111 为根节点，然后设 size[x]size[x]size[x] 代表 xxx 的子树大小。我们定义 max_part 为当前 dfs 到的节点中，最大的子树大小。它的孩子们的子树大小在 dfs 时就可以统计，而剩下的一棵子树就是它父亲对应的子树，这就是 n−size[x]n-size[x]n−size[x]。这样只需要调用一次 dfs，时间复杂度为 O(n)O(n)O(n)。 int n, pos, ans = 1e7; // pos 为重心，ans 为重心对应的最大子树 int s[105]; vector &lt;int> G[105]; void dfs(int x, int fa) &#123; s[x] = 1; int max_part = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; // 想逃回父亲，直接枪毙 dfs(y, x); s[x] += s[y]; // 父节点的子树大小加上子节点的 max_part = max(max_part, s[y]); // 更新 max_part &#125; max_part = max(max_part, n - s[x]); // 最后一棵子树是父亲节点对应的子树（这里的子树是指以 x 为根的情况） if (max_part &lt; ans) // 答案更优就更新 &#123; ans = max_part; pos = x; &#125; &#125; 学过树形 DP 的读者应该可以发现这个东西类似于换根 DP，但又不太一样。 最近公共祖先（LCA） LCA 是指点集的 LCA，为了方便，我们记某点集 A={ui∣1⩽i⩽n}A=\\{u_i|1\\leqslant i\\leqslant n\\}A={ui​∣1⩽i⩽n} 的最近公共祖先为 LCA(u1,u2,…,un)LCA(u_1,u_2,\\ldots,u_n)LCA(u1​,u2​,…,un​) 或 LCA(A)LCA(A)LCA(A)。含义是离它们最近的一个点，是它们所有点的祖先。 LCA 有以下性质： LCA(u)=uLCA(u)=uLCA(u)=u； LCA(u,v)=uLCA(u,v)=uLCA(u,v)=u 的充要条件是 uuu 是 vvv 的祖先； 如果 uuu 不为 vvv 的祖先并且 vvv 不为 uuu 的祖先，那么 u,vu,vu,v 分别处于 LCA(u,v)LCA(u,v)LCA(u,v) 的两棵不同子树中； 给定一棵二叉树，前序遍历中，LCA(S)LCA(S)LCA(S) 出现在所有 SSS 中元素之前，后序遍历中 LCA(S)LCA(S)LCA(S) 则出现在所有 SSS 中元素之后； 两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 LCA(A∪B)=LCA(LCA(A),LCA(B))LCA(A \\cup B) = LCA(LCA(A),LCA(B))LCA(A∪B)=LCA(LCA(A),LCA(B))； 两点的最近公共祖先必定处在树上两点间的最短路上，且 dist(u,v)=h(u)+h(v)−2h(LCA(u,v))dist(u,v)=h(u)+h(v)-2h(LCA(u,v))dist(u,v)=h(u)+h(v)−2h(LCA(u,v))，其中 h(x)h(x)h(x) 指 xxx 到树根的距离。 这些性质都比较显然，在此不做证明。 现在我们来讨论 LCA 的求法。 LCA 有多种求法，不同情况要用不同的方法。 可以在 模板 进行测试。 向上标记法 比如我们现在要求 LCA(u,v)LCA(u,v)LCA(u,v)，我们可以先让 uuu 和 vvv 向上跳到同一深度，然后让它们一起往上调，一定可以找到它们的 LCA。 int n, m, root; vector &lt;int> G[500005]; bool v[500005]; struct node &#123; int p, fa, dep; &#125;T[500005]; void dfs(int o, int deep) &#123; v[o] = 1; T[o].dep = deep; for (int i = 0; i &lt; G[o].size(); ++i) if (!v[G[o][i]]) &#123; T[G[o][i]].fa = o; dfs(G[o][i], deep + 1); &#125; &#125; int LCA(int x, int y) &#123; if (T[x].dep &lt; T[y].dep) swap(x, y); while (T[x].dep > T[y].dep) x = T[x].fa; // 跳到同一深度 if (x == y) return x; // 此处特判可以略去，但习惯写上 while (x != y) x = T[x].fa, y = T[y].fa; // 一起往上跳 return x; &#125; int main(void) &#123; n = read(), m = read(), root = read(); for (int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); G[x].push_back(y); G[y].push_back(x); &#125; T[root].fa = -1; dfs(root, 1); // 构造树 while (m--) &#123; int a = read(), b = read(); cout &lt;&lt; LCA(a, b) &lt;&lt; endl; &#125; return 0; &#125; 树上倍增法 以上做法极慢，最常用的快速求 LCA 的方法是树上倍增法。设 f[x,k]f[x,k]f[x,k] 表示 xxx 的 2k2^k2k 辈祖先。若该节点不存在，则令 f[x,k]=−1f[x,k]=-1f[x,k]=−1（不设为 000 的原因是有的题需要设一个编号为 000 的虚拟节点）。那么有 f[x,k]=f[f[x,k−1]][k−1]f[x,k]=f[f[x,k-1]][k-1]f[x,k]=f[f[x,k−1]][k−1]，接下来的思路跟向上标记法大致相同。 在求解 LCA 时，我们先让它们都跳到同一深度。如果此时两个点已经相等，那么这个点就是 LCA（此步不能略去，原因接下来会说明）。然后我们尝试着让它们一起往上跳，如果跳完值还不相等，那一定跳。最后再跳一步即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m, root; int dep[500005]; int lg[500005]; int f[500005][20]; vector &lt;int> G[500005]; void dfs(int o, int fa) &#123; f[o][0] = fa; // 根据定义 dep[o] = dep[fa] + 1; // 深度为父亲 +1 for (int i = 1; i &lt;= lg[n]; ++i) // 跳出树的值都会变成 -1 f[o][i] = f[f[o][i - 1]][i - 1]; for (int i = 0; i &lt; G[o].size(); ++i) if (G[o][i] != fa) dfs(G[o][i], o); // 如果不往父亲回，就以 G[o][i] 为儿子，o 为父亲 dfs &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) // 从一个最大可能值开始枚举，这样做的正确性基于二进制拆分 if (dep[f[x][i]] >= dep[y]) x = f[x][i]; // 如果跳这么大深度依然比 y 大，那只能跳 if (x == y) return x; // 此步不能省去，否则已经是 LCA，最后 return 时还会再跳一次 for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; // 如果跳这么大都不相等，此时必须要跳 return f[x][0]; // 最后再跳一步便一定是 LCA &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;root); lg[1] = 0; for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(root, -1); // 让 -1 作为根节点的“父亲“，使得 f 数组中跳出树的都变成 -1 while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", LCA(x, y)); &#125; return 0; &#125; 除了求解 LCA 问题，很多树上问题都会用到树上倍增法。 树上前缀和与差分 前缀和和差分是线性结构上的有力工具，但是它们也可以搬到树上来。 树上前缀和 设 SiS_iSi​ 代表根节点到节点 iii 的权值总和，那么： 如果是边权，那么 d(x,y)=Sx+Sy−2×SLCA(x,y)d(x,y)=S_x+S_y-2\\times S_{LCA(x,y)}d(x,y)=Sx​+Sy​−2×SLCA(x,y)​， 如果是点权，那么 d(x,y)=Sx+Sy−SLCA(x,y)−Sfa[LCA(x,y)]d(x,y)=S_x+S_y-S_{LCA(x,y)}-S_{fa[LCA(x,y)]}d(x,y)=Sx​+Sy​−SLCA(x,y)​−Sfa[LCA(x,y)]​（因为 LCA 处只能减一次）。 树上点差分 也就是对于点权的树上差分。也就是说，给定若干条路经，求出每个点经过的次数。那么： // s -> t d[s]++, d[t]++; d[lca(s, t)]--, d[fa[lca(s, t)]]--; 当然不同的数值也可以改。 模板。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, k, lg[50005], dep[50005]; int f[50005][18], sum[50005]; vector &lt;int> G[50005]; void dfs(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (int i = 0; i &lt; G[x].size(); ++i) if (G[x][i] != fa) dfs(G[x][i], x); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; void get(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; get(y, x); sum[x] += sum[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; dfs(1, 0); while (k--) &#123; int s, t, lca; scanf(\"%d%d\", &amp;s, &amp;t); lca = LCA(s, t); sum[s]++, sum[t]++; sum[lca]--, sum[f[lca][0]]--; &#125; get(1, 0); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, sum[i]); printf(\"%d\\n\", ans); return 0; &#125; 树上边差分 还是直接将边前缀和搬过来： d[s]++, d[t]++; d[lca(s, t)] -= 2; DFS 序列 树在进行 DFS 时，会有入栈出栈的顺序，而且每一个树恰好入栈一次、出栈一次。这样产生的序列就是树的 欧拉序。如果只记录一次节点，那么产生的是 DFS 序，访问到顺序记为时间戳 dfn。 概述 比如这样一棵树： 它的欧拉序就是 1 4 4 2 6 8 8 6 5 5 2 3 7 7 3 1。 可以发现，欧拉序有以下性质： 若树的大小为 nnn，那么欧拉序的长度就等于 2n2n2n，每个数恰好出现了两次。 每棵子树 xxx 在欧拉序中一定是连续的一段，节点 xxx 一定同时在这个连续段的两端。 而 DFS 序可以与树上差分结合起来，实现满足差分信息的树上信息高效维护。下面我们来看 DFS 序的应用： 单点修改 模板。 单点增加，查询子树和。 根据 DFS 序列的性质，我们可以将树上信息转化到链上来维护。怎么转呢？可以发现，子树一定是在根后面连着的，那么我们记录 sizsizsiz 大小就可以了。 接下来就是 Fenwick 树了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define lowbit(x) (x &amp; -x) using namespace std; typedef long long i64; int n, m, root; int a[1000005], siz[1000005]; int dfn[1000005], num = 0; vector &lt;int> G[1000005]; i64 C[1000005]; void add(int x, int k) &#123; while (x &lt;= n) &#123; C[x] += k; x += lowbit(x); &#125; &#125; i64 sum(int x) &#123; i64 res = 0; while (x) &#123; res += C[x]; x -= lowbit(x); &#125; return res; &#125; void dfs(int x, int fa) &#123; dfn[x] = ++num; siz[x] = 1; add(num, a[x]); for (auto y : G[x]) &#123; if (y == fa) continue; dfs(y, x); siz[x] += siz[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;root); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(root, 0); while (m--) &#123; int op, a, x; scanf(\"%d%d\", &amp;op, &amp;a); if (op == 1) &#123; scanf(\"%d\", &amp;x); add(dfn[a], x); &#125; else &#123; printf(\"%lld\\n\", sum(dfn[a] + siz[a] - 1) - sum(dfn[a] - 1)); &#125; &#125; return 0; &#125; 子树修改 模板。 子树所有节点增加 xxx，子树节点和。 实际上是一样的，我们只需要将树状数组替换为线段树（当然，利用拆分信息树状数组也可以做）。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; int n, m, root; int a[1000005], siz[1000005]; int dfn[1000005], idx[1000005], num = 0; vector &lt;int> G[1000005]; i64 T[4000005]; int tag[4000005]; void build(int o, int l, int r) &#123; if (l == r) return T[o] = a[idx[l]], void(); int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; inline void pushdown(int o, int l, int r) &#123; if (!tag[o]) return; int mid = l + r >> 1; T[o &lt;&lt; 1] += 1ll * (mid - l + 1) * tag[o], T[o &lt;&lt; 1 | 1] += 1ll * (r - mid) * tag[o]; tag[o &lt;&lt; 1] += tag[o], tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o] += 1ll * (r - l + 1) * k, tag[o] += k, void(); int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; i64 query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; i64 res = 0; pushdown(o, l, r); if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; void dfs(int x, int fa) &#123; dfn[x] = ++num; idx[num] = x; siz[x] = 1; for (auto y : G[x]) &#123; if (y == fa) continue; dfs(y, x); siz[x] += siz[y]; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;root); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(root, 0); build(1, 1, n); while (m--) &#123; int op, a, x; scanf(\"%d%d\", &amp;op, &amp;a); if (op == 1) &#123; scanf(\"%d\", &amp;x); update(1, 1, n, dfn[a], dfn[a] + siz[a] - 1, x); &#125; else &#123; printf(\"%lld\\n\", query(1, 1, n, dfn[a], dfn[a] + siz[a] - 1)); &#125; &#125; return 0; &#125; 链上修改 这里简单提一下，有兴趣可以写一下模板。 我们说过，DFS 序维护的依旧是前缀和，所以利用树上差分的方式，配合树状数组可以快速修改与查询，会比重链剖分少一个 log⁡\\loglog。 但是当维护的内容不满足差分的区间可减性，DFS 序就做不了了。 快速 LCA DFS 序求 LCA 是常用方式中最快的 LCA 算法，并且是在线的。可以做到 O(nlog⁡n)O(n\\log n)O(nlogn) 预处理，O(1)O(1)O(1) 查询。而欧拉序求 LCA 则有 222 倍的常数，至于利用笛卡尔树的 O(n)O(n)O(n) 预处理做法则并不使用，因为大部分树上问题都是带 log⁡\\loglog 的。尤其是对于虚树这询问 LCA 次数极多的东西，DFS 序的优势很大。 考虑树上的两个节点 u,vu,vu,v 和其 LCA ddd，ddd 显然在 u,vu,vu,v 之前出现。 如果 uuu 不是 vvv 的祖先，我们只需要求出 uuu 和 vvv 的 DFS 序之间深度最小的一个节点，它的父亲就是 ddd。 如果是，那么直接令 uuu 变成 dfn 比它大 111 的节点，就转化成了上一种情况。 只需要特判掉 u=vu=vu=v，这样就可以直接改变 uuu 的 DFS 序了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 5e5 + 5; int n, m, root, num, dfn[N], dep[N], lg[N], mi[20][N]; vector&lt;int> G[N]; inline int get(int x, int y) &#123; return dep[x] &lt; dep[y] ? x : y; &#125; // 这个 inline 有用 void dfs(int x, int fa) &#123; mi[0][dfn[x] = ++num] = fa, dep[x] = dep[fa] + 1; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int u, int v) &#123; if (u == v) return u; if ((u = dfn[u]) > (v = dfn[v])) swap(u, v); int d = lg[v - u]; return get(mi[d][u + 1], mi[d][v - (1 &lt;&lt; d) + 1]); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;root); for (int i = 2; i &lt;= n; i++) lg[i] = lg[i >> 1] + 1; for (int i = 1, u, v; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs(root, 0); for (int i = 1; i &lt;= lg[n]; i++) for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; j++) mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1, u, v; i &lt;= m; i++) scanf(\"%d%d\", &amp;u, &amp;v), printf(\"%d\\n\", LCA(u, v)); return 0; &#125; 树链与树链剖分 我们学过的很多内容，比如线段树，都只能处理序列，也就是链上的问题。当它跑到了树上，我们还可以使用 DFS 序列来进行处理。但是当维护的信息不满足差分性质后，DFS 序就显得无力了。这是候怎么办？要对树链进行处理了。 概念 我们先简单介绍一下相关概念。 树链是指树上的一条链，树链剖分就是将整棵树剖分成若干条链，使它组合成线性结构，然后可以在线性结构上工作的强大数据结构就可以派上用场了，也简称树剖。 树链剖分有多种形式，比如重链剖分，长链剖分和实链剖分，其中重链剖分最为常用，大部分树剖指的都是它。 这里只介绍最常用的重链剖分，长链剖分请参考《复杂树形问题》。 重链剖分 我们先来看一下这个问题： 你需要写一种数据结构，支持区间修改和区间查询。 这个我当然会！直接线段树敲上去不久完事了嘛！ 那么再来一个： 给出一棵树，支持链上修改，链上查询，子树修改，子树查询。 这是什么？ 这个题是有的，模板。 我们不会这种题，我们只会在链上做，那就需要使用树链剖分。 重链剖分可以将树上的任意一条路径划分成长度不超过 O(log⁡n)O(\\log n)O(logn) 的连续链，每条链上的点深度互不相同（即自底向上的一条链，链上所有点的 LCA 为链的深度小的那个端点）。 我们首先需要了解几个概念： 子树的大小：子树中节点的个数。 重子节点（重节点）：表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。 轻子节点（轻节点）：除了重子节点外的所有节点。特别地，树根是轻节点。 重边：连接节点到它的重子节点的边。 轻边：除了重边之外的所有边。 重链：若干条首尾连接的重边，也就是说，一条重链的开头是一个轻节点，剩下的都是重节点。特别地，一个落单的节点也是重链。 这样整棵树就被剖分成若干条重链，可以证明链的规模是 O(log⁡n)O(\\log n)O(logn) 的。 实现时要通过两次 dfs，大概像这样： int f[100005], son[100005], top[100005]; // son 指重儿子，没有为 -1；top 指重链的顶端节点的标号 int dep[100005], siz[100005], dfn[100005], tot = 0; // dfn 指时间戳 vector &lt;int> G[100005]; void dfs1(int x, int fa) &#123; dep[x] = dep[fa] + 1; f[x] = fa; siz[x] = 1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) // topf 记录这个重链的顶点 &#123; dfn[x] = ++tot; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); // 优先处理重链 for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); // 遍历轻儿子 &#125; 注意到重链的处理总是优先的，也就是说，重链内的时间戳编号是连续的，那么就决定了我们维护的时候直接对应了一段序列上的区间。 建立一棵线段树，以 xxx 到 yyy 的最短路径上加上 zzz 为例，像这样： while (top[x] != top[y]) // 如果它们不在一条重链上 &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); // 要计算深的节点 update(1, 1, n, dfn[top[x]], dfn[x], z); // 更新 x = f[top[x]]; // 跳上来，注意重链的头部已经修改过了，跳到重链头的父亲上 &#125; if (dep[x] > dep[y]) swap(x, y); update(1, 1, n, dfn[x], dfn[y], z); // 现在已经在一条重链上，更新 发没发现这个处理特别像 LCA 的求解？没错，LCA 确实也可以用树链剖分来求解，但是不如倍增简单，除非恰好这道题目需要用到树链剖分，我们才会使用树链剖分来求解 LCA。 那么对于子树的操作呢？由于是深度优先遍历，所以一棵子树内的时间戳编号也是连续的（依然具有 DFS 序的性质），也可以直接使用线段树维护： update(1, 1, n, dfn[x], dfn[x] + siz[x] - 1, k); // 利用子树的大小直接计算 那么完整代码就很简单了： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; int n, m, root, P; int w[100005], f[100005], son[100005], top[100005]; int dep[100005], siz[100005], dfn[100005], tot = 0, a[100005]; vector &lt;int> G[100005]; void dfs1(int x, int fa) &#123; dep[x] = dep[fa] + 1; f[x] = fa; siz[x] = 1; int maxx = -1; for (auto y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > maxx) son[x] = y, maxx = siz[y]; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++tot; top[x] = topf; a[tot] = w[x]; if (son[x] == -1) return; dfs2(son[x], topf); for (auto y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int T[400005], tag[400005]; inline void maintain(int o) &#123; T[o] = (T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]) % P; &#125; inline void pushdown(int o, int l, int r) &#123; if (!tag[o]) return; int mid = l + r >> 1, ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; tag[ls] = (tag[ls] + tag[o]) % P, tag[rs] = (tag[rs] + tag[o]) % P; T[ls] = (T[ls] + 1ll * tag[o] * (mid - l + 1)) % P, T[rs] = (T[rs] + 1ll * tag[o] * (r - mid)) % P; tag[o] = 0; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o] = a[l] % P; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); maintain(o); &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; T[o] = (T[o] + 1ll * k * (r - l + 1)) % P; tag[o] = (tag[o] + k) % P; return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); maintain(o); &#125; int query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return T[o]; pushdown(o, l, r); int mid = l + r >> 1, res = 0; if (ql &lt;= mid) res = (res + query(o &lt;&lt; 1, l, mid, ql, qr)) % P; if (mid &lt; qr) res = (res + query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr)) % P; return res; &#125; int main(void) &#123; memset(son, 0xff, sizeof(son)); scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;root, &amp;P); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", w + i); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs1(root, 0); dfs2(root, root); build(1, 1, n); while (m--) &#123; int k, x, y, z; scanf(\"%d\", &amp;k); if (k == 1) &#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); z %= P; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); update(1, 1, n, dfn[top[x]], dfn[x], z); x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); update(1, 1, n, dfn[x], dfn[y], z); &#125; else if (k == 2) &#123; scanf(\"%d%d\", &amp;x, &amp;y); int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ans = (ans + query(1, 1, n, dfn[top[x]], dfn[x])) % P; x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); ans = (ans + query(1, 1, n, dfn[x], dfn[y])) % P; printf(\"%d\\n\", ans); &#125; else if (k == 3) &#123; scanf(\"%d%d\", &amp;x, &amp;k); update(1, 1, n, dfn[x], dfn[x] + siz[x] - 1, k); &#125; else &#123; scanf(\"%d\", &amp;x); printf(\"%d\\n\", query(1, 1, n, dfn[x], dfn[x] + siz[x] - 1)); &#125; &#125; return 0; &#125; 算法理论实践复杂度为 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)，但实际上远远达不到上界，重链剖分的常数很小。 但即使如此，树链剖分也是比 DFS 序慢的。如果能使用 DFS 序，更推荐用它。 树链剖分求 LCA 之前维护链的过程很像求 LCA 往上跳的过程，所以重链剖分也可以用来求 LCA。 int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; // 不在一条重链上 if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; 一般来讲树链剖分会比倍增算法快一点，常数也很小（想想那个二维数组吧），甚至不会比 O(1)O(1)O(1) LCA 慢（因为有寻址）。 Problemset 我们来看一些有趣的题目，前面的一些题目都很简单，后面的部分题目相当复杂。 简单树形问题 不涉及什么算法，只需要树的有关知识，以及求解树的直径和树的重心的方法等即可。 [JLOI2012] 树 Portal. 直接 dfs 遍历树即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, c, ans = 0, a[100005]; vector &lt;int> son[100005]; void dfs(int o, int sum) &#123; if (sum == c) return ++ans, void(); if (sum > c) return; for (auto x : son[o]) dfs(x, sum + a[x]); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;c); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); son[u].push_back(v); &#125; for (int i = 1; i &lt;= n; ++i) dfs(i, a[i]); printf(\"%d\\n\", ans); return 0; &#125; [YsOI2020] 植树 Portal. 类似于求树的重心，不过要统计的是子树的大小。注意 111 号节点肯定是可以的。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, s[1000005]; bool flag[1000005]; vector &lt;int> G[1000005]; void dfs(int x, int fa) &#123; int num = 0; s[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; dfs(y, x); s[x] += s[y]; if (!num) num = s[y]; if (num != s[y]) flag[x] = true; &#125; if (x != 1 &amp;&amp; num &amp;&amp; num != n - s[x]) flag[x] = true; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) if (!flag[i]) printf(\"%d \", i); putchar('\\n'); return 0; &#125; [NOIP2014 提高组] 联合权值 Portal. 由于距离为 222，所以枚举每一个点，与它相邻的点两两互为联合点，然后使用 nnn 项式的平方计算即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define MOD 10007 using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int W[200005]; vector &lt;int> G[200005]; int main(void) &#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; ++i) W[i] = read(); int anssum = 0, ansmax = 0; for (int i = 1; i &lt;= n; ++i) &#123; int res = 0, ret = 0; int maxx1 = 0, maxx2 = 0; for (int j = 0; j &lt; G[i].size(); ++j) &#123; #define pocket W[G[i][j]] if (pocket > maxx1) maxx2 = maxx1, maxx1 = pocket; else if (pocket > maxx2) maxx2 = pocket; res = (res + pocket) % MOD; ret = (ret + pocket * pocket) % MOD; &#125; anssum = (anssum + res * res % MOD - ret + MOD) % MOD; ansmax = max(ansmax, maxx1 * maxx2); &#125; printf(\"%d %d\\n\", ansmax, anssum); return 0; &#125; [NOI2011] 道路修建 Portal. 我们采用类似求树的重心的方法。统计一条边的费用时，一部分大小是子树的大小，另一部分是 nnn 减去这个子树的大小。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define i64 long long using namespace std; struct edge &#123; int v, d; edge(int v = 0, int d = 0) : v(v), d(d) &#123;&#125; &#125;; int n; i64 ans; int s[1000005]; vector &lt;edge> G[1000005]; void dfs(int x, int fa) &#123; s[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].v, w = G[x][i].d; if (y == fa) continue; dfs(y, x); ans += (i64)w * abs(s[y] - (n - s[y])); s[x] += s[y]; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(edge(v, d)); G[v].push_back(edge(u, d)); &#125; dfs(1, 0); printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P1395] 会议 Portal. 树中所有点到某个点的距离和中，到重心的距离和是最小的。我们只需要先求出树的重心，然后用 dfs 计算距离即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, ans = 1e7, pos, s[50005]; vector &lt;int> G[50005]; void dfs(int x, int fa) &#123; s[x] = 1; int max_part = 0; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; dfs(y, x); s[x] += s[y]; max_part = max(max_part, s[y]); &#125; max_part = max(max_part, n - s[x]); if (max_part &lt; ans || (max_part == ans &amp;&amp; x &lt; pos)) &#123; pos = x; ans = max_part; &#125; &#125; int sum = 0, dep[50005]; void dfs2(int x, int fa) &#123; dep[x] = dep[fa] + 1; sum += dep[x]; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; if (y == fa) continue; dfs2(y, x); &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); dep[0] = -1; dfs2(pos, 0); printf(\"%d %d\\n\", pos, sum); return 0; &#125; LCA 的综合应用 包括 LCA、树上差分等内容。有的时候也会与别的算法综合（比如二分），但不涉及高难的算法。 [Luogu P3938] 斐波那契 Portal. 树的规模很大，但是深度很小，我们考虑不建树使用向上标记法。由于 dep 肯定是编号越大的节点越大，因此现在的问题就是有如何求解一个节点的爸爸。 发现节点和父亲的差都是斐波那契数，直接二分即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; typedef long long i64; const i64 MAXL = 1e12; i64 f[105] = &#123;0, 1&#125;; int main(void) &#123; int i; for (i = 2;; ++i) &#123; f[i] = f[i - 1] + f[i - 2]; if (f[i] > MAXL) break; &#125; int n; scanf(\"%d\", &amp;n); while (n--) &#123; i64 a, b; scanf(\"%lld%lld\", &amp;a, &amp;b); while (a != b) &#123; if (a > b) swap(a, b); b -= (*(lower_bound(f, f + i + 1, b) - 1)); &#125; printf(\"%lld\\n\", a); &#125; return 0; &#125; [JLOI2014] 松鼠的新家 Portal. 直接使用树上点差分即可，但是要注意处理重复的情况。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, a[300005], dep[300005]; int f[300005][35], sum[300005]; vector &lt;int> G[300005]; void dfs(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= 30; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (auto y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 30; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = 30; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; void get(int x, int fa) &#123; for (auto y : G[x]) if (y != fa) &#123; get(y, x); sum[x] += sum[y]; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt; n; ++i) &#123; int lca = LCA(a[i], a[i + 1]); sum[a[i]]++; sum[a[i + 1]]++; sum[lca]--; sum[f[lca][0]]--; &#125; get(1, 0); for (int i = 2; i &lt;= n; ++i) --sum[a[i]]; for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", sum[i]); return 0; &#125; [BJOI2018] 求和 Portal. 注意到 kkk 的范围很小，因此可以将不同的 kkk 分开来做，那么这道题就成了树上前缀和的模板题。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; const int MOD = 998244353; int n, m, lg[300005]; int f[300005][25], dep[300005]; i64 w[55][300005]; vector &lt;int> G[300005]; void dfs(int x, int fa) &#123; if (fa == 0) dep[x] = 0; else dep[x] = dep[fa] + 1; f[x][0] = fa; w[1][x] = dep[x]; for (int i = 2; i &lt;= 50; ++i) w[i][x] = w[i - 1][x] * dep[x] % MOD; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (auto y : G[x]) if (y != fa) dfs(y, x); &#125; void df5(int x, int fa) &#123; for (auto y : G[x]) if (y != fa) &#123; for (int i = 1; i &lt;= 50; ++i) w[i][y] = (w[i][y] + w[i][x]) % MOD; df5(y, x); &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; dfs(1, 0); df5(1, 0); scanf(\"%d\", &amp;m); while (m--) &#123; int x, y, k; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;k); int lca = LCA(x, y); printf(\"%lld\\n\", ((w[k][x] + w[k][y] - w[k][lca] - w[k][f[lca][0]]) % MOD + MOD) % MOD); &#125; return 0; &#125; [CF519E] A and B and Lecture Rooms Portal. 如果两个点相同，那么所有都可以。如果这两个点之间的简单路径的中点不存在，那么没有可以的。 否则呢？假象两个点如果在同一深度上，那么只有其 LCA 的，包含着两个点的两棵子树上的点是不可以的。不在同一深度上，找到它们的中点，然后中点的子树，除了包含较深节点的那棵子树外，都是可以的。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, lg[100005]; int f[17][100005], dep[100005], siz[100005]; vector&lt;int> G[100005]; void dfs(int x, int fa) &#123; dep[x] = dep[f[0][x] = fa] + 1; siz[x] = 1; for (int i = 1; i &lt;= lg[n]; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x), siz[x] += siz[y]; &#125; int lca(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; void calc(int x, int y) &#123; if (x == y) return printf(\"%d\\n\", siz[1]), void(); int l = lca(x, y); if ((dep[x] + dep[y] - 2 * dep[l]) % 2) return puts(\"0\"), void(); if (dep[x] == dep[y]) &#123; for (int i = lg[n]; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return printf(\"%d\\n\", n - siz[x] - siz[y]), void(); &#125; int up = (dep[x] + dep[y] - 2 * dep[l]) / 2; if (dep[x] &lt; dep[y]) swap(x, y); int x0 = x; for (int i = lg[n]; i >= 0; --i) &#123; if (up >> i &amp; 1) x = f[i][x]; if (up - 1 >> i &amp; 1) x0 = f[i][x0]; &#125; printf(\"%d\\n\", siz[x] - siz[x0]); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (scanf(\"%d\", &amp;m); m--; ) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); calc(a, b); &#125; return 0; &#125; [NOIP2015 提高组] 运输计划 Portal. 像这种要求最大值最小的问题显然想到二分答案，然后使用树上边差分进行 check 即可，就找一个虫洞在所有不满足条件的运输计划上，取最大的一个来判断是否可行。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; struct edge &#123; int v, d; edge(int v = 0, int d = 0) : v(v), d(d) &#123;&#125; &#125;; int n, m, lg[300005]; int dep[300005], f[300005][20], dis[300005]; int s[300005], t[300005], lca[300005], dist[300005], C[300005]; int maxlen = 0, sum = 0, val[300005], ans; vector &lt;edge> G[300005]; void dfs(int x, int fa) &#123; dep[x] = dep[fa] + 1, f[x][0] = fa; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].v, w = G[x][i].d; if (y == fa) continue; dis[y] = dis[x] + w, val[y] = w; dfs(y, x); &#125; &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; void get(int x, int fa) &#123; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].v; if (y == fa) continue; get(y, x); C[x] += C[y]; &#125; &#125; bool P(int x) &#123; // 所有运输计划都不超过 x int cnt = 0, maxdis = 0; memset(C, 0, sizeof(C)); for (int i = 1; i &lt;= m; ++i) if (dist[i] > x) &#123; C[s[i]]++, C[t[i]]++, C[lca[i]] -= 2; ++cnt; &#125; if (cnt == 0) return true; get(1, 0); for (int i = 1; i &lt;= n; ++i) if (C[i] == cnt) maxdis = max(maxdis, val[i]); if (maxlen - maxdis &lt;= x) return true; return false; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1, u, v, d; i &lt; n; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(edge(v, d)), G[v].push_back(edge(u, d)); &#125; for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; dfs(1, 0); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", s + i, t + i); lca[i] = LCA(s[i], t[i]); dist[i] = dis[s[i]] + dis[t[i]] - 2 * dis[lca[i]]; sum += dist[i]; maxlen = max(maxlen, dist[i]); &#125; int L = -1, R = 300000005; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) R = mid; else L = mid; &#125; printf(\"%d\\n\", R); return 0; &#125; [NOIP2013 提高组] 货车运输 Portal. 直觉告诉我们，走的路应该在最大生成树上。那我们先求出生成树，然后预处理 LCA，要记 w[x][i] 代表 xxx 向上蹦 2i2^i2i 次所遇到的最小边权，然后直接做就行了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> using namespace std; const int INF = 1e9; struct edge &#123; int u, v, d; edge(int u = 0, int v = 0, int d = 0) : u(u), v(v), d(d) &#123;&#125; bool operator &lt; (const edge &amp;a) const &#123; return d > a.d; &#125; &#125;a[50005]; int n, m, q; int bin[10005]; int find(int x) &#123; if (bin[x] == x) return x; return bin[x] = find(bin[x]); &#125; vector &lt;edge> G[10005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(u, v, d)); &#125; void Kruskal(void) &#123; sort(a + 1, a + m + 1); for (int i = 1; i &lt;= n; ++i) bin[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int x = find(a[i].u), y = find(a[i].v); if (x == y) continue; bin[x] = y; addedge(a[i].u, a[i].v, a[i].d); addedge(a[i].v, a[i].u, a[i].d); &#125; &#125; bool v[10005]; int dep[10005], lg[10005]; int f[10005][15], w[10005][15]; void dfs(int x, int fa) &#123; v[x] = true; dep[x] = dep[fa] + 1; f[x][0] = fa; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1], w[x][i] = min(w[x][i - 1], w[f[x][i - 1]][i - 1]); for (int i = 0; i &lt; G[x].size(); ++i) if (G[x][i].v != fa) &#123; w[G[x][i].v][0] = G[x][i].d; dfs(G[x][i].v, x); &#125; &#125; int LCA(int x, int y) &#123; if (find(x) != find(y)) return -1; if (dep[x] &lt; dep[y]) swap(x, y); int ans = INF; for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) ans = min(ans, w[x][i]), x = f[x][i]; if (x == y) return ans; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) ans = min(&#123;ans, w[x][i], w[y][i]&#125;), x = f[x][i], y = f[y][i]; return min(&#123;ans, w[x][0], w[y][0]&#125;); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;a[i].u, &amp;a[i].v, &amp;a[i].d); Kruskal(); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= n; ++i) if (!v[i]) dfs(i, 0); scanf(\"%d\", &amp;q); while (q--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", LCA(x, y)); &#125; return 0; &#125; [NOIP2016 提高组] 天天爱跑步 Portal. 一棵包含 nnn 个点的树，有 mmm 个玩家，第 iii 个玩家的起点为 sis_isi​，终点为 tit_iti​。所有玩家在第 000 秒同时从自己的起点出发，以每秒跑一条边的速度向着终点跑去。每个结点上都放置了一个观察员。在结点 jjj 的观察员会选择在第 wjw_jwj​ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家恰好在第 wjw_jwj​ 秒也正好到达了结点 jjj 。问每个观察员会观察到多少人？ 一个玩家能够被观察员 xxx 观察到，当且仅当： 这个观察员在 [s,LCA(s,t)][s,LCA(s,t)][s,LCA(s,t)] 上，那么需要满足 dep[s]−dep[x]=w[x]dep[s]-dep[x]=w[x]dep[s]−dep[x]=w[x]，相当于 dep[s]=dep[x]+w[x]dep[s]=dep[x]+w[x]dep[s]=dep[x]+w[x]。 这个观察员在 (LCA(s,t),t](LCA(s,t),t](LCA(s,t),t] 上，那么需要满足 dep[s]+dep[x]−2×dep[LCA(s,t)]=w[x]dep[s]+dep[x]-2\\times dep[LCA(s,t)]=w[x]dep[s]+dep[x]−2×dep[LCA(s,t)]=w[x]，相当于 dep[s]−2×dep[LCA(s,t)]=w[x]−dep[x]dep[s]-2\\times dep[LCA(s,t)]=w[x]-dep[x]dep[s]−2×dep[LCA(s,t)]=w[x]−dep[x]。 这个模型就很清晰了，因为右面的信息只和观察员的位置有关。因此对于每一个玩家，我们都使用树上差分的思路。将玩家拆分成两个（一个从 sss 到 lcalcalca，一个从 ttt 到 lcalcalca），然后把差分维护操作，给每一个节点都加上一种“物品”。放置相应节点编号的到 STL vector 中。然后进行 DFS。 建立数组 c1,c2c1,c2c1,c2 来维护树上前缀和（因为有两种，分开维护比较方便）。使用 DFS 来统计树上前缀和，刚才已经把差分的操作放置到了 STL vector 中，我们只需要将这些操作执行，统计前后 ccc 的变化就可以得到当前节点的答案了。 注意编号可能是负的，需要平移。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; const int N = 300005; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m, f[N][20]; int dep[N], lg[N]; int w[N], ans[N], c1[N * 2], c2[N * 2]; vector &lt;int> G[N]; vector &lt;int> a1[N], b1[N], a2[N], b2[N]; void dfs(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= lg[n]; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (auto y : G[x]) if (y != fa) dfs(y, x); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; &#125; void dfs2(int x, int fa) &#123; int val1 = c1[w[x] + dep[x]], val2 = c2[w[x] - dep[x] + n]; for (auto y : G[x]) &#123; if (y == fa) continue; dfs2(y, x); &#125; for (auto i : a1[x]) c1[i]++; for (auto i : b1[x]) c1[i]--; for (auto i : a2[x]) c2[i + n]++; for (auto i : b2[x]) c2[i + n]--; ans[x] = c1[w[x] + dep[x]] - val1 + c2[w[x] - dep[x] + n] - val2; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1, u, v; i &lt; n; ++i) &#123; u = read(), v = read(); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) w[i] = read(); while (m--) &#123; int s = read(), t = read(); int lca = LCA(s, t); a1[s].emplace_back(dep[s]); b1[f[lca][0]].emplace_back(dep[s]); a2[t].emplace_back(dep[s] - 2 * dep[lca]); b2[lca].emplace_back(dep[s] - 2 * dep[lca]); &#125; dfs2(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", ans[i]); putchar('\\n'); return 0; &#125; DFS 序列 看起来重链剖分可以代替 DFS 序列，只是慢了一点。实际上不是。本质上重链剖分也是一种特殊的 DFS 序列，而重链剖分转为链式结构来维护也不能解决所有问题（比如树上倍增就很有用）。DFS 序列自身也有一条美妙的性质：每一个节点恰好出现两次，中间是子树。这里仅举一个例子，足够说明问题。 [CF176E] Archaeology Portal.有一棵 nnn 个点的带权树，每个点都是黑色或白色，最初所有点都是白色的。有 qqq 个询问：把点 xxx 从白色变成黑色。把点 xxx 从黑色变成白色。查询黑点的导出子树 (((用最少的边把所有的黑点连通起来的树))) 的总边权和，实际上就是虚树大小。保证 1≤n,q≤105,1≤x≤n1 \\leq n, q \\leq 10^5, 1 \\leq x \\leq n1≤n,q≤105,1≤x≤n。 维护黑点的集合，并将它们按照 dfn 从小到大排序，设排序后的序列为 fff，那么答案就是： 12(d(f1,f2)+⋯+d(fn−1,fn)+d(fn,f1))\\frac{1}{2}(d(f_1,f_2)+\\cdots+d(f_{n-1},f_n)+d(f_n,f_1)) 21​(d(f1​,f2​)+⋯+d(fn−1​,fn​)+d(fn​,f1​)) DFS 序列的性质就可以证明：它相当于是遍历了这些点两遍。知道了这一点之后就可以直接维护，插入和删除的时候计算对答案的贡献即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #include &lt;set> #define pii pair&lt;int, int> using namespace std; typedef long long i64; int n, q; set&lt;int> S; int dfn[100005], son[100005], top[100005], num = 0; int f[100005], siz[100005], dep[100005], idx[100005]; i64 dis[100005], ans = 0; vector&lt;pii> G[100005]; void dfs1(int x, int fa) &#123; siz[x] = 1; f[x] = fa; dep[x] = dep[fa] + 1; int max_part = -1; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first, w = G[x][i].second; if (y != fa) &#123; dis[y] = dis[x] + w; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > max_part) &#123; son[x] = y; max_part = siz[y]; &#125; &#125; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; idx[num] = x; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i].first; if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; &#125; int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; i64 F(int x, int y) &#123; return dis[x] + dis[y] - 2 * dis[LCA(x, y)]; &#125; i64 query(set&lt;int>::iterator it) &#123; auto pre = it, nxt = it; pre = (it == S.begin() ? S.end() : it); --pre; ++nxt; if (nxt == S.end()) nxt = S.begin(); int l = idx[*pre], r = idx[*nxt], x = idx[*it]; return F(l, x) + F(x, r) - F(l, r); &#125; int main(void) &#123; memset(son, -1, sizeof(son)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(&#123;v, d&#125;); G[v].push_back(&#123;u, d&#125;); &#125; dfs1(1, 0); dfs2(1, 1); scanf(\"%d\", &amp;q); while (q--) &#123; char op = getchar(); int x; while (op != '+' &amp;&amp; op != '-' &amp;&amp; op != '?') op = getchar(); if (op == '+') &#123; scanf(\"%d\", &amp;x); if (S.find(dfn[x]) != S.end()) continue; auto it = S.insert(dfn[x]).first; if (S.size() > 2) ans += query(it); else if (S.size() == 2) &#123; ++it; auto ot = (it == S.end() ? S.begin() : it); ans = F(idx[*ot], x) * 2; &#125; &#125; else if (op == '-') &#123; scanf(\"%d\", &amp;x); auto it = S.find(dfn[x]); if (it == S.end()) continue; if (S.size() == 2) ans = 0; else if (S.size() > 2) ans -= query(it); S.erase(it); &#125; else printf(\"%lld\\n\", ans / 2); &#125; return 0; &#125; [CF1149C] Tree Generator™ Portal. 考虑括号序的任意一个子序列代表了什么？树上路径的移动过程！由于直径必能表示成一个移动过程，因此设 f(l,r)f(l,r)f(l,r) 代表括号序 [l,r][l,r][l,r] 中删掉匹配括号之后的长度，最大的 f(l,r)f(l,r)f(l,r) 就是答案。 然鹅这东西看起来不是很好维护，但不是不能推出一点东西：设 ( = 1, ) = -1。剩余的括号一定形如 )))(((，设删完之后设 xxx 个有括号，yyy 个左括号，则 f(l,r)=x+y=max⁡{s(k+1,r)−s(l,k)}f(l,r)=x+y=\\max\\{s(k+1,r)-s(l,k)\\}f(l,r)=x+y=max{s(k+1,r)−s(l,k)}。 这个东西就可以用小白逛公园线段树来维护了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, a[200005]; char s[200005]; struct Node &#123; int s, lmx, rmn, lrans, lans, rans, ans; friend Node operator+ (const Node &amp;a, const Node &amp;b) &#123; Node c; c.s = a.s + b.s; c.lmx = max(a.lmx, a.s + b.lmx); c.rmn = min(b.rmn, a.rmn + b.s); c.lans = max(&#123;a.lans, a.lrans + b.lmx, b.lans - a.s&#125;); c.rans = max(&#123;b.rans, b.lrans - a.rmn, a.rans + b.s&#125;); c.lrans = max(a.lrans + b.s, b.lrans - a.s); c.ans = max(&#123;a.ans, b.ans, a.rans + b.lmx, b.lans - a.rmn&#125;); return c; &#125; &#125; T[800005]; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].s = a[l]; T[o].lmx = max(a[l], 0); T[o].rmn = min(a[l], 0); T[o].lans = T[o].rans = T[o].lrans = T[o].ans = 1; return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x, int k) &#123; if (l == r) &#123; T[o].s = k; T[o].lmx = max(k, 0); T[o].rmn = min(k, 0); return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, k); else update(o &lt;&lt; 1 | 1, mid + 1, r, x, k); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;m, s + 1); n = n * 2 - 2; for (int i = 1; i &lt;= n; ++i) a[i] = (s[i] == '(' ? 1 : -1); build(1, 1, n); printf(\"%d\\n\", T[1].ans); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); swap(a[x], a[y]); update(1, 1, n, x, a[x]); update(1, 1, n, y, a[y]); printf(\"%d\\n\", T[1].ans); &#125; return 0; &#125; 其它树上问题 这里是一些树上杂题。 【XR-3】核心城市 Portal. 考虑从叶子节点开始向中间推进。当叶子节点的数量达到 n−kn-kn−k 时就应停止。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> using namespace std; int n, k, dep[100005], deg[100005]; bool vis[100005]; vector&lt;int> G[100005]; queue&lt;int> Q; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); k = n - k; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); deg[u] += 1; G[v].emplace_back(u); deg[v] += 1; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) if (G[i].size() == 1 &amp;&amp; k >= 1) Q.push(i), vis[i] = true, --k, ans = dep[i] = 1, --deg[i]; if (k >= 1) &#123; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) &#123; int y = G[x][i]; deg[y] -= 1; if (!vis[y] &amp;&amp; deg[y] == 1) &#123; dep[y] = dep[x] + 1; ans = max(ans, dep[y]); vis[y] = true; Q.push(y); --k; if (k &lt; 1) &#123; printf(\"%d\\n\", ans); return 0; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; 表达式树 | [CSP-J2020] 表达式 Portal. 先考虑不带修怎么做。扫描 sss，开一个栈，建立表达式树，遇到数就入栈，运算符就弹栈进行运算然后再入栈。最后 dfs 一次表达式树就可以计算出答案。 当修改时，要么答案会变，要么答案不变。记录一个数组 ccc，代表答案是否会不变。如果与运算的时候一个数为零，那么改变另一个数没有意义。或运算同理。这种关系可以再一次进行 dfs，通过或运算向儿子传递。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;stack> using namespace std; int n, q, a[2000005], ck = 0; int son[2000005][2]; bool flag[2000005], c[2000005]; // c 记录当前节点的值改变是否有用 char s[1000010]; bool dfs(int x, bool f) &#123; f ^= flag[x]; a[x] ^= f; if (x &lt;= n) return a[x]; bool p = dfs(son[x][0], f), q = dfs(son[x][1], f); if (a[x] == 2) &#123; if (p == 0) c[son[x][1]] = 1; if (q == 0) c[son[x][0]] = 1; return p &amp; q; &#125; else &#123; if (p == 1) c[son[x][1]] = 1; if (q == 1) c[son[x][0]] = 1; return p | q; &#125; &#125; void dfs2(int x) &#123; if (x &lt;= n) return; c[son[x][0]] |= c[x]; c[son[x][1]] |= c[x]; dfs2(son[x][0]); dfs2(son[x][1]); &#125; int main(void) &#123; fgets(s, 1000002, stdin); scanf(\"%d\", &amp;n); ck = n; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); stack&lt;int> b; for (int i = 0; s[i]; i += 2) &#123; if (s[i] == 'x') &#123; int x = 0; ++i; while (s[i] != ' ') &#123; x = x * 10 + s[i] - '0'; ++i; &#125; --i; b.push(x); &#125; else if (s[i] == '!') flag[b.top()] ^= 1; else &#123; int x = b.top(); b.pop(); int y = b.top(); b.pop(); b.push(++ck); if (s[i] == '&amp;') a[ck] = 2; else a[ck] = 3; son[ck][0] = x; son[ck][1] = y; &#125; &#125; bool ans = dfs(ck, 0); dfs2(ck); scanf(\"%d\", &amp;q); while (q--) &#123; int x; scanf(\"%d\", &amp;x); printf(\"%d\\n\", c[x] ? ans : !ans); &#125; return 0; &#125; [SDOI2011] 消防 Portal. 要选的话，往直径上选比较好，因为即使直径选不满而选到了非直径上的边，那么原来直径上的点也使答案距离更大。 因此随便搞一条直径，然后枚举直径上的一个起点，计算一个最远的终点（距离不超过 sss），选这一段。只考虑直径上的点，满足最远点距离最小的这一段即为答案。因为如果不是答案（直径外点到这段的距离更大），那么这条直径必然是假的。 这里偷懒了，直径上的查找没有使用单调队列。 查看代码 #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> using namespace std; int n, s, X, Y, ison[300005]; // (X, Y) 为直径 int d[300005], fr[300005]; // X -> Y 从哪里来 int ans = 2e9; vector&lt;pii> G[300005]; void dfs(int x, int fa) &#123; fr[x] = fa; for (auto [y, w] : G[x]) if (y != fa) d[y] = d[x] + w, dfs(y, x); &#125; void workA(void) &#123; // 标记直径上的点, d[x] 为 x 到 Y 的距离 memset(d, 0, sizeof d); int u = Y; ison[Y] = 1; while (u != X) &#123; for (auto [v, w] : G[u]) if (v == fr[u]) ison[v] = 1, d[v] = d[u] + w; u = fr[u]; &#125; &#125; int find(int x, int len) &#123; // x 向 X 走 len 最远走到哪里 for (auto [y, w] : G[x]) if (y == fr[x] &amp;&amp; len >= w) return find(y, len - w); return x; &#125; void workB(void) &#123; // 枚举直径上的起点 int u = Y; while (u != X) &#123; ans = min(ans, max(d[u], d[X] - d[find(u, s)])); u = fr[u]; &#125; ans = min(ans, max(d[X], d[X] - d[find(X, s)])); &#125; void query(int x, int fa) &#123; for (auto [y, w] : G[x]) if (!ison[y] &amp;&amp; y != fa) d[y] = d[x] + w, query(y, x); &#125; void workC(void) &#123; memset(d, 0, sizeof d); int u = Y; while (u != X) query(u, 0), u = fr[u]; query(X, 0); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;s); for (int i = 1; i &lt;= n; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].emplace_back(v, w); G[v].emplace_back(u, w); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) if (d[i] > d[X]) X = i; d[X] = 0; dfs(X, 0); for (int i = 1; i &lt;= n; ++i) if (d[i] > d[Y]) Y = i; workA(); workB(); workC(); for (int i = 1; i &lt;= n; ++i) ans = max(ans, d[i]); return !printf(\"%d\\n\", ans); &#125; [CF1707C] DFS Trees Portal. 题中的求解方式是求搜索树，也就是说，以一个节点为根的时候，所有不在 MST 上的边必须都是返祖边。 对于一条边连接的两个点，两子树内的点都 +1，树上差分维护即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, lg[100005]; struct Edge &#123; int u, v; &#125; e[200005]; bool vis[200005]; int bin[100005], f[18][100005], dep[100005], s[100005]; vector&lt;int> G[100005]; int find(int x) &#123; return bin[x] == x ? x : bin[x] = find(bin[x]); &#125; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = lg[n]; i >= 0; --i) if (dep[f[i][x]] >= dep[y]) x = f[i][x]; if (x == y) return x; for (int i = lg[n]; i >= 0; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; void dfs(int x, int fa) &#123; f[0][x] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= lg[n]; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; for (int y : G[x]) if (y != fa) dfs(y, x); &#125; void dfs2(int x, int fa) &#123; s[x] += s[fa]; for (int y : G[x]) if (y != fa) dfs2(y, x); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) lg[i] = lg[i >> 1] + 1; for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d\", &amp;e[i].u, &amp;e[i].v); for (int i = 1; i &lt;= n; ++i) bin[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v; if (find(u) == find(v)) continue; G[u].emplace_back(v); G[v].emplace_back(u); vis[i] = 1; bin[find(u)] = find(v); &#125; dfs(1, 0); for (int i = 1; i &lt;= m; ++i) if (!vis[i]) &#123; int u = e[i].u, v = e[i].v, l = LCA(u, v); if (dep[u] > dep[v]) swap(u, v); if (l == u) &#123; // (u, v) 路径上不行 ++s[1], ++s[v]; int p = v; for (int j = lg[n]; j >= 0; --j) if (dep[f[j][p]] > dep[u]) p = f[j][p]; --s[p]; &#125; else ++s[u], ++s[v]; &#125; dfs2(1, 0); for (int i = 1; i &lt;= n; ++i) putchar(s[i] == m - (n - 1) ? '1' : '0'); return putchar('\\n'), 0; &#125; 重链剖分 看起来树链剖分就是个板子，只是将链上的数据结构放到树上了。实际上不是，因为树自身也有许多性质。 [NOI2021] 轻重边 Portal.有一棵 nnn 个结点的树，树上的每一条边可能是轻边或者重边。接下来你需要对树进行 mmm 次操作，在所有操作开始前，树上所有边都是轻边。操作有以下两种：给定两个点 aaa 和 bbb，首先对于 aaa 到 bbb 路径上的所有点 xxx（包含 aaa 和 bbb），你要将与 xxx 相连的所有边变为轻边。然后再将 aaa 到 bbb 路径上包含的所有边变为重边。给定两个点 aaa 和 bbb，你需要计算当前 aaa 到 bbb 的路径上一共包含多少条重边。 肯定是树剖（LCT 也可，但是笔者不会 LCT），但是如何简单维护呢？ 考虑使用颜色来维护。初始时每一个点的颜色都不同；每一次修改的时候，我们都将 (a,b)(a,b)(a,b) 间染上一个新的颜色，然后重边的判定法则就变成了：连接的两个端点的颜色相同（想一想看是不是这样）。 那么实现一个可以统计颜色相同的相邻对的线段树即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; vector &lt;int> G[100005]; int dep[100005], siz[100005], f[100005]; int dfn[100005], top[100005], son[100005], num = 0; void dfs1(int x, int fa) &#123; dep[x] = dep[fa] + 1; siz[x] = 1; f[x] = fa; int maxx = -1; for (auto y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > maxx) &#123; maxx = siz[y]; son[x] = y; &#125; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (auto y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; // Segment Tree struct Node &#123; int lc, rc, tag; int cnt; Node(int lc = 0, int rc = 0, int cnt = 0, int tag = 0) : lc(lc), rc(rc), tag(tag), cnt(cnt) &#123;&#125; &#125; T[400005]; inline Node hb(const Node &amp;a, const Node &amp;b) &#123; Node c(a.lc, b.rc, a.cnt + b.cnt + (a.rc == b.lc)); return c; &#125; inline void pushdown(int o, int l, int r) &#123; if (!T[o].tag) return; int mid = l + r >> 1; T[o &lt;&lt; 1] = Node(T[o].tag, T[o].tag, mid - l, T[o].tag); T[o &lt;&lt; 1 | 1] = Node(T[o].tag, T[o].tag, r - mid - 1, T[o].tag); T[o].tag = 0; &#125; void update(int o, int l, int r, int x, int y, int k) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; T[o] = Node(k, k, r - l, k); return; &#125; pushdown(o, l, r); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y, k); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y, k); T[o] = hb(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]); &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; pushdown(o, l, r); int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return hb(query(o &lt;&lt; 1, l, mid, x, y), query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)); &#125; int query(int x, int y) &#123; bool flag = 0; Node ans1, ans2, tmp; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y), flag = !flag; tmp = query(1, 1, n, dfn[top[x]], dfn[x]); if (flag) ans2 = Node(tmp.lc, ans2.rc, ans2.cnt + tmp.cnt + (ans2.lc == tmp.rc)); else ans1 = Node(ans1.lc, tmp.lc, ans1.cnt + tmp.cnt + (ans1.rc == tmp.rc)); x = f[top[x]]; &#125; if (dep[x] &lt; dep[y]) swap(x, y), flag = !flag; tmp = query(1, 1, n, dfn[y], dfn[x]); if (flag) ans2 = Node(tmp.lc, ans2.rc, ans2.cnt + tmp.cnt + (ans2.lc == tmp.rc)); else ans1 = Node(ans1.lc, tmp.lc, ans1.cnt + tmp.cnt + (ans1.rc == tmp.rc)); return ans1.cnt + ans2.cnt + (ans1.rc == ans2.lc); &#125; int main(void) &#123; int TT; scanf(\"%d\", &amp;TT); while (TT--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); num = 0; memset(son, -1, sizeof(son)); memset(T, 0, sizeof(T)); for (int i = 1; i &lt;= n; ++i) G[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; for (int i = 1; i &lt;= n; ++i) update(1, 1, n, i, i, -i); dfs1(1, 0); dfs2(1, 1); for (int i = 1; i &lt;= m; ++i) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); update(1, 1, n, dfn[top[x]], dfn[x], i); x = f[top[x]]; &#125; if (dep[x] &lt; dep[y]) swap(x, y); update(1, 1, n, dfn[y], dfn[x], i); &#125; else printf(\"%d\\n\", query(x, y)); &#125; &#125; return 0; &#125; [SCOI2015] 情报传递 Portal.nnn 名情报员形成树形结构，每天会派发以下两种任务中的一个任务：指派 TTT 号情报员搜集情报；将一条情报从 XXX 号情报员经最短路径传递给 YYY 号情报员。情报员最初处于潜伏阶段，此时所有情报员的危险值为 000；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 111 点（开始搜集情报的当天危险值仍为 000，第 222 天为 111）。每条情报都有一个风险控制值 CCC。参与传递这条情报的危险值大于 CCC 的情报员将对该条情报构成威胁。问对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。n≤2×105,Q≤2×105,0&lt;Pi,Ci≤N,1≤Ti,Xi,Yi≤nn\\le 2\\times 10^5,Q\\le 2\\times 10^5,0&lt;P_i,C_i\\le N,1\\le T_i,X_i,Y_i\\le nn≤2×105,Q≤2×105,0&lt;Pi​,Ci​≤N,1≤Ti​,Xi​,Yi​≤n。 考虑这个限制条件是什么意思。假定一个人开始作死的时间为 ttt，一条情报传递任务的时间为 iii，那么需要满足 t+c&gt;it+c&gt;it+c&gt;i，也就是 t≥i−c−1t\\ge i-c-1t≥i−c−1。 那么，离线，按照 i−c−1i-c-1i−c−1 排序，然后依次将冒险者添加进来（单点修改），查询就是链上距离和链上查询。 查看代码 #include &lt;bits/stdc++.h> using namespace std; struct Question &#123; int x, y, c, id; Question(int x = 0, int y = 0, int c = 0, int id = 0) : x(x), y(y), c(c), id(id) &#123;&#125; bool operator &lt; (const Question &amp;a) const &#123; return c &lt; a.c; &#125; &#125; Q[200005]; struct Operation &#123; int x, t; Operation(int x = 0, int t = 0) : x(x), t(t) &#123;&#125; &#125; A[200005]; int tot = 0, tot2 = 0; int n, q, root; bool vis[200005]; int f[200005], dep[200005], siz[200005], dis[200005]; int son[200005], top[200005], dfn[200005], num = 0; vector&lt;int> G[200005]; int ans[200005]; void dfs1(int x) &#123; dep[x] = dep[f[x]] + 1; siz[x] = 1; int max_part = -1; for (int y : G[x]) &#123; dfs1(y); siz[x] += siz[y]; if (siz[y] > max_part) &#123; max_part = siz[y]; son[x] = y; &#125; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (int y : G[x]) if (y != son[x]) dfs2(y, y); &#125; int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = f[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y; &#125; int T[800005]; void update(int o, int l, int r, int x) &#123; if (l == r) return T[o] += 1, void(); int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = 0; if (x &lt;= mid) res += query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) res += query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125; int main(void) &#123; memset(son, -1, sizeof(son)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i); if (f[i] == 0) root = i; else G[f[i]].emplace_back(i); &#125; dfs1(root); dfs2(root, root); scanf(\"%d\", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; int op, x, y, c; scanf(\"%d%d\", &amp;op, &amp;x); if (op == 1) &#123; scanf(\"%d%d\", &amp;y, &amp;c); ++tot; Q[tot] = Question(x, y, i - c - 1, tot); &#125; else A[++tot2] = Operation(x, i); &#125; sort(Q + 1, Q + tot + 1); for (int i = 1, p = 1; i &lt;= tot; ++i) &#123; while (p &lt;= tot2 &amp;&amp; A[p].t &lt;= Q[i].c) &#123; if (!vis[A[p].x]) update(1, 1, n, dfn[A[p].x]); vis[A[p].x] = true; ++p; &#125; int x = Q[i].x, y = Q[i].y, res = 0; dis[Q[i].id] = dep[x] + dep[y] - 2 * dep[LCA(x, y)] + 1; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); res += query(1, 1, n, dfn[top[x]], dfn[x]); x = f[top[x]]; &#125; if (dep[x] &lt; dep[y]) swap(x, y); res += query(1, 1, n, dfn[y], dfn[x]); ans[Q[i].id] = res; &#125; for (int i = 1; i &lt;= tot; ++i) printf(\"%d %d\\n\", dis[i], ans[i]); return 0; &#125; [BJOI2014] 大融合 Portal.给定一个无向图，动态加边，查询一条边的负载（经过这条边的简单路径的数量），保证任意时刻图都是一片森林。 解决动态图的常规手段依然是动态树，但是此题没有删边操作，也没有强制在线，所以可以考虑使用树剖来求解。 将询问全部读入，然后建立出最终的森林，并对每一棵树都进行树链剖分。建立一个树状数组维护树上子树的大小的前缀和，利用差分的方式进行修改（因为子树大小只需要单点查询，写线段树有点小题大做了）。初始时要将所有所有点的子树大小都初始化为 111，因为它们都是孤立的。同时维护一个并查集，用于查询一个节点所在的集合。 扫描每一个操作： 连边。设要将 yyy 连接到 xxx，xxx 是 yyy 的祖先，那么并查集进行合并操作，现在在并查集中，find(y) 的结果一定是 find(x) 的结果。现在需要维护子树大小。yyy 所对应的子树大小不变，xxx 以及 xxx 的父亲所对应的子树大小需要加上 siz[y]siz[y]siz[y]。但是由于树还没有建完，所以从 find(x) 的父亲开始，需要减去 siz[y]siz[y]siz[y]。 查询。当前 yyy 的子树大小是一部分，整个集合中剩下的是一部分，两者的乘积就是答案。 查看代码 #include &lt;bits/stdc++.h> #define lowbit(x) (x &amp; -x) using namespace std; struct Question &#123; char op; int x, y; &#125; a[100005]; int n, q; vector&lt;int> G[100005]; int dep[100005], siz[100005], f[100005]; int dfn[100005], top[100005], son[100005], num = 0; struct UnionFind_Set &#123; int f[100005]; void init(void) &#123; for (int i = 1; i &lt;= n; ++i) f[i] = i; &#125; int find(int x) &#123; if (f[x] == x) return x; return f[x] = find(f[x]); &#125; &#125; S; void dfs1(int x, int fa) &#123; dep[x] = dep[fa] + 1; siz[x] = 1; f[x] = fa; int max_part = -1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > max_part) &#123; son[x] = y; max_part = siz[y]; &#125; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; int C[100005]; void add(int x, int k) &#123; if (x == 0) return; for (; x &lt;= n; x += lowbit(x)) C[x] += k; &#125; int query(int x) &#123; int res = 0; for (; x >= 1; x -= lowbit(x)) res += C[x]; return res; &#125; void update(int x, int k) &#123; while (x >= 1) &#123; // 修改：top[x] -> x add(dfn[top[x]], k); add(dfn[x] + 1, -k); // 因为是差分，减的地方要加上 1 x = f[top[x]]; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; a[i].op = getchar(); while (a[i].op != 'A' &amp;&amp; a[i].op != 'Q') a[i].op = getchar(); scanf(\"%d %d\", &amp;a[i].x, &amp;a[i].y); if (a[i].op == 'A') &#123; G[a[i].x].emplace_back(a[i].y); G[a[i].y].emplace_back(a[i].x); &#125; &#125; memset(son, -1, sizeof(son)); for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) &#123; dfs1(i, 0); dfs2(i, i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; update(i, 1); update(f[i], -1); &#125; S.init(); for (int i = 1; i &lt;= q; ++i) &#123; int op = a[i].op, x = a[i].x, y = a[i].y; if (dep[x] > dep[y]) swap(x, y); // x 是 y 的祖先 uint sy = query(dfn[y]); if (op == 'A') &#123; S.f[y] = S.find(x); update(x, sy); update(f[S.f[x]], -sy); &#125; else &#123; uint s = query(dfn[S.find(x)]); printf(\"%u\\n\", sy * (s - sy)); &#125; &#125; return 0; &#125; [LNOI2014] LCA Portal.给出一个 nnn 个节点的有根树（编号为 000 到 n−1n-1n−1，根节点为 000）。有 mmm 次询问，每次询问给出 l r zl\\ r\\ zl r z，求 ∑i=lrdep[LCA(i,z)]\\sum_{i=l}^r dep[LCA(i,z)]∑i=lr​dep[LCA(i,z)]。1≤n,m≤5×1041\\le n,m\\le 5\\times 10^41≤n,m≤5×104。 对于一个询问来说，所有的 LCA 都在 zzz 到根节点的路径上，深度代表的含义是当前点到根节点的点数。把 xxx 到根的路径上的点全部 +1+1+1，求 yyy 到根的路径的权值，就是 LCA(x,y)LCA(x,y)LCA(x,y) 的深度。于是我们采用差分的方式求解询问，将询问离线，依次将点加入系统进行维护。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 201314; int n, m; int f[50005], dep[50005], siz[50005]; int dfn[50005], son[50005], top[50005], num = 0; vector&lt;int> G[50005]; void dfs1(int x) &#123; dep[x] = dep[f[x]] + 1; siz[x] = 1; int max_part = -1; for (int y : G[x]) &#123; dfs1(y); siz[x] += siz[y]; if (siz[y] > max_part) max_part = siz[y], son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; dfn[x] = ++num; top[x] = topf; if (son[x] == -1) return; dfs2(son[x], topf); for (int y : G[x]) if (y != son[x]) dfs2(y, y); &#125; int T[200005], tag[200005]; inline void pushdown(int o, int l, int r) &#123; if (!tag[o]) return; int mid = l + r >> 1; tag[o &lt;&lt; 1] += tag[o], tag[o &lt;&lt; 1 | 1] += tag[o]; T[o &lt;&lt; 1] += tag[o] * (mid - l + 1), T[o &lt;&lt; 1 | 1] += tag[o] * (r - mid); tag[o] = 0; &#125; void update(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return tag[o] += 1, T[o] += r - l + 1, void(); int mid = l + r >> 1; pushdown(o, l, r); if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; y) update(o &lt;&lt; 1 | 1, mid + 1, r, x, y); T[o] = (T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]) % MOD; &#125; int query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1, res = 0; pushdown(o, l, r); if (x &lt;= mid) res = (res + query(o &lt;&lt; 1, l, mid, x, y)) % MOD; if (mid &lt; y) res = (res + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y)) % MOD; return res; &#125; void update(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); update(1, 1, n, dfn[top[x]], dfn[x]); x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); update(1, 1, n, dfn[x], dfn[y]); &#125; int query(int x, int y) &#123; int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ans = (ans + query(1, 1, n, dfn[top[x]], dfn[x])) % MOD; x = f[top[x]]; &#125; if (dep[x] > dep[y]) swap(x, y); ans = (ans + query(1, 1, n, dfn[x], dfn[y])) % MOD; return ans; &#125; struct Question &#123; int id, r, z, flag; Question(int id = 0, int r = 0, int z = 0, int flag = 0) : id(id), r(r), z(z), flag(flag) &#123;&#125; bool operator &lt; (const Question &amp;a) const &#123; return r &lt; a.r; &#125; &#125; Q[100005]; int ans[50005]; int main(void) &#123; memset(son, 0xff, sizeof(son)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 2; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i); ++f[i]; G[f[i]].emplace_back(i); &#125; dfs1(1); dfs2(1, 1); for (int i = 1; i &lt;= m; ++i) &#123; int l, r, z; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;z); ++l, ++r, ++z; Q[(i &lt;&lt; 1) - 1] = Question(i, l - 1, z, -1); Q[(i &lt;&lt; 1)] = Question(i, r, z, 1); &#125; sort(Q + 1, Q + m * 2 + 1); int r = 0; for (int i = 1; i &lt;= m * 2; ++i) &#123; while (r &lt; Q[i].r) update(1, ++r); ans[Q[i].id] += Q[i].flag * query(1, Q[i].z); &#125; for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", (ans[i] + MOD) % MOD); return 0; &#125; [Ynoi2017] 由乃的 OJ Portal. 回想当初的贪心是怎么做的，于是我们用线段树维护 0,10,10,1 经过这些运算之后会变成什么，要维护 646464 个，因此可以压进一个 unsigned long long 进行维护。由于树剖的特性，所以正反都需要维护。合并的时候很好处理，可以讨论一下当前位什么时候是 111。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef unsigned long long u64; const u64 INF = 0 - 1; int n, m, k, op[100005]; u64 val[100005]; int f[100005], siz[100005], dep[100005]; int top[100005], dfn[100005], idx[100005], num, son[100005]; vector&lt;int> G[100005]; void dfs1(int x, int fa) &#123; dep[x] = dep[f[x] = fa] + 1; siz[x] = 1; for (int y : G[x]) if (y != fa) &#123; dfs1(y, x); siz[x] += siz[y]; if (siz[y] > siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int topf) &#123; idx[dfn[x] = ++num] = x; top[x] = topf; if (son[x]) dfs2(son[x], topf); for (int y : G[x]) if (y != f[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; u64 calc(u64 v, int x) &#123; if (op[x] == 1) return v &amp; val[x]; if (op[x] == 2) return v | val[x]; return v ^ val[x]; &#125; struct Node &#123; u64 a0, a1, b0, b1; Node() : a0(0), a1(0), b0(0), b1(0) &#123;&#125; // a: 0/1 从左到右 // b: 0/1 从右到左 &#125; T[400005]; inline Node operator+ (const Node &amp;a, const Node &amp;b) &#123; Node c; c.a0 = ((a.a0 &amp; b.a1) | (~a.a0 &amp; b.a0)); c.a1 = ((a.a1 &amp; b.a1) | (~a.a1 &amp; b.a0)); c.b0 = ((b.b0 &amp; a.b1) | (~b.b0 &amp; a.b0)); c.b1 = ((b.b1 &amp; a.b1) | (~b.b1 &amp; a.b0)); return c; &#125; void build(int o, int l, int r) &#123; if (l == r) &#123; T[o].a0 = T[o].b0 = calc(0, idx[l]); T[o].a1 = T[o].b1 = calc(INF, idx[l]); return; &#125; int mid = l + r >> 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; void update(int o, int l, int r, int x) &#123; if (l == r) &#123; T[o].a0 = T[o].b0 = calc(0, idx[l]); T[o].a1 = T[o].b1 = calc(INF, idx[l]); return; &#125; int mid = l + r >> 1; if (x &lt;= mid) update(o &lt;&lt; 1, l, mid, x); else update(o &lt;&lt; 1 | 1, mid + 1, r, x); T[o] = T[o &lt;&lt; 1] + T[o &lt;&lt; 1 | 1]; &#125; Node query(int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return T[o]; int mid = l + r >> 1; if (y &lt;= mid) return query(o &lt;&lt; 1, l, mid, x, y); if (mid &lt; x) return query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); return query(o &lt;&lt; 1, l, mid, x, y) + query(o &lt;&lt; 1 | 1, mid + 1, r, x, y); &#125; Node ans1[100005], ans2[100005]; int tot1, tot2; Node query(int x, int y) &#123; tot1 = tot2 = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] >= dep[top[y]]) &#123; ans1[++tot1] = query(1, 1, n, dfn[top[x]], dfn[x]); x = f[top[x]]; &#125; else &#123; ans2[++tot2] = query(1, 1, n, dfn[top[y]], dfn[y]); y = f[top[y]]; &#125; &#125; if (dep[x] > dep[y]) ans1[++tot1] = query(1, 1, n, dfn[y], dfn[x]); else ans2[++tot2] = query(1, 1, n, dfn[x], dfn[y]); for (int i = 1; i &lt;= tot1; ++i) swap(ans1[i].a0, ans1[i].b0), swap(ans1[i].a1, ans1[i].b1); Node ans; if (tot1) &#123; ans = ans1[1]; for (int i = 2; i &lt;= tot1; ++i) ans = ans + ans1[i]; if (tot2) ans = ans + ans2[tot2]; &#125; else ans = ans2[tot2]; for (int i = tot2 - 1; i >= 1; --i) ans = ans + ans2[i]; return ans; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d%llu\", op + i, val + i); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(1, 0); dfs2(1, 1); build(1, 1, n); while (m--) &#123; int opt, x, y; u64 z; scanf(\"%d%d%d%llu\", &amp;opt, &amp;x, &amp;y, &amp;z); if (opt == 1) &#123; u64 ans = 0; Node t = query(x, y); for (int i = 63; i >= 0; --i) &#123; u64 t0 = (t.a0 >> i) &amp; 1ull; u64 t1 = (t.a1 >> i) &amp; 1ull; if ((1ull &lt;&lt; i) > z || t0 >= t1) ans |= (t0 ? (1ull &lt;&lt; i) : 0); else ans |= (t1 ? (1ull &lt;&lt; i) : 0), z -= (1ull &lt;&lt; i); &#125; printf(\"%llu\\n\", ans); &#125; else &#123; op[x] = y; val[x] = z; update(1, 1, n, dfn[x]); &#125; &#125; return 0; &#125; [CF1017G] The Tree Portal.维护一棵树：1 x：如果 xxx 为白色，那么将其染黑，否则对这个节点的儿子进行递归操作；2 x：将 xxx 子树上的所有节点染成白色。3 x：查询 xxx 的颜色。 关键问题是，这个 1 操作是什么鬼？如果节点 yyy 会被 1 x 影响到，那说明 x∼yx\\sim yx∼y 中除了 yyy 的节点都被染黑了。 简单树上乱搞 一些有趣的题。 [Ynoi Easy Round 2021] TEST_68 Portal. 发现很多点的答案应该是一样的。我们将所有点加入 01-Trie，找出一个异或值最大的点对 (p,q)(p,q)(p,q)，只有 (1,p),(1,q)(1,p),(1,q)(1,p),(1,q) 这两条链上的答案可能与最大答案不同。考虑由 111 开始遍历链（因为 111 的限制是最严的，而两条链分别遍历一次），不断解放树上的节点，将它们加入 Trie，找出异或的最大值。 时间复杂度 O(nlog⁡V)O(n\\log V)O(nlogV)。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; const int N = 500005; i64 a[500005]; int val[N * 60], ch[N * 60][2], tot; void insert(int id) &#123; int x = 0; for (int i = 59; i >= 0; --i) &#123; int c = a[id] >> i &amp; 1; if (!ch[x][c]) ch[x][c] = ++tot; x = ch[x][c]; &#125; val[x] = id; &#125; int query(int id) &#123; // 返回异或值最大的节点编号 int x = 0; for (int i = 59; i >= 0; --i) &#123; int c = a[id] >> i &amp; 1; if (!ch[x][c ^ 1]) x = ch[x][c]; else x = ch[x][c ^ 1]; &#125; return val[x]; &#125; int n, p, q; int f[500005], dep[500005], son[2]; bool v[500005]; i64 Ans[500005], ans, s[500005]; vector&lt;int> G[500005]; int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); v[x] = v[y] = 1; while (dep[x] > dep[y]) v[x = f[x]] = 1; if (x == y) return x; while (x != y) v[x = f[x]] = 1, v[y = f[y]] = 1; return x; &#125; void dfs2(int x) &#123; insert(x); s[x] = max(s[x], a[x] ^ a[query(x)]); for (int y : G[x]) dfs2(y), s[x] = max(s[x], s[y]); &#125; void dfs1(int x, int type) &#123; Ans[x] = max(Ans[x], s[f[x]]); s[x] = s[f[x]]; insert(x); s[x] = max(s[x], a[x] ^ a[query(x)]); for (int y : G[x]) if (!v[y] || y == son[type]) dfs2(y), s[x] = max(s[x], s[y]); for (int y : G[x]) if (v[y] &amp;&amp; y != son[type]) dfs1(y, type); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); dep[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; scanf(\"%d\", f + i), G[f[i]].emplace_back(i); dep[i] = dep[f[i]] + 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", a + i); insert(i); int x = query(i); if ((a[i] ^ a[x]) > ans) ans = a[p = i] ^ a[q = x]; &#125; int lca = LCA(p, q), tmp = lca; for (int x : G[lca]) if (v[x]) son[1] = son[0], son[0] = x; while (tmp) v[tmp = f[tmp]] = 1; memset(val, 0, sizeof val); memset(ch, 0, sizeof ch); tot = 0; dfs1(1, 0); memset(s, 0, sizeof s); memset(val, 0, sizeof val); memset(ch, 0, sizeof ch); tot = 0; dfs1(1, 1); for (int i = 1; i &lt;= n; ++i) printf(\"%lld\\n\", v[i] ? Ans[i] : ans); return 0; &#125; [CF19E] Fairy Portal. 本来就是二分图的可以随便删。对于非二分图，只能删掉被所有奇环覆盖的边，而且不能被偶环覆盖。找一棵搜索树，然后检查所有返祖边即可（因为搜索树不存在横叉边）。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, cnt, sp, s[10005]; vector&lt;pair&lt;int, int> > G[10005]; vector&lt;int> ans; bool vis[10005], dis[10005], pas[10005]; void dfs(int x) &#123; vis[x] = 1; for (auto [y, i] : G[x]) if (!vis[y]) &#123; dis[y] = dis[x] ^ 1; pas[i] = 1; dfs(y); &#125; else if (!pas[i]) &#123; pas[i] = 1; if (dis[y] == dis[x]) &#123; ++cnt; sp = i; ++s[x], --s[y]; &#125; else --s[x], ++s[y]; &#125; &#125; void dfs2(int x) &#123; vis[x] = 1; for (auto [y, i] : G[x]) if (!vis[y]) &#123; dfs2(y); if (s[y] == cnt) ans.emplace_back(i); s[x] += s[y]; &#125; &#125; int main(void) &#123; ios::sync_with_stdio(0); cin >> n >> m; for (int i = 1, u, v; i &lt;= m; ++i) &#123; cin >> u >> v; G[u].emplace_back(v, i); G[v].emplace_back(u, i); &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i); if (cnt == 0) &#123; cout &lt;&lt; m &lt;&lt; \"\\n\"; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; i &lt;&lt; \" \"; return cout &lt;&lt; \"\\n\", 0; &#125; if (cnt == 1) ans.emplace_back(sp); for (int i = 1; i &lt;= n; ++i) vis[i] = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs2(i); sort(ans.begin(), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; \"\\n\"; for (int x : ans) cout &lt;&lt; x &lt;&lt; \" \"; return cout &lt;&lt; \"\\n\", 0; &#125; 【XR-4】 复读 Portal. 枚举一个轮回能够到达的点，将其所有需要构造的子树合并。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m, ans = 1e9, pos, dx; struct Node &#123; int ls, rs; &#125; T[2005], T2[2005]; int get(void) &#123; int c = getchar() - '0', x = ++n; if (c &amp; 1) T[x].ls = get(); if (c &amp; 2) T[x].rs = get(); return x; &#125; void dfs2(int x, int y) &#123; if (x == pos || y == dx) dx = y, y = 1; if (T[x].ls) &#123; if (!T2[y].ls) T2[y].ls = ++m; dfs2(T[x].ls, T2[y].ls); &#125; if (T[x].rs) &#123; if (!T2[y].rs) T2[y].rs = ++m; dfs2(T[x].rs, T2[y].rs); &#125; &#125; void dfs(int x, int dep) &#123; m = 1; memset(T2, 0, sizeof T2); pos = x; dx = 0; dfs2(1, 1); ans = min(ans, (m - 1) * 2 - dep + 1); if (T[x].ls) dfs(T[x].ls, dep + 1); if (T[x].rs) dfs(T[x].rs, dep + 1); &#125; int main(void) &#123; get(); dfs(1, 1); return !printf(\"%d\\n\", ans); &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"算法竞赛/学习笔记/数据结构","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91/"},{"name":"LCA","slug":"LCA","permalink":"https://james1badcreeper.github.io/tags/LCA/"},{"name":"树的直径","slug":"树的直径","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"树的重心","slug":"树的重心","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"树上差分","slug":"树上差分","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"}]},{"title":"最短路问题","slug":"notes/图论/Shortest-path","date":"2022-08-01T00:00:00.000Z","updated":"2022-08-01T00:00:00.000Z","comments":true,"path":"6bbbc5e9/","link":"","permalink":"https://james1badcreeper.github.io/6bbbc5e9/","excerpt":"最短路是图论中的常考问题，本文引导你学习最短路的 Floyd，BellmanFord 及 Djikstra 算法，以及它们的各种应用。还有一种基于最短路的系统：差分约束系统。","text":"最短路是图论中的常考问题，本文引导你学习最短路的 Floyd，BellmanFord 及 Djikstra 算法，以及它们的各种应用。还有一种基于最短路的系统：差分约束系统。 概念 松弛。最短路的核心思想是松弛，即找一个点 C，如果从 A 到 B 的距离比从 A 到 C 再到 B 的距离长，那么更新最短路，这便是松弛操作。 环。要认识到一个事实。如果最短路存在，一定是个不含环的最短路。因为如果它是正环（边权和为正数），走它是自寻死路；如果它是零环，走它没有意义；如果它是负环，则不存在最短路了（一直转圈刷分，或者说存在长度为 -INF 的最短路，当然，前提是这个负环能走到）。 对于无权图（或者 01 权值，BFS 时双端队列维护即可）的最短路，我们可以直接使用 BFS 来求解。 多源最短路 指求任意两点间的最短路的问题，一般使用简单好写的 Floyd 算法（全称为 Floyd-Warshall）。 Floyd 非常简单，用邻接矩阵存图，初始化边为距离，其它距离为无穷大，跑下面的代码（注意循环顺序！）： for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); 嗯，非常简单，但怎么证明呢？ 好，给点提示，这实际上是个 DP，而且数组的第一维被滚掉了。 实际上，设 D[k,i,j]D[k,i,j]D[k,i,j] 为经过若干编号不超过 kkk 的节点的 iii 到 jjj 的最短路长度。那么有两种选择：经过编号不超过 k−1k-1k−1 的点，或者从 iii 到 kkk 再到 jjj，也就是 D[k,i,j]=min⁡{D[k−1,i,j],D[k−1,i,k]+D[k−1,k,j]}D[k,i,j]=\\min\\{D[k-1,i,j], D[k-1,i,k]+D[k-1,k,j]\\}D[k,i,j]=min{D[k−1,i,j],D[k−1,i,k]+D[k−1,k,j]} 改变松弛操作，就可以求不同的路径。值得一提的是，如果求图的连通性，那么这一问题被称为传递闭包。代码是 d[i][j] |= (d[i][k] &amp; d[k][j])。 Floyd 的时间复杂度是 Θ(n3)\\Theta(n^3)Θ(n3)。 有的时候你会在网上看到一种判断 k, i, j 是否不相等的代码，但是没有必要。因为即使其中有变量相等，它的结果也会是正确的。 说个有趣的事情，即使循环顺序错误，只要连续跑三遍 Floyd，它的结果也是正确的。 Johnson 一种特殊的多源最短路算法，可以做到 O(nmlog⁡m)O(nm \\log m)O(nmlogm) 的复杂度来求解（Dijkstra 的复杂度是 O(mlog⁡m)O(m\\log m)O(mlogm)，但实用性不高，感兴趣的读者可以自己了解学习。 Floyd 的题目 我们来几道简单题。 [Luogu 1119] 灾后重建 Portal. 直接使用 Floyd 算法。因为我们知道 Floyd 是个以“到达点的编号”为阶段的 DP 算法，这跟题目的要求正好符合。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x; &#125; int n, m; int d[205][205]; int t[205]; int main(void) &#123; n = read(), m = read(); memset(d, 0x3f, sizeof(d)); for (int i = 0; i &lt; n; ++i) &#123; t[i] = read(); d[i][i] = 0; &#125; while (m--) &#123; int x = read(), y = read(), v = read(); d[x][y] = v; d[y][x] = v; &#125; int q = read(), k = 0; while (q--) &#123; int x = read(), y = read(), T = read(); for (; t[k] &lt;= T &amp;&amp; k &lt; n; ++k) // 核心 for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); if (t[x] > T || t[y] > T || d[x][y] == 0x3f3f3f3f) puts(\"-1\"); // 可能这个村庄依旧处于报废 else printf(\"%d\\n\", d[x][y]); &#125; return 0; &#125; 时间复杂度 O(n3)O(n^3)O(n3)。 [UVa 10048] Audiophobia Portal 也可以使用 Floyd。我们求的还是最短路，路径中的加法变成了 max 而已。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int c, s, q, kase = 0; int d[105][105]; int main(void) &#123; while (scanf(\"%d%d%d\", &amp;c, &amp;s, &amp;q) == 3 &amp;&amp; c) &#123; if (kase) putchar('\\n'); printf(\"Case #%d\\n\", ++kase); memset(d, 0x7f, sizeof(d)); while (s--) &#123; int x, y, val; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;val); d[x][y] = min(d[x][y], val); d[y][x] = min(d[y][x], val); &#125; for (int i = 1; i &lt;= c; ++i) d[i][i] = 0; for (int k = 1; k &lt;= c; ++k) for (int i = 1; i &lt;= c; ++i) for (int j = 1; j &lt;= c; ++j) d[i][j] = min(d[i][j], max(d[i][k], d[k][j])); while (q--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); if (d[x][y] == 0x7f7f7f7f) puts(\"no path\"); else printf(\"%d\\n\", d[x][y]); &#125; &#125; return 0; &#125; [UVa 247] Calling Circles Portal. 用 Floyd 求出传递闭包即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #include &lt;cstring> #include &lt;vector> using namespace std; int n, m, kase; vector &lt;string> names; bool f[30][30], vis[30]; char a[100], b[100]; int ID(const string &amp;s) &#123; for (int i = 0; i &lt; names.size(); ++i) if (names[i] == s) return i; names.push_back(s); return names.size() - 1; &#125; void dfs(int u) &#123; vis[u] = true; for (int v = 0; v &lt; n; ++v) if (!vis[v] &amp;&amp; f[u][v] &amp;&amp; f[v][u]) &#123; cout &lt;&lt; \", \" &lt;&lt; names[v]; dfs(v); &#125; &#125; int main(void) &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; names.clear(); memset(f, 0, sizeof(f)); for (int i = 0; i &lt; n; ++i) f[i][i] = 1; while (m--) &#123; scanf(\"%s%s\", a, b); f[ID(a)][ID(b)] = 1; &#125; for (int k = 0; k &lt; n; ++k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) f[i][j] |= f[i][k] &amp; f[k][j]; if (kase) putchar('\\n'); printf(\"Calling circles for data set %d:\\n\", ++kase); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; n; ++i) if (!vis[i]) &#123; cout &lt;&lt; names[i]; dfs(i); putchar('\\n'); &#125; &#125; return 0; &#125; 负环 Floyd 可以判断是否有负环。如果从一个点绕了一圈回到了自己，正常情况下 f(i,i)=0f(i,i)=0f(i,i)=0，但如果跑了一个负环，它就会变成负数。 [USACO06DEC] Wormholes G. 使用 Floyd 判断负环即可，需要吸氧（不吸氧需要使用后文介绍的 SPFA）。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m, w; int f[505][505]; int main(void) &#123; int T = read(); while (T--) &#123; memset(f, 0x3f, sizeof(f)); n = read(), m = read(), w = read(); while (m--) &#123; int x = read(), y = read(), v = read(); f[x][y] = min(f[x][y], v); f[y][x] = min(f[y][x], v); &#125; while (w--) &#123; int x = read(), y = read(); f[x][y] = min(f[x][y], -read()); &#125; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) f[i][j] = min(f[i][j], f[i][k] + f[k][j]); bool flag = true; for (int i = 1; i &lt;= n; ++i) if (f[i][i] &lt; 0) &#123; puts(\"YES\"); flag = false; break; &#125; if (flag) puts(\"NO\"); &#125; return 0; &#125; 最小环问题 给定一张图，求图中一个至少包含 333 个点的环，环上的节点不重复，并且环上的边的长度之和最小。该问题称为图的最小环问题。 模板。注意，Floyd 只能解决无向图的最小环问题。 可以发现，最小环的长度就是 min⁡1≤i&lt;j&lt;k{d[i,j]+a[i,k]+a[k,j]}\\min\\limits_{1\\le i&lt;j&lt;k}\\{d[i,j]+a[i,k]+a[k,j]\\}1≤i&lt;j&lt;kmin​{d[i,j]+a[i,k]+a[k,j]}，代表经过节点 kkk，由编号不超过 kkk 的节点构成（i,j,ki,j,ki,j,k）的顺序是为了保证不重复经过节点。 for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt; k; i++) for (int j = i + 1; j &lt; k; j++) ans = min(ans, f[i][j] + a[i][k] + a[k][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) f[i][j] = min(f[i][j], f[i][k] + f[k][j]); &#125; Bellman-Ford 这是一种 Θ(nm)\\Theta(nm)Θ(nm) 的单源最短路算法，即可以计算出从 sss 到任意一点的最短路。 原理 基于之前说的有最短路，一定是不含环的。那么我们撑死只要迭代 n−1n-1n−1 次，每次检查所有的边，便会没有更新的内容（环是无意义的），便可以得到正确的最短路，代码如下： memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; for (int op = 1; op &lt; n; ++op) // 迭代 n-1 次 for (int i = 0; i &lt; edges.size(); ++i) // 检查所有边 if (dis[edges[i].u] + edges[i].val &lt; dis[edges[i].v]) dis[edges[i].v] = dis[edges[i].u] + edges[i].val; SPFA 但是 Bellman-Ford 也太慢了吧！Θ(nm)\\Theta(nm)Θ(nm) 的复杂度，谁顶得住啊！ 解决方法是使用 SPFA（SPFA 是 Shortest Path Fast Algorithm 的缩写，在中国大陆使用这一称谓。由于这玩意的复杂度是错的，所以在国际上称之为“队列优化的 Bellman-Ford 算法”）。 Bellman-Ford 每次都要将所有点对应的所有边松弛一遍，这当中有很多浪费，因为不是每一条边都要松弛的！ 就是说，如果上一轮这个点的最短路没有发生变化，那么这一轮我们就不用对这一个点进行松弛了。 那么我们开一个队列，如果节点在队列中，表示最短路发生改变，需要重新计算该点。 模板。 为方便，这里也给出封装好的数据结构，之后介绍 Dijkstra 时也会使用相同的数据结构，这里使用 vector，因为它很方便，而且在各大竞赛都普遍使用 O2 后，vector 甚至比链式前向星更快，可以看一下 riteme 的这篇博客，经笔者测试开 O2 基本是相同的效果。至于 vector 会开二倍空间，一般不会被卡。 代码如下： void SPFA(void) &#123; memset(d, 0x3f, sizeof d); d[s] = 0; inq[s] = 1; queue &lt;int> q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (auto [v, w] : G[u]) if (d[v] > d[u] + w) &#123; d[v] = d[u] + w; if (!inq[v]) inq[v] = 1, q.push(v); &#125; &#125; &#125; 干掉 SPFA R.I.P. SPFA 1994~2018 可怜的 SPFA 发明人——段凡丁. 2018 年 7 月 19 日，某位同学在 NOIDay1T1 归程 一题里非常熟练地使用了一个广为人知的算法求最短路。然后呢？100→60100 \\rightarrow 60100→60Ag→Cu\\text{Ag} \\rightarrow \\text{Cu}Ag→Cu最终，他因此没能与理想的大学达成契约。这是 NOI2018 的真实照片，讲题人公开宣称 SPFA 已死 SPFA 的复杂度是 Ω(kn)\\Omega(kn)Ω(kn)。其中 kkk 是一个较小的常数，但是注意！这里的时间复杂度符号不对，它的下界是较快的，一般在随机图中，SPFA 是最快的最短路算法，但如果构造特殊数据，SPFA 会达到 O(nm)O(nm)O(nm) 的上界复杂度，即退化成 Bellman-Ford（而且常数更大）。 实际上 SPFA 在国际上通称队列优化的 Bellman-Ford 算法，因为段凡丁极其不负责任地搞出了一个错误的证明，给出它的复杂度是 Θ(kn)\\Theta(kn)Θ(kn)。 怎么干掉 SPFA 呢？核心思路是：让节点频繁入队。可以看一下 fstqwq 在知乎上的回答。 负环 SPFA 也不是什么用也没有，它可以判负环（相比于 Floyd，它显然更快）。 当然 Bellman-Ford 也可以判断负环，如果 nnn 轮之后还是有更新的内容，就说明有人在刷分，有负环。 SPFA 有三种方法判断负环。 第一种方法是 cnt[v]cnt[v]cnt[v] 表示从 sss 到 vvv 的最短路经过了多少个点，如果 u-&gt;v 松弛了 s-&gt;v，那么就让 cnt[v]cnt[v]cnt[v] 更新为 cnt[u]+1cnt[u]+1cnt[u]+1。 之前提到过，一个正常的最短路是不应该有超过 nnn 个点的，因此当 cnt[v]&gt;ncnt[v]&gt;ncnt[v]&gt;n 的时候说明有内鬼，终止交易。 第二种是这样的：还是说最短路最多经过 nnn 个点，cnt[v]cnt[v]cnt[v] 表示从 vvv 入了多少次队，如果一个点超过了 nnn 次入队，那么就说明还是有内鬼，就是有负环！ 第三种方式是 dfs 版的 SPFA 判环。如果一个点被松弛了，就直接递归进这个点去松弛别人就行了。而如果一个点递归一圈又回到自己了，那显然是有负环的。 一般第二种方法很慢（需要绕着环跑 nnn 次才能找到负环），而第三种方法比第一种快。但是很少有第一种不够快的时候，而且第三种方法很可能会严重降低负环不存在时的最短路计算效率，还有可能有其它副作用，不建议使用。这里给出第一种方法的代码，时间复杂度为 O(nm)O(nm)O(nm)。 可以参考模板。 查看代码 #include &lt;bits/stdc++.h> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x * f; &#125; struct edge &#123; int from, to, dist; edge(int from = 0, int to = 0, int dist = 0) : from(from), to(to), dist(dist) &#123;&#125; &#125;; int n, m; int d[10005], inq[10005]; vector &lt;edge> G[10005]; int cnt[100005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(u, v, d)); &#125; bool SPFA() &#123; memset(d, 0x3f, sizeof(d)); memset(cnt, 0, sizeof(cnt)); memset(inq, 0, sizeof(inq)); d[1] = 0; inq[1] = true; queue &lt;int> q; q.push(1); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; cnt[e.to] = cnt[u] + 1; if (cnt[e.to] > n) return true; if (!inq[e.to]) &#123; inq[e.to] = 1; q.push(e.to); &#125; &#125; &#125; &#125; return false; &#125; int main(void) &#123; int T = read(); while (T--) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) G[i].clear(); while (m--) &#123; int u = read(), v = read(), w = read(); addedge(u, v, w); if (w >= 0) addedge(v, u, w); &#125; puts(SPFA() ? \"YES\" : \"NO\"); &#125; return 0; &#125; 要注意的是，如果图中有负环但是起点 sss 走不到这个负环，那么无法找到。解决方法是外挂一个节点，跟每一个点都连一条边，然后对这个点跑 SPFA。 Dijkstra 既然 SPFA 都会被卡，那我们用什么？答案是：Dijkstra。 原理与实现 Dijkstra 基于贪心的思想。大致流程如下： 初始化 d[s]=0d[s]=0d[s]=0，其余为 INF。 找出一个没有被访问的，d[x]d[x]d[x] 最小的 xxx，然后访问 xxx。 扫描 xxx 所有的出边，进行松弛。 迭代步骤 2~3 n−1n-1n−1 次。 所以说，Dijkstra 的思路就是“我找当前最近的路走，一定能找到最短路”。但这意味着，如果图中存在负权边，那么 Dijkstra 可能会鼠目寸光，忽略了前方还有很小的负权边的可能，所以 Dijkstra 只可用于正权图！ 具体证明请读者自行查找（在 OI-wiki 上有）。 下面是代码： int v[5005], d[5050]; memset(d, 0x3f, sizeof(d)); memset(a, 0x3f, sizeof(a)); read_graph(); memset(v, 0, sizeof(v)); d[1] = 0; for (int op = 1; op &lt; n; ++op) // 迭代 n-1 次 &#123; int x = 0; // 找 x for (int i = 1; i &lt;= n; ++i) if (v[i] == 0 &amp;&amp; (x == 0 || d[i] &lt; d[x])) x = i; v[x] = 1; // 松弛 for (int i = 1; i &lt;= n; ++i) d[i] = min(d[i], d[x] + a[x][i]); &#125; 而且由于 Dijkstra 的贪心思想，使用前必须满足当前的最优决策就是最终的最优决策。 优化 然而还是很慢，上述代码的复杂度高达 Θ(n2)\\Theta(n^2)Θ(n2)，n=105n = 10^5n=105 的时候直接告辞，这也是为什么上述代码采用邻接矩阵的原因。 但是有优化（啊，小心在不同的数据范围下可能是负优化，比如 m=n2m = n^2m=n2）！ 因为”找出一个没有被访问的，d[x]d[x]d[x] 最小的 xxx，然后访问 xxx“这一操作实属费时费力，所以我们可以用数据结构代替，使用优先队列优化时间复杂度为 O((n+m)log⁡n)O((n+m)\\log n)O((n+m)logn)。 由于除了优先队列是 STL 就有的，剩下的数据结构手写巨复杂，超级难写且容易爆炸，而且效率差不了太多，所以我们还是用优先队列吧。 下面是代码，这套代码可以通过 模板： void Dijkstra(void) &#123; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; // 小根堆 memset(d, 0x3f, sizeof(d)); q.emplace(0, d[s] = 0); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (v[u) continue; // 没有被访问过 v[u] = true; for (auto [v, w] : G[u]) if (d[v] > d[u] + w) q.emplace(d[v] = d[u] + w, v); &#125; &#125; 值得注意的是这个入队的方式。正常来讲我们应该修改队列中的 d[e.to]d[e.to]d[e.to]，但是 STL 不支持这种操作。所以我们再入一个队，值小的自然会先出队，所以正确性是没有问题的。当然也可以判断当前到此的距离是否小于最短路，从而省掉一个 v 数组，接下来的次短路也用到了类似的思想。 我究竟用什么算法？ 这个问题已经很显然了，这里列出表格给大家参考（绿色字体意为这类题目少见，初学阶段可不必学习；蓝色意为要求数据随机）： 最短路 n≤300n \\le 300n≤300 n≤103,m≤104n\\le 10^3, m\\le 10^4n≤103,m≤104 n≤105,m≤106n\\le 10^5, m\\le 10^6n≤105,m≤106 多源 Floyd Johnson N/A 无负权单源 Floyd Dijkstra 优先队列 Dijkstra 有负权单源 Floyd Belman-Ford 或 SPFA SPFA 如果这题要求有负权单源最短路，而且没保证数据随机，则有两种可能：一是毒瘤出题人就是没写，二是你真的建错模型了，这题可以转化为无负权单源最短路或者它压根就不是最短路。 注意！如果一张图是稠密图（图的边数接近点数的平方，否则就是稀疏图），那么这时就使用不优化的 Dijkstra，反而比优化的好。 就是这么简单。 最短路的技巧 虽然最短路的算法我们都学习完毕了，但是还远远不够。如果最短路只有以上那些内容，那么它很简单，但事实上并不是。最短路有很多技巧，我们来看几个经典的。 最短路的打印 嗯，最短路还可以打印。 怎么打？每次松弛的时候记录一下不就完事了？ 以 Dijkstra 为例： int p[100005]; void dijkstra(void) &#123; #define pii pair&lt;int, int> priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii> > q; memset(d, 0x3f, sizeof(d)); d[s] = 0; q.push(make_pair(0, s)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (v[u] == 0) &#123; v[u] = 1; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[u] + e.dist &lt; d[e.to]) &#123; d[e.to] = d[u] + e.dist; p[e.to] = u; // 记录从哪个点来 q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; &#125; void print(int s, int t) // 打印 s 到 t 的最短路 &#123; if (s == t) // 是起点 &#123; printf(\"%d \", s); return; &#125; print(s, p[t]); // 打印前一个点 printf(\"%d \", t); //打印当前的点 &#125; 固定终点的最短路 [Luogu 1629] 邮递员送信。 可以看出题目要分别求固定起点（从 111 走）和固定终点（走回 111）的最短路。前者可以直接使用 Dijkstra 算法，但后者怎么办？ 想一想，正常的单源最短路求的是从一个起点到所有点的最短路，如果这是无向图，我们只需要把这个最短路反过来就是所有点到这个起点的最短路（就是路径是反着的）。 也就是说，从 iii 走到 111 的最短路，就是从 111 走到 iii 的最短路径倒着走。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #include &lt;queue> using namespace std; struct edge &#123; int from, to, dist; edge(int from = 0, int to = 0, int dist = 0) : from(from), to(to), dist(dist) &#123;&#125; &#125;; struct solver &#123; vector &lt;edge> G[1005]; int d[1005]; bool v[1005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(u, v, d)); &#125; void Dijkstra(void) &#123; memset(d, 0x3f, sizeof(d)); d[1] = 0; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.push(make_pair(0, 1)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!v[u]) &#123; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; &#125; &#125;A, B; int main(void) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); A.addedge(u, v, d); B.addedge(v, u, d); &#125; A.Dijkstra(); B.Dijkstra(); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += A.d[i] + B.d[i]; printf(\"%d\\n\", ans); return 0; &#125; 分层图最短路 [JLOI2011] 飞行路线。 注意到 kkk 的范围很小，所以可以使用分层图，下面介绍什么是分层图。 将原图复制 kkk 次，原来编号为 iii 的节点复制为编号 i+jni+jni+jn 的节点。然后第 jjj 层和第 j+1j+1j+1 层的对应节点也要连上边，边权值为 000，而且是单向边（最多免费乘坐 kkk 次）。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; int n, m, k, s, t; int d[110005]; bool v[110005]; vector &lt;edge> G[110005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(v, d)); &#125; void Dijkstra(void) &#123; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; memset(d, 0x3f, sizeof(d)); d[s] = 0; q.push(make_pair(0, s)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!v[u]) &#123; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;s, &amp;t); for (int i = 0, u, v, d; i &lt; m; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); addedge(u, v, d); addedge(v, u, d); for (int j = 1; j &lt;= k; ++j) &#123; addedge(u + j * n, v + j * n, d); addedge(v + j * n, u + j * n, d); addedge(u + (j - 1) * n, v + j * n, 0); addedge(v + (j - 1) * n, u + j * n, 0); &#125; &#125; Dijkstra(); int ans = 0x7fffffff; for (int i = 0; i &lt;= k; ++i) ans = min(ans, d[t + i * n]); printf(\"%d\\n\", ans); return 0; &#125; 最短路的性质 最短路有一条重要的性质：最短路中的一部分依然是最短路。采用反证法，如果存在一条路径比那一部分更短，那么可以用这条路径替换那一部分，原先的整条路就不是最短路。 最短路树（SPT） 能形成最短路的路径构成了一棵树，求解的方法是在松弛时记录来的边（跟最短路的打印是一样的），然后把它当作父指针就可以求解出整棵最短路树。 或者也可以在 dfs 查找树的时候直接扫描所有边，虽然会慢一点，但是时间复杂度是没有变的。 [CF1076D] Edge Deletion.给一个 nnn 个点，mmm 条边的无向简单带权连通图, 要求删边至最多剩余 kkk 条边。定义&quot;好点&quot;是指删边后，111 号节点到它的最短路长度仍然等于原图最短路长度的节点。最大化删边后的好点个数。 显然要尽可能地保留最短路树，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; typedef long long i64; typedef pair&lt;i64, int> pii; int n, m, k; struct edge &#123; int v, d, id; &#125;; vector&lt;edge> G[300005]; bool vis[300005]; i64 d[300005]; void Dijkstra(void) &#123; memset(d, 0x3f, sizeof(d)); d[1] = 0; priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii> > q; q.push(&#123;0, 1&#125;); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!vis[u]) &#123; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].v, w = G[u][i].d; if (d[v] > d[u] + w) &#123; d[v] = d[u] + w; q.push(&#123;d[v], v&#125;); &#125; &#125; &#125; &#125; &#125; int ans[300005], tot = 0; void dfs(int x) &#123; if (tot >= k) return; vis[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; int v = G[x][i].v, id = G[x][i].id, w = G[x][i].d; if (!vis[v] &amp;&amp; d[v] == d[x] + w) &#123; ans[++tot] = id; dfs(v); if (tot >= k) return; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G[u].push_back(&#123;v, w, i&#125;); G[v].push_back(&#123;u, w, i&#125;); &#125; printf(\"%d\\n\", k = min(n - 1, k)); Dijkstra(); memset(vis, 0, sizeof(vis)); dfs(1); for (int i = 1; i &lt;= k; ++i) printf(\"%d \", ans[i]); putchar('\\n'); return 0; &#125; 次短路 模板。 直接套用 Dijkstra 算法，但是要记录两个 ddd 数组，分别保存最短路和次短路。 具体一点，如果发现了一条新的 1→i1\\rightarrow i1→i 的最短路，那么存在以下几种可能： 这是最短路，则更新最短路，并将次短路替换为原来的最短路； 等于最短路，没用（因为是严格次短路）； 大于最短路但是小于次短路，则替换次短路； 否则没用。 无论如何，更新之后都要 push，因为接下来都可能需要更新（即使是次短路）。判断是否已经更新过的条件就是当前的距离是否已经比次短路还要大。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; struct edge &#123; int from, to, dist; edge(int from = 0, int to = 0, int dist = 0) : from(from), to(to), dist(dist) &#123;&#125; &#125;; int n, m; int d[2][5005]; vector &lt;edge> edges; vector &lt;int> G[5005]; inline void addedge(int u, int v, int d) &#123; edges.push_back(edge(u, v, d)); G[u].push_back(edges.size() - 1); &#125; void Dijkstra2(void) &#123; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; memset(d, 0x3f, sizeof(d)); d[0][1] = 0; q.push(make_pair(0, 1)); while (!q.empty()) &#123; int dis = q.top().first, u = q.top().second; q.pop(); if (dis > d[1][u]) continue; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (d[0][e.to] > dis + e.dist) &#123; d[1][e.to] = d[0][e.to]; d[0][e.to] = dis + e.dist; // 原来最短路变成次短路 q.push(make_pair(d[0][e.to], e.to)); &#125; else if (d[1][e.to] > dis + e.dist &amp;&amp; d[0][e.to] &lt; dis + e.dist) &#123; d[1][e.to] = dis + e.dist; q.push(make_pair(d[1][e.to], e.to)); // 次短路可能被用于接下来的次短路更新 &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); addedge(u, v, d); addedge(v, u, d); &#125; Dijkstra2(); printf(\"%d\\n\", d[1][n]); return 0; &#125; 当然还有 k 短路，不过非常的麻烦，会在专门的地方进行讨论。 差分约束系统 还记得负环吗？负环能做什么呢？就在这里，差分约束系统。 概述 模板。 这类问题是说，给定一个包含 mmm 个不等式的不等式组，有 nnn 个变量 x1…xnx_1\\dots x_nx1​…xn​，判断是否有解，有解输出一组解。不等式组如下： {xc1−xc1′≤y1xc2−xc2′≤y2⋯xcm−xcm′≤ym\\begin{cases} x_{c_1}-x_{c&#x27;_1}\\leq y_1 \\\\x_{c_2}-x_{c&#x27;_2} \\leq y_2 \\\\ \\cdots\\\\ x_{c_m} - x_{c&#x27;_m}\\leq y_m\\end{cases} ⎩⎨⎧​xc1​​−xc1′​​≤y1​xc2​​−xc2′​​≤y2​⋯xcm​​−xcm′​​≤ym​​ 我们将一个不等式写作 xi−xj≤yx_i-x_j\\le yxi​−xj​≤y，那么可以变形为 xi≤xj+ckx_i \\le x_j+c_kxi​≤xj​+ck​，这与单源最短路径中的不等式非常相似，因此可以连一条从 jjj 到 iii 的长度为 ckc_kck​ 的有向边。我们利用之前所讲的外挂一个虚拟节点 000，作为起点，将它向所有点连一条长度为 000 的有向边，用于方便下面求解整个图的负环。那么 000 到 iii 的距离必定小于 000 到 jjj 再到 iii，满足不等式。 显然这个 ccc 一般是有一个负数值的，否则随便都能整一组解。 如果图中不存在负环，那么可以令 xi=dix_i=d_ixi​=di​ 就是一组解。如果有负环，设负环对应的所有不等式是 xai−xai+1≤ybix_{a_i}-x_{a_{i+1}}\\le y_{b_i}xai​​−xai+1​​≤ybi​​，将所有不等式相加得到 0≤∑ybi0\\le \\sum y_{b_i}0≤∑ybi​​，但是这个是负环，∑ybi&lt;0\\sum y_{b_i} &lt; 0∑ybi​​&lt;0，矛盾，因此差分约束系统无解。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; int n, m; int d[5005], cnt[5005]; bool inq[5005]; vector &lt;edge> G[5005]; inline void addedge(int u, int v, int d) &#123; G[u].push_back(edge(v, d)); &#125; bool SPFA(void) &#123; memset(d, 0x3f, sizeof(d)); d[0] = 0, cnt[0] = 1, inq[0] = true; queue &lt;int> q; q.push(0); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; cnt[e.to] = cnt[u] + 1; if (cnt[e.to] > n + 1) return false; // 总共有 n+1 个点，超过它有负环 if (!inq[e.to]) &#123; inq[e.to] = true; q.push(e.to); &#125; &#125; &#125; &#125; return true; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int i, j, c; scanf(\"%d%d%d\", &amp;i, &amp;j, &amp;c); addedge(j, i, c); &#125; for (int i = 1; i &lt;= n; ++i) addedge(0, i, 0); if (SPFA()) &#123; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", d[i]); putchar('\\n'); &#125; else puts(\"NO\"); return 0; &#125; 小杂项 有的约束条件会出现为 xi−xj≥yx_i-x_j \\ge yxi​−xj​≥y，那么只需要两边乘 −1-1−1 得到 xj−xi≤−yx_j-x_i \\le -yxj​−xi​≤−y。如果出现了相等，只需要将其拆分成 xi−xj≥yx_i-x_j \\ge yxi​−xj​≥y 和 xi−xj≤yx_i-x_j \\le yxi​−xj​≤y 即可。 如果要求正数解，我们只需要给所有值加上一个足够大的数即可，这样不等式组依然成立。 还有一个问题，只能跑最短路吗？我跑最长路找正环可不可以？当然行！这样的约束条件形如 xi−xj≥yx_i-x_j\\ge yxi​−xj​≥y，那么变形为 xi≥xj+yx_i\\ge x_j+yxi​≥xj​+y，需要连一条 j→ij\\rightarrow ij→i 的长度为 yyy 的有向边，跑最长路即可。当有正环时无解，剩下内容相同。 Problemset 我们来看一些习题，它们正是最短路中最有趣的内容，其中有些题目会与图论的其它内容综合。 简单最短路 不需要什么转化，就是赤裸的模板。 [Cnoi2020] 雷雨 Portal. 我们可以枚举这个中转点，利用 Dijkstra 分别求出三个点到所有点的最短路，在建模的时候将一个有序数对作为点的编号，然后这个点的答案就是 d1(i,j)+d2(i,j)+d3(i,j)−r(i,j)×2d1(i,j)+d2(i,j)+d3(i,j)-r(i,j)\\times 2d1(i,j)+d2(i,j)+d3(i,j)−r(i,j)×2。推荐读者自行实现代码。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;queue> #include &lt;vector> #define i64 long long using namespace std; const int dx[] = &#123;0, 0, 1, -1&#125;, dy[] = &#123;1, -1, 0, 0&#125;; int n, m, a, b, c; int R[1005][1005]; i64 d[3][1001][1001]; bool v[1005][1005]; struct node &#123; int x, y; i64 d; node(int x = 0, int y = 0, i64 d = 0) : x(x), y(y), d(d) &#123;&#125; bool operator &lt; (const node &amp;a) const &#123; return d > a.d; &#125; &#125;; void Dijkstra(int sx, int sy, int k) &#123; memset(v, 0, sizeof(v)); priority_queue &lt;node> q; q.push(node(sx, sy, R[sx][sy])); d[k][sx][sy] = R[sx][sy]; while (!q.empty()) &#123; int x = q.top().x, y = q.top().y; q.pop(); if (!v[x][y]) &#123; v[x][y] = true; for (int i = 0; i &lt; 4; ++i) &#123; int xx = x + dx[i], yy = y + dy[i]; if (xx &lt; 1 || xx > n || yy &lt; 1 || yy > n) continue; if (d[k][xx][yy] > d[k][x][y] + R[xx][yy]) &#123; d[k][xx][yy] = d[k][x][y] + R[xx][yy]; q.push(node(xx, yy, d[k][xx][yy])); &#125; &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;a, &amp;b, &amp;c); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;R[i][j]); memset(d, 0x3f, sizeof(d)); Dijkstra(1, a, 0); Dijkstra(n, b, 1); Dijkstra(n, c, 2); i64 ans = 2e18; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) ans = min(ans, d[0][i][j] + d[1][i][j] + d[2][i][j] - (R[i][j] &lt;&lt; 1)); printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P1144] 最短路计数 Portal. 记 cnt[i]cnt[i]cnt[i] 代表走到 iii 的最短路数目，那么如果 iii 被 u→iu\\rightarrow iu→i 松弛，那么 cnt[u]=cnt[i]+1cnt[u]=cnt[i]+1cnt[u]=cnt[i]+1，如果恰好相等而不能被松弛，那么 cnt[i]cnt[i]cnt[i] 要加上 cnt[u]cnt[u]cnt[u]。 查看代码 // 笔者为了练习而使用的 SPFA，正常不要使用 #include &lt;bits/stdc++.h> using namespace std; const int MOD = 100003; int n, m; int d[1000005], cnt[1000005]; bool inq[1000005]; vector &lt;int> G[1000005]; void SPFA(void) &#123; memset(d, 0x3f, sizeof(d)); d[1] = 0, cnt[1] = 1, inq[1] = true; queue &lt;int> q; q.push(1); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) if (d[G[u][i]] > d[u] + 1) &#123; d[G[u][i]] = d[u] + 1; cnt[G[u][i]] = cnt[u]; if (!inq[G[u][i]]) &#123; inq[G[u][i]] = true; q.push(G[u][i]); &#125; &#125; else if (d[G[u][i]] == d[u] + 1) cnt[G[u][i]] = (cnt[G[u][i]] + cnt[u]) % MOD; &#125; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); G[y].push_back(x); &#125; SPFA(); for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", cnt[i]); return 0; &#125; [Luogu P1875] 佳佳的魔法药水 Portal. 直接使用不加优化的 Dijkstra 算法，用一个二维数组记录边，在转移的时候要保证另一个点也已经被访问。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #define i64 long long using namespace std; int n; int d[1005]; i64 cnt[1005]; int G[3005][3005]; bool v[1005]; int main(void) &#123; memset(G, 0xff, sizeof G); scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", d + i), cnt[i] = 1; int a, b, c; while (scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c) == 3) G[a][b] = G[b][a] = c; for (int op = 1; op &lt; n; ++op) &#123; int x = 0; for (int i = 0; i &lt; n; ++i) if (!v[i] &amp;&amp; (x == 0 || d[i] &lt; d[x])) x = i; v[x] = true; for (int y = 0; y &lt; n; ++y) if (v[y] &amp;&amp; G[x][y] != -1) &#123; if (d[G[x][y]] > d[x] + d[y]) d[G[x][y]] = d[x] + d[y], cnt[G[x][y]] = cnt[x] * cnt[y]; else if (d[G[x][y]] == d[x] + d[y]) cnt[G[x][y]] += cnt[x] * cnt[y]; &#125; &#125; printf(\"%d %lld\\n\", d[0], cnt[0]); return 0; &#125; [Luogu P1462] 通往奥格瑞玛的道路 Portal. 我们可以二分需要交的最大过路费，在限定内才允许松弛，然后跑最短路判断血量是否允许。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;vector> #include &lt;queue> using namespace std; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; vector &lt;edge> edges; vector &lt;int> G[10005]; inline void addedge(int u, int v, int d) &#123; edges.push_back(edge(v, d)); G[u].push_back(edges.size() - 1); &#125; int n, m, b; int f[10005]; int d[10005]; bool v[10005]; bool Dijkstra(int maxx) &#123; if (f[1] > maxx) return false; #define pii pair&lt;int, int> memset(d, 0x3f, sizeof(d)); memset(v, 0, sizeof(v)); d[1] = 0; priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.push(make_pair(0, 1)); while (!q.empty()) &#123; int x = q.top().second; q.pop(); if (!v[x]) &#123; v[x] = true; for (int i = 0; i &lt; G[x].size(); ++i) &#123; edge &amp;e = edges[G[x][i]]; if (d[e.to] > d[x] + e.dist &amp;&amp; f[e.to] &lt;= maxx) &#123; d[e.to] = d[x] + e.dist; q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; return d[n] &lt;= b; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;b); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", f + i); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); addedge(u, v, d); addedge(v, u, d); &#125; int L = 0, R = 1000000002; while (L + 1 != R) // 二分需要交的最多的过路费 &#123; int mid = L + R >> 1; if (Dijkstra(mid)) R = mid; else L = mid; &#125; if (L == 1000000001) puts(\"AFK\"); else printf(\"%d\\n\", R); return 0; &#125; [UVa 11374] Airport Express Portal。 注意到商业线只能坐一站，所以枚举坐哪个商业线即可。在起点和重点各跑一次最短路（因为是无向图）。代码较为复杂，推荐自行实现。注意本题有坑，输出的行末不能有空格。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> #include &lt;algorithm> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; struct edge &#123; int u, v, d; edge(int u, int v, int d) : u(u), v(v), d(d) &#123;&#125; &#125;; vector &lt;edge> edges; vector &lt;int> G[505]; inline void addedge(int u, int v, int d) &#123; edges.push_back(edge(u, v, d)); G[u].push_back(edges.size() - 1); &#125; int n, s, e, m, k; int dist[505], p[505]; bool vis[505]; inline void dijkstra(int S) &#123; memset(dist, 0x3f, sizeof(dist)); memset(vis, 0, sizeof(vis)); memset(p, 0, sizeof(p)); dist[S] = 0; priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii> > q; q.push(make_pair(0, S)); while (!q.empty()) &#123; int u = q.top().Y; q.pop(); if (vis[u] == 0) &#123; vis[u] = 1; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (dist[u] + e.d &lt; dist[e.v]) &#123; dist[e.v] = dist[u] + e.d; p[e.v] = G[u][i]; q.push(make_pair(dist[e.v], e.v)); &#125; &#125; &#125; &#125; &#125; int d1[505], d2[505]; vector &lt;int> path1[505], path2[505]; inline void calcShortestPath(int S, int *d, vector&lt;int> *paths) &#123; dijkstra(S); for (int i = 1; i &lt;= n; ++i) &#123; d[i] = dist[i]; paths[i].clear(); int t = i; paths[i].push_back(t); while (S != t) &#123; paths[i].push_back(edges[p[t]].u); t = edges[p[t]].u; &#125; reverse(paths[i].begin(), paths[i].end()); &#125; &#125; int main(void) &#123; int kase = 0; while (scanf(\"%d%d%d\", &amp;n, &amp;s, &amp;e) == 3) &#123; for (int i = 0; i &lt;= n; ++i) G[i].clear(); edges.clear(); m = read(); while (m--) &#123; int u = read(), v = read(), d = read(); addedge(u, v, d); addedge(v, u, d); &#125; calcShortestPath(s, d1, path1); calcShortestPath(e, d2, path2); int ans = d1[e], midpoint = -1; vector &lt;int> path = path1[e]; k = read(); while (k--) &#123; int x = read(), y = read(), val = read(); for (int op = 0; op &lt; 2; ++op) &#123; if (d1[x] + d2[y] + val &lt; ans) &#123; ans = d1[x] + d2[y] + val; midpoint = x; path = path1[x]; for (int j = path2[y].size() - 1; j >= 0; --j) path.push_back(path2[y][j]); &#125; swap(x, y); &#125; &#125; if (kase) putchar('\\n'); ++kase; for (int i = 0; i &lt; path.size() - 1; ++i) printf(\"%d \", path[i]); printf(\"%d\\n\", e); if (midpoint == -1) puts(\"Ticket Not Used\"); else printf(\"%d\\n\", midpoint); printf(\"%d\\n\", ans); &#125; return 0; &#125; [Luogu P2829] 大逃离 Portal.求从 xxx 到 yyy，不能进入出度小于 kkk 的点（起点终点除外）的次短路。 根据最短路的性质，次短路还有另一种求法：跑出以 1,n1,n1,n 为起点的最短路（当然有向图还需要建反图），然后枚举每一条边，以这一条边为次短路中的一条，两端的最短路是剩下的部分。按上述方式实现即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #include &lt;queue> using namespace std; const int INF = 1e9; struct edge &#123; int u, v, d; &#125;; int n, m, k; bool vis[5005]; int d1[5005], d2[5005], out[5005]; vector&lt;edge> edges; vector&lt;int> G[5005]; inline void addedge(int u, int v, int w) &#123; edges.push_back(&#123;u, v, w&#125;); G[u].push_back(edges.size() - 1); &#125; void Dijkstra(int s, int *d) &#123; #define pii pair&lt;int, int> priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii> > q; memset(vis, 0, sizeof(vis)); d[s] = 0; q.push(&#123;0, s&#125;); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!vis[u]) &#123; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = edges[G[u][i]].v, w = edges[G[u][i]].d; if (d[v] > d[u] + w &amp;&amp; out[v] >= k) &#123; d[v] = d[u] + w; q.push(&#123;d[v], v&#125;); &#125; &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; out[1] = out[n] = INF; for (int i = 2; i &lt; n; ++i) &#123; memset(vis, 0, sizeof(vis)); for (int j = 0; j &lt; G[i].size(); ++j) &#123; int v = edges[G[i][j]].v; if (!vis[v]) &#123; vis[v] = true; ++out[i]; &#125; &#125; &#125; memset(d1, 0x3f, sizeof(d1)); memset(d2, 0x3f, sizeof(d2)); Dijkstra(1, d1); Dijkstra(n, d2); int ans = INF; for (int i = 0; i &lt; edges.size(); ++i) &#123; int u = edges[i].u, v = edges[i].v, w = edges[i].d; int len = d1[u] + d2[v] + w; if (len > d1[n]) ans = min(ans, len); &#125; if (ans != INF) printf(\"%d\\n\", ans); else puts(\"-1\"); return 0; &#125; 差分约束算法 差分约束系统很有用。 [Luogu P1993] 小 K 的农场 Portal. 可以看出是差分约束，只需要利用之前所讲的随便转化一下就可以了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cstring> #include &lt;queue> using namespace std; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; int n, m; vector &lt;edge> G[5005]; void addedge(int u, int v, int d) &#123; G[u].push_back(edge(v, d)); &#125; int d[5005], cnt[5005]; bool inq[5005]; bool SPFA(void) &#123; memset(d, 0x3f, sizeof(d)); d[0] = 0; inq[0] = true; queue &lt;int> q; q.push(0); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = G[u][i]; if (d[e.to] > d[u] + e.dist) &#123; d[e.to] = d[u] + e.dist; cnt[e.to] = cnt[u] + 1; if (cnt[e.to] >= n + 1) return true; if (!inq[e.to]) &#123; inq[e.to] = true; q.push(e.to); &#125; &#125; &#125; &#125; return false; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int a, b, c, d; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); if (a == 3) addedge(b, c, 0), addedge(c, b, 0); else &#123; scanf(\"%d\", &amp;d); if (a == 1) addedge(b, c, -d); else addedge(c, b, d); &#125; &#125; for (int i = 0; i &lt;= n; ++i) addedge(0, i, 0); if (SPFA()) puts(\"No\"); else puts(\"Yes\"); return 0; &#125; Floyd 求解 | [SCOI2008] 天平 Portal.你有 nnn 个砝码，均为 111 克，222 克或者 333 克。你并不清楚每个砝码的重量，但你知道其中一些砝码重量的大小关系。你把其中两个砝码 AAA 和 BBB 放在天平的左边，需要另外选出两个砝码放在天平的右边。问：有多少种选法使得天平的左边重、一样重、右边重（只有结果保证唯一的选法才统计在内）？ 考虑每一个限制关系，相当于是给出了 a≤xi−xj≤ba\\le x_i-x_j\\le ba≤xi​−xj​≤b。按照约束条件讨论之后可以得出 a,ba,ba,b 的值（详见代码）。 这个东西一看就老差分约束了。我们跑一个最短路（用于限制 ≤b\\le b≤b），一个最长路（用于限制 ≥a\\ge a≥a），但是用 Folyd 跑！得出的距离可以转化回不等式，可以很方便的回答问题。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, a, b; int maxd[55][55], mind[55][55]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b); char c = getchar(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; while (!ispunct(c)) c = getchar(); if (i == j || c == '=') maxd[i][j] = mind[i][j] = 0; else if (c == '?') maxd[i][j] = 2, mind[i][j] = -2; else if (c == '+') maxd[i][j] = 2, mind[i][j] = 1; else maxd[i][j] = -1, mind[i][j] = -2; c = getchar(); &#125; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; maxd[i][j] = min(maxd[i][j], maxd[i][k] + maxd[k][j]); mind[i][j] = max(mind[i][j], mind[i][k] + mind[k][j]); &#125; int c1 = 0, c2 = 0, c3 = 0; for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123; if (i == a || i == b) continue; if (j == a || j == b) continue; if (mind[a][i] > maxd[j][b] || mind[a][j] > maxd[i][b]) ++c1; if ((maxd[a][i] == mind[a][i] &amp;&amp; mind[a][i] == maxd[j][b] &amp;&amp; maxd[j][b] == mind[j][b]) || (maxd[a][j] == mind[a][j] &amp;&amp; mind[a][j] == maxd[i][b] &amp;&amp; maxd[i][b] == mind[i][b])) ++c2; if (maxd[a][i] &lt; mind[j][b] || maxd[a][j] &lt; mind[i][b]) ++c3; &#125; printf(\"%d %d %d\\n\", c1, c2, c3); return 0; &#125; [1007] 倍杀测量者 Portal. 观察到答案具有单调性，因此可以二分。限制条件是乘法，但是我们可以取一个 log⁡\\loglog 化乘为加，对于给定的数值就是相等的限制条件，用两个不等式夹死，这样就可以直接用差分约束求解了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const double eps = 1e-6; const double INF = 1e9; int n, m, t; bool inq[1005]; struct edge &#123; int v, type; double w; edge(int v = 0, double w = 0, int type = 0) : v(v), w(w), type(type) &#123;&#125; &#125;; vector&lt;edge> G[1005]; double d[1005]; int cnt[1005]; bool SPFA(double T) &#123; for (int i = 0; i &lt;= n; ++i) cnt[i] = 0, d[i] = -INF; d[n + 1] = 0; queue&lt;int> q; q.push(n + 1); inq[n + 1] = true; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].v, type = G[u][i].type; double w = G[u][i].w; if (type == 1) w = log2(w - T); else if (type == 2) w = -log2(w + T); if (d[v] &lt; d[u] + w) &#123; d[v] = d[u] + w, inq[v] = true, q.push(v); if ((cnt[v] = cnt[u] + 1) > n + 1) return 1; // 肯定有人女装 &#125; &#125; &#125; return 0; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;t); for (int i = 0; i &lt;= n; ++i) G[n + 1].emplace_back(i, 0); while (m--) &#123; int o, a, b, k; scanf(\"%d%d%d%d\", &amp;o, &amp;a, &amp;b, &amp;k); G[b].emplace_back(a, k, o); &#125; while (t--) &#123; int c; double x; scanf(\"%d%lf\", &amp;c, &amp;x); G[0].emplace_back(c, log2(x)); G[c].emplace_back(0, -log2(x)); &#125; double L = 0, R = 10, mid; if (!SPFA(0)) return puts(\"-1\"), 0; while (L + eps &lt; R) &#123; if (SPFA(mid = (L + R) / 2)) L = mid; else R = mid; &#125; printf(\"%.6lf\\n\", L); return 0; &#125; [Luogu P5590] 赛车游戏 Portal.james1 和 Mr. V 打算一起玩赛车。但他们被 Solaris 骗去了秋名山。秋名山上有 nnn 个点和 mmm 条边，james1 和 Mr. V 要从点 111 出发开往点 nnn，每条边都有一个初始的方向。Solaris 拿到了秋名山的地图但却不知道每条路有多长。显然，为了赛车游戏的公平，每条 111 到 nnn 的路径应当是等长的。Solaris 想，我就随便给边表上一个 1…91\\dots 91…9 的长度，反正傻傻的 james1 也看不出来。现在 Solaris 要求你标出长度，否则 Mr. V 在赛车比赛中可能会将 james1 撞死。n≤1000 m≤2000n \\leq 1000\\, m \\leq 2000n≤1000m≤2000。 限制边权这件事比较牛马，因此考虑直接限制距离。我们只需要满足 1≤dv−du≤91\\le d_v-d_u\\le 91≤dv​−du​≤9，转化为 dv≤du+9,du≤dv−1d_v\\le d_u+9,d_u\\le d_v-1dv​≤du​+9,du​≤dv​−1，差分约束构造即可，注意不在路径上的边不能考虑。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 0x3f3f3f3f; int n, m, u[2005], v[2005], d[1005], cnt[1005]; bool inq[1005], vis[1005], f[1005]; vector&lt;pair&lt;int, int> > G[1005]; vector&lt;int> e[1005]; void dfs(int x) &#123; vis[x] = 1; for (int y : e[x]) &#123; if (!vis[y]) dfs(y); f[x] |= f[y]; &#125; &#125; bool SPFA(void) &#123; memset(d, 0x3f, sizeof d); queue&lt;int> q; q.push(1); d[1] = 0; inq[1] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (auto [v, w] : G[u]) if (d[v] > d[u] + w) &#123; d[v] = d[u] + w, cnt[v] = cnt[u] + 1; if (cnt[v] > n) return 1; if (!inq[v]) q.push(v), inq[v] = 1; &#125; &#125; return 0; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", u + i, v + i); e[u[i]].emplace_back(v[i]); &#125; f[n] = 1; dfs(1); for (int i = 1; i &lt;= m; ++i) &#123; if (!f[u[i]] || !f[v[i]]) continue; G[u[i]].emplace_back(v[i], 9); G[v[i]].emplace_back(u[i], -1); &#125; if (!f[1] || SPFA()) return puts(\"-1\"), 0; printf(\"%d %d\\n\", n, m); for (int i = 1; i &lt;= m; ++i) &#123; int w = d[v[i]] - d[u[i]]; if (!f[u[i]] || !f[v[i]]) w = 1; printf(\"%d %d %d\\n\", u[i], v[i], w); &#125; return 0; &#125; 最短路建模与综合应用 这里的题可能需要一些脑子，但是笔者没有。 [SDOI2009] Elaxia 的路线 Portal.给定一张有向图，分别给定两个人的起点和终点，求它们走最短路的重合路径的最大长度。 我们对四个点各跑一次最短路，然后依次判断每一条边是否同时是两个最短路中的一条边，这些边将构成一个 DAG。然后进行 DAG 上的 DP，计算最长的公共时间。 要注意的是，这两个人走的公共路径重合，方向是反的也是可以的，这种情况需要再算一遍。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, m; int x_, y_, x__, y__; struct edge &#123; int from, to, dist; edge(int from = 0, int to = 0, int dist = 0) : from(from), to(to), dist(dist) &#123;&#125; &#125;; vector &lt;edge> edges; vector &lt;int> G[1505]; int d[4][1505]; bool v[1505]; inline void addedge(int u, int v, int w) &#123; edges.push_back(edge(u, v, w)); G[u].push_back(edges.size() - 1); &#125; void Dijkstra(int s, int id) &#123; memset(d[id], 0x3f, sizeof(d[id])); memset(v, 0, sizeof(v)); d[id][s] = 0; #define pii pair&lt;int, int> priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.push(make_pair(0, s)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!v[u]) &#123; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (d[id][e.to] > d[id][u] + e.dist) &#123; d[id][e.to] = d[id][u] + e.dist; q.push(make_pair(d[id][e.to], e.to)); &#125; &#125; &#125; &#125; &#125; int in[1505], len[1505]; vector &lt;edge> G2[1505]; inline void addedge2(int u, int v, int w) &#123; G2[u].push_back(edge(u, v, w)); ++in[v]; &#125; void Kahn(void) &#123; queue &lt;int> q; for (int i = 1; i &lt;= n; ++i) if (in[i] == 0) q.push(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G2[u].size(); ++i) &#123; edge &amp;e = G2[u][i]; --in[e.to]; len[e.to] = max(len[e.to], len[e.from] + e.dist); if (in[e.to] == 0) q.push(e.to); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;x_, &amp;y_, &amp;x__, &amp;y__); while (m--) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; Dijkstra(x_, 0), Dijkstra(y_, 1); Dijkstra(x__, 2), Dijkstra(y__, 3); int ans = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; G[i].size(); ++j) &#123; edge &amp;e = edges[G[i][j]]; // x_ -> i + i -> to + y_ -> to == x_ -> y_ // x__ -> i + i -> to + y__ -> to == x__ -> y__ if (d[0][i] + e.dist + d[1][e.to] == d[0][y_] &amp;&amp; d[2][i] + e.dist + d[3][e.to] == d[2][y__]) addedge2(e.from, e.to, e.dist); &#125; Kahn(); for (int i = 1; i &lt;= n; ++i) ans = max(ans, len[i]); for (int i = 1; i &lt;= n; ++i) G2[i].clear(); memset(len, 0, sizeof(len)), memset(in, 0, sizeof(in)); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; G[i].size(); ++j) &#123; edge &amp;e = edges[G[i][j]]; // x_ -> i + i -> to + y_ -> to == x_ -> y_ // y__ -> i + i -> to + x__ -> to == y__ -> x__ if (d[0][i] + e.dist + d[1][e.to] == d[0][y_] &amp;&amp; d[3][i] + e.dist + d[2][e.to] == d[3][x__]) addedge2(e.from, e.to, e.dist); &#125; Kahn(); for (int i = 1; i &lt;= n; ++i) ans = max(ans, len[i]); printf(\"%d\\n\", ans); return 0; &#125; [GXOI/GZOI2019] 旅行者 Portal.给定一张 n(1≤n≤105)n(1\\le n \\le 10^5)n(1≤n≤105) 点 m(1≤m≤105)m(1\\le m\\le 10^5)m(1≤m≤105) 边的有向带权图，给定其中 k(2≤k≤n)k(2\\le k\\le n)k(2≤k≤n) 个点，问这 kkk 个点两两之间的最短路的最小一个的长度。 如果我们把特殊点分成 A,BA,BA,B 两个集合，新建起点 sss 连接到 AAA 上的所有点，BBB 中所有点连到 ttt，那么 s,ts,ts,t 的最短路就是 A,BA,BA,B 之间点对的最小最短路。 我们枚举二进制位，将第 iii 位为 111 的放在 AAA，其余放在 000，这样就能保证总有一种情况两个点不在一个集合里，可以覆盖所有的情况。 然而这样很慢，我们换一种思路。我们求出点 iii 到某个关键点的最短距离 tit_iti​ 和到的关键点 toito_itoi​，以及到点 iii 最近的关键点 frifr_ifri​ 和距离 fif_ifi​。我们只需要用一条边把两个最短拼接在一起即可。显然不存在一条比这更短的路径，否则我们一定可以将原来最短路中的一条边替换，变成更短的路。而且也肯定不会漏解，因为最优解一定是“从一个关键点出发，经过一条边，再到另一个关键点”。 查看代码 #include &lt;bits/stdc++.h> using namespace std; using i64 = long long; using pii = pair&lt;int, int>; using pli = pair&lt;i64, int>; int n, m, k; int u[500005], v[500005], d[500005]; int a[100005]; struct Dijkstra &#123; i64 d[100005]; int f[100005]; bool vis[100005]; vector&lt;pii> G[100005]; void init(void) &#123; for (int i = 1; i &lt;= n; ++i) G[i].clear(); &#125; void dijkstra(void) &#123; memset(d, 0x1f, sizeof(d)); memset(vis, 0, sizeof(vis)); priority_queue&lt;pli, vector&lt;pli>, greater&lt;pli>> q; for (int i = 1; i &lt;= k; ++i) &#123; d[a[i]] = 0; f[a[i]] = a[i]; q.push(make_pair(0, a[i])); &#125; while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!vis[u]) &#123; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].first, w = G[u][i].second; if (d[v] > d[u] + w) &#123; d[v] = d[u] + w; q.push(make_pair(d[v], v)); f[v] = f[u]; &#125; &#125; &#125; &#125; &#125; &#125; S1, S2; void solve(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); S1.init(), S2.init(); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d%d\", u + i, v + i, d + i); S1.G[u[i]].push_back(&#123;v[i], d[i]&#125;); S2.G[v[i]].push_back(&#123;u[i], d[i]&#125;); &#125; for (int i = 1; i &lt;= k; ++i) scanf(\"%d\", a + i); S1.dijkstra(); S2.dijkstra(); // S1 为关键点到点 i，S2 为从点 i 到关键点 i64 ans = 4e18; for (int i = 1; i &lt;= m; ++i) if (S1.f[u[i]] != S2.f[v[i]]) ans = min(ans, S1.d[u[i]] + S2.d[v[i]] + d[i]); printf(\"%lld\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [Code+#4] 最短路 Portal. 异或这种距离处理方式让人想到有些边是不必要的。对于一个二进制数，我们将其中一位取反，再将另一位取反，跟同时将这两位取反的代价是一样的，因此只要枚举每一个点的每一个二进制位建图即可，边的数量在 O(nlog⁡n+m)O(n\\log n+m)O(nlogn+m) 级别。 查看代码 #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> using namespace std; int n, m, c, S, T; int d[200005]; bool vis[200005]; vector&lt;pair&lt;int, int>> G[200005]; void dijkstra(void) &#123; priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii>> q; memset(d, 0x3f, sizeof d); q.emplace(d[S] = 0, S); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = true; for (auto [v, w] : G[u]) if (d[v] > d[u] + w) q.emplace(d[v] = d[u] + w, v); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].emplace_back(v, d); &#125; scanf(\"%d%d\", &amp;S, &amp;T); for (int i = 0; i &lt;= 16; ++i) for (int u = 1; u &lt;= n + (1 &lt;&lt; i); ++u) &#123; int v = u ^ (1 &lt;&lt; i); G[u].emplace_back(v, (1 &lt;&lt; i) * c); &#125; dijkstra(); return printf(\"%d\\n\", d[T]), 0; &#125; [NOIP2017 提高组] 逛公园 Portal. 求出最短路，然后设 f(i,j)f(i,j)f(i,j) 代表到达节点 iii，距离为 d[i]+j(0≤j≤k)d[i]+j(0\\le j\\le k)d[i]+j(0≤j≤k) 的方案数，初始 f(1,0)=1f(1,0)=1f(1,0)=1，在反图上进行 DP，通过标记一个访问数组来判断是否有零环。 查看代码 #include &lt;bits/stdc++.h> #define pii pair&lt;int, int> using namespace std; int n, m, k, P; vector&lt;pair&lt;int, int>> G1[100005], G2[100005]; bool done[100005]; int d[100005]; void dijkstra(void) &#123; memset(done, 0, sizeof done); memset(d, 0x3f, sizeof d); priority_queue&lt;pii, vector&lt;pii>, greater&lt;pii>> q; q.emplace(d[1] = 0, 1); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (done[u]) continue; done[u] = true; for (auto [v, w] : G1[u]) if (d[v] > d[u] + w) q.emplace(d[v] = d[u] + w, v); &#125; &#125; bool flag, vis[100005][51]; int f[100005][51]; int dp(int u, int k) &#123; if (flag || k &lt; 0) return 0; if (vis[u][k]) return flag = 1, 0; if (f[u][k]) return f[u][k]; int ans = 0; vis[u][k] = 1; for (auto [v, w] : G2[u]) &#123; ans = (ans + dp(v, d[u] + k - w - d[v])) % P; if (flag) return 0; &#125; vis[u][k] = 0; return f[u][k] = ans; &#125; void solve(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;P); for (int i = 1; i &lt;= n; ++i) G1[i].clear(), G2[i].clear(); while (m--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G1[u].emplace_back(v, d); G2[v].emplace_back(u, d); &#125; dijkstra(); memset(vis, 0, sizeof vis); memset(f, 0, sizeof f); flag = 0; dp(1, 0); f[1][0] = 1; int ans = 0; for (int i = 0; i &lt;= k; ++i) ans = (ans + dp(n, i)) % P; printf(\"%d\\n\", flag ? -1 : ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; [AHOI2014/JSOI2014] 骑士游戏 Portal. 如果一个怪兽的魔伤是所有怪兽中最小的，那么显然就用魔法打死它了（Ri≥1R_i\\ge 1Ri​≥1）。按照这个顺序进行贪心，如果打死 xxx 生成一个怪兽 yyy，那么连一条 y→xy\\rightarrow xy→x 的边，表示如果想用物攻杀死 xxx 需要先打死 yyy，距离可以很方便的统计，是一个类似于 Dijkstra 的贪心过程。 查看代码 #include &lt;bits/stdc++.h> #define i64 long long #define pli pair&lt;i64, int> using namespace std; int n; i64 dis[200005], s[200005], deg[200005]; bool vis[200005]; vector&lt;int> G[200005]; priority_queue&lt;pli, vector&lt;pli>, greater&lt;pli> > q; void Dijkstra(void) &#123; while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int v : G[u]) &#123; --deg[v]; s[v] += dis[u]; if (!deg[v] &amp;&amp; s[v] &lt; dis[v]) q.emplace(dis[v] = s[v], v); &#125; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x, m; scanf(\"%lld%lld%d\", s + i, dis + i, &amp;m); q.emplace(dis[i], i); deg[i] = m; while (m--) scanf(\"%d\", &amp;x), G[x].emplace_back(i); &#125; Dijkstra(); return !printf(\"%lld\\n\", dis[1]); &#125; [CF375C] Circling Round Treasures Portal. 发现东西很少，状压即可。设 fx,y,Sf_{x,y,S}fx,y,S​ 表示走到这个状态的最小步数，BFS 最短路即可。 现在的问题是，如何判断一个点是否在多边形内？ 射线法：以点 AAA 为端点的一条射线与多边形的交点个数，为奇数在多边形内，为偶数不在。 令射线方向都往左，这样就可以很方便的统计了。 查看代码 #include &lt;bits/stdc++.h> using namespace std; const int INF = 1e7; const int DX[] = &#123;0, 0, 1, -1&#125;, DY[] = &#123;1, -1, 0, 0&#125;; int n, m, t; int sx, sy, px[15], py[15], v[15]; char a[25][25]; int f[25][25][1024], sum[1024]; inline bool check(int x, int y, int xx, int yy, int i) &#123; if (xx == px[i] &amp;&amp; yy &lt; py[i] &amp;&amp; x &lt; xx) return 1; if (x == px[i] &amp;&amp; y &lt; py[i] &amp;&amp; x > xx) return 1; return 0; &#125; int bfs(void) &#123; int ans = -INF; struct state &#123; int x, y, s; state(int x = 0, int y = 0, int s = 0) : x(x), y(y), s(s) &#123;&#125; &#125;; memset(f, 0xff, sizeof f); f[sx][sy][0] = 0; queue&lt;state> q; q.emplace(sx, sy, 0); while (!q.empty()) &#123; state u = q.front(); q.pop(); int x = u.x, y = u.y, s = u.s; if (x == sx &amp;&amp; y == sy) ans = max(ans, sum[s] - f[x][y][s]); for (int i = 0; i &lt; 4; ++i) &#123; int xx = x + DX[i], yy = y + DY[i], ss = s; if (xx &lt; 1 || xx > n || yy &lt; 1 || yy > m) continue; if (a[xx][yy] != '.' &amp;&amp; a[xx][yy] != 'S') continue; for (int j = 0; j &lt; t; ++j) if (check(x, y, xx, yy, j)) ss ^= 1 &lt;&lt; j; if (f[xx][yy][ss] == -1) f[xx][yy][ss] = f[x][y][s] + 1, q.emplace(xx, yy, ss); &#125; &#125; return ans; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%s\", a[i] + 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; char &amp;c = a[i][j]; if (c == 'S') sx = i, sy = j; else if (isdigit(c)) px[c - '0' - 1] = i, py[c - '0' - 1] = j, ++t; &#125; for (int i = 0; i &lt; t; ++i) scanf(\"%d\", v + i); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (a[i][j] == 'B') px[t] = i, py[t] = j, v[t] = -INF, ++t; for (int i = 0; i &lt; 1 &lt;&lt; t; ++i) for (int j = 0; j &lt; t; ++j) if (i >> j &amp; 1) sum[i] += v[j]; return !printf(\"%d\\n\", bfs()); &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://james1badcreeper.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"差分约束","slug":"差分约束","permalink":"https://james1badcreeper.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"}]},{"title":"区间 DP 与高维 DP","slug":"notes/DP/range-dp","date":"2022-07-28T00:00:00.000Z","updated":"2022-07-28T00:00:00.000Z","comments":true,"path":"1177a5e3/","link":"","permalink":"https://james1badcreeper.github.io/1177a5e3/","excerpt":"区间 DP 是线性 DP 的一种特殊形式，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。高维 DP 则是线性 DP 的扩展，大部分是从一条链扩展为了二维结构。","text":"区间 DP 是线性 DP 的一种特殊形式，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。高维 DP 则是线性 DP 的扩展，大部分是从一条链扩展为了二维结构。 这两个内容都属于都属于线性 DP 的变形。 区间 DP 区间类动态规划是线性动态规划的扩展。 它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。其转移方程一般形如 fi,j=max⁡{fi,k+fk+1,j+cost∣i≤k&lt;j}f_{i,j}=\\max\\{f_{i,k}+f_{k+1,j}+cost\\mid i \\le k &lt; j\\}fi,j​=max{fi,k​+fk+1,j​+cost∣i≤k&lt;j}，costcostcost 为将这两组元素合并起来的代价。 也有另一类区间 DP 的转移方程形如 fi,j=max⁡{fi+1,j+costi,fi,j−1+costj}f_{i,j}=\\max\\{f_{i+1,j}+cost_i,f_{i,j-1}+cost_j\\}fi,j​=max{fi+1,j​+costi​,fi,j−1​+costj​}，这一类的区间是通过左右端点逐个扩展的。 由于大区间的答案依赖于小区间的答案，所以要将区间的长度作为“阶段”来进行 DP。 但是这么说很闹鬼，我们通过题目来认识区间 DP。 模板 我们分别来看一看刚才所说的两种转移的具体实例。 [NOI1995] 石子合并 Portal. 以最大得分为例。 先假设排成一排，设 f[l][r]f[l][r]f[l][r] 表示合并区间 [l,r][l,r][l,r] 的最大得分，则有 f[l][r]=max⁡l⩽k&lt;r{f[l,k]+f[k+1][r]}+∑i=lraif[l][r]=\\max\\limits_{l \\leqslant k &lt; r}\\{f[l,k]+f[k+1][r]\\}+\\sum\\limits_{i=l}^r a_if[l][r]=l⩽k&lt;rmax​{f[l,k]+f[k+1][r]}+i=l∑r​ai​。 编程时有两种思路，一是记忆化搜索，二是递推，但注意递推时要以区间长度递增的顺序来推，因为大区间的答案依赖于小区间的答案。 接下来考虑如何处理环。我们将这条链延长两倍，变成 n×2n \\times 2n×2 堆，这样就可以转化成 nnn 条链，分别为 [1,n],[2,n+1][3,n+2],⋯ ,[n,2n−1][1,n],[2,n+1][3,n+2],\\cdots,[n,2n-1][1,n],[2,n+1][3,n+2],⋯,[n,2n−1]。这种复制二倍链是处理环形 DP 极为有效的方式（因为环形问题中肯定有一条边是用不到的，那么我们将它从任意位置断开，然后就相当于从每个位置断开的情况都求了）。 代码如下： #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int a[205], sum[205]; int f[205][205]; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = a[n + i] = read(); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) sum[i] = sum[i-1] + a[i]; int ans = 1000000000; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) f[i][i] = 0; for (int len = 2; len &lt;= n; ++len) // 我们只需要处理到 len = n 即可 for (int i = 1; i &lt;= (n &lt;&lt; 1) - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + sum[j] - sum[i-1]); &#125; for (int i = 1; i &lt;= n; ++i) ans = min(ans, f[i][i + n - 1]); printf(\"%d\\n\", ans); ans = 0; memset(f, 0, sizeof(f)); for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= (n &lt;&lt; 1) - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = max(f[i][j], f[i][k] + f[k+1][j] + sum[j] - sum[i-1]); &#125; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i][i + n - 1]); printf(\"%d\\n\", ans); return 0; &#125; 状态有 O(n2)O(n^2)O(n2) 个，每个状态的决策有 O(n)O(n)O(n) 个，因此总时间复杂度为 O(n3)O(n^3)O(n3)。 [IOI2000] 回文字串 Portal. 设 f[l][r]f[l][r]f[l][r] 表示处理区间 [l,r][l,r][l,r] 的最小代价，那么显然可以花费 111 来处理左端点或右端点，如果左右端点相等的话还可以等价于处理 [l+1,r−1][l+1,r-1][l+1,r−1]。显然，这是第二种转移。 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; char s[1005]; int f[1005][1005]; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) f[i][i] = 0, f[i][i - 1] = 0; for (int len = 2; len &lt;= n; ++len) &#123; for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = min(f[i][j - 1], f[i + 1][j]) + 1; if (s[i] == s[j]) f[i][j] = min(f[i][j], f[i + 1][j - 1]); &#125; &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; 状态有 O(n2)O(n^2)O(n2) 个，每个状态的决策只有有 O(1)O(1)O(1) 个，因此总时间复杂度为 O(n2)O(n^2)O(n2)。 简单应用 这里是一些简单的区间 DP 题目。 [CQOI2007] 涂色 Portal. 设 f(i,j)f(i,j)f(i,j) 为完成 [i,j][i,j][i,j] 涂色需要的最少步数。首先有 f(i,i)=1f(i,i)=1f(i,i)=1。 当 s[i]=s[j]s[i] = s[j]s[i]=s[j] 时，f(i,j)=min⁡{f(i,j−1),f(i+1,j)}f(i,j)=\\min\\{f(i,j-1),f(i+1,j)\\}f(i,j)=min{f(i,j−1),f(i+1,j)}（只需要在涂其中某一个时，先涂这种颜色，将涂色的区间改为 [i,j][i,j][i,j]，再考虑 [i+1,j−1][i+1,j-1][i+1,j−1] 即可）。 在任何情况下，[i,j][i,j][i,j] 都能由 [i,k][i,k][i,k] 和 [k+1,j][k+1,j][k+1,j] 拼出来。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; char s[55]; int f[55][55]; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) f[i][i] = 1; for (int len = 1; len &lt; n; ++len) for (int i = 1; i &lt;= n - len; ++i) &#123; int j = i + len; if (s[i] == s[j]) f[i][j] = min(f[i][j - 1], f[i + 1][j]); for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; [NOIP2007 提高组] 矩阵取数游戏 Portal. 每一行的操作都是独立的，因此可以一行一行的思考。设 f[i][j]f[i][j]f[i][j] 为一行中取到只剩下 [i,j][i,j][i,j] 的最大值，转移只有两种方式：左取和右取。时间复杂度为 O(nm2)\\mathcal{O}(n{m}^2)O(nm2)。注意需要高精（当然可以用 __int128）。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> #define LL __int128 using namespace std; inline LL read(void) &#123; LL x = 0; int c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar(); return x; &#125; inline void print(LL x) &#123; if (x > 9) print(x / 10); putchar(x % 10 + '0'); &#125; int n, m; LL a[85]; LL f[85][85]; int main(void) &#123; n = read(), m = read(); LL ans = 0; while (n--) &#123; for (int i = 1; i &lt;= m; ++i) a[i] = read(); memset(f, 0, sizeof(f)); f[1][m] = 0; LL k = 1; for (int len = m - 1; len >= 0; --len) &#123; k &lt;&lt;= 1; for (int i = 1; i &lt;= m - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = max(f[i - 1][j] + a[i - 1] * k, f[i][j + 1] + a[j + 1] * k); &#125; &#125; LL res = -1; for (int i = 1; i &lt;= m; ++i) res = max(res, f[i][i] + a[i] * k); ans += res; &#125; print(ans); putchar('\\n'); return 0; &#125; [CF245H] Queries for Number of Palindromes Portal. 尽管用专门的字符串算法可以很高效地解决这个问题，但是还可以用区间 DP 来解决。根据经验，我们设 f(l,r)f(l,r)f(l,r) 表示这个范围内的回文子串个数。那么根据容斥原理显然有： f(l,r)=f(l,r−1)+f(l+1,r)−f(l+1,r−1)+is_pal(sl⋯r)f(l,r) = f(l,r-1) + f(l+1,r) - f(l+1,r-1) + \\text{is\\_pal}(s_{l\\cdots r}) f(l,r)=f(l,r−1)+f(l+1,r)−f(l+1,r−1)+is_pal(sl⋯r​) 现在的问题就是如何处理 is_pal。虽然字符串 Hash 可以在线性复杂度内解决这个问题，但没必要，因为我们的 DP 是平方复杂度。实际上这个问题也可以以平方复杂度用区间 DP 来求解。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; char s[5005]; int n, f[5005][5005]; bool is_pal[5005][5005]; int main(void) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (s[i] == s[j] &amp;&amp; (i + 1 >= j || is_pal[i + 1][j - 1])) is_pal[i][j] = true; &#125; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j] = f[i + 1][j] + f[i][j - 1] - f[i + 1][j - 1] + is_pal[i][j]; &#125; int q, l, r; scanf(\"%d\", &amp;q); while (q--) &#123; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d\\n\", f[l][r]); &#125; return 0; &#125; [IOI1998] Polygon Portal. 特别地，请将数据范围看作 n⩽150n\\leqslant 150n⩽150。 我们可以枚举删哪一条边，本题就转化为链上问题。设 f[l,r]f[l,r]f[l,r] 表示区间 [l,r][l,r][l,r] 的最大值行吗？不行！由于负负得正的存在，这样的状态设计不满足最优子结构性质，那怎么办？在记录一个记录最小值的就行了！ 设 f[l,r,0],f[l,r,1]f[l,r,0],f[l,r,1]f[l,r,0],f[l,r,1] 分别代表区间的最大最小值。当运算为求和是，正常更新即可。乘法需要注意，最大值的来源只可能是最大乘最大或最小乘最小，而最小值的来源则是所有的都可能。实际上，这时候如果搞不清楚，还不如都写上，反正不会得出错误的解就行（没人会卡这里的常数吧）。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; const int INF = 1000000000; int n; char c[105]; int a[105]; int f[105][105][2]; int main(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> c[i] >> a[i]; for (int i = n + 1; i &lt;= (n &lt;&lt; 1); ++i) c[i] = c[i - n], a[i] = a[i - n]; for (int l = 1; l &lt;= (n &lt;&lt; 1); ++l) for (int r = 1; r &lt;= (n &lt;&lt; 1); ++r) if (l != r) f[l][r][0] = -INF, f[l][r][1] = INF; else f[l][r][0] = f[l][r][1] = a[l]; for (int len = 2; len &lt;= (n &lt;&lt; 1); ++len) for (int l = 1; l &lt;= (n &lt;&lt; 1) - len + 1; ++l) &#123; int r = l + len - 1; for (int k = l; k &lt; r; ++k) &#123; if (c[k + 1] == 't') &#123; f[l][r][0] = max(f[l][r][0], f[l][k][0] + f[k + 1][r][0]); f[l][r][1] = min(f[l][r][1], f[l][k][1] + f[k + 1][r][1]); &#125; else &#123; f[l][r][0] = max(&#123;f[l][r][0], f[l][k][0] * f[k + 1][r][0], f[l][k][1] * f[k + 1][r][1]&#125;); f[l][r][1] = min(&#123;f[l][r][1], f[l][k][0] * f[k + 1][r][1], f[l][k][1] * f[k + 1][r][0], f[l][k][0] * f[k + 1][r][0], f[l][k][1] * f[k + 1][r][1]&#125;); &#125; &#125; &#125; int ans = -INF; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i][i + n - 1][0]); printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; ++i) if (f[i][i + n - 1][0] == ans) printf(\"%d \", i); putchar('\\n'); return 0; &#125; [SCOI2003] 字符串折叠 Portal. 首先这肯定是第一种区间 DP，因为折叠可以从中间抠，肯定不是从两头扩展。 设 f(i,j)f(i,j)f(i,j) 为 [i,j][i,j][i,j] 的最短折叠，按照它的题意，应该有以下三种折叠方式： 自己作为一个折叠，显然这时 f(i,j)=j−i+1f(i,j)=j-i+1f(i,j)=j−i+1； 把若干个重复的东西拼成一个，这怎么搞？不要紧，数据范围那么小，我们暴力点想，这些重复的东西长度肯定是一样的，那么我们就枚举长度 kkk，而且显然要求 k∣j−i+1k\\mid j-i+1k∣j−i+1，这一过程我们 for 一遍检查是不是约数就可以了，因为检查能不能折叠的操作更费时间，加上括号和数字的代价，有 f(i,j)=f(i,i+k−1)+2+D(j−i+1k)f(i,j)=f(i,i+k-1)+2+D\\left(\\cfrac{j-i+1}{k}\\right)f(i,j)=f(i,i+k−1)+2+D(kj−i+1​)，其中 DDD 表示求一个数字的位数，在这之前我们要线性扫一遍看能不能折叠，进行一轮这样的转移的时间复杂度为 O(n1.5)\\mathcal{O}(n^{1.5})O(n1.5)； 枚举中间点进行转移，就是把两坨东西拼在一起，这时候 f(i,j)=min⁡{f(i,k)+f(k+1,j)∣k∈[i,j)}f(i,j)=\\min \\left\\{f(i,k) + f(k+1,j)\\mid k\\in [i,j)\\right\\}f(i,j)=min{f(i,k)+f(k+1,j)∣k∈[i,j)}。 状态有 O(n2)\\mathcal{O}(n^2)O(n2) 个，总时间复杂度为 O(n3.5)\\mathcal{O}(n^{3.5})O(n3.5)。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, D[105]; char s[105]; int f[105][105]; inline bool check(int l, int r, int len) &#123; for (int i = l; i &lt;= r; ++i) if (s[i] != s[(i - l) % len + l]) return false; return true; &#125; int main(void) &#123; for (int i = 0; i &lt; 10; ++i) D[i] = 1; for (int i = 10; i &lt; 100; ++i) D[i] = 2; for (int i = 100; i &lt; 103; ++i) D[i] = 3; scanf(\"%s\", s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) f[i][j] = j - i + 1; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); for (int k = 1; k &lt;= len; ++k) &#123; if (len % k != 0) continue; if (check(i, j, k)) f[i][j] = min(f[i][j], f[i][i + k - 1] + 2 + D[len / k]); &#125; &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; 高维 DP 其实在之前就已经见识过高维 DP 了。像 [NOIP2002 普及组] 过河卒。要知道的是它们也可以用滚动数组优化。我们直接上题： 简单内容 一道简单题。 [NOIP2009 普及组] 道路游戏 Portal. 设 f(i)f(i)f(i) 代表第 iii 个时刻获得的最大收益，转移的时候枚举机器人走的距离和从哪个位置开始走的即可（这样价值就可以计算出来了，用前缀和预处理加速查询）。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, p; int a[1005][1005], s[1005][1005]; int f[1005], cost[1005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;p); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[j][i % n]); for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt; n; ++j) s[i][j] = s[i - 1][(j - 1 + n) % n] + a[i][j]; for (int i = 0; i &lt; n; ++i) scanf(\"%d\", cost + i); memset(f, 0xbf, sizeof(f)); f[0] = 0; for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt; n; ++j) for (int k = 1; k &lt;= min(i, p); ++k) f[i] = max(f[i], f[i - k] + s[i][j] - s[i - k][((j - k) % n + n) % n] - cost[((j - k) % n + n) % n]); printf(\"%d\\n\", f[m]); return 0; &#125; 普通内容 两道正常一点的题。 [NOIP2014 提高组] 飞扬的小鸟 Portal. 设 f(i,j)f(i,j)f(i,j) 代表飞到 iii，高度为 jjj 的最小点击数。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; constexpr int INF = 0x3f3f3f3f; int n, m, k; int x[10005], y[10005], low[10005], high[10005]; bool e[10005]; int f[10005][2005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", x + i, y + i); low[i] = 1, high[i] = m; &#125; for (int i = 1, a, b, c; i &lt;= k; ++i) &#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); e[a] = true; low[a] = b + 1; high[a] = c - 1; &#125; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= m; ++i) f[0][i] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = x[i] + 1; j &lt;= x[i] + m; ++j) f[i][j] = min(f[i - 1][j - x[i]] + 1, f[i][j - x[i]] + 1); // 上升 for (int j = m + 1; j &lt;= x[i] + m; ++j) f[i][m] = min(f[i][m], f[i][j]); // 将飞到天上的拉回来 for (int j = 1; j &lt;= m - y[i]; ++j) f[i][j] = min(f[i][j], f[i - 1][j + y[i]]); // 下降 // 禁区 for (int j = 0; j &lt; low[i]; ++j) f[i][j] = INF; for (int j = high[i] + 1; j &lt;= m; ++j) f[i][j] = INF; &#125; int ans = INF; for (int i = 1; i &lt;= n; ++i) ans = min(ans, f[n][i]); if (ans &lt; INF) printf(\"1\\n%d\\n\", ans); else &#123; puts(\"0\"); for (int i = n; i >= 1; --i) &#123; bool flag = false; for (int j = 1; j &lt;= m; ++j) if (f[i][j] &lt; INF) &#123; flag = true; break; &#125; if (flag) &#123; ans = 0; for (int j = 1; j &lt;= i; ++j) if (e[j]) ++ans; printf(\"%d\\n\", ans); return 0; &#125; &#125; &#125; return 0; &#125; [CSP-S2019] Emiya 家今天的饭 Portal. 如果没有第三种限制，那么直接使用乘法原理碾过去即可。那么我们只需要求解出违反限制三的方案数，然后减去即可。 也就是说要求由食材的出现次数大于 ⌊k2⌋\\left\\lfloor \\cfrac{k}{2}\\right\\rfloor⌊2k​⌋，不难发现满足这一条件的食材最多只有 111 个，否则 (⌊k2⌋+1)×2&gt;k\\left(\\left\\lfloor \\cfrac{k}{2}\\right\\rfloor+1\\right)\\times 2 &gt; k(⌊2k​⌋+1)×2&gt;k。于是我们可以枚举这一个食材，设该食材为 xxx，每一个食材都进行 DP： 设 f(i,k,c)f(i,k,c)f(i,k,c) 代表考虑前 iii 个烹饪方法，总共选出 kkk 道菜，其中 ccc 个菜使用食材 xxx，那么： f(i,k,c)=max⁡{f(i−1,k,c),f(i−1,k−1,c−1)×ai,j,j=x,f(i−1,k−1,c)×ai,j,j≠x.f(i,k,c)=\\max\\begin{cases} f(i-1,k,c),\\\\ f(i-1,k-1,c-1)\\times a_{i,j},&amp;j=x,\\\\ f(i-1,k-1,c)\\times a_{i,j},&amp;j\\ne x. \\end{cases} f(i,k,c)=max⎩⎨⎧​f(i−1,k,c),f(i−1,k−1,c−1)×ai,j​,f(i−1,k−1,c)×ai,j​,​j=x,j=x.​ 但是这样的状态数爆炸了，有 O(n3)O(n^3)O(n3) 个，转移有 O(m)O(m)O(m) 个，还要进行 O(m)O(m)O(m) 次 DP，时间复杂度 O(n3m2)O(n^3 m^2)O(n3m2)，无法通过。 c&gt;⌊k2⌋c&gt;\\left\\lfloor \\cfrac{k}{2}\\right\\rfloorc&gt;⌊2k​⌋ 意味着什么？注意它等价于 c&gt;k2c&gt;\\cfrac{k}{2}c&gt;2k​，也就是 c−(k−c)&gt;0c-(k-c)&gt;0c−(k−c)&gt;0，也就是使用 xxx 的菜肴数量减去未使用 xxx 的菜肴数量。设 f(i,Δc)f(i,\\Delta c)f(i,Δc) 代表考虑前 iii 个烹饪方法，xxx 用的次数减掉 xxx 未被用的次数为 Δc\\Delta cΔc，那么： 若 j=xj=xj=x，则 f(i,Δc+1)←f(i,Δc+1)+f(i−1,Δc)×ai,jf(i,\\Delta c + 1)\\leftarrow f(i,\\Delta c+1)+f(i-1,\\Delta c)\\times a_{i,j}f(i,Δc+1)←f(i,Δc+1)+f(i−1,Δc)×ai,j​； 若 j≠xj\\ne xj=x，则 f(i,Δc−1)←f(i,Δc−1)+f(i−1,Δc)×ai,jf(i,\\Delta c - 1)\\leftarrow f(i,\\Delta c-1)+f(i-1,\\Delta c)\\times a_{i,j}f(i,Δc−1)←f(i,Δc−1)+f(i−1,Δc)×ai,j​； 不选， f(i,Δc)←f(i,Δc)+f(i−1,Δc)f(i,\\Delta c)\\leftarrow f(i,\\Delta c) + f(i-1,\\Delta c)f(i,Δc)←f(i,Δc)+f(i−1,Δc)。 最后的答案就是所有 Δ\\DeltaΔ 为正的 f(n,Δc)f(n,\\Delta c)f(n,Δc) 和，这样就满足 c−(k−c)&gt;0c-(k-c)&gt;0c−(k−c)&gt;0。 还可以进一步进行优化：对于第二种转移，我们不需要枚举 jjj，而是直接使用 aia_iai​ 的前缀和减去 ai,xa_{i,x}ai,x​ 即可。 实现时由于数组的下标不能是负的，所以我们只需要给下标加上 100100100 即可。最终时间复杂度为 O(m×n2)O(m\\times n^2)O(m×n2)。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int MOD = 998244353; int n, m; int S[105]; int a[105][2005]; int f[105][205]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;a[i][j]), S[i] = (S[i] + a[i][j]) % MOD; ans = 1ll * ans * (S[i] + 1) % MOD; &#125; ans = (ans - 1 + MOD) % MOD; for (int x = 1; x &lt;= m; ++x) &#123; memset(f, 0, sizeof(f)); f[0][0 + 100] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int re = (S[i] + MOD - a[i][x]) % MOD; // 利用前缀和进行计算 for (int j = 1; j &lt;= 201; ++j) &#123; f[i][j + 1] = (f[i][j + 1] + 1ll * a[i][x] * f[i - 1][j]) % MOD; f[i][j - 1] = (f[i][j - 1] + 1ll * re * f[i - 1][j]) % MOD; f[i][j] = (f[i][j] + f[i - 1][j]) % MOD; &#125; &#125; int no = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans - f[n][i + 100] + MOD) % MOD; &#125; printf(\"%d\\n\", ans); return 0; &#125; Problemset 嗯，题真多。 区间 DP 这里是区间 DP 的内容。 [CF607B] Zuma Portal. 设 f(i,j)f(i,j)f(i,j) 代表消掉区间 [i,j][i,j][i,j] 的答案，转移对于读到这里的读者来说不是困难。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; int a[505]; int f[505][505]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) f[i][i] = 1, f[i][i - 1] = 1; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (a[i] == a[j]) f[i][j] = f[i + 1][j - 1]; for (int k = i; k &lt; j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; [NOIP2003 提高组] 加分二叉树 Portal. 设 f[i][j]f[i][j]f[i][j] 代表区间 [i,j][i,j][i,j] 的最大答案，那么 f[i][j]=max⁡{f[i,k−1]×f[k+1][j]+f[k][k]}f[i][j]=\\max\\{f[i,k-1]\\times f[k+1][j]+f[k][k]\\}f[i][j]=max{f[i,k−1]×f[k+1][j]+f[k][k]}。初始条件要注意，由于空树的贡献是 111，所以要令 f(i,i−1)=1f(i,i-1)=1f(i,i−1)=1。本题需要打印解，用 root[i][j]root[i][j]root[i][j] 记录区间 [i,j][i,j][i,j] 所选取的根节点，然后递归遍历二叉树即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define i64 long long using namespace std; int n; int a[35], root[35][35]; i64 f[35][35]; void print_ans(int l, int r) &#123; if (l > r) return; printf(\"%d \", root[l][r]); if (l == r) return; print_ans(l, root[l][r] - 1); print_ans(root[l][r] + 1, r); &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;a[i]); f[i][i] = a[i]; f[i][i - 1] = 1; root[i][i] = i; &#125; f[n + 1][n] = 1; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) if (f[i][j] &lt; f[i][k - 1] * f[k + 1][j] + a[k]) &#123; f[i][j] = f[i][k - 1] * f[k + 1][j] + a[k]; root[i][j] = k; &#125; &#125; printf(\"%lld\\n\", f[1][n]); print_ans(1, n); putchar('\\n'); return 0; &#125; [NOIP2006 提高组] 能量项链 Portal. 环上问题肯定要复制成二倍链，而且为了方便计算我们最好现予处理出能量珠的头尾标记。转移时 f[i,j]=max⁡{f[i,k]+f[k+1,j]+head[i]×head[k+1]×tail[j]}f[i,j]=\\max\\{f[i,k]+f[k+1,j]+head[i]\\times head[k+1]\\times tail[j]\\}f[i,j]=max{f[i,k]+f[k+1,j]+head[i]×head[k+1]×tail[j]}。相乘的三个数分别是左区间对应的头标记，右区间对应的头标记和右区间对应的尾标记。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[205], head[205], tail[205]; int f[205][205]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); head[i] = head[i + n] = a[i]; tail[i - 1] = tail[i + n - 1] = a[i]; &#125; tail[n &lt;&lt; 1] = a[1]; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= (n &lt;&lt; 1) - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + head[i] * head[k + 1] * tail[j]); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i][i + n - 1]); printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1220] 关路灯 Portal. 设 f(i,j)f(i,j)f(i,j) 表示关掉 [i,j][i,j][i,j] 的最小功率？不行，因为我们还需要知道张大爷（不是笔者）的位置，到底是在 iii 还是在 jjj。所以 f(i,j,0)f(i,j,0)f(i,j,0) 表示张大爷在 iii，f(i,j,1)f(i,j,1)f(i,j,1) 表示张大爷在 jjj。转移对读到这的读者来说不是困难。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;cmath> using namespace std; int n, c; int p[155], w[155]; int sum[155]; int f[155][155][2]; int calc(int x, int y) &#123; // 除开区间 [x, y] 的和 return sum[x - 1] + sum[n] - sum[y]; &#125; int main(void) &#123; memset(f, 0x3f, sizeof(f)); scanf(\"%d%d\", &amp;n, &amp;c); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", p + i, w + i); sum[i] = sum[i - 1] + w[i]; &#125; f[c][c][0] = f[c][c][1] = 0; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j][0] = min(f[i + 1][j][0] + (p[i + 1] - p[i]) * calc(i + 1, j), f[i + 1][j][1] + (p[j] - p[i]) * calc(i + 1, j)); f[i][j][1] = min(f[i][j - 1][0] + (p[j] - p[i]) * calc(i, j - 1), f[i][j - 1][1] + (p[j] - p[j - 1]) * calc(i, j - 1)); &#125; printf(\"%d\\n\", min(f[1][n][0], f[1][n][1])); return 0; &#125; [USACO07OPEN] Cheapest Palindrome G Portal. 设 f(i,j)f(i,j)f(i,j) 代表完成 [i,j][i,j][i,j] 的最小代价，然后分类转移。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m; char s[2005]; int f[2005][2005]; int a[30], b[30]; int main(void) &#123; cin >> n >> m; scanf(\"%s\", s + 1); for (int i = 1; i &lt;= n; ++i) &#123; char x; int y, z; cin >> x >> y >> z; a[x - 'a'] = y, b[x - 'a'] = z; &#125; memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= m; ++i) f[i][i] = 0, f[i][i - 1] = 0; f[m + 1][m] = 0; for (int len = 2; len &lt;= m; ++len) for (int i = 1; i &lt;= m - len + 1; ++i) &#123; int j = i + len - 1; if (s[i] == s[j]) f[i][j] = min(f[i][j], f[i + 1][j - 1]); f[i][j] = min(f[i][j], f[i][j - 1] + min(b[s[j] - 'a'], a[s[j] - 'a'])); f[i][j] = min(f[i][j], f[i + 1][j] + min(b[s[i] - 'a'], a[s[i] - 'a'])); &#125; printf(\"%d\\n\", f[1][m]); return 0; &#125; [HNOI2010] 合唱队 Portal. 设 f(i,j)f(i,j)f(i,j) 表示形成理想队列中区间 [i,j][i,j][i,j] 的方案数？但是这样我们不知道上一个人是谁，那么就设 f(i,j,0)f(i,j,0)f(i,j,0) 代表上一个人从左边加，f(i,j,1)f(i,j,1)f(i,j,1) 代表上一个人从右边加，初始条件仅设其中一个为 111 即可（否则会算重）。 查看代码 #include &lt;bits/stc++.h> using namespace std; const int MOD = 19650827; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar(); return x; &#125; int n; int a[1005]; int f[1005][1005][2]; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); f[i][i][0] = 1; &#125; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (a[i] &lt; a[i + 1]) f[i][j][0] += f[i + 1][j][0]; if (a[i] &lt; a[j]) f[i][j][0] += f[i + 1][j][1]; f[i][j][0] %= MOD; if (a[j] > a[i]) f[i][j][1] += f[i][j - 1][0]; if (a[j] > a[j - 1]) f[i][j][1] += f[i][j - 1][1]; f[i][j][1] %= MOD; &#125; cout &lt;&lt; (f[1][n][0] + f[1][n][1]) % MOD &lt;&lt; endl; return 0; &#125; [UVA1336] Fixing the Great Wall Portal. 和“关路灯”很相似。这种不知到当前的时间，而在转移时将“未来增加的费用”计算好，然后“时间归零”的技巧很有用。 查看代码 #include &lt;bits/stdc++.h> using namespace std; int n, x; double v; double f[1005][1005][2]; // k = 0 在 i, k = 1 在 j int s[1005]; struct mouse &#123; int x, c, d; mouse(int x = 0, int c = 0, int d = 0) : x(x), c(c), d(d) &#123;&#125; bool operator &lt; (const mouse &amp;a) const &#123; return x &lt; a.x; &#125; &#125; a[1005]; int g(int x, int y) &#123; return s[n] - (s[y] - s[x - 1]); &#125; int main(void) &#123; // 计算未发生，但是肯定会发生的代价，然后“时钟归零” while (scanf(\"%d%lf%d\", &amp;n, &amp;v, &amp;x) == 3 &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d%d\", &amp;a[i].x, &amp;a[i].c, &amp;a[i].d); a[++n] = mouse(x); sort(a + 1, a + n + 1); int t, sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].x == x) t = i; s[i] = s[i - 1] + a[i].d; sum += a[i].c; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) f[i][j][0] = f[i][j][1] = 1e9; f[t][t][0] = f[t][t][1] = 0; for (int len = 2; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j][0] = min(f[i + 1][j][0] + (a[i + 1].x - a[i].x) / v * g(i + 1, j), f[i + 1][j][1] + (a[j].x - a[i].x) / v * g(i + 1, j)); f[i][j][1] = min(f[i][j - 1][0] + (a[j].x - a[i].x) / v * g(i, j - 1), f[i][j - 1][1] + (a[j].x - a[j - 1].x) / v * g(i, j - 1)); &#125; printf(\"%d\\n\", int(sum + min(f[1][n][0], f[1][n][1]))); &#125; return 0; &#125; [USACO19DEC] Greedy Pie Eaters P Portal. 考虑计算 f(i,j)f(i,j)f(i,j) 为吃掉 [i,j][i,j][i,j] 的派所能得到的最大体重。那么有 f(i,j)=max⁡{f(i,k−1)+f(k+1,j)+p(i,j,k)}f(i,j)=\\max\\{f(i,k-1)+f(k+1,j)+p(i,j,k)\\}f(i,j)=max{f(i,k−1)+f(k+1,j)+p(i,j,k)}，其中 p(i,j,k)p(i,j,k)p(i,j,k) 代表区间 [i,j][i,j][i,j] 中 kkk 未被吃掉，现在吃了获得的最大体重，可以通过区间 DP 预处理得到。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, m; int w[90005], l[50005], r[50005]; int f[305][305], g[305][305][305]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int w, l, r; scanf(\"%d%d%d\", &amp;w, &amp;l, &amp;r); for (int j = l; j &lt;= r; ++j) g[l][r][j] = w; &#125; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt;= j; ++k) g[i][j][k] = max(&#123;g[i][j][k], g[i + 1][j][k], g[i][j - 1][k]&#125;); &#125; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt; j; ++k) f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j]); for (int k = i; k &lt;= j; ++k) f[i][j] = max(f[i][j], f[i][k - 1] + f[k + 1][j] + g[i][j][k]); &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; [CSP-S 2021] 括号序列 Portal. 大型分类讨论，注意不要算重，有许多种方法可以解决这个问题：细分状态或者对特别处理算重的情况。对于读到这里的读者来说应该能完成这道题。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; const int MOD = 1000000007; int n, k; char s[505]; i64 f[505][505][6]; // f[0]: ** // f[1]: (..) // f[2]: (..)** // f[3]: (..)..(..) 包含 1 // f[4]: **(..) // f[5]: **(..)** 包含 0 int main(void) &#123; scanf(\"%d%d%s\", &amp;n, &amp;k, s + 1); for (int i = 1; i &lt;= n; ++i) f[i][i-1][0] = 1; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; if (len &lt;= k) f[i][j][0] = f[i][j-1][0] &amp;&amp; (s[j] == '*' || s[j] == '?'); if (len >= 2) &#123; if ((s[i] == '(' || s[i] == '?') &amp;&amp; (s[j] == ')' || s[j] == '?')) f[i][j][1] = (f[i+1][j-1][0] + f[i+1][j-1][2] + f[i+1][j-1][3] + f[i+1][j-1][4]) % MOD; for (int k = i; k &lt; j; ++k) &#123; f[i][j][2] = (f[i][j][2] + f[i][k][3] * f[k+1][j][0]) % MOD; f[i][j][3] = (f[i][j][3] + (f[i][k][2]+f[i][k][3]) * f[k+1][j][1]) % MOD; f[i][j][4] = (f[i][j][4] + (f[i][k][4]+f[i][k][5]) * f[k+1][j][1]) % MOD; f[i][j][5] = (f[i][j][5] + f[i][k][4] * f[k+1][j][0]) % MOD; &#125; &#125; f[i][j][5] = (f[i][j][5] + f[i][j][0]) % MOD; f[i][j][3] = (f[i][j][3] + f[i][j][1]) % MOD; &#125; printf(\"%lld\\n\", f[1][n][3]); return 0; &#125; 高维 DP 高维 DP。 [SDOI2010] 地精部落 Portal.一座长度为 nnn 的山脉可分为从左到右的 nnn 段，每段有一个独一无二的高度 hih_ihi​，其中 hih_ihi​ 是 111 到 nnn 之间的正整数。这 nnn 段山脉每段都必须是一个山峰或者山谷，问这样的山脉有多少种。答案对 ppp 取模。3≤N≤42003 \\le N \\le 42003≤N≤4200，P≤109P \\le 10^9P≤109。 设 f(i,j)f(i,j)f(i,j) 代表考虑前 iii 个数，第一个数是山顶，高度为 jjj 的方案数。当 jjj 与 j−1j-1j−1 不相邻的时候，两者位置可以交换，方案数是 f(i,j−1)f(i,j-1)f(i,j−1)；当相邻的时候，由于 jjj 是山峰，j−1j-1j−1 是山谷，这时我们将第 222 个数翻转成 i−(j−1)i-(j-1)i−(j−1)，这时候它就成了山峰，方案数就是 f(i−1,i−j+1)f(i-1,i-j+1)f(i−1,i−j+1)。 由于我们假设了第一个数是山顶，所以还有第一个数是山谷的答案，答案要乘 222。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, p; int f[2][4205]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); f[0][2] = 1; for (int i = 3; i &lt;= n; ++i) for (int j = 2; j &lt;= i; ++j) f[i &amp; 1][j] = (f[i &amp; 1][j - 1] + f[(i - 1) &amp; 1][i - j + 1]) % p; uint ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + f[n &amp; 1][i] * 2) % p; printf(\"%u\\n\", ans); return 0; &#125; 线性 DP 的综合应用 这里的题难度会稍大。 [UVA10559] Blocks Portal. 预处理颜色段，然后定义 f(l,r,k)f(l,r,k)f(l,r,k) 代表消除 [l,r][l,r][l,r]，且 rrr 右边还有 kkk 个与 rrr 颜色相同的木块。那么要么是消 rrr，要么是在 [l,r−1)[l,r-1)[l,r−1) 中有与 rrr 相同的颜色，消完中间段之后将两段颜色合并再进行消除。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, a[205]; int tot, len[205], color[205]; int f[205][205][205]; int dfs(int l, int r, int k) &#123; if (f[l][r][k]) return f[l][r][k]; if (l == r) return f[l][r][k] = (len[r] + k) * (len[r] + k); // 只有一段，只能消除 f[l][r][k] = dfs(l, r - 1, 0) + (len[r] + k) * (len[r] + k); // 先消除 [l, r - 1] for (int i = l; i &lt; r - 1; ++i) // 在 [l, r - 2] 中寻找与 r 相同的颜色 // 先消除 [i + 1, r - 1] // 然后 [l, i] 就会与 [r, r + len[r] + k] 合并，可以直接消除 if (color[i] == color[r]) f[l][r][k] = max(f[l][r][k], dfs(l, i, len[r] + k) + dfs(i + 1, r - 1, 0)); return f[l][r][k]; &#125; int main(void) &#123; int T, kase = 0; scanf(\"%d\", &amp;T); while (T--) &#123; memset(f, 0, sizeof(f)); tot = 0; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] == a[i - 1]) ++len[tot]; else ++tot, len[tot] = 1, color[tot] = a[i]; &#125; n = tot; printf(\"Case %d: %d\\n\", ++kase, dfs(1, n, 0)); &#125; return 0; &#125; [THUSC2016] 成绩单 Portal.期末考试结束了，班主任 L 老师要将成绩单分发到每位同学手中。L 老师共有 nnn 份成绩单，按照编号从 111 到 nnn 的顺序叠放在桌子上，其中编号为 iii 的的成绩单分数为 WiW_iWi​。成绩单是按照批次发放的。发放成绩单时，L 老师会从当前的一叠成绩单中抽取连续的一段，让这些同学来领取自己的成绩单。当这批同学领取完毕后，L 老师再从剩余的成绩单中抽取连续的一段，供下一批同学领取。经过若干批次的领取后，成绩单将被全部发放到同学手中。对于一个分发成绩单的方案，我们定义其代价为：a×k+b×∑i=1k(maxi−mini)2a \\times k + b \\times \\sum_{i = 1} ^ k (max_i - min_i) ^ 2a×k+b×i=1∑k​(maxi​−mini​)2其中 kkk 是分发的批次数，对于第 iii 披分发的成绩单，maximax_imaxi​ 是最高分数，minimin_imini​ 是最低分数，aaa 和 bbb 是给定的评估参数。现在，请你帮助 L 老师找到代价最小的分发成绩单的方案，并将这个最小的代价告诉 L 老师。当然，分发成绩单的批次数 kkk 是你决定的。n≤50n\\le 50n≤50。 设 g(i,j)g(i,j)g(i,j) 代表区间 [i,j][i,j][i,j] 全部取走的答案。初始时 g(i,i)=ag(i,i)=ag(i,i)=a，答案是 g(1,n)g(1,n)g(1,n)。现在考虑转移，我们设 f(i,j,x,y)f(i,j,x,y)f(i,j,x,y) 代表区间 [i,j][i,j][i,j] 中所有成绩单（可以有发走的）中的最大值为 yyy，最小值为 xxx 时，发放的最小代价，那么： g(i,j)=min⁡{f(i,j,x,y)+a+b×(x−y)2}g(i,j)=\\min\\{f(i,j,x,y)+a+b\\times (x-y)^2\\} g(i,j)=min{f(i,j,x,y)+a+b×(x−y)2} 显然在 DP 之前需要先离散化，现在考虑 fff 如何求解。 fff 可以是 [l,r−1][l,r-1][l,r−1] 和 rrr 合并得来的，也可以是从 f(i,k,x,y)+g(k+1,j)f(i,k,x,y)+g(k+1,j)f(i,k,x,y)+g(k+1,j) 转移过来的。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> #define rep(i, l, r) for (int i = l; i &lt;= r; ++i) using namespace std; inline int F(int x) &#123; return x * x; &#125; int n, a, b; int w[55], l[55]; int f[55][55][55][55], g[55][55]; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", w + i), l[i] = w[i]; sort(l + 1, l + n + 1); int m = unique(l + 1, l + n + 1) - (l + 1); for (int i = 1; i &lt;= n; ++i) w[i] = lower_bound(l + 1, l + m + 1, w[i]) - l; memset(f, 0x3f, sizeof(f)); memset(g, 0x3f, sizeof(g)); for (int i = 1; i &lt;= n; ++i) f[i][i][w[i]][w[i]] = 0, g[i][i] = a; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; rep(x, 1, m) rep(y, x, m) &#123; f[i][j][min(x, w[j])][max(y, w[j])] = min(f[i][j][min(x, w[j])][max(y, w[j])], f[i][j - 1][x][y]); for (int k = i; k &lt; j; ++k) f[i][j][x][y] = min(f[i][j][x][y], f[i][k][x][y] + g[k + 1][j]); &#125; rep(x, 1, m) rep(y, x, m) g[i][j] = min(g[i][j], f[i][j][x][y] + a + b * F(l[y] - l[x])); &#125; printf(\"%d\\n\", g[1][n]); return 0; &#125; [POI2015] Myjnie Portal.有 n(n≤50)n(n\\le 50)n(n≤50) 家洗车店从左往右排成一排，每家店都有一个正整数价格 pip_ipi​。有 m(m≤4000)m(m\\le 4000)m(m≤4000) 个人要来消费，第 iii 个人会驶过第 aia_iai​ 个开始一直到第 bib_ibi​ 个洗车店，且会选择这些店中最便宜的一个进行一次消费。但是如果这个最便宜的价格大于 cic_ici​，那么这个人就不洗车了。请给每家店指定一个价格，使得所有人花的钱的总和最大。 先将 ccc 离散化，然后考虑 f(i,j,k)f(i,j,k)f(i,j,k) 代表考虑 [i,j][i,j][i,j] 的洗车间，它们当中的最小消费额大于等于 kkk。初始时 f(i,j,k)=f(i,j,k+1)f(i,j,k)=f(i,j,k+1)f(i,j,k)=f(i,j,k+1) 转移的时候很简单： f(i,j,k)=f(i,j,k+1),f(i,j,k)=max⁡{f(i,t−1,k)+f(t+1,j,k)+c}f(i,j,k)=f(i,j,k+1),\\\\ f(i,j,k)=\\max\\{f(i,t-1,k)+f(t+1,j,k)+c\\} f(i,j,k)=f(i,j,k+1),f(i,j,k)=max{f(i,t−1,k)+f(t+1,j,k)+c} 其中 ccc 代表满足 i≤a≤t≤b≤ji\\le a\\le t\\le b\\le ji≤a≤t≤b≤j 的人的个数，这个可以在枚举 kkk 的时候预处理。需要输出方案，在转移的时候需要记录当前这个状态的最小消费额和分割点，然后 dfs 输出，分割点的答案记录为最小消费额。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, m; int a[4005], b[4005], c[4005], l[4005]; int f[55][55][4005]; // 最小值大于等于 k int cnt[55][55]; pair&lt;int, int> p[55][55][4005]; int ans[55]; void dfs(int i, int j, int k) &#123; if (i > j) return; pair&lt;int, int> it = p[i][j][k]; ans[it.second] = l[it.first]; dfs(i, it.second - 1, it.first); dfs(it.second + 1, j, it.first); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", a + i, b + i, c + i), l[i] = c[i]; sort(l + 1, l + m + 1); int t = unique(l + 1, l + m + 1) - (l + 1); for (int i = 1; i &lt;= m; ++i) c[i] = lower_bound(l + 1, l + t + 1, c[i]) - l; for (int op = t; op >= 1; --op) &#123; for (int k = 1; k &lt;= m; ++k) if (c[k] == op) &#123; for (int i = 1; i &lt;= a[k]; ++i) for (int j = b[k]; j &lt;= n; ++j) ++cnt[i][j]; &#125; for (int len = 1; len &lt;= n; ++len) for (int i = 1; i &lt;= n - len + 1; ++i) &#123; int j = i + len - 1; f[i][j][op] = f[i][j][op + 1]; p[i][j][op] = p[i][j][op + 1]; for (int k = i; k &lt;= j; ++k) &#123; int v = f[i][k - 1][op] + f[k + 1][j][op] + (cnt[i][j] - cnt[i][k - 1] - cnt[k + 1][j]) * l[op]; if (v > f[i][j][op]) &#123; f[i][j][op] = v; p[i][j][op] = &#123;op, k&#125;; &#125; &#125; if (p[i][j][op].first == 0) p[i][j][op] = &#123;op, i&#125;; &#125; &#125; printf(\"%d\\n\", f[1][n][1]); dfs(1, n, 1); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", ans[i]); putchar('\\n'); return 0; &#125; 小结 区间 DP 和高维 DP 是线性结构上比较难的一类 DP，但只要多写题，也不是什么难事。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"算法竞赛/学习笔记/动态规划","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"线性 DP","slug":"线性-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7-DP/"},{"name":"区间 DP","slug":"区间-DP","permalink":"https://james1badcreeper.github.io/tags/%E5%8C%BA%E9%97%B4-DP/"}]},{"title":"动态规划基础","slug":"notes/DP/basic-dp","date":"2022-07-25T00:00:00.000Z","updated":"2022-08-11T00:00:00.000Z","comments":true,"path":"cafcfd0d/","link":"","permalink":"https://james1badcreeper.github.io/cafcfd0d/","excerpt":"动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20 世纪 50 年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划问世以来，在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便。所以动态规划不仅在 OI 中应用广泛，在生活实际同样应用广泛。本文将引导你学习简单的动态规划。","text":"动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20 世纪 50 年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划问世以来，在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便。所以动态规划不仅在 OI 中应用广泛，在生活实际同样应用广泛。本文将引导你学习简单的动态规划。 更新日志 2022/08/08完成了预定的所有内容。2022/08/11增补了 LIS 的 O(nlog⁡n)O(n\\log n)O(nlogn) 算法及其变形。 为方便，接下来我们均用 DP 指代动态规划。 引子 我们先来看这样一个问题。 james1 要写一封恰好有 nnn 个字的入团申请书，但由于 james1 非常懒（假的），所以他会在一开始有 111 个字的文稿里进行以下两种操作： 写字：在文稿末尾写 111 个字，就是说如果文稿有 kkk 个字，那么写字后文稿会有 k+1k+1k+1 个字。 复读：将写完这文稿复制，粘贴到文稿末尾，就是说如果文稿有 kkk 个字，那么复制后文稿会有 k×2k \\times 2k×2 个字。 问 james1 最少要进行多少次操作，才能完成这封入团申请书？ 真实情况下入团申请书可别这么写，否则入不进去别找我。 贪心的末日 感觉这道题长得很像贪心，然而一般人写的贪心是错的。 为什么说是一般人呢？因为一般人都不会倒着想题。如果正着贪心，因为是恰好 nnn 个字，比如我要写 313131，那么我会这样 1→2→4→8→16→17→18→...→311 \\rightarrow 2 \\rightarrow 4 \\rightarrow 8 \\rightarrow 16 \\rightarrow 17 \\rightarrow 18 \\rightarrow ... \\rightarrow 311→2→4→8→16→17→18→...→31 耗费了大量的操作，这样显然不是最优。 决策 既然贪心不行，那么我们则么办呢？ james1 显然拥有“选择的权利”。 每一秒钟，他要么决定“写字”，要么决定“复读”。 james1 写完文稿的过程，可以理解成一系列决策：最开始是 111 个字，通过一次次决策，文稿变得越来越长，最终达到 nnn 个字。 这里列出了两种凑出 101010 个字的方案。第一种步数更少，所以是优秀的方案；后者是不优的方案。 在我们手上有 444 个字的时候，我们该如何选择？ 然而，我们很难以在“手上有 444 个字”的情况下，选出“接下来是变成 555 个字还是 888 个字”。这需要我们有预判未来的能力！ 这显然不是正常人能做到的，所以我们要换一种思维方式。 子问题的拆分 我们来考虑另一种思维。现在我们目标是凑出 nnn 个字，我们尝试先决定“最后一 步是写字还是复读”（某人：终于学会倒着想了）。 这个问题似乎简单很多。首先，如果 nnn 是奇数，那么我们没得选，它只能是写字之后的结果；如果 nnn 是偶数，只要我们知道“凑出 n−1n-1n−1 个字的时间”和“凑出 n2\\cfrac{n}{2}2n​ 个字的时间”，就可以选出耗时更短的方案。具体而言： cost(n)={cost(n−1)+1,n 是奇数,min{cost(n2)+1, cost(n−1)+1},n 是偶数.cost(n)=\\begin{cases} cost(n-1)+1 &amp; ,n \\text{ 是奇数} ,\\\\ \\text{min}\\{cost(\\cfrac{n}{2})+1,~cost(n-1)+1\\} &amp; ,n \\text{ 是偶数}. \\end{cases} cost(n)=⎩⎨⎧​cost(n−1)+1min{cost(2n​)+1, cost(n−1)+1}​,n 是奇数,,n 是偶数.​ 例如，在 n=10n=10n=10 的时候决策，如果知道“凑出 555 的代价是 333”以及“凑出 999 的代价是 888”，我们就会选择“从 555 复读得到 101010”，代价是 3+1=43+1=43+1=4。 实现 根据刚才推出的公式，实现变得非常简单： int n, cost[105]; int main(void) &#123; scanf(\"%d\", &amp;n); cost[1] = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (n % 2 == 1) cost[i] = cost[i-1]+1; else cost = min(cost[i/2]+1, cost[i-1]+1); printf(\"cost[%d] = %d\\n\", i, cost[i]); &#125; &#125; 可以发现就是对着刚才的公式照抄，时空复杂度均为 O(n)\\mathcal{O}(n)O(n)。 优化 然而这东西不是最优，之前说了，正着贪心是错的，但倒着贪心是对的。 但为什么倒着贪心是对的？很简单，因为 cost(n2)+1⩽cost(n−1)+1cost(\\cfrac{n}{2})+1\\leqslant cost(n-1)+1cost(2n​)+1⩽cost(n−1)+1 恒成立。 代码更简单了： int ans = 0; while (n != 1) &#123; if (n % 2 == 1) --n; else n /= 2; ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; 时间复杂度 Θ(log⁡n)\\Theta(\\log n)Θ(logn)，空间 O(1)\\mathcal{O}(1)O(1) 。 状态和子问题 我们刚刚谈到了“拆分子问题”，就是我们现在需要回答一个大问题（凑 nnn 个字）。 我们先解决几个小问题（凑 n2\\cfrac{n}{2}2n​ 个字、凑 n−1n−1n−1 个字），把这些小问题的结论综合起来，获得大问题的答案。DP 中，一般把我们面对某个问题的情景也叫做“状态”。例如我们手上有 kkk 个字，这是一个状态。我们可以作出“复读”的决策，转移到 2k2k2k 这个状态；也可以作出“写字”的决策，转移到 k+1k+1k+1 这个状态。 引入名词是为了以后能更加简便地描述算法。 状态转移方程 cost(n)={cost(n−1)+1,n 是奇数,min{cost(n2)+1, cost(n−1)+1},n 是偶数.cost(n)=\\begin{cases} cost(n-1)+1 &amp; ,n \\text{ 是奇数} ,\\\\ \\text{min}\\{cost(\\cfrac{n}{2})+1,~cost(n-1)+1\\} &amp; ,n \\text{ 是偶数}. \\end{cases} cost(n)=⎩⎨⎧​cost(n−1)+1min{cost(2n​)+1, cost(n−1)+1}​,n 是奇数,,n 是偶数.​ 刚才这个式子便是状态转移方程。 硬币问题 Luogu B3635.今有三种面额的钱币，111、555 和 111111。现在要凑出 nnn 元钱，问最少需要多少张钱才能达到目的？ 可以证明，贪心是错误的，我们需要用 DP 来解决这道题。 状态的设计 显然，f(i)f(i)f(i) 表示凑出 iii 元最少需要多少张钱。 状态的转移 除了刚才的方法，我们还将介绍一种新的方法。 传统方法（填表法） 根据之前的经验，我们可以设计出状态转移方程： f(i)=min⁡{f(i−1)+1, f(i−5)+1, f(i−11)+1}f(i)=\\min\\{f(i-1)+1,~f(i-5)+1,~f(i-11)+1\\} f(i)=min{f(i−1)+1, f(i−5)+1, f(i−11)+1} 程序也很好写： int n, f[1005]; memset(f, 0x3f, sizeof(f)); f[0] = 0; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; if(i-1 >= 0) f[i] = min(f[i], f[i-1] + 1); if(i-5 >= 0) f[i] = min(f[i], f[i-5] + 1); if(i-11 >= 0) f[i] = min(f[i], f[i-11] + 1); printf(\"f[%d] = %d\\n\", i, f[i]); &#125; 像这样，对于每个状态 iii，计算 f(i)f(i)f(i) 的方式，我们称之为“填表法”，或形象地称之为“我从哪里来”，也就是 pull 型的转移。 刷表法 既然有“我从哪里来”，那么必定有“我到哪里去”，也就是刷表法，push 型的转移，即对于每个状态 iii，更新 f(i)f(i)f(i) 所影响的状态，对于此题而言： int n, f[1015]; // 想想这里为什么要把空间开大 // 初始化和读入略 for (int i = 0; i &lt;= n; ++i) // 从 0 开始 &#123; // 更新所影响的状态 f[i+1] = min(f[i+1], f[i] + 1); f[i+5] = min(f[i+5], f[i] + 1); f[i+11] = min(f[i+11], f[i] + 1); printf(\"f[%d] = %d\\n\", i, f[i]); &#125; 通常我们不把刷表法的式子称作状态转移方程，因为它只是一个更新公式。 一般地（嗯，真有不一般地），填表法和刷表法可以互相转化，只是一种比较容易些，另一种比较难写。需根据实际情况判断用什么方法。 解的打印 虽然大多数题目都不要求打印解，但我们还是得会。 有哪位神仙知道怎么做嘛？ 我不会，但我一定是对的。 —— 搜索 好，那我们来试试吧！ 比如我们用 print_ans(n) 来打印凑 nnn 块钱时的解。 print_ans(n) 从哪里来？当然是从 print_ans(n-1)、print_ans(n-5) 或 print_ans(n-11) 来。 那么是这三个中的那个呢？很简单，我们可以根据 f 数组来判断。 像这样： void print_ans(int x) &#123; if (x >= 1 &amp;&amp; f[x] == f[x-1] + 1) //f[x] == f[x-1] + 1 判断我们递推时是不是这么干的 &#123; printf(\"1 \"); print_ans(x-1); &#125; else if (x >= 5 &amp;&amp; f[x] == f[x-5] + 1) &#123; printf(\"5 \"); print_ans(x-5); &#125; else if (x >= 11 &amp;&amp; f[x] == f[x-11] + 1) &#123; printf(\"11 \"); print_ans(x-11); &#125; &#125; 记忆化搜索 斐波那契数列。输出斐波那契数列的第 nnn 项。（1⩽n⩽1071\\leqslant n \\leqslant 10^71⩽n⩽107） 这里我们用递归来实现： int fib(int n) &#123; if(n &lt;= 2) return 1; return fib(n-2) + fib(n-1); &#125; int main(void) &#123; int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", fib(n)); return 0; &#125; 单说这份程序，谁都写得出来，但是，它很慢！慢到什么程度？ 因为斐波那契数列是指数级的，所以它的时间复度是 Θ(2n)\\Theta (2^n)Θ(2n)，所以在 n=107n=10^7n=107 的时候，算到宇宙毁灭它也算不完。 可为什么它这么慢？很简单，重复计算。比如我要算 fib(10)fib(10)fib(10)，想知道 fib(10)fib(10)fib(10)，我需要知道 fib(8)fib(8)fib(8) 和 fib(9)fib(9)fib(9)。而为此需要知道 fib(6)fib(6)fib(6)、fib(7)fib(7)fib(7) 和 fib(8)fib(8)fib(8)，而 fib(7)fib(7)fib(7) 需要计算两次，如此看来，重复计算量是非常大的！ 那么我们加个数组记录下来之前算的结果不就行了？像这样： int f[10000005]; bool vis[10000005]; int fib(int n) &#123; if(n &lt;= 2) return 1; if (vis[n]) return f[n]; vis[n] = 1; return f[n] = fib(n-2) + fib(n-1); &#125; int main(void) &#123; int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", fib(n)); return 0; &#125; 为什么使用 visvisvis 数组？只是因为斐波那契数列每一项都是正的，所以有的人会通过 f[i]=−1f[i]=-1f[i]=−1 的方式来判断 iii 没访问过，但有负数就行不通了，所以采用 visvisvis 这种更加通用的方式。 这种搜索时记录以前答案的形式，称之为记忆化搜索。 DP 解题思路 我们通过两道题目感受一下 DP 的解题思路。 [IOI1994] 数字三角形 Portal. 题面 观察下面的数字金字塔。写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 在上面的样例中,从 7→3→8→7→57 \\to 3 \\to 8 \\to 7 \\to 57→3→8→7→5 的路径产生了最大。 设计状态 用一个状态来描述目前需要求解的情景，这个过程称为设计状态。 本题可以这样设计状态：f(x,y)f(x,y)f(x,y) 表示“走到 (x,y)(x,y)(x,y) 的位置，能获取的最大收益”。注意，走到第 rrr 行的任意一个都可以。 设计转移 设计完状态之后，我们要写出状态转移方程（或更新公式）。这个步骤叫做“设计转移”。这里采用的是”刷表法”。 由于状态 (x,y)(x,y)(x,y) 要么走到下面的 (x+1,y)(x+1, y)(x+1,y) 走过来，要么从右下角 (x+1,y+1)(x+1,y+1)(x+1,y+1) 走过来。所以可以这样： f(x+1,y)=max⁡{f(x+1,y),f(x,y)+a[x+1][y]}f(x+1,y+1)=max⁡{f(x+1,y+1),f(x,y)+a[x+1][y+1]}f(x+1,y)=\\max\\{f(x+1,y),f(x,y)+a[x+1][y]\\} \\\\ f(x+1,y+1)=\\max\\{f(x+1,y+1),f(x,y)+a[x+1][y+1]\\}f(x+1,y)=max{f(x+1,y),f(x,y)+a[x+1][y]}f(x+1,y+1)=max{f(x+1,y+1),f(x,y)+a[x+1][y+1]} 实现 注意答案要取最大值即可。 #include &lt;iostream> #include &lt;cstdio> using namespace std; int r; int a[1005][1005], f[1005][1005]; int main(void) &#123; scanf(\"%d\", &amp;r); for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= i; ++j) scanf(\"%d\", &amp;a[i][j]); f[1][1] = a[1][1]; for (int i = 1; i &lt; r; ++i) for (int j = 1; j &lt;= i; ++j) &#123; f[i + 1][j] = max(f[i + 1][j], f[i][j] + a[i + 1][j]); f[i + 1][j + 1] = max(f[i + 1][j + 1], f[i][j] + a[i + 1][j + 1]); &#125; int ans = 0; for (int i = 1; i &lt;= r; ++i) ans = max(ans, f[r][i]); printf(\"%d\\n\", ans); return 0; &#125; 用 dfs 解决 我们来看： int dfs(int x, int y) // 代表从 [x,y] 出发 &#123; if (x == n) return a[x][y]; return max(dfs(x + 1, y), dfs(x + 1, y + 1)) + a[x][y]; &#125; 还要加上记忆化： int g[1005][1005]; // 先执行 memset(g, 0xff, sizeof(g)); int dfs(int x, int y) // 代表从 [x,y] 出发 &#123; if (g[x][y] != -1) return g[x][y]; if (x == n) return g[x][y] = a[x][y]; return g[x][y] = max(dfs(x + 1, y), dfs(x + 1, y + 1)) + a[x][y]; &#125; 其实这样是定义了状态：f(x,y)f(x,y)f(x,y) 代表从 (x,y)(x,y)(x,y) 出发。转移方程为：f(x,y)=max(f(x+1,y),f(x+1,y+1))+a[x][y]f(x,y)=max(f(x + 1, y), f(x + 1, y + 1)) + a[x][y]f(x,y)=max(f(x+1,y),f(x+1,y+1))+a[x][y]。考虑到依赖性的问题，所以要倒序 DP。 #include &lt;iostream> #include &lt;cstdio> using namespace std; int r; int a[1005][1005], f[1005][1005]; int main(void) &#123; scanf(\"%d\", &amp;r); for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= i; ++j) scanf(\"%d\", &amp;a[i][j]); for (int i = 1; i &lt;= r; ++i) f[r][i] = a[r][i]; for (int i = r - 1; i >= 1; --i) for (int j = 1; j &lt;= i; ++j) f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]; printf(\"%d\\n\", f[1][1]); return 0; &#125; 最大子段和 Portal. 设 f(i)f(i)f(i) 代表以 iii 结尾（必须含 iii）的最大子段和，那么有 f(i)=max⁡{f(i−1)+a[i],a[i]}f(i)=\\max\\{f(i-1)+a[i],a[i]\\}f(i)=max{f(i−1)+a[i],a[i]}。目标为 max⁡{f(i)}\\max\\{f(i)\\}max{f(i)}。 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, a[200005], f[200005], ans = -10005; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; f[i] = 0; scanf(\"%d\", &amp;a[i]); f[i] = max(f[i - 1] + a[i], a[i]); ans = max(f[i], ans); &#125; printf(\"%d\", ans); return 0; &#125; DP 二要素 DP 有二要素，最优子结构和无后效性。 最优子结构 大问题的最优解，一定是从小问题的最优解推出来的。比如硬币问题，我们只关心 f(15)f(15)f(15) 的最优解，从而推出依赖 f(15)f(15)f(15) 的 f(16)f(16)f(16)、f(20)f(20)f(20)、f(26)f(26)f(26) 的解（填表法）。 无后效性 现在的决策，只与过去的结果有关，而与过去的决策无关。这跟 DP 的本质很像，在每一个阶段根据以前的答案（不是决策）推出当前阶段的答案。为什么必须满足无后效性，我们来看： [NOIP2010 提高组] 乌龟棋。 啊，我知道了，我来设计状态，像这样：f(i)f(i)f(i) 表示走到位置 iii 能获得的最大分数。 But wait！注意这样我们不知道之前用了哪些爬行卡片，所以状态是有后效性的！换句话说，之前的决策会影响现在的结果。所以状态定义的不够好，无法转移。 可不就是不知道用了哪些卡片嘛！那我这么干：f(p,i,j,k,l)f(p,i,j,k,l)f(p,i,j,k,l) 代表走到第 ppp 个位置，用了卡片 1,2,3,41,2,3,41,2,3,4 分别 i,j,k,li,j,k,li,j,k,l 张。 实际上没必要，因为知道用了哪些卡片就知道走到那个位置了，所以只需定义 f(i,j,k,l)f(i,j,k,l)f(i,j,k,l)。因为本题数据范围很小，所以不会爆空间。 #include &lt;iostream> #include &lt;cstdio> #include &lt;cctype> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m; int a[355], b[5]; int dp[45][45][45][45]; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); while (m--) ++b[read()]; //每种卡牌的数量 dp[0][0][0][0] = a[1]; //这里使用填表法，当然，刷表法也是可以的 for (int i = 0; i &lt;= b[1]; ++i) for (int j = 0; j &lt;= b[2]; ++j) for (int k = 0; k &lt;= b[3]; ++k) for (int l = 0; l &lt;= b[4]; ++l) &#123; int c = i + j*2 + k*3+ l*4 + 1; //计算从 1 用这些卡牌走到了哪里 #define f dp[i][j][k][l] //简化代码的技巧 if (i != 0) f = max(f, dp[i-1][j][k][l] + a[c]); if (j != 0) f = max(f, dp[i][j-1][k][l] + a[c]); if (k != 0) f = max(f, dp[i][j][k-1][l] + a[c]); if (l != 0) f = max(f, dp[i][j][k][l-1] + a[c]); &#125; printf(\"%d\", dp[b[1]][b[2]][b[3]][b[4]]); return 0; &#125; 像这样，把引起后效性的因素直接加入到状态里，是处理后效性的手段之一（其它以后会见到），形象地称之为“打不过就加入”。 线性 DP 以上可以说都是 DP 的引子，真正的挑战现在才刚刚开始。 线性 DP 是指“具有线性阶段”的 DP，也包含具有多维度阶段的 DP，比如上一道例题“乌龟棋”。接下来我们来看更多的经典问题。 一维结构上的动态规划 它们的结构只有一维，但是并不是说状态一定只有一维。 [Luogu P1192] 台阶问题 Portal. 设 f(i)f(i)f(i) 代表跳到第 iii 级台阶的方案数，初始 f(0)=0f(0)=0f(0)=0，有 f(i)=∑max(0,i−k)i−1f(j)f(i)=\\sum_{max(0,i-k)}^{i-1}f(j)f(i)=∑max(0,i−k)i−1​f(j)。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 100003; int n, k; int f[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); f[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = max(i - k, 0); j &lt; i; ++j) f[i] = (f[i] + f[j]) % MOD; printf(\"%d\\n\", f[n]); return 0; &#125; 最长上升子序列 最长上升子序列（Longest Increasing Subsequence，LIS）问题：给定一个长度为 NNN 的序列，求最长上升子序列，即这个长度为 M(M≤N)M(M \\le N)M(M≤N) 的子序列 BBB 满足 ∀i∈[1,M),Bi&lt;Bi+1\\forall i \\in [1,M), B_i &lt;B_{i+1}∀i∈[1,M),Bi​&lt;Bi+1​。子序列指在原序列中任意删掉几个数（可以是 000 个数）所得到的序列。注意，这里是严格上升。 你可以在 POJ2533 提交这道题。 怎么求呢？设 f[i]f[i]f[i] 为 iii 结尾的 LIS 长度，那么可以设计出转移：f[i]=max⁡{f[j]+1},0≤j&lt;i,Aj&lt;Aif[i] = \\max\\{f[j]+1\\}, 0\\le j &lt; i,A_j&lt; A_if[i]=max{f[j]+1},0≤j&lt;i,Aj​&lt;Ai​。 代码很简单： int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = 1; // 有时候这一步是必要的（当求的不是最长上升而是最长不升之类的）， // 如果求的是最长上升，f[i] 必定可以在 j = 0 时取到 1 // 但是最长不升没有这种特点 // 为防止出错，建议何时都要把这一步写上去。 for (int j = 0; j &lt; i; ++j) if (a[i] > a[j]) f[i] = max(f[j] + 1, f[i]); ans = max(ans, f[i]); &#125; 但是这种做法太慢了，复杂度高达 O(n2)O(n^2)O(n2)，还有一种基于二分的优化到 O(nlog⁡n)O(n\\log n)O(nlogn) 的做法。 设 g(i)g(i)g(i) 表示 f(j)=if(j)=if(j)=i 时最小的 AjA_jAj​，也就是长度为 iii 的 LIS 的结尾数最小的值。可以证明 gig_igi​ 是递增的（子序列都变长了这玩意怎么可能减小），具有单调性。那么对于当前扫描的 f(i)f(i)f(i)，可以在之前已经找到的 ggg 中，找到第一个大于等于 AiA_iAi​ 的 g(k)g(k)g(k)，则此时 f(i)=kf(i)=kf(i)=k。 实际上是因为 LIS 问题要求 Ai&gt;AjA_i &gt; A_jAi​&gt;Aj​，我们用 AiA_iAi​ 去在 ggg 数组中检索，检索到了一个大于等于的下标，设这个下标对应的最小的 AjA_jAj​ 是 xxx，满足 x≥Ajx\\ge A_jx≥Aj​，由于 xxx 的最小性，xxx 的前一个数 yyy 一定满足 y&lt;Ajy&lt;A_jy&lt;Aj​。也就是说我们实际上要找满足 g[k′]&lt;Aig[k&#x27;]&lt;A_ig[k′]&lt;Ai​ 的最后一个下标 k′k&#x27;k′，就有 f(i)=k′+1f(i)=k&#x27;+1f(i)=k′+1，而 kkk 是第一个满足 g[k]≥Aig[k]\\ge A_ig[k]≥Ai​ 的，而我们的这种求法会使 k=k′+1k=k&#x27;+1k=k′+1，也就有了 f(i)=kf(i)=kf(i)=k。由于在查找的时候 g[k]≥Aig[k]\\ge A_ig[k]≥Ai​，而我们也要找最小的 AjA_jAj​，就将 g[k]g[k]g[k] 更新为 AiA_iAi​ 即可。 for (int i = 1; i &lt;= n; ++i) g[i] = INF; // INF 表示不存在 for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + n + 1, a[i]) - g; f[i] = k; g[k] = a[i]; &#125; [NOIP1999 普及组] 导弹拦截。 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是 ≤5×104\\le 5\\times 10^4≤5×104 的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。（个数 ≤105\\le 10^5≤105）。 第一问求的是最长不升子序列，非常简单。 第二问怎么做？想一想在导弹不停飞来的过程中，我们会尝试用第一套拦截系统去拦截这个导弹，但万一我们拦截不了，就只能再上一套拦截系统。这样需要上的拦截系统就是原序列的 LIS 长度。这就是 Dilworth 定理：将一个序列剖成若干个单调不升子序列的最小个数等于该序列最长上升子序列的个数。 这里分别给出 O(n2)O(n^2)O(n2) 和 O(nlog⁡n)O(n\\log n)O(nlogn) 的代码： // O(n^2) #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[100005]; int f1[100005], f2[100005]; int main(void) &#123; int x; while (cin >> x) a[++n] = x; int ans1 = 0, ans2 = 0; for (int i = 1; i &lt;= n; ++i) &#123; f1[i] = f2[i] = 1; for (int j = 0; j &lt; i; ++j) &#123; if (a[i] &lt;= a[j]) f1[i] = max(f1[j] + 1, f1[i]); if (a[i] > a[j]) f2[i] = max(f2[j] + 1, f2[i]); &#125; ans1 = max(ans1, f1[i]); ans2 = max(ans2, f2[i]); &#125; cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2 &lt;&lt; endl; return 0; &#125; // O(nlogn) #include &lt;iostream> #include &lt;algorithm> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; int a[100005], f[100005], g[100005]; int main(void) &#123; int x, ans = 0; while (cin >> x) a[++n] = x; memset(g, 0x3f, sizeof(g)); for (int i = n; i >= 1; --i) // 这里求的是最长不降子序列了，倒过来看就是最长不升子序列 &#123; int k = upper_bound(g + 1, g + n + 1, a[i]) - g; f[i] = k; g[k] = a[i]; ans = max(ans, f[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; memset(g, 0x3f, sizeof(g)); ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + n + 1, a[i]) - g; f[i] = k; g[k] = a[i]; ans = max(ans, f[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; [NOIP2004 提高组] 合唱队形。 这里的前半部分是最长上升子序列，后半部分是反着的最长上升子序列（因为我们的算法定义的是以 iii 结尾的最长上升子序列）。只需要分别计算，然后拼起来即可。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[105], f[105], g[105]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = 1; for (int j = 0; j &lt; i; ++j) if (a[i] > a[j]) f[i] = max(f[i], f[j] + 1); &#125; for (int i = n; i >= 1; --i) &#123; g[i] = 1; for (int j = n; j > i; --j) if (a[i] > a[j]) g[i] = max(g[i], g[j] + 1); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i] + g[i] - 1); printf(\"%d\\n\", n - ans); return 0; &#125; 上述内容可能稍显抽象，这里给出代码供背诵。 已为您折叠过长的内容 // 最长不升（非严格下降） memset(g, 0xbf, sizeof(g)); // 要找小于（等于）它的，初始化为负无穷 for (int i = 1; i &lt;= n; ++i) &#123; int k = upper_bound(g + 1, g + n + 1, a[i], greater&lt;int>()) - g; // 找到第一个 a[i] &lt;= g[k] f[i] = k; g[k] = a[i]; &#125; // 最长上升（严格上升） memset(g, 0x3f, sizeof(g)); for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + n + 1, a[i]) - g; // 找到第一个 a[i] >= g[k] f[i] = k; g[k] = a[i]; &#125; // 最长不降（非严格上升） memset(g, 0x3f, sizeof(g)); for (int i = 1; i &lt;= n; ++i) &#123; int k = upper_bound(g + 1, g + n + 1, a[i]) - g; // 找到第一个 a[i] > g[k] f[i] = k; g[k] = a[i]; &#125; // 最长下降（严格下降） memset(g, 0xbf, sizeof(g)); for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + n + 1, a[i], greater&lt;int>()) - g; // 找到第一个 a[i] &lt; g[k] f[i] = k; g[k] = a[i]; &#125; 经典结论 将一个序列改为非严格单调递增的，至少需要修改这个序列长度减去单调不降子序列的长度。 而严格单调递增呢？考虑 1 1 2 2 3 3，用序列长度减去它的 LIS 长度是错误的。因此构造 Bi=Ai−iB_i=A_i-iBi​=Ai​−i 可以将问题转化为非严格单调递增。 [CF713C] Sonya and Problem Wihtout a Legend.给定一个有 n(n≤106)n(n\\le 10^6)n(n≤106) 个正整数的数组，一次操作中，可以把任意一个元素加一或减一，求使得原序列严格递增的求最小操作次数。 先转化为要变成非严格单调递增。对于之前的数维护一个大根堆，如果当前的 aia_iai​ 比之前最大的数小，那么就将那个最大的数强行改为 aia_iai​。发现这样构造出来的答案一定不会更劣，但是是否合法呢？ 定义“微调”为在不改变花费的前提下改变数对的值。我们现在要找将 yyy 修改为 xxx 后是否会使得一个 yyy 前面的 zzz 满足 z&gt;yz&gt;yz&gt;y。 当 z&gt;yz&gt;yz&gt;y 时矛盾，那么考虑将 x,yx,yx,y 微调成 zzz，此时花费为 (y−z)+(z−x)=y−x(y-z)+(z-x)=y-x(y−z)+(z−x)=y−x，这样答案依然合法。 如何输出答案？令 bib_ibi​ 为 iii 时刻的堆顶，对 bbb 取一遍后缀最小值即可。 最长公共子序列 给定两个序列 AAA 和 BBB，求它们长度最大的公共子序列（即既是 AAA 的子序列也是 BBB 的子序列）的长度。如 1, 5, 2, 6, 8, 7 和 2, 3, 5, 6, 9, 8, 4 的最长公共子序列（Longest Common Subsequence，LCS）是 5, 6, 8 或 2, 6, 8。 怎么做呢？设 f(i,j)f(i,j)f(i,j) 为 A1,A2,⋯ ,AiA_1,A_2,\\cdots,A_iA1​,A2​,⋯,Ai​ 和 B1,B2,⋯ ,BjB_1,B_2,\\cdots,B_jB1​,B2​,⋯,Bj​ 的 LCS 长度，那么显然有 f(i,0)=f(0,i)=0f(i,0)=f(0,i)=0f(i,0)=f(0,i)=0，且： f(i,j)=max⁡{f(i−1,j),f(i,j−1),f(i−1,j−1)+1,A[i]=B[j].f(i,j) =\\max\\begin{cases} f(i-1,j),&amp;\\\\ f(i,j-1),&amp;\\\\ f(i-1,j-1)+1,&amp;A[i]=B[j]. \\end{cases} f(i,j)=max⎩⎨⎧​f(i−1,j),f(i,j−1),f(i−1,j−1)+1,​A[i]=B[j].​ 但是这样的时间复杂度太高了，我们需要用更快的方法。如下： 模板。 比如： A: 3 2 1 4 5 B: 1 2 3 4 5 我们把 A 重新编号成有序的： A: a b c d e B: c b a d e 这样标号之后 LCS 显然不变，因为相对元素没变，但是发现如果这个 LCS 想要成立，那么它必须是 A 的子序列，而 A 又是单调递增的，也就相当于是在 B 中的子序列是单调递增的，也就是要求 B 的 LIS。 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int n, ans; int p[100005], a[100005], f[100005], g[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); p[x] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf(\"%d\", &amp;x); a[i] = p[x]; &#125; memset(g, 0x3f, sizeof(g)); for (int i = 1; i &lt;= n; ++i) &#123; int k = lower_bound(g + 1, g + i + 1, a[i]) - g; f[i] = k; g[k] = a[i]; ans = max(ans, f[i]); &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1944] 最长括号匹配 Portal. 设 f(i)f(i)f(i) 为以 iii 结束的最长的括号匹配子串，那么 f(i)=f(i−1)+2+f(i−f(i−1)−2)f(i)=f(i-1)+2+f(i-f(i-1)-2)f(i)=f(i−1)+2+f(i−f(i−1)−2)。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; string s; int f[1000005]; int main(void) &#123; cin >> s; int ans = 0; for (int i = 1; i &lt; s.length(); ++i) &#123; if ((s[i] == ')' &amp;&amp; s[i - f[i-1] - 1] == '(') || (s[i] == ']' &amp;&amp; s[i - f[i-1] - 1] == '[')) &#123; f[i] = f[i-1] + 2 + (i - 2 - f[i-1] >= 0 ? f[i - 2 - f[i-1]] : 0); ans = max(ans, f[i]); &#125; &#125; if (ans == 0) return 0; for (int i = 1; i &lt; s.length(); ++i) if (f[i] == ans) &#123; for (int j = i - ans + 1; j &lt;= i; ++j) putchar(s[j]); break; &#125; putchar('\\n'); return 0; &#125; [NOIP2000 提高组] 乘积最大 Portal. 设计状态。设 f[i][j]f[i][j]f[i][j] 为前 iii 位（不含 iii）用 jjj 个乘号的答案，转移也很简单，f[i][j]=max⁡x&lt;i{f[i][j−1]×a[i,x)}f[i][j]=\\max\\limits_{x&lt;i}\\{f[i][j-1]\\times a_{[i,x)}\\}f[i][j]=x&lt;imax​{f[i][j−1]×a[i,x)​}。 P.S. 注意！这题的代码细节巨多，一定要按照工程标准编写这道题：处理字符串用左闭右开区间！ 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; string dp[45][8]; int n, k; string a; inline string get(int x, int y) // 获取子串 &#123; string res = \"\"; for (int i = x; i &lt; y; ++i) res = res + a[i]; return res; &#125; inline string choose(string x, string y) &#123; if (x.length() != y.length()) return x.length() > y.length() ? x : y; for (int i = 0; i &lt; x.length(); ++i) if (x[i] != y[i]) return x[i] > y[i] ? x : y; return x; &#125; int p[5005], q[5005], res[5005]; inline string mul(string x, string y) &#123; int lenx = x.length(), leny = y.length(); for (int i = lenx - 1; i >= 0; --i) p[lenx - i - 1] = x[i] - '0'; for (int i = leny - 1; i >= 0; --i) q[leny - i - 1] = y[i] - '0'; memset(res, 0, sizeof(res)); for (int i = 0; i &lt; lenx; ++i) for (int j = 0; j &lt; leny; ++j) res[i+j] += p[i] * q[j]; int len = lenx + leny; for (int i = 0; i &lt; len; ++i) &#123; res[i+1] += res[i] / 10; res[i] %= 10; &#125; while (res[len] == 0 &amp;&amp; len >= 0) --len; if (len == -1) return \"0\"; string ans = \"\"; for (int i = 0; i &lt;= len; ++i) ans = char(res[i] + '0') + ans; return ans; &#125; int main(void) &#123; cin >> n >> k >> a; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= k; ++j) dp[i][j] = \"0\"; for (int i = 1; i &lt;= n; ++i) // 长度为 1，用 0 个乘号 dp[i][0] = get(0, i); for (int i = 2; i &lt;= n; ++i) // 从长度为 2 开始计算 for (int j = 1; j &lt;= min(k, i - 1); ++j) // i 个数，最多 i-1 个乘号 for (int pos = j; pos &lt; i; ++pos) dp[i][j] = choose(dp[i][j], mul(dp[pos][j-1], get(pos, i))); cout &lt;&lt; dp[n][k] &lt;&lt; endl; return 0; &#125; [Luogu P1868] 饥饿的奶牛 Portal. 给定 nnn 个区间，找出不重复的区间，使得区间总长度尽量的长。 根据数据范围和经验，设 f(i)f(i)f(i) 代表前 iii 的长度序列的最大答案，那么显然有对于区间 (j,i)(j,i)(j,i)： f(i)=max⁡(f(i),max⁡(f(j−1)+j−i+1))f(i) = \\max(f(i), \\max(f(j-1)+j-i+1)) f(i)=max(f(i),max(f(j−1)+j−i+1)) 代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int f[3000005]; vector &lt;int> a[3000005]; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int l = read(), r = read(); a[r].push_back(l); &#125; for (int i = 1; i &lt;= 3000000; ++i) &#123; f[i] = f[i - 1]; for (auto x : a[i]) f[i] = max(f[i], f[x - 1] + i - x + 1); &#125; printf(\"%d\\n\", f[3000000]); return 0; &#125; 多维结构上的动态规划 它们本身就是高维问题。 [NOIP2002 普及组] 过河卒 Portal. 设 ans[i][j] 代表走到 (i,j)(i,j)(i,j) 的方案数，有 ans(i,j)=ans(i−1,j)+ans(i,j−1)ans(i,j)=ans(i−1,j)+ans(i,j−1)ans(i,j)=ans(i−1,j)+ans(i,j−1)，具体如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #define ll long long using namespace std; const int h[9][2] = &#123;&#123;0, 0&#125;, &#123;1, 2&#125;, &#123;2, 1&#125;, &#123;-1, 2&#125;, &#123;2, -1&#125;, &#123;-1, -2&#125;, &#123;-2, -1&#125;, &#123;1, -2&#125;, &#123;-2, 1&#125;&#125;; bool flag[25][25]; ll ans[25][25]; int main(void) &#123; int n, m, x, y; cin >> n >> m >> x >> y; for (int i = 0; i &lt; 9; i++) &#123; int tx = x + h[i][0], ty = y + h[i][1]; if (tx >= 0 &amp;&amp; tx &lt;= n &amp;&amp; ty >= 0 &amp;&amp; ty &lt;= m) flag[tx][ty] = 1; &#125; if (flag[0][0] == 1) &#123; puts(\"0\"); return 0; &#125; ans[0][0] = 1; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) &#123; if (flag[i][j]) continue; if (i != 0) ans[i][j] += ans[i - 1][j]; if (j != 0) ans[i][j] += ans[i][j - 1]; &#125; cout &lt;&lt; ans[n][m] &lt;&lt; '\\n'; return 0; &#125; [NOIP2000 提高组] 方格取数 Portal. 走两回相当于两个人同时走（常见套路），那么定义 dp[i][j][k][l] 为其中一人向右走 iii，向下走 jjj；另一人向右走 kkk，向下走 lll。 当 i+j=k+li+j=k+li+j=k+l 时，转移： dp[i][j][k][l]=gold+max⁡{dp[i−1][j][k−1][l],dp[i−1][j][k][l−1],dp[i][j−1][k−1][l],dp[i][j−1][k][l−1].dp[i][j][k][l]=gold+\\max \\begin{cases} dp[i-1][j][k-1][l],\\\\ dp[i-1][j][k][l-1],\\\\ dp[i][j-1][k-1][l],\\\\ dp[i][j-1][k][l-1].\\\\ \\end{cases}dp[i][j][k][l]=gold+max⎩⎨⎧​dp[i−1][j][k−1][l],dp[i−1][j][k][l−1],dp[i][j−1][k−1][l],dp[i][j−1][k][l−1].​ 其中 goldgoldgold 指当前能获得的分数。 可以证明这一设计没有后效性，满足最优子结构。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int a[15][15]; int dp[15][15][15][15]; int main(void) &#123; scanf(\"%d\", &amp;n); int x, y, z; while (scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z) == 3 &amp;&amp; x) a[x][y] = z; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int k = 1; k &lt;= n; ++k) for (int l = 1; l &lt;= n; ++l) if (i + j == k + l) // 实际上是 i+j-2 == k+l-2，这是 dp 的前提 &#123; #define f dp[i][j][k][l] f = max(f, dp[i-1][j][k-1][l]); f = max(f, dp[i-1][j][k][l-1]); f = max(f, dp[i][j-1][k-1][l]); f = max(f, dp[i][j-1][k][l-1]); f += a[i][j] + a[k][l]; if (i == k &amp;&amp; j == l) f -= a[i][j]; // 想一想，为什么 #undef f &#125; printf(\"%d\\n\", dp[n][n][n][n]); return 0; &#125; 还可以写一下 [NOIP2008 提高组] 传纸条 加以巩固。 Problemset 动态规划的实践性很强，需要做大量的题目。这里会给出一些。为了更好的解决一下题目，请先了解背包问题的基础概念部分（仅第 111 节即可）： 背包 DP/b2626942/ 简单题 这里的问题比较简单。 [ABC261D] Flipping and Bonus Portal. 当前的状态由 f[i,j]f[i,j]f[i,j] 来定义，表示翻到了第 iii 个硬币，分数为 jjj 时所获得的最大钱数，没有后效性。 转移很简单：要么是正面，要么反面，对应即可（详见代码）。满足最优子结构。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x; &#125; int n, m; int x[5005], y[5005]; i64 f[5005][5005], ans; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) x[i] = read(); for (int i = 1; i &lt;= m; ++i) &#123; int c = read(); y[c] = read(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) // 注意最多拿 i-1 分 f[i][0] = max(f[i][0], f[i - 1][j]); // f[i][0] 是从 f[i-1][x] 中的任意一个不选反面的 for (int j = 1; j &lt;= i; ++j) f[i][j] = f[i - 1][j - 1] + x[i] + y[j]; // 一定是选正面了 &#125; for (int i = 0; i &lt;= n; ++i) ans = max(ans, f[n][i]); printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P1280] 尼克的任务 Portal. 设 f(i)f(i)f(i) 代表从 iii 时间开始能获得的最多休息时间，那么： f(i)={f(i+1)+1,max⁡{f(i+tj)}.f(i) = \\begin{cases} f(i+1)+1,\\\\ \\max\\{f(i+t_j)\\}. \\end{cases} f(i)={f(i+1)+1,max{f(i+tj​)}.​ 这个时刻有任务采用第一种转移，否则采用第二种。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, k, f[10005]; vector &lt;int> v[10005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= k; ++i) &#123; int p, t; scanf(\"%d%d\", &amp;p, &amp;t); v[p].push_back(t); &#125; for (int i = n; i >= 1; --i) &#123; if (v[i].size() == 0) f[i] = f[i + 1] + 1; else &#123; for (int j = 0; j &lt; v[i].size(); ++j) f[i] = max(f[i], f[i + v[i][j]]); &#125; &#125; printf(\"%d\\n\", f[1]); return 0; &#125; [UVa 1025] A spy in the Metro Portal. 影响决策的只有当前时间和所处的车站。设 f(i,j)f(i,j)f(i,j) 表示时刻 iii，位于车站 jjj，最少需要等待的时间。有如下三种决策： 等 111 分钟； 乘左边来的车（如果存在）； 乘右边来的车（如果存在）。 代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, T, m1, m2, kase = 0; int t[55]; bool has_train[205][55][2]; int f[205][55]; int main(void) &#123; while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; memset(f, 0x3f, sizeof(f)); memset(has_train, 0, sizeof(has_train)); f[0][1] = 0; T = read(); for (int i = 1; i &lt; n; ++i) t[i] = read(); m1 = read(); for (int i = 1; i &lt;= m1; ++i) &#123; int x = read(); for (int j = 1; j &lt;= n; ++j) &#123; has_train[x][j][0] = true; x += t[j]; if (x > T) break; &#125; &#125; m2 = read(); for (int i = 1; i &lt;= m2; ++i) &#123; int x = read(); for (int j = n; j >= 1; --j) &#123; has_train[x][j][1] = true; x += t[j-1]; if (x > T) break; &#125; &#125; for (int i = 1; i &lt;= T; ++i) for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = f[i-1][j] + 1; if (j > 1 &amp;&amp; has_train[i][j][0] &amp;&amp; i >= t[j - 1]) f[i][j] = min(f[i][j], f[i - t[j - 1]][j - 1]); if (j &lt; n &amp;&amp; has_train[i][j][1] &amp;&amp; i >= t[j]) f[i][j] = min(f[i][j], f[i - t[j]][j + 1]); &#125; printf(\"Case Number %d: \", ++kase); if (f[T][n] >= 0x3f3f3f3f) puts(\"impossible\"); else printf(\"%d\\n\", f[T][n]); &#125; return 0; &#125; [UVA10943] How do you add? Portal. 设 f(i,k)f(i,k)f(i,k) 代表将 iii 划分为 kkk 个数。直接暴力转移即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const int MOD = 1000000; int n, k; int f[105][105]; int main(void) &#123; for (int i = 0; i &lt;= 100; ++i) &#123; f[i][1] = 1; for (int j = 0; j &lt;= 100; ++j) for (int k = 0; k &lt;= i; ++k) f[i][j] = (f[i][j] + f[i - k][j - 1]) % MOD; &#125; while (scanf(\"%d%d\", &amp;n, &amp;k) == 2 &amp;&amp; n) printf(\"%d\\n\", f[n][k]); return 0; &#125; 较复杂内容 从这里开始的题目会比较有趣。 [Luogu P4310] 绝世好题 Portal. 按照求解 LIS 问题的经验，很容易设计出一个 O(n2)O(n^2)O(n2) 的暴力 DP。由于 bi&amp;bi−1≠0b_i\\&amp;b_{i-1}\\ne 0bi​&amp;bi−1​=0，也就是说在二进制意义下至少有一位相同。设 f(i)f(i)f(i) 代表以在二进制中第 iii 位为 111 的数结尾的满足题意的子序列长度，那么扫描到一个 aia_iai​，就可以计算以 aia_iai​ 结尾的最长子序列长度。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = 0; int a[100005], f[32]; // f[i] 代表以在二进制中第 i 位为 1 的数结尾的满足题意的子序列长度 int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); int k = 1; // k 代表以 a[i] 结尾的最长子序列长度 for (int j = 0; j &lt;= 30; ++j) if ((1 &lt;&lt; j) &amp; a[i]) k = max(k, f[j] + 1); // a[i] 的第 j 位是 1，a[i] 可以与第 j 位为 1 的数结尾的子序列连起来 for (int j = 0; j &lt;= 30; ++j) if ((1 &lt;&lt; j) &amp; a[i]) f[j] = max(f[j], k); // a[i] 的第 j 位是 1，f[j] 对应的子序列可以以 a[i] 结尾 ans = max(ans, k); &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1385] 密令 Portal. 可以发现一条神奇的性质：不论怎样，这个字符串的字符和永远不变，而且任意和相等的字符串都可以变出来。 证明：采用构造方法。我们从前往后构造新的字符串，考虑第一个字符，如果比目标大就用 (−1,+1)(−1, +1)(−1,+1) 变换，比目标小就用 (+1,−1)(+1,−1)(+1,−1) 变换。然后去搞第二个字符……以此类推，直到搞完前 n−1n − 1n−1 位。至于最后一位，我们断言它此时必定等于目标串的最后一位。这是因为两种变换均不会改变字母和 sumsumsum。 于是整个问题被简化为：给定 sumsumsum，有多少种长度为 nnn 的序列满足： 每个元素在 [1,26][1, 26][1,26] 之间； 序列和为 sumsumsum。 设 dp[k][x]dp[k][x]dp[k][x] 表示长度为 kkk 的序列之和为 xxx 的方案数，答案显然是 dp[n][sum]dp[n][sum]dp[n][sum]。转移是显然的： dp[k][x]=∑1≤i≤min⁡{26,x}dp[k−1][x−i]dp[k][x] = \\sum\\limits_{1\\le i\\le\\min\\{26,x\\}}dp[k − 1][x − i] dp[k][x]=1≤i≤min{26,x}∑​dp[k−1][x−i] 我们不需要惧怕多组询问，预处理之后就能直接出答案。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #define MOD 1000000007 using namespace std; char s[105]; int f[105][3000]; int main(void) &#123; for (int i = 0; i &lt;= 26; ++i) f[1][i] = 1; for (int i = 2; i &lt;= 102; ++i) &#123; for (int j = 1; j &lt;= 2602; ++j) for (int k = 1; k &lt;= 26; ++k) if (j > k) f[i][j] = (f[i][j] + f[i-1][j-k]) % MOD; &#125; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int sum = 0; string s; cin >> s; for (int i = 0; i &lt; s.length(); ++i) sum += s[i] - 'a' + 1; cout &lt;&lt; (f[s.length()][sum] - 1) % MOD &lt;&lt; '\\n'; &#125; return 0; &#125; [CF1061C] Multiplicity Portal. 从序列 {a1,a2,⋯ ,an}\\{a_1, a_2,\\cdots,a_n\\}{a1​,a2​,⋯,an​} 中选出非空子序列 {b1,b2,⋯ ,bk}\\{b_1,b_2,\\cdots,b_k\\}{b1​,b2​,⋯,bk​}，一个子序列合法需要满足 ∀ i∈[1,k],i∣b\\forall\\ i \\in [1,k],i\\mid b∀ i∈[1,k],i∣b。求有多少互不相等的合法子序列，答案对 109+710^9+7109+7 取模。 由于人类尚不知道素数分布规律之类的内容，所以 OI 中的数学题很多都建立在枚举之上。这道题就是一个典型的例子。 往往线性 DP 的状态设计都很暴力，求什么就什么。我们令 f[i,j]f[i,j]f[i,j] 代表前 iii 个数中选择 jjj 个数的方案数。显然有： f[i][j]={f[i−1][j]+f[i−1][j−1],j∣a[i]f[i−1][j]f[i][j] = \\begin{cases} f[i-1][j]+f[i-1][j-1]&amp;,j\\mid a[i]\\\\ f[i-1][j] \\end{cases} f[i][j]={f[i−1][j]+f[i−1][j−1]f[i−1][j]​,j∣a[i] 但是这样显然是 TLE + MLE。如何优化？由于 j∣a[i]j\\mid a[i]j∣a[i]，我们可以不枚举 jjj 而是枚举 a[i]a[i]a[i] 的约数（方法。同时我们还可以把第一维给滚掉。 但是枚举约数时，由于转移必须要有顺序，所以我们需要排个序。滚动时也要注意，由于我们需要 (i−1,j−1)(i-1,j-1)(i−1,j−1) 的内容，所以需要倒序枚举。因为我们需要的是上一阶段前面的解，第二种转移已经不需要了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;cmath> #include &lt;algorithm> #define MOD 1000000007 using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n; int a[100005]; int dp[1000005]; int main(void) &#123; n = read(); dp[0] = 1; for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= n; ++i) &#123; vector &lt;int> v; // 先求约数 for (int j = 1; j * j &lt;= a[i]; ++j) &#123; if (a[i] % j == 0) &#123; v.push_back(j); if (j * j != a[i]) v.push_back(a[i] / j); &#125; &#125; sort(v.begin(), v.end()); // 排序 for (int j = min(int(v.size() - 1), i); j >= 0; --j) dp[v[j]] = (dp[v[j] - 1] + dp[v[j]]) % MOD; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + dp[i]) % MOD; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; [Luogu P3861] 拆分 Portal. 给定一个整数 n(n≤1012)n(n\\le 10^{12})n(n≤1012)，求将 nnn 分解为互不相同的不小于 222 的数的乘积的方案数。答案模 998244353998244353998244353。 预处理出 nnn 的约数数组 ddd，以及用 pos[i]pos[i]pos[i] 代表约数 iii 在 ddd 中的位置。由于约数很大，所以如果 i&gt;ni&gt;\\sqrt{n}i&gt;n​，就用 n÷in\\div in÷i 代表其位置。设 f(i,j)f(i,j)f(i,j) 代表将 did_idi​ 拆分成不大于 djd_jdj​ 的约数个数方案数，转移方程不难写出。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cmath> using namespace std; typedef long long i64; const int MOD = 998244353; int tot, pos1[1000005], pos2[1000005], f[6721][6721]; i64 n, d[7000]; int main(void) &#123; int T; cin >> T; while (T--) &#123; tot = 0; cin >> n; int sqrtn = sqrt(n); for (i64 i = 1; i * i &lt;= n; ++i) if (n % i == 0) &#123; d[++tot] = i; if (i * i != n) d[++tot] = n / i; &#125; sort(d + 1, d + tot + 1); for (int i = 1; i &lt;= (tot + 1) / 2; ++i) pos1[d[i]] = i, pos2[d[i]] = tot - i + 1; for (int i = 1; i &lt;= tot; ++i) &#123; f[i][1] = (i == 1 ? 1 : 0); for (int j = 2; j &lt;= tot; ++j) &#123; f[i][j] = f[i][j - 1]; if (d[i] % d[j] == 0) &#123; i64 tmp = d[i] / d[j]; i64 pos = tmp &lt;= sqrtn ? pos1[tmp] : pos2[n / tmp]; f[i][j] = (f[i][j] + f[pos][j - 1]) % MOD; &#125; &#125; &#125; printf(\"%d\\n\", f[tot][tot] - 1); &#125; return 0; &#125; [CF10D] LCIS Portal. 求最长公共上升子序列的长度，并给出解。 根据之前求解 LIS 与 LCS 的经验，我们可以得出这样一个做法： 设 f(i,j)f(i,j)f(i,j) 表示 A1∼AiA_1\\sim A_iA1​∼Ai​ 与 B1∼BjB_1\\sim B_jB1​∼Bj​ 的 LCIS 长度。这样行吗？不行！因为我们不知道 LCIS 结尾的数是什么，无法转移，有后效性。那么我们就规定以 BjB_jBj​ 结尾（BjB_jBj​ 也等于 AiA_iAi​）。当 Ai≠BjA_i \\ne B_jAi​=Bj​ 时，有 f(i,j)=f(i−1,j)f(i,j)=f(i-1,j)f(i,j)=f(i−1,j)；当 Ai=BjA_i = B_jAi​=Bj​ 时，f(i,j)=max⁡0≤k&lt;j,Bk&lt;Bj{f(i−1,k)}+1f(i,j)=\\max\\limits_{0\\le k&lt;j,B_k&lt;B_j}\\{f(i-1,k)\\}+1f(i,j)=0≤k&lt;j,Bk​&lt;Bj​max​{f(i−1,k)}+1。代码便不难写出（打印解的方法将在下文介绍）。for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (a[i] == b[j]) &#123; for (int k = 0; k &lt; j; ++k) if (b[k] &lt; b[j]) f[i][j] = max(f[i][j], f[i-1][k] + 1); &#125; else f[i][j] = f[i-1][j]; 这样的时间复杂度是 O(n3)\\mathcal{O}(n^3)O(n3)，足以通过原题，但是我们还可以做得更好。Bk&lt;BjB_k&lt;B_jBk​&lt;Bj​ 相当于 Bk&lt;AiB_k&lt;A_iBk​&lt;Ai​。随着 iii 的增大，kkk 可以取的值只多不少。一旦来了个更好的决策，我们只需保留它即可。综上，我们只需要动态更新决策。代码如下： for (int i = 1; i &lt;= n; ++i) &#123; int val = 0; // val 代表之前代码中“f[i-1][k]“的最大值，一开始为 0（前提是序列中的数都是正数，否则它要为 —INF） if (b[0] &lt; a[i]) val = f[i-1][0]; for (int j = 1; j &lt;= m; ++j) &#123; if (a[i] == b[j]) f[i][j] = val + 1; else f[i][j] = f[i-1][j]; if (b[j] &lt; a[i]) val = max(val, f[i-1][j]); // 这个 j 相当于 k，相当于原始代码中的 f[i-1][k] &#125; &#125; 现在的问题就成了如何打印解，这里给出 DP 打印解的一般方式：记录每个状态从哪里来，然后用递归输出。完整代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m; int a[505], b[505]; int f[505][505], g[505][505]; // g[i][j] 记录长度为 i 的序列选取的第 j 个数的编号从哪个编号转移过来（在 b 中的编号） void print(int s) // 递归输出 &#123; if (s == 0) return; // 回到了 0，也就是什么都没有 print(g[n][s]); printf(\"%d \", b[s]); &#125; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); m = read(); for (int i = 1; i &lt;= m; ++i) b[i] = read(); for (int i = 1; i &lt;= n; ++i) &#123; int t = 0; // 记录最后选取的数的编号（与之前不同） for (int j = 1; j &lt;= m; ++j) &#123; if (a[i] == b[j]) &#123; f[i][j] = f[i-1][t] + 1; // 将这个编号对应的 f[i-1][j] 进行转移 g[i][j] = t; // 从 t 来 &#125; else &#123; f[i][j] = f[i-1][j]; g[i][j] = g[i-1][j]; // 从 g[i-1][j] 对应的编号来 &#125; if (b[j] &lt; a[i]) t = j; // 编号可以取 j &#125; &#125; // 注意以下，由于状态定义了结尾，所以要取最大值 int s = 0; for (int i = 1; i &lt;= m; ++i) if (f[n][i] > f[n][s]) s = i; printf(\"%d\\n\", f[n][s]); print(s); putchar('\\n'); return 0; &#125; [NOIP2005 提高组] 过河 Portal. 当 LLL 比较小，直接暴力 DP 即可。当 LLL 比较大怎么办呢？发现其实 S,T,MS,T,MS,T,M 都很小，实际上当两个石子的间隔超过 S×TS\\times TS×T 之后，都是可以跳过去的，因此可以根据此压缩状态。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> using namespace std; int L; int S, T, M; int A[105], stone[105]; bool flag[4000005]; int f[4000005]; int main(void) &#123; memset(f, 0x7f, sizeof(f)); scanf(\"%d%d%d%d\", &amp;L, &amp;S, &amp;T, &amp;M); for (int i = 1; i &lt;= M; ++i) scanf(\"%d\", stone + i); sort(stone + 1, stone + M + 1); if (S == T) // 特判 &#123; int ans = 0; for (int i = 1; i &lt;= M; ++i) if (stone[i] % S == 0) ++ans; printf(\"%d\\n\", ans); return 0; &#125; for (int i = 1; i &lt;= M; ++i) &#123; int d = stone[i] - stone[i - 1]; A[i] = A[i - 1] + min(d, S * T); // 在上一个石子的基础上 flag[A[i]] = true; &#125; L = A[M] + S * T; // 最远跳这么远 f[0] = 0; for (int i = 1; i &lt;= L; ++i) for (int j = S; j &lt;= T; ++j) if (i >= j) f[i] = min(f[i], f[i - j] + flag[i]); int ans = 1e9; for (int i = A[M]; i &lt;= L; ++i) ans = min(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; [CF41D] Pawn Portal. 由于规模很小，所以状态可以设计的暴力一点。不知道倍数无法进行转移，那么就将对 k+1k+1k+1 取模后的结果加入状态。 本题需要打印解，我们只需要在更新的时候看一下这个状态从哪里来的就可以了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, k; char s[105]; int a[105][105]; int f[105][105][15]; char d[105][105][15]; void dfs(int x, int y, int back) &#123; if (x == n) return printf(\"%d\\n\", y), void(); if (d[x][y][back] == 'R') dfs(x + 1, y - 1, ((back - a[x][y]) % k + k) % k); else dfs(x + 1, y + 1, ((back - a[x][y]) % k + k) % k); putchar(d[x][y][back]); &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); ++k; memset(f, 0xff, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", s + 1); for (int j = 1; j &lt;= m; ++j) a[i][j] = int(s[j] - '0'); &#125; for (int i = 1; i &lt;= m; ++i) f[n][i][a[n][i] % k] = a[n][i]; for (int i = n - 1; i >= 1; --i) for (int j = 1; j &lt;= m; ++j) for (int x = 0; x &lt; k; ++x) &#123; int back = ((x - a[i][j]) % k + k) % k; int &amp;dp = f[i][j][x], &amp;val = a[i][j]; #define check(x) (x != -1 &amp;&amp; x + val > dp) if (j > 1 &amp;&amp; check(f[i + 1][j - 1][back])) &#123; d[i][j][x] = 'R'; f[i][j][x] = f[i + 1][j - 1][back] + val; &#125; if (j &lt; m &amp;&amp; check(f[i + 1][j + 1][back])) &#123; d[i][j][x] = 'L'; f[i][j][x] = f[i + 1][j + 1][back] + val; &#125; &#125; int ans = -1, pos; for (int i = 1; i &lt;= m; ++i) if (f[1][i][0] > ans) ans = f[1][i][0], pos = i; printf(\"%d\\n\", ans); if (ans != -1) dfs(1, pos, 0); return 0; &#125; [UVA116] Unidirectional TSP Portal. 由于需要打印字典序最小的解，所以设 f(i,j)f(i,j)f(i,j) 代表从 (i,j)(i,j)(i,j) 出发的最小代价比较方便（字典序是从前往后比的）。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; int m, n; int a[15][105]; int f[15][105], nxt[15][105]; int main(void) &#123; while (scanf(\"%d%d\", &amp;m, &amp;n) == 2) &#123; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[i][j]); int ans = 1e9, first; for (int j = n; j >= 1; --j) for (int i = 1; i &lt;= m; ++i) &#123; if (j == n) f[i][j] = a[i][j]; else &#123; int rows[3] = &#123;i, (i == 1 ? m : i - 1), (i == m ? 1 : i + 1)&#125;; sort(rows, rows + 3); f[i][j] = 1e9; for (int k = 0; k &lt; 3; ++k) &#123; int v = f[rows[k]][j + 1]; if (v &lt; f[i][j]) &#123; f[i][j] = v; nxt[i][j] = rows[k]; &#125; &#125; f[i][j] += a[i][j]; &#125; if (j == 1 &amp;&amp; f[i][j] &lt; ans) ans = f[first = i][j]; &#125; printf(\"%d\", first); for (int i = nxt[first][1], j = 2; j &lt;= n; i = nxt[i][j], ++j) printf(\" %d\", i); printf(\"\\n%d\\n\", ans); &#125; return 0; &#125; [UVA1625] Color Length Portal. 状态直接 f(i,j)f(i,j)f(i,j) 表示当前取到的位置，用的最小代价。现在就是要搞清楚代价。代价需要预处理好每一个字符首次出现和最后出现的位置，在扫描的时候维护，把“已经出现但尚未结束”的值 +1。可以使用滚动数组优化空间。 扫描时维护一个 ccc 数组，代表当前新增的代价。正常来讲新增的代价是不变的，当有新的字母出现时，代价就增加 111，一个字母终结时，代价就 −1-1−1。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int INF = 1e9; int n, m; char a[5005], b[5005]; int f[2][5005], c[2][5005]; int sa[26], sb[26], ea[26], eb[26]; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s%s\", a + 1, b + 1); n = strlen(a + 1), m = strlen(b + 1); memset(sa, 0x3f, sizeof(sa)); memset(sb, 0x3f, sizeof(sb)); memset(ea, 0, sizeof(ea)); memset(eb, 0, sizeof(eb)); memset(c, 0, sizeof(c)); memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; a[i] -= 'A'; sa[a[i]] = min(sa[a[i]], i); ea[a[i]] = i; &#125; for (int i = 1; i &lt;= m; ++i) &#123; b[i] -= 'A'; sb[b[i]] = min(sb[b[i]], i); eb[b[i]] = i; &#125; int t = 0; for (int i = 0; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= m; ++j) &#123; if (!i &amp;&amp; !j) continue; f[i &amp; 1][j] = min(i ? (f[(i - 1) &amp; 1][j] + c[(i - 1) &amp; 1][j]) : INF, (j ? (f[i &amp; 1][j - 1] + c[i &amp; 1][j - 1]) : INF)); if (i) &#123; c[i &amp; 1][j] = c[(i - 1) &amp; 1][j]; if (sa[a[i]] == i &amp;&amp; sb[a[i]] > j) ++c[i &amp; 1][j]; // 首个 a[i] if (ea[a[i]] == i &amp;&amp; eb[a[i]] &lt;= j) --c[i &amp; 1][j]; // a[i] 完全结束 &#125; else if (j) &#123; c[i][j] = c[i][j - 1]; if (sb[b[j]] == j &amp;&amp; sa[b[j]] > i) ++c[i &amp; 1][j]; if (eb[b[j]] == j &amp;&amp; ea[b[j]] &lt;= i) --c[i &amp; 1][j]; &#125; &#125; &#125; printf(\"%d\\n\", f[n &amp; 1][m]); &#125; return 0; &#125; [Luogu P1412] 经营与开发 Portal. 正序很难做，但是倒序可以。设 f(i)f(i)f(i) 代表从 iii 开始的最大收入，转移不难写出。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, type[100005], a[100005]; double k, c, w, f[100005]; int main(void) &#123; cin >> n >> k >> c >> w; for (int i = 1; i &lt;= n; ++i) scanf(\"%d%d\", &amp;type[i], &amp;a[i]); for (int i = n; i >= 1; --i) &#123; if (type[i] == 1) f[i] = max(f[i + 1], f[i + 1] * (1 - 0.01 * k) + a[i]); else f[i] = max(f[i + 1], f[i + 1] * (1 + 0.01 * c) - a[i]); &#125; printf(\"%.2lf\\n\", f[1] * w); return 0; &#125; [ZJOI2006] 物流运输 Portal. 注意到数据范围小的吓人，所以可以想的暴力一点。设 f(i)f(i)f(i) 代表前 iii 天的最小成本，那么转移的时候直接暴力枚举从什么时间开始走同一条最短路（走不通就是 INF 的代价）。最短路的处理直接多次 Dijkstra。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> #define pii pair&lt;int, int> #define i64 long long using namespace std; const int INF = 0x3f3f3f3f; int n, m, k, e; int f[105]; bool ban[25][205]; struct edge &#123; int to, dist; edge(int to = 0, int dist = 0) : to(to), dist(dist) &#123;&#125; &#125;; vector &lt;edge> G[25]; bool v[25], die[25]; int d[25]; void Dijkstra(void) &#123; priority_queue &lt;pii, vector&lt;pii>, greater&lt;pii> > q; memset(v, 0, sizeof(v)); memset(d, 0x3f, sizeof(d)); d[1] = 0; q.push(make_pair(0, 1)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (!v[u]) &#123; v[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].to, w = G[u][i].dist; if (die[v]) continue; if (d[v] > d[u] + w) &#123; d[v] = d[u] + w; q.push(make_pair(d[v], v)); &#125; &#125; &#125; &#125; &#125; int cost[105][105]; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;e); while (e--) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); G[u].push_back(edge(v, d)); G[v].push_back(edge(u, d)); &#125; int dx; scanf(\"%d\", &amp;dx); for (int i = 1; i &lt;= dx; ++i) &#123; int p, a, b; scanf(\"%d%d%d\", &amp;p, &amp;a, &amp;b); for (int j = a; j &lt;= b; ++j) ban[p][j] = true; &#125; // i 到 j 走同一条最短路 for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) &#123; memset(die, 0, sizeof(die)); for (int k = 1; k &lt;= m; ++k) for (int t = i; t &lt;= j; ++t) if (ban[k][t]) die[k] = true; Dijkstra(); cost[i][j] = d[m]; &#125; memset(f, 0x3f, sizeof(f)); f[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (cost[1][i] != INF) f[i] = cost[1][i] * i; else f[i] = INF; for (int j = 1; j &lt; i; ++j) if (cost[j + 1][i] != INF &amp;&amp; f[j] != INF) f[i] = min(f[i], f[j] + cost[j + 1][i] * (i - j) + k); &#125; printf(\"%d\\n\", f[n]); return 0; &#125; [HAOI2006] 数字序列 Portal.给定一个长度为 n(n≤3.5×104)n(n\\le 3.5\\times 10^4)n(n≤3.5×104) 的整数序列，问将它改成一个单调严格上升序列最少要修改多少数？和在这个前提下每个数改变的绝对值之和的最小值？ 构造 b[i]=a[i]−ib[i]=a[i]-ib[i]=a[i]−i，那么要修改的数就等于 nnn 减去 bbb 的最长不降子序列长度。为什么呢？比如说：4 8 8 8 7，想保留 444 和 777 是不成的，因为 7−4−1&lt;37-4-1&lt;37−4−1&lt;3。所以写一个方程：f(i)=max⁡{f(j)+1∣ai−aj≥i−j}f(i)=\\max\\{f(j)+1|a_i-a_j\\ge i-j\\}f(i)=max{f(j)+1∣ai​−aj​≥i−j}，因此构造 bbb 数组。 直接在 bbb 上求解第二位。设 dp(i)dp(i)dp(i) 代表考虑到 iii 的最小答案，显然有 dp(i)=min⁡{dp(j)+w(j+1,i)∣f(i)=f(j)+1}dp(i)=\\min\\{dp(j)+w(j+1,i)|f(i)=f(j)+1\\}dp(i)=min{dp(j)+w(j+1,i)∣f(i)=f(j)+1}，其中 w(l,r)w(l,r)w(l,r) 代表将 w(l,r)w(l,r)w(l,r) 改成合法的最小代价。怎么改？找到一个分割点，分割点前 bjb_jbj​，分割点后全部变成 bib_ibi​ 一定能找到最优解。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> #include &lt;vector> #define int long long using namespace std; int n, ans; int a[35005], b[35005], g[35005], f[35005]; int dp[30005], sl[30005], sr[30005]; vector&lt;int> v[30005]; signed main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[i] = a[i] - i; memset(g, 0x3f, sizeof(g)); b[0] = -1e9; b[n + 1] = 1e9; for (int i = 1; i &lt;= n + 1; ++i) &#123; int k = upper_bound(g + 1, g + n + 1, b[i]) - g; f[i] = k, g[k] = b[i]; if (i &lt;= n) ans = max(ans, f[i]); &#125; printf(\"%d\\n\", n - ans); v[0].emplace_back(0); for (int i = 1; i &lt;= n + 1; ++i) &#123; dp[i] = 1e9; for (int j : v[f[i] - 1]) &#123; if (b[j] > b[i]) continue; sl[j] = sr[i - 1] = 0; for (int k = j + 1; k &lt;= i - 1; ++k) sl[k] = sl[k - 1] + abs(b[k] - b[j]); for (int k = i - 2; k >= j; --k) sr[k] = sr[k + 1] + abs(b[k+ 1] - b[i]); for (int k = j; k &lt;= i - 1; ++k) dp[i] = min(dp[i], dp[j] + sl[k] + sr[k]); &#125; v[f[i]].emplace_back(i); &#125; printf(\"%lld\\n\", dp[n + 1]); return 0; &#125; 小结 动态规划的做法需要在实践中积累经验。可以看出，线性 DP 的状态设计和转移往往都比较暴力，没有太多技巧可言。但细节很多，综合性强。学完线性 DP 后，接下来可以阅读背包问题的剩余内容： 背包 DP/b2626942/","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"算法竞赛/学习笔记/动态规划","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"线性 DP","slug":"线性-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7-DP/"}]},{"title":"背包问题","slug":"notes/DP/pack-dp","date":"2022-07-25T00:00:00.000Z","updated":"2022-07-25T00:00:00.000Z","comments":true,"path":"b2626942/","link":"","permalink":"https://james1badcreeper.github.io/b2626942/","excerpt":"背包是 DP 中一类重要而特殊的模型。本文将引导你学习各类背包。","text":"背包是 DP 中一类重要而特殊的模型。本文将引导你学习各类背包。 关于背包问题有一个特别著名的讲义：崔添翼的背包九讲。想要学好更多复杂的动态规划问题，对背包问题的深入理解必不可少。你可以选择将背包九讲和本文搭配着阅读。 01 背包 这类问题的形式是： 你有 nnn 个物品，要把其中一些物品装进容量为 VVV 的背包； 第 iii 个物品自己的体积是 viv_ivi​； 如果把第 iii 个物品放进背包，会获得 wiw_iwi​ 的收益； 要求在不超过容量的情况下，最大化收益。 01 背包就是这个物品要么选，要么不选。 这是模板。 实现 这个问题初学者较容易设计出错误的状态，如下： dpndp_ndpn​ 表示前 nnn 个物品取得的最大价值。然而前面的物品占用了空间，所以会影响我现在决定能不能放第 nnn 个物品。有后效性。 dpkdp_kdpk​ 表示占用 kkk 的空间取得的价值。然而每个物品只能用一次，决策的时候必须考虑哪些物品用了、哪些没用。有后效性。 那么我们就设计状态：dp[k,m]dp[k,m]dp[k,m] 表示“只考虑前 kkk 个物品，恰好用 mmm 的容量能装下的最大价值”。这个状态没有后效性。 转移方程： dp[k][m]=max⁡{dp[k−1][m]dp[k−1][m−vk]+wk,m⩾vkdp[k][m] = \\max\\begin{cases} dp[k-1][m] \\\\ dp[k-1][m-v_k]+w_k &amp; ,m \\geqslant v_k \\end{cases}dp[k][m]=max{dp[k−1][m]dp[k−1][m−vk​]+wk​​,m⩾vk​​ 初始 dp[0][0]=0dp[0][0]=0dp[0][0]=0，目标（注意由于状态的设计，必须要取最大值，我们定义的是”恰好“，不是”至多“）：max⁡0≤m≤Vdp[n][m]\\max\\limits_{0 \\le m \\le V}{dp[n][m]}0≤m≤Vmax​dp[n][m]。 之所以状态不定义为“至多用 mmm 的容量”，是因为这样无法确定还剩多少空间（但实际上这么做是可行的，具体方法请读者自行思考）。 memset(dp, 0xcf, sizeof(dp)); // -INF，因为要搞最大值 dp[0][0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= V; ++j) &#123; dp[i][j] = dp[i-1][j]; if (j >= v[i]) dp[i][j] = max(dp[i][j], dp[i-1][j-v[i]] + w[i]); &#125; &#125; int ans = -1; for (int i = 0; i &lt;= V; ++i) ans = max(ans, dp[n][i]); 注意到一个问题，jjj 的循环次序是无关紧要的，这不会影响结果。 实际上，笔者目前没有找到任何能证明不用取最大值是错误的反例，也许这样的反例根本不存在，因为在更新时，由于体积更大，肯定能成功更新。实际上这个代码实现是将那些用不掉的体积填进去了空气，例如我们看这样一组数据： n &#x3D; 2, V &#x3D; 4 物品 A: v &#x3D; 3, w &#x3D; 10 物品 B: v &#x3D; 4, w &#x3D; 1 它的 DP 数组长这样： j&#x3D; 0 1 2 3 4 i &#x3D; 1: 0 0 0 10 10 i &#x3D; 2: 0 0 0 10 10 这个 dp[1][4] = 10 从哪来的？显然，它是从 dp[1][1] 更新来的，我们填进去了体积为 111 的空气。 但考虑到实际中是不在意这点时间（取最大值才线性），且严格符合状态转移的过程，强烈建议取最大值。接下来的局部代码为了不影响阅读均不会取最大值，但是完整题目的代码均会取最大值。 滚动数组 更奇妙的是，还可以把 dpdpdp 数组变成一维的。 for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;v, &amp;w); for (int j = V; j >= v; --j) dp[j] = max(dp[j], dp[j-v] + w); &#125; 为什么这样是对的？在计算 dp(i,j)dp(i,j)dp(i,j) 前，dp[j]dp[j]dp[j] 里保存的是 dp(i−1,j)dp(i-1,j)dp(i−1,j)，而 dp[j−v]dp[j-v]dp[j−v] 保存的是 dp(i−1,j−v)dp(i-1,j-v)dp(i−1,j−v)（注意 jjj 的循环次序），然后 dp[j]dp[j]dp[j] 可以顺利更新成 dp(i,j)dp(i,j)dp(i,j) 的内容，覆盖掉的内容再也不会使用，倒序的循环顺序可以使得计算 dp(i,j)dp(i,j)dp(i,j) 时 dp(i,j−v)dp(i,j-v)dp(i,j−v) 还未被计算，保存的是 dp(i−1,j−v)dp(i-1,j-v)dp(i−1,j−v)。所以这样是可以的！ 一个 DP 可以通过滚动数组来优化，当且仅当其状态图是分层的，下 kkk 层的结果，由上 ddd 层结果唯一确定。 在 01 背包中，第 iii 层的结果由第 i−1i-1i−1 层唯一确定，因此可以使用滚动数组。而且由于顺序的特殊性，所以只用了一维。 但是如果没有这种特殊性怎么办？很简单： int dp[2][MAXV]; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= V; ++j) &#123; dp[i &amp; 1][j] = dp[(i-1) &amp; 1][j]; if (j >= v[i]) dp[i &amp; 1][j] = max(dp[i &amp; 1][j], dp[(i-1) &amp; 1][j-v[i]] + w[i]); &#125; &#125; 看到了吗？这样就与循环顺序没有关系了，让 DP 在两维中交替进行。 解的打印 使用滚动数组后，解的打印几乎变成天方夜谭了。事实上即使不用滚动数组，想打印解还是很困难（试一试会发现无法打印字典序最大的解），此时应该使用 dp[k,m]dp[k,m]dp[k,m] 表示“只考虑后 kkk 个物品，恰好用 mmm 的容量能装下的最大价值”。方法相同，打印时使用回溯法打印即可。实际上要求输出解的背包问题很少，但为了防住毒瘤可以考虑学习。 完全背包 这类问题的形式是： 你有 nnn 种物品，每种有无限多，要把其中一些物品装进容量为 VVV 的背包； 第 iii 种物品自己的体积是 viv_ivi​； 如果把第 iii 个物品放进背包，会获得 wiw_iwi​ 的收益； 要求在不超过容量的情况下，最大化收益。 这是模板。 根据经验，设 f[i,j]f[i,j]f[i,j] 表示选前 iii 种物品，体积为 jjj，物品最大价值，则有： f[i,j]=max⁡{f[i−1,j]f[i,j−vi]+wi,j⩾vif[i,j] = \\max\\begin{cases} f[i-1,j] \\\\ f[i,j-v_i]+w_i &amp;, j \\geqslant v_i \\end{cases}f[i,j]=max{f[i−1,j]f[i,j−vi​]+wi​​,j⩾vi​​ 初始 f[0][0]=0f[0][0]=0f[0][0]=0，目标：max⁡0⩽m⩽Vf[n][m]\\max\\limits_{0 \\leqslant m \\leqslant V}{f[n][m]}0⩽m⩽Vmax​f[n][m]。 代码如下： for (int i = 1; i &lt;= n; ++i) &#123; int v = read(), w = read(); for (int j = 0; j &lt;= V; ++j) f[i][j] = f[i-1][j]; // 这是另一种初始化的写法，代码较长但是效率较高 for (int j = v; j &lt;= V; ++j) f[i][j] = max(f[i][j], f[i][j-v] + w); &#125; 还是计算顺序的原因，在计算 f(i,j)f(i,j)f(i,j) 时，f[j]f[j]f[j] 保存的是 f(i−1,j)f(i-1,j)f(i−1,j)，而 f[j−v]f[j-v]f[j−v] 保存的是 f(i,j−v)f(i, j-v)f(i,j−v)，计算 f(i,j)f(i,j)f(i,j) 时，f(i,j−v)f(i,j-v)f(i,j−v) 已经计算完毕。滚动数组代码如下： for (int i = 1; i &lt;= m; ++i) &#123; int v = read(), w = read(); for (int j = v; j &lt;= V; ++j) f[j] = max(f[j], f[j-v] +w); &#125; 多重背包 这类问题的形式是： 你有 nnn 种物品，每种有 CiC_iCi​ 个，要把其中一些物品装进容量为 VVV 的背包； 第 iii 种物品自己的体积是 viv_ivi​； 如果把第 iii 个物品放进背包，会获得 wiw_iwi​ 的收益； 要求在不超过容量的情况下，最大化收益。 如果我们把每种物品都拆成 MiM_iMi​ 个物品，这几乎就跟 01 背包一模一样了。但遗憾的是，这样做很慢，时间复杂度高达 O(V∑Mi)\\mathcal{O}(V\\sum M_i)O(V∑Mi​)。 面对这一情况有两种做法：二进制拆分法和单调队列优化法，时间复杂度分别为 O(V∑log⁡Mi)\\mathcal{O}(V\\sum \\log M_i)O(V∑logMi​) 和 O(VN)\\mathcal{O}(VN)O(VN)。其中单调队列优化法我们会在后续的动态规划教程中进行讨论，也可以阅读背包九讲来学习。 二进制拆分法基于这样一个事实：从 20,21,22,⋯ ,2k−12^0,2^1,2^2,\\cdots,2^{k-1}20,21,22,⋯,2k−1 这 kkk 个整数中选出若干个相加，可以得到 0∼2k−10\\sim 2^{k}-10∼2k−1 之间的所有数。为什么？想一想计算机是怎么用二进制表示数的吧！ 进一步地，我们可以求出满足 ∑i=0p2i⩽Ci\\sum\\limits_{i=0}^{p}2^i\\leqslant C_ii=0∑p​2i⩽Ci​ 的最大整数 ppp，设 Ri=Ci−∑i=0p2iR_i=C_i-\\sum\\limits_{i=0}^{p}2^iRi​=Ci​−i=0∑p​2i，那么： 根据 ppp 的最大性，有 ∑i=0p+12i&gt;Ci\\sum\\limits_{i=0}^{p+1}2^i &gt; C_ii=0∑p+1​2i&gt;Ci​，将 Ri+∑i=0p2i=CiR_i+\\sum\\limits_{i=0}^{p}2^i=C_iRi​+i=0∑p​2i=Ci​ 代入得 ∑i=0p+12i&gt;Ri+∑i=0p2i\\sum\\limits_{i=0}^{p+1}2^i &gt; R_i+\\sum\\limits_{i=0}^{p}2^ii=0∑p+1​2i&gt;Ri​+i=0∑p​2i，可推出 2p+1&gt;Ri2^{p+1} &gt; R_i2p+1&gt;Ri​（两边同时减去 ∑i=0p2i\\sum\\limits_{i=0}^{p}2^ii=0∑p​2i），所以 2p+1−1≥Ri2^{p+1}-1 \\ge R_i2p+1−1≥Ri​，因此从 20,21,22,⋯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,⋯,2p 中选出若干个相加可以得到 0∼Ri0\\sim R_i0∼Ri​ 之间的任何整数（实际上是可以得到 0∼2p+1−10\\sim 2^{p+1}-10∼2p+1−1 之间的任意整数）。 从 20,21,22,⋯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,⋯,2p 以及 RiR_iRi​ 中选择若干个数相加（注意多了个 RiR_iRi​），可以得到 Ri∼Ri+2p+1−1R_i\\sim R_i + 2^{p+1}-1Ri​∼Ri​+2p+1−1 之间的任何整数（就是把 111 中最后的结论用不等式性质一变形），而由于 RiR_iRi​ 的定义，加上数学结论 ∑i=0p2i=2p+1−1\\sum\\limits_{i=0}^{p}2^i=2^{p+1}-1i=0∑p​2i=2p+1−1，可得到 Ri+2p+1−1=Ri=Ci−∑i=0p2i+∑i=0p2i+1−1=CiR_i+2^{p+1}-1=R_i=C_i-\\sum\\limits_{i=0}^{p}2^i+\\sum\\limits_{i=0}^{p}2^i+1-1=C_iRi​+2p+1−1=Ri​=Ci​−i=0∑p​2i+i=0∑p​2i+1−1=Ci​，所以等量代换后可以证明从 20,21,22,⋯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,⋯,2p 以及 RiR_iRi​ 中选择若干个数相加，可以得到 Ri∼CiR_i\\sim C_iRi​∼Ci​ 之间的任何整数。而又有从 20,21,22,⋯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,⋯,2p 中选出若干个相加可以得到 0∼Ri0\\sim R_i0∼Ri​ 之间的任何整数，因此从 20,21,22,⋯ ,2p2^0,2^1,2^2,\\cdots,2^p20,21,22,⋯,2p 以及 RiR_iRi​ 中选择若干个数相加，可以得到 0∼Ci0\\sim C_i0∼Ci​ 之间的任何整数。 综上所述，我们只需要把数量为 CiC_iCi​ 的第 iii 种物品拆成 p+2p+2p+2 个物品，体积为 20×Vi,21×Vi,⋯ ,2p×Vi,Ri×Vi2^0\\times V_i, 2^1\\times V_i,\\cdots,2^p\\times V_i,R_i\\times V_i20×Vi​,21×Vi​,⋯,2p×Vi​,Ri​×Vi​，它们可以凑成 0∼Ci×Vi0\\sim C_i\\times V_i0∼Ci​×Vi​ 之间所有能被 ViV_iVi​ 整除的数。 模板，代码如下： 查看代码 // 注：我们通常用 v 代表体积，w 代表价值，但是此题中是反的。笔者在编码时遵照的时常规而不是原题。 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, V; int f[40005]; struct BadCreeper // ( &#123; int v, w; BadCreeper(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; int main(void) &#123; n = read(), V = read(); for (int i = 1; i &lt;= n; ++i) &#123; int w = read(), v = read(), m = read(), c = 1; vector &lt;BadCreeper> a; while (m - c >= 0) &#123; m -= c; a.push_back(BadCreeper(c * v, c * w)); c &lt;&lt;= 1; &#125; if (m != 0) a.push_back(BadCreeper(m * v, m * w)); // R = 0，没必要添加 for (int j = 0; j &lt; a.size(); ++j) // 枚举物品 for (int k = V; k >= a[j].v; --k) // 01 转移 f[k] = max(f[k], f[k - a[j].v] + a[j].w); &#125; int ans = -1; for (int i = 0; i &lt;= V; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; 混合背包 其实就是将前面三种背包混起来一起乱炖，有的物品只能取 111 次，有的能取 kkk 次，有的能取无限次。这怎么办？一种方法是将无限次化为最多能取得次数，这样就转化成多重背包了。但实际上没必要，我们只需要判断每种情况，然后套用不同种背包对应的循环即可。 模板，代码如下： 查看代码 // 注：此代码编写时仍按照标准背包的定义 #include &lt;iostream> #include &lt;cstdio> #include &lt;string> #include &lt;vector> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, V; inline int calc(string s) &#123; pii res; bool flag = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (s[i] == ':') &#123; flag = 1; continue; &#125; if (flag) res.Y = res.Y * 10 + (s[i] - '0'); else res.X = res.X * 10 + (s[i] - '0'); &#125; return res.X * 60 + res.Y; &#125; int f[1005]; int main(void) &#123; string B, E; cin >> B >> E; V = calc(E) - calc(B); n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int v = read(), w = read(), p = read(); if (p == 0) &#123; for (int j = v; j &lt;= V; ++j) f[j] = max(f[j], f[j - v] + w); &#125; else // 你也可以把 01 背包的情况单独扔出来，不过没必要 &#123; vector &lt;pii> a; int s = 1; while (p > s) &#123; p -= s; a.push_back(make_pair(v * s, w * s)); s &lt;&lt;= 1; &#125; a.push_back(make_pair(v * p, w * p)); for (int j = 0; j &lt; a.size(); ++j) for (int k = V; k >= a[j].X; --k) f[k] = max(f[k], f[k - a[j].X] + a[j].Y); &#125; &#125; int ans = 0; for (int i = 0; i &lt;= V; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; 二维费用背包 二位费用背包是一类一个物品会消耗两种价值（比如汽水就是一种消耗金钱和寿命的东西）。 设 f(i,u,v)f(i,u,v)f(i,u,v) 表示只考虑前 iii 瓶汽水，消耗的金钱恰好为 uuu，消耗的阳寿恰好为 vvv，获得的脂肪是 www ，那么转移方程便是： f(i,u,v)=max⁡{f(i−1,u,v)f(i−1,u−ui,v−vi)+w,u⩾ui,v⩾vif(i,u,v) = \\max\\begin{cases} f(i-1,u,v) \\\\ f(i-1,u-u_i,v-v_i)+w &amp; ,u \\geqslant u_i, v \\geqslant v_i \\end{cases}f(i,u,v)=max{f(i−1,u,v)f(i−1,u−ui​,v−vi​)+w​,u⩾ui​,v⩾vi​​ 同样可以使用滚动数组优化空间（只有第一维是阶段，剩下的是状态，不能滚），注意相应的循环顺序。 模板，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, M, T; int f[205][205]; int main(void) &#123; n = read(), M = read(), T = read(); for (int i = 1; i &lt;= n; ++i) &#123; int m = read(), t = read(); for (int j = M; j >= m; --j) for (int k = T; k >= t; --k) f[j][k] = max(f[j][k], f[j-m][k-t] + 1); // 每个愿望带来的价值都是相等的，都是单位 1 &#125; int ans = 0; for (int i = 0; i &lt;= M; ++i) for (int j = 0; j &lt;= T; ++j) ans = max(ans, f[i][j]); cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 也很容易转化到二维完全背包、多重背包等问题，这里不做赘述。 分组背包 这类问题跟 01 背包的本质区别是：物品可以分为 kkk 组，每组中的物品相互冲突，即每组中最多只能选一个物品。问最大价值。模板。 设 f(i,j)f(i,j)f(i,j) 表示在前 iii 组中选出总体积为 jjj 的物品放入背包，物品的最大价值和。那么： f(i,j)=max⁡{f(i−1,j)max⁡1⩽k⩽Cif(i−1,j−v(i,k))+w(i,k),j⩾v(i,k)f(i,j) = \\max\\begin{cases} f(i-1,j) \\\\ \\max\\limits_{1\\leqslant k \\leqslant C_i} f(i-1,j-v_{(i,k)})+w_{(i,k)} &amp; , j \\geqslant v_{(i,k)} \\end{cases}f(i,j)=max{f(i−1,j)1⩽k⩽Ci​max​f(i−1,j−v(i,k)​)+w(i,k)​​,j⩾v(i,k)​​ 同样可以使用滚动数组滚掉第一维，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, V, f[1005]; vector &lt;pii> a[1005]; int main(void) &#123; V = read(), n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int v = read(), w = read(), c = read(); a[c].push_back(make_pair(v, w)); &#125; for (int i = 0; i &lt; 1000; ++i) &#123; if (a[i].size() == 0) continue; // 这组没有东西就不算了 for (int j = V; j >= 0; --j) for (int k = 0; k &lt; a[i].size(); ++k) // 决策 if (j >= a[i][k].X) f[j] = max(f[j], f[j - a[i][k].X] + a[i][k].Y); &#125; int ans = 0; for (int i = 0; i &lt;= V; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; 注意循环顺序，因为 i,j 是状态，k 是决策，顺序不能混淆。 依赖性背包 这类问题长这样：在 01 背包的基础上，某些物品依赖于一个主物品，比如你想购买 Minecraft Java Edition，你就需要注册 Microsoft 账号，否则是不能购买 Minecraft Java Edition 的。 这里我们讨论基础的依赖性背包，见模板。 我们对这个题做一个扩展：每个主件可以拥有无限个附件，这怎么办呢？可以将每个主件和它的附件作为分组背包中的一个组，想要对这个组进行背包问题的求解，就必须选择主件。对于包含一个主件和若干个附件的集合有以下可能性：仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……需要将以上可能性的容量和价值转换成一件件物品。因为这几种可能性只能选一种，所以可以将这看成分组背包。虽然这样做很慢，但足以通过原题（毕竟最多才两个附件）。对于本题而言，只需要依次判断每种情况即可。 代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; struct BadCreeper &#123; int v, w; BadCreeper(int v = 0, int w = 0) : v(v), w(w) &#123;&#125; &#125;; int n, V, f[32005]; vector &lt;BadCreeper> a[65]; int main(void) &#123; V = read(), n = read(); for (int i = 0; i &lt; n; ++i) &#123; int v = read(), p = read(), q = read(); if (q == 0) a[i].push_back(BadCreeper(v, v * p)); else a[q - 1].push_back(BadCreeper(v, v * p)); &#125; for (int i = 0; i &lt; n; ++i) for (int j = V; j >= 0; --j) &#123; if (a[i].size() > 0 &amp;&amp; j >= a[i][0].v) f[j] = max(f[j], f[j - a[i][0].v] + a[i][0].w); if (a[i].size() > 1 &amp;&amp; j >= a[i][0].v + a[i][1].v) f[j] = max(f[j], f[j - a[i][0].v - a[i][1].v] + a[i][0].w + a[i][1].w); if (a[i].size() > 2) &#123; if (j >= a[i][0].v + a[i][2].v) f[j] = max(f[j], f[j - a[i][0].v - a[i][2].v] + a[i][0].w + a[i][2].w); if (j >= a[i][0].v + a[i][1].v + a[i][2].v) f[j] = max(f[j], f[j - a[i][0].v - a[i][1].v - a[i][2].v] + a[i][0].w + a[i][1].w + a[i][2].w); &#125; &#125; int ans = 0; for (int i = 0; i &lt;= V; ++i) ans = max(ans, f[i]); printf(\"%d\\n\", ans); return 0; &#125; 这类问题的更复杂形态我们会在树形 DP 中讨论。 Problemset 这里是一些简单各类背包问题的合集。它们本身不难，主要是帮助读者进一步了解背包，为接下来更困难的 DP 学习做准备。强烈读者仔细阅读这一部分，其中会出现一些前面的专题没有讲述的内容。 简单问题 这里的问题都比较简单，可以当作复习的题目。 [NOIP2001 普及组] 装箱问题 Portal. 由于我们希望剩余空间尽可能地小，那么可以将物品的体积视作物品的价值，那么本题就是标准的 01 背包问题。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int v, n, w; int f[30005]; int main(void) &#123; scanf(\"%d%d\", &amp;v, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;w); for (int j = v; j >= w; j--) f[j] = max(f[j], f[j - w] + w); &#125; printf(\"%d\", v - f[v]); // 根据之前的推论，这么做也可 return 0; &#125; [CH5201] 数字组合 Portal. 这个问的是将背包装满的方案总数。设计状态：f[i,j]f[i,j]f[i,j] 表示用前 iii 个物品，恰好填满 jjj 的体积的方案总数。首先 f[i,0]f[i,0]f[i,0] 必定为 111。转移：f[i,j]=f[i−1,j]+f[i−1,j−v]f[i,j]=f[i-1,j]+f[i-1,j-v]f[i,j]=f[i−1,j]+f[i−1,j−v]，跟 01 背包很像？的确如此，对于这类改变问法的问题，一般只需将状态转移方程中的 max 改成 sum 即可。事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int f[10005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); f[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int w; scanf(\"%d\", &amp;w); for (int j = m; j >= w; --j) // 数字只能使用一次，对应 01 背包的顺序 f[j] += f[j - w]; &#125; printf(\"%d\\n\", f[m]); return 0; &#125; But WAIT! 这样不会产生之前所说的“不用取最大值也是对的”的填进去空气的情况吗？不会，我们只让 f[i,0]f[i,0]f[i,0] 为 111，而 f[i,1]f[i,1]f[i,1] 这种空气是 000，没有方案。 [CH5202] 自然数拆分 Lunatic 版 Portal. 就是求方案总数的完全背包：容量为 nnn，有 1⋯n1\\cdots n1⋯n 的物品体积。注意要使用若干个，不能是 111 个（我拆成我自己），所以最终结果要 -1。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; const unsigned int MOD = 2147483648u; int n; unsigned int f[4005]; int main(void) &#123; scanf(\"%d\", &amp;n); f[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) f[j] = (f[j - i] + f[j]) % MOD; printf(\"%u\\n\", (f[n] - 1 + MOD) % MOD); return 0; &#125; [NOI Online #3 入门组] 买表 Portal. 直接使用多重背包的模板即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, m; bool f[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); f[0] = true; for (int i = 1; i &lt;= n; ++i) &#123; int k, a, c = 1; scanf(\"%d%d\", &amp;k, &amp;a); while (a - c >= 0) &#123; a -= c; int v = k * c; for (int j = 500000; j >= v; --j) f[j] |= f[j - v]; c &lt;&lt;= 1; &#125; &#125; while (m--) &#123; int x; scanf(\"%d\", &amp;x); puts(f[x] ? \"Yes\" : \"No\"); &#125; return 0; &#125; [BJOI2019] 排兵布阵 Portal. 假设 s=1，那么这就是普通的背包问题了。现在将每个城堡排序一下，枚举要打过多少个玩家，就可以轻松算出贡献了。 查看代码 // 甚至连滚动数组都不用 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int s, n, m; int a[105][105]; int f[105][20005]; // 只考虑前 i 座城堡，恰好使用 j 位士兵所获得的最大收益 int main(void) &#123; scanf(\"%d%d%d\", &amp;s, &amp;n, &amp;m); for (int i = 1; i &lt;= s; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[j][i]); for (int i = 1; i &lt;= n; ++i) sort(a[i] + 1, a[i] + s + 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) // 若使用滚动数组，需要倒序 &#123; f[i][j] = f[i - 1][j]; for (int k = 1; k &lt;= s; ++k) if (j >= a[i][k] * 2 + 1) f[i][j] = max(f[i][j], f[i - 1][j - a[i][k] * 2 - 1] + k * i); // 贡献为 k * i &#125; int ans = 0; for (int j = 0; j &lt;= m; ++j) ans = max(ans, f[n][j]); printf(\"%d\\n\", ans); return 0; &#125; 较复杂题目 这些题目会比较复杂。 [NOIP2018 提高组] 货币系统 Portal. 大凯的疑惑。 可以猜测 (m,b)(m,b)(m,b) 的所有货币面额在 (n,a)(n,a)(n,a) 中一定都有，我们只需要看哪些没有。先排序，然后扫描，使用完全背包，可以拼成的就赋值为 111。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cstring> using namespace std; int n; int a[105]; bool f[25005]; int main(void) &#123; int T; cin >> T; while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); int ans = n; memset(f, 0, sizeof(f)); f[0] = true; for (int i = 1; i &lt;= n; ++i) &#123; if (f[a[i]]) &#123; --ans; continue; &#125; for (int j = a[i]; j &lt;= 25000; ++j) f[j] |= f[j - a[i]]; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; [CSP-J2019] 纪念品 Portal. 由于当日购买的纪念品也可以当日卖出换回金币，那么我们可以强制让第 iii 天买的纪念品在第 i+1i+1i+1 天卖掉。但如果它应该在 i+2i+2i+2 天卖掉怎么办？不要紧，在第 i+1i+1i+1 天再买回来，价格是一样的。 于是直接完全背包板子拍上去就行了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int t, n, m; int p[105][105]; int f[10005]; int main(void) &#123; scanf(\"%d%d%d\", &amp;t, &amp;n, &amp;m); for (int i = 1; i &lt;= t; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", p[i] + j); for (int i = 1; i &lt; t; ++i) &#123; memset(f, 0, sizeof(f)); for (int j = 1; j &lt;= n; ++j) for (int k = p[i][j]; k &lt;= m; ++k) f[k] = max(f[k], f[k - p[i][j]] + p[i + 1][j] - p[i][j]); m += f[m]; &#125; printf(\"%d\\n\", m); return 0; &#125; [Luogu P1441] 砝码称重 Portal. 使用搜索枚举删掉哪些砝码，然后对剩下的砝码使用背包。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m, sum = 0, ans = 0; int a[25]; bool f[2005], del[25]; void dfs(int o, int cnt) &#123; if (cnt == m) &#123; memset(f, 0, sizeof(f)); f[0] = true; int ret = 0; for (int i = 1; i &lt;= n; ++i) if (!del[i]) &#123; for (int j = 2000; j >= 0; --j) if (f[j] &amp;&amp; !f[j + a[i]]) f[j + a[i]] = true, ++ret; &#125; ans = max(ans, ret); return; &#125; if (o > n || cnt > m) return; dfs(o + 1, cnt); del[o] = true; dfs(o + 1, cnt + 1); del[o] = false; &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); sum += a[i]; &#125; dfs(1, 0); printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1782] 旅行商的背包 Portal. 就是将多重背包和分组背包混在了一起（将奇货拆开），但是本题时间很紧，需要大力卡常。 查看代码 #include &lt;iostream> #include &lt;cstdio> #define V first #define W second using namespace std; typedef long long i64; inline int read(void) &#123; int x = 0, c = getchar_unlocked(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar_unlocked();&#125; while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar_unlocked(); return x * f; &#125; int n, m, C, tot = 0; i64 f[100005]; pair&lt;i64, i64> a[2000005]; int main(void) &#123; n = read(), m = read(), C = read(); while (n--) &#123; i64 v = read(), w = read(), d = read(), c = 1; // 这个二进制优化非常的强力，先处理物品再统一计算 while (d) &#123; if (d >= c) d -= c; else c = d, d = 0; a[++tot].V = v * c, a[tot].W = w * c; c &lt;&lt;= 1; &#125; &#125; // 放到外面统一计算 for (int i = 1; i &lt;= tot; ++i) for (int j = C; j >= a[i].V; --j) f[j] = max(f[j], f[j - a[i].V] + a[i].W); while (m--) &#123; i64 a = read(), b = read(), c = read(); for (int j = C; j >= 0; --j) for (int v = 0; v &lt;= j; ++v) f[j] = max(f[j], f[j - v] + a * v * v + b * v + c); &#125; printf(\"%lld\\n\", f[C]); return 0; &#125; [Luogu P1284] 三角形牧场 Portal. 注意到所有的木板都需要使用，那么我们只需要确定三角形两条边的长度就可以知道第三边，然后使用海伦公式计算三角形面积。只需要配合一个二维状态的 01 背包就可以计算这样的长度是否可以得到满足。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; double S(double a, double b, double c) &#123; double p = (a + b + c) / 2; return sqrt(p * (p - a) * (p - b) * (p - c)); &#125; bool check(int a, int b, int c) &#123; if (a &lt;= 0 || b &lt;= 0 || c &lt;= 0) return false; if (a + b &lt;= c || a + c &lt;= b || b + c &lt;= a) return false; return true; &#125; int n; int l[45]; bool f[805][805]; int main(void) &#123; scanf(\"%d\", &amp;n); int sum = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", l + i), sum += l[i]; f[0][0] = true; for (int i = 1; i &lt;= n; ++i) for (int j = 800; j >= 0; --j) for (int k = 800; k >= 0; --k) &#123; if (j - l[i] >= 0) f[j][k] |= f[j - l[i]][k]; if (k - l[i] >= 0) f[j][k] |= f[j][k - l[i]]; &#125; double ans = -1.0; for (int i = 0; i &lt;= 800; ++i) for (int j = 0; j &lt;= 800; ++j) if (f[i][j] &amp;&amp; check(i, j, sum - i - j)) ans = max(ans, S(i, j, sum - i - j)); if (ans == -1.0) puts(\"-1\"); else printf(\"%d\\n\", int(ans * 100)); return 0; &#125; [Luogu P1156] 垃圾陷阱 Portal. 设 f(j)f(j)f(j) 代表高度为 jjj 时的最长存活时间，然后就是 01 背包了（采用刷表法）。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; struct Rubbish &#123; int t, f, h; bool operator &lt; (const Rubbish &amp;a) const &#123; return t &lt; a.t; &#125; &#125; a[105]; int D, G; int f[105]; int main(void) &#123; scanf(\"%d%d\", &amp;D, &amp;G); for (int i = 1; i &lt;= G; ++i) scanf(\"%d%d%d\", &amp;a[i].t, &amp;a[i].f, &amp;a[i].h); sort(a + 1, a + G + 1); f[0] = 10; for (int i = 1; i &lt;= G; ++i) for (int j = D; j >= 0; --j) if (f[j] >= a[i].t) &#123; if (j + a[i].h >= D) &#123; printf(\"%d\\n\", a[i].t); return 0; &#125; f[j + a[i].h] = max(f[j + a[i].h], f[j]); f[j] += a[i].f; &#125; printf(\"%d\\n\", f[0]); return 0; &#125; [USACO03FALL] Cow Exhibition G Portal. 考虑将智商设定为体积，情商设定为价值，答案计算的时候枚举智商。注意滚动的时候的转移顺序。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; const int E = 400000, C = 400000; int n; int f[900005]; int main(void) &#123; scanf(\"%d\", &amp;n); memset(f, 0xbf, sizeof(f)); f[E] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if (a >= 0) &#123; for (int j = C + E; j >= a; --j) f[j] = max(f[j], f[j - a] + b); &#125; else &#123; for (int j = 0; j &lt;= C + E - a; ++j) f[j] = max(f[j], f[j - a] + b); &#125; &#125; int ans = 0; for (int i = 0; i &lt;= C; ++i) if (f[i + E] >= 0) ans = max(ans, i + f[i + E]); printf(\"%d\\n\", ans); return 0; &#125; [SCOI2009] 粉刷匠 Portal.windy 有 NNN 条木板需要被粉刷。每条木板被分为 MMM 个格子。每个格子要被刷成红色或蓝色。windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。如果 windy 只能粉刷 TTT 次，他最多能正确粉刷多少格子？一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。1≤N,M≤50,0≤T≤25001\\le N,M \\le 50, 0 \\le T \\le 25001≤N,M≤50,0≤T≤2500。 考虑使用分组背包，每一个组是每一个木板，组内的物品是不同的粉刷次数。物品的价值可以使用 DP 预处理。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; int n, m, T; vector&lt;int> a[55]; int f[55][55][55][2]; // f(id,i,j,flag) 第 id 块木板，考虑到第 i 个，染了 j 次，第 i 块是否正常染色 int g[2505]; void work(int id) &#123; int siz = a[id].size() - 1; for (int i = 1; i &lt;= siz; ++i) for (int j = siz; j >= 1; --j) &#123; f[id][i][j][0] = max(f[id][i - 1][j][0], f[id][i - 1][j][1]); f[id][i][j][1] = max(f[id][i - 1][j - 1][0], f[id][i - 1][j - 1][1]) + a[id][i]; if (i >= 2) f[id][i][j][1] = max(f[id][i][j][1], f[id][i - 2][j][1] + a[id][i]); &#125; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;T); for (int i = 1; i &lt;= n; ++i) &#123; a[i].push_back(0); static char s[55]; scanf(\"%s\", s + 1); for (int j = 1; j &lt;= m; ++j) if (a[i].empty() || s[j] != s[j - 1]) a[i].push_back(1); else ++a[i][a[i].size() - 1]; &#125; for (int id = 1; id &lt;= n; ++id) work(id); for (int i = 1; i &lt;= n; ++i) &#123; int siz = a[i].size() - 1; for (int j = T; j >= 0; --j) for (int k = 0; k &lt;= siz; ++k) if (j >= k) g[j] = max(g[j], g[j - k] + max(f[i][siz][k][0], f[i][siz][k][1])); &#125; printf(\"%d\\n\", g[T]); return 0; &#125; [HEOI2013] Eden 的新背包问题 Portal.多重背包，但是多组询问，每次给定体积，并删去一个物品。询问相互独立。 用前后缀合并的做法，分别处理分组背包即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define pii pair&lt;int, int> #define V first #define W second using namespace std; int n, q; int f1[1005][1005], f2[1005][1005]; vector&lt;pii> a[1005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int v, w, m, c = 1; scanf(\"%d%d%d\", &amp;v, &amp;w, &amp;m); while (m >= c) &#123; m -= c; a[i].push_back(&#123;c * v, c * w&#125;); c &lt;&lt;= 1; &#125; if (m) a[i].push_back(&#123;m * v, m * w&#125;); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= 1000; ++j) f1[i][j] = f1[i - 1][j]; for (pii x : a[i]) for (int j = 1000; j >= x.V; --j) f1[i][j] = max(f1[i][j], f1[i][j - x.V] + x.W); &#125; for (int i = n; i >= 1; --i) &#123; for (int j = 0; j &lt;= 1000; ++j) f2[i][j] = f2[i + 1][j]; for (pii x : a[i]) for (int j = 1000; j >= x.V; --j) f2[i][j] = max(f2[i][j], f2[i][j - x.V] + x.W); &#125; scanf(\"%d\", &amp;q); while (q--) &#123; int d, e; scanf(\"%d%d\", &amp;d, &amp;e); ++d; int ans = 0; for (int j = 0; j &lt;= e; ++j) ans = max(ans, f1[d - 1][j] + f2[d + 1][e - j]); printf(\"%d\\n\", ans); &#125; return 0; &#125; [Luogu P4141] 消失之物 Portal.背包，每次去掉一个物品，问有多少种方式填满。 考虑每次转移的时候加上了什么，我们倒序加了，那么查询的时候正序减去就好了。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n, m; int a[2005], f[2005], g[2005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); f[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = m; j >= a[i]; --j) f[j] = (f[j] + f[j - a[i]]) % 10; for (int i = 1; i &lt;= n; ++i) &#123; memcpy(g, f, sizeof(g)); for(int j = a[i]; j &lt;= m; ++j) g[j] = (f[j] - g[j - a[i]] + 10) % 10; for (int j = 1; j &lt;= m; ++j) printf(\"%d\", g[j]); putchar('\\n'); &#125; return 0; &#125; 小结 背包问题主要以算法模板的形式出现在考试中，难在一道题如何转化成背包问题，但这不是本文讲解的重点。想要学会这一点，只能通过学习各种各样的 DP，做大量的题目，积累经验。请读者务必记住各种背包的原理，而不是背住循环顺序。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"算法竞赛/学习笔记/动态规划","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包","slug":"背包","permalink":"https://james1badcreeper.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"提高优化技巧","slug":"notes/杂项/tg-tricks","date":"2022-07-24T00:00:00.000Z","updated":"2022-07-24T00:00:00.000Z","comments":true,"path":"37f7d707/","link":"","permalink":"https://james1badcreeper.github.io/37f7d707/","excerpt":"提高级别的常见简单技巧包括前缀和与差分，2-pointers 等，本文简单介绍了它们。","text":"提高级别的常见简单技巧包括前缀和与差分，2-pointers 等，本文简单介绍了它们。 双指针 双指针里的指针并不是指 C 语言中的指针，而是一个抽象的指针。我一个指针“指”在了序列中的某个地方，一方面表示目前枚举到了这里，另一方面表示正在关注这个数，两个指针也经常有区间左右端点的意义。一般是枚举一个指针，然后另一个指针随着这个指针的移动而移动。 简单地来说，2-pointer 其实就是用两个指针扫描数组。 大概分为两种，两个指针的行进方向是相同的，或是相向的。 普通双指针 因为很常规，所以它没有名字。 [Luogu P1102] A-B 数对 Portal. A−B=CA-B=CA−B=C 可以化为 A−C=BA-C=BA−C=B，也就是说可以找到序列中的一个数减掉 CCC 等于序列中的另一个数。显然对于一个 AAA, BBB 是唯一的。 当然可以排序后使用二分来找这个 BBB 的数量，不过今天我们介绍另一种做法。我们还是先排序，这些 BBB 一定是连续的。从左到右扫描序列，记当前扫描到 aia_iai​，当继续向右扫，aia_iai​ 会增加，所对应的 BBB 的下标不会减小。利用这个性质扫描一次即可，时间复杂度为 O(n)O(n)O(n)（需要使用基数排序）。 维护两个下标 l,rl,rl,r，使得使得任意时刻 lll 是第一个满足 A−C=BA-C=BA−C=B 的位置，rrr 是第一个不满足 A−C=BA-C=BA−C=B 的位置，那么个数就是 r−lr-lr−l。 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; using i64 = long long; int n, c; int a[200005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;c); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); int l = 1, r = 1; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (a[l] &lt; a[i] - c &amp;&amp; l &lt;= n) ++l; // 找到第一个 B 的下标 while (a[r] &lt;= a[i] - c &amp;&amp; r &lt;= n) ++r; // 找到第一个不是 B 的下标 ans += r - l; // l &lt;= r 恒成立，直接加即可 &#125; printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P1115] 最大子段和 Portal. 先计算前缀和。一个子段和等于 S[r]−S[l−1]S[r]-S[l-1]S[r]−S[l−1]，当 S[r]S[r]S[r] 一定时，找到最小的 S[l−1]S[l-1]S[l−1] 就可以了。可以简单地记录 S[l−1]S[l-1]S[l−1]，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x * f; &#125; int sum[200005]; int main(void) &#123; int n = read(), ans = -2000000000, minn = 0; for (int i = 1; i &lt;= n; ++i) sum[i] = read() + sum[i-1]; for (int R = 1; R &lt;= n; ++R) &#123; ans = max(ans, sum[R] - minn); minn = min(minn, sum[R]); &#125; printf(\"%d\\n\", ans); return 0; &#125; [USACO16OPEN] Diamond Collector S Portal. 根据直觉肯定要先排序。由于总共有两个架子，然后容易发现，如果两个钻石放到同一个盒子，那么这两个钻石中间的也可以放到同一个盒子。问题实际上是要找出两个不相交的区间，使得最大值和最小值之差都小于 KKK，且区间长度之和最大。 这时就有两种思路，一个是前后各做两边双指针，然后合并。 扫两遍 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, k; int a[50005]; int f[50005], g[50005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); // 此时 f[i] 代表从 i 开始（必须含 i）向右可以选的最长区间 for (int L = 1, R = 1; L &lt;= n; ++L) &#123; while (R &lt; n &amp;&amp; a[R + 1] &lt;= k + a[L]) ++R; // R 尽量往左走 f[L] = R - L + 1; // 从 L 开始的最大区间长度 &#125; // 接下来让 f[i] 代表在 [i,n] 中选一段区间的最大长度（可以不含 i） for (int i = n - 1; i >= 1; --i) f[i] = max(f[i], f[i + 1]); // 此时 g[i] 代表从 i 开始（含 i）向左可以选的最长区间 for (int L = n, R = n; R >= 1; --R) &#123; while (L > 1 &amp;&amp; a[R] - a[L - 1] &lt;= k) --L; // L 尽量往左走 g[R] = R - L + 1; // 从 R 开始的最大区间长度 &#125; // 接下来让 g[i] 代表在 [1,i] 中选一段区间的最大长度（可以不含 i） for (int i = 2; i &lt;= n; ++i) g[i] = max(g[i], g[i - 1]); int ans = 0; for (int i = 1; i &lt; n; ++i) // 合并答案，枚举分界点 i，分别求 [1,i], [i+1,n] 两端区间中选一段最长区间的长度，然后相加 ans = max(ans, f[i + 1] + g[i]); printf(\"%d\\n\", ans); return 0; &#125; 另一种是只扫一遍，同时统计： 扫一遍 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, k, ans = 0, res = 0; // ans 记录最大答案，res 记录 [0,i-1] 中的最长区间 int a[50005], c[50005]; // c[i] 记录从 i 开始向左走，最长的区间，就是满足条件的 [x,i] 的最大长度 int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); c[1] = 1; for (int i = 1, R = 1; i &lt;= n; ++i) // [i,R] 放在第二个架子，能放多少放多少 // 在 [0,i - 1] 中挑一段区间放在第一个架子 // 在 i 右边选一段区间放没有意义，因为迟早能扫到 // 也就是说，这个算法相当于枚举 i，找到最大的 R，并计算在 [0,i - 1] 中挑一段区间的最大长度 &#123; while (R &lt; n &amp;&amp; a[R + 1] &lt;= a[i] + k) &#123; ++R; // R 越大越好 /* c[R] 表示从 R 开始向左走的最大长度 R 能跑到这里，是在当前这个 i 之前前所未有的 也就是当前这个 i 是第一个能使 R 跑到这里的 那么这个 i 一定是使得区间长度最长的最小 i */ c[R] = R - i + 1; &#125; res = max(res, c[i - 1]); // 更新 res，res 就是 max(c[0],c[1]...c[i-1]) ans = max(ans, R - i + 1 + res); // R - i + 1 为 [i,R] 的长度 &#125; printf(\"%d\\n\", ans); return 0; &#125; 尺取法 我也不知道这是个什么东西，但是给的题单是这样的，笔记我就这么写了。 感觉就是滑动窗口，但可能还不太一样。 实际上指的就是两个移动方向相同的双指针，然后统计它们之间的信息。 [Luogu P1638] 逛画展 Portal. 使用滑动窗口（同向双指针），并开一个桶记录看的各个画家的画的数量，在这个数量到 mmm 钱让 R++，到了之后让 L++ 直到不满足条件。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m, cnt = 0; int ans = 1000005, ansL = 1, ansR = 1000000; int a[1000005], b[2005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); int L = 1, R = 1; while (R &lt;= n) &#123; if (b[a[R]] == 0) ++cnt; ++b[a[R]]; while (L &lt; R &amp;&amp; cnt == m &amp;&amp; b[a[L]] > 1) --b[a[L]], ++L; if (cnt == m &amp;&amp; R - L &lt; ansR - ansL) &#123; ansL = L; ansR = R; &#125; ++R; &#125; printf(\"%d %d\\n\", ansL, ansR); return 0; &#125; [UVa 11572] Unique Snowflakes Portal. 直接使用滑动窗口，然后利用一个 set 判重即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;unordered_set> using namespace std; int n; int a[1000005]; unordered_set &lt;int> s; void solve(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); s.clear(); int L = 1, R = 1, ans = 0; while (R &lt;= n) &#123; while (R &lt;= n &amp;&amp; s.find(a[R]) == s.end()) s.insert(a[R++]); ans = max(ans, R - L); s.erase(a[L++]); &#125; printf(\"%d\\n\", ans); &#125; int main(void) &#123; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; &#125; 排序 是普及组内容，但是笔者不会。 排序算法（英语：Sorting algorithm）是一种将一组特定的数据按某种顺序进行排列的算法。排序算法多种多样，性质也大多不同。 稳定性。稳定性是指相等的元素经过排序之后相对顺序是否发生了改变。拥有稳定性这一特性的算法会让原本有相等键值的纪录维持相对次序，即如果一个排序算法是稳定的，当有两个相等键值的纪录 AAA 和 BBB，且在原本的列表中 AAA 出现在 BBB 之前，在排序过的列表中 AAA 也将会是在 BBB 之前。 关于稳定性的意义： 如果只是简单的进行数字的排序，那么稳定性将毫无意义。 如果排序的内容仅仅是一个复杂对象的某一个属性（比如排序的是结构体，其中一个数字作为排序依据），那么稳定性依旧将毫无意义。 如果要排序的内容是一个复杂对象的多个属性（比如排序的是结构体，其中几个数字参与运算作为排序依据），但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。 除非要排序的内容是一个复杂对象的多个属性，且其原本的初始顺序存在意义，那么我们需要在进行排序的基础上保持原有顺序的意义，才需要使用到稳定性的算法。例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得相同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。 也就是说，除非要排序的内容具有多个属性，而且在相等时要保证原有的顺序，才需要使用稳定性排序。 排序的方法。排序要么是基于比较，要么是基于分类。下文会进行介绍。 复杂度。包括时间复杂度和空间复杂度。有最坏复杂度，平均复杂度和最优复杂度。一般来讲算法竞赛中只看最坏。 冒泡排序 工作原理是每次检查相邻两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。 扫了一次后，最后一项必定是最大的。扫 n−1n-1n−1 次就行了。 时间复杂度 O(n2)O(n^2)O(n2)，是一种稳定的排序算法。 for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt;= n - i; ++j) if (a[j] > a[j + 1]) swap(a[j], a[j + 1]); 这个东西可以优化，如果扫完了之后发现没有交换的内容，那么说明已经排好序了。代码如下： for (int i = 1; i &lt; n; ++i) &#123; bool flag = false; for (int j = 1; j &lt;= n - i; ++j) if (a[j] > a[j + 1]) &#123; swap(a[j], a[j + 1]); flag = true; &#125; if (!flag) break; &#125; 冒泡排序与逆序对。我们知道逆序对是指 a[i]&gt;a[j],i&lt;ja[i]&gt;a[j],i&lt;ja[i]&gt;a[j],i&lt;j，它也是冒泡排序的最小交换次数。需要知道的是，冒泡排序交换元素的次数就等于原序列的逆序对数。 可以这样理解：交换条件是 a[j] &gt; a[j + 1]，这就是指一个逆序对，交换了之后如果不产生新的逆序对，那么逆序对数必然会减少一；由于交换后 jjj 前面的依然在 jjj 前面，j+1j+1j+1 后面的依然在后面，所以逆序对数没有改变。综上可得冒泡排序交换元素的最小次数就等于原序列的逆序对数。 选择排序 原理是每次寻找第 iii 小的元素，与第 iii 个位置上的东西交换，时间复杂度 O(n2)O(n^2)O(n2)。 是一种不稳定的排序算法，如 3 3 1，将斜体 3 和 1 比较，变成了 1 3 3，斜体 3 到了直体 3 后面。 for (int i = 1; i &lt; n; ++i) &#123; int ith = i; // 就是寻找后面最小的元素，那个一定是第 i 小 for (int j = i + 1; j &lt;= n; ++j) if (a[j] &lt; a[ith]) ith = j; swap(a[i], a[ith]); &#125; 插入排序 插入排序的工作原理是将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。 一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。 是一种稳定的排序算法。平均时间复杂度为 O(n2)O(n^2)O(n2)。 for (int i = 2; i &lt;= n; ++i) &#123; int now = a[i], j = i - 1; for (; j >= 1; --j) &#123; if (a[j] > now) a[j + 1] = a[j]; else break; &#125; a[j + 1] = now; &#125; 快速排序 基于分治，但是均可以使用 STL 替代： sort(a + 1, a + n + 1); // 排序 nth_element(a + 1, a + k, a + n + 1); // 查找 k 小元素 归并排序 是分治法的基础，利用其完美的性质可以高效求逆序对。 离散化 就是将无穷大集合中的若干元素映射为有限集合来方便统计。当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。 但是这个为什么东西叫离散化？我也不知道。 最常见的是有 nnn 个 int 范围内的整数，可能有重复，假定去重后有 mmm 个整数。我们要把每个 a[i]a[i]a[i] 用 1∼m1\\sim m1∼m 之间的整数代替，并且保证顺序大小不变。当然可以使用 map，但是我们来探讨一个常数更小的算法。 我们可以把 aaa 排序并去重，得到有序数组 b[1]∼b[m]b[1]\\sim b[m]b[1]∼b[m]，若查询 iii 代表的数值，返回 b[i]b[i]b[i] 即可。若要查询整数 a[j]a[j]a[j] 被那个 1∼m1\\sim m1∼m 之间的整数代替，只需要在 bbb 中二分查找它的位置。 void discrete(void) &#123; // 离散化 sort(b + 1, b + n + 1); // 先排序 m = unique(b + 1, b + n + 1) - (b + 1); // 再去重 &#125; int P(int x) &#123; // 查询谁替代了 x return lower_bound(b + 1, b + n + 1, x) - b; &#125; [CF670C] Cinema. 这些语言的数比较大，可以把它们都放到一个数组里，离散化后就容易统计了。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m, size; int a[200005], b[200005], c[200005]; int d[800005]; int cnt[800005]; inline int P(int x) &#123; return lower_bound(d+1, d+size+1, x) - d; &#125; int main(void) &#123; n = read(); int tot = 0; for (int i = 1; i &lt;= n; ++i) a[i] = read(), d[++tot] = a[i]; m = read(); for (int i = 1; i &lt;= m; ++i) b[i] = read(), d[++tot] = b[i]; for (int i = 1; i &lt;= m; ++i) c[i] = read(), d[++tot] = c[i]; sort(d+1, d+tot+1); size = unique(d+1, d+tot+1) - (d+1); for (int i = 1; i &lt;= n; ++i) ++cnt[P(a[i])]; int ans = 0, ret = -1, res = -1; for (int i = 1; i &lt;= m; ++i) &#123; int x = cnt[P(b[i])], y = cnt[P(c[i])]; if (x > ret || (x == ret &amp;&amp; y > res)) ans = i, ret = x, res = y; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 单调栈与单调队列 如果栈或队列中的元素具有单调性，那么它们就分别被成为单调栈和单调队列，可以及时帮我们排除不可能的决策。 单调栈 模板。 由于求的是之后，所以我们可以从后往前考虑。 第一个大于？想到了什么？如果这个数是后被考虑到的（即下标小），而且它还比前面考虑到的数大，那么这些数就不可能称为答案了。用俗语来说就是： 如果一个人比你小，还比你强，那么你就永远也打不过他了。 我们可以建立一个栈，记录编号，如果发现满足这种条件的东西，那么就弹栈，最后 push 即可。代码如下： int n; int a[3000005]; int ans[3000005]; stack&lt;int> s; int main(void) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = n; i >= 1; --i) &#123; // 倒序扫 while (!s.empty() &amp;&amp; a[s.top()] &lt;= a[i]) s.pop(); // 弹栈 ans[i] = s.empty() ? 0 : s.top(); // 记录答案 s.push(i); // 将这个数压进栈里 &#125; // 最后输出答案即可 return 0; &#125; 注意，stack 很慢，如果可以建议手写。 单调队列 模板。 这回可不一样了，它还要求区间的长度。如果我们开一个双端队列，那么不就可以及时弹掉不符合要求的数了吗？ 所以说，单调队列相比单调栈增加了弹出超过时间的数的功能。 deque &lt;int> q; for (int i = 1; i &lt;= n; ++i) &#123; while (!q.empty() &amp;&amp; a[q.back()] >= a[i]) q.pop_back(); while (!q.empty() &amp;&amp; q.front() &lt;= i - k) q.pop_front(); q.push_back(i); // print(a[q.front()]) &#125; for (int i = 1; i &lt;= n; ++i) &#123; while (!q.empty() &amp;&amp; a[q.back()] &lt;= a[i]) q.pop_back(); while (!q.empty() &amp;&amp; q.front() &lt;= i - k) q.pop_front(); q.push_back(i); // print(a[q.front()]) &#125; 前缀和与差分 这是很简单但很重要的优化技巧。 前缀和 前缀和是一种重要的预处理，能大大降低查询的时间复杂度。可以简单理解为“数列的前 nnn 项的和”。 实现 模板。 设 Si=∑j=1iAiS_i=\\sum_{j=1}^{i}A_iSi​=∑j=1i​Ai​，则 ∑i=lr=Sr−Sl−1\\sum_{i=l}^{r} = S_r-S_{l-1}∑i=lr​=Sr​−Sl−1​。 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; inline int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; i64 sum[100005]; int main(void) &#123; int n = read(); for (int i = 1; i &lt;= n; ++i) sum[i] = read() + sum[i-1]; int m = read(); while (m--) &#123; int l = read(), r = read(); printf(\"%lld\\n\", sum[r] - sum[l - 1]); &#125; return 0; &#125; [Luogu P1115] 最大子段和 Portal. 最大子段和问题有很多种解决方式，比如动态规划。这里我们用前缀和再实现一个线性算法（虽然应该算滑动窗口）。 一个子段和等于 S[r]−S[l−1]S[r]-S[l-1]S[r]−S[l−1]，当 S[r]S[r]S[r] 一定时，找到最小的 S[l−1]S[l-1]S[l−1] 就可以了。可以简单地记录 S[l−1]S[l-1]S[l−1]，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar(), f = 1; while (!isdigit(c)) &#123;if (c == '-') f = -1; c = getchar();&#125; while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x * f; &#125; int sum[200005]; int main(void) &#123; int n = read(), ans = -2000000000, minn = 0; for (int i = 1; i &lt;= n; ++i) sum[i] = read() + sum[i-1]; for (int R = 1; R &lt;= n; ++R) &#123; ans = max(ans, sum[R] - minn); minn = min(minn, sum[R]); &#125; printf(\"%d\\n\", ans); return 0; &#125; 差分 差分是前缀和的逆运算。对于一个数组 AAA，定义它的差分数组 BBB，满足 B1=A1,Bi=Ai−Ai−1(i≥2)B_1=A_1, B_i=A_i-A_{i-1}(i\\ge 2)B1​=A1​,Bi​=Ai​−Ai−1​(i≥2)。对这个差分数组求前缀和得到的就是原数组，对前缀和求差分也能得到原数组。 实现 [Luogu P2367] 语文成绩。 求出原序列 AAA 的差分序列 BBB。求出将 bxb_xbx​ 增加 111，那么 Ax⋯AnA_x \\cdots A_nAx​⋯An​ 都会增加 111。利用这个规律就可以解决这个问题了。 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; int n, p; i64 a[5000005], b[5000005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;p); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) b[i] = a[i] - a[i - 1]; while (p--) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); b[x] += z, b[y + 1] -= z; &#125; i64 ans = 1000000000000; for (int i = 1; i &lt;= n; ++i) // 此时的 a 用于计算前缀和 a[i] = a[i - 1] + b[i], ans = min(ans, a[i]); printf(\"%lld\\n\", ans); return 0; &#125; [Luogu P3406] 海底高铁 Portal. 我们只需要统计出坐每辆车的次数就可以进行计算了。维护一个差分数组，对于将 [l,r−1]+1[l,r-1]+1[l,r−1]+1 的操作，只需要让 Sl+1,Sr−1+1S_l+1, S_{r-1}+1Sl​+1,Sr−1​+1 即可，最后算一遍前缀和就行了。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; int m, n, a, b, c, p[100005]; i64 sum[100005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", p + i); for (int i = 2; i &lt;= m; ++i) ++sum[min(p[i - 1], p[i])], --sum[max(p[i - 1], p[i])]; for (int i = 2; i &lt;= n; ++i) sum[i] += sum[i - 1]; i64 ans = 0; for (int i = 1; i &lt; n; ++i) &#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); ans += min(a * sum[i], b * sum[i] + c); &#125; printf(\"%lld\\n\", ans); return 0; &#125; 高维问题 前缀和和差分不仅能够在一维线性空间上工作，还可以在高维空间上工作。主要应用是二位前缀和和二维差分（三维可以自己类比，需要一定的空间想象能力，这里不做介绍 实际上你也用不着）。 二维前缀和 [Luogu P1719] 最大加权矩形。要求给出一个 O(n3)O(n^3)O(n3) 的算法。 我们可以枚举矩形的四个端点坐标，然后使用二维前缀和在常数时间内解决问题。利用容斥原理很容易得到结果，具体过程请读者自行模拟：记 s[i,j]=∑p=1i∑q=1jAi,js[i,j]=\\sum\\limits_{p=1}^i\\sum\\limits_{q=1}^j A_{i,j} s[i,j]=p=1∑i​q=1∑j​Ai,j​ 则 ∑x1=1x2∑y1=1y2Ai,j=s[x2,y2]−s[x1−1,y2]−s[x2,y1−1]+s[x1−1,y1−1]\\sum\\limits_{x_{1}=1}^{x_{2}}\\sum\\limits_{y_{1}=1}^{y_{2}} A_{i,j}= s[x_{2},y_{2}]-s[x_{1}-1,y_{2}]-s[x_{2},y_{1}-1]+s[x_{1}-1,y_{1}-1] x1​=1∑x2​​y1​=1∑y2​​Ai,j​=s[x2​,y2​]−s[x1​−1,y2​]−s[x2​,y1​−1]+s[x1​−1,y1​−1] 那么 O(n4)O(n^4)O(n4) 的代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = -1000000000; int sum[125][125]; int solve(int x1, int y1, int x2, int y2) &#123; return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; int x; scanf(\"%d\", &amp;x); sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + x - sum[i - 1][j - 1]; &#125; for (int x1 = 1; x1 &lt;= n; x1++) for (int y1 = 1; y1 &lt;= n; y1++) for (int x2 = x1; x2 &lt;= n; x2++) for (int y2 = y1; y2 &lt;= n; y2++) ans = max(ans, solve(x1, y1, x2, y2)); printf(\"%d\\n\", ans); return 0; &#125; 考虑优化。还记得《最大子段和》吗？可以枚举上下边界，中间的这一大排就是个最大子段和问题！可以使用滑动窗口或 DP 实现最大子段和。这里用一个很聪明的方式：如果当前累计和是非负数就保留，负数就扔掉。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, ans = -1000000000; int sum[125][125]; int solve(int x1, int y1, int x2, int y2) &#123; return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; int x; scanf(\"%d\", &amp;x); sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + x - sum[i - 1][j - 1]; &#125; for (int x1 = 1; x1 &lt;= n; x1++) for (int x2 = x1; x2 &lt;= n; x2++) &#123; int s = 0; for (int i = 1; i &lt;= n; i++) &#123; s += solve(x1, i, x2, i); ans = max(ans, s); if (s &lt; 0) s = 0; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P2004] 领地选择 Portal. 使用二维前缀和，简单枚举即可。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m, c; int sum[1005][1005]; int ans = -1000000000, ansx, ansy; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; int x; scanf(\"%d\", &amp;x); sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + x; &#125; for (int i = 1; i &lt;= n - c + 1; i++) for (int j = 1; j &lt;= m - c + 1; j++) &#123; if (sum[i + c - 1][j + c - 1] + sum[i - 1][j - 1] - sum[i + c - 1][j - 1] - sum[i - 1][j + c - 1] >= ans) &#123; ans = sum[i + c - 1][j + c - 1] + sum[i - 1][j - 1] - sum[i + c - 1][j - 1] - sum[i - 1][j + c - 1]; ansx = i; ansy = j; &#125; &#125; printf(\"%d %d\\n\", ansx, ansy); return 0; &#125; [HNOI2003] 激光炸弹 Portal. 直接用二位前缀和处理，然后枚举激光炸弹投放的位置即可。空间较为紧张，最好直接在前缀和数组上进行读入。虽然目标是一个质点，但我们可以把它看成一个块块，前缀和就可以做了。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m; int s[5005][5005]; int main(void) &#123; n = read(), m = read(); while (n--) &#123; int x = read(), y = read(), w = read(); s[x + 1][y + 1] += w; &#125; for (int i = 1; i &lt;= 5001; ++i) for (int j = 1; j &lt;= 5001; ++j) s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; int ans = 0; for (int i = m; i &lt;= 5001; ++i) for (int j = m; j &lt;= 5001; ++j) ans = max(ans, s[i][j] - s[i - m][j] - s[i][j - m] + s[i - m][j - m]); printf(\"%d\\n\", ans); return 0; &#125; 二维差分 [Luogu P3397] 地毯。 将差分扩展到二维即可。请读者自行用容斥原理进行模拟。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int a[1005][1005]; int ans[1005][1005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int x1, y1, x2, y2; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); a[x2 + 1][y2 + 1]++; a[x1][y1]++; a[x1][y2 + 1]--; a[x2 + 1][y1]--; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) ans[i][j] = ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1] + a[i][j]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) printf(\"%d \", ans[i][j]); putchar('\\n'); &#125; return 0; &#125; 高维问题的 DP 解法 这是什么？ 你能够轻松想象三维前缀和甚至四维前缀和的做法码？反正笔者不能。 用 DP 计算可以使过程变得简单许多。这种 DP 是 sosDP（Sum over Subsets DP，子集和 DP，是状压 DP 的一种）。 鉴于本文的内容水平，这里不给出具体原理，请读者自行模拟。 二维前缀和// 读入时直接读到前缀和数组里 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(\"%d\", &amp;s[i][j]); // 进行两次运算，注意 +=，一次是 i - 1，一次是 j - 1 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) s[i][j] += s[i - 1][j]; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) s[i][j] += s[i][j - 1]; 三维前缀和// 和二维基本相同 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= k; ++j) for (int k = 1; k &lt;= n; ++k) scanf(\"%d\", &amp;s[i][j][k]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++) s[i][j][k] += s[i - 1][j][k]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++) s[i][j][k] += s[i][j - 1][k]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++) s[i][j][k] += s[i][j][k - 1]; 但是查询好像还是要用容斥。这里给出公式供背诵： 三维维护：s[i][j][k] = s[i-1][j][k] + s[i][j-1][k] + s[i][j][k-1] - s[i-1][j-1][k] - s[i-1][j][k-1] - s[i][j-1][k-1] + s[i-1][j-1][k-1] + a[i][j][k] 三维求和：s[x2][y2][z2] - s[x1-1][y2][z2] - s[x2][y1-1][z2] - s[x2][y2][z1-1] + s[x1-1][y1-1][z2] + s[x1-1][y2][z1-1] + s[x2][y1-1][z1-1] - s[x1-1][y1-1][z1-1] 差分大概也是同样的原理： 三维差分： b[x1][y1][z1] += c , b[x2+1][y1][z1] -=c , b[x1][y2+1][z1] -= c , b[x1][y1][z2+1] -= c , b[x2+1][y2+1][z1] += c , b[x2+1][y1][z2+1] += c , b[x1][y2+1][z2+1] += c , b[x2+1][y2+1][z2+1] -= c 然后呢？nnn 维前缀和的问题较为困难，需要使用 sosDP，请读者阅读笔者的《基于状态进行优化的 DP》一文。 贪心的应用 真的不是简单贪心了。 贪心方法 必须满足当前一步是最优解，那么全局就是最优解。 排序贪心。这种做法是离线的，通过排序找出最优的。 反悔贪心。这种做法是在线的，无论当前的选择是什么都接受，如果之后发现这个选项不优了，那么就废弃掉。 贪心证明 微扰法。对局部的任何改变都不会使得结果变好。 范围缩放。证明局部的最优策略必定是全局的最优策略，或者是局部最优决策已经包含了所有可能的情况。 反证法。 数学归纳法。n=1n=1n=1 时成立；n=mn=mn=m 成立时，n=m+1n=m+1n=m+1 也成立。那么对于任意的 nnn 就都成立。 简单题 更多的题会在 Problemset 中出现。 [USACO07NOV] Sunscreen G Portal. 按照 minSPF 递减进行排序，每次找能用的最大的防晒霜。微扰可以证明。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #define pint pair&lt;int, int> using namespace std; int c, l; pint a[2505], b[2505]; int main(void) &#123; scanf(\"%d%d\", &amp;c, &amp;l); for (int i = 1; i &lt;= c; ++i) scanf(\"%d%d\", &amp;a[i].first, &amp;a[i].second); for (int i = 1; i &lt;= l; ++i) scanf(\"%d%d\", &amp;b[i].first, &amp;b[i].second); sort(a + 1, a + c + 1, greater&lt;pint>()); sort(b + 1, b + l + 1, greater&lt;pint>()); int ans = 0; for (int i = 1; i &lt;= c; ++i) &#123; for (int j = 1; j &lt;= l; ++j) if (b[j].second &amp;&amp; b[j].first >= a[i].first &amp;&amp; b[j].first &lt;= a[i].second) &#123; b[j].second -= 1; ans += 1; break; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125; [USACO06FEB] Stall Reservations S Portal. 将每一个事件拆分成开吃和结束吃，然后找能吃的放进去。可以证明再开一个的话结果不会更好。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;queue> #include &lt;algorithm> #include &lt;map> using namespace std; struct event &#123; int id, type, time; event(int id = 0, int type = 0, int time = 0) : id(id), type(type), time(time) &#123;&#125; bool operator &lt; (const event &amp;a) const &#123; return time &lt; a.time; &#125; &#125; a[100005]; struct fence &#123; int id, time; fence(int id = 0, int time = 0) : id(id), time(time) &#123;&#125; bool operator &lt; (const fence &amp;a) const &#123; return time > a.time; &#125; &#125;; int n, cnt; int use[100005]; priority_queue &lt;fence> q; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); a[(i &lt;&lt; 1) - 1] = event(i, 1, x); a[i &lt;&lt; 1] = event(i, 2, y); &#125; sort(a + 1, a + n * 2 + 1); cnt = 1; q.push(&#123;1, 0&#125;); for (int i = 1; i &lt;= n * 2; ++i) &#123; if (a[i].type == 1) &#123; if (q.empty() || q.top().time > a[i].time) &#123; cnt += 1; q.push(&#123;cnt, 0&#125;); &#125; int u = q.top().id; q.pop(); use[a[i].id] = u; &#125; else q.push(&#123;use[a[i].id], a[i].time + 1&#125;); &#125; printf(\"%d\\n\", cnt); for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", use[i]); return 0; &#125; [UVA1193] Radar Installation Portal. 每一个建筑能被哪个区间的监视器监视是可以预处理的，然后将范围按照左端点排序，以此考虑是否能监视，能监视就监视。 因为如果不监视而要新建的话，未来也是可以新建的，现在就监视并不会丢失解。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> #include &lt;algorithm> #define pdb pair&lt;double, double> #define L first #define R second using namespace std; int n, d; pdb a[1005]; int main(void) &#123; int kase = 0; while (scanf(\"%d%d\", &amp;n, &amp;d) == 2 &amp;&amp; n) &#123; bool flag = true; for (int i = 1; i &lt;= n; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); double t = d * d - y * y; if (t &lt; 0) flag = false; t = sqrt(t); a[i].L = x - t, a[i].R = x + t; &#125; if (!flag) &#123; printf(\"Case %d: -1\\n\", ++kase); continue; &#125; sort(a + 1, a + n + 1); int ans = 1; double pos = a[1].R; for (int i = 2; i &lt;= n; ++i) &#123; if (pos >= a[i].L) pos = min(pos, a[i].R); else pos = a[i].R, ++ans; &#125; printf(\"Case %d: %d\\n\", ++kase, ans); &#125; return 0; &#125; [NOIP2012 提高组] 国王游戏 Portal. 恰逢 H 国国庆，国王邀请 n(n≤1000)n(n\\le 1000)n(n≤1000) 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 nnn 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 大胆假设，小心求证：按照左右手上的数的乘积从小到大排序。 我们采用微扰法来证明，交换大臣 iii 和 i+1i+1i+1，原来的奖励是： 1B[i]∏j=0i−1A[j]A[i]B[i+1]∏j=0i−1A[j]\\frac{1}{B[i]}\\prod_{j=0}^{i-1} A[j]\\\\ \\frac{A[i]}{B[i+1]}\\prod_{j=0}^{i-1} A[j] B[i]1​j=0∏i−1​A[j]B[i+1]A[i]​j=0∏i−1​A[j] 交换后的奖励是： 1B[i+1]∏j=0i−1A[j]A[i+1]B[i]∏j=0i−1A[j]\\frac{1}{B[i+1]}\\prod_{j=0}^{i-1}A[j]\\\\ \\frac{A[i+1]}{B[i]}\\prod_{j=0}^{i-1}A[j] B[i+1]1​j=0∏i−1​A[j]B[i]A[i+1]​j=0∏i−1​A[j] 其它奖励并不变，我们只需要比较上面两个，即比较： max⁡{1B[i],A[i]B[i+1]}max⁡{1B[i+1],A[i+1]B[i]}\\max\\left\\{\\frac{1}{B[i]},\\frac{A[i]}{B[i+1]}\\right\\}\\\\ \\max\\left\\{\\frac{1}{B[i+1]},\\frac{A[i+1]}{B[i]}\\right\\} max{B[i]1​,B[i+1]A[i]​}max{B[i+1]1​,B[i]A[i+1]​} 通分得到： max⁡{B[i+1],A[i]×B[i]}max⁡{B[i],A[i+1]×B[i+1]}\\max\\{B[i+1],A[i]\\times B[i]\\}\\\\ \\max\\{B[i],A[i+1]\\times B[i+1]\\} max{B[i+1],A[i]×B[i]}max{B[i],A[i+1]×B[i+1]} 分类讨论比较大小后发现前者不会比后者差。 本题需要高精，代码偷懒了。 查看代码 n = int(input()) a, b = map(int, input().split()) ans = [] for i in range(n): ans.append([int(ii) for ii in input().split()]) ans.sort(key=lambda x: (x[0] * x[1])) s = 0 for i in range(n): s = max(s, a // ans[i][1]) a *= ans[i][0] print(s) Problemset 我们来看一些题目。 双指针 这里的双指针可能会稍微难一些。 [Luogu P5745] 数列求和 Portal. 虽然可以用二分做到 O(nlog⁡n)O(n \\log n)O(nlogn)，然而并不推荐这样做，因为还有写起来更简单跑起来也更快的 O(n)O(n)O(n) 做法。 我们先定义两个指针 l=r=1l=r=1l=r=1，如果∑i=lri&lt;m\\sum\\limits_{i=l}^{r}i &lt; mi=l∑r​i&lt;m，那么令 r++，否则令 l++，可看出数列中的每个元素都被扫了常数次，时间复杂度O(n)O(n)O(n)。 相比 O(n2)O(n^2)O(n2) 的枚举，少枚举了不少不可能成为答案的解。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #define LL long long using namespace std; inline int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48), c = getchar(); return x; &#125; int n, m; int a[4000005]; LL sum[4000005]; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(), sum[i] = sum[i-1] + a[i]; //计算前缀和 int l = 1, r = 1, L, R; LL ans = -1; while (r &lt;= n) &#123; while (sum[r] - sum[l-1] &lt;= m) &#123; if (sum[r] - sum[l-1] > ans) &#123; ans = sum[r] - sum[l-1]; L = l, R = r; &#125; ++r; &#125; ++l; &#125; printf(\"%d %d %lld\", L, R, ans); return 0; &#125; [ARC 098B] Xor Sum 2 Portal. 什么时候加和和异或和相等？只有当异或的时候不存在两个二进制位都是 111 的时候。也就是说，如果右端点固定，缩小左端点，那么这样两个二进制位都是 111 的情况是只能变少或不变，不能变多的。那么就可以使用尺取法了。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, s1, s2; int a[200005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); i64 ans = 0; for (int L = 1, R = 0; L &lt;= n; ++L) &#123; while (R &lt; n &amp;&amp; s1 + a[R + 1] == (s2 ^ a[R + 1])) ++R, s1 += a[R], s2 ^= a[R]; ans += R - L + 1; s1 -= a[L], s2 ^= a[L]; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [CEOI2017] Sure Bet Portal. 如果都取一个灯泡，我们肯定是取权值更大的更好，所以先排序。A、B 的和肯定是平均好，所以用双指针同时扫描 AB，记录当前的和，其中有一个大了就移动另一个指针。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n; double a[100005], b[100005], suma[100005], sumb[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lf%lf\", a + i, b + i); sort(a + 1, a + n + 1, greater&lt;double>()); sort(b + 1, b + n + 1, greater&lt;double>()); for (int i = 1; i &lt;= n; ++i) &#123; suma[i] = suma[i - 1] + a[i]; sumb[i] = sumb[i - 1] + b[i]; &#125; double ans = 0.0; for (int i = 1, j = 1; i &lt;= n &amp;&amp; j &lt;= n;) &#123; ans = max(ans, min(suma[i] - i - j, sumb[j] - i - j)); if (suma[i] &lt;= sumb[j]) ++i; else ++j; &#125; printf(\"%.4lf\\n\", ans); return 0; &#125; [CF939E] Maximize! Portal. 最大的肯定要选，再选若干个最小的。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> using namespace std; typedef long long i64; int n, L = -1, maxn = 0; i64 sum = 0; vector &lt;int> a; int main(void) &#123; scanf(\"%d\", &amp;n); while (n--) &#123; int op, x; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%d\", &amp;x); a.push_back(x); sum += x - maxn; maxn = x; while (L + 1 &lt; a.size() &amp;&amp; 1ll * a[L + 1] * (L + 2) &lt; sum) sum += a[++L]; &#125; else &#123; if (L == -1) puts(\"0\"); else printf(\"%.6lf\\n\", maxn - (double)sum / double(L + 2)); &#125; &#125; return 0; &#125; [NOIP2011 提高组] 选择客栈 Portal. 枚举右指针，当一个客栈可以被用来喝咖啡时，就移动左指针更新。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, k, p, t = 1; int color[200005]; int cnt[200005]; // 当前 cnt[i] 表示颜色为 i 的客栈的数目 i64 ans = 0; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;k, &amp;p); for (int i = 1, money; i &lt;= n; ++i) &#123; scanf(\"%d%d\", color + i, &amp;money); if (money &lt;= p) &#123; // 到 i 为止的客栈都可以满足喝咖啡的条件了 for (int j = t; j &lt;= i; ++j) ++cnt[color[j]]; t = i + 1; ans += cnt[color[i]] - 1; // 不能选择同一个客栈 &#125; else ans += cnt[color[i]]; &#125; printf(\"%lld\\n\", ans); return 0; &#125; 前缀和与差分 前缀和与差分很重要，出现概率很高。 [USACO05JAN] Moo Volume S Portal. 绝对值很烦人，所以考虑排序。只计算当前 iii 及以前的，最后将结果乘以二。通过找规律发现 ansi=ai×(i−1)−si−1ans_i=a_i\\times (i-1)-s_{i-1}ansi​=ai​×(i−1)−si−1​，代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n; int a[100005]; long long sum[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + a[i]; long long ans = 0; for (int i = 1; i &lt;= n; ++i) ans += (long long)a[i] * (i - 1) - sum[i - 1]; printf(\"%lld\\n\", ans * 2); return 0; &#125; [USACO16JAN] Subsequences Summing to Sevens S Portal. 区间和，前缀和！也就是说我们要使得 7∣(s[r]−s[l−1])7\\mid (s[r]-s[l-1])7∣(s[r]−s[l−1])，要求最大的 r−lr-lr−l。 根据取模的性质，可以转化为 s[r]≡s[l−1](mod7)s[r]\\equiv s[l-1] \\pmod 7s[r]≡s[l−1](mod7)，那么开两个数组 L, R，扫到 s[i]，就将其计入数组中。具体过程见代码： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int main(void) &#123; int n, x, sum = 0, ans = 0; int l[7] = &#123;0, -1, -1, -1, -1, -1, -1&#125;, r[7] = &#123;0, -1, -1, -1, -1, -1, -1&#125;; // l[i] 存 mod 7 为 i 的最小 l - 1 , r[i] 存 mod 7 为 i 的最大 r // 开始时 s[0] = 0, s[0] mod 7 = 0，所以 l[0] = r[0] = 0 scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); sum = (sum + x) % 7; // 利用随时取模性质 if (l[sum] == -1) l[sum] = i; // 第一次扫到的肯定最小 r[sum] = i; // 最后一次扫到的肯定最大 &#125; for (int i = 0; i &lt; 7; ++i) ans = max(ans, r[i] - l[i]); printf(\"%d\\n\", ans); return 0; &#125; [NOIP2012 提高组] 借教室 Portal. 借教室的这一过程很容易用差分来进行。我们只需要知道需要通知哪一个申请人修改订单。可以使用二分答案的方式来判断是哪一个人。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m, r[1000005]; int c[1000005], sum[1000005], d[1000005], s[1000005], t[1000005]; bool solve(int x) &#123; for (int i = 1; i &lt;= n; ++i) c[i] = r[i] - r[i - 1]; for (int i = 1; i &lt;= x; ++i) &#123; c[s[i]] -= d[i]; c[t[i] + 1] += d[i]; &#125; for (int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + c[i]; for (int i = 1; i &lt;= n; ++i) if (sum[i] &lt; 0) return 0; return 1; &#125; int main(void) &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) r[i] = read(); for (int i = 1; i &lt;= m; ++i) d[i] = read(), s[i] = read(), t[i] = read(); if (solve(m)) puts(\"0\"); else &#123; puts(\"-1\"); int L = 0, R = m + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (solve(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", R); &#125; return 0; &#125; [NOIP2011 提高组] 聪明的质监员 Portal. 注意到这个条件：wj≥Ww_j \\ge Wwj​≥W。WWW 越小，得到的 yyy 就越大，具有单调性，因此可以二分答案，我们只要找到 y,sy,sy,s 大小的分界点即可。现在的问题就是如何在线性时间内计算出 yyy。 前缀和就可以轻松完成。查询的内容是典型的多次查询区间和（每个 yyy 都是两个区间和相乘）。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cmath> using namespace std; using i64 = long long; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int n, m; i64 s, ans = 1000000000005; int w[200005], v[200005]; int l[200005], r[200005]; i64 sum[200005], sumv[200005]; bool P(int W) &#123; for (int i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i-1] + (w[i] >= W); sumv[i] = sumv[i-1] + (w[i] >= W ? v[i] : 0); &#125; i64 y = 0; for (int i = 1; i &lt;= m; ++i) y += (sum[r[i]] - sum[l[i] - 1]) * (sumv[r[i]] - sumv[l[i] - 1]); i64 ret = llabs(y - s); if (ret &lt; ans) ans = ret; if (y > s) return 1; else return 0; &#125; int main(void) &#123; n = read(), m = read(); cin >> s; int minw = 1000005, maxw = 0; for (int i = 1; i &lt;= n; ++i) &#123; w[i] = read(), v[i] = read(); minw = min(minw, w[i]); maxw = max(maxw, w[i]); &#125; for (int i = 1; i &lt;= m; ++i) l[i] = read(), r[i] = read(); int L = minw - 1, R = maxw + 1; while (L + 1 != R) &#123; int mid = L + R >> 1; if (P(mid)) L = mid; else R = mid; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [USACO07MAR] Face The Right Way G Portal. 注意到数据范围只有 500050005000，容易想到要用一个 O(n2)O(n^2)O(n2) 算法，我们可以枚举 KKK，问题就变成了如何在线性时间内计算这个 KKK 能否完成任务。 从前到后进行扫描。如果遇到了一个 B，那么肯定要进行以它为起点的翻转，否则扫描到后面它就再也无力翻身了。这样可以进行模拟，时间复杂度为 O(n2)O(n^2)O(n2)，需要进行优化。 考虑差分。差分还可以这么做：建立另一个数组来记录变化，而不是对着原序列进行差分。由于只有 0, 1 两种数，我们可以用异或来简化运算。设 b[i]b[i]b[i] 代表 iii 以后的元素都要异或上 b[i]b[i]b[i]，给 [i,i+k−1][i, i + k - 1][i,i+k−1] 进行翻转，只需要 b[i] ^= 1, b[i + k] ^= 1 即可，另外再用一个 c 记录当前的状态，来判断当前扫描到的是 1 还是 0。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; int n; int a[5005], b[5005]; int main(void) &#123; scanf(\"%d\", &amp;n); char s[5]; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", s); a[i] = (s[0] == 'F'); &#125; int mink = 0, minres = 1000000; for (int k = 1; k &lt;= n; ++k) &#123; memset(b, 0, sizeof(b)); bool c = 0, flag = true; int res = 0; for (int i = 1; i &lt;= n; ++i) &#123; c ^= b[i]; if ((a[i] ^ c) == 0) &#123; if (i + k - 1 > n) &#123; flag = false; break; &#125; b[i] ^= 1, b[i + k] ^= 1; c ^= 1, ++res; &#125; &#125; if (flag &amp;&amp; res &lt; minres) minres = res, mink = k; &#125; printf(\"%d %d\\n\", mink, minres); return 0; &#125; [Poetize6] IncDec Sequence Portal. 区间加减这种操作已经很熟悉了，肯定是把原序列做成差分序列进行计算，问题就变成了：给定一个序列 BBB，可以每次选择一对数，一个 +1，一个 -1，使得 B2⋯BnB_2\\cdots B_nB2​⋯Bn​ 都为 000。注意 B1B_1B1​ 对结果没有影响，我们计算时也可以选择 Bn+1B_{n+1}Bn+1​。 我们尽可能地选择 B2⋯BnB_2\\cdots B_nB2​⋯Bn​ 进行操作，这样可以尽快地接近目标。还有剩余怎么办？那就跟 B1B_1B1​ 或 Bn+1B_{n+1}Bn+1​ 配对就可以了。设 B2⋯BnB_2\\cdots B_nB2​⋯Bn​ 中正数和为 ppp，负数和为 qqq，则前者可以进行 min⁡(p,q)\\min(p,q)min(p,q) 次，后者进行 ∣p−q∣\\left|p-q\\right|∣p−q∣ 次，总共是 max⁡(p,q)\\max(p,q)max(p,q) 次。根据是否选择 B1B_1B1​ 进行配对，得到的序列共有 ∣p−q∣+1\\left|p-q\\right|+1∣p−q∣+1 种。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;cmath> using namespace std; using i64 = long long; int n; i64 a[100005], b[100005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) b[i] = a[i] - a[i - 1]; int p = 0, q = 0; for (int i = 2; i &lt;= n; ++i) if (b[i] >= 0) p += b[i]; else q -= b[i]; printf(\"%lld\\n%lld\\n\", max(p, q), abs(p - q) + 1); return 0; &#125; [CF1700C] Helping the Nature Portal. 给定一个长度为 nnn 的序列 AAA，支持以下三种操作：将 A1,…,AiA_1,\\dots,A_iA1​,…,Ai​ 都减去一；将 Ai,…,AnA_i,\\dots,A_nAi​,…,An​ 都减去一；全局加上一。 将序列差分，那么前两种操作对应： Bi+1B_{i+1}Bi+1​ 加上一； BiB_{i}Bi​ 减去一。 那么除了第一个数，剩下的所有数我们都可以将其变成 000，这样序列中的所有数都相等，把第一个数作为“标准”进行维护即可。 查看代码 #include &lt;bits/stdc++.h> using namespace std; typedef long long i64; int n; int a[200005], b[200005]; void solve(void) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) &#123; cin >> a[i]; b[i] = a[i] - a[i - 1]; &#125; i64 ans = 0, h = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; ans += abs(b[i]); if (b[i] &lt; 0) h += b[i]; &#125; cout &lt;&lt; ans + abs(h) &lt;&lt; \"\\n\"; &#125; int main(void) &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) solve(); return 0; &#125; [USACO07JAN] Tallest Cow S Portal. 要求所有的奶牛都尽可能的高。因此给了 a,ba,ba,b，就意味着它们之间的奶牛都比他们低 111，用差分维护即可。注意可能有重复的条件，所以要用一个 set 判重。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;set> #include &lt;algorithm> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; int n, p, h, r, d[10005], s[10005]; set &lt;pii> us; int main(void) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;p, &amp;h, &amp;r); while (r--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if (a > b) swap(a, b); if (us.find(make_pair(a, b)) != us.end()) continue; us.insert(make_pair(a, b)); --d[a + 1], ++d[b]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; s[i] = s[i - 1] + d[i]; printf(\"%d\\n\", s[i] + h); &#125; return 0; &#125; [Codeforcs 1703F] Yet Another Problem About Pairs Satisfying an Inequality Portal. 对不等式进行拆解，得到 ai&lt;ia_i&lt;iai​&lt;i，aj&lt;ja_j&lt;jaj​&lt;j 和 i&lt;aji &lt; a_ji&lt;aj​ 三个不等式。前两个很容易判断，第三个考虑暴力算法，枚举 i,ji,ji,j 可以轻松得到答案。 对此进行优化。i&lt;aji &lt; a_ji&lt;aj​ 变形为 aj≥i+1a_j\\ge i+1aj​≥i+1（因为都是整数）。 除了前缀和，还有后缀和，就是表示它后面而不是前面的和。aj≥i+1a_j\\ge i+1aj​≥i+1 具有明显的这种性质，要求的就是满足这个条件的数的个数，维护即可。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; using i64 = long long; int n, t; int a[200005]; i64 sum[200005]; int main(void) &#123; scanf(\"%d\", &amp;t); while (t--) &#123; memset(sum, 0, sizeof(sum)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] &lt; i) ++sum[a[i]]; // 满足基本条件，将这个 sum +1 &#125; for (int i = n; i >= 1; --i) // 计算后缀和 sum[i] += sum[i + 1]; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &lt; i) ans += sum[i + 1]; // a[j] >= i+1 printf(\"%lld\\n\", ans); &#125; return 0; &#125; [USACO11MAR] Brownie Slicing G Portal. 切的刀越多，每头牛分的就越少，满足单调性，考虑二分答案。 二分 Bessie 能得到的碎屑数目。通过暴力计算使得其它奶牛分的数目都大于等于她，若最后横着切的刀数大于 aaa（说明这些蛋糕够分给更多的奶牛，Bessie 分少了），就可以。其中需要用二维前缀和来优化。代码如下： 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int read(void) &#123; int x = 0, c = getchar_unlocked(); while (!isdigit(c)) c = getchar_unlocked(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar_unlocked(); return x; &#125; int r, c, a, b; int s[505][505]; int calc(int x1, int y1, int x2, int y2) &#123; return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; &#125; bool P(int x) &#123; int cuta = 0, row = 1; for (int i = 1; i &lt;= r; ++i) &#123; int col = 1, cutb = 0; for (int j = 1; j &lt;= c; ++j) &#123; if (calc(row, col, i, j) >= x) col = j + 1, ++cutb; &#125; if (cutb >= b) ++cuta, row = i + 1; &#125; return cuta >= a; &#125; int main(void) &#123; r = read(), c = read(), a = read(), b = read(); for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + read(); int L = -1 , R = s[r][c] + 1; while (L + 1 != R) &#123; int mid = (L + R) / 2, ss; if (P(mid)) L = mid; else R = mid; &#125; printf(\"%d\\n\", L); return 0; &#125; 单调栈 比较简单。 [USACO06NOV] Bad Hair Day S Portal. 可以看出这是一个单调栈，每个数的答案就是栈的大小。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; typedef long long i64; int n, tot; int a[80005], s[80005]; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); i64 ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (tot &amp;&amp; s[tot] &lt;= a[i]) --tot; ans += tot; s[++tot] = a[i]; &#125; printf(\"%lld\\n\", ans); return 0; &#125; [POI2008] PLA-Postering Portal. 注意到宽度与答案没有关系，而高度相同的可以使用一张海报。我们使用单调栈来进行维护，如果进来了一个元素不比栈顶大，那么是有机会合并的。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n; int w[250005]; int s[250005], tot = 0; int main(void) &#123; scanf(\"%d\", &amp;n); for (int i = 1, d; i &lt;= n; ++i) scanf(\"%d%d\", &amp;d, w + i); int ans = n; for (int i = 1; i &lt;= n; ++i) &#123; while (tot &amp;&amp; w[i] &lt;= s[tot]) &#123; if (w[i] == s[tot]) --ans; --tot; &#125; s[++tot] = w[i]; &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1950] 长方形 Portal. 从上到下扫描每一行，统计“向上最多能延伸的高度”，然后找到左面第一个比它小的，右面第一个小于等于的，就可以计算出当前贡献。单调栈可以完成这一过程。 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; typedef long long i64; int n, m, h[1005], l[1005], r[1005]; int s[1005], tot = 0; bool a[1005][1005]; i64 ans = 0; void work(void) &#123; tot = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (tot &amp;&amp; h[i] &lt;= h[s[tot]]) --tot; l[i] = tot ? s[tot] : 0; s[++tot] = i; &#125; tot = 0; for (int i = m; i >= 1; --i) &#123; while (tot &amp;&amp; h[i] &lt; h[s[tot]]) --tot; r[i] = tot ? s[tot] : m + 1; s[++tot] = i; &#125; for (int i = 1; i &lt;= m; ++i) ans += h[i] * (i - l[i]) * (r[i] - i); &#125; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; char c = getchar(); while (c != '.' &amp;&amp; c != '*') c = getchar(); a[i][j] = (c == '*'); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; h[j] += 1; if (a[i][j]) h[j] = 0; &#125; work(); &#125; printf(\"%lld\\n\", ans); return 0; &#125; 单调队列 其实就是多了个排除不合法时间功能的单调栈。 [Luogu P1714] 切蛋糕 Portal. 这是经典的要求长度的最大子段和问题，我们枚举右端点，利用滑动窗口维护目前遇到过的最小的 S[l−1]S[l-1]S[l−1] 即可。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, m; int a[500005], sum[500005]; int L = 1, R = 0, Q[500005]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), sum[i] = sum[i - 1] + a[i]; int ans = -1e9; Q[++R] = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (L &lt;= R &amp;&amp; Q[L] + m &lt; i) ++L; ans = max(ans, sum[i] - sum[Q[L]]); while (L &lt;= R &amp;&amp; sum[Q[R]] >= sum[i]) --R; Q[++R] = i; &#125; printf(\"%d\\n\", ans); return 0; &#125; [Luogu P1419] 寻找段落 Portal. 显然可以二分。 如何实现 check(x)？条件是 s[l…r]≥x×(r−l+1)s[l\\dots r]\\ge x\\times (r-l+1)s[l…r]≥x×(r−l+1)，那么就将序列整个减去 xxx，用单调队列判断是否存在一个和大于等于零的子段。 查看代码 #include &lt;iostream> #include &lt;cstdio> using namespace std; int n, a[100005]; double S[100005]; int s, t; int Q[100005], L = 1, R = 0; bool calc(double x) &#123; L = 1, R = 0; for (int i = 1; i &lt;= n; ++i) S[i] = S[i - 1] + a[i] - x; for (int i = s; i &lt;= n; ++i) &#123; while (L &lt;= R &amp;&amp; S[Q[R]] >= S[i - s]) --R; while (L &lt;= R &amp;&amp; Q[L] &lt; i - t) ++L; Q[++R] = i - s; if (L &lt;= R &amp;&amp; S[i] - S[Q[L]] >= 0) return true; &#125; return false; &#125; int main(void) &#123; scanf(\"%d%d%d\", &amp;n, &amp;s, &amp;t); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); double L = -10000, R = 10000; for (int op = 0; op &lt; 200; ++op) &#123; double mid = (L + R) / 2; if (calc(mid)) L = mid; else R = mid; &#125; printf(\"%.3lf\\n\", R); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"单调队列","slug":"单调队列","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"双指针","slug":"双指针","permalink":"https://james1badcreeper.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"前缀和","slug":"前缀和","permalink":"https://james1badcreeper.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"https://james1badcreeper.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"单调栈","slug":"单调栈","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"[Luogu2671][NOIP2015 普及组] 求和","slug":"default/old/LuoguP2671","date":"2022-07-18T00:00:00.000Z","updated":"2022-07-18T00:00:00.000Z","comments":true,"path":"e1d941a1/","link":"","permalink":"https://james1badcreeper.github.io/e1d941a1/","excerpt":"一道找规律与推导的题目。","text":"一道找规律与推导的题目。 题目 Portal. 展开题目 题目描述输入输出格式输入输出样例样例说明一条狭长的纸带被均匀划分出了nnn个格子，格子编号从111到nnn。每个格子上都染了一种颜色coloricolor_icolori​用[1,m][1,m][1,m]当中的一个整数表示），并且写了一个数字numberinumber_inumberi​。定义一种特殊的三元组：(x,y,z)(x,y,z)(x,y,z)，其中x,y,zx,y,zx,y,z都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：xyzxyzxyz是整数,x&lt;y&lt;z,y−x=z−yx&lt;y&lt;z,y-x=z-yx&lt;y&lt;z,y−x=z−ycolorx=colorzcolorx=colorzcolorx=colorz满足上述条件的三元组的分数规定为(x+z)×(numberx+numberz)(x+z) \\times (number_x+number_z)(x+z)×(numberx​+numberz​)。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以10,00710,00710,007所得的余数即可。 输入格式 第一行是用一个空格隔开的两个正整数nnn和m,nm,nm,n表纸带上格子的个数，mmm表纸带上颜色的种类数。第二行有nnn用空格隔开的正整数，第iii数字numbernumbernumber表纸带上编号为iii格子上面写的数字。第三行有nnn用空格隔开的正整数，第iii数字colorcolorcolor表纸带上编号为iii格子染的颜色。 输出格式 一个整数，表示所求的纸带分数除以100071000710007所得的余数。 样例输入#16 25 5 3 2 2 22 2 1 1 2 1样例输出#182样例输入#215 45 10 8 2 2 2 9 9 7 7 5 6 4 2 42 2 3 3 4 3 3 2 4 4 4 4 1 1 1样例输出#21388【输入输出样例 1 说明】纸带如题目描述中的图所示。所有满足条件的三元组为： (1,3,5),(4,5,6)(1, 3, 5), (4, 5, 6)(1,3,5),(4,5,6)。所以纸带的分数为(1+5)×(5+2)+(4+6)×(2+2)=42+40=82(1 + 5) \\times (5 + 2) + (4 + 6) \\times (2 + 2) = 42 + 40 = 82(1+5)×(5+2)+(4+6)×(2+2)=42+40=82。对于第 111 组至第 222 组数据， 1≤n≤100,1≤m≤51 \\le n \\le 100, 1 \\le m \\le 51≤n≤100,1≤m≤5；对于第 333 组至第 444 组数据， 1≤n≤3000,1≤m≤1001 \\le n \\le 3000, 1 \\le m \\le 1001≤n≤3000,1≤m≤100；对于第 555 组至第 666 组数据， 1≤n≤100000,1≤m≤1000001 \\le n \\le 100000, 1 \\le m \\le 1000001≤n≤100000,1≤m≤100000，且不存在出现次数超过 202020 的颜色；对于全部 101010 组数据 ， 1≤n≤100000,1≤m≤100000,1≤colori≤m,1≤numberi≤1000001 \\le n \\le 100000, 1 \\le m \\le 100000, 1 \\le color_i \\le m,1\\le number_i\\le 1000001≤n≤100000,1≤m≤100000,1≤colori​≤m,1≤numberi​≤100000 解答 x&lt;y&lt;z,y−x=z−yx&lt;y&lt;z,y-x=z-yx&lt;y&lt;z,y−x=z−y 表示的显然是距离相等，也就是 yyy 是 x,zx,zx,z 的平均数，而且 yyy 是个整数，所以 x,zx,zx,z 奇偶性相同，分别进行计算即可。 又因为颜色与答案无关，所以颜色也可以分别计算。现在的问题就转化为了求： ∑i=1n∑j=i+1n(Ai+Aj)(Bi+Bj)\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=i+1}^{n}(A_i+A_j)(B_i+B_j) i=1∑n​j=i+1∑n​(Ai​+Aj​)(Bi​+Bj​) 展开后会发现当中有 n−1n-1n−1 个 AiBiA_i B_iAi​Bi​，和所有 A,BA,BA,B 相乘。利用多项式乘法的特性，可得原式等于： ∑i=1nAi×∑i=1nBi+∑i=1n(n−2)AiBi\\sum\\limits_{i=1}^{n}A_i \\times \\sum\\limits_{i=1}^{n}B_i + \\sum\\limits_{i=1}^{n}(n-2)A_iB_i i=1∑n​Ai​×i=1∑n​Bi​+i=1∑n​(n−2)Ai​Bi​ 代码就很简单了： 查看代码 #include &lt;iostream> #include &lt;cstdio> #include &lt;vector> #define pii pair&lt;int, int> #define X first #define Y second using namespace std; const int MOD = 10007; int n, m; int number[100005], color[100005]; vector &lt;pii> v[100005][2]; int main(void) &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", number + i), number[i] %= MOD; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", color + i); for (int i = 1; i &lt;= n; ++i) v[color[i]][i &amp; 1].push_back(make_pair(i, number[i])); int ans = 0; for (int op = 0; op &lt; 2; ++op) &#123; for (int i = 1; i &lt;= m; ++i) &#123; int R = v[i][op].size(); if (R >= 2) &#123; int res = 0, ret = 0; for (int j = 0; j &lt; R; ++j) res = (res + v[i][op][j].X) % MOD, ret = (ret + v[i][op][j].Y) % MOD; ans = (ans + res * ret % MOD) % MOD; for (int j = 0; j &lt; R; ++j) ans = (ans + (R - 2) % MOD * v[i][op][j].X % MOD * v[i][op][j].Y % MOD) % MOD; &#125; &#125; &#125; printf(\"%d\\n\", ans); return 0; &#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"找规律","slug":"找规律","permalink":"https://james1badcreeper.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"解题","slug":"解题","permalink":"https://james1badcreeper.github.io/tags/%E8%A7%A3%E9%A2%98/"}]},{"title":"Codeforces Round #806 Div.4 解题记录","slug":"default/old/cf806-4","date":"2022-07-15T00:00:00.000Z","updated":"2022-07-15T00:00:00.000Z","comments":true,"path":"a947015c/","link":"","permalink":"https://james1badcreeper.github.io/a947015c/","excerpt":"回归 OI 了！打算用这套题来练手，来找一找感觉，然后开始学习。","text":"回归 OI 了！打算用这套题来练手，来找一找感觉，然后开始学习。 这是一场 Div.4，难度较低。 A. YES or YES? Portal. 利用常量数组可以简单地实现。以此判断三个字母，代码如下： #include &lt;iostream> #include &lt;string> #include &lt;cstdio> using namespace std; int main(void) &#123; const string a = \"YES\", b = \"yes\"; int t; cin >> t; while (t--) &#123; string s; bool flag = true; cin >> s; for (int i = 0; i &lt; 3; ++i) if (s[i] != a[i] &amp;&amp; s[i] != b[i]) flag = false; if (flag) puts(\"YES\"); else puts(\"NO\"); &#125; return 0; &#125; B. ICPC Balloons Portal. 利用一个数组记录这个字母之前是否出现过即可，代码如下： #include &lt;iostream> #include &lt;string> #include &lt;cstring> using namespace std; int main(void) &#123; int T, n; string s; bool flag[30]; cin >> T; while (T--) &#123; cin >> n >> s; int ans = 0; memset(flag, 0, sizeof(flag)); for (int i = 0; i &lt; n; ++i) &#123; if (!flag[s[i] - 'A']) ++ans, flag[s[i] - 'A'] = true; ++ans; &#125; cout &lt;&lt; ans &lt;&lt; '\\n'; &#125; return 0; &#125; C. Cypher Portal. 按顺序模拟即可，代码如下： #include &lt;iostream> #include &lt;cstdio> #include &lt;string> using namespace std; int main(void) &#123; int T, n, b, a[105]; cin >> T; string s; while (T--) &#123; cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> a[i]; for (int i = 1; i &lt;= n; ++i) &#123; cin >> b >> s; for (int j = 0; j &lt; b; ++j) &#123; a[i] += (s[j] == 'D') ? (1) : (-1); if (a[i] == 10) a[i] = 0; if (a[i] == -1) a[i] = 9; &#125; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; putchar('\\n'); &#125; return 0; &#125; D. Double Strings Portal. 注意到字符串的长度很短，直接枚举前缀同时计算后缀，再利用集合（当然可以写字符串哈希）判断是否存在即可。代码如下： #include &lt;iostream> #include &lt;string> #include &lt;unordered_set> using namespace std; string s[100005]; unordered_set &lt;string> us; int main(void) &#123; ios::sync_with_stdio(false); cin.tie(0); int t, n; cin >> t; while (t--) &#123; us.clear(); cin >> n; for (int i = 1; i &lt;= n; ++i) cin >> s[i], us.insert(s[i]); for (int i = 1; i &lt;= n; ++i) &#123; bool flag = false; string a = \"\", b = s[i]; for (int j = 0; j &lt; s[i].length() - 1; ++j) &#123; a += s[i][j], b.erase(b.begin()); if (us.find(a) != us.end() &amp;&amp; us.find(b) != us.end()) &#123; flag = true; break; &#125; &#125; putchar(flag ? '1' : '0'); &#125; putchar('\\n'); &#125; return 0; &#125; E. Mirror Grid Portal. 经典题。找规律找到旋转后的坐标，模拟即可。 #include &lt;cstdio> #include &lt;string> #include &lt;iostream> using namespace std; bool a[105][105]; int main(void) &#123; int t, n; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%d\", &amp;n); string s; for (int i = 0; i &lt; n; ++i) &#123; cin >> s; for (int j = 0; j &lt; n; ++j) a[i][j] = s[j] - '0'; &#125; int ans = 0; for (int i = 0; i &lt; n / 2 + 1; ++i) for (int j = 0; j &lt; n / 2 + 1; ++j) &#123; int s = a[i][j] + a[j][n - i - 1] + a[n - i - 1][n - j - 1] + a[n - j - 1][i]; if (s &lt;= 2) &#123; a[i][j] = a[j][n - i - 1] = a[n - i - 1][n - j - 1] = a[n - j - 1][i] = 0; ans += s; &#125; else &#123; a[i][j] = a[j][n - i - 1] = a[n - i - 1][n - j - 1] = a[n - j - 1][i] = 1; ans += 4 - s; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125; F. Yet Another Problem About Pairs Satisfying an Inequality Portal. 对不等式进行拆解，得到 ai&lt;ia_i&lt;iai​&lt;i，aj&lt;ja_j&lt;jaj​&lt;j 和 i&lt;aji &lt; a_ji&lt;aj​ 三个不等式。考虑暴力算法，枚举 i,ji,ji,j 可以轻松得到答案。 对此进行优化。i&lt;aji &lt; a_ji&lt;aj​ 变形为 aj≥i+1a_j\\ge i+1aj​≥i+1（因为都是整数），满足这个条件的数的个数具有单调性，可以用一个 sum 数组记录，维护后缀和即可。 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> using namespace std; using i64 = long long; int n, t; int a[200005]; i64 sum[200005]; int main(void) &#123; scanf(\"%d\", &amp;t); while (t--) &#123; memset(sum, 0, sizeof(sum)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); if (a[i] &lt; i) ++sum[a[i]]; // 满足基本条件，将这个 sum +1 &#125; for (int i = n; i >= 1; --i) // 计算后缀和 sum[i] += sum[i + 1]; i64 ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &lt; i) ans += sum[i + 1]; // a[j] >= i+1 printf(\"%lld\\n\", ans); &#125; return 0; &#125; G. Good Key, Bad Key Portal. 用 Bad Key 减半这种事情越在后面发生越好。因为 ⌊Ai2⌋+⌊Ai+12⌋−k≤⌊Ai⌋+⌊Ai+12⌋−k\\left\\lfloor \\cfrac{A_i}{2}\\right\\rfloor + \\left\\lfloor \\cfrac{A_{i+1}}{2}\\right\\rfloor - k \\le \\left\\lfloor A_i\\right\\rfloor + \\left\\lfloor \\cfrac{A_{i+1}}{2}\\right\\rfloor - k⌊2Ai​​⌋+⌊2Ai+1​​⌋−k≤⌊Ai​⌋+⌊2Ai+1​​⌋−k 恒成立。 交替使用 Good Key, Bad Key 没有意义。理由基本同上，在 Bad Key 后面出现一个 Good Key 不如将这个 Good Key 移到 Bad Key 前。花费的钱都是 kkk，而先用 Good Key 却能避免第一个箱子中钱减半的惨案。 而且用了 303030 个 Bad Key 之后就无意义了。因为 230&gt;1092^{30} &gt; 10^9230&gt;109。 #include &lt;iostream> #include &lt;cstdio> using namespace std; using i64 = long long; const i64 MAX = 1000000005; int read(void) &#123; int x = 0, c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x; &#125; int n, k; int a[100005]; int main(void) &#123; int t = read(); while (t--) &#123; n = read(), k = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); i64 ans = 0, res = 0; for (int i = 0; i &lt;= n; ++i) &#123; if (i >= 1) res += a[i] - k; i64 ret = 1, cur = 0; for (int j = i + 1, R = min(n, i + 31); j &lt;= R; ++j) // 为防止出错，开了 31 cur += a[j] / (ret *= 2); ans = max(ans, res + cur); &#125; printf(\"%lld\\n\", ans); &#125; return 0; &#125; 总结 主要是考察了一些编程基本功，练一下手还是不错的。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"比赛记录","slug":"算法竞赛/比赛记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"},{"name":"比赛","slug":"比赛","permalink":"https://james1badcreeper.github.io/tags/%E6%AF%94%E8%B5%9B/"},{"name":"Div.4","slug":"Div-4","permalink":"https://james1badcreeper.github.io/tags/Div-4/"}]},{"title":"记 2022 大连中考","slug":"summaries/游记/中考","date":"2022-07-15T00:00:00.000Z","updated":"2022-07-15T00:00:00.000Z","comments":false,"path":"3f40bc15/","link":"","permalink":"https://james1badcreeper.github.io/3f40bc15/","excerpt":"大连中考满分 695 分，其中语数各 150 分，英语 140 分，理综 160 分（物理 90，化学 70），体育 50 分，等级学科累计成绩 45 分。由于辽宁是信息学竞赛的弱省，大连市唯一一所可以打信竞的学校就是大连市第二十四中学，同时是全市最优秀的高中，清北率高达 10%。我大概就是要考这里。","text":"大连中考满分 695 分，其中语数各 150 分，英语 140 分，理综 160 分（物理 90，化学 70），体育 50 分，等级学科累计成绩 45 分。由于辽宁是信息学竞赛的弱省，大连市唯一一所可以打信竞的学校就是大连市第二十四中学，同时是全市最优秀的高中，清北率高达 10%。我大概就是要考这里。 我所在的初中是一所四流初中，所以考二十四就是抢指标。而且我语文奇烂，可能会有意想不到的困难。 寒假的最后 为了中考停止了竞赛，并去了一趟书城看教辅。不得不说大连这里教辅是真的多（除非同时做理想树和万唯）。大连这里的两个教辅品牌”学习之星“和”点石成金“已经够忙活了。 点石成金的《中考冲刺》（用于一二轮复习的大本）是我们的寒假作业。大概长这样： 以上展示了几本，有的找不到了（或者是在班级卖废品了） 所以，要开战了。 开始了？ 明明开学了，但感觉还是没开学。 开学了 和预想的不一样，老师并没有花大量的时间说明中考的重要性（因为我们是小班），很快地进入了正题。开始讲没有讲完的课（数学已经讲完了）。 告诉了我们理化实验和计算机不考了，总共 15 分送给我们了。 开学典礼什么的还是照常有，也记不清了。 突来的疫情 才开学两周，大连就又出现了疫情。这可不是一个好事情。本来我们在初一、初二已经因为疫情停了好多课了。现在在初三下停课，只能说是对自律性的一次考验吧。 网课期间班主任老师通过钉钉看我们自习到晚 10 点，让我多学了不少东西（因为自习的时候化学老师经常过来讲课，恰好我化学很差）。 又买了不少卷子做。包括学习之星的《领跑》： 定位跟《中考冲刺》差不多，这里有的是作业，有的是自己做的 还有学习之星的《备考》： 跟万唯的《试题研究》很像，都是研究真题，每科附赠四套模拟卷 学习之星的《星阅读》： 语文很差，买了这个 还有学习之星的《必刷卷》： 一科十套卷，配单色答题卡，只展示了三本，剩下两本丢了 还有一些奇奇怪怪的卷子，找不到了，这里不放图了。 同学说点石成金的《大连中考冲刺模拟试卷》不错，一科八套卷，但实在是做不过来了（手里这些还没做完）。 复课如此艰难 本来是四月中旬复课，但是核酸检测时又查出了个阳性，于是又停了一周课，终于复学了。 老师告诉我们一周后就靠甘区模拟（双基测试），这才开始慌了。这就考试了？我真的没有想到。 好消息是，老师告诉我们体育和英语听力不考了，直接送 35 分。 模拟考试 万众期待的模拟考试来了！！！ 甘区模拟 四月末就直接是甘区模拟，说是为五月十一日的市一模做准备。九上期末年级排名第七，而二十四中只有四个指标，也就是说必须进年级前 4。 最后分数大概是这样的： 语文 数学 外语 物理 化学 总分（加 95） 121 135 131 82 65 629 结果还是年级第七。不得不说这个分数真的很烂，接着努力吧。 一模的胜利 感觉答的不是很好，但是没想到最后排到了年级第二，高兴了好一阵子。 语文 数学 外语 物理 化学 总分（加 95） 129 139.5 131 88 60 642.5 然后老师开始定卷了！包括学习之星《中考决胜卷》、点石成金《中考冲刺仿真测试卷》和《源创思维》。卷真多。 二模的失败 本来听说没有二模，结果二模又出现了。想好好答然后使得其他人不敢报二十四，结果过于紧张，直接干到了年级第十六。 语文 数学 外语 物理 化学 总分（加 95） 125 140 128 88 63 639 决胜中考 还剩二十多天就中考了，加油吧。 押题卷 不出意外的，点石成金和学习之星各出了一套押题卷（类似万唯的黑白卷），买了一套复印了一套，只能说是一个心理安慰吧。 最后的备考 体活的时候也留在教室写题，很痛苦。 壮行仪式 为初三壮行。我们老师还给我们发了红包，百事可乐，手环和金榜题名的口罩。甚至学校还给了士力架。希望能考好吧。 中考游记 真的开始紧张了。 Day 1 上午考语文，下午考理综。 语文感觉还行？理综还是很有自信的，毕竟二模失利之后刷了那么多卷子，感觉没有任何问题。 Day 2 上午考数学，下午考英语。 数学只有 26(3) 没做出来（太难算了），但是感觉做出来的人应该很少，不太要紧。 英语很简单（肯定比源创思维的死卷简单），作文认真地打了草稿，感觉挺好。 Day 3 虽然这天下雨，但是没什么感觉（甚至连伞都没拿就进了考场）。考政治历史，而且是开卷考试，胡乱作答就满分了。 考后焦虑症 最可怕的事情是，明明感觉超长发挥了，却还是考不上。 考完了？ 一直很焦虑。虽然感觉答得没什么问题，但是总感觉考不上。 烦躁的心情加上炎热的天气，根本睡不着。 甚至有一次做梦梦到我语文作文只写了 53 分（满分 70），直接吓醒。 上山咯！ 班主任老师领我们上山，心情好了不少。这里仅放一张照片这张照片是用万元级的专业相机照的，但是因为压缩而效果查了许多： 我们班报二十四的四位同学中的三位，另一位重感冒没来 《高考必刷题》 因为某些原因，准高一就买了《高考必刷题》，看到这么一段话： 高考，无非就是很多人同时做同一份卷子然后决定去哪一座城和谁走四年和谁走一辈子最终发现错的每一道题都是为了遇见对的人而对的每一道题让你遇见更好的自己 中考大概也是这个道理吧。 出分了 出分前出门了，想在外面查分。结果如下： 查看分数 查分的时候真的手抖这个语文分……语文还是太差了，高中必须认真学了！语文作文得了 53.5，太巧了吧 看到这个分的时候真感觉凉了。但是问了其他人的成绩之后进行比较，发现居然上了！ 真没想到，真没想到…… 但是这个分数去了也要被虐吧，高中需要更加努力才行。 录取结果 查看录取结果 不负众望？考前还信誓旦旦能统招，结果……统招线高达 667.5…… 总结 高一高二的时候就要按高三的状态学习，否则还会像中考时那样手忙脚乱、内心焦虑。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"Goodbye 2021, Hello 2022!","slug":"summaries/hello2022","date":"2021-12-31T00:00:00.000Z","updated":"2021-12-31T00:00:00.000Z","comments":false,"path":"bec2b773/","link":"","permalink":"https://james1badcreeper.github.io/bec2b773/","excerpt":"再见，2021。你好，2022！","text":"再见，2021。你好，2022！ 引子 班级搞了新年联欢会，而且我是 1 月份生日，老师直接给我们开生日派对，不过真的挺开心的。 借此，就在这里写一些奇谈鬼论吧。 回首 真的就这么过去了。时间是最恨的东西，在转瞬间就杀掉了一切。这一年得到了什么？可能真说不出口。自己想要达成的目标没有达成，但时间不在乎这一切。它只是无声地飞，而且飞得越来越快。 但时间流逝的迹象还是出现了：是我们教室的中考倒计时（顺带一提，那玩意儿还是我写的），它从 300 多天转瞬变成了 90 天（300 天是指总时间，90 天是在校时间，这个建议是化学老师提的，在此致敬）。中考离自己越来越近了，再没有勇气说“我还有时间”了，按这个时间流逝的速度，可能真的就，一眨眼，即是中考。 未来 虽然就在不到两个小时之后就会发生，但该考虑的事情还是需要考虑的。虽然从纪年上来看明年会是二逼的一年（雾），但仍希望自己能不忘初心，砥砺前行。 在此简单列一下明年要干的事情，按重要度排序： 统招二十四中（二十四是我们市唯一搞 OI 的最好重点，而且信竞也是全省最强（虽然在全国还是很弱） 完成 OI 计划内容（在个人文件夹里，不公开） 读一些书，可能寒假期间会在这个博客里开一个读书计划 学习高中的物理，以及高等数学线性代数的部分重要内容，阅读科普性量子力学的书 看起来不多，但也够忙好一阵子的了。 报一下结果，一个东西都没有完成。不过二十四是上了（指标）。 最后 这篇文章在匆忙中写下，也没什么内容。最后祝愿大家在 2022 能找到新的自己，实现景阳冈打虎的梦想，为自己争取一个更美好的未来！","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"CSP-S2021 游记","slug":"summaries/游记/CSP2021","date":"2021-10-19T00:00:00.000Z","updated":"2021-10-19T00:00:00.000Z","comments":false,"path":"16c563fe/","link":"","permalink":"https://james1badcreeper.github.io/16c563fe/","excerpt":"CSP-S 2021 的智障爆零选手的游记，坐标：LN。","text":"CSP-S 2021 的智障爆零选手的游记，坐标：LN。 初赛 几乎忘光了，写啥是啥吧。 考试那天下着小雨，rp– 总感觉题目很不正常，比如出现了 base64，笛卡尔树 Θ(n)\\Theta(n)Θ(n) 求 RMQ 等奇怪的问题（笛卡尔树那题我好像完美的避开了正确答案，不愧是（语气词）苦力怕）。 但即使感觉自己什么都答错了，还是考了 67.567.567.5，好像比去年低了…… 国庆期间 报名了洛谷秋令营，质量肯定是没问题（不是广告），但我好像太蠢了有些东西明明夏令营讲了秋令营再讲一遍居然也没听懂（数论是罪魁祸首 看来这次并不会比去年顺利了，加油吧…… Day -5（10/18） 尝试写 UVA10966 3KP-BASH Project，结果才写了大概一百行就写不动了（这才写了个框架 感觉越来越不妙（拿不到前 20%20\\%20% 了，之前还幻想前 10%10\\%10%，唉……） Day -4（10/19） 感觉很不好，于是写下了这篇游记，作为颓废时的快乐（ 怎么感觉自己还是什么都不会啊（ Day -3（10/20） 因为考试前总得写大模拟，所以写了 [CSP-S2020] 儒略日，终于写过了，实在不想写 3KP-BASH Project 了😥。 Day -2（10/21） Windows Subsystem For Android 公测了！但是我是 dev，所以折腾了好长时间。 搞完没剩多少时间了，所以开始过模板。 Day -1 颓废。 CSP 2021 RP++。 Day 1 考的是 S 组，而且跟考场同市，所以出发前还有一点时间写下了这点文字。RP++，Score++。 考试前又睡了一个小时。 另说一句，我之前一直以为 nth_element 是 log⁡\\loglog 复杂度…… 我们 14:30 才进的考场，延迟五分钟考试，刚打完 VScode 的代码片段就开始了。 T1 看了之后感觉不对劲，先写了 O(n2m)\\mathcal{O}(n^2m)O(n2m) 的暴力，后来想用优先队列优化到 O(nmlog⁡n)\\mathcal{O}(nm\\log n)O(nmlogn)，不过好像没什么用。 这时大约过了一个小时，开始慌了，去开 T2，但发现 T2 压根就不会写，所以果断弃掉，去看 T3。 讲个笑话，这时我旁边同学的 Code::Blocks 死机了，他被卡了大概五分钟。 T3 写了 404040 分的暴力后就走人了，看了一眼 T4 发现题目很长，不敢开，就接着去搞 T1。 T1 的 404040 分做法想了好久，想到可以扫描每一架飞机看是否有空位，然后把答案加到对应的空位中，最后做一遍前缀和。 但满分做法始终想不出来，慌了，去上了第一趟厕所。 再讲个笑话，这时我旁边同学的 Code::Blocks 又死机了，他被卡了大概四分钟。 上完厕所接着回来搞 T1，发现不用扫描空位，可以用 nth_element 来找，但不知怎得调了好长时间都没有调出来，这时已经过去了三个小时，腿开始发抖，去上了第二趟厕所。 这时旁边同学的 Code::Blocks 又炸了，于是他换了 Windows（这是特例，正常我们这里只让用 NOILinux 物理机）。 又过了 151515 分钟 T1 终于把大样例过了，腿不再抖了，开始看 T4。 但是我没看懂 T4，于是把 T4 也给弃掉了。 我旁边同学的 Windows 也崩了，他的代码全丢了，默哀。 又去看 T3，感觉那个特殊情况可以搞一搞，想了个不知道是对是错的做法敲了上去。 又去看 T2，发现还是不会（ 于是 100+0+(40∼55)+0=140∼155100+0+(40\\sim 55)+0=140\\sim 155100+0+(40∼55)+0=140∼155 （剧情反转 感觉比去年难的多。 回来的路上新认识了一位同市的大佬 Cat_shao，聊得非常愉快（并第一次再归程中没有睡觉）。 然后他跟我说 nth_element 是线性复杂度，完，炸了。 所以我的分治是怎么学的啊…… 于是 40+0+(40∼55)+0=80∼9540+0+(40\\sim 55)+0=80\\sim 9540+0+(40∼55)+0=80∼95，我是傻逼。 赛后总结 问题还是很严重，一是做题做少了，导致题根本想不出来，以后需要狂刷题。 再者有些知识的理解还是有偏差，博客要勤写，写的时候对着文档或书保证正确性。 最后千万不要以为在弱省就很轻松，有的时候你进步的速度还没 CCF 题目变难的速度快。 可怜天下人啊…… 赛后 最后分数 606060，不说具体问什么了，接下来是一些总结，希望能帮助到我和大家。 首先是训练方式的问题。感觉大纲上的知识点都学得差不多，但考场上却也什么都不会，根本原因在于题刷的实在太少。比如 T1 的“扫描算法”，在《训练指南》中第一章的例题中出现过，统计前缀和的思路也在 Codeforces 的一场比赛中出现过（想这个路在考场上花了大量的时间）。再如 T3 深入分析 + 贪心，平时多做点题就不会再考场上凄惨的死亡。进考场之前充满信心，出来之后因自己对知识点的误解而信心满满地踏上了归程，以为自己得了 155155155 分，实际上就是个傻逼。这种态度，只能使自己消亡在历史长河之中。 所以，端正自己的态度吧，别再搞那些没用的了。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"LNOI2021 游记","slug":"summaries/游记/LNOI2021","date":"2021-04-10T00:00:00.000Z","updated":"2021-04-10T00:00:00.000Z","comments":false,"path":"1f5836f2/","link":"","permalink":"https://james1badcreeper.github.io/1f5836f2/","excerpt":"坐标：LN-DL。","text":"坐标：LN-DL。 Day ? 由于 NOIP 不理想的成绩，加上知道自己基本什么也不会，所以这次省选是抱着去玩的心态去的。 虽然口头说着是去玩，但是心里却有一种莫名的紧张，毕竟是第一次参加省选！ Day -1 这一天（周五）进校的时候发现课程表不对，外语为什么被调到了下午第 777 节课？（班主任是外语老师，而且第 888 节晚课（短达 909090 分钟）也是英语。 由于目前初二在读，学校是不可能给停课去训练 OI 的，中午自习时间就抱着李煜东的《算法竞赛进阶指南》翻来翻去地看，但实际上一个字也没看进去。 月考在两天前结束，上午听老师念了第一科出来的数学的分数，我仅考了 138138138 分，真的非常糟糕，虽然只有 5 分的题是真心不会（我真没想到转完那个直角三角形后要连四条线），步骤被扣了 777 分？ 中午我在发本。由于是弱省弱校，周围同学素质极差，中午有把苹果当成炸弹扔的，有打架的，有在讲台前踱来踱去地唱着歌的（雾）。 然而午间自习开始的时候老师叫我们坐好，弄得我摸不着头脑。 结果是，老师打算今天下午带我们去大连著名的星海公园去看著名的圣亚海洋世界！ 俗话说的真好，近处没有好看的风景…… 天哪，这是专门为我散心而准备的吗？ 所以留下了一些非常美好的回忆。我瞬间感觉对省选充满了信心。 一些回忆 嗯，这是《海豚湾之恋》，不过我记得以前是有海盗的，现在被删了qaq功 夫 海 象这里可是国家级的企鹅繁殖基地呢！闹 鬼 系 列（左边的同学名为“坦克”）这些是我们老师拍摄的照片，在此表示最崇高的敬意！ LNOI2021 加油！月考分在晚上全出来了：语文（83/100），数学（138/150），外语（131/140），物理（87/90），但是不知道年级排名…… Day 1 还好在大连大学考，否则周五下午的活动我就不能去了，需要请假赶往沈阳之类的地方。 等待的时候看到了许多神仙，除了一个 wmh 比我小，剩下都是高中生？感觉他们好厉害的样子（其实真的很厉害）。 进考场了！ 虽然题目要比我预想中的简单不少，但我还是什么也不会。 T1 拿了 202020 分的暴力滚蛋了。 T2 可能做出了 m=2 的情况拿了 303030 分，但由于感觉自己写的有点问题，所以也可能是 0 分。 T3 做了个 161616 分的暴力然后又滚蛋了。 Day 1 估分（最悲观）：20+0+16=3620 + 0 + 16 = 3620+0+16=36 嗯，我真菜。 Day 2 心 情 极 为 郁 闷。 T1 嗯，这题我不会，所以我选择直接打暴力，以为只有 101010 分的暴力竟然拿了 252525 分？ T2 嗯，这题我也不会。 而且好像连暴力也不会了（生成排名后不知道怎么判断是否成立），最后胡乱写上去了一个，预期得分 000 分。 T3 嗯，这题我还是不会。 （某人：你究竟会啥？） 而且连暴力也不会了qwq。 最后似乎搞出了这图是树的情况得了 151515 分（但也可能是错的），预期得分 000 分。 ∴\\therefore∴ Day2 估分为 10+0+0=1010+0+0=1010+0+0=10。 ∴\\therefore∴ 最后分数为 20+0+16+10+0+0=4620+0+16+10+0+0=4620+0+16+10+0+0=46。 你可以退役了，你这个松饼脑袋。——路人甲。 Day 4 月考班级排名 Rk2，年级 Rk4。 Day 6 or 7 最终分数为 102102102 （我也不知道为什么是这个分数，逃 但即使比预期的高了不少，排名依然是垫底，在后 10%10\\%10% 的位置。 唉，还是太菜了，但没关系，明年接着来！ 不管怎样，我一定要变强。 我估计你明年还是倒数，你这个松饼脑袋。——路人甲。","categories":[{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]}],"categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"做题记录","slug":"算法竞赛/做题记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"加训","slug":"算法竞赛/做题记录/加训","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8A%A0%E8%AE%AD/"},{"name":"文章","slug":"文章","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/"},{"name":"记录","slug":"文章/记录","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E8%AE%B0%E5%BD%95/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"NOI 复习","slug":"算法竞赛/学习笔记/NOI-复习","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NOI-%E5%A4%8D%E4%B9%A0/"},{"name":"比赛记录","slug":"算法竞赛/比赛记录","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"},{"name":"Codeforces","slug":"算法竞赛/做题记录/Codeforces","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/Codeforces/"},{"name":"ATCoder","slug":"算法竞赛/做题记录/ATCoder","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ATCoder/"},{"name":"ICPC","slug":"算法竞赛/做题记录/ICPC","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/ICPC/"},{"name":"闲话","slug":"闲话","permalink":"https://james1badcreeper.github.io/categories/%E9%97%B2%E8%AF%9D/"},{"name":"JOI","slug":"算法竞赛/做题记录/JOI","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/JOI/"},{"name":"闲话","slug":"文章/闲话","permalink":"https://james1badcreeper.github.io/categories/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%AF%9D/"},{"name":"动态规划","slug":"算法竞赛/学习笔记/动态规划","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数据结构","slug":"算法竞赛/学习笔记/数据结构","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"算法竞赛/学习笔记/图论","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"},{"name":"数学","slug":"算法竞赛/学习笔记/数学","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"},{"name":"字符串","slug":"算法竞赛/学习笔记/字符串","permalink":"https://james1badcreeper.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://james1badcreeper.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"做题记录","slug":"做题记录","permalink":"https://james1badcreeper.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"游记","slug":"游记","permalink":"https://james1badcreeper.github.io/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://james1badcreeper.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"闲话","slug":"闲话","permalink":"https://james1badcreeper.github.io/tags/%E9%97%B2%E8%AF%9D/"},{"name":"数学","slug":"数学","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"群论","slug":"群论","permalink":"https://james1badcreeper.github.io/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"博弈论","slug":"博弈论","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"单调队列","slug":"单调队列","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"wqs 二分","slug":"wqs-二分","permalink":"https://james1badcreeper.github.io/tags/wqs-%E4%BA%8C%E5%88%86/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://james1badcreeper.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"},{"name":"四边形不等式","slug":"四边形不等式","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/"},{"name":"数据结构优化","slug":"数据结构优化","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/"},{"name":"分块","slug":"分块","permalink":"https://james1badcreeper.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"数据结构f","slug":"数据结构f","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84f/"},{"name":"数论","slug":"数论","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"可持久化","slug":"可持久化","permalink":"https://james1badcreeper.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"树套树","slug":"树套树","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"},{"name":"图论","slug":"图论","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"动态规划","slug":"动态规划","permalink":"https://james1badcreeper.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数据结构","slug":"数据结构","permalink":"https://james1badcreeper.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","permalink":"https://james1badcreeper.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"Treap","slug":"Treap","permalink":"https://james1badcreeper.github.io/tags/Treap/"},{"name":"Splay","slug":"Splay","permalink":"https://james1badcreeper.github.io/tags/Splay/"},{"name":"FHQ-Treap","slug":"FHQ-Treap","permalink":"https://james1badcreeper.github.io/tags/FHQ-Treap/"},{"name":"组合数学","slug":"组合数学","permalink":"https://james1badcreeper.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"多项式","slug":"多项式","permalink":"https://james1badcreeper.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"网络流","slug":"网络流","permalink":"https://james1badcreeper.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"提交答案","slug":"提交答案","permalink":"https://james1badcreeper.github.io/tags/%E6%8F%90%E4%BA%A4%E7%AD%94%E6%A1%88/"},{"name":"交互题","slug":"交互题","permalink":"https://james1badcreeper.github.io/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/"},{"name":"构造","slug":"构造","permalink":"https://james1badcreeper.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"随机化","slug":"随机化","permalink":"https://james1badcreeper.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"},{"name":"字符串","slug":"字符串","permalink":"https://james1badcreeper.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"刷","slug":"刷","permalink":"https://james1badcreeper.github.io/tags/%E5%88%B7/"},{"name":"Div.2","slug":"Div-2","permalink":"https://james1badcreeper.github.io/tags/Div-2/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://james1badcreeper.github.io/tags/Codeforces/"},{"name":"比赛","slug":"比赛","permalink":"https://james1badcreeper.github.io/tags/%E6%AF%94%E8%B5%9B/"},{"name":"并查集","slug":"并查集","permalink":"https://james1badcreeper.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"ATCoder","slug":"ATCoder","permalink":"https://james1badcreeper.github.io/tags/ATCoder/"},{"name":"线段树","slug":"线段树","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树形 DP","slug":"树形-DP","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E5%BD%A2-DP/"},{"name":"图上 DP","slug":"图上-DP","permalink":"https://james1badcreeper.github.io/tags/%E5%9B%BE%E4%B8%8A-DP/"},{"name":"生成树","slug":"生成树","permalink":"https://james1badcreeper.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"概率","slug":"概率","permalink":"https://james1badcreeper.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"期望","slug":"期望","permalink":"https://james1badcreeper.github.io/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"线性代数","slug":"线性代数","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://james1badcreeper.github.io/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://james1badcreeper.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"状压 DP","slug":"状压-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%8A%B6%E5%8E%8B-DP/"},{"name":"树","slug":"树","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91/"},{"name":"LCA","slug":"LCA","permalink":"https://james1badcreeper.github.io/tags/LCA/"},{"name":"树的直径","slug":"树的直径","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"树的重心","slug":"树的重心","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"树上差分","slug":"树上差分","permalink":"https://james1badcreeper.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"},{"name":"最短路","slug":"最短路","permalink":"https://james1badcreeper.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"差分约束","slug":"差分约束","permalink":"https://james1badcreeper.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"线性 DP","slug":"线性-DP","permalink":"https://james1badcreeper.github.io/tags/%E7%BA%BF%E6%80%A7-DP/"},{"name":"区间 DP","slug":"区间-DP","permalink":"https://james1badcreeper.github.io/tags/%E5%8C%BA%E9%97%B4-DP/"},{"name":"背包","slug":"背包","permalink":"https://james1badcreeper.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"双指针","slug":"双指针","permalink":"https://james1badcreeper.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"前缀和","slug":"前缀和","permalink":"https://james1badcreeper.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"https://james1badcreeper.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"单调栈","slug":"单调栈","permalink":"https://james1badcreeper.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"找规律","slug":"找规律","permalink":"https://james1badcreeper.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"解题","slug":"解题","permalink":"https://james1badcreeper.github.io/tags/%E8%A7%A3%E9%A2%98/"},{"name":"Div.4","slug":"Div-4","permalink":"https://james1badcreeper.github.io/tags/Div-4/"}]}